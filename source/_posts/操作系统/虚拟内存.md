---
title: 虚拟内存
tags:
  - 操作系统
categories:
  - 操作系统
abbrlink: f79e4123
date: 2018-09-21 14:42:00
---
# 虚拟内存

### 概述

1. 虚拟内存是什么、可以用来做什么
2. 基本概念介绍
3. 虚拟内存作为缓存的工具
4. 虚拟内存作为内存管理的工具
5. 虚拟内存作为内存保护的工具

### 1. 虚拟内存是什么、功能是什么

**虚拟内存是什么**

**虚拟内存**是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

下面是《深入立即操作系统》给出的定义：

> 为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。

并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。

虚拟内存功能是什么

1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。
2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。
3. 它保护了每个进程的地址空间不被其他进程破坏。

<!-- more -->

### 2.基本概念介绍

#### 物理地址、虚拟地址

虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：

![物理寻址](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg)

主存的每个地址都是唯一的，第一个字节地址为0，接下来为1，以此类推。CPU使用这种访问方式就是**物理寻址**。上图所示就是CPU通过**地址总线**传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。

当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：

![img](upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp)



使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。

我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。

#### 地址空间

地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。

### 3. 虚拟内存作为缓存的工具

**虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。**

从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块(block)，这些块作为和主存(较高层)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。

在任意时刻，虚拟页面都分为三个不相交的部分：

- **未分配的(Unallocated)**：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。
- **缓存的(Cached)**：当前已缓存在物理内存中的已分配页。
- **未缓存的(UnCached)**：该页已经映射到磁盘上了，但是还没缓存在物理内存中。

> 其中**未分配的VP**不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射，毕竟程序不可能实际使用那么大的地址空间。

![](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png)

图13：VM使用主存来作为缓存

上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。

> 当然，那个图上标注的不对,VP 部分， `n-p`和`N-1`应该分别标注为`3`和`7`,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。

### 参考

[什么是虚拟内存](https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-3/virtual_mem_managment.html)

[《深入理解计算机系统》| 虚拟存储器](https://www.jianshu.com/p/e1b82b230917)

[什么是内存(二)：虚拟内存](https://www.cnblogs.com/yaoxiaowen/p/7805964.html)