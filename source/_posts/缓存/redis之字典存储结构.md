---
title: redis之字典存储结构
abbrlink: 51730
date: 2022-04-19 22:29:30
updated: 2022-04-19 22:29:30
tags:
    - redis
categories:
    - 缓存
---

字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽 象数据结构。 在字典中，一个键（key）可以和一个值（value）进行关联（或者 说将键映射为值），这些关联的键和值就称为键值对。 字典中的每个键都是独一无二的，程序可以在字典中根据键查找与 之关联的值，或者通过键来更新值，又或者根据键来删除整个键值对， 等等。

字典经常作为一种数据结构内置在很多高级编程语言里面，但 Redis所使用的C语言并没有内置这种数据结构，因此Redis构建了自己 的字典实现。 字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典 来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典 的操作之上的。

<!-- more -->

## 字典的实现

Redis字典所使用的哈希表由dict.h/dictht结构定义：

```c
typedef struct dictht { 
    // 哈希表数组 
    dictEntry **table; 

    // 哈希表大小 
    unsigned long size; 

    // 哈希表大小掩码，用于计算索引值
     // 总是等于size-1 
     unsigned long sizemask; 

     // 该哈希表已有节点的数量 
     unsigned long used; 
} dictht;
```

table属性是一个数组，数组中的每个元素都是一个指向 dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size 属性记录了哈希表的大小，也即是table数组的大小，而used属性则记录了哈希表目前已有节点（键值对）的数量。sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个 索引上面。
下图是一个具体的例子
![具体实现](https://cdn.jsdelivr.net/gh/fengxiu/img/20220419223309.png)

**哈希表节点**
哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一 个键值对：

```c
typedef struct dictEntry { 
    // 键 
    void *key; 
    // 值 
    union{
        void *val; 
        uint64_tu64; 
        int64_ts64; 
    } v;
     // 指向下个哈希表节点，形成链表 
     struct dictEntry *next; 
} dictEntry;
```

key属性保存着键值对中的键，而v属性则保存着键值对中的值，其 中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一 个int64_t整数。 next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。

具体的例子如下
![具体例子](https://cdn.jsdelivr.net/gh/fengxiu/img/20220419223628.png)

**字典**

Redis中的字典由dict.h/dict结构表示：

```c
typedef struct dict { 
// 类型特定函数 
dictType *type; 
// 私有数据
void *privdata; 
// 哈希表
dictht ht[2]; 
// rehash 索引
//当rehash 不在进行时，值为-1 
rehashidx; 
/* rehashing not in progress if rehashidx== -1 */
} dict;
```

未进行rehash下的具体实例
![](https://cdn.jsdelivr.net/gh/fengxiu/img/20220419224017.png)

## hash算法

当要将一个新的键值对添加到字典里面时，程序需要先根据键值对 的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈 希表节点放到哈希表数组的指定索引上面。

Redis计算哈希值和索引值的方法如下：

```c
// 使用字典设置的哈希函数，计算键key的哈希值 
hash = dict->type->hashFunction(key); 
//使用哈希表的sizemask 属性和哈希值，计算出索引值 #根据情况不同，ht[x] 可以是ht[0] 或者ht[1] index = hash & dict->ht[x].sizemask;
```

当字典被用作数据库的底层实现，或者哈希键的底层实现时 Redis使用MurmurHash2算法来计算键的哈希值。 MurmurHash算法最初由Austin Appleby于2008年发明，这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。 MurmurHash算法目前的最新版本为MurmurHash3，而Redis使用的 是MurmurHash2，关于MurmurHash算法的更多信息可以参考该算法的 
主页：http://code.google.com/p/smhasher/。

## 解决键冲突

当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面 时，我们称这些键发生了冲突（collision）。 Redis的哈希表使用链地址法（separate chaining）来解决键冲突， 每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。

补充一点，hash的解决方式不知上面一种，具体的**hash冲突的解决方式**可以参考这篇文章[解决哈希冲突的常用方法分析](https://cloud.tencent.com/developer/article/1672781)

## rehash

随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减 少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的 大小进行相应的扩展或者收缩。 扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下： 

1. 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于 要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性 的值）：
   1. 如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于 ht[0].used*2的2 n（2的n次方幂）；
   2. 如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于 ht[0].used的2 n。 
2. 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是 重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定 位置上。
3. 当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。

**哈希表的扩展与收缩**

当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行 扩展操作：

1. 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。 
2. 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命 令，并且哈希表的负载因子大于等于5

负载因子的计算公式

```C
// 负载因子= 哈希表已保存节点数量/ 哈希表大小 load_factor
load_factor = ht[0].used / ht[0].size
```

根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器 执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子 进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化 子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操 作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩 展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。
另一方面，当哈希表的负载因子小于0.1时，程序自动开始对哈希 表执行收缩操作。

## 渐进式rehash

上一节说过，扩展或收缩哈希表需要将ht[0]里面的所有键值对 rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成 的，而是分多次、渐进式地完成的。 这样做的原因在于，如果ht[0]里只保存着四个键值对，那么服务器可以在瞬间就将这些键值对全部rehash到ht[1]；但是，如果哈希表里保存的键值对数量不是四个，而是四百万、四千万甚至四亿个键值对，那 么要一次性将这些键值对全部rehash到ht[1]的话，庞大的计算量可能会 导致服务器在一段时间内停止服务。 因此，为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1]，而是分多次、渐进式地将 ht[0]里面的键值对慢慢地rehash到ht[1]。 
以下是哈希表渐进式rehash的详细步骤： 

1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。 
2. 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。 
3. 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。
4. 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。

渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式rehash而带来的庞大计算量。

**渐进式rehash执行期间的哈希表操作**
因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两 个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找 （find）、更新（update）等操作会在两个哈希表上进行。例如，要在 字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到 的话，就会继续到ht[1]里面进行查找，诸如此类。 另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被 保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了 ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变 成空表。

## 总结

1. 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希 键。
2. Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。
3. 当字典被用作数据库的底层实现，或者哈希键的底层实现时， Redis使用MurmurHash2算法来计算键的哈希值。
4. 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多 个键值对会连接成一个单向链表。
5. 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一 次性地完成的，而是渐进式地完成的。