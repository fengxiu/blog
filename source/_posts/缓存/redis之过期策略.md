---
title: post
date: 2022-04-21 23:38:43
updated: 2022-04-21 23:38:43
tags:
    - redis
categories:
    - 缓存
---

Redis有四个不同的命令可以用于设置键的生存时间（键可以存在 多久）或过期时间（键什么时候会被删除）：

* `EXPIRE <key> <ttl>`命令用于将键key的生存时间设置为ttl秒。
* `PEXPIRE <key> <ttl>`命令用于将键key的生存时间设置为ttl毫秒。
* `EXPIREAT <key> <timestamp>`命令用于将键key的过期时间设置为 timestamp所指定的秒数时间戳。
* `PEXPIREAT <key> <timestamp>`命令用于将键key的过期时间设置为 timestamp所指定的毫秒数时间戳。

虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、 PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的： 无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行PEXPIREAT命令一样。

![设置过期时间](https://raw.githubusercontent.com/fengxiu/img/master/20220421234049.png)

<!-- more -->

**保存过期时间**
redis数据库使用字典保存了数据库中所有键的过期时间，称这个字典为过期字典：

* 过期字典的键是一个指针，这个指针指向键空间中的某个键对象 （也即是某个数据库键）。
* 过期字典的值是一个long long类型的整数，这个整数保存了键所指 向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。

**移除过期时间**
PERSIST命令可以移除一个键的过期时间，PERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期 字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。

**计算并返回剩余生存时间**
TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间。

**过期键的判定**
通过过期字典，程序可以用以下步骤检查一个给定键是否过期：

1. 检查给定键是否存在于过期字典：如果存在，那么取得键的过 期时间。
2. 检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那 么键已经过期；否则的话，键未过期。

## 过期删除策略

目前有的过期删除策略有以下三种

* 定时删除：在设置键的过期时间的同时，创建一个定时器 （timer），让定时器在键的过期时间来临时，立即执行对键的删除操 作。
* 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期， 就返回该键。
* 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

在这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略。

**定时删除策略**对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。 
另一方面，定时删除策略的缺点是，它对CPU时间是最不友好的： 在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响前不缺少内存，那么服务器应该优先将CPU时间用在处理客户端的命令请求上面，而不是用在删除过期键上面。

 除此之外，创建一个定时器需要用到Redis服务器中的时间事件， 而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度 为O（N）——并不能高效地处理大量时间事件。 因此，要让服务器创建大量的定时器，从而实现定时删除策略，在 现阶段来说并不现实。

 **惰性删除**策略对CPU时间来说是最友好的：程序只会在取出键时才 对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情 况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除 其他无关的过期键上花费任何CPU时间。 惰性删除策略的缺点是，它对内存是最不友好的：如果一个键已经 过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删 除，它所占用的内存就不会释放。 在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些 过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除 非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存，而服务器却不会自己去 释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。

 **定期删除**从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷：

 * 定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。
 * 惰性删除浪费太多内存，有内存泄漏的危险。
  
定期删除策略是前两种策略的一种整合和折中：

* 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。
* 除此之外，通过定期删除过期键，定期删除策略有效地减少了因 为过期键而带来的内存浪费。


定期删除策略的难点是确定删除操作执行的时长和频率： 

* 如果删除操作执行得太频繁，或者执行的时间太长，定期删除策 略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期 键上面。
* 如果删除操作执行得太少，或者执行的时间太短，定期删除策略 又会和惰性删除策略一样，出现浪费内存的情况。 因此，如果采用定期删除策略的话，服务器必须根据情况，合理地 设置删除操作的执行时长和执行频率。

### Redis的过期键删除策略

Redis服务器实际使用的是惰性删除和定期删除两种策略： 通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间 和避免浪费内存空间之间取得平衡。