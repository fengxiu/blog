---
title: redis之持久化与主从复制
abbrlink: 20736
tags:
  - redis
categories:
  - 缓存
date: 2022-04-24 19:57:58
updated: 2022-04-24 19:57:58
---

Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。 为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。

通过持久化可以减少服务器重启后数据的丢失，但是当服务器出现故障时，会导致缓存不可用，因此这时就需要多台服务器同时服务，从而避免单台服务器故障引起的服务不可用问题，同时带来的问题就是如何保持多台服务器数据一致，也就是本文要介绍的第二个主题，主从复制。

<!-- more -->

## 持久化

Redis提供了RDB和AOF两种不同的数据持久化方式，下面会介绍俩种模式时如何工作的，接着总结如何选择持久化模式。

### RDB

RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。

**开启RDB持久化方式**
开启RDB持久化方式很简单，客户端可以通过向Redis服务器发送save或bgsave命令让服务器生成rdb文件，或者通过服务器配置文件指定触发RDB条件。

**save命令**
save命令是一个同步操作。

当客户端向服务器发送save命令请求进行持久化时，服务器会阻塞save命令之后的其他客户端的请求，直到数据同步完成。如果数据量太大，同步数据会执行很久，而这期间Redis服务器也无法接收其他请求，所以，最好不要在生产环境使用save命令。

![save](https://cdn.jsdelivr.net/gh/fengxiu/img/20220424205800.png)

**bgsave**

与save命令不同，bgsave命令是一个异步操作。

![bgsave](https://cdn.jsdelivr.net/gh/fengxiu/img/20220424205901.png)

当客户端发服务发出bgsave命令时，Redis服务器主进程会forks一个子进程来数据同步问题，在将数据保存到rdb文件之后，子进程会退出。

所以，与save命令相比，Redis服务器在处理bgsave采用子线程进行IO写入，而主进程仍然可以接收其他请求，但forks子进程是同步的，所以forks子进程时，一样不能接收其他请求，这意味着，如果forks一个子进程花费的时间太久(一般是很快的)，bgsave命令仍然有阻塞其他客户的请求的情况发生。

**服务器配置自动触发**
除了通过客户端发送命令外，还有一种方式，就是在Redis配置文件中的save指定到达触发RDB持久化的条件，比如【多少秒内至少达到多少写操作】就开启RDB数据同步。

例如我们可以在配置文件redis.conf指定如下的选项：

```text
# 900s内至少达到一条写命令
save 900 1
# 300s内至少达至10条写命令
save 300 10
# 60s内至少达到10000条写命令
save 60 10000
之后在启动服务器时加载配置文件。

# 启动服务器加载配置文件
redis-server redis.conf
```

这种通过服务器配置文件触发RDB的方式，与bgsave命令类似，达到触发条件时，会forks一个子进程进行数据同步，不过最好不要通过这方式来触发RDB持久化，因为设置触发的时间太短，则容易频繁写入rdb文件，影响服务器性能，时间设置太长则会造成数据丢失。

**rdb文件**

前面介绍了三种让服务器生成rdb文件的方式，无论是由主进程生成还是子进程来生成，其过程如下：

1. 生成临时rdb文件，并写入数据。
2. 完成数据写入，用临时文代替代正式rdb文件。
3. 删除原来的db文件。

RDB默认生成的文件名为dump.rdb，当然，我可以通过配置文件进行更加详细配置，比如在单机下启动多个redis服务器进程时，可以通过端口号配置不同的rdb名称，如下所示：

```text
# 是否压缩rdb文件
rdbcompression yes

# rdb文件的名称
dbfilename redis-6379.rdb

# rdb文件保存目录
dir ~/redis/
```
**RDB的几个优点**

* 与AOF方式相比，通过rdb文件恢复数据比较快。
* rdb文件非常紧凑，适合于数据备份。
* 通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。

**RDB的几个缺点**

* 如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。
* 使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。
* 使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。


### AOF

聊完了RDB，来聊聊Redis的另外一个持久化方式：AOF(Append-only file)。
与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。

![aof](https://cdn.jsdelivr.net/gh/fengxiu/img/20220424210544.png)

**开启AOF持久化方式**
Redis默认不开启AOF持久化方式，我们可以在配置文件中开启并进行更加详细的配置，如下面的redis.conf文件：

```
# 开启aof机制
appendonly yes

# aof文件名
appendfilename "appendonly.aof"

# 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec或no
appendfsync always

# 默认不重写aof文件
no-appendfsync-on-rewrite no

# 保存目录
dir ~/redis/
```

**三种写入策略**
在上面的配置文件中，我们可以通过appendfsync选项指定写入策略，有三个选项。

```
appendfsync always
# appendfsync everysec
# appendfsync no
```

1. always：客户端的每一个写操作都保存到aof文件当，这种策略很安全，但是每个写请注都有IO操作，所以也很慢。
2. everysec：appendfsync的默认写入策略，每秒写入一次aof文件，因此，最多可能会丢失1s的数据。
3. no：redis服务器不负责写入aof，而是交由操作系统来处理什么时候写入aof文件。更快，但也是最不安全的选择，不推荐使用。

**AOF文件重写**
AOF将客户端的每一个写操作都追加到aof文件末尾，比如对一个key多次执行incr命令，这时候，aof保存每一次命令到aof文件中，aof文件会变得非常大。

```
incr num 1
incr num 2
incr num 3
incr num 4
incr num 5
incr num 6
...
incr num 100000
```

aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决这个问题，Redis支持aof文件重写，通过重写aof，可以生成一个恢复当前数据的最少命令集，比如上面的例子中那么多条命令，可以重写为：

```
set num 100000
```

aof文件是一个二进制文件，并不是像上面的例子一样，直接保存每个命令，而使用Redis自己的格式，上面只是方便演示。

**两种重写方式**
通过在redis.conf配置文件中的选项no-appendfsync-on-rewrite可以设置是否开启重写，这种方式会在每次fsync时都重写，影响服务器性以，因此默认值为no，不推荐使用。

```
# 默认不重写aof文件
no-appendfsync-on-rewrite no
```

客户端向服务器发送bgrewriteaof命令，也可以让服务器进行AOF重写。
```
# 让服务器异步重写追加aof文件命令
> bgrewriteaof
```

![重写](https://cdn.jsdelivr.net/gh/fengxiu/img/20220424210838.png)

重写aof文件的好处

* 压缩aof文件，减少磁盘占用量。
* 将aof的命令压缩为最小命令集，加快了数据恢复的速度。

AOF文件损坏

在写入aof日志文件时，如果Redis服务器宕机，则aof日志文件文件会出格式错误，在重启Redis服务器时，Redis服务器会拒绝载入这个aof文件，可以通过以下步骤修复aof并恢复数据。

备份现在aof文件，以防万一。

使用redis-check-aof命令修复aof文件，该命令格式如下：

```java
# 修复aof日志文件
$ redis-check-aof -fix file.aof
```

重启Redis服务器，加载已经修复的aof文件，恢复数据。

**AOF的优点**

AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。

**AOF的缺点**

* AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。
* 恢复数据的速度比RDB慢。


### 选择RDB还是AOF呢？

通过上面的介绍，我们了解了RDB与AOF各自的优点与缺点，到底要如何选择呢？

通过下面的表示，我们可以从几个方面对比一下RDB与AOF,在应用时，要根本自己的实际需求，选择RDB或者AOF，其实，如果想要数据足够安全，可以两种方式都开启，但两种持久化方式同时进行IO操作，会严重影响服务器性能，因此有时候不得不做出选择。

![](https://cdn.jsdelivr.net/gh/fengxiu/img/20220424211136.png)

当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。

## 复制

### 旧版复制

Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作： 
* 同步操作用于将从服务器的数据库状态更新至主服务器当前所处 的数据库状态。 
* 命令传播操作则用于在主服务器的数据库状态被修改，导致主从 服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态

**同步详细介绍**
当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，将从服务器的数据 库状态更新至主服务器当前所处的数据库状态。 从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤： 

1. 从服务器向主服务器发送SYNC命令。
2. 收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。 
3. 当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时 的数据库状态。 
4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器， 从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态

![](https://cdn.jsdelivr.net/gh/fengxiu/img/20220424211617.png)


**命令传播** 
在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态 不再一致。

为了让主从服务器再次回到一致状态，主服务器需要对从服务器执 行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服 务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相 同的写命令之后，主从服务器将再次回到一致状态。

#### 缺陷

在Redis中，从服务器对主服务器的复制可以分为以下两种情况： 

* 初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。 
* 断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。 

对于初次复制来说，旧版复制功能能够很好地完成任务，但对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低。

**SYNC命令是一个非常耗费资源的操作**
每次执行SYNC命令，主从服务器需要执行以下动作： 
1）主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。 
2）主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响。 
3）接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。

因为SYNC命令是一个如此耗费资源的操作，所以Redis有必要 保证在真正有需要时才执行SYNC命令

### 新版复制

为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作。 PSYNC命令具有完整重同步（full resynchronization）和部分重同步 （partial resynchronization）两种模式： 

* 其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发 送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。
* 而部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这 些写命令，就可以将数据库更新至主服务器当前所处的状态。 

PSYNC命令的部分重同步模式解决了旧版复制功能在处理断线后重复制时出现的低效情况，下图展示了如何使用PSYNC命令高效地处理上一节展示的断线后复制情况。 

![](https://cdn.jsdelivr.net/gh/fengxiu/img/20220424212355.png)

#### 部分重同步的实现

在了解了PSYNC命令的由来，以及部分重同步的工作方式之后，是时候来介绍一下部分重同步的实现细节了。 部分重同步功能由以下三个部分构成： 

* 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。
* 主服务器的复制积压缓冲区（replication backlog）。 
* 服务器的运行ID（run ID）。 

**复制偏移量**
执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量：

* 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。 
* 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。

![](https://cdn.jsdelivr.net/gh/fengxiu/img/20220424212613.png)
![](https://cdn.jsdelivr.net/gh/fengxiu/img/20220424212637.png)

**复制积压缓冲区**
复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。
当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面，如图15-10所示
![](https://cdn.jsdelivr.net/gh/fengxiu/img/20220424212840.png)
因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量，
![](https://cdn.jsdelivr.net/gh/fengxiu/img/20220424212930.png)
当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作： 

* 如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作。 
* 相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。 

Redis为复制积压缓冲区设置的默认大小为1MB，如果主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间比较长，那么这个大小也许并不合适。如果复制积压缓冲区的大 小设置得不恰当，那么PSYNC命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要。

复制积压缓冲区的最小大小可以根据公式 `second*write_size_per_second`来估算： 

其中second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）。而write_size_per_second则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）。

为了安全起见，可以将复制积压缓冲区的大小设为 2*second*write_size_per_second，这样可以保证绝大部分断线情况 都能用部分重同步来处理。 至于复制积压缓冲区大小的修改方法，可以参考配置文件中关 于repl-backlog-size选项的说明。

**服务器运行ID**

除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行ID（run ID）： 

* 每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID。
* 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。 

当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来。 

当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID： 

如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器， 主服务器可以继续尝试执行部分重同步操作。 

相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。

**PSYNC命令**

调用方法有两种： 
* 如果从服务器以前没有复制过任何主服务器，或者之前执行过`SLAVEOF no one`命令，那么从服务器在开始一次新的复制时将向主服务器发送`PSYNC ? -1`命令，主动请求主服务器进行完整重同步（因为这时不可能执行部分重同步）。 
* 相反地，如果从服务器已经复制过某个主服务器，那么从服务器 在开始一次新的复制时将向主服务器发送`PSYNC <runid> <offset>`命 令：其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作。 根据情况，接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种： 
	- 如果主服务器返回`+FULLRESYNC <runid> <offset>`回复，那么表示主服务器将与从服务器执行完整重同步操作：其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量。 
	- 如果主服务器返回+CONTINUE回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了。 
	- 如果主服务器返回-ERR回复，那么表示主服务器的版本低于Redis 2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令， 并与主服务器执行完整同步操作

![](https://cdn.jsdelivr.net/gh/fengxiu/img/20220424213916.png)

## 参考

1. [十分钟彻底理解 Redis 的持久化和主从复制](https://mp.weixin.qq.com/s?__biz=MzU1OTg0MzMwOQ==&mid=2247485453&idx=1&sn=620e0f1b682cf94c17ed2587281b819f&chksm=fc105a8fcb67d39923cc5b669edc93e0adcf9e95d39c8fdad7b040ba212e568ce227b183c15b&scene=132#wechat_redirect)
