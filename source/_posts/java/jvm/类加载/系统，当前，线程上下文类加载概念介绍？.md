---
title: 系统，当前，线程上下文类加载概念介绍？
abbrlink: '338e9034'
categories:
  - java
  - jvm
  - 类加载
tags:
  - 类加载
date: 2019-07-02 13:25:00
---
## 概念区分
在Java进行类加载时，一般会有多个ClassLoader可以使用，包括当前类加载器，制定类加载器，上下文类加载器三个，可以用多种方式进行类型加载，以下面这段代码来对这个三个概念进行说明：
<!-- more -->
``` java
class A{
    public void m(){
        A.class.getClassLoader().loaClass("B");
    }
}
```
上面的代码很简单，主要是为了说明下面三个概念：
* CurrentClassLoader，称之为当前类加载器，简称CCL：在上面的代码中对应的就是类型A的类加载器。
* SpecificClassLoader，称之为指定类加载器，简称SCL：在代码中对应的是`A.class.getClassLoader()`，如果使用任意的ClassLoader进行加载，这个ClassLoader都可以称之为SCL。
* ThreadContextClassLoader，称之为线程上下文类加载器，简称TCCL：每个线程都可以通过`Thread.currentThread().setContextClassLoader(ClassLoader)`来进行切换。
  
SCL和TCCL都可以理解为在代码中使用CLassLoader的引用进行类加载，我们可以自定义。但是CCL的加载过程是由JVM运行时来控制的，是无法通过Java编程来更改的。
<!-- more -->

## 系统、当前、线程上下文类加载器，该如何使用？
这个问题虽然不经常问到，但是这个问题却很难有一个正确的答案。一般来说，这个问题都来自于框架编程过程中需要动态的加载资源。一般来说，加载一个资源的时候，你会有至少三个CLassLoader可以用来加载资源，系统ClassLoader（AppClassLoader），当前CLassLoader和线程上下文ThreadContextClassLoader。如何去选择使用哪个CLassLoader呢？
首先应该被排除掉的应该是系统ClassLoader，这个就是main的入口，通过载入`-classPath`的资源来加载类，这段代码是从sun.mis.Launcher.AppClassLoader中摘抄：
``` java
public static ClassLoader getAppClassLoader(final ClassLoader var0) 
    throws IOException {

    final String var1 = System.getProperty("java.class.path");
    final File[] var2 = var1 == null ? new File[0] : Launcher.getClassPath(var1);
    return (ClassLoader)AccessController.doPrivileged(new PrivilegedAction<Launcher.AppClassLoader>() {
        public Launcher.AppClassLoader run() {
            URL[] var1x = var1 == null ? new URL[0] : Launcher.pathToURLs(var2);
            return new Launcher.AppClassLoader(var1x, var0);
        }
    });
}
```
其实AppClassLoader继承了URLClassLoader，它所做的工作，就是将java.class.path下的资源，转换为URL，然后加入到AppClassLoader中，除此没有别的特殊的地方。

能够通过静态方法`ClassLoader.getSystemClassLoader()`来获取到这个AppClassLoader。一般来说非常少的需求，需要获取到AppClassLoader，然后用它来加载一个类，因为都会使用其他的ClassLoader来加载类，并通过委派的方式到达AppClassLoader。

如果你编写的程序运行在ClassLoader是AppClassLoader的情况下，那么你的程序就只能在命令行下运行，因为你的程序需要依赖均在classpath下设置好，而如果将程序直接部署在WebApp容器中，那么肯定会出问题。

接下来，只有两个选择了，当前ClassLoader和线程上下文ClassLoader，以下简称：CurrentClassLoader（CCL）和ThreadContextClassLoader（TCCL）。
### 当前类加载器
 这里简单介绍一下这个仿佛看不到的CurrentClassLoader是如何出现的。 在如下这段代码中：
``` java
class A {
     public void m() {
          B b = new B();
     }
}
``` 
B是如何加载的呢？其实等值于`A.class.getClassLoader().loadClass(“B”)`;通过这种方式获取到B的类型。 那么如果是这段代码：
``` java
class A {
     public void m() {
          Class<?> clazz = B.class;
     }
}
```
上面加载B的Class，相当于`Class.forName("B")`，而进入`Class.forName()`方法后，后续的载入会利用`Class.class.getClassLoader().loadClass(“B”)`，也就是利用bootstrap来载入B，但是事实上还是利用载入A的ClassLoader，也就是CurrentClassLoader来载入B，看一下Class.forName的实现：
``` java
public static Class<?> forName(String className)
                throws ClassNotFoundException {
    return forName0(className, true, ClassLoader.getClassLoader(Reflection.getCallerClass()));
}
```
Class.forName运作时，通过Reflection.getCallerClass()，能够获取是谁调用了`Class.forName`，这时 `ClassLoader.getClassLoader()`返回的就是当前ClassLoader，这就符合原有含义了。可以通过观察，通过Java的rt.jar中的API，返回给客户端时，都是使用了获取调用者的ClassLoader的特性，因为在rt.jar中，是无法找到自定义类型的。

通过`Reflection.getCallerClass()`可以获取到调用`Class.forName`的类的ClassLoader，从而虽然中间涉及到了bootstrap加载的类（Class），但是依旧能够维护**当前**这个语义。

Java自身除了通过`Reflection.getCallerClass`来获取调用的类的类型，在deSerialization中也需要知道类型的信息。在序列化后的内容中，已经包含了当前用户自定义类的类型信息，那么如何在ObjectInputStream调用中，能够拿到客户端的类型呢？通过调用Class.forName？肯定不可以，因为在ObjectInputStream中调用这个，会使用bootstrap来加载，那么它肯定加载不到所需要的类。

答案是通过查询栈信息，通过`sun.misc.VM.latestUserDefinedLoader()`; 获取从栈上开始计算，第一个不为空（bootstrap classloader是空）的ClassLoader便返回。

可以试想，在ObjectInputStream运作中，通过直接获取当前调用栈中，第一个非空的ClassLoader，这种做法能够非常便捷的定位用户的ClassLoader，也就是用户在进行：
``` java
ObjectInputStream ois = new ObjectInputStream(new FileInputStream(“xx.dat”));
B b = (B) ois.readObject();
```
这种调用的时候，依旧能够通过**当前**的ClassLoader正确的加载用户的类。

可以说`Reflection.getCallerClass`和`sun.misc.VM.latestuserDefinedLoader`都是用来突破双亲委派模型的一种解决方式，它能让Java在bootstrap加载的代码中运行时，能够获取到外界（用户）使用的子ClassLoader。
### 线程上下文类加载器
ThreadContextClassLoader是作为Thread的一个成员变量出现的，一个线程在构造的时候，它会从parent线程中继承这个ClassLoader，但是Java的文档中对这个ClassLoader描述非常有限，但是它对于理解JNDI以及JAXP等技术有非常大的帮助，不过它是应用服务器，或者框架需要特别关注的一种ClassLoader。

在介绍CurrentClassLoader中，已经说明它用来突破双亲委派模型的目的，而ThreadContextClassLoader也是为了完成这个工作。试想： 如果一个JNDI的提供方，或者JAXP的提供方，他们的SPI是通过bootstrap加载的，但是他们的实现类必须通过应用ClassLoader甚至是更下层的ClassLoader来加载。那么在其初始化的过程中，需要考虑如果获取到部署了SPI实现的ClassLoader，而给出的方案是使用ContextClassLoader。 在javax.xml.parsers.DocumentBuilderFactory中，进行创建SPI实现的方法：
``` java
public static DocumentBuilderFactory newInstance() {
        try {
            return (DocumentBuilderFactory) FactoryFinder.find(
                /* The default property name according to the JAXP spec */
                "javax.xml.parsers.DocumentBuilderFactory",
                /* The fallback implementation class name */
                "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl");
        } catch (FactoryFinder.ConfigurationError e) {
            throw new FactoryConfigurationError(e.getException(),
                                                e.getMessage());
        }

    }
```
可以看到通过查询一个property的Key来定位客户端的实现者，或者在找不到时，默认使用`com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl`。 而在FactoryFinder中，find方法通过如下的方式定位实现者：
``` java
String serviceId = "META-INF/services/" + factoryId;
        InputStream is = null;
        ClassLoader cl = ss.getContextClassLoader();
        boolean useBSClsLoader = false;
        if (cl != null) {
            is = ss.getResourceAsStream(cl, serviceId);
            if (is == null) {
                cl = FactoryFinder.class.getClassLoader();
                is = ss.getResourceAsStream(cl, serviceId);
                useBSClsLoader = true;
            }
        } else {
            cl = FactoryFinder.class.getClassLoader();
            is = ss.getResourceAsStream(cl, serviceId);
            useBSClsLoader = true;
        }
```
可以看到**cl**变量，就是当前线程的ThreadContextClassLoader，选择使用这种方式，是因为不同的部署（通过classpath启动的控制台程序，通过Webapp部署的程序）方式不同，最终都需要有一个用户ClassLoder来查找到客户端的实现，通过前面的`Reflection.getCallerClass`或者`sun.misc.VM`中获取最近一个不为空的ClassLoder的方式都不能很好的满足要求，那么就利用一个指定的ClassLoder来完成，也就是接口实现者能够很明确的被这个ClassLorder加载，这个选择就是ContextClassLoader。

可以看出来CurrentClassLoader对用户来说是自动的，隐式的，而ThreadContextClassLoader需要显示的使用，先进行设置然后再进行使用。
## 参考
1. [Find a way out of the ClassLoader maze](http://www.javaworld.com/article/2077344/core-java/find-a-way-out-of-the-classloader-maze.html)
