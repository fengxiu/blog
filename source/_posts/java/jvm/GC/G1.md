---
title: G1
abbrlink: af3fcb07
categories:
  - java
  - jvm
date: 2019-09-06 11:26:42
tags:
  - GC
---
翻译自[https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html#overview](Getting Started with the G1 Garbage Collector)

## 概述

**目标**
本教程介绍了如何使用G1垃圾收集器以及如何将其与Hotspot JVM一起使用的基础知识。您将了解G1收集器内部如何运行，如何切换使用G1的关键命令，以及用于记录其操作的选项。

**简介**
本OBE涵盖了Java中Java虚拟机（JVM）G1垃圾收集（GC）的基础知识。在OBE的第一部分中，提供了JVM的概述以及垃圾收集和性能的介绍。下一批学生将了解CMS收集器如何与Hotspot JVM配合使用。接下来，逐步指导将垃圾收集与Hotspot JVM一起使用时垃圾收集的工作原理。接下来，提供了一个部分，其中包含G1垃圾收集器可用的垃圾收集命令行选项。最后，您将了解用于G1收集器的日志记录选项。
<!-- more -->
**硬件和软件要求**
以下是硬件和软件要求列表：

* 运行Windows XP或更高版本，Mac OS X或Linux的PC。请注意，此操作已在Windows 7中完成，尚未在所有平台上进行测试。但是，一切都应该在OS X或Linux上正常工作。另外，具有多于一个芯的机器也是优选的。
* Java 7 Update 9或更高版本
* 最新的Java 7演示和示例Zip文件

**先决条件**
在开始本教程之前，您应该：

* 如果尚未这样做，请下载并安装最新版本的Java JDK（JDK 7 u9或更高版本）。
* Java 7 JDK下载从同一位置下载并安装Demos and Samples zip文件。解压缩文件并将内容放在目录中。例如：C：\ javademos

**性能基础知识**
通常，在调优Java应用程序时，重点是两个主要目标之一：响应性或吞吐量。随着教程的进展，我们将回顾这些概念。
**响应**
响应性是指应用程序或系统对请求的数据进行响应的速度。例子包括：

* 桌面UI响应事件的速度有多快
* 网站返回页面的速度有多快返回
* 数据库查询的速度有多快
对于专注于响应性的应用程序，大型暂停时间是不可接受的。重点是在短时间内做出回应。
**吞吐量**
吞吐量侧重于在特定时间段内最大化应用程序的工作量。如何衡量吞吐量的示例包括：
* 在给定时间内完成的交易数量。
* 批处理程序可在一小时内完成的作业数。
* 可以在一小时内完成的数据库查询数。
对于专注于吞吐量的应用程序，高暂停时间是可接受的由于高吞吐量应用程序在较长时间内专注于基准测试，因此不需要考虑快速响应时间。

## G1 垃圾收集器

### G1垃圾收集器

Garbage-First（G1）收集器是一种服务器式（Server-style）垃圾收集器，适用于具有大内存的多处理器机器。它以高可能性满足垃圾收集（GC）暂停时间目标，同时实现高吞吐量。Oracle JDK 7 Update 4及更高版本完全支持G1垃圾收集器。G1收集器专为以下应用而设计：

* 可以与CMS收集器等应用程序线程同时运行。
* 紧凑的自由空间，没有长时间的GC引起的暂停时间
* 需要更多可预测的GC暂停持续时间。
* 不想牺牲很多吞吐量性能。
* 不需要更大的Java堆。

G1计划作为Concurrent Mark-Sweep Collector（CMS）的长期替代品。将G1与CMS进行比较，存在差异，使G1成为更好的解决方案。一个区别是G1是压缩收集器。G1足够紧凑以完全避免使用细粒度的自由列表进行分配，而是依赖于区域。这大大简化了收集器的各个部分，并且主要消除了潜在的碎片问题。此外，G1提供比CMS收集器更可预测的垃圾收集暂停，并允许用户指定所需的暂停目标。

### G1操作概览

旧的垃圾收集器（串行，并行，CMS）都将堆构建为三个部分：年轻代，旧代和永久生成固定内存大小。旧的垃圾收集器（串行，并行，CMS）都将堆构建为三个部分：年轻代，旧代和永久生成固定内存大小。
![HeapStructure](/sourcehttps://cdn.jsdelivr.net/gh/fengxiu/img/HeapStructure.png)
所有内存对象都以这三个部分之一结束。
G1收集器采用不同的方法。
![Slide9](/sourcehttps://cdn.jsdelivr.net/gh/fengxiu/img/Slide9.png)
堆被分区为一组大小相等的堆区域，每个区域都是一个连续的虚拟内存区域。某些区域集具有与旧收集器中相同的角色（eden，survivor，old），但它们没有固定的大小。这为内存使用提供了更大的灵活性。

执行垃圾收集时，G1以类似于CMS收集器的方式运行。G1执行并发全局标记阶段以确定整个堆中对象的活跃度。在标记阶段完成之后，G1知道哪些区域基本上是空的。它首先收集在这些区域，这通常会产生大量的自由空间。这就是为什么这种垃圾收集方法称为Garbage-First。顾名思义，G1将其集合和压缩活动集中在堆的可能充满可回收对象的区域，即垃圾。G1使用暂停预测模型来满足用户定义的暂停时间目标，并根据指定的暂停时间目标选择要收集的区域数。

由G1确定为回收成熟的区域是使用疏散（evacuation）收集的垃圾。G1将对象从堆的一个或多个区域复制到堆上的单个区域，并且在此过程中压缩并释放内存。这种疏散在多处理器上并行执行，以减少暂停时间并提高吞吐量。因此，对于每次垃圾收集，G1会持续工作以减少碎片，在用户定义的暂停时间内工作。这超出了以前两种方法的能力。CMS（Concurrent Mark Sweep）垃圾收集器不进行压缩。ParallelOld垃圾收集仅执行整堆压缩，这会导致相当长的暂停时间。

值得注意的是G1不是实时收集器。它以高概率但不是绝对确定性满足设定的暂停时间目标。基于先前集合的数据，G1估计可以在用户指定的目标时间内收集多少个区域。因此，收集器具有收集区域的成本的相当准确的模型，并且它使用该模型来确定在停留在暂停时间目标内时要收集哪些区域和多少区域。
注意：G1具有并发（与应用程序线程一起运行，例如，细化，标记，清理）和并行（多线程，例如，STW）阶段。完全垃圾收集仍然是单线程的，但如果正确调整，您的应用程序应该避免使用完整的GC。

### G1 FootPrint

如果从ParallelOldGC或CMS收集器迁移到G1，您可能会看到更大的JVM进程大小。这主要与“统计”数据结构有关，
例如 Remembered Sets and Collection Sets。
**Remembered Sets**或RSet跟踪对象引用到给定区域。堆中每个区域有一个RSet。RSet支持并行和独立收集区域。RSets的总体footprint影响小于5％。
**Collection Sets**或CSets将在GC中收集的区域集。在GC期间，CSet中的所有实时数据都被撤离（复制/移动）。区域集可以是Eden, survivor, and/or old generation。CSets对JVM的大小影响不到1％。

### 推荐的G1用例

G1的第一个重点是为运行需要具有有限GC延迟的大堆的应用程序的用户提供解决方案。这意味着堆大小约为6GB或更大，稳定且可预测的暂停时间低于0.5秒。
如果应用程序具有以下一个或多个特征，那么今天使用CMS或ParallelOldGC垃圾收集器运行的应用程序将有利于切换到G1。

* Full GC持续时间太长或太频繁。
* 对象分配率或促销率差异很大。
* 不期望的长垃圾收集或压实暂停（超过0.5到1秒）

注意：如果您使用的是CMS或ParallelOldGC，并且您的应用程序没有经历长时间的垃圾收集暂停，那么与您当前的收集器保持联系是可以的。更改为G1收集器不是使用最新JDK的必要条件。