---
title: JVM 垃圾回收算法
tags:
  - 垃圾回收
categories:
  - java
  - jvm
  - GC
abbrlink: d20aa128
date: 2019-03-15 09:05:00
---
## 概述

通过前面介绍`Java`内存运行时区域，可以学习到**程序计数器**、**虚拟机栈**、**本地方法栈** 三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的**内存分配和回收**都具备**确定性**。在这几个区域内不需要过多考虑回收的问题，**因为方法结束或线程结束时，内存自然就跟随着回收了**。

而`Java`**堆** 和 **方法区** 则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样。我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分**内存的分配和回收**都是**动态的**，**垃圾收集器** 所关注的是这部分内存。

接下来我将会用俩篇文章来聊聊这部分内容，这篇文章主要讲解如何确定一个对象可以回收以及垃圾回收算法的种类，属于方法的介绍，下一篇文章则主要介绍`JVM`中实现的垃圾回收器和内存分配的策略。

因此本篇文章主要是包含下面俩块内容：

1. 对象是否可以回收判定
2. 垃圾回收算法

**注:**后面都是基于java来进行讲解。
<!-- more -->

## 对象是否可以回收判定

要想回收对象，首先应该判定哪些对象活着哪些对象已经死去（不会再被使用的对象）

### 引用计数算法

JVM堆中每个具体对象（**不是引用**）都有一个**引用计数器**。当一个对象被创建并初始化赋值后，该变量计数设置为`1`。每当有一个地方引用它时，计数器值就**加1**。当引用**失效**时，即一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时，计数器值就**减1**。任何引用计数为`0`的对象可以被当作**垃圾收集**。当一个对象被回收时，它引用的任何对象计数减1。

**优点**：引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利。

**缺点**：难以检测出对象之间的循环引用。简单的说就是A对象内部引用了B对象，B对象内部引用了A对象同时，但是这俩个对象都不会在被使用，也就是对象已经死去，但是因为引用计数都是1，所以无法判定这俩个对象死去，也就无法回收。引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。

### 可达性分析算法

**可达性分析算法**也叫**根搜索算法**，通过一系列的称为 `GC Roots` 的对象作为起点，然后向下搜索。搜索所走过的**路径**称为引用链 （`Reference Chain`）， 当一个**对象**到 `GC Roots` 没有任何**引用链**相连时, 即该对象**不可达**，也就说明此对象是 **不可用的**。

如下图所示: `Object5`、`Object6`、`Object7` 虽然互有关联, 但它们到`GC Roots`是不可达的, 因此也会被判定为可回收的对象。

![upload successful](/images/pasted-134.png)

在`Java`中, 可作为`GC Roots`的对象包括以下四种：

- **虚拟机栈**（栈帧中的**本地变量表**）中引用的对象
- **本地方法栈** 中 `JNI` （`Native`方法）引用的变量
- **方法区** 中**类静态属性**引用的变量
- **方法区** 中**常量**引用的变量

## 垃圾回收算法

本节具体介绍一下各种垃圾回收算法的思想，主要由**标记-清除**、**标记-复制**、**标记-整理**

### 标记-清除算法

标记-清除算法对**根集合**进行扫描，对**存活**的对象进行标记。标记完成后，再对整个空间内**未被标记**的对象扫描，进行回收。
**优点**：实现简单，不需要进行对象进行移动。
**缺点**：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。

### 标记-复制算法

这种算法将内存区域划分成相同的两个**内存块**，每次仅使用一半的空间，`JVM`生成的新对象放在一半空间中。当一半空间用完时进行`GC`，第一步和 **标记-清除算法**一样，先对跟集合进行扫描，把可到达对象复制到另一半空间，然后把使用过的内存空间一次清理掉。这种收集算法解决了标记清除算法存在的效率问题。
**优点**：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。
**缺点**：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。

### 标记-整理算法

**标记-整理算法**采用和**标记-清除算法**一样的方式进行对象的标记，但后续不直接对可回收对象进行清理，而是将所有的**存活对象**往一端**空闲空间**移动，然后清理掉边界以外的内存空间。
**优点**：解决了标记-清除算法存在的内存碎片问题。
**缺点**：仍需要进行局部对象移动，一定程度上降低了效率。

### 分代收集算法

当前商业虚拟机都采用**分代收集**的垃圾收集算法。分代收集算法，顾名思义是根据对象的**存活周期**将内存划分为几块。一般包括**年轻代**、**老年代** 和 **永久代**，如图所示：
![upload successful](/images/pasted-137.png)

1. **新生代（Young generation）**

   绝大多数最新被创建的对象会被分配到这里，由于**大部分对象**在创建后会很快变得**不可达**，所以很多对象被创建在**新生代**，然后**消失**。对象从这个区域消失的过程我们称之为 `minor GC`。

   在很多的JVM虚拟机中新生代都是采用这种**标记-复制**回收算法来回收新生代对象，但是并不是按照上面介绍的`1:1`来分配复制区域，通常情况下，会划分成一个较大`Eden`区和两个较小`Survivor`区。每次使用`Eden`区和一个`Survivor`区。当回收时，会先将`Eden`区和一个`Survivor`区存活的对象复制到另外一个`Survivor`区。最后清理掉`Eden`区和刚才使用的`Survivor`区。HotSpot默认`Eden`区和`Survivor`区的大小比例是8：1，也就是用10%的空间浪费掉。

   另外就是存活的对象可能大于`Survivor`区的空间，这时就需要使用到老年代，将这部分存活的对象移动到老年代（这里说的不是很准确，因为牵扯到分配担保的问题，如果说了这个会使得这部分内容不好理解，所以放到下一篇中讲解，这里可以先这样理解）。

   * **-XX:NewSize和-XX:MaxNewSize**

     用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。

   * **-XX:SurvivorRatio**

     用于设置Eden和其中一个Survivor的比值，这个值也比较重要。

   * **-XX:+PrintTenuringDistribution**

     这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。

2. **老年代（Old generation）**

   对象没有变得不可达，并且从新生代中**存活**下来（这里不准确，应该经过是几次回收之后），会被**拷贝**到这里。其所占用的空间要比新生代多。也正由于其相对**较大的空间**，发生在**老年代**上的`GC`要比**新生代**要**少得多**。对象从**老年代**中消失的过程，可以称之为`major GC`（或者`full GC`）。老年代经常使用的回收算法是**标记-整理**算法

3. **永久代（permanent generation）**

   像一些**类的层级信息**，**方法数据** 和**方法信息**（如**字节码**，**栈** 和 **变量大小**），**运行时常量池**（`JDK7`之后移出**永久代**），已确定的**符号引用**和**虚方法表**等等。它们几乎都是**静态的**并且**很少**被**卸载和回收**，在`JDK8`之前的`HotSpot`虚拟机中，类的这些**“永久的”** 数据存放在一个叫做**永久代**的区域

   永久代一段**连续的内存空间**，我们在`JVM`启动之前可以通过设置`-XX:MaxPermSize`的值来控制永久代的大小。但是`JDK8`之后取消了永久代，这些**元数据**被移到了一个与堆**不相连**的称为**元空间** (`Metaspace`) 的**本地内存区域**。

   在这里补充一点，这部分内存其实也会被回收，但是在这里垃圾回收的效率很低。永久代的垃圾主要回收俩部分：废弃常量和无用的类。回收废弃常量和回收java堆中的对象非常相似，只要这个常量不会再被使用到就可以被回收。但是判断一个类是否可以回收则比较苛刻，类需要同时满足以下三个条件才能算是无用的类：

   * 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
   * 加载该类的ClassLoader已经被回收
   * 该类对应的java.lang.Class对象没有任何地方被引用。无法在任何地方通过反射获取到改class。

   即使满足了上面的三个条件也只是达到可以回收的条件，这里仅仅是可以，而不是像对象一样，不使用了就必然回收。

   通过上面的介绍你大概可以感受到回收永久代的性价比很低。

上面已经简单介绍分代收集算法，下面补充下为什么需要分代和详细介绍下年轻代。

### 为什么分代

我们先来屡屡，为什么需要把堆分代？不分代不能完成他所做的事情么？其实不分代完全可以，分代的唯一理由就是优化GC性能。你先想想，如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而我们的很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。

### 新生代

HotSpot JVM把新生代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到老年代中。

因为新生代中的对象基本都是朝生夕死的(80%以上)，所以在新生代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。

在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到老年代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。
![young_gc](/images/young_gc.png)
## 参考

1. 周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社
2. [JVM系列(五) - JVM垃圾回收算法](https://juejin.im/post/5b4dea755188251ac1098e98)
3. [聊聊JVM的年轻代](http://ifeve.com/jvm-yong-generation/)