---
title: 垃圾回收算法
tags:
  - 垃圾回收
categories:
  - java
  - jvm
abbrlink: d20aa128
date: 2019-03-15 09:05:00
updated: 2019-03-15 09:05:00
---
## 概述

通过前面介绍`Java`内存运行时区域，可以学习到**程序计数器**、**虚拟机栈**、**本地方法栈** 三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的**内存分配和回收**都具备**确定性**。在这几个区域内不需要过多考虑回收的问题，**因为方法结束或线程结束时，内存自然就跟随着回收了**。

而`Java`**堆** 和 **方法区** 则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样。我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分**内存的分配和回收**都是**动态的**，**垃圾收集器** 所关注的是这部分内存。

要对对象进行回收，首先需要解决下面三个事情：

1. 确定哪些对象可以回收？
2. 什么时间可以回收？
3. 如何回收？

本篇文章主要对前面俩个问题进行回答，第三个问题设计具体的回收实现，留到下一篇文章进行讲解。

**注**：后面都是基于java来进行讲解。

<!-- more -->
## 对象是否可以回收判定

要想回收对象，首先应该判定哪些对象活着哪些对象已经死去（不会再被使用的对象）。目前有俩种防范，引用计数算法和可达性分析算法。

### 引用计数算法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

**优点**：引用计数收集器执行简单，判定效率高，交织在程序运行中，对程序不被长时间打断的实时环境比较有利。

**缺点**：难以检测出对象之间的循环引用。简单的说就是A对象内部引用了B对象，B对象内部引用了A对象同时，但是这俩个对象都不会在被使用，也就是对象已经死去，但是因为引用计数都是1，所以无法判定这俩个对象死去，也就无法回收。

### 可达性分析算法

**可达性分析算法**也叫**根搜索算法**，通过一系列的称为 `GC Roots` 的对象作为起点，然后向下搜索。搜索所走过的**路径**称为引用链 （`Reference Chain`）， 当一个**对象**到 `GC Roots` 没有任何**引用链**相连时, 即该对象**不可达**，也就说明此对象是 **不可用的**。

如下图所示: `Object5`、`Object6`、`Object7` 虽然互有关联, 但它们到`GC Roots`是不可达的, 因此也会被判定为可回收的对象。

![upload successful](https://cdn.jsdelivr.net/gh/fengxiu/img/pasted-134.png)

在`Java`中, 可作为`GC Roots`的对象包括以下四种：

* 在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。
* 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
* 在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用。
* 在本地方法栈中JNI(即通常所说的Native方法)引用的对象。 
* Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如
NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。
* 所有被同步锁(synchronized关键字)持有的对象。
* 反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。

除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不 同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。譬如将会提到的分代收集和局部回收(Partial GC)，如果只针对Java堆中某一块区域发起垃圾收集时(如最典型的只针对新生代的垃圾收集)，必须考虑到内存区域是虚拟机自己的实现细节(在用户视角里任何内存区域都是不可见的)，更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引 用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。

## 垃圾回收算法

本节具体介绍一下各种垃圾回收算法的思想，主要由**标记-清除**、**标记-复制**、**标记-整理**

### 标记-清除算法

分为俩个阶段：

* 标记阶段：标记所有需要回收的对象
* 清楚阶段：标记完成后，统一回收所有被标记的帝乡

**优点**：实现简单，不需要进行对象进行移动。
**缺点**：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。

![](https://cdn.jsdelivr.net/gh/fengxiu/img/20220418165640.png)

### 标记-复制算法

这种算法将内存区域划分成相同的两个**内存块**，每次仅使用一半的空间，`JVM`生成的新对象放在一半空间中。当一半空间用完时进行`GC`，第一步和 **标记-清除算法**一样，先对跟集合进行扫描，把可到达对象复制到另一半空间，然后把使用过的内存空间一次清理掉。这种收集算法解决了标记清除算法存在的效率问题。

![](https://cdn.jsdelivr.net/gh/fengxiu/img/20220418165848.png)

**优点**：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。
**缺点**：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。

### 标记-整理算法

**标记-整理算法**采用和**标记-清除算法**一样的方式进行对象的标记，但后续不直接对可回收对象进行清理，而是将所有的**存活对象**往一端**空闲空间**移动，然后清理掉边界以外的内存空间。

![](https://cdn.jsdelivr.net/gh/fengxiu/img/20220418170025.png)

**优点**：解决了标记-清除算法存在的内存碎片问题。
**缺点**：仍需要进行局部对象移动，一定程度上降低了效率。

### 分代收集理论

当前商业虚拟机都采用分代收集理论进行设计。具体的理论依据如下：

1. 弱分代假说(Weak Generational Hypothesis):绝大多数对象都是朝生夕灭的。
2. 强分代假说(Strong Generational Hypothesis):熬过越多次垃圾收集过程的对象就越难以消亡。
3. 跨代引用假说(Intergenerational Reference Hypothesis):跨代引用相对于同代引用来说仅占极少数。

首先看前两个分代假说，共同奠定了多款常用的垃圾收集器的一致的设计原则:收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间;如果剩下的都是难以消亡的对象，那把它们集中放在一块， 虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

java中根据分带收集理论，把内存分成不通的区，一般包括**年轻代**、**老年代** 和 **永久代**，如图所示：
![upload successful](https://cdn.jsdelivr.net/gh/fengxiu/img/pasted-137.png)

假如要现在进行一次只局限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要来研究第三条理论依据。

这其实是可根据前两条假说逻辑推理得出的隐含推论:存在互相引用关系的两个对象，是应该倾
向于同时生存或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。

依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构(该结构被称为“记忆集”，Remembered Set)，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会 存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系(如将自己或者某个属性赋值)时维护记录数 据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。这就是我们在前面提到的，除了在线程中和方法去中包含的GC roots以外，还有一部分就来自这个记忆表。

这里先不着急往下进行，补充一些容易搞混的名词。

* 部分收集(Partial GC):指目标不是完整收集整个Java堆的垃圾收集，其中又分为:
* 新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集。
* 老年代收集(Major GC/Old GC):指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。
* 混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。
* 整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集。

这里对新生代、老年代以及永久代进行简单的介绍，方便理解后面一篇文章，主要也是不知道把这写知识点放在哪里。

**新生代（Young generation）**
绝大多数最新被创建的对象会被分配到这里，由于**大部分对象**在创建后会很快变得**不可达**，所以很多对象被创建在**新生代**，然后**消失**。

在很多的JVM虚拟机中新生代都是采用**标记-复制**回收算法来回收新生代对象，但是并不是按照上面介绍的`1:1`来分配复制区域，通常情况下，会划分成一个较大`Eden`区和两个较小`Survivor`区。每次使用`Eden`区和一个`Survivor`区。当回收时，会先将`Eden`区和一个`Survivor`区存活的对象复制到另外一个`Survivor`区。最后清理掉`Eden`区和刚才使用的`Survivor`区。HotSpot默认`Eden`区和`Survivor`区的大小比例是`8：1`，也就是用10%的空间浪费掉。

另外就是存活的对象可能大于`Survivor`区的空间，这时就需要使用到老年代，将这部分存活的对象移动到老年代（这里说的不是很准确，因为牵扯到分配担保的问题，如果说了这个会使得这部分内容不好理解，所以放到下一篇中讲解，这里可以先这样理解）。

在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到老年代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

![young_gc](https://cdn.jsdelivr.net/gh/fengxiu/img/young_gc.png)

新生代可能使用到的参数如下

```java
# 用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。
-XX:NewSize和-XX:MaxNewSize 
# 用于设置Eden和其中一个Survivor的比值，这个值也比较重要。
-XX:SurvivorRatio
# 这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。
-XX:+PrintTenuringDistribution
```

**老年代（Old generation）**
对象没有变得不可达，并且从新生代中**存活**下来（这里不准确，应该经过是几次回收之后），会被**拷贝**到这里。其所占用的空间要比新生代多。也正由于其相对**较大的空间**，发生在**老年代**上的`GC`要比**新生代**要**少得多**。老年代经常使用的回收算法是**标记-整理**算法

**永久代（permanent generation）**
可以当成方法区，像一些**类的层级信息**，**方法数据** 和**方法信息**（如**字节码**，**栈** 和 **变量大小**），**运行时常量池**（`JDK7`之后移出**永久代**），已确定的**符号引用**和**虚方法表**等等。它们几乎都是**静态的**并且**很少**被**卸载和回收**，在`JDK8`之前的`HotSpot`虚拟机中，类的这些**“永久的”** 数据存放在一个叫做**永久代**的区域

永久代一段**连续的内存空间**，我们在`JVM`启动之前可以通过设置`-XX:MaxPermSize`的值来控制永久代的大小。但是`JDK8`之后取消了永久代，这些**元数据**被移到了一个与堆**不相连**的称为**元空间** (`Metaspace`) 的**本地内存区域**。

在这里补充一点，这部分内存其实也会被回收，但是在这里垃圾回收的效率很低。永久代的垃圾主要回收俩部分：废弃常量和无用的类。回收废弃常量和回收java堆中的对象非常相似，只要这个常量不会再被使用到就可以被回收。但是判断一个类是否可以回收则比较苛刻，类需要同时满足以下三个条件才能算是无用的类：

* 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
* 加载该类的ClassLoader已经被回收
* 该类对应的java.lang.Class对象没有任何地方被引用。无法在任何地方通过反射获取到改class。
即使满足了上面的三个条件也只是达到可以回收的条件，这里仅仅是可以，而不是像对象一样，不使用了就必然回收。通过上面的介绍你大概可以感受到回收永久代的性价比很低。

## 总结

本篇文章主要是理论篇，介绍了如何判定对象是否可被回收，又俩种方法，引用计数法和可达性分析方法。接着对垃圾回收的算法进行了整理，分别是标记-清楚算法，标记-复制算法，标记-整理算法，然后又介绍了分代收集理论，可以用来做为将堆划分成不同区块，从而减少垃圾回收的时间，又在此基础上介绍了JVM中的分区方案。

## 参考

1. 周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社
2. [JVM系列(五) - JVM垃圾回收算法](https://juejin.im/post/5b4dea755188251ac1098e98)
3. [聊聊JVM的年轻代](http://ifeve.com/jvm-yong-generation/)