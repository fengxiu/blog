---
title: JVM 垃圾回收器
tags:
  - 垃圾回收
categories:
  - java
  - jvm
abbrlink: 1d97a19
date: 2019-03-15 09:02:00
---
# JVM 垃圾回收器

## 概述

在之前的博客中，我们大致介绍了，常见的 **垃圾回收算法** 及 `JVM` 中常见的分类回收算法。本篇我们主要介绍在 `oracle JVM` 中，垃圾回收的具体实现:**垃圾回收器**（`Garbage Collector`）。
<!-- more -->
在了解 **垃圾回收器** 之前，首先得了解一下垃圾回收器的几个名词。

1. **吞吐量**

   `CPU` 用于运行用户代码的时间与 `CPU` 总消耗时间的比值。比如说虚拟机总运行了 `100` 分钟，**用户代码** 时间 `99` 分钟，**垃圾回收** 时间 `1` 分钟，那么吞吐量就是 `99%`。

   ```
   吞吐量 = 运行用户代码时间/（运行用户代码时间 + 垃圾回收时间）
   ```

2. **停顿时间**

   **停顿时间** 指垃圾回收器运行时，**应用程序** 的 **暂停时间**。对于 **独占回收器** （也就是只有回收器运行）而言，停顿时间可能会比较长。使用 **并发回收器** 时，由于垃圾回收器和应用程序 **交替运行**，程序的 **停顿时间** 会变短，但是，由于其 **效率** 很可能不如独占垃圾回收器，故系统的 **吞吐量** 可能会较低。

3. **GC的名词**

   **新生代GC（Minor GC）**

   指发生在 **新生代** 的垃圾回收动作，因为 `Java` 对象大多都具备 **朝生夕死** 的特性，所以 `Minor GC` 通常 **非常频繁**，一般回收速度也比较快。

   **老年代GC（Major GC）**

   指发生在 **老年代** 的垃圾回收动作，出现了 `Major GC`，经常会伴随至少一次的 `Minor GC`（发生这种情况，那么 **整个堆** 都 `GC` 一遍，通常称为 `Full GC`）。`Major GC` 的速度一般会比 `Minor GC` 慢 `10` 倍以上。

4. **并发与并行**

   串行（Serial）

   **单线程** 进行垃圾回收工作，但此时 **用户线程** 仍然处于 **等待状态**。

   并发（Concurrent）

   这里的并发指 **用户线程** 与 **垃圾回收线程** 交替执行。

   并行（Parallel）

   这里的并行指 **用户线程** 和多条 **垃圾回收线程** 分别在不同 `CPU` 上同时工作。

## 垃圾回收器

在 `JVM` 中，具体实现有 `Serial`、`ParNew`、`Parallel Scavenge`、`CMS`、`Serial Old（MSC）`、`Parallel Old`、`G1` 等。在下图中，你可以看到 **不同垃圾回收器** 适合于 **不同的内存区域**，如果两个垃圾回收器之间 **存在连线**，那么表示两者可以 **配合使用**。

![upload successful](/images/pasted-138.png)

下面按照先新生代后老年代的顺序介绍每个垃圾回收器。

1. **Serial（-XX:+UseSerialGC）**

   `Serial` 回收器是最基本的 **新生代** 垃圾回收器，是 **单线程** 的垃圾回收器。这里单线程的意思不仅仅在于它只使用一个cpu或者一个线程来进行垃圾回收，更重要的在于他在进行垃圾回收时必须暂停其他所有线程的运行，等到回收完成时才允许其他线程继续运行，由于这个暂停的存在，所以他很不适用于交互式应用中去，类如web就不适合。他的劣势也正是它的优势，由于垃圾清理时，`Serial` **回收器** 不存在 **线程间的切换**，因此，特别是在单 `CPU` 的环境下，它的 **垃圾清除效率** 比较高。对于 `Client` 运行模式的程序，选择 `Serial` 回收器是一个不错的选择。

   主要流程如下：

   ![upload successful](/images/pasted-139.png)

   **`Serial` 新生代回收器采用的是复制算法。**

2. **ParNew（-XX:+UseParNewGC）**

   `ParNew` 回收器是在 `Serial` 回收器的基础上演化而来的，属于 `Serial` 回收器的 **多线程版本**，同样运行在 **新生代区域**。在实现上，两者共用很多代码。在不同运行环境下，根据 `CPU` 核数，开启 **不同的线程数**，从而达到 **最优** 的垃圾回收效果。对于那些 `Server` 模式的应用程序，如果考虑采用 `CMS` 作为 **老年代回收器** 时，`ParNew` 回收器是一个不错的选择。

   ![upload successful](/images/pasted-140.png)

   **`ParNew` 新生代回收器采用的是复制算法。**

3. **Parallel Scavenge（-XX:+UseParallelGC）**

   和 `ParNew` 回收一样，`Parallel Scavenge` 回收器也是运行在 **新生代区域**，属于**多线程** 的回收器。但不同的是，`ParNew` 回收器是通过控制**垃圾回收**的**线程数**来进行参数调整，而 `Parallel Scavenge` 回收器更关心的是**程序运行的吞吐量**。即一段时间内，**用户代码**运行时间占**总运行时间**的百分比。

   **`Parallel Scavenge` 新生代回收器采用的是复制算法。**

对上面做一个小的总结：

* Serial和ParNew追求的是垃圾回收的时间越短越好，越短越适合于与用户进行交互的程序，良好的响应速度更能提升用户体验
* Parallel Scavenge 则是追求高吞吐量，而高吞吐量则可以高效利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要交互的任务。

下面主要介绍适用于老年代的垃圾回收器

1. **Serial Old（-XX:+UseSerialGC）**

   `Serial Old` 回收器是 `Serial` 回收器的 **老生代版本**，属于**单线程回收器**，它使用**标记-整理**算法。对于 `Server` 模式下的虚拟机，在 `JDK1.5` 及其以前，它常与 `Parallel Scavenge` 回收器配合使用，达到较好的 **吞吐量**，另外它也是 `CMS` 回收器在 `Concurrent Mode Failure` 时的**后备方案**。

   `Serial` 回收器和 `Serial Old` 回收器的工作过程如下：

   ![upload successful](/images/pasted-141.png)

   **`Serial Old` 老年代回收器采用的是标记 - 整理算法。**

2. **Parallel Old（-XX:+UseParallelOldGC）**

   `Parallel Old`回收器是 `Parallel Scavenge` 回收器的 **老生代版本**，属于**多线程回收器**，采用**标记-整理算法**。`Parallel Old`回收器和 `Parallel Scavenge` 回收器同样考虑了**吞吐量优先** 这一指标，非常适合那些 **注重吞吐量**和`CPU` **资源敏感** 的场合。

   ![upload successful](/images/pasted-142.png)

   **`Parallel Old` 老年代回收器采用的是标记 - 整理算法。**

3. **CMS（-XX:+UseConcMarkSweepGC）**

   `CMS（Concurrent Mark Sweep）` 回收器以获取**最短回收停顿时间**为前提的回收器，属于**多线程回收器**，采用 **标记-清除算法**（这个是和上面不一样的地点）。

   ![upload successful](/images/pasted-143.png)

   相比之前的回收器，`CMS` 回收器的运作过程比较复杂，分为四步：

   1. **初始标记（CMS initial mark）**

      **初始标记** 仅仅是标记 `GC Roots` 能**直接关联** 的对象。这个阶段 **速度很快**，需要 `Stop the World`。

   2. **并发标记（CMS concurrent mark）**

      **并发标记**进行的是 `GC  root Tracing`，从 `GC Roots` 开始对堆内的对象进行**可达性分析**，找出 **存活对象**。

   3. **重新标记（CMS remark）**

      **重新标记** 阶段为了**修正**并发期间由于**用户进行运作**导致的 **标记变动** 的那一部分对象的 **标记记录**。这个阶段的 **停顿时间**一般会比 **初始标记阶段**稍长一些，但远比**并发标记**的时间短，也需要 `Stop The World`。

   4. **并发清除（CMS concurrent sweep）**

      **并发清除** 阶段会清除垃圾对象。这个阶段采用的是**标记-清除**算法

   **初始标记**（`CMS initial mark`和**重新标记**（`CMS remark`会导致**用户线程** 卡顿，`Stop the World` 现象发生，不过相对来说这俩个阶段时间比较短。在整个过程中，`CMS` 回收器的**内存回收** 基本上和 **用户线程** 并发执行，因此不需要停顿用户线程，所以综合起来，CMS垃圾回收算法相对来说停顿的时间比较少，非常适合交互任务的执行，能给用户带来良好的体验。

   由于 `CMS` 回收器 **并发收集**、**停顿低**，因此有些地方成为**并发低停顿回收器**（`Concurrent Low Pause Sweep Collector`）。

   `CMS` 回收器的缺点：

   1. **CMS回收器对CPU资源非常依赖**

      `CMS` 回收器过分依赖于**多线程环境**，默认情况下，开启的 **线程数** 为`（CPU 的数量 + 3）/ 4`，当 `CPU` 数量少于 `4` 个时，`CMS` 对 **用户查询** 的影响将会很大，因为他们要分出一半的运算能力去 **执行回收器线程**；

   2. **CMS回收器无法清除浮动垃圾**

      由于 `CMS` 回收器 **清除已标记的垃圾** （处于最后一个阶段）时，**用户线程** 还在运行，因此会有新的垃圾产生。但是这部分垃圾 **未被标记**，只有在下一次 `GC` 才能清除，因此被成为**浮动垃圾**。

      由于**内存回收**和**用户线程**是同时进行的，内存在被**回收**的同时，也在被**分配**。当**老年代**中的内存使用超过一定的比例时，系统将会进行**垃圾回收**；当**剩余内存**不能满足程序运行要求时，系统将会出现 `Concurrent Mode Failure`，临时采用 `Serial Old` 垃圾回收器来重新进行老年代的垃圾收集，这样就会造成停顿的时间增长，从而致使CMS的**性能 **降低。

   3. **垃圾收集结束后残余大量空间碎片**

      `CMS` 回收器采用的**标记清除算法**，本身存在垃圾回收器收集结束后残余**大量空间碎片**的缺点。`CMS` 需要配合适当的**内存整理策略**，在一定程度上可以解决这个问题。

   **G1垃圾回收器**

   `G1` 是 `JDK 1.7` 中正式投入使用的用于取代 `CMS` 的垃圾收集器器，它既可以用在新生代又可以用在老年代，是一款面向服务端应用的垃圾收集器。

   在G1之前的其他收集器进行的收集范围都是整个新生代或者老年代。使用G1收集器时，java堆的内存布局就与其他收集器有很大差别，他将整个java堆划分成多个大小相等的区域（region），虽然还保留有新生代和老年代的概念，但是新生代和老年代不在是物理上的各留，他们都是一部分region（不需要连续）的集合。`G1` 的分区示例如下图所示：

   ![upload successful](/images/pasted-144.png)

   G1收集器之所以能建立可预测的停顿时间模型，是因为他可以有计划地避免在真个java堆中进行全区域的垃圾收集。G1跟中各个Reqion里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要时间的经验值），在后台维护一个优先列表，每次根据允许的手机时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及优先级的区域回收方式，保证了G1收集器在有限时间内可以获取竟可能高的手机效率。

   还有一点需要注意的是，虽然划分了多个Region进行隔离，但是Region之间不可能是孤立的。一个对象分配在某个Region中，他并非只能被本Region中的其他对象引用，而是可以与整个java堆中任意的对象发生引用关系。那么在做可达性确定对象是否存活的时候，岂不是还得扫描整个java堆才能保证准确性？这个问题并非在G1中才有，只是在G1中更加突出而已。在以前的分代收集中，新生代的规模一般都比老年代要小许多，新生代的收集比老年代的收集要频繁写，那么回收新生代的对象时也面临相同的问题，如果回收新生代时不得不扫描老年代的话，那么Minor GC的效率可能下降不少。

   在G1收集器中，Region之间的对象引用以及其他是机器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembed set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembed set，虚拟机发现程序在堆Reference类型的数据进行写操作时，会产生一个write barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代的对象是否一样了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用的对象所属的Region的Remembered set注解中。当进行内存回收时，在GC根及诶单的枚举范围中加入Remembered set即可保证不对全堆扫面也不会有遗漏。

   这种使用 `Region` 划分 **内存空间** 以及有 **优先级** 的区域回收方式，保证 `G1` 回收器在有限的时间内可以获得尽可能 **高的回收效率**。

   `G1` 和 `CMS` 运作过程有很多相似之处，整个过程也分为 `4` 个步骤：

   1. **初始标记（CMS initial mark）**

      **初始标记** 仅仅是标记 `GC Roots` 内 **直接关联** 的对象。这个阶段**速度很快**，需要 `Stop the World`。

   2. **并发标记（CMS concurrent mark）**

      **并发标记** 进行的是 `GC Tracing root`，从 `GC Roots` 开始对堆进行**可达性分析**，找出**存活对象**。这个阶段耗时比较长，但可以与用户线程并发运行。

   3. **最终标记（CMS remark）**

      **最终标记** 阶段为了**修正** 并发期间由于**用户进行运作** 导致的 **标记变动** 的那一部分对象的 **标记记录**。这个阶段的 **停顿时间** 一般会比 **初始标记阶段** 稍长一些，但远比 **并发标记** 的时间短，也需要 `Stop The World`。

   4. **筛选回收**

      首先对各个 `Region` 的 **回收价值** 和 **成本** 进行排序，根据用户所期望的 `GC` **停顿时间** 来制定回收计划。这个阶段是可以与用户程序一起 **并发执行**，但是因为只回收一部分 `Region`，时间是用户可控制的，而且停顿 **用户线程** 将大幅提高回收效率。

   具体的运行步骤如下图：

   ![upload successful](/images/pasted-281.png)

   **与其它 `GC` 回收相比，`G1` 具备如下 `4` 个特点：**

   - **并行与并发**

     使用多个 `CPU` 来缩短 `Stop-the-World` 的 **停顿时间**，部分其他回收器需要停顿 `Java` 线程执行的 `GC` 动作，`G1` 回收器仍然可以通过 **并发的方式** 让 `Java` 程序继续执行。

   - **分代回收**

     与其他回收器一样，**分代概念** 在 `G1` 中依然得以保留。虽然 `G1` 可以不需要 **其他回收器配合** 就能独立管理 **整个GC堆**，但它能够采用 **不同的策略** 去处理 **新创建的对象** 和 **已经存活** 一段时间、**熬过多次** `GC` 的旧对象，以获取更好的回收效果。**新生代** 和 **老年代** 不再是 **物理隔离**，是多个 **大小相等** 的独立 `Region`。

   - **空间整合**

     与 `CMS` 的 **标记—清理** 算法不同，`G1` 从 **整体** 来看是基于 **标记—整理** 算法实现的回收器。从 **局部**（两个 `Region` 之间）上来看是基于 **复制算法** 实现的。

     但无论如何，这 **两种算法** 都意味着 `G1` 运作期间 **不会产生内存空间碎片**，回收后能提供规整的可用内存。这种特性有利于程序长时间运行，**分配大对象** 时不会因为无法找到 **连续内存空间** 而提前触发 **下一次** `GC`。

   - **可预测的停顿**

     这是 `G1` 相对于 `CMS` 的另一大优势，**降低停顿时间** 是 `G1` 和 `CMS` 共同的关注点。`G1` 除了追求 **低停顿** 外，还能建立 **可预测** 的 **停顿时间模型**，能让使用者明确指定在一个 **长度** 为 `M` 毫秒的 **时间片段** 内，消耗在 **垃圾回收** 上的时间不得超过 `N` 毫秒。（后台维护的 **优先列表**，优先回收 **价值大** 的 `Region`）。


## 内存分配

上面主要说的是内存的回收，下面来讲解内存的分配，主要是在堆里面进行分配（也有可能经过JIT编译后被拆散为标量类型并间接地在栈上分配），堆里面主要是发生在新生代的Eden区中，少数情况下是在老年代中，分配的规则不是固定的，这需要根据当前使用的是哪种垃圾收集器组合还有虚拟机与内存相关的参数设置。

   1. **对象优先在Eden分配**
      大多数情况下，对象在新生代Eden区进行分配。当Eden区没有足够空间进行分配时JVM发生一次Minor GC。因为Java对象大多具备朝生夕死的特性，所以Minor GC非常频繁，当然了，其回收速度肯定也是比较快的，与之对应，还有个Full GC或者称为Major GC,是指老年代中的GC，经常会伴随一次Minor GC，Major GC速度一般会比Minor GC速度慢10倍以上！

   2. **大对象直接进入老年代**
      所谓的大对象，是指占用大量连续内存空间的Java对象。最经典的大对象就是那种很长的字符串和数组。大对象对于虚拟机来说是个坏消息,我们写程序时，尽量要避免出现一群朝生夕死的大对象。经常出现大对象容易导致内存还有不少空间时就得提前触发垃圾收集以获取足够的空间来存放大对象。

   3. **长期存活的对象将进入老年代**
      JVM采用分代收集思想来管理内存，就要去区分哪些是年轻代的对象，哪些是老年代的对象。我们知道，刚创建的对象肯定是年轻的对象，那么怎么将对象判断为老年代？

      在Eden区出生，并经过一次Minor GC后仍然存活，并且能被To Suvivor容纳，移动到To Suvivor区后，年龄设置为1。以后每经历一次Minor GC就将年龄加1，当它的年龄达到一个阀值（默认15，也可以更改-XX:MaxTenurinigThreshold来设置），就会被晋级到老年代中。

   4. **动态对象年龄判定**

      为了更好地适应不同程序内存情况，JVM并不一定是等到对象年龄达到阀值才将对象晋级到老年代。如果在Survivor空间中的相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年的对象就可以直接进入老年代，无需等到指定的阀值。这句话可能有点绕，不太好理解，我来再解释一下，就是说，假设Survivor的空间大小为max，年龄为y的对象总共有n个，如果y*n>max/2，那么所有年龄大于y的对象全部进入到老年代。

下面介绍一个概念，前面也提到过，就是**空间分配担保**
在发生Minor GC之前，虚拟机会先检查老年代可用的连续空间是否大于所有新生代的总空间，如果大于的话，那么这个GC就可以保证安全，如果不成立的，那么可能会造成晋升老年代的时候内存不足。在这样的情况下，虚拟机会先检查HandlePromotionFailure设置值是否允许担保失败，如果是允许的，那么说明虚拟机允许这样的风险存在并坚持运行，然后检查老年代的最大连续可用空间是否大于历次晋升老年代对象的平均大小，如果大于的话，就执行Minor GC,如果小于或者HandlePromotionFailure设置不允许冒险，那么就会先进行一次Full GC将老年代的内存清理出来，然后再判断。

上面提到的风险，是由于新生代因为存活对象采用复制算法，但为了内存利用率，只使用其中的一个Survivor空间，将存活的对象备份到Survivor空间上，一旦出现大量对象在一次Minor GC以后依然存活（最坏的计划就是没有发现有对象死亡需要清理），那么就需要老年代来分担一部分内存，把在Survivor上分配不下的对象直接进入老年代，因为我们不知道实际上具体需要多大内存，我们只能估算一个合理值，这个值采用的方法就是计算出每次晋升老年代的平均内存大小作为参考，如果需要的话，那就提前进行一次Full GC.

  取平均值在大多数情况下是可行的，但是因为内存分配的不确定性太多，保不定哪次运行突然出现某些大对象或者Minor GC以后多数对象依然存活，导致内存远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。这样的情况下，担保失败是要付出代价的，大部分情况下都还是会将HandlePromotionFailure开关打开，毕竟失败的几率比较小，这样的担保可以避免Full GC过于频繁，垃圾收集器频繁的启动肯定是不好的。在JDK6之后这是默认打开的

## 参考

1.  周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社
2. [JVM（九）内存分配策略](https://blog.csdn.net/liupeifeng3514/article/details/79183734)
3. [JVM系列(六) - JVM垃圾回收器](https://juejin.im/post/5b651200f265da0fa00a38d7#heading-20)
4. [JVM系列(五) - JVM垃圾回收算法](https://juejin.im/post/5b4dea755188251ac1098e98)
5. [聊聊JVM的年轻代](http://ifeve.com/jvm-yong-generation/)