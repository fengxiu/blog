---
title: 并发队列-无界非阻塞队列ConcurrentLinkedQueue原理探究
tags:
  - 并发队列
  - juc
categories:
  - java
  - juc
  - 队列
author: fengxiutianya
abbrlink: a75f3158
date: 2019-03-06 19:07:00
---

# 并发队列-无界非阻塞队列ConcurrentLinkedQueue原理探究

### 性能考虑

在轻度到中度的争用情况下，非阻塞算法的性能会超越阻塞算法，因为 CAS 的多数时间都在第一次尝试时就成功，而发生争用时的开销也不涉及线程挂起和上下文切换，只多了几个循环迭代。没有争用的 CAS 要比没有争用的锁便宜得多（这句话肯定是真的，因为没有争用的锁涉及 CAS 加上额外的处理），而争用的 CAS 比争用的锁获取涉及更短的延迟。

在高度争用的情况下（即有多个线程不断争用一个内存位置的时候），基于锁的算法开始提供比非阻塞算法更好的吞吐率，因为当线程阻塞时，它就会停止争用，耐心地等候轮到自己，从而避免了进一步争用。但是，这么高的争用程度并不常见，因为多数时候，线程会把线程本地的计算与争用共享数据的操作分开，从而给其他线程使用共享数据的机会。（这么高的争用程度也表明需要重新检查算法，朝着更少共享数据的方向努力。）[“流行的原子”](http://www.ibm.com/developerworks/cn/java/j-jtp11234/) 中的图在这方面就有点儿让人困惑，因为被测量的程序中发生的争用极其密集，看起来即使对数量很少的线程，锁定也是更好的解决方案。
<!-- more -->

## 非阻塞的链表

ArrayBlockingQueue和LinkedBlockingQueue都是阻塞算法，都使用了同步锁来保证线程安全。一旦掌握了在循环中使用 CAS，就可以容易地模仿它们。对于更复杂的数据结构，非阻塞算法要比这些简单示例复杂得多，因为修改链表、树或哈希表可能涉及对多个指针的更新。CAS 支持对单一指针的原子性条件更新，但是不支持两个以上的指针。所以，要构建一个非阻塞的链表、树或哈希表，需要找到一种方式，可以用 CAS 更新多个指针，同时不会让数据结构处于不一致的状态。

在链表的尾部插入元素，通常涉及对两个指针的更新：“尾” 指针总是指向列表中的最后一个元素，“下一个” 指针从过去的最后一个元素指向新插入的元素。因为需要更新两个指针，所以需要两个 CAS。在独立的 CAS 中更新两个指针带来了两个需要考虑的潜在问题：如果第一个 CAS 成功，而第二个 CAS 失败，会发生什么？如果其他线程在第一个和第二个 CAS 之间企图访问链表，会发生什么？

对于非复杂数据结构，构建非阻塞算法的 “技巧” 是确保数据结构总处于一致的状态（甚至包括在线程开始修改数据结构和它完成修改之间），还要确保其他线程不仅能够判断出第一个线程已经完成了更新还是处在更新的中途，还能够判断出如果第一个线程走向 AWOL（未经请假而离队），完成更新还需要什么操作。如果线程发现了处在更新中途的数据结构，它就可以 “帮助” 正在执行更新的线程完成更新，然后再进行自己的操作。当第一个线程回来试图完成自己的更新时，会发现不再需要了，返回即可，因为 CAS 会检测到帮助线程的干预（在这种情况下，是建设性的干预）。

这种 “帮助邻居” 的要求，对于让数据结构免受单个线程失败的影响，是必需的。如果线程发现数据结构正处在被其他线程更新的中途，然后就等候其他线程完成更新，那么如果其他线程在操作中途失败，这个线程就可能永远等候下去。即使不出现故障，这种方式也会提供糟糕的性能，因为新到达的线程必须放弃处理器，导致上下文切换，或者等到自己的时间片过期（而这更糟）。

具体的算法可以看java 中ConcurrentLinkedQueue，他就是借助于 Michael-Scott 非阻塞队列算法来实现的队列。

具体的原理探究可以看这篇文章[并发队列-无界非阻塞队列ConcurrentLinkedQueue原理探究](http://ifeve.com/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97-%E6%97%A0%E7%95%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97concurrentlinkedqueue%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/)讲的很棒，这里就不在重复的转载。



### 参考

[非阻塞算法简介](https://www.ibm.com/developerworks/cn/java/j-jtp04186/index.html)

[聊聊并发（六）——ConcurrentLinkedQueue 的实现原理分析](https://infoq.cn/article/ConcurrentLinkedQueue)