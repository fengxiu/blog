abbrlink: 24
title: JVM 垃圾回收算法
tags:
  - java
categories:
  - 垃圾回收
  - jvm
author: fengxiutianya
date: 2019-03-04 07:20:00
---
# JVM 垃圾回收算法

### 概述

通过前面介绍`Java`内存运行时区域，可以学习到**程序计数器**、**虚拟机栈**、**本地方法栈** 三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的**内存分配和回收**都具备**确定性**。在这几个区域内不需要过多考虑回收的问题，**因为方法结束或线程结束时，内存自然就跟随着回收了**。

而`Java`**堆** 和 **方法区** 则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样。我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分**内存的分配和回收**都是**动态的**，**垃圾收集器** 所关注的是这部分内存。

接下来我将会用俩篇文章来聊聊这部分内容，这篇文章主要讲解如何确定一个对象可以回收以及垃圾回收算法的种类，属于方法论，下一篇文章则主要介绍`JVM`中实现的垃圾回收器和内存分配回收策略。

1. 对象是否可以回收判定
2. 对象引用分类
3. finalize()二次标记
4. 垃圾回收算法

### 1.对象是否可以回收判定

要想回收对象，首先应该判定哪些对象活着哪些对象已经死去（不会再被使用的对象）

#### 1. 引用计数算法

`Java` **堆** 中每个具体对象（**不是引用**）都有一个**引用计数器**。当一个对象被创建并初始化赋值后，该变量计数设置为`1`。每当有一个地方引用它时，计数器值就**加1**。当引用**失效**时，即一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时，计数器值就**减1**。任何引用计数为`0`的对象可以被当作**垃圾收集**。当一个对象被垃圾收集时，它引用的任何对象计数减1。

- **优点**：

  引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利。

- **缺点**：

  难以检测出对象之间的循环引用。简单的说就是A对象内部引用了B对象，B对象内部引用了A对象同时，但是这俩个对象都不会在被使用，也就是对象已经死去，但是因为引用计数都是1，所以无法判定这俩个对象死去，也就无法回收。引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。

#### 2. 可达性分析算法

**可达性分析算法**也叫**根搜索算法**，通过一系列的称为 `GC Roots` 的对象作为起点，然后向下搜索。搜索所走过的**路径**称为引用链 （`Reference Chain`）， 当一个**对象**到 `GC Roots` 没有任何**引用链**相连时, 即该对象**不可达**，也就说明此对象是 **不可用的**。

如下图所示: `Object5`、`Object6`、`Object7` 虽然互有关联, 但它们到`GC Roots`是不可达的, 因此也会被判定为可回收的对象。

![upload successful](/images/pasted-134.png)

在`Java`中, 可作为`GC Roots`的对象包括以下四种：

- **虚拟机栈**（栈帧中的**本地变量表**）中引用的对象
- **本地方法栈** 中 `JNI` （`Native`方法）引用的变量
- **方法区** 中**类静态属性**引用的变量
- **方法区** 中**常量**引用的变量

JVM中用到的所有现代GC算法在回收前都会先找出所有仍存活的对象。可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图。下图展示的JVM中的内存布局可以用来很好地阐释这一概念：

![upload successful](/images/pasted-136.png)

### 2 对象引用分类

1. **强引用(Strong Reference)**

   在代码中普遍存在的，类似`Object obj = new Object()`这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。

2. **软引用(Sofe Reference)**

   **有用但并非必需** 的对象，可用`SoftReference`类来实现软引用。在系统将要发生**内存溢出异常**之前，将会把这些对象列进回收范围之中进行**二次回收**。如果这次回收还没有足够的内存，才会抛出内存溢出异常。

3. **弱引用(Weak Reference)

   **非必需** 的对象，但它的**强度**比软引用更弱，被弱引用关联的对象**只能**生存到下一次垃圾收集发生之前，`JDK`提供了`WeakReference`类来实现弱引用。无论当前内存是否足够，用软引用相关联的对象都会被回收掉。

4.  **虚引用(Phantom Reference)**

   虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系，`JDK`提供了`PhantomReference`类来实现虚引用。为一个对象设置虚引用的唯一目的是：能在这个对象在**垃圾回收器**回收时收到一个**系统通知**。

这部分就不具体的介绍，具体的可以查看这俩篇文章[Java Reference详解](https://taolove.top/posts/28002/)

### 3 finalize()二次标记

一个对象是否应该在垃圾回收器在`GC`时回收，至少要经历**两次标记过程**。

第一次标记过程，通过**可达性分析算法**分析对象是否与`GC Roots`可达。经过第一次标记，并且被筛选为**不可达**的对象会进行第二次标记。

第二次标记过程，判断不可达对象是否有必要执行`finalize`方法。执行条件是当前对象的`finalize`方法被重写，并且还未被系统调用过。如果允许执行那么这个对象将会被放到一个叫`F-Query`的队列中，等待被执行。

> **注意**：由于`finalize`由一个优先级比较低的`Finalizer`线程运行，所以该对象的的`finalize`方法不一定被执行，即使被执行了，也不保证`finalize`方法一定会执行完。如果对象第二次小规模标记，即`finalize`方法中拯救自己，只需要重新和引用链上的任一对象建立关联即可。

如果你对这一部分比较感兴趣，可以看看我写的这篇文章，里面详细讲解finalize的回收过程以及实现[JVM源码分析之 FinalReference 完全解读](https://taolove.top/posts/13502/)

### 4 垃圾回收算法

本节具体介绍一下各种垃圾回收算法的思想：（这里是结合java来进行的介绍）

#### 1. 标记-清除算法

标记-清除算法对**根集合**进行扫描，对**存活**的对象进行标记。标记完成后，再对整个空间内**未被标记**的对象扫描，进行回收。

- **优点**：

  实现简单，不需要进行对象进行移动。

- **缺点**：

  标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。

#### 2. 复制算法

这种收集算法解决了标记清除算法存在的效率问题。它将内存区域划分成相同的两个**内存块**。每次仅使用一半的空间，`JVM`生成的新对象放在一半空间中。当一半空间用完时进行`GC`，把可到达对象复制到另一半空间，然后把使用过的内存空间一次清理掉。

- **优点**：

  按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。

- **缺点**：

  可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。

  在很多的JVM虚拟机中都是采用这种回收算法来回收新生代对象，但是并不是按照上面介绍的1：1来分配复制区域，通常情况下，会划分成一个较大`Eden`区和两个较小`Survivor`区。每次使用`Eden`区和一个`Survivor`区。当回收时，会先将`Eden`区和`Survivor`区存活的对象复制到另外一个`Survivor`区。最后清理掉`Eden`区和刚才使用的`Survivor`区。HotSpot默认`Eden`区和`Survivor`区的大小比例是8：1，也就是用10%的空间浪费掉。

  另外就是存活的对象可能大于`Survivor`区的空间，这时就需要使用到老年代，将这部分存活的对象移动到老年代（这里说的不是很准确，因为牵扯到分配担保的问题，如果说了这个会使得这部分内容不好理解，所以放到下一篇中讲解，这里可以先这样理解）。

#### 3. 标记-整理算法

**标记-整理算法** 采用和 **标记-清除算法** 一样的方式进行对象的标记，但后续不直接对可回收对象进行清理，而是将所有的**存活对象**往一端**空闲空间**移动，然后清理掉端边界以外的内存空间。

- **优点**：

  解决了标记-清理算法存在的内存碎片问题。

- **缺点**：

  仍需要进行局部对象移动，一定程度上降低了效率。

#### 4. 分代收集算法

当前商业虚拟机都采用**分代收集**的垃圾收集算法。分代收集算法，顾名思义是根据对象的**存活周期**将内存划分为几块。一般包括**年轻代**、**老年代** 和 **永久代**，如图所示： 

![upload successful](/images/pasted-137.png)



1. **新生代（Young generation）**

   绝大多数最新被创建的对象会被分配到这里，由于**大部分对象**在创建后会很快变得**不可达**，所以很多对象被创建在**新生代**，然后**消失**。对象从这个区域消失的过程我们称之为 `minor GC`。

   **新生代** 中存在一个`Eden`区和两个`Survivor`区。新对象会首先分配在`Eden`中（如果新对象过大，会直接分配在老年代中）。在`GC`中，`Eden`中的对象会被移动到`Survivor`中，直至对象满足一定的年纪（定义为熬过`GC`的次数），会被移动到**老年代**。

   可以设置**新生代**和**老年代**的相对大小。这种方式的优点是新生代大小会随着整个**堆**大小**动态扩展**。参数 `-XX:NewRatio` 设置**老年代**与**新生代**的比例。例如 `-XX:NewRatio=8` 指定 **老年代/新生代** 为`8/1`. **老年代** 占堆大小的 `7/8` ，**新生代** 占堆大小的 `1/8`（默认即是 `1/8`）。

   例如：

```
-XX:NewSize=64m -XX:MaxNewSize=1024m -XX:NewRatio=8
复制代码
```

2. **老年代（Old generation）**

   对象没有变得不可达，并且从新生代中**存活**下来，会被**拷贝**到这里。其所占用的空间要比新生代多。也正由于其相对**较大的空间**，发生在**老年代**上的`GC`要比**新生代**要**少得多**。对象从**老年代**中消失的过程，可以称之为`major GC`（或者`full GC`）。

3. **永久代（permanent generation）**

   像一些**类的层级信息**，**方法数据** 和**方法信息**（如**字节码**，**栈** 和 **变量大小**），**运行时常量池**（`JDK7`之后移出**永久代**），已确定的**符号引用**和**虚方法表**等等。它们几乎都是**静态的**并且**很少**被**卸载和回收**，在`JDK8`之前的`HotSpot`虚拟机中，类的这些**“永久的”** 数据存放在一个叫做**永久代**的区域

   永久代一段**连续的内存空间**，我们在`JVM`启动之前可以通过设置`-XX:MaxPermSize`的值来控制永久代的大小。但是`JDK8`之后取消了永久代，这些**元数据**被移到了一个与堆**不相连**的称为**元空间** (`Metaspace`) 的**本地内存区域**。

   在这里补充一点，这部分内存其实也会被回收，但是在这里垃圾回收的效率很低。永久代的垃圾主要回收俩部分：废弃常量和无用的类。回收废弃常量和回收java堆中的对象非常相似，只要这个常量不会再被使用到就可以被回收。但是判断一个类是否可以回收则比较苛刻，类需要同时满足以下三个条件才能算是无用的类：

   * 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
   * 加载该类的ClassLoader已经被回收
   * 该类对应的java.lang.Class对象没有任何地方被引用。无法在任何地方通过反射获取到改class。

   即使满足了上面的三个条件也只是达到可以回收的条件，这里仅仅是可以，而不是像对象一样，不使用了就必然回收。

   通过上面的介绍你大概可以感受到回收永久代的性价比很低。

### 参考

1. 周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社

2. [JVM系列(五) - JVM垃圾回收算法](https://juejin.im/post/5b4dea755188251ac1098e98)