{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/pasted-11.png","path":"images/pasted-11.png","modified":0,"renderable":0},{"_id":"source/images/pasted-13.png","path":"images/pasted-13.png","modified":0,"renderable":0},{"_id":"source/images/pasted-2.png","path":"images/pasted-2.png","modified":0,"renderable":0},{"_id":"source/images/pasted-18.png","path":"images/pasted-18.png","modified":0,"renderable":0},{"_id":"source/images/pasted-30.png","path":"images/pasted-30.png","modified":0,"renderable":0},{"_id":"source/images/pasted-31.png","path":"images/pasted-31.png","modified":0,"renderable":0},{"_id":"source/images/pasted-32.png","path":"images/pasted-32.png","modified":0,"renderable":0},{"_id":"source/images/pasted-33.png","path":"images/pasted-33.png","modified":0,"renderable":0},{"_id":"source/images/pasted-34.png","path":"images/pasted-34.png","modified":0,"renderable":0},{"_id":"source/images/pasted-3.png","path":"images/pasted-3.png","modified":0,"renderable":0},{"_id":"source/images/pasted-36.png","path":"images/pasted-36.png","modified":0,"renderable":0},{"_id":"source/images/pasted-38.png","path":"images/pasted-38.png","modified":0,"renderable":0},{"_id":"source/images/pasted-39.png","path":"images/pasted-39.png","modified":0,"renderable":0},{"_id":"source/images/pasted-4.png","path":"images/pasted-4.png","modified":0,"renderable":0},{"_id":"source/images/pasted-40.png","path":"images/pasted-40.png","modified":0,"renderable":0},{"_id":"source/images/pasted-41.png","path":"images/pasted-41.png","modified":0,"renderable":0},{"_id":"source/images/pasted-43.png","path":"images/pasted-43.png","modified":0,"renderable":0},{"_id":"source/images/pasted-44.png","path":"images/pasted-44.png","modified":0,"renderable":0},{"_id":"source/images/pasted-42.png","path":"images/pasted-42.png","modified":0,"renderable":0},{"_id":"source/images/pasted-46.png","path":"images/pasted-46.png","modified":0,"renderable":0},{"_id":"source/images/pasted-45.png","path":"images/pasted-45.png","modified":0,"renderable":0},{"_id":"source/images/pasted-47.png","path":"images/pasted-47.png","modified":0,"renderable":0},{"_id":"source/images/pasted-48.png","path":"images/pasted-48.png","modified":0,"renderable":0},{"_id":"source/images/pasted-5.png","path":"images/pasted-5.png","modified":0,"renderable":0},{"_id":"source/images/pasted-49.png","path":"images/pasted-49.png","modified":0,"renderable":0},{"_id":"source/images/pasted-50.png","path":"images/pasted-50.png","modified":0,"renderable":0},{"_id":"source/images/pasted-51.png","path":"images/pasted-51.png","modified":0,"renderable":0},{"_id":"source/images/pasted-52.png","path":"images/pasted-52.png","modified":0,"renderable":0},{"_id":"source/images/pasted-54.png","path":"images/pasted-54.png","modified":0,"renderable":0},{"_id":"source/images/pasted-53.png","path":"images/pasted-53.png","modified":0,"renderable":0},{"_id":"source/images/pasted-55.png","path":"images/pasted-55.png","modified":0,"renderable":0},{"_id":"source/images/pasted-58.png","path":"images/pasted-58.png","modified":0,"renderable":0},{"_id":"source/images/pasted-56.png","path":"images/pasted-56.png","modified":0,"renderable":0},{"_id":"source/images/pasted-57.png","path":"images/pasted-57.png","modified":0,"renderable":0},{"_id":"source/images/pasted-59.png","path":"images/pasted-59.png","modified":0,"renderable":0},{"_id":"source/images/pasted-60.png","path":"images/pasted-60.png","modified":0,"renderable":0},{"_id":"source/images/pasted-6.png","path":"images/pasted-6.png","modified":0,"renderable":0},{"_id":"source/images/pasted-61.png","path":"images/pasted-61.png","modified":0,"renderable":0},{"_id":"source/images/pasted-63.png","path":"images/pasted-63.png","modified":0,"renderable":0},{"_id":"source/images/pasted-64.png","path":"images/pasted-64.png","modified":0,"renderable":0},{"_id":"source/images/pasted-67.png","path":"images/pasted-67.png","modified":0,"renderable":0},{"_id":"source/images/pasted-68.png","path":"images/pasted-68.png","modified":0,"renderable":0},{"_id":"source/images/pasted-69.png","path":"images/pasted-69.png","modified":0,"renderable":0},{"_id":"source/images/pasted-7.png","path":"images/pasted-7.png","modified":0,"renderable":0},{"_id":"source/images/pasted-70.png","path":"images/pasted-70.png","modified":0,"renderable":0},{"_id":"source/images/pasted-8.png","path":"images/pasted-8.png","modified":0,"renderable":0},{"_id":"source/images/pasted-10.png","path":"images/pasted-10.png","modified":0,"renderable":0},{"_id":"source/images/pasted-1.png","path":"images/pasted-1.png","modified":0,"renderable":0},{"_id":"source/images/pasted-23.png","path":"images/pasted-23.png","modified":0,"renderable":0},{"_id":"source/images/pasted-25.png","path":"images/pasted-25.png","modified":0,"renderable":0},{"_id":"source/images/pasted-35.png","path":"images/pasted-35.png","modified":0,"renderable":0},{"_id":"source/images/pasted-62.png","path":"images/pasted-62.png","modified":0,"renderable":0},{"_id":"source/images/pasted-65.png","path":"images/pasted-65.png","modified":0,"renderable":0},{"_id":"source/images/pasted-71.png","path":"images/pasted-71.png","modified":0,"renderable":0},{"_id":"source/images/pasted-78.png","path":"images/pasted-78.png","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-apollo.js","path":"plugins/prettify/lang-apollo.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-basic.js","path":"plugins/prettify/lang-basic.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-dart.js","path":"plugins/prettify/lang-dart.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-clj.js","path":"plugins/prettify/lang-clj.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-erlang.js","path":"plugins/prettify/lang-erlang.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-css.js","path":"plugins/prettify/lang-css.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-kotlin.js","path":"plugins/prettify/lang-kotlin.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-go.js","path":"plugins/prettify/lang-go.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-ex.js","path":"plugins/prettify/lang-ex.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-hs.js","path":"plugins/prettify/lang-hs.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-lisp.js","path":"plugins/prettify/lang-lisp.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-llvm.js","path":"plugins/prettify/lang-llvm.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-logtalk.js","path":"plugins/prettify/lang-logtalk.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-lua.js","path":"plugins/prettify/lang-lua.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-ml.js","path":"plugins/prettify/lang-ml.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-mumps.js","path":"plugins/prettify/lang-mumps.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-n.js","path":"plugins/prettify/lang-n.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-pascal.js","path":"plugins/prettify/lang-pascal.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-proto.js","path":"plugins/prettify/lang-proto.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-r.js","path":"plugins/prettify/lang-r.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-rd.js","path":"plugins/prettify/lang-rd.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-rust.js","path":"plugins/prettify/lang-rust.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-scala.js","path":"plugins/prettify/lang-scala.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-sql.js","path":"plugins/prettify/lang-sql.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-tcl.js","path":"plugins/prettify/lang-tcl.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-swift.js","path":"plugins/prettify/lang-swift.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-tex.js","path":"plugins/prettify/lang-tex.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-vb.js","path":"plugins/prettify/lang-vb.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-vhdl.js","path":"plugins/prettify/lang-vhdl.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-wiki.js","path":"plugins/prettify/lang-wiki.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-yaml.js","path":"plugins/prettify/lang-yaml.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-xq.js","path":"plugins/prettify/lang-xq.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/prettify.css","path":"plugins/prettify/prettify.css","modified":0,"renderable":0},{"_id":"source/plugins/prettify/node_prettify.js","path":"plugins/prettify/node_prettify.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/prettify.js","path":"plugins/prettify/prettify.js","modified":0,"renderable":0},{"_id":"source/uploads/img/avatar.jpg","path":"uploads/img/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/pasted-12.png","path":"images/pasted-12.png","modified":0,"renderable":0},{"_id":"source/images/pasted-24.png","path":"images/pasted-24.png","modified":0,"renderable":0},{"_id":"source/images/pasted-9.png","path":"images/pasted-9.png","modified":0,"renderable":0},{"_id":"source/images/pasted-97.png","path":"images/pasted-97.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"source/plugins/prettify/lang-lasso.js","path":"plugins/prettify/lang-lasso.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-matlab.js","path":"plugins/prettify/lang-matlab.js","modified":0,"renderable":0},{"_id":"source/images/pasted-0.png","path":"images/pasted-0.png","modified":0,"renderable":0},{"_id":"source/plugins/prettify/run_prettify.js","path":"plugins/prettify/run_prettify.js","modified":0,"renderable":0},{"_id":"source/images/pasted-14.png","path":"images/pasted-14.png","modified":0,"renderable":0},{"_id":"source/images/pasted-85.png","path":"images/pasted-85.png","modified":0,"renderable":0},{"_id":"source/images/pasted-66.png","path":"images/pasted-66.png","modified":0,"renderable":0},{"_id":"source/images/pasted-72.png","path":"images/pasted-72.png","modified":0,"renderable":0},{"_id":"source/images/pasted-73.png","path":"images/pasted-73.png","modified":0,"renderable":0},{"_id":"source/images/pasted-74.png","path":"images/pasted-74.png","modified":0,"renderable":0},{"_id":"source/images/pasted-75.png","path":"images/pasted-75.png","modified":0,"renderable":0},{"_id":"source/images/pasted-79.png","path":"images/pasted-79.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/LICENSE","path":"lib/algolia-instant-search/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/README.md","path":"lib/algolia-instant-search/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"source/images/pasted-20.png","path":"images/pasted-20.png","modified":0,"renderable":0},{"_id":"source/images/pasted-22.png","path":"images/pasted-22.png","modified":0,"renderable":0},{"_id":"source/images/pasted-28.png","path":"images/pasted-28.png","modified":0,"renderable":0},{"_id":"source/images/pasted-26.png","path":"images/pasted-26.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"source/images/pasted-86.png","path":"images/pasted-86.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"source/images/pasted-103.png","path":"images/pasted-103.png","modified":0,"renderable":0},{"_id":"source/images/pasted-130.png","path":"images/pasted-130.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"source/images/pasted-17.png","path":"images/pasted-17.png","modified":0,"renderable":0},{"_id":"source/images/pasted-29.png","path":"images/pasted-29.png","modified":0,"renderable":0},{"_id":"source/images/pasted-76.png","path":"images/pasted-76.png","modified":0,"renderable":0},{"_id":"source/images/pasted-129.png","path":"images/pasted-129.png","modified":0,"renderable":0},{"_id":"source/images/pasted-27.png","path":"images/pasted-27.png","modified":0,"renderable":0},{"_id":"source/images/pasted-77.png","path":"images/pasted-77.png","modified":0,"renderable":0},{"_id":"source/images/pasted-96.png","path":"images/pasted-96.png","modified":0,"renderable":0},{"_id":"source/images/pasted-98.png","path":"images/pasted-98.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"source/images/pasted-102.png","path":"images/pasted-102.png","modified":0,"renderable":0},{"_id":"source/images/pasted-114.png","path":"images/pasted-114.png","modified":0,"renderable":0},{"_id":"source/images/pasted-116.png","path":"images/pasted-116.png","modified":0,"renderable":0},{"_id":"source/images/pasted-117.png","path":"images/pasted-117.png","modified":0,"renderable":0},{"_id":"source/images/pasted-120.png","path":"images/pasted-120.png","modified":0,"renderable":0},{"_id":"source/images/pasted-121.png","path":"images/pasted-121.png","modified":0,"renderable":0},{"_id":"source/images/pasted-19.png","path":"images/pasted-19.png","modified":0,"renderable":0},{"_id":"source/images/pasted-21.png","path":"images/pasted-21.png","modified":0,"renderable":0},{"_id":"source/images/pasted-82.png","path":"images/pasted-82.png","modified":0,"renderable":0},{"_id":"source/images/pasted-90.png","path":"images/pasted-90.png","modified":0,"renderable":0},{"_id":"source/images/pasted-115.png","path":"images/pasted-115.png","modified":0,"renderable":0},{"_id":"source/images/pasted-125.png","path":"images/pasted-125.png","modified":0,"renderable":0},{"_id":"source/images/pasted-126.png","path":"images/pasted-126.png","modified":0,"renderable":0},{"_id":"source/images/pasted-15.png","path":"images/pasted-15.png","modified":0,"renderable":0},{"_id":"source/images/pasted-88.png","path":"images/pasted-88.png","modified":0,"renderable":0},{"_id":"source/images/pasted-91.png","path":"images/pasted-91.png","modified":0,"renderable":0},{"_id":"source/images/pasted-94.png","path":"images/pasted-94.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"source/images/pasted-109.png","path":"images/pasted-109.png","modified":0,"renderable":0},{"_id":"source/images/pasted-123.png","path":"images/pasted-123.png","modified":0,"renderable":0},{"_id":"source/images/pasted-128.png","path":"images/pasted-128.png","modified":0,"renderable":0},{"_id":"source/images/pasted-84.png","path":"images/pasted-84.png","modified":0,"renderable":0},{"_id":"source/images/pasted-92.png","path":"images/pasted-92.png","modified":0,"renderable":0},{"_id":"source/images/pasted-100.png","path":"images/pasted-100.png","modified":0,"renderable":0},{"_id":"source/images/pasted-104.png","path":"images/pasted-104.png","modified":0,"renderable":0},{"_id":"source/images/pasted-111.png","path":"images/pasted-111.png","modified":0,"renderable":0},{"_id":"source/images/pasted-16.png","path":"images/pasted-16.png","modified":0,"renderable":0},{"_id":"source/images/pasted-81.png","path":"images/pasted-81.png","modified":0,"renderable":0},{"_id":"source/images/pasted-80.png","path":"images/pasted-80.png","modified":0,"renderable":0},{"_id":"source/images/pasted-87.png","path":"images/pasted-87.png","modified":0,"renderable":0},{"_id":"source/images/pasted-89.png","path":"images/pasted-89.png","modified":0,"renderable":0},{"_id":"source/images/pasted-93.png","path":"images/pasted-93.png","modified":0,"renderable":0},{"_id":"source/images/pasted-99.png","path":"images/pasted-99.png","modified":0,"renderable":0},{"_id":"source/images/pasted-101.png","path":"images/pasted-101.png","modified":0,"renderable":0},{"_id":"source/images/pasted-105.png","path":"images/pasted-105.png","modified":0,"renderable":0},{"_id":"source/images/pasted-106.png","path":"images/pasted-106.png","modified":0,"renderable":0},{"_id":"source/images/pasted-112.png","path":"images/pasted-112.png","modified":0,"renderable":0},{"_id":"source/images/pasted-118.png","path":"images/pasted-118.png","modified":0,"renderable":0},{"_id":"source/images/pasted-122.png","path":"images/pasted-122.png","modified":0,"renderable":0},{"_id":"source/images/pasted-108.png","path":"images/pasted-108.png","modified":0,"renderable":0},{"_id":"source/images/pasted-127.png","path":"images/pasted-127.png","modified":0,"renderable":0},{"_id":"source/images/pasted-119.png","path":"images/pasted-119.png","modified":0,"renderable":0},{"_id":"source/images/pasted-110.png","path":"images/pasted-110.png","modified":0,"renderable":0},{"_id":"source/images/pasted-107.png","path":"images/pasted-107.png","modified":0,"renderable":0},{"_id":"source/images/pasted-37.png","path":"images/pasted-37.png","modified":0,"renderable":0},{"_id":"source/images/pasted-124.png","path":"images/pasted-124.png","modified":0,"renderable":0},{"_id":"source/images/pasted-83.png","path":"images/pasted-83.png","modified":0,"renderable":0},{"_id":"source/images/pasted-95.png","path":"images/pasted-95.png","modified":0,"renderable":0},{"_id":"source/images/pasted-113.png","path":"images/pasted-113.png","modified":0,"renderable":0},{"_id":"source/images/pasted-132.png","path":"images/pasted-132.png","modified":1,"renderable":0},{"_id":"source/images/pasted-133.png","path":"images/pasted-133.png","modified":1,"renderable":0},{"_id":"source/images/pasted-131.png","path":"images/pasted-131.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"c3ddb78d56d8afb1de43766a962b58378cd300c2","modified":1545966351620},{"_id":"source/.DS_Store","hash":"2956795e1069aff90f5b8211d3d31e5992592fe3","modified":1547535356180},{"_id":"themes/next/.all-contributorsrc","hash":"e32dc4075e304af04b98d0726d489081bea722c0","modified":1546588351793},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1546588351793},{"_id":"themes/next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1546588351796},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1546588351794},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1546588351794},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1546588351796},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1546588351796},{"_id":"themes/next/_config.yml","hash":"5f9fd6b2f22494608b3535ab3d44d05f74b4be54","modified":1546590978212},{"_id":"themes/next/README.md","hash":"b4f780a96b0e5d3737eb93bc00da6de91f042c4b","modified":1546588351797},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1546588351797},{"_id":"themes/next/bower.json","hash":"09628558259cf990fac43ed1f5ef9edae73f124b","modified":1546588351798},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1546588351798},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1546588351805},{"_id":"themes/next/package.json","hash":"c791b45d1e6fde11a1e1e11ba5a6ced1f5ba0fce","modified":1546588351824},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1546588351794},{"_id":"source/_discarded/hello-world.md","hash":"202a20f1ba49668b3709f06599583a8d017be807","modified":1545980330760},{"_id":"source/_discarded/test.md","hash":"5f80c6aa2e6352ee670d73cf2e422320f0555223","modified":1546408219798},{"_id":"source/_drafts/Untitled.md","hash":"54d25064776cc5bab8c528c008c57a2750de70d9","modified":1550472064000},{"_id":"source/_discarded/测试视频.md","hash":"7dac0e72398556690c1f694c6589b22e06111a78","modified":1546407478761},{"_id":"source/_posts/JVM源码分析之-FinalReference完全解读.md","hash":"47b4be00797b9f2174ee7561177a83d337872f08","modified":1546588273063},{"_id":"source/_posts/Java CompletableFuture 详解.md","hash":"47fa73b0743d7b819cedbc511b7eab63682b1cc4","modified":1546593541907},{"_id":"source/_posts/Java-Reference详解.md","hash":"565f0ae5fba426cf0b6499ceb836ec37b7d93f16","modified":1546588273064},{"_id":"source/_posts/.DS_Store","hash":"9743940311c67da829dd16f78a77bc3ee478459d","modified":1547535382462},{"_id":"source/_posts/Random 与 ThreadLocalRandom 对比.md","hash":"5dfe46698a86596894a91866bdd84509a806d9fb","modified":1546567138210},{"_id":"source/_posts/LockSupport.md","hash":"d0b36bacc3daf04a11ff03d094778022fa60a545","modified":1546566539316},{"_id":"source/_posts/String、StringBuffer和StringBuilder对比.md","hash":"4d98b5de2adc7c15400ec28b78a6b8fa2a1f164e","modified":1546408219800},{"_id":"source/_posts/java 中 Iterator 和 Iterable 区别.md","hash":"331874f7332733ce0ccf7c782e14508d1c091509","modified":1546566539318},{"_id":"source/_posts/java 多线系列之 04 线程让步和join.md","hash":"139e07004fddbb1529b76bce342b80182e4090c1","modified":1546566539318},{"_id":"source/_posts/java 打包技术之jar文件.md","hash":"095cd92982d748840d3e91efa10db6655fc08376","modified":1547432496469},{"_id":"source/_posts/super 和 extends.md","hash":"ef4e3b8819bc6df90919b8a0306437ca03147548","modified":1546566539323},{"_id":"source/_posts/伪缓存.md","hash":"f4989799c66406b17281669213a73763d60461cc","modified":1546566539324},{"_id":"source/_posts/使用-Travis-CI-自动更新-GitHub-Pages.md","hash":"2b2d6c9e1fc85df1e37c545fc1ca453df54205f9","modified":1546408219800},{"_id":"source/_posts/内部类.md","hash":"f5cdb480428dee2d28f0a60ceb2d4f784f65531d","modified":1546566539324},{"_id":"source/_posts/枚举初探.md","hash":"d3ec01acfad646892338f9a65f5e11b5225aad80","modified":1546566539324},{"_id":"source/_posts/深入分析ThreadLocal.md","hash":"ed44507140a354073aa885a8c6ddc887e37c159e","modified":1546407478763},{"_id":"source/_posts/自旋锁.md","hash":"ec8828c5884a7d672f8219f01d1d6a2402c4cf2f","modified":1546408219801},{"_id":"source/_posts/虚拟内存.md","hash":"5ffdc674283cdab3b00b425203f4b35b57d05686","modified":1546566539325},{"_id":"source/about/index.html","hash":"3da0683d9fac971c9072a727a6d6623b12890669","modified":1546407478764},{"_id":"source/categories/index.md","hash":"79cd584ef9d28b5afbd1836b345ab5648d6f7fed","modified":1545980134150},{"_id":"source/_discarded/String、StringBuffer和StringBuilder对比.md","hash":"1b11dc203cdda7a8b1683e485fde9c17a947447d","modified":1546407478760},{"_id":"source/tags/index.md","hash":"de2c4bea11d42170dabebd5ecfc7551e86759c4b","modified":1545980134151},{"_id":"source/uploads/.DS_Store","hash":"b071dd0a0152009c5d1b904a5c53707f072719fc","modified":1547444642774},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1547437844258},{"_id":"source/images/pasted-11.png","hash":"f91dad10da6e5a6b7c3461998d2893b836bbd630","modified":1547445579345},{"_id":"source/images/pasted-13.png","hash":"48e6e7a8777b686471a505c561135907dd2299d7","modified":1547473040069},{"_id":"source/images/pasted-2.png","hash":"6a8659805db44ecfa2e19fcc84baece617b816bb","modified":1547435139427},{"_id":"source/images/pasted-18.png","hash":"ea10a7a09312c7f02425e76d3b8d8c1f7eaeea6d","modified":1547532806099},{"_id":"source/images/pasted-30.png","hash":"f7c5e909929d54dbda1ede33e0e0d33959cf17a3","modified":1547971346660},{"_id":"source/images/pasted-31.png","hash":"f7c5e909929d54dbda1ede33e0e0d33959cf17a3","modified":1547971358270},{"_id":"source/images/pasted-32.png","hash":"528390754b3d963c1e27769a8b8beacc5021681b","modified":1547971636947},{"_id":"source/images/pasted-33.png","hash":"528390754b3d963c1e27769a8b8beacc5021681b","modified":1547971644950},{"_id":"source/images/pasted-34.png","hash":"c813bfa9a4cdb4d7ab79e55a575c1fa81923e305","modified":1547971856181},{"_id":"source/images/pasted-3.png","hash":"f8ea4e210aead0ed4e1535329113b23212c712aa","modified":1547435179330},{"_id":"source/images/pasted-36.png","hash":"549b96b9f9461ea6b9f656bbde12d0d9abea3aaa","modified":1547972322876},{"_id":"source/images/pasted-38.png","hash":"efec35af64e0bbae7e3ffb3eb59810f2a311141b","modified":1547973203120},{"_id":"source/images/pasted-39.png","hash":"d442eda15ba4bbf35d59fceb9b15aaed06041d22","modified":1547973214279},{"_id":"source/images/pasted-4.png","hash":"17532b57db57ff549224bfd4602f9d902fd4ea51","modified":1547435189014},{"_id":"source/images/pasted-40.png","hash":"4e15a9ddc14422103af6ad01e3704aebc5a7b824","modified":1547973428711},{"_id":"source/images/pasted-41.png","hash":"4e15a9ddc14422103af6ad01e3704aebc5a7b824","modified":1547973429943},{"_id":"source/images/pasted-43.png","hash":"5a315e03c5454d64f257416538f63d1bb581430f","modified":1547974249580},{"_id":"source/images/pasted-44.png","hash":"b1dfe7224472fc484fd1a5e5eff266056db15d5a","modified":1547974444994},{"_id":"source/images/pasted-42.png","hash":"54a24efbc2cc4421ad6292db68f56c3b38664e8d","modified":1547973664547},{"_id":"source/images/pasted-46.png","hash":"873698287cbff6192aed7ba77fd5ebbbcf030e4f","modified":1547974541514},{"_id":"source/images/pasted-45.png","hash":"59e47558e8c093872617f981124669682bb7bacc","modified":1547974518646},{"_id":"source/images/pasted-47.png","hash":"53a8cdefe1ee79ea10bb67d01178747ef20cca9a","modified":1547974551412},{"_id":"source/images/pasted-48.png","hash":"c769740d4d36469223a614c1a62c0627427c931c","modified":1547974558595},{"_id":"source/images/pasted-5.png","hash":"ec95990561615b2990460ac87f2c1abc61fa9426","modified":1547435830144},{"_id":"source/images/pasted-49.png","hash":"81d46ccb1a84d1afc5d0adb0334e5c99948eded9","modified":1547974565911},{"_id":"source/images/pasted-50.png","hash":"8718dff38108bd7122c14aac6468e59a2d4b7e43","modified":1547974581130},{"_id":"source/images/pasted-51.png","hash":"0fa7d7739fa6c84c6024e56c862cf0e3a0b00c9a","modified":1547974588551},{"_id":"source/images/pasted-52.png","hash":"602f73ced7f3bfc4cd7f6fadfd74f4d286b7470b","modified":1547974595226},{"_id":"source/images/pasted-54.png","hash":"11207cfda75d4f3c6f4efd8637b9d14e88d26aba","modified":1547974610405},{"_id":"source/images/pasted-53.png","hash":"7066b45fb067aaa7e21454b94fe2e83bc6fb013a","modified":1547974601714},{"_id":"source/images/pasted-55.png","hash":"c49e42015ea10ba34857d9418b66aba763f3db5d","modified":1547974621731},{"_id":"source/images/pasted-58.png","hash":"804ae6f5969ba2e0d23a1f1d5b56cafd9db6e3d9","modified":1547974752644},{"_id":"source/images/pasted-56.png","hash":"c3a17a4de9f75074fbcd88ce71db943bee934e14","modified":1547974627901},{"_id":"source/images/pasted-57.png","hash":"31f97c17e97dc37f0b523e7cca3992fb7f825800","modified":1547974744816},{"_id":"source/images/pasted-59.png","hash":"743ca4ad558f24139468bf12777c0f2bfe40dd62","modified":1547974758929},{"_id":"source/images/pasted-60.png","hash":"743ca4ad558f24139468bf12777c0f2bfe40dd62","modified":1547974765586},{"_id":"source/images/pasted-6.png","hash":"941621862e64d203c3f7afc06d41bcf414849f49","modified":1547437256316},{"_id":"source/images/pasted-61.png","hash":"ef93ca7a38b03ccc74248bc42729a65dd1974e9a","modified":1547974773034},{"_id":"source/images/pasted-63.png","hash":"36f7e32e4aaf8a44440f2c93b8d6cdcda737c91a","modified":1547974796486},{"_id":"source/images/pasted-64.png","hash":"c371067a912af02484a4d367c5f7133aa1ea153f","modified":1547974822100},{"_id":"source/images/pasted-67.png","hash":"c1f65a559a89f43e1f57184442c4212e9e2790bd","modified":1547975218157},{"_id":"source/images/pasted-68.png","hash":"8b9a1c3c6362dd145aff7313f4d49214cb32d212","modified":1547975270330},{"_id":"source/images/pasted-69.png","hash":"2e070d576e65271667fd3f333fc77399e761e5c6","modified":1547975334134},{"_id":"source/images/pasted-7.png","hash":"829e30bf16f791ba059fa2218e59822ee3c1e6e6","modified":1547437272890},{"_id":"source/images/pasted-70.png","hash":"2ff0186bd9d75b4fc4d4c8acc59334defdb59010","modified":1547975358797},{"_id":"source/images/pasted-8.png","hash":"3eaa9111042ed5a9d25fc8e5f1a02ae66d26f740","modified":1547437778147},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1546588351799},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1546588351799},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1546588351799},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1546588351800},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1546588351800},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1546588351800},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1546588351800},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1546588351801},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1546588351805},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1546588351806},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1546588351806},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1546588351806},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1546588351806},{"_id":"themes/next/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1546588351806},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1546588351806},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1546588351807},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1546588351807},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1546588351807},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1546588351807},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1546588351807},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1546588351808},{"_id":"themes/next/languages/uk.yml","hash":"1eb59e581568da9a81d6e20541b4ada5fc1c55c0","modified":1546588351808},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1546588351808},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1546588351808},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1546588351809},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1546588351809},{"_id":"themes/next/layout/_layout.swig","hash":"b894a3764076a8f8bd8aa18c5aefaaaa91b50585","modified":1546588915087},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1546588351823},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1546588351823},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1546588351823},{"_id":"themes/next/layout/page.swig","hash":"2d0e80e8a4dcba665704882b9dc5858c187acc31","modified":1546588351823},{"_id":"themes/next/layout/post.swig","hash":"f74929fd792541916eb25c2addfb35431be071ba","modified":1546588351824},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1546588351824},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1546588351824},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1546588351825},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1546588351825},{"_id":"themes/next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1546588351801},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1546588351864},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1546588351865},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1546588351865},{"_id":"source/images/pasted-10.png","hash":"9b9c41bcdb1c3d981aa90f3cda8b5b21d7f38db2","modified":1547442985565},{"_id":"source/images/pasted-1.png","hash":"c2dbe92d1f5a02e5fba942eb0c28e70042958b8f","modified":1547435247188},{"_id":"source/images/pasted-23.png","hash":"36196f85b5e49afae09d337ed14a1cf69f320df2","modified":1547537359499},{"_id":"source/images/pasted-25.png","hash":"46324a419ef23d06bfa39f9a4690891fc3d78d6f","modified":1547538099302},{"_id":"source/images/pasted-35.png","hash":"5d3a8ec7c4dbf613393b809dedb1a45a7c487b7b","modified":1547972249903},{"_id":"source/images/pasted-62.png","hash":"5ca8d9a3810329d3efc8e1e48895569edce9db54","modified":1547974784558},{"_id":"source/images/pasted-65.png","hash":"f7ee132797cc71eab6eede10e4ba3602d0117e03","modified":1547975101535},{"_id":"source/images/pasted-71.png","hash":"6afa199d748a1e632920d252fe50475caff124ab","modified":1548317193480},{"_id":"source/images/pasted-78.png","hash":"44f18a0f6a09c821907ac8477610b5af91f189c4","modified":1548400893769},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546588351849},{"_id":"source/_posts/juc/.DS_Store","hash":"365725951c1e43a0c20e11ebc85a2249987fee75","modified":1547523024770},{"_id":"source/_posts/nio/JAVA NIO之浅谈内存映射文件原理与DirectBuffer.md","hash":"9aefdd04e7c436fab2b318a250cccf2fd9bb3b8b","modified":1547455208310},{"_id":"source/_posts/threads/java多线程系列 01基本概念以及实现方式.md","hash":"56486ee9797cd0cd41e2501a77a53b708fdab160","modified":1546566539319},{"_id":"source/_posts/spring 源码分析/.DS_Store","hash":"2eca2a7b6d28a8a6f12e18acc1d0b3c0a8c71aa5","modified":1547549034851},{"_id":"source/_posts/threads/java多线程系列 02 synchronized 关键字.md","hash":"a5621376d58d8f4439eca366bbf092ae17b90626","modified":1546566539319},{"_id":"source/_posts/threads/java多线程系列 03 线程等待与唤醒，线程休眠.md","hash":"cfa3f6809c9ddfbba436dff4e6140f168f2977a3","modified":1546566539320},{"_id":"source/_posts/threads/java多线程系列 05 interrupt()和线程终止方式.md","hash":"faa7f0842b19076d00db49626c9de8093a1e7422","modified":1546566539320},{"_id":"source/_posts/threads/java多线程系列 06  线程优先级和守护线程.md","hash":"adab1c73be57112e4ad4a588b7113e3b3dbd84c9","modified":1546566539321},{"_id":"source/_posts/threads/java多线程系列 07 ThreadGroup.md","hash":"c2e4db8af80f755cee4d9be51fa4360cc98c5446","modified":1546566539321},{"_id":"source/_posts/threads/java多线程系列之 08 ThreadLocal.md","hash":"f43f7fbad98b1953aef7351ab38c59a0dcd72a20","modified":1546566539323},{"_id":"source/plugins/prettify/lang-apollo.js","hash":"e19c633557b10eab4daad0c2586b3ecb44937ba3","modified":1546588273064},{"_id":"source/plugins/prettify/lang-basic.js","hash":"565276ee5ea2f117e07a8997d792b7d734e4063c","modified":1546588273064},{"_id":"source/plugins/prettify/lang-dart.js","hash":"34c6c4897cf7d22e230ff9db55f2821c5eddbca8","modified":1546588273065},{"_id":"source/plugins/prettify/lang-clj.js","hash":"fff2857ba9919e7a2e8b61b08f1b87be41ed3a46","modified":1546588273064},{"_id":"source/plugins/prettify/lang-erlang.js","hash":"6cb9234429b62d55ff078346668725d6c08efea9","modified":1546588273065},{"_id":"source/plugins/prettify/lang-css.js","hash":"9df3f79343a2104339e5c3ab9d94a39c0291b37b","modified":1546588273065},{"_id":"source/plugins/prettify/lang-kotlin.js","hash":"4aa66901437d588ccaf669d40a91a5cf36f2ffaa","modified":1546588273067},{"_id":"source/plugins/prettify/lang-go.js","hash":"9cfcf1a3e4f9884b369910d7ed2cd67f644ac284","modified":1546588273066},{"_id":"source/plugins/prettify/lang-ex.js","hash":"4a73c2a674799327a2dbe2691aff72d909034b7a","modified":1546588273066},{"_id":"source/plugins/prettify/lang-hs.js","hash":"602e2ff0c97f814773d3895f08c07b5efa8a63d5","modified":1546588273066},{"_id":"source/plugins/prettify/lang-lisp.js","hash":"48d79c12e1915e1166c3cb8cb1798f8ec2443cc9","modified":1546588273067},{"_id":"source/plugins/prettify/lang-llvm.js","hash":"5138b9a56f063688205157703c629fefdb8ed4d0","modified":1546588273068},{"_id":"source/plugins/prettify/lang-logtalk.js","hash":"7836eccb85957e1dae2ca02a9530cf0c7369f949","modified":1546588273068},{"_id":"source/plugins/prettify/lang-lua.js","hash":"d907fa9f1e43aa6f86530d9803b6150b0852140b","modified":1546588273068},{"_id":"source/plugins/prettify/lang-ml.js","hash":"968bdc15137ae94b206e485b5bdfa5c96eff5857","modified":1546588273069},{"_id":"source/plugins/prettify/lang-mumps.js","hash":"9a1cae257b9b028b22ac2c4c9e4c3d2873898566","modified":1546588273070},{"_id":"source/plugins/prettify/lang-n.js","hash":"c2c992ba29d96410a93109ec2505b8e7a96782b9","modified":1546588273070},{"_id":"source/plugins/prettify/lang-pascal.js","hash":"17d60d30e6a73b3a8657baba733bb04ecbd53039","modified":1546588273070},{"_id":"source/plugins/prettify/lang-proto.js","hash":"8dc02debbff302b7d75df5728888abea01d885ae","modified":1546588273070},{"_id":"source/plugins/prettify/lang-r.js","hash":"0c6b75d79b64f603b5e66e4824e51b01df7dc841","modified":1546588273071},{"_id":"source/plugins/prettify/lang-rd.js","hash":"5421a7fe15ddf2b5ea4ab37805e7b7df9784cb34","modified":1546588273071},{"_id":"source/plugins/prettify/lang-rust.js","hash":"d5320b7d04fa87634729120062047b4843d62e04","modified":1546588273071},{"_id":"source/plugins/prettify/lang-scala.js","hash":"74e6aef0b3c6ee2208d0ee3a4887766271724763","modified":1546588273072},{"_id":"source/plugins/prettify/lang-sql.js","hash":"75c9fcd8145b0312c103841ba4fa80bcb76c01e7","modified":1546588273072},{"_id":"source/plugins/prettify/lang-tcl.js","hash":"2270ce056e525578c4fdff32947fa44baeb3475a","modified":1546588273072},{"_id":"source/plugins/prettify/lang-swift.js","hash":"0b12cb29773ac59b3e86a709982c06d1fb903e21","modified":1546588273072},{"_id":"source/plugins/prettify/lang-tex.js","hash":"c30f64b85d576afbb7586a85bcfb471c4dace462","modified":1546588273073},{"_id":"source/plugins/prettify/lang-vb.js","hash":"ba5046fe3caa09c7e2b7e1b3a643b710285a1efa","modified":1546588273073},{"_id":"source/plugins/prettify/lang-vhdl.js","hash":"d19fd1f281d3f7b9583bbf446790d8c7f0022d9c","modified":1546588273073},{"_id":"source/plugins/prettify/lang-wiki.js","hash":"197ed2adc974afa9eba86f6eec4dbb864a8649c7","modified":1546588273074},{"_id":"source/plugins/prettify/lang-yaml.js","hash":"a3a509eb7a2298b962d8b132bd19d093c5e75b25","modified":1546588273074},{"_id":"source/plugins/prettify/lang-xq.js","hash":"dd0c434083a0fd01b144eb506caedf481abc4052","modified":1546588273074},{"_id":"source/plugins/prettify/prettify.css","hash":"3f5dc3139f7385092d5dd567bb273c4585dee82d","modified":1546588273075},{"_id":"source/plugins/prettify/node_prettify.js","hash":"a3b9a2e9b334ffd6fd1b59534b260a270c96c5c1","modified":1546588273075},{"_id":"source/plugins/prettify/prettify.js","hash":"eec92d79f0678b390289981b01866ea5dd36c090","modified":1546588273076},{"_id":"source/uploads/img/avatar.jpg","hash":"8f378705739f7611db358b2b61c7986c7223c2f8","modified":1545980134151},{"_id":"source/images/pasted-12.png","hash":"da74ee4f4d326f43904f94eb03a2306b53d67f57","modified":1547447472217},{"_id":"source/images/pasted-24.png","hash":"14474761e572524e7881d455b19c7e81658714de","modified":1547537702721},{"_id":"source/images/pasted-9.png","hash":"76d749c4527b9305c315f4f62e7dd6db0f7e43b6","modified":1547437951705},{"_id":"source/images/pasted-97.png","hash":"ddd158694fdb7704e88730b4f86c6a9859298522","modified":1548402805956},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1546588351801},{"_id":"themes/next/docs/ru/README.md","hash":"953deb732e0b3b22c423122a189d6847d908c4b8","modified":1546588351802},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1546588351802},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1546588351802},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1546588351803},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1546588351803},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1546588351803},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1546588351804},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1546588351804},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1546588351805},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"35affac8c523f399e59fcc4d3905e03e4e1ed9aa","modified":1546588351810},{"_id":"themes/next/layout/_macro/post.swig","hash":"d1cf93a757768e8fb9bfb7183daad64667ef3544","modified":1546588351811},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"a1ded7ba92354ed55ae20a0b6bcc15bbb4b801c2","modified":1546588351811},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1546588351809},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1546588351809},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1546588351809},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"d01881f8056203c4b6920328db8c2ae8fa662a08","modified":1546588351815},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"d66bc7ec3cc03f60fcc7d555368a5b9b010f7f11","modified":1546588351815},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"edaff4766e0c05fd5c889d9dd32884d376bef9d9","modified":1546588351815},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"c4c58ea2bd4cf10372a5e46dbec1b9a2e0e69f0f","modified":1546588351816},{"_id":"themes/next/layout/_partials/comments.swig","hash":"dce2938bb54c3cef3319f09f2621b93bc41117a0","modified":1546588351811},{"_id":"themes/next/layout/_partials/footer.swig","hash":"07f88421bda86d9d5ff32d130b1cb1196b99a326","modified":1546588351811},{"_id":"themes/next/layout/_partials/github-banner.swig","hash":"11128d3fbe195d7d105e43cf774a1a70b2c1de24","modified":1546588351812},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1546588351813},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"06dac109504812b63766a80ede9ddacbd42d227d","modified":1546588351813},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"10b61a8bac671e375916a4d234c120117098a78f","modified":1546588351819},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"01056ad0e5ad73885e02244943544d7b740bc3bb","modified":1546588351820},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"d359e638a86bd9664101c48e9344f21ec96e6a15","modified":1546588351820},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"2c4a66be4677d3e4dec3f169ac8a769098dad1fe","modified":1546588351821},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"c28f9dc96ab735daeb7f599f86470aa5a83c03cf","modified":1546588351821},{"_id":"themes/next/layout/_third-party/pdf.swig","hash":"5453d76e00bfcd1d732fc5f41828a90eb681f645","modified":1546588351821},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"cbe40cb67dad15ade967b0f396c1a95b6871f76a","modified":1546588351821},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"272c46f03766ea0c169163342bb98f09f561cf4c","modified":1546588351822},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1b250c1b7945cb1029b9e855edb09854f7c8250a","modified":1546588351822},{"_id":"themes/next/scripts/helpers/engine.js","hash":"60eb1554456d9d0e5afc4a2d16f1580a0aa02da8","modified":1546588351825},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"15582e823d228c0b2288543c1eb460c40afad29b","modified":1546588351825},{"_id":"themes/next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1546588351826},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1546588351826},{"_id":"themes/next/scripts/tags/exturl.js","hash":"7ded3e7a78380b32de3e12f156e0978ef5c2890a","modified":1546588351826},{"_id":"themes/next/scripts/tags/full-image.js","hash":"5f2f4c6e15b3197f26a26926876af70ef6390fc4","modified":1546588351826},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1546588351826},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1546588351827},{"_id":"themes/next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1546588351827},{"_id":"themes/next/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1546588351827},{"_id":"themes/next/scripts/tags/tabs.js","hash":"dbc8750a3f6d5676c52bb570d13ac7c51a234f21","modified":1546588351827},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1546588351848},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1546588351849},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1546588351849},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1546588351849},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1546588351850},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1546588351850},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1546588351850},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1546588351850},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1546588351850},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1546588351851},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1546588351851},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1546588351851},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1546588351851},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1546588351851},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1546588351851},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1546588351852},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1546588351852},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1546588351852},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1546588351852},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1546588351801},{"_id":"source/plugins/prettify/lang-lasso.js","hash":"ba0b1a3ac1ad041a1adf6b90154713d1248391e1","modified":1546588273067},{"_id":"source/plugins/prettify/lang-matlab.js","hash":"b71302c9a2aa5ed2b31a75ff364ec6270ac52b1b","modified":1546588273069},{"_id":"source/images/pasted-0.png","hash":"98ebd524cc955564f59ecdb44d9ea65a349792cc","modified":1546408219801},{"_id":"source/plugins/prettify/run_prettify.js","hash":"b029f610e84bf11d705927d92b0df4f376973a67","modified":1546588273077},{"_id":"source/images/pasted-14.png","hash":"c67f633c0cd7faa4c24eb106332b0719ec19c327","modified":1547532750063},{"_id":"source/images/pasted-85.png","hash":"3a40e56fffcdf251ffc55aa00076c17a86fb7bf1","modified":1548402370914},{"_id":"themes/next/docs/zh-CN/README.md","hash":"15e55eb77616500fa4c64982d6bad9ac17a46e2a","modified":1546588351804},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"8ac2f5d2a023211d8d8ea626cbf6b8dea67ac201","modified":1546588351804},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546588351816},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546588351816},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546588351842},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546588351842},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546588351842},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546588351848},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546588351848},{"_id":"source/_posts/juc/threads/java多线程系列-JUC线程池之01 线程池架构.md","hash":"22d3b60fb526cb88fe29427393881c57c77d201b","modified":1546568307930},{"_id":"source/_posts/juc/threads/java多线程系列-JUC线程池之02 ThreadPoolExecutor源码分析.md","hash":"9cd2a0d4178233bd854429467952b8ecbcf52356","modified":1546566539322},{"_id":"source/_posts/juc/threads/java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建.md","hash":"50e3cd94f6e9d97fc049a7dacb61f52868162de6","modified":1546566539313},{"_id":"source/_posts/juc/threads/java多线程系列-JUC线程池之04 Future 和Callable.md","hash":"4aca500f42aa1d5914c8269629d8f7d9460d47df","modified":1546566539323},{"_id":"source/_posts/spring 源码分析/spring/Spring源码解析之  08bean标签：BeanDefinition .md","hash":"c740ee77ecf31ca81904cece3beb31a17b0a39df","modified":1547523469772},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之  01环境搭建.md","hash":"8d5a8d4be01f379d543d971368e6b6039b51c207","modified":1547442252393},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之  02IOC原理.md","hash":"8464de80c442b8eb0314b80ecae5db220668c2c8","modified":1547442214074},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之  03统一资源加载.md","hash":"716fc5bfcae6b748cd58ef01015ce709beb1a41a","modified":1547441239723},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之  04（上）加载bean.md","hash":"167f7fcb82ca2a55be90d0132dae2acacffb0fab","modified":1547523507933},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之  04（下）获取验证模型.md","hash":"a128199cfabb72d84eec7e0a4970c462c4430d3a","modified":1547446412371},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之  05获取Document对象.md","hash":"c3c5a8cc8d45aaa7fb2a4960eeb2cab6b510aa13","modified":1547523494051},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之  06注册BeanDefinition.md","hash":"63316e6dff0c5caeb7b85d5b638429b7b116fc8f","modified":1547523486084},{"_id":"source/_posts/spring 源码分析/spring/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1547534220480},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之  07bean标签：开始解析进程.md","hash":"29a786cf7c78d89158a5ffd6b0305f1a5cbff1bd","modified":1547523477042},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之  09bean 标签：meta、lookup-method、replace-method.md","hash":"0fada633a99401c8be48c0c8a4dbb5ed8a46b1eb","modified":1547523460705},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 10bean标签：constructor-arg、property子元素.md","hash":"cc9b216c67857ab921da905a9d8d7065e17f9179","modified":1547523451126},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 11bean标签：解析自定义标签.md","hash":"763decf5e4e6d9f3d35d4563386c035d654dfa6d","modified":1547523443781},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 12alias标签的解析.md","hash":"d41a0e93d6df415d89f2aee5f955d889a2e28210","modified":1547523433956},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 13自定义标签解析.md","hash":"16979af906f3ca15a182b9bf94f2cde6c950ea96","modified":1547523426297},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 14注册解析的BeanDefinition.md","hash":"2dafca896c70e29c8f70a4dad46378fc36137d83","modified":1547523418462},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 15BeanDefinition解析总结.md","hash":"229258b92216e1a1129fe6170d4f7c512ca6d9f2","modified":1547523408112},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 16开启bean的加载.md","hash":"00ab14c6a654dac4a8963916f0080dd54e4971cf","modified":1547523657705},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 17缓存中获取单例bean.md","hash":"95a26556d8e9aad20c729c3860b7bdbd9f97801c","modified":1547523578203},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 18parentBeanFactory 与依赖处理.md","hash":"2f2ece182c651a79fad3437af2db924a3cb1b94e","modified":1547523389916},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 19各Scope的创建.md","hash":"43ab1954ae65aefe56296498954cea4f240ea8d2","modified":1547536105293},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 20开启bean的实例化进程.md","hash":"9fb05c499a68375ffed3a8f1b3f51f6f134ec8fd","modified":1547627763825},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 21实例化bean.md","hash":"d7d872db2692057293a90c5e8c8a9951f923598e","modified":1547627744934},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 22构造函数实例化.md","hash":"7d894d8bdbf30e24e73e0db57da8c682013ef6cd","modified":1547627724194},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 23属性填充.md","hash":"c6feceaec992e225d8a549394a20a05cfc1e11bd","modified":1547627701858},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 24循环依赖处理.md","hash":"416bbfbcc0019fcdd588a5c40052191d9f0d7e8b","modified":1547627689186},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 25bean的初始化.md","hash":"03ec68d87a28a1122ee6c5ac191635d70d2b5b20","modified":1547627678829},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 26深入分析Aware接口.md","hash":"e60c388b6fa3eb47c27ff457330e91909736077a","modified":1547627666050},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 27深入分析BeanPostProcessor接口.md","hash":"d92c7171d983746a5e47c59661b3cd5f9b4c46d1","modified":1547627654071},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 28深入分析InitializingBean 接口和 init-method.md","hash":"16ef1d8374e0e60c04734c8fce730b7ed99d47c4","modified":1547627640777},{"_id":"source/_posts/spring 源码分析/spring/spring源码解析之 29实例化bean总结.md","hash":"27174540ac84baf58a5934fce5af31209cd291d7","modified":1547627626176},{"_id":"source/images/pasted-66.png","hash":"9220a33034e426381a184a5f0bb110fdb00bb0f7","modified":1547975177680},{"_id":"source/images/pasted-72.png","hash":"c3603a6e381cccd5b5b9c9b5cb741471c3fa767d","modified":1548317888954},{"_id":"source/images/pasted-73.png","hash":"e31d1aa575581dc4d215e963817d50e7bc183e54","modified":1548318479788},{"_id":"source/images/pasted-74.png","hash":"6450e41506148dedbe410ac24907071a102aa561","modified":1548398873822},{"_id":"source/images/pasted-75.png","hash":"6450e41506148dedbe410ac24907071a102aa561","modified":1548398878466},{"_id":"source/images/pasted-79.png","hash":"4a6d7721736ba4245f4e0b1ce1464b5dcaa332bc","modified":1548402241655},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1546588351810},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"fb33f499022cd02722f834fcef1a0e193362cfde","modified":1546588351810},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"c7f2855f19dfdf18aba8c58d55b7489e631ed035","modified":1546588351815},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"94e106755c5fb6f40431b621beeba0bd33877e57","modified":1546588351816},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"94e106755c5fb6f40431b621beeba0bd33877e57","modified":1546588351816},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"fc6bafc8c633afadc538c5afa5620ea2a1cdcb84","modified":1546588351812},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"dc53a41196b675268bfd2a944f6258c57ed44e91","modified":1546588351812},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"58e2e153e8b67e643b24453a1e1cceaae3323647","modified":1546588351812},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"6a825ce9412339ec4a128d9714804994cb85522c","modified":1546588351812},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1546588351813},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1546588351813},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"5adc60100e129c1d0307bdcaa0c7b8e8375a6ea4","modified":1546588351813},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"69722be16ce5eae5c027168f9b2fded4776e1b53","modified":1546588351813},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"2940df694fff28e8bf71b6546b4162f1e38227db","modified":1546588351813},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"2f73cc9ffb63534f0b6d8f0e9ee853c1af1b1244","modified":1546588351814},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"eea95b785c9c36d28e1839619793f66e89773bee","modified":1546588351814},{"_id":"themes/next/layout/_partials/post/reward.swig","hash":"64d65d9ad0cc94734ac6ded279e2b5dc870a1cab","modified":1546588351814},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"d63208ee20529450c35de8fe80ef41fffa831dc9","modified":1546588351814},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1546588351814},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1546588351814},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a5587bd1f60d35e58618576cec45e662aa44ea1f","modified":1546588351814},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1546588351814},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1546588351815},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1546588351815},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d5bfb363a1154e6505f0cccbd811fa71db133e3d","modified":1546588351815},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1546588351817},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"798d67e4a736613ab899eabe6529091bbcda7850","modified":1546588351817},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"591b2ccd9713ccb922b9fcf5e278b6de9c5ec30b","modified":1546588351817},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"8eadb929c9e50e58502ccad2dc2657746f8c592a","modified":1546588351817},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"08cd47ef8572121b7811342d3c9a84a338a18191","modified":1546588351817},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"050ea01f25cfe492be9bb77b409644d623fdf2dc","modified":1546588351817},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1546588351818},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"529db1ff4b6c18822d6cf77f644a7f7b39c80870","modified":1546588351818},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"9e576f12a294b14bd262f59c309a50cbf7003827","modified":1546588351818},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1546588351818},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1546588351818},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"f240a50cd9b627620d9a374a29cf95f0c5e99d7c","modified":1546588351818},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"41b4644f7264b16336154ac842f35278e3bb09b8","modified":1546588351818},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"cbf620cf2a78e3ac736cdd7e768513cfd6946e83","modified":1546588351819},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"aea70f5ec17917b75812020d8bf2aeabd434e8bc","modified":1546588351819},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c4c50a646254a186413bb5e4e320af4071a8b072","modified":1546588351819},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"3fee34fc9620195b1152e96f126c516a7175fdbb","modified":1546588351819},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"d34e054a6d5c8a5fb4dd4b4671e666891e4c9adf","modified":1546588351819},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"9809d63a4234c5f268ff0b489579149b849728fc","modified":1546588351820},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"607a60588ad3d226eb0fb50df601e2f2ff6d627c","modified":1546588351820},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"9eb881107c407d8d9e759d10d247f2ade412c2d9","modified":1546588351820},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a7e304b05a44279d3e4f611908d7faef9dc14d7c","modified":1546588351820},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"c2cb2f384bc30d31cdccf9794a729c03e687b45c","modified":1546588351821},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"c76c7ac9b97e74908467701b10e25707ba5c979e","modified":1546588351821},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1546588351822},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b3eaab6a269aa3fcbafe24fd06f0c9206dc12716","modified":1546588351823},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1546588351823},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"323ccd05bf8befb7d33de443cf3ac6a4195c3554","modified":1546588351823},{"_id":"themes/next/scripts/filters/after_post_render/exturl.js","hash":"9c9f61b7bfb3349b03b1e61355f20232044b5fd8","modified":1546588351824},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1546588351842},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1546588351842},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1546588351842},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"086f5979b3de091c3378512e6c5c2f8fcb4f6298","modified":1546588351842},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"a8aa41625b94cf17a7f473ed10dcbe683b1db705","modified":1546588351848},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1546588351848},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"fc15e277d1504532a09b7b1bd31f900ad95ec4b8","modified":1546588351848},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d0e97b205d3320421c380f2eee445457430c8152","modified":1546588351848},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1546588351853},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1546588351853},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1546588351853},{"_id":"themes/next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1546588351854},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1546588351853},{"_id":"themes/next/source/js/src/motion.js","hash":"7933a30382a84b655238f6e78d42ea1b99af4de6","modified":1546588351854},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1546588351854},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1546588351854},{"_id":"themes/next/source/js/src/utils.js","hash":"f1394d64977439ec569d2777b1ac304905e043f1","modified":1546588351855},{"_id":"themes/next/source/lib/algolia-instant-search/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1546590371779},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1546590371780},{"_id":"themes/next/source/lib/algolia-instant-search/README.md","hash":"9fa5175cdb7d3d939fe7174b6d68608ca996c174","modified":1546590371779},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1546588351855},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1546588351855},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1546588351856},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1546588351856},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1546588351856},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1546588351864},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1546588351863},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1546588351864},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1546588351853},{"_id":"source/images/pasted-20.png","hash":"3e38af7ce22ba0480d4f52a7ca16b3d1466c1ee2","modified":1547533994194},{"_id":"source/images/pasted-22.png","hash":"af3b0d3c39f1de998114c1535be28546ea3b1c9e","modified":1547534083140},{"_id":"source/images/pasted-28.png","hash":"d0c1b81296926d8b20d62fbca3868561334face2","modified":1547636500328},{"_id":"source/images/pasted-26.png","hash":"a42ce671d63403f0dbd00f806c2ae2622e1c5eb5","modified":1547623829690},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1546588351861},{"_id":"source/images/pasted-86.png","hash":"ef5d2dd5d015558a7ca2d7d483853224f9c820e4","modified":1548402613168},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"837ff3718cb5a63eb01a451e35989fd1dfe4218c","modified":1546588351827},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1546588351828},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"cd86bed852fec6e6933898067122a03755bc17f0","modified":1546588351822},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1546588351822},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1546588351828},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1546588351828},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1546588351828},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"61ca40856e5cacd48e0fa9728fde4605c7dd4c94","modified":1546588351837},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"513779f38d94a98511db14fe4527cdc453f426b8","modified":1546588351840},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"d33420ef9a655ecaa1c70af6d9bfed0740d8a5bf","modified":1546588351840},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1546588351841},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1546588351841},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1546588351841},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1546588351841},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1546588351841},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"2d17b26331f2eb019c95854154dcad52c69c08e4","modified":1546588351843},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1546588351843},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1546588351843},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1546588351843},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fe2dc74726a515549956d233becda188da64f948","modified":1546588351844},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1546588351844},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1546588351844},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1546588351844},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"fc160583f742c94316a0fee05c18468033173534","modified":1546588351845},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1546588351845},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"936132428a0d35b3947ccedd4c379940abcf223a","modified":1546588351846},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1546588351846},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1546588351846},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"09b5054ae34ba83c0d614821e574da265af55a14","modified":1546588351846},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"9b076c92abdadcf9acee75da64592ff3badd69b8","modified":1546588351847},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"74c7dccf0a3ee9fc2ca25ad8e998243191813a0e","modified":1546588351847},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1546588351847},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5b936dddb7b4de4720cd1e8428b30a2f06d63fb","modified":1546588351847},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1546588351847},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e7afdb343f9502f433f49044e42fe347719ce330","modified":1546588351847},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1546588351854},{"_id":"themes/next/source/lib/algolia-instant-search/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1546590371769},{"_id":"themes/next/source/lib/algolia-instant-search/.git/config","hash":"ae057b7f33eac7ddf41bed1c7a3323eb69ec0b7c","modified":1546590371772},{"_id":"themes/next/source/lib/algolia-instant-search/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1546590368794},{"_id":"themes/next/source/lib/algolia-instant-search/.git/index","hash":"4e2d0edb12ec283cc030e37f73442a85bc64b103","modified":1546590371784},{"_id":"themes/next/source/lib/algolia-instant-search/.git/packed-refs","hash":"12fab895cc22fc0453352f3c81e6209511e88dab","modified":1546590371768},{"_id":"themes/next/source/lib/algolia-instant-search/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1546590371778},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1546588351857},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1546588351861},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1546588351861},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1546588351857},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1546588351856},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1546588351832},{"_id":"source/images/pasted-103.png","hash":"c686dcdace32a5daac411a47c23553144abaed09","modified":1548403082932},{"_id":"source/images/pasted-130.png","hash":"b904e5a00ab189b68f8fc27625666e89caed3b6b","modified":1548403476015},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1546588351863},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1546588351860},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1546588351859},{"_id":"source/images/pasted-17.png","hash":"22b0849024340a900fd14794f12f01a57426b056","modified":1547532788233},{"_id":"source/images/pasted-29.png","hash":"cd1dcca7cadb8d3317ad6df4a99ab96c471d3279","modified":1547730808147},{"_id":"source/images/pasted-76.png","hash":"26bf4a1492c1f627d8f88c0b2ef3c22e0080bd95","modified":1548400684056},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1546588351829},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1546588351828},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1546588351829},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1546588351829},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"c0d9e18a9210fdcaf33e488518b3b288eb58c0a1","modified":1546588351829},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1546588351829},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1546588351830},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"2dfa5fde3df69fba8282627e592fe637c2cbac6b","modified":1546588351830},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1546588351830},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"6904fd7ea6455e008d9884558b68254608af9a3c","modified":1546588351830},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1546588351831},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1546588351831},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1546588351831},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1546588351831},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1546588351832},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f2911a048e5c20ca2a059bd1087d98ac1c51681c","modified":1546588351831},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"3b5a37ba5e70f92c1ee707c8053524e38adbb710","modified":1546588351832},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1546588351832},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1546588351833},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"2356226157e8068b0e9bbe2f7d0f74e1ab49199b","modified":1546588351832},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1546588351833},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1546588351833},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1546588351833},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"1cf64afd4b49143972f7617869539be3adb91a5e","modified":1546588351833},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"5f964ef8a38b9901ac8f87e3f5c93e0c44ec947a","modified":1546588351834},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1546588351834},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1546588351834},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1546588351834},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1546588351834},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"8e058c99dd7d41f0bd34c7c28b6ac9fbb17dcb5e","modified":1546588351834},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"3039df53b94b0847b0c451d2d227270b479cc184","modified":1546588351834},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1546588351835},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1546588351835},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"b34bb2ea4d16e47e6fdc06cd4feb32d93ccbd779","modified":1546588351835},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1546588351835},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1546588351836},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1546588351836},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1546588351835},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1546588351836},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1546588351837},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1546588351836},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1546588351836},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1546588351837},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1546588351837},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1546588351837},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1546588351837},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1546588351838},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1546588351838},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1546588351838},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"090018c4467a5cc056bdceebd2517a87e3cb7835","modified":1546588351838},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1546588351839},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1546588351839},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"6157665b8fc26ce4635c926128ffbd831a2fdd46","modified":1546588351839},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1546588351839},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1546588351840},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1546588351839},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"190ad18f45b8a69cef13b2fdd2254893d06ec2c3","modified":1546588351840},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1546588351845},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1546588351845},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1546588351846},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1546590368796},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1546590368795},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1546590368797},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1546590368797},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1546590368796},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1546590368798},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1546590368797},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1546590368797},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1546590368795},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1546590368798},{"_id":"themes/next/source/lib/algolia-instant-search/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1546590368794},{"_id":"themes/next/source/lib/algolia-instant-search/.git/logs/HEAD","hash":"f61acb3d13eaf6c85819e29974a6bc27b77fa3fe","modified":1546590371771},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"05e68adae13f4d99a6ac6493daab39c92e39a6bd","modified":1546588351829},{"_id":"source/images/pasted-129.png","hash":"9fd8c9540db53ba24d6c5d31b0aa9ac89da24293","modified":1548403466008},{"_id":"source/images/pasted-27.png","hash":"c9275506fcf1833c4a7a68e4c7eaad4e560d5f36","modified":1547634614672},{"_id":"source/images/pasted-77.png","hash":"9c0dfedee253b0e04223b82841389aa17742e49a","modified":1548400729224},{"_id":"source/images/pasted-96.png","hash":"fa10fe7f62aed37880b76c497ba55998b7a66b6c","modified":1548402766450},{"_id":"source/images/pasted-98.png","hash":"b434f72d132b2893122291ad8b81de8a29808eb1","modified":1548402818013},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1546588351859},{"_id":"source/images/pasted-102.png","hash":"48210d412d070dce5db29baf7cebec118bd01cd0","modified":1548402930905},{"_id":"source/images/pasted-114.png","hash":"6c914ee6512a9ec1853530549508a78e1002ef61","modified":1548403216372},{"_id":"source/images/pasted-116.png","hash":"241b1487b38901b0c36410ea5abc730c03145a8c","modified":1548403235513},{"_id":"source/images/pasted-117.png","hash":"a85d0662716a1c624cfff0ab5d01df8b951ed869","modified":1548403272348},{"_id":"source/images/pasted-120.png","hash":"0f61c0caf55afc9d6a86f8f87d6c13c4e9189327","modified":1548403357869},{"_id":"source/images/pasted-121.png","hash":"7b3df00d5707d31bb95cd47edf42bc0fca46829f","modified":1548403370331},{"_id":"source/images/pasted-19.png","hash":"1ce0741f70fcdb83621ed88d3f501393b82e1f54","modified":1547532827069},{"_id":"source/images/pasted-21.png","hash":"e35ef746c737c2183c7a8c2181167a5fe382453e","modified":1547534007505},{"_id":"source/images/pasted-82.png","hash":"e9256ea516952bb48af19070411fcdc68577a0c3","modified":1548402307049},{"_id":"source/images/pasted-90.png","hash":"b0c5a80bf5aec548e4f3d7bc5890ead23dcb8073","modified":1548402689013},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/08/777d50ffb9e517f20d2cbf2ea19130862fb501","hash":"110fcf7830673d2a7715f8347834f7393597ecd0","modified":1546590371752},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/0d/49463cf444a6411519b6d7b5bb65fa7e96c4dc","hash":"8baa9ed7c87fbf1a9fdeb378c656471cb98c48e5","modified":1546590371381},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/0c/dada082d621dbfdd00f7020c33dc751129167f","hash":"b490c11cdefde6b331a7d4ddb055e34ad08459d8","modified":1546590371377},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/2f/9eba51ec174b1e0c719d12cafa7c3c07140471","hash":"fc994d9d8b3b21ec7c941eea7e3862970e297e9b","modified":1546590371377},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/2b/a3834eb798ac34ab72ed5fdf7a56d175fee554","hash":"e8edf92b35519a3ec9333c7b54243eca7edc37f2","modified":1546590371376},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/54/7b348ba5c8725ea590087860a352c8ff41cb98","hash":"79281e0d03b3acdbce61914bbfef33ae0c29be6d","modified":1546590371375},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/59/0f6f985f6018c397b2499bb49e599b7109ec06","hash":"650b4b24a81daa3b02646b7ffd5ccdac11ab6be8","modified":1546590371382},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/69/a20d65d83035fdb01734a8eabe3340f740a4cb","hash":"9e95b02d8e43ec92e06bee3f60dffb74e8e7b9fa","modified":1546590371380},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/92/1eb7be3c529d19b6c92ce67e4099e8f7d6adf3","hash":"023bef5405aee54ae6b00e1e02eb6984b691ccbf","modified":1546590371753},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/c7/fbb078f1639009ff35512e07a344065d222948","hash":"123afd34f26169b38c32f4b035562726036fd960","modified":1546590371373},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/c9/af6112eed1dab47eba55651562f768bfbc861d","hash":"a3ce783cca46bdcba0a1eda2d034c77221e07e06","modified":1546590371374},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/f5/e09255981809338b668b56510e360595fc12fa","hash":"c385e27cf914367d1fde121a2c920b93832cf2ed","modified":1546590371752},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/da/0b2b5f2ab8f750444499f17e4cbf6074aef7f0","hash":"b343b66897d47a95d9a4363eaab8ff61a1c8a683","modified":1546590371374},{"_id":"themes/next/source/lib/algolia-instant-search/.git/refs/heads/master","hash":"74df65c788c01d698900837b633ee6c323315819","modified":1546590371770},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/6d/b4c7bd4b80f34ae7165de7d91291759569d572","hash":"f04a0f8b9dde5d5c36f470634ca8f958a3b6aa15","modified":1546590371754},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/a4/0c9f2635389a60948f0f2235f037277f8acff6","hash":"ec4074d54b477aea533dab38384dd9a52fa58854","modified":1546590371380},{"_id":"source/images/pasted-115.png","hash":"6059ee06f307742af49f03fbae2d78c5f5fc1464","modified":1548403225564},{"_id":"source/images/pasted-125.png","hash":"f0aad5dbdd9f48084df50ddae30d7ba173d063b8","modified":1548403424432},{"_id":"source/images/pasted-126.png","hash":"d5a05d773174931d81e9a28228a9c393cb2fd4fe","modified":1548403435437},{"_id":"source/images/pasted-15.png","hash":"1ce0741f70fcdb83621ed88d3f501393b82e1f54","modified":1547532762911},{"_id":"source/images/pasted-88.png","hash":"c7a8741ed2b663832210c71a02c8528d87bf7f68","modified":1548402652842},{"_id":"source/images/pasted-91.png","hash":"19581359c40e46e1a8dca5fa9160852ff7a5c8ab","modified":1548402700721},{"_id":"source/images/pasted-94.png","hash":"c790c2caafa65d14d3a92d9455a8323fdc8e03e8","modified":1548402741294},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1546590371784},{"_id":"source/images/pasted-109.png","hash":"bc22049acc26af3671769aa8fb00a82e7b5e53a9","modified":1548403159956},{"_id":"source/images/pasted-123.png","hash":"5a8d29a99cc574dc43be2a3e37dbf37a089d4bda","modified":1548403396152},{"_id":"source/images/pasted-128.png","hash":"8ff3f6e4b51c913cbdc4d20854ed411e3af65b57","modified":1548403456737},{"_id":"source/images/pasted-84.png","hash":"6c09174a47fd1b2179286648f7267deda58286bc","modified":1548402351675},{"_id":"source/images/pasted-92.png","hash":"66051ab38bea0d2d3766a9e3e911edaca52e80d0","modified":1548402713464},{"_id":"themes/next/source/lib/algolia-instant-search/.git/logs/refs/heads/master","hash":"f61acb3d13eaf6c85819e29974a6bc27b77fa3fe","modified":1546590371771},{"_id":"themes/next/source/lib/algolia-instant-search/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1546590371769},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/2b/d5d590d07a161741477ace2339eb37c07cc40c","hash":"10a1f52729a36d3b9d594e93473fef26fed768e1","modified":1546590371751},{"_id":"source/images/pasted-100.png","hash":"60651e58898b802c8f700714ec8a4bff720b1330","modified":1548402839248},{"_id":"source/images/pasted-104.png","hash":"3c733add8772415335fe2d81985d966e19024a72","modified":1548403095582},{"_id":"source/images/pasted-111.png","hash":"f223ed78b2c68da381a285dca8956b96f1afd1da","modified":1548403182015},{"_id":"source/images/pasted-16.png","hash":"631b6705250d421f9f5fa8f4c1b8bf2977d94c71","modified":1547532775142},{"_id":"source/images/pasted-81.png","hash":"f3d9894955ae6a896552c14645ace6d9b5a723a6","modified":1548402286823},{"_id":"source/images/pasted-80.png","hash":"eed6cc131081c5fd0a499e9e76da097fe3ffba4a","modified":1548402266148},{"_id":"source/images/pasted-87.png","hash":"8e4c5fefffa4196cfb618891066f5b79d5725e20","modified":1548402634629},{"_id":"source/images/pasted-89.png","hash":"89228ae6f5221894882ecc230423fe5796b8f46a","modified":1548402673534},{"_id":"source/images/pasted-93.png","hash":"c1371144b73bdfb0012c788e5667078e3f5971e7","modified":1548402725289},{"_id":"source/images/pasted-99.png","hash":"32e0ba6ed23af7deb3471d239690e4db5e3dd2a6","modified":1548402828815},{"_id":"source/images/pasted-101.png","hash":"dfaf5bda61232ea15cfc64978b15d9425f353d31","modified":1548402853331},{"_id":"source/images/pasted-105.png","hash":"917ccb480fb7f55dbc0a2e8db5b94479caf2fa06","modified":1548403107306},{"_id":"source/images/pasted-106.png","hash":"93d8bd0b3d009fc87c325e77378af95cb8093a42","modified":1548403118724},{"_id":"source/images/pasted-112.png","hash":"bfc1aaf08c08e646ff8511b558d0d94f3b883fd1","modified":1548403194186},{"_id":"source/images/pasted-118.png","hash":"be7ed36db1c64ca2e984084c6f342e911ee13a25","modified":1548403298669},{"_id":"source/images/pasted-122.png","hash":"2d77dca3d3a96111f3983feef4ac24a3023547b5","modified":1548403382327},{"_id":"themes/next/source/lib/algolia-instant-search/.git/logs/refs/remotes/origin/HEAD","hash":"f61acb3d13eaf6c85819e29974a6bc27b77fa3fe","modified":1546590371769},{"_id":"source/images/pasted-108.png","hash":"915d128a68beb6919aa08b3b619a34383fbb5563","modified":1548403148584},{"_id":"source/images/pasted-127.png","hash":"b8635f63fb725734634d19d100afcfb92adca557","modified":1548403447128},{"_id":"source/images/pasted-119.png","hash":"7ff49cf5b4244f2fa218d65bb89beafc562f47f1","modified":1548403322695},{"_id":"source/images/pasted-110.png","hash":"d974663cb14c3ded9829c2eb92e53fc806093582","modified":1548403171376},{"_id":"source/images/pasted-107.png","hash":"53b779fc1096f39a47f528ecfeefa82b9807fa1a","modified":1548403132932},{"_id":"source/images/pasted-37.png","hash":"19a55c42ac148d801173ac0a0725e193ccb2d589","modified":1547973035086},{"_id":"source/images/pasted-124.png","hash":"f0986e3e223fd6a3ba6dfd77ac5d6dfc5c0f22da","modified":1548403412762},{"_id":"source/images/pasted-83.png","hash":"d20373fa5478413d55420650687e546ba0c90279","modified":1548402326909},{"_id":"source/images/pasted-95.png","hash":"9415e850c0fa672824c175fdbb3c01b79f8492dc","modified":1548402753261},{"_id":"source/images/pasted-113.png","hash":"f3926a3537e5f6d617baf604cd59db4971b852b7","modified":1548403204487},{"_id":"source/images/pasted-132.png","hash":"127b9181238908ff4de2db6d971053adbeddf38a","modified":1550470766000},{"_id":"source/images/pasted-133.png","hash":"78c747aa0ba9b7ff92b7aabbfc0125d9c5243a5f","modified":1550472061000},{"_id":"source/images/pasted-131.png","hash":"101e6d503b86180d7b4ce6f3be9498e0044ef91d","modified":1550470715000}],"Category":[{"name":"java","_id":"cjs9qovje00059q1u27yk1w4z"},{"name":"其他","_id":"cjs9qovji00089q1uxzffgpo6"},{"name":"操作系统","_id":"cjs9qovjj000c9q1uck9ppukv"},{"name":"spring","_id":"cjs9qovtg00389q1u632wr7rs"}],"Data":[],"Page":[{"title":"简介","date":"2019-01-02T05:30:52.000Z","_content":"---\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    <strong>TODO<strong>\n</body>\n\n</html>","source":"about/index.html","raw":"title: 简介\ndate: 2019-01-02 13:30:52\n---\n---\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    <strong>TODO<strong>\n</body>\n\n</html>","updated":"2019-01-02T05:37:58.764Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjs9qovj900019q1uicm2fph0","content":"---\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    <strong>TODO<strong>\n</strong></strong></body>\n\n</html>","site":{"data":{}},"excerpt":"","more":"---\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    <strong>TODO<strong>\n</strong></strong></body>\n\n</html>"},{"title":"文章分类","date":"2018-12-28T06:31:10.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2018-12-28 14:31:10\ntype: \"categories\"\n---\n","updated":"2018-12-28T06:55:34.150Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjs9qovjc00039q1u9c4qe1tk","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-12-28T06:30:54.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-12-28 14:30:54\ntype: \"tags\"\n---\n","updated":"2018-12-28T06:55:34.151Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjs9qovp2000j9q1uzbh7jsix","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"用于查看图片","author":"枫秀天涯","abbrlink":12013,"date":"2019-01-14T03:04:18.000Z","_content":"![upload successful](/images/pasted-131.png)\n\n![upload successful](/images/pasted-132.png)\n\n![upload successful](/images/pasted-133.png)\n\n![upload successful](/images/pasted-68.png)\n\n![upload successful](/images/pasted-69.png)\n\n![upload successful](/images/pasted-70.png)\n\n![upload successful](/images/pasted-71.png)\n\n![upload successful](/images/pasted-72.png)\n\n![upload successful](/images/pasted-73.png)\n\n![upload successful](/images/pasted-74.png)\n\n\n\n\n\n\n![upload successful](/images/pasted-103.png)\n\n![upload successful](/images/pasted-104.png)\n\n![upload successful](/images/pasted-105.png)\n\n![upload successful](/images/pasted-106.png)\n\n![upload successful](/images/pasted-107.png)\n\n![upload successful](/images/pasted-108.png)\n\n![upload successful](/images/pasted-109.png)\n\n![upload successful](/images/pasted-110.png)\n\n![upload successful](/images/pasted-111.png)\n\n![upload successful](/images/pasted-112.png)\n\n![upload successful](/images/pasted-113.png)\n\n![upload successful](/images/pasted-114.png)\n\n![upload successful](/images/pasted-115.png)\n\n![upload successful](/images/pasted-116.png)\n\n![upload successful](/images/pasted-117.png)\n\n![upload successful](/images/pasted-118.png)\n\n![upload successful](/images/pasted-119.png)\n\n![upload successful](/images/pasted-120.png)\n\n![upload successful](/images/pasted-121.png)\n\n![upload successful](/images/pasted-122.png)\n\n![upload successful](/images/pasted-123.png)\n\n![upload successful](/images/pasted-124.png)\n\n![upload successful](/images/pasted-125.png)\n\n![upload successful](/images/pasted-126.png)\n\n![upload successful](/images/pasted-127.png)\n\n![upload successful](/images/pasted-128.png)\n\n![upload successful](/images/pasted-129.png)\n\n![upload successful](/images/pasted-130.png)","source":"_drafts/Untitled.md","raw":"title: 用于查看图片\nauthor: 枫秀天涯\nabbrlink: 12013\ndate: 2019-01-14 03:04:18\ntags:\n---\n![upload successful](/images/pasted-131.png)\n\n![upload successful](/images/pasted-132.png)\n\n![upload successful](/images/pasted-133.png)\n\n![upload successful](/images/pasted-68.png)\n\n![upload successful](/images/pasted-69.png)\n\n![upload successful](/images/pasted-70.png)\n\n![upload successful](/images/pasted-71.png)\n\n![upload successful](/images/pasted-72.png)\n\n![upload successful](/images/pasted-73.png)\n\n![upload successful](/images/pasted-74.png)\n\n\n\n\n\n\n![upload successful](/images/pasted-103.png)\n\n![upload successful](/images/pasted-104.png)\n\n![upload successful](/images/pasted-105.png)\n\n![upload successful](/images/pasted-106.png)\n\n![upload successful](/images/pasted-107.png)\n\n![upload successful](/images/pasted-108.png)\n\n![upload successful](/images/pasted-109.png)\n\n![upload successful](/images/pasted-110.png)\n\n![upload successful](/images/pasted-111.png)\n\n![upload successful](/images/pasted-112.png)\n\n![upload successful](/images/pasted-113.png)\n\n![upload successful](/images/pasted-114.png)\n\n![upload successful](/images/pasted-115.png)\n\n![upload successful](/images/pasted-116.png)\n\n![upload successful](/images/pasted-117.png)\n\n![upload successful](/images/pasted-118.png)\n\n![upload successful](/images/pasted-119.png)\n\n![upload successful](/images/pasted-120.png)\n\n![upload successful](/images/pasted-121.png)\n\n![upload successful](/images/pasted-122.png)\n\n![upload successful](/images/pasted-123.png)\n\n![upload successful](/images/pasted-124.png)\n\n![upload successful](/images/pasted-125.png)\n\n![upload successful](/images/pasted-126.png)\n\n![upload successful](/images/pasted-127.png)\n\n![upload successful](/images/pasted-128.png)\n\n![upload successful](/images/pasted-129.png)\n\n![upload successful](/images/pasted-130.png)","slug":"Untitled","published":0,"updated":"2019-02-18T06:41:04.000Z","_id":"cjs9qovj100009q1u53tnt6tn","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/images/pasted-131.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-132.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-133.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-68.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-69.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-70.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-71.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-72.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-73.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-74.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-103.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-104.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-105.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-106.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-107.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-108.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-109.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-110.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-111.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-112.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-113.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-114.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-115.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-116.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-117.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-118.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-119.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-120.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-121.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-122.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-123.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-124.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-125.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-126.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-127.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-128.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-129.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-130.png\" alt=\"upload successful\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/pasted-131.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-132.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-133.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-68.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-69.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-70.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-71.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-72.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-73.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-74.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-103.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-104.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-105.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-106.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-107.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-108.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-109.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-110.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-111.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-112.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-113.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-114.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-115.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-116.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-117.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-118.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-119.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-120.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-121.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-122.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-123.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-124.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-125.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-126.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-127.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-128.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-129.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-130.png\" alt=\"upload successful\"></p>\n"},{"title":"Random 与 ThreadLocalRandom 对比","author":"zhangke","abbrlink":26181,"date":"2018-12-12T07:42:00.000Z","_content":"---\n# Random 与 ThreadLocalRandom 对比\n\n1. 简介\n2. 测试结果与分析\n3. 补充\n\n### 1. 简介\n\n首先，如果你看到这篇文章相信对这俩个类有一定的了解，所以我就不再这里介绍具体的用法。简单的介绍一下这个类，Random，ThreadLocalRandom是Java中的随机数生成器，Random是我们比较常用的随机数生成器，他是线程安全的。ThreadLocalRandom是jdk7才出现的，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，同时也能保证线程安全和提高性能。\n\n由于本人能力有限，如果你的英文比较好，可以看看StackOverFlow上的这个讨论[https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom](https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom)\n<!--  more -->\n\n### 2. 测试结果与分析\n\n我使用的JMH来进行的压测，这篇文章可以帮助你[入门 JMH](https://www.cnkirito.moe/java-jmh/)。具体代码如下\n\n```java\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 11:44\n *      email  : 398757724@qq.com\n *      Desc   : ThreadRandom 和 Random性能对比\n ***************************************/\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 5)\n@Measurement(iterations = 3, time = 5)\n@Threads(10)\n@Fork(1)\n@State(Scope.Benchmark)\npublic class Randombenchmark {\n    Random random = new Random();\n\n    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n\n\n    @Benchmark\n    public int random() {\n        return random.nextInt();\n    }\n\n\n    @Benchmark\n    public int threadLocalRandom() {\n        return threadLocalRandom.nextInt();\n    }\n\n\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(Randombenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n\n```\n\n测试结果\n\n```\n··· 前面一部分省略，主要内容如下\nBenchmark                          Mode  Cnt    Score     Error  Units\nRandombenchmark.random             avgt    3  349.952 ± 115.007  ns/op\nRandombenchmark.threadLocalRandom  avgt    3   26.393 ±  11.538  ns/op\n```\n\n从上面结果可以看出，结果验证确实ThreadLocalRandom在多线程环境情况下更快，ThreadLocalRandom比Random快了将近13倍之多。\n\n至于为什么ThreadLocalRandom更快呢，这个要从源码来分析。\n\nRandom的实现也比较简单，初始化的时候用当前的事件来初始化一个随机数种子，然后每次取值的时候用这个种子与有些MagicNumber运算，并更新种子。最核心的就是这个next的函数，不管你是调用了nextDouble还是nextInt还是nextBoolean，Random底层都是调这个next(int bits)。\n\n```java\n    protected int next(int bits) {\n        long oldseed, nextseed;\n        AtomicLong seed = this.seed;\n        do {\n            oldseed = seed.get();\n            nextseed = (oldseed * multiplier + addend) & mask;\n        } while (!seed.compareAndSet(oldseed, nextseed));\n        return (int)(nextseed >>> (48 - bits));\n    }\n```\n\n　　为了保证多线程下每次生成随机数都是用的不同，next()得保证seed的更新是原子操作，所以用了AtomicLong的compareAndSet()，该方法底层调用了sum.misc.Unsafe的compareAndSwapLong()，也就是大家常听到的CAS， 这是一个native方法，它能保证原子更新一个数。\n\n既然Random是线程安全的，又能满足我们大多说的要求，为什么concurrent包里还要实现一个ThreadLocalRandom。在oracle的jdk文档里发现这样一句话\n\n> use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.\n\n大意就是用ThreadLocalRandom更适合用在多线程下，能大幅减少多线程并行下的性能开销和资源争抢。\n\n　既然ThreadLocalRandom在多线程下表现这么牛逼，它究竟是如何做到的？我们来看下源码，它的核心代码是这个（在看源码时需要注意一点，虽然ThreadLocalRandom也实现了next函数，但是在这个函数上面有一句，定义了这个方法，但绝不使用，你也可以从next*方法里面看出，使用的都是mix32(nextSeed)或者mix64(nextSeed)来获取随机数）\n\n```java\n    final long nextSeed() {\n        Thread t; long r; // read and update per-thread seed\n        UNSAFE.putLong(t = Thread.currentThread(), SEED,\n                       r = UNSAFE.getLong(t, SEED) + GAMMA);\n        return r;\n    }\n```\n\n上面虽然使用了UNSAFE对象，但是没有调用CAS方法，只是简单的替换Thread对象中的threadLocalRandomSeed属性，所以不要一看到UNSAFE这个类，就当成要调用CAS方法，我刚开始阅读的时候就有这个疑惑，自己太菜了。\n\n在创建ThreadLocalRandom对象时，ThreadLocalRandom是对每个线程都设置了单独的随机数种子，这样就不会发生多线程同时更新一个数时产生的资源争抢了，用空间换时间。\n\n### 3. 补充\n\n在生成验证码的情况下，不要使用Random，因为它是线性可预测的。所以在安全性要求比较高的场合，应当使用SecureRandom。从理论上来说计算机产生的随机数都是伪随机数，要想**产生高强度的随机数，有两个重要的因素：种子和算法。当然算法是可以有很多的，但是如何选择种子是非常关键的因素。如Random，它的种子是System.currentTimeMillis()，所以它的随机数都是可预测的。那么如何得到一个近似随机的种子？这里有一个很别致的思路：收集计算机的各种信息，如键盘输入时间，CPU时钟，内存使用状态，硬盘空闲空间，IO延时，进程数量，线程数量等信息，来得到一个近似随机的种子。这样的话，除了理论上有破解的可能，实际上基本没有被破解的可能。而事实上，现在的高强度的随机数生成器都是这样实现的。**\n\n\n\n### 参考\n\n1. [java.util.Random和concurrent.ThreadLocalRandom对比](https://xindoo.me/article/1400)\n2. [C 位操作 左移32位 错误](https://blog.csdn.net/huqinweI987/article/details/70941199) 这个是我在进行源码研究时，发先自己int类型的说移动32位还是原数子，从这篇文章找到了答案\n3. [Java随机数探秘](https://www.cnkirito.moe/java-random/)","source":"_posts/Random 与 ThreadLocalRandom 对比.md","raw":"title: Random 与 ThreadLocalRandom 对比\ntags:\n  - JUC\ncategories:\n  - java\nauthor: zhangke\nabbrlink: 26181\ndate: 2018-12-12 15:42:00\n---\n---\n# Random 与 ThreadLocalRandom 对比\n\n1. 简介\n2. 测试结果与分析\n3. 补充\n\n### 1. 简介\n\n首先，如果你看到这篇文章相信对这俩个类有一定的了解，所以我就不再这里介绍具体的用法。简单的介绍一下这个类，Random，ThreadLocalRandom是Java中的随机数生成器，Random是我们比较常用的随机数生成器，他是线程安全的。ThreadLocalRandom是jdk7才出现的，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，同时也能保证线程安全和提高性能。\n\n由于本人能力有限，如果你的英文比较好，可以看看StackOverFlow上的这个讨论[https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom](https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom)\n<!--  more -->\n\n### 2. 测试结果与分析\n\n我使用的JMH来进行的压测，这篇文章可以帮助你[入门 JMH](https://www.cnkirito.moe/java-jmh/)。具体代码如下\n\n```java\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 11:44\n *      email  : 398757724@qq.com\n *      Desc   : ThreadRandom 和 Random性能对比\n ***************************************/\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 5)\n@Measurement(iterations = 3, time = 5)\n@Threads(10)\n@Fork(1)\n@State(Scope.Benchmark)\npublic class Randombenchmark {\n    Random random = new Random();\n\n    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n\n\n    @Benchmark\n    public int random() {\n        return random.nextInt();\n    }\n\n\n    @Benchmark\n    public int threadLocalRandom() {\n        return threadLocalRandom.nextInt();\n    }\n\n\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(Randombenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n\n```\n\n测试结果\n\n```\n··· 前面一部分省略，主要内容如下\nBenchmark                          Mode  Cnt    Score     Error  Units\nRandombenchmark.random             avgt    3  349.952 ± 115.007  ns/op\nRandombenchmark.threadLocalRandom  avgt    3   26.393 ±  11.538  ns/op\n```\n\n从上面结果可以看出，结果验证确实ThreadLocalRandom在多线程环境情况下更快，ThreadLocalRandom比Random快了将近13倍之多。\n\n至于为什么ThreadLocalRandom更快呢，这个要从源码来分析。\n\nRandom的实现也比较简单，初始化的时候用当前的事件来初始化一个随机数种子，然后每次取值的时候用这个种子与有些MagicNumber运算，并更新种子。最核心的就是这个next的函数，不管你是调用了nextDouble还是nextInt还是nextBoolean，Random底层都是调这个next(int bits)。\n\n```java\n    protected int next(int bits) {\n        long oldseed, nextseed;\n        AtomicLong seed = this.seed;\n        do {\n            oldseed = seed.get();\n            nextseed = (oldseed * multiplier + addend) & mask;\n        } while (!seed.compareAndSet(oldseed, nextseed));\n        return (int)(nextseed >>> (48 - bits));\n    }\n```\n\n　　为了保证多线程下每次生成随机数都是用的不同，next()得保证seed的更新是原子操作，所以用了AtomicLong的compareAndSet()，该方法底层调用了sum.misc.Unsafe的compareAndSwapLong()，也就是大家常听到的CAS， 这是一个native方法，它能保证原子更新一个数。\n\n既然Random是线程安全的，又能满足我们大多说的要求，为什么concurrent包里还要实现一个ThreadLocalRandom。在oracle的jdk文档里发现这样一句话\n\n> use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.\n\n大意就是用ThreadLocalRandom更适合用在多线程下，能大幅减少多线程并行下的性能开销和资源争抢。\n\n　既然ThreadLocalRandom在多线程下表现这么牛逼，它究竟是如何做到的？我们来看下源码，它的核心代码是这个（在看源码时需要注意一点，虽然ThreadLocalRandom也实现了next函数，但是在这个函数上面有一句，定义了这个方法，但绝不使用，你也可以从next*方法里面看出，使用的都是mix32(nextSeed)或者mix64(nextSeed)来获取随机数）\n\n```java\n    final long nextSeed() {\n        Thread t; long r; // read and update per-thread seed\n        UNSAFE.putLong(t = Thread.currentThread(), SEED,\n                       r = UNSAFE.getLong(t, SEED) + GAMMA);\n        return r;\n    }\n```\n\n上面虽然使用了UNSAFE对象，但是没有调用CAS方法，只是简单的替换Thread对象中的threadLocalRandomSeed属性，所以不要一看到UNSAFE这个类，就当成要调用CAS方法，我刚开始阅读的时候就有这个疑惑，自己太菜了。\n\n在创建ThreadLocalRandom对象时，ThreadLocalRandom是对每个线程都设置了单独的随机数种子，这样就不会发生多线程同时更新一个数时产生的资源争抢了，用空间换时间。\n\n### 3. 补充\n\n在生成验证码的情况下，不要使用Random，因为它是线性可预测的。所以在安全性要求比较高的场合，应当使用SecureRandom。从理论上来说计算机产生的随机数都是伪随机数，要想**产生高强度的随机数，有两个重要的因素：种子和算法。当然算法是可以有很多的，但是如何选择种子是非常关键的因素。如Random，它的种子是System.currentTimeMillis()，所以它的随机数都是可预测的。那么如何得到一个近似随机的种子？这里有一个很别致的思路：收集计算机的各种信息，如键盘输入时间，CPU时钟，内存使用状态，硬盘空闲空间，IO延时，进程数量，线程数量等信息，来得到一个近似随机的种子。这样的话，除了理论上有破解的可能，实际上基本没有被破解的可能。而事实上，现在的高强度的随机数生成器都是这样实现的。**\n\n\n\n### 参考\n\n1. [java.util.Random和concurrent.ThreadLocalRandom对比](https://xindoo.me/article/1400)\n2. [C 位操作 左移32位 错误](https://blog.csdn.net/huqinweI987/article/details/70941199) 这个是我在进行源码研究时，发先自己int类型的说移动32位还是原数子，从这篇文章找到了答案\n3. [Java随机数探秘](https://www.cnkirito.moe/java-random/)","slug":"Random 与 ThreadLocalRandom 对比","published":1,"updated":"2019-01-04T01:58:58.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovja00029q1u5lf1hmt9","content":"<hr>\n<h1 id=\"Random-与-ThreadLocalRandom-对比\"><a href=\"#Random-与-ThreadLocalRandom-对比\" class=\"headerlink\" title=\"Random 与 ThreadLocalRandom 对比\"></a>Random 与 ThreadLocalRandom 对比</h1><ol>\n<li>简介</li>\n<li>测试结果与分析</li>\n<li>补充</li>\n</ol>\n<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>首先，如果你看到这篇文章相信对这俩个类有一定的了解，所以我就不再这里介绍具体的用法。简单的介绍一下这个类，Random，ThreadLocalRandom是Java中的随机数生成器，Random是我们比较常用的随机数生成器，他是线程安全的。ThreadLocalRandom是jdk7才出现的，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，同时也能保证线程安全和提高性能。</p>\n<p>由于本人能力有限，如果你的英文比较好，可以看看StackOverFlow上的这个讨论<a href=\"https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom</a><br><a id=\"more\"></a></p>\n<h3 id=\"2-测试结果与分析\"><a href=\"#2-测试结果与分析\" class=\"headerlink\" title=\"2. 测试结果与分析\"></a>2. 测试结果与分析</h3><p>我使用的JMH来进行的压测，这篇文章可以帮助你<a href=\"https://www.cnkirito.moe/java-jmh/\" target=\"_blank\" rel=\"noopener\">入门 JMH</a>。具体代码如下</p>\n<pre><code class=\"java\">/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 11:44\n *      email  : 398757724@qq.com\n *      Desc   : ThreadRandom 和 Random性能对比\n ***************************************/\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 5)\n@Measurement(iterations = 3, time = 5)\n@Threads(10)\n@Fork(1)\n@State(Scope.Benchmark)\npublic class Randombenchmark {\n    Random random = new Random();\n\n    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n\n\n    @Benchmark\n    public int random() {\n        return random.nextInt();\n    }\n\n\n    @Benchmark\n    public int threadLocalRandom() {\n        return threadLocalRandom.nextInt();\n    }\n\n\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(Randombenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n\n</code></pre>\n<p>测试结果</p>\n<pre><code>··· 前面一部分省略，主要内容如下\nBenchmark                          Mode  Cnt    Score     Error  Units\nRandombenchmark.random             avgt    3  349.952 ± 115.007  ns/op\nRandombenchmark.threadLocalRandom  avgt    3   26.393 ±  11.538  ns/op\n</code></pre><p>从上面结果可以看出，结果验证确实ThreadLocalRandom在多线程环境情况下更快，ThreadLocalRandom比Random快了将近13倍之多。</p>\n<p>至于为什么ThreadLocalRandom更快呢，这个要从源码来分析。</p>\n<p>Random的实现也比较简单，初始化的时候用当前的事件来初始化一个随机数种子，然后每次取值的时候用这个种子与有些MagicNumber运算，并更新种子。最核心的就是这个next的函数，不管你是调用了nextDouble还是nextInt还是nextBoolean，Random底层都是调这个next(int bits)。</p>\n<pre><code class=\"java\">    protected int next(int bits) {\n        long oldseed, nextseed;\n        AtomicLong seed = this.seed;\n        do {\n            oldseed = seed.get();\n            nextseed = (oldseed * multiplier + addend) &amp; mask;\n        } while (!seed.compareAndSet(oldseed, nextseed));\n        return (int)(nextseed &gt;&gt;&gt; (48 - bits));\n    }\n</code></pre>\n<p>　　为了保证多线程下每次生成随机数都是用的不同，next()得保证seed的更新是原子操作，所以用了AtomicLong的compareAndSet()，该方法底层调用了sum.misc.Unsafe的compareAndSwapLong()，也就是大家常听到的CAS， 这是一个native方法，它能保证原子更新一个数。</p>\n<p>既然Random是线程安全的，又能满足我们大多说的要求，为什么concurrent包里还要实现一个ThreadLocalRandom。在oracle的jdk文档里发现这样一句话</p>\n<blockquote>\n<p>use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.</p>\n</blockquote>\n<p>大意就是用ThreadLocalRandom更适合用在多线程下，能大幅减少多线程并行下的性能开销和资源争抢。</p>\n<p>　既然ThreadLocalRandom在多线程下表现这么牛逼，它究竟是如何做到的？我们来看下源码，它的核心代码是这个（在看源码时需要注意一点，虽然ThreadLocalRandom也实现了next函数，但是在这个函数上面有一句，定义了这个方法，但绝不使用，你也可以从next*方法里面看出，使用的都是mix32(nextSeed)或者mix64(nextSeed)来获取随机数）</p>\n<pre><code class=\"java\">    final long nextSeed() {\n        Thread t; long r; // read and update per-thread seed\n        UNSAFE.putLong(t = Thread.currentThread(), SEED,\n                       r = UNSAFE.getLong(t, SEED) + GAMMA);\n        return r;\n    }\n</code></pre>\n<p>上面虽然使用了UNSAFE对象，但是没有调用CAS方法，只是简单的替换Thread对象中的threadLocalRandomSeed属性，所以不要一看到UNSAFE这个类，就当成要调用CAS方法，我刚开始阅读的时候就有这个疑惑，自己太菜了。</p>\n<p>在创建ThreadLocalRandom对象时，ThreadLocalRandom是对每个线程都设置了单独的随机数种子，这样就不会发生多线程同时更新一个数时产生的资源争抢了，用空间换时间。</p>\n<h3 id=\"3-补充\"><a href=\"#3-补充\" class=\"headerlink\" title=\"3. 补充\"></a>3. 补充</h3><p>在生成验证码的情况下，不要使用Random，因为它是线性可预测的。所以在安全性要求比较高的场合，应当使用SecureRandom。从理论上来说计算机产生的随机数都是伪随机数，要想<strong>产生高强度的随机数，有两个重要的因素：种子和算法。当然算法是可以有很多的，但是如何选择种子是非常关键的因素。如Random，它的种子是System.currentTimeMillis()，所以它的随机数都是可预测的。那么如何得到一个近似随机的种子？这里有一个很别致的思路：收集计算机的各种信息，如键盘输入时间，CPU时钟，内存使用状态，硬盘空闲空间，IO延时，进程数量，线程数量等信息，来得到一个近似随机的种子。这样的话，除了理论上有破解的可能，实际上基本没有被破解的可能。而事实上，现在的高强度的随机数生成器都是这样实现的。</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://xindoo.me/article/1400\" target=\"_blank\" rel=\"noopener\">java.util.Random和concurrent.ThreadLocalRandom对比</a></li>\n<li><a href=\"https://blog.csdn.net/huqinweI987/article/details/70941199\" target=\"_blank\" rel=\"noopener\">C 位操作 左移32位 错误</a> 这个是我在进行源码研究时，发先自己int类型的说移动32位还是原数子，从这篇文章找到了答案</li>\n<li><a href=\"https://www.cnkirito.moe/java-random/\" target=\"_blank\" rel=\"noopener\">Java随机数探秘</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<hr>\n<h1 id=\"Random-与-ThreadLocalRandom-对比\"><a href=\"#Random-与-ThreadLocalRandom-对比\" class=\"headerlink\" title=\"Random 与 ThreadLocalRandom 对比\"></a>Random 与 ThreadLocalRandom 对比</h1><ol>\n<li>简介</li>\n<li>测试结果与分析</li>\n<li>补充</li>\n</ol>\n<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>首先，如果你看到这篇文章相信对这俩个类有一定的了解，所以我就不再这里介绍具体的用法。简单的介绍一下这个类，Random，ThreadLocalRandom是Java中的随机数生成器，Random是我们比较常用的随机数生成器，他是线程安全的。ThreadLocalRandom是jdk7才出现的，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，同时也能保证线程安全和提高性能。</p>\n<p>由于本人能力有限，如果你的英文比较好，可以看看StackOverFlow上的这个讨论<a href=\"https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom</a><br>","more":"</p>\n<h3 id=\"2-测试结果与分析\"><a href=\"#2-测试结果与分析\" class=\"headerlink\" title=\"2. 测试结果与分析\"></a>2. 测试结果与分析</h3><p>我使用的JMH来进行的压测，这篇文章可以帮助你<a href=\"https://www.cnkirito.moe/java-jmh/\" target=\"_blank\" rel=\"noopener\">入门 JMH</a>。具体代码如下</p>\n<pre><code class=\"java\">/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 11:44\n *      email  : 398757724@qq.com\n *      Desc   : ThreadRandom 和 Random性能对比\n ***************************************/\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 5)\n@Measurement(iterations = 3, time = 5)\n@Threads(10)\n@Fork(1)\n@State(Scope.Benchmark)\npublic class Randombenchmark {\n    Random random = new Random();\n\n    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n\n\n    @Benchmark\n    public int random() {\n        return random.nextInt();\n    }\n\n\n    @Benchmark\n    public int threadLocalRandom() {\n        return threadLocalRandom.nextInt();\n    }\n\n\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(Randombenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n\n</code></pre>\n<p>测试结果</p>\n<pre><code>··· 前面一部分省略，主要内容如下\nBenchmark                          Mode  Cnt    Score     Error  Units\nRandombenchmark.random             avgt    3  349.952 ± 115.007  ns/op\nRandombenchmark.threadLocalRandom  avgt    3   26.393 ±  11.538  ns/op\n</code></pre><p>从上面结果可以看出，结果验证确实ThreadLocalRandom在多线程环境情况下更快，ThreadLocalRandom比Random快了将近13倍之多。</p>\n<p>至于为什么ThreadLocalRandom更快呢，这个要从源码来分析。</p>\n<p>Random的实现也比较简单，初始化的时候用当前的事件来初始化一个随机数种子，然后每次取值的时候用这个种子与有些MagicNumber运算，并更新种子。最核心的就是这个next的函数，不管你是调用了nextDouble还是nextInt还是nextBoolean，Random底层都是调这个next(int bits)。</p>\n<pre><code class=\"java\">    protected int next(int bits) {\n        long oldseed, nextseed;\n        AtomicLong seed = this.seed;\n        do {\n            oldseed = seed.get();\n            nextseed = (oldseed * multiplier + addend) &amp; mask;\n        } while (!seed.compareAndSet(oldseed, nextseed));\n        return (int)(nextseed &gt;&gt;&gt; (48 - bits));\n    }\n</code></pre>\n<p>　　为了保证多线程下每次生成随机数都是用的不同，next()得保证seed的更新是原子操作，所以用了AtomicLong的compareAndSet()，该方法底层调用了sum.misc.Unsafe的compareAndSwapLong()，也就是大家常听到的CAS， 这是一个native方法，它能保证原子更新一个数。</p>\n<p>既然Random是线程安全的，又能满足我们大多说的要求，为什么concurrent包里还要实现一个ThreadLocalRandom。在oracle的jdk文档里发现这样一句话</p>\n<blockquote>\n<p>use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.</p>\n</blockquote>\n<p>大意就是用ThreadLocalRandom更适合用在多线程下，能大幅减少多线程并行下的性能开销和资源争抢。</p>\n<p>　既然ThreadLocalRandom在多线程下表现这么牛逼，它究竟是如何做到的？我们来看下源码，它的核心代码是这个（在看源码时需要注意一点，虽然ThreadLocalRandom也实现了next函数，但是在这个函数上面有一句，定义了这个方法，但绝不使用，你也可以从next*方法里面看出，使用的都是mix32(nextSeed)或者mix64(nextSeed)来获取随机数）</p>\n<pre><code class=\"java\">    final long nextSeed() {\n        Thread t; long r; // read and update per-thread seed\n        UNSAFE.putLong(t = Thread.currentThread(), SEED,\n                       r = UNSAFE.getLong(t, SEED) + GAMMA);\n        return r;\n    }\n</code></pre>\n<p>上面虽然使用了UNSAFE对象，但是没有调用CAS方法，只是简单的替换Thread对象中的threadLocalRandomSeed属性，所以不要一看到UNSAFE这个类，就当成要调用CAS方法，我刚开始阅读的时候就有这个疑惑，自己太菜了。</p>\n<p>在创建ThreadLocalRandom对象时，ThreadLocalRandom是对每个线程都设置了单独的随机数种子，这样就不会发生多线程同时更新一个数时产生的资源争抢了，用空间换时间。</p>\n<h3 id=\"3-补充\"><a href=\"#3-补充\" class=\"headerlink\" title=\"3. 补充\"></a>3. 补充</h3><p>在生成验证码的情况下，不要使用Random，因为它是线性可预测的。所以在安全性要求比较高的场合，应当使用SecureRandom。从理论上来说计算机产生的随机数都是伪随机数，要想<strong>产生高强度的随机数，有两个重要的因素：种子和算法。当然算法是可以有很多的，但是如何选择种子是非常关键的因素。如Random，它的种子是System.currentTimeMillis()，所以它的随机数都是可预测的。那么如何得到一个近似随机的种子？这里有一个很别致的思路：收集计算机的各种信息，如键盘输入时间，CPU时钟，内存使用状态，硬盘空闲空间，IO延时，进程数量，线程数量等信息，来得到一个近似随机的种子。这样的话，除了理论上有破解的可能，实际上基本没有被破解的可能。而事实上，现在的高强度的随机数生成器都是这样实现的。</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://xindoo.me/article/1400\" target=\"_blank\" rel=\"noopener\">java.util.Random和concurrent.ThreadLocalRandom对比</a></li>\n<li><a href=\"https://blog.csdn.net/huqinweI987/article/details/70941199\" target=\"_blank\" rel=\"noopener\">C 位操作 左移32位 错误</a> 这个是我在进行源码研究时，发先自己int类型的说移动32位还是原数子，从这篇文章找到了答案</li>\n<li><a href=\"https://www.cnkirito.moe/java-random/\" target=\"_blank\" rel=\"noopener\">Java随机数探秘</a></li>\n</ol>"},{"title":"使用 Travis CI 自动更新 GitHub Pages","author":"枫秀天涯","abbrlink":32102,"date":"2018-12-28T06:59:00.000Z","_content":"此篇博客主要为记录学习使用\n在研究过程中主要参考如下俩篇文章\n1. [使用 Travis CI 自动更新 GitHub Pages](https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/)\n2. [在持续集成过程出现文件为空的错误解决](http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/)","source":"_posts/使用-Travis-CI-自动更新-GitHub-Pages.md","raw":"---\ntitle: 使用 Travis CI 自动更新 GitHub Pages\nauthor: 枫秀天涯\ntags:\n  - 博客建站\ncategories:\n  - 其他\nabbrlink: 32102\ndate: 2018-12-28 14:59:00\n---\n此篇博客主要为记录学习使用\n在研究过程中主要参考如下俩篇文章\n1. [使用 Travis CI 自动更新 GitHub Pages](https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/)\n2. [在持续集成过程出现文件为空的错误解决](http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/)","slug":"使用-Travis-CI-自动更新-GitHub-Pages","published":1,"updated":"2019-01-02T05:50:19.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovjd00049q1uudgb33ld","content":"<p>此篇博客主要为记录学习使用<br>在研究过程中主要参考如下俩篇文章</p>\n<ol>\n<li><a href=\"https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/\" target=\"_blank\" rel=\"noopener\">使用 Travis CI 自动更新 GitHub Pages</a></li>\n<li><a href=\"http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/\" target=\"_blank\" rel=\"noopener\">在持续集成过程出现文件为空的错误解决</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>此篇博客主要为记录学习使用<br>在研究过程中主要参考如下俩篇文章</p>\n<ol>\n<li><a href=\"https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/\" target=\"_blank\" rel=\"noopener\">使用 Travis CI 自动更新 GitHub Pages</a></li>\n<li><a href=\"http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/\" target=\"_blank\" rel=\"noopener\">在持续集成过程出现文件为空的错误解决</a></li>\n</ol>\n"},{"title":"虚拟内存","author":"zhangke","abbrlink":"f79e4123","date":"2018-09-21T06:42:00.000Z","_content":"# 虚拟内存\n\n### 概述\n\n1. 虚拟内存是什么、可以用来做什么\n2. 基本概念介绍\n3. 虚拟内存作为缓存的工具\n4. 虚拟内存作为内存管理的工具\n5. 虚拟内存作为内存保护的工具\n\n### 1. 虚拟内存是什么、功能是什么\n\n**虚拟内存是什么**\n\n**虚拟内存**是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。\n\n下面是《深入立即操作系统》给出的定义：\n\n> 为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。\n\n并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。\n\n虚拟内存功能是什么\n\n1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。\n2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。\n3. 它保护了每个进程的地址空间不被其他进程破坏。\n\n<!-- more -->\n\n### 2.基本概念介绍\n\n#### 物理地址、虚拟地址\n\n虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：\n\n![物理寻址](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg)\n\n主存的每个地址都是唯一的，第一个字节地址为0，接下来为1，以此类推。CPU使用这种访问方式就是**物理寻址**。上图所示就是CPU通过**地址总线**传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。\n\n当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：\n\n![img](upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp)\n\n\n\n使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。\n\n我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。\n\n#### 地址空间\n\n地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。\n\n### 3. 虚拟内存作为缓存的工具\n\n**虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。**\n\n从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块(block)，这些块作为和主存(较高层)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。\n\n在任意时刻，虚拟页面都分为三个不相交的部分：\n\n- **未分配的(Unallocated)**：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。\n- **缓存的(Cached)**：当前已缓存在物理内存中的已分配页。\n- **未缓存的(UnCached)**：该页已经映射到磁盘上了，但是还没缓存在物理内存中。\n\n> 其中**未分配的VP**不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射，毕竟程序不可能实际使用那么大的地址空间。\n\n![](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png)\n\n图13：VM使用主存来作为缓存\n\n上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。\n\n> 当然，那个图上标注的不对,VP 部分， `n-p`和`N-1`应该分别标注为`3`和`7`,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。\n\n### 参考\n\n[什么是虚拟内存](https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-3/virtual_mem_managment.html)\n\n[《深入理解计算机系统》| 虚拟存储器](https://www.jianshu.com/p/e1b82b230917)\n\n[什么是内存(二)：虚拟内存](https://www.cnblogs.com/yaoxiaowen/p/7805964.html)","source":"_posts/虚拟内存.md","raw":"title: 虚拟内存\nauthor: zhangke\nabbrlink: f79e4123\ntags:\n  - 操作系统\ncategories:\n  - 操作系统\ndate: 2018-09-21 14:42:00\n---\n# 虚拟内存\n\n### 概述\n\n1. 虚拟内存是什么、可以用来做什么\n2. 基本概念介绍\n3. 虚拟内存作为缓存的工具\n4. 虚拟内存作为内存管理的工具\n5. 虚拟内存作为内存保护的工具\n\n### 1. 虚拟内存是什么、功能是什么\n\n**虚拟内存是什么**\n\n**虚拟内存**是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。\n\n下面是《深入立即操作系统》给出的定义：\n\n> 为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。\n\n并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。\n\n虚拟内存功能是什么\n\n1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。\n2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。\n3. 它保护了每个进程的地址空间不被其他进程破坏。\n\n<!-- more -->\n\n### 2.基本概念介绍\n\n#### 物理地址、虚拟地址\n\n虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：\n\n![物理寻址](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg)\n\n主存的每个地址都是唯一的，第一个字节地址为0，接下来为1，以此类推。CPU使用这种访问方式就是**物理寻址**。上图所示就是CPU通过**地址总线**传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。\n\n当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：\n\n![img](upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp)\n\n\n\n使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。\n\n我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。\n\n#### 地址空间\n\n地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。\n\n### 3. 虚拟内存作为缓存的工具\n\n**虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。**\n\n从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块(block)，这些块作为和主存(较高层)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。\n\n在任意时刻，虚拟页面都分为三个不相交的部分：\n\n- **未分配的(Unallocated)**：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。\n- **缓存的(Cached)**：当前已缓存在物理内存中的已分配页。\n- **未缓存的(UnCached)**：该页已经映射到磁盘上了，但是还没缓存在物理内存中。\n\n> 其中**未分配的VP**不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射，毕竟程序不可能实际使用那么大的地址空间。\n\n![](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png)\n\n图13：VM使用主存来作为缓存\n\n上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。\n\n> 当然，那个图上标注的不对,VP 部分， `n-p`和`N-1`应该分别标注为`3`和`7`,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。\n\n### 参考\n\n[什么是虚拟内存](https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-3/virtual_mem_managment.html)\n\n[《深入理解计算机系统》| 虚拟存储器](https://www.jianshu.com/p/e1b82b230917)\n\n[什么是内存(二)：虚拟内存](https://www.cnblogs.com/yaoxiaowen/p/7805964.html)","slug":"虚拟内存","published":1,"updated":"2019-01-04T01:48:59.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovjh00079q1umfu8cn21","content":"<h1 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>虚拟内存是什么、可以用来做什么</li>\n<li>基本概念介绍</li>\n<li>虚拟内存作为缓存的工具</li>\n<li>虚拟内存作为内存管理的工具</li>\n<li>虚拟内存作为内存保护的工具</li>\n</ol>\n<h3 id=\"1-虚拟内存是什么、功能是什么\"><a href=\"#1-虚拟内存是什么、功能是什么\" class=\"headerlink\" title=\"1. 虚拟内存是什么、功能是什么\"></a>1. 虚拟内存是什么、功能是什么</h3><p><strong>虚拟内存是什么</strong></p>\n<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>\n<p>下面是《深入立即操作系统》给出的定义：</p>\n<blockquote>\n<p>为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。</p>\n</blockquote>\n<p>并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。</p>\n<p>虚拟内存功能是什么</p>\n<ol>\n<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。</li>\n<li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li>\n<li>它保护了每个进程的地址空间不被其他进程破坏。</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"2-基本概念介绍\"><a href=\"#2-基本概念介绍\" class=\"headerlink\" title=\"2.基本概念介绍\"></a>2.基本概念介绍</h3><h4 id=\"物理地址、虚拟地址\"><a href=\"#物理地址、虚拟地址\" class=\"headerlink\" title=\"物理地址、虚拟地址\"></a>物理地址、虚拟地址</h4><p>虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg\" alt=\"物理寻址\"></p>\n<p>主存的每个地址都是唯一的，第一个字节地址为0，接下来为1，以此类推。CPU使用这种访问方式就是<strong>物理寻址</strong>。上图所示就是CPU通过<strong>地址总线</strong>传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。</p>\n<p>当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：</p>\n<p><img src=\"upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp\" alt=\"img\"></p>\n<p>使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。</p>\n<p>我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。</p>\n<h4 id=\"地址空间\"><a href=\"#地址空间\" class=\"headerlink\" title=\"地址空间\"></a>地址空间</h4><p>地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>\n<h3 id=\"3-虚拟内存作为缓存的工具\"><a href=\"#3-虚拟内存作为缓存的工具\" class=\"headerlink\" title=\"3. 虚拟内存作为缓存的工具\"></a>3. 虚拟内存作为缓存的工具</h3><p><strong>虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。</strong></p>\n<p>从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块(block)，这些块作为和主存(较高层)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。</p>\n<p>在任意时刻，虚拟页面都分为三个不相交的部分：</p>\n<ul>\n<li><strong>未分配的(Unallocated)</strong>：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。</li>\n<li><strong>缓存的(Cached)</strong>：当前已缓存在物理内存中的已分配页。</li>\n<li><strong>未缓存的(UnCached)</strong>：该页已经映射到磁盘上了，但是还没缓存在物理内存中。</li>\n</ul>\n<blockquote>\n<p>其中<strong>未分配的VP</strong>不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射，毕竟程序不可能实际使用那么大的地址空间。</p>\n</blockquote>\n<p><img src=\"https://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png\" alt=\"\"></p>\n<p>图13：VM使用主存来作为缓存</p>\n<p>上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。</p>\n<blockquote>\n<p>当然，那个图上标注的不对,VP 部分， <code>n-p</code>和<code>N-1</code>应该分别标注为<code>3</code>和<code>7</code>,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。</p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-3/virtual_mem_managment.html\" target=\"_blank\" rel=\"noopener\">什么是虚拟内存</a></p>\n<p><a href=\"https://www.jianshu.com/p/e1b82b230917\" target=\"_blank\" rel=\"noopener\">《深入理解计算机系统》| 虚拟存储器</a></p>\n<p><a href=\"https://www.cnblogs.com/yaoxiaowen/p/7805964.html\" target=\"_blank\" rel=\"noopener\">什么是内存(二)：虚拟内存</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>虚拟内存是什么、可以用来做什么</li>\n<li>基本概念介绍</li>\n<li>虚拟内存作为缓存的工具</li>\n<li>虚拟内存作为内存管理的工具</li>\n<li>虚拟内存作为内存保护的工具</li>\n</ol>\n<h3 id=\"1-虚拟内存是什么、功能是什么\"><a href=\"#1-虚拟内存是什么、功能是什么\" class=\"headerlink\" title=\"1. 虚拟内存是什么、功能是什么\"></a>1. 虚拟内存是什么、功能是什么</h3><p><strong>虚拟内存是什么</strong></p>\n<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>\n<p>下面是《深入立即操作系统》给出的定义：</p>\n<blockquote>\n<p>为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。</p>\n</blockquote>\n<p>并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。</p>\n<p>虚拟内存功能是什么</p>\n<ol>\n<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。</li>\n<li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li>\n<li>它保护了每个进程的地址空间不被其他进程破坏。</li>\n</ol>","more":"<h3 id=\"2-基本概念介绍\"><a href=\"#2-基本概念介绍\" class=\"headerlink\" title=\"2.基本概念介绍\"></a>2.基本概念介绍</h3><h4 id=\"物理地址、虚拟地址\"><a href=\"#物理地址、虚拟地址\" class=\"headerlink\" title=\"物理地址、虚拟地址\"></a>物理地址、虚拟地址</h4><p>虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg\" alt=\"物理寻址\"></p>\n<p>主存的每个地址都是唯一的，第一个字节地址为0，接下来为1，以此类推。CPU使用这种访问方式就是<strong>物理寻址</strong>。上图所示就是CPU通过<strong>地址总线</strong>传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。</p>\n<p>当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：</p>\n<p><img src=\"upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp\" alt=\"img\"></p>\n<p>使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。</p>\n<p>我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。</p>\n<h4 id=\"地址空间\"><a href=\"#地址空间\" class=\"headerlink\" title=\"地址空间\"></a>地址空间</h4><p>地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>\n<h3 id=\"3-虚拟内存作为缓存的工具\"><a href=\"#3-虚拟内存作为缓存的工具\" class=\"headerlink\" title=\"3. 虚拟内存作为缓存的工具\"></a>3. 虚拟内存作为缓存的工具</h3><p><strong>虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。</strong></p>\n<p>从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块(block)，这些块作为和主存(较高层)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。</p>\n<p>在任意时刻，虚拟页面都分为三个不相交的部分：</p>\n<ul>\n<li><strong>未分配的(Unallocated)</strong>：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。</li>\n<li><strong>缓存的(Cached)</strong>：当前已缓存在物理内存中的已分配页。</li>\n<li><strong>未缓存的(UnCached)</strong>：该页已经映射到磁盘上了，但是还没缓存在物理内存中。</li>\n</ul>\n<blockquote>\n<p>其中<strong>未分配的VP</strong>不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射，毕竟程序不可能实际使用那么大的地址空间。</p>\n</blockquote>\n<p><img src=\"https://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png\" alt=\"\"></p>\n<p>图13：VM使用主存来作为缓存</p>\n<p>上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。</p>\n<blockquote>\n<p>当然，那个图上标注的不对,VP 部分， <code>n-p</code>和<code>N-1</code>应该分别标注为<code>3</code>和<code>7</code>,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。</p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-3/virtual_mem_managment.html\" target=\"_blank\" rel=\"noopener\">什么是虚拟内存</a></p>\n<p><a href=\"https://www.jianshu.com/p/e1b82b230917\" target=\"_blank\" rel=\"noopener\">《深入理解计算机系统》| 虚拟存储器</a></p>\n<p><a href=\"https://www.cnblogs.com/yaoxiaowen/p/7805964.html\" target=\"_blank\" rel=\"noopener\">什么是内存(二)：虚拟内存</a></p>"},{"title":"JVM源码分析之 FinalReference 完全解读","author":"枫秀天涯","abbrlink":13502,"date":"2019-01-04T02:24:00.000Z","_content":"# JVM源码分析之 FinalReference完全解读\n\n## 概述\n\nJava对象引用体系除了强引用之外，出于对性能、可扩展性等方面考虑还特地实现了4种其他引用：`SoftReference`、`WeakReference`、`PhantomReference`、`FinalReference`，本文主要想讲的是`FinalReference`，因为当使用内存分析工具，比如zprofiler、mat等，分析一些oom的heap时，经常能看到 `java.lang.ref.Finalizer`占用的内存大小远远排在前面，而这个类占用的内存大小又和我们这次的主角`FinalReference`有着密不可分的关系。\n\n`FinalReference`及关联的内容可能给我们留下如下印象：\n\n- 自己代码里从没有使用过；\n- 线程dump之后，会看到一个叫做`Finalizer`的Java线程；\n- 偶尔能注意到`java.lang.ref.Finalizer`的存在；\n- 在类里可能会写`finalize`方法。\n\n那`FinalReference`到底存在的意义是什么，以怎样的形式和我们的代码相关联呢？这是本文要理清的问题。\n<!-- more -->\n\n## JDK中的FinalReference\n\n首先我们看看`FinalReference`在JDK里的实现：\n\n```\nclass FinalReference&lt;T&gt; extends Reference&lt;T&gt; {\n\n    public FinalReference(T referent, ReferenceQueue&lt;? super T&gt; q) {\n        super(referent, q);\n    }\n\n}\n```\n\n大家应该注意到了类访问权限是package的，这也就意味着我们不能直接去对其进行扩展，但是JDK里对此类进行了扩展实现`java.lang.ref.Finalizer`，这个类在概述里提到的过，而此类的访问权限也是package的，并且是final的，意味着它不能再被扩展了，接下来的重点我们围绕`java.lang.ref.Finalizer`展开。(PS：后续讲的`Finalizer`其实也是在说`FinalReference`。)\n\n```\nfinal class Finalizer extends FinalReference { \n   /* Package-private; must be in same package as the \n   Referenceclass */\n   \n   /* A native method that invokes an arbitrary object's  \n   finalize method is  required since the finalize method is \n   protected*/\n    static native void invokeFinalizeMethod(Object o) throws Throwable;\n\n    private static ReferenceQueue queue = new ReferenceQueue();\n    private static Finalizer unfinalized = null;\n    private static final Object lock = new Object();\n\n    private Finalizer\n        next = null,\n        prev = null;\n\n    private Finalizer(Object finalizee) {\n        super(finalizee, queue);\n        add();\n    }\n\n    /* Invoked by VM */\n    static void register(Object finalizee) {\n        new Finalizer(finalizee);\n    }  \n\n    private void add() {\n        synchronized (lock) {\n            if (unfinalized != null) {\n                this.next = unfinalized;\n                unfinalized.prev = this;\n            }\n            unfinalized = this;\n        }\n    }\n\n    ...\n\n   }    \n```\n\n### Finalizer的构造函数\n\n`Finalizer`的构造函数提供了以下几个关键信息：\n\n- `private`：意味着我们无法在当前类之外构建这类的对象；\n- `finalizee`参数：`FinalReference`指向的对象引用；\n- 调用`add`方法：将当前对象插入到`Finalizer`对象链里，链里的对象和`Finalizer`类静态关联。言外之意是在这个链里的对象都无法被GC掉，除非将这种引用关系剥离（因为`Finalizer`类无法被unload）。\n\n虽然外面无法创建`Finalizer`对象，但是它有一个名为`register`的静态方法，该方法可以创建这种对象，同时将这个对象加入到`Finalizer`对象链里，这个方法是被vm调用的，那么问题来了，vm在什么情况下会调用这个方法呢？\n\n## Finalizer对象何时被注册到Finalizer对象链里\n\n类的修饰有很多，比如final，abstract，public等，如果某个类用final修饰，我们就说这个类是final类，上面列的都是语法层面我们可以显式指定的，在JVM里其实还会给类标记一些其他符号，比如`finalizer`，表示这个类是一个`finalizer`类（为了和`java.lang.ref.Fianlizer`类区分，下文在提到的`finalizer`类时会简称为f类），GC在处理这种类的对象时要做一些特殊的处理，如在这个对象被回收之前会调用它的`finalize`方法。\n\n#### 如何判断一个类是不是一个final类\n\n在讲这个问题之前，我们先来看下`java.lang.Object`里的一个方法\n\n```\n    protected void finalize() throws Throwable { }\n```\n\n在`Object`类里定义了一个名为`finalize`的空方法，这意味着Java里的所有类都会继承这个方法，甚至可以覆写该方法，并且根据方法覆写原则，如果子类覆盖此方法，方法访问权限至少protected级别的，这样其子类就算没有覆写此方法也会继承此方法。\n\n而判断当前类是否是f类的标准并不仅仅是当前类是否含有一个参数为空，返回值为void的`finalize`方法，还要求`finalize方法必须非空`，因此Object类虽然含有一个`finalize`方法，但它并不是f类，Object的对象在被GC回收时其实并不会调用它的`finalize`方法。\n\n需要注意的是，类在加载过程中其实就已经被标记为是否为f类了。（JVM在类加载的时候会遍历当前类的所有方法，包括父类的方法，只要有一个参数为空且返回void的非空`finalize`方法就认为这个类是f类。）\n\n### f类的对象何时传到Finalizer.register方法\n\n对象的创建其实是被拆分成多个步骤的，比如`A a=new A(2)`这样一条语句对应的字节码如下：\n\n```\n0: new           #1                  // class A\n3: dup\n4: iconst_2\n5: invokespecial #11                 // Method \"&lt;init&gt;\":(I)V\n```\n\n先执行new分配好对象空间，然后再执行invokespecial调用构造函数，JVM里其实可以让用户在这两个时机中选择一个，将当前对象传递给`Finalizer.register`方法来注册到`Finalizer`对象链里，这个选择取决于是否设置了`RegisterFinalizersAtInit`这个vm参数，默认值为true，也就是在构造函数返回之前调用`Finalizer.register`方法，如果通过`-XX:-RegisterFinalizersAtInit`关闭了该参数，那将在对象空间分配好之后将这个对象注册进去。\n\n另外需要提醒的是，当我们通过clone的方式复制一个对象时，如果当前类是一个f类，那么在clone完成时将调用`Finalizer.register`方法进行注册。\n\n### hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register\n\n这个实现比较有意思，在这简单提一下，我们知道执行一个构造函数时，会去调用父类的构造函数，主要是为了初始化继承自父类的属性，那么任何一个对象的初始化最终都会调用到`Object`的空构造函数里（任何空的构造函数其实并不空，会含有三条字节码指令，如下代码所示），为了不对所有类的构造函数都埋点调用`Finalizer.register`方法，hotspot的实现是，在初始化`Object`类时将构造函数里的`return`指令替换为`_return_register_finalizer`指令，该指令并不是标准的字节码指令，是hotspot扩展的指令，这样在处理该指令时调用`Finalizer.register`方法，以很小的侵入性代价完美地解决了这个问题。\n\n```\n0: aload_0\n1: invokespecial #21                 // Method java/lang/Object.\"&lt;init&gt;\":()V\n4: return\n```\n\n## f类对象的GC回收\n\n### FinalizerThread线程\n\n在`Finalizer`类的`clinit`方法（静态块）里，我们看到它会创建一个`FinalizerThread`守护线程，这个线程的优先级并不是最高的，意味着在CPU很紧张的情况下其被调度的优先级可能会受到影响\n\n```\n  private static class FinalizerThread extends Thread {\n        private volatile boolean running;\n        FinalizerThread(ThreadGroup g) {\n            super(g, \"Finalizer\");\n        }\n        public void run() {\n            if (running)\n                return;\n            running = true;\n            for (;;) {\n                try {\n                    Finalizer f = (Finalizer)queue.remove();\n                    f.runFinalizer();\n                } catch (InterruptedException x) {\n                    continue;\n                }\n            }\n        }\n    }\n\n    static {\n        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n        for (ThreadGroup tgn = tg;\n             tgn != null;\n             tg = tgn, tgn = tg.getParent());\n        Thread finalizer = new FinalizerThread(tg);\n        finalizer.setPriority(Thread.MAX_PRIORITY - 2);\n        finalizer.setDaemon(true);\n        finalizer.start();\n    }\n```\n\n这个线程用来从queue里获取`Finalizer`对象，然后执行该对象的`runFinalizer`方法，该方法会将`Finalizer`对象从`Finalizer`对象链里剥离出来，这样意味着下次GC发生时就可以将其关联的f对象回收了，最后将这个`Finalizer`对象关联的f对象传给一个native方法`invokeFinalizeMethod`\n\n```\nprivate void runFinalizer() {\n        synchronized (this) {\n            if (hasBeenFinalized()) return;\n            remove();\n        }\n        try {\n            Object finalizee = this.get();\n            if (finalizee != null && !(finalizee instanceof java.lang.Enum)) {\n                invokeFinalizeMethod(finalizee);\n                /* Clear stack slot containing this variable, to decrease\n                   the chances of false retention with a conservative GC */\n                finalizee = null;\n            }\n        } catch (Throwable x) { }\n        super.clear();\n    }\n\n static native void invokeFinalizeMethod(Object o) throws Throwable;\n```\n\n其实`invokeFinalizeMethod`方法就是调了这个f对象的finalize方法，看到这里大家应该恍然大悟了，整个过程都串起来了。\n\n```\nJNIEXPORT void JNICALL\nJava_java_lang_ref_Finalizer_invokeFinalizeMethod(JNIEnv *env, jclass clazz,\n                                                  jobject ob)\n{\n    jclass cls;\n    jmethodID mid;\n\n    cls = (*env)-&gt;GetObjectClass(env, ob);\n    if (cls == NULL) return;\n    mid = (*env)-&gt;GetMethodID(env, cls, \"finalize\", \"()V\");\n    if (mid == NULL) return;\n    (*env)-&gt;CallVoidMethod(env, ob, mid);\n}\n```\n\n### f对象的finalize方法抛出异常会导致FinalizeThread退出吗\n\n不知道大家有没有想过如果f对象的`finalize`方法抛了一个没捕获的异常，这个`FinalizerThread`会不会退出呢，细心的读者看上面的代码其实就可以找到答案，`runFinalizer`方法里对`Throwable`的异常进行了捕获，因此不可能出现`FinalizerThread`因异常未捕获而退出的情况。\n\n### f对象的finalize方法会执行多次吗\n\n如果我们在f对象的`finalize`方法里重新将当前对象赋值，变成可达对象，当这个f对象再次变成不可达时还会执行`finalize`方法吗？答案是否定的，因为在执行完第一次`finalize`方法后，这个f对象已经和之前的`Finalizer`对象剥离了，也就是下次GC的时候不会再发现`Finalizer`对象指向该f对象了，自然也就不会调用这个f对象的`finalize`方法了。\n\n### Finalizer对象何时被放到ReferenceQueue里\n\n除了这里接下来要介绍的环节之外，整个过程大家应该都比较清楚了。\n\n当GC发生时，GC算法会判断f类对象是不是只被`Finalizer`类引用（f类对象被`Finalizer`对象引用，然后放到`Finalizer`对象链里），如果这个类仅仅被`Finalizer`对象引用，说明这个对象在不久的将来会被回收，现在可以执行它的`finalize`方法了，于是会将这个`Finalizer`对象放到`Finalizer`类的`ReferenceQueue`里，但是这个f类对象其实并没有被回收，因为`Finalizer`这个类还对它们保持引用，在GC完成之前，JVM会调用`ReferenceQueue`中lock对象的notify方法（当`ReferenceQueue`为空时，`FinalizerThread`线程会调用`ReferenceQueue`的lock对象的wait方法直到被JVM唤醒），此时就会执行上面FinalizeThread线程里看到的其他逻辑了。\n\n## Finalizer导致的内存泄露\n\n这里举一个简单的例子，我们使用挺广的Socket通信，`SocksSocketImpl`的父类其实就实现了`finalize`方法:\n\n```\n/**\n * Cleans up if the user forgets to close it.\n */\nprotected void finalize() throws IOException {\n    close();\n}\n```\n\n其实这么做的主要目的是万一用户忘记关闭Socket，那么在这个对象被回收时能主动关闭Socket来释放一些系统资源，但是如果用户真的忘记关闭，那这些`socket`对象可能因为`FinalizeThread`迟迟没有执行这些`socket`对象的`finalize`方法，而导致内存泄露，这种问题我们碰到过多次，因此对于这类情况除了大家好好注意貌似没有什么更好的方法了，该做的事真不能省.\n\n## Finalizer的客观评价\n\n上面的过程基本对`Finalizer`的实现细节进行了完整剖析，Java里我们看到有构造函数，但是并没有看到析构函数一说，`Finalizer`其实是实现了析构函数的概念，我们在对象被回收前可以执行一些“收拾性”的逻辑，应该说是一个特殊场景的补充，但是这种概念的实现给f对象生命周期以及GC等带来了一些影响：\n\n- f对象因为`Finalizer`的引用而变成了一个临时的强引用，即使没有其他的强引用，还是无法立即被回收；\n- f对象至少经历两次GC才能被回收，因为只有在`FinalizerThread`执行完了f对象的`finalize`方法的情况下才有可能被下次GC回收，而有可能期间已经经历过多次GC了，但是一直还没执行f对象的`finalize`方法；\n- CPU资源比较稀缺的情况下`FinalizerThread`线程有可能因为优先级比较低而延迟执行f对象的`finalize`方法；\n- 因为f对象的`finalize`方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易引发old分代的GC，甚至Full GC，GC暂停时间明显变长；\n- f对象的`finalize`方法被调用后，这个对象其实还并没有被回收，虽然可能在不久的将来会被回收。\n\n## 参考\n1. [JVM 源码分析之 FinalReference 完全解读](https://www.infoq.cn/articles/jvm-source-code-analysis-finalreference)","source":"_posts/JVM源码分析之-FinalReference完全解读.md","raw":"title: JVM源码分析之 FinalReference 完全解读\nauthor: 枫秀天涯\nabbrlink: 13502\ntags:\n  - java\n  - java引用\n  - ''\n  - JVM\ncategories:\n  - java\ndate: 2019-01-04 10:24:00\n---\n# JVM源码分析之 FinalReference完全解读\n\n## 概述\n\nJava对象引用体系除了强引用之外，出于对性能、可扩展性等方面考虑还特地实现了4种其他引用：`SoftReference`、`WeakReference`、`PhantomReference`、`FinalReference`，本文主要想讲的是`FinalReference`，因为当使用内存分析工具，比如zprofiler、mat等，分析一些oom的heap时，经常能看到 `java.lang.ref.Finalizer`占用的内存大小远远排在前面，而这个类占用的内存大小又和我们这次的主角`FinalReference`有着密不可分的关系。\n\n`FinalReference`及关联的内容可能给我们留下如下印象：\n\n- 自己代码里从没有使用过；\n- 线程dump之后，会看到一个叫做`Finalizer`的Java线程；\n- 偶尔能注意到`java.lang.ref.Finalizer`的存在；\n- 在类里可能会写`finalize`方法。\n\n那`FinalReference`到底存在的意义是什么，以怎样的形式和我们的代码相关联呢？这是本文要理清的问题。\n<!-- more -->\n\n## JDK中的FinalReference\n\n首先我们看看`FinalReference`在JDK里的实现：\n\n```\nclass FinalReference&lt;T&gt; extends Reference&lt;T&gt; {\n\n    public FinalReference(T referent, ReferenceQueue&lt;? super T&gt; q) {\n        super(referent, q);\n    }\n\n}\n```\n\n大家应该注意到了类访问权限是package的，这也就意味着我们不能直接去对其进行扩展，但是JDK里对此类进行了扩展实现`java.lang.ref.Finalizer`，这个类在概述里提到的过，而此类的访问权限也是package的，并且是final的，意味着它不能再被扩展了，接下来的重点我们围绕`java.lang.ref.Finalizer`展开。(PS：后续讲的`Finalizer`其实也是在说`FinalReference`。)\n\n```\nfinal class Finalizer extends FinalReference { \n   /* Package-private; must be in same package as the \n   Referenceclass */\n   \n   /* A native method that invokes an arbitrary object's  \n   finalize method is  required since the finalize method is \n   protected*/\n    static native void invokeFinalizeMethod(Object o) throws Throwable;\n\n    private static ReferenceQueue queue = new ReferenceQueue();\n    private static Finalizer unfinalized = null;\n    private static final Object lock = new Object();\n\n    private Finalizer\n        next = null,\n        prev = null;\n\n    private Finalizer(Object finalizee) {\n        super(finalizee, queue);\n        add();\n    }\n\n    /* Invoked by VM */\n    static void register(Object finalizee) {\n        new Finalizer(finalizee);\n    }  \n\n    private void add() {\n        synchronized (lock) {\n            if (unfinalized != null) {\n                this.next = unfinalized;\n                unfinalized.prev = this;\n            }\n            unfinalized = this;\n        }\n    }\n\n    ...\n\n   }    \n```\n\n### Finalizer的构造函数\n\n`Finalizer`的构造函数提供了以下几个关键信息：\n\n- `private`：意味着我们无法在当前类之外构建这类的对象；\n- `finalizee`参数：`FinalReference`指向的对象引用；\n- 调用`add`方法：将当前对象插入到`Finalizer`对象链里，链里的对象和`Finalizer`类静态关联。言外之意是在这个链里的对象都无法被GC掉，除非将这种引用关系剥离（因为`Finalizer`类无法被unload）。\n\n虽然外面无法创建`Finalizer`对象，但是它有一个名为`register`的静态方法，该方法可以创建这种对象，同时将这个对象加入到`Finalizer`对象链里，这个方法是被vm调用的，那么问题来了，vm在什么情况下会调用这个方法呢？\n\n## Finalizer对象何时被注册到Finalizer对象链里\n\n类的修饰有很多，比如final，abstract，public等，如果某个类用final修饰，我们就说这个类是final类，上面列的都是语法层面我们可以显式指定的，在JVM里其实还会给类标记一些其他符号，比如`finalizer`，表示这个类是一个`finalizer`类（为了和`java.lang.ref.Fianlizer`类区分，下文在提到的`finalizer`类时会简称为f类），GC在处理这种类的对象时要做一些特殊的处理，如在这个对象被回收之前会调用它的`finalize`方法。\n\n#### 如何判断一个类是不是一个final类\n\n在讲这个问题之前，我们先来看下`java.lang.Object`里的一个方法\n\n```\n    protected void finalize() throws Throwable { }\n```\n\n在`Object`类里定义了一个名为`finalize`的空方法，这意味着Java里的所有类都会继承这个方法，甚至可以覆写该方法，并且根据方法覆写原则，如果子类覆盖此方法，方法访问权限至少protected级别的，这样其子类就算没有覆写此方法也会继承此方法。\n\n而判断当前类是否是f类的标准并不仅仅是当前类是否含有一个参数为空，返回值为void的`finalize`方法，还要求`finalize方法必须非空`，因此Object类虽然含有一个`finalize`方法，但它并不是f类，Object的对象在被GC回收时其实并不会调用它的`finalize`方法。\n\n需要注意的是，类在加载过程中其实就已经被标记为是否为f类了。（JVM在类加载的时候会遍历当前类的所有方法，包括父类的方法，只要有一个参数为空且返回void的非空`finalize`方法就认为这个类是f类。）\n\n### f类的对象何时传到Finalizer.register方法\n\n对象的创建其实是被拆分成多个步骤的，比如`A a=new A(2)`这样一条语句对应的字节码如下：\n\n```\n0: new           #1                  // class A\n3: dup\n4: iconst_2\n5: invokespecial #11                 // Method \"&lt;init&gt;\":(I)V\n```\n\n先执行new分配好对象空间，然后再执行invokespecial调用构造函数，JVM里其实可以让用户在这两个时机中选择一个，将当前对象传递给`Finalizer.register`方法来注册到`Finalizer`对象链里，这个选择取决于是否设置了`RegisterFinalizersAtInit`这个vm参数，默认值为true，也就是在构造函数返回之前调用`Finalizer.register`方法，如果通过`-XX:-RegisterFinalizersAtInit`关闭了该参数，那将在对象空间分配好之后将这个对象注册进去。\n\n另外需要提醒的是，当我们通过clone的方式复制一个对象时，如果当前类是一个f类，那么在clone完成时将调用`Finalizer.register`方法进行注册。\n\n### hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register\n\n这个实现比较有意思，在这简单提一下，我们知道执行一个构造函数时，会去调用父类的构造函数，主要是为了初始化继承自父类的属性，那么任何一个对象的初始化最终都会调用到`Object`的空构造函数里（任何空的构造函数其实并不空，会含有三条字节码指令，如下代码所示），为了不对所有类的构造函数都埋点调用`Finalizer.register`方法，hotspot的实现是，在初始化`Object`类时将构造函数里的`return`指令替换为`_return_register_finalizer`指令，该指令并不是标准的字节码指令，是hotspot扩展的指令，这样在处理该指令时调用`Finalizer.register`方法，以很小的侵入性代价完美地解决了这个问题。\n\n```\n0: aload_0\n1: invokespecial #21                 // Method java/lang/Object.\"&lt;init&gt;\":()V\n4: return\n```\n\n## f类对象的GC回收\n\n### FinalizerThread线程\n\n在`Finalizer`类的`clinit`方法（静态块）里，我们看到它会创建一个`FinalizerThread`守护线程，这个线程的优先级并不是最高的，意味着在CPU很紧张的情况下其被调度的优先级可能会受到影响\n\n```\n  private static class FinalizerThread extends Thread {\n        private volatile boolean running;\n        FinalizerThread(ThreadGroup g) {\n            super(g, \"Finalizer\");\n        }\n        public void run() {\n            if (running)\n                return;\n            running = true;\n            for (;;) {\n                try {\n                    Finalizer f = (Finalizer)queue.remove();\n                    f.runFinalizer();\n                } catch (InterruptedException x) {\n                    continue;\n                }\n            }\n        }\n    }\n\n    static {\n        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n        for (ThreadGroup tgn = tg;\n             tgn != null;\n             tg = tgn, tgn = tg.getParent());\n        Thread finalizer = new FinalizerThread(tg);\n        finalizer.setPriority(Thread.MAX_PRIORITY - 2);\n        finalizer.setDaemon(true);\n        finalizer.start();\n    }\n```\n\n这个线程用来从queue里获取`Finalizer`对象，然后执行该对象的`runFinalizer`方法，该方法会将`Finalizer`对象从`Finalizer`对象链里剥离出来，这样意味着下次GC发生时就可以将其关联的f对象回收了，最后将这个`Finalizer`对象关联的f对象传给一个native方法`invokeFinalizeMethod`\n\n```\nprivate void runFinalizer() {\n        synchronized (this) {\n            if (hasBeenFinalized()) return;\n            remove();\n        }\n        try {\n            Object finalizee = this.get();\n            if (finalizee != null && !(finalizee instanceof java.lang.Enum)) {\n                invokeFinalizeMethod(finalizee);\n                /* Clear stack slot containing this variable, to decrease\n                   the chances of false retention with a conservative GC */\n                finalizee = null;\n            }\n        } catch (Throwable x) { }\n        super.clear();\n    }\n\n static native void invokeFinalizeMethod(Object o) throws Throwable;\n```\n\n其实`invokeFinalizeMethod`方法就是调了这个f对象的finalize方法，看到这里大家应该恍然大悟了，整个过程都串起来了。\n\n```\nJNIEXPORT void JNICALL\nJava_java_lang_ref_Finalizer_invokeFinalizeMethod(JNIEnv *env, jclass clazz,\n                                                  jobject ob)\n{\n    jclass cls;\n    jmethodID mid;\n\n    cls = (*env)-&gt;GetObjectClass(env, ob);\n    if (cls == NULL) return;\n    mid = (*env)-&gt;GetMethodID(env, cls, \"finalize\", \"()V\");\n    if (mid == NULL) return;\n    (*env)-&gt;CallVoidMethod(env, ob, mid);\n}\n```\n\n### f对象的finalize方法抛出异常会导致FinalizeThread退出吗\n\n不知道大家有没有想过如果f对象的`finalize`方法抛了一个没捕获的异常，这个`FinalizerThread`会不会退出呢，细心的读者看上面的代码其实就可以找到答案，`runFinalizer`方法里对`Throwable`的异常进行了捕获，因此不可能出现`FinalizerThread`因异常未捕获而退出的情况。\n\n### f对象的finalize方法会执行多次吗\n\n如果我们在f对象的`finalize`方法里重新将当前对象赋值，变成可达对象，当这个f对象再次变成不可达时还会执行`finalize`方法吗？答案是否定的，因为在执行完第一次`finalize`方法后，这个f对象已经和之前的`Finalizer`对象剥离了，也就是下次GC的时候不会再发现`Finalizer`对象指向该f对象了，自然也就不会调用这个f对象的`finalize`方法了。\n\n### Finalizer对象何时被放到ReferenceQueue里\n\n除了这里接下来要介绍的环节之外，整个过程大家应该都比较清楚了。\n\n当GC发生时，GC算法会判断f类对象是不是只被`Finalizer`类引用（f类对象被`Finalizer`对象引用，然后放到`Finalizer`对象链里），如果这个类仅仅被`Finalizer`对象引用，说明这个对象在不久的将来会被回收，现在可以执行它的`finalize`方法了，于是会将这个`Finalizer`对象放到`Finalizer`类的`ReferenceQueue`里，但是这个f类对象其实并没有被回收，因为`Finalizer`这个类还对它们保持引用，在GC完成之前，JVM会调用`ReferenceQueue`中lock对象的notify方法（当`ReferenceQueue`为空时，`FinalizerThread`线程会调用`ReferenceQueue`的lock对象的wait方法直到被JVM唤醒），此时就会执行上面FinalizeThread线程里看到的其他逻辑了。\n\n## Finalizer导致的内存泄露\n\n这里举一个简单的例子，我们使用挺广的Socket通信，`SocksSocketImpl`的父类其实就实现了`finalize`方法:\n\n```\n/**\n * Cleans up if the user forgets to close it.\n */\nprotected void finalize() throws IOException {\n    close();\n}\n```\n\n其实这么做的主要目的是万一用户忘记关闭Socket，那么在这个对象被回收时能主动关闭Socket来释放一些系统资源，但是如果用户真的忘记关闭，那这些`socket`对象可能因为`FinalizeThread`迟迟没有执行这些`socket`对象的`finalize`方法，而导致内存泄露，这种问题我们碰到过多次，因此对于这类情况除了大家好好注意貌似没有什么更好的方法了，该做的事真不能省.\n\n## Finalizer的客观评价\n\n上面的过程基本对`Finalizer`的实现细节进行了完整剖析，Java里我们看到有构造函数，但是并没有看到析构函数一说，`Finalizer`其实是实现了析构函数的概念，我们在对象被回收前可以执行一些“收拾性”的逻辑，应该说是一个特殊场景的补充，但是这种概念的实现给f对象生命周期以及GC等带来了一些影响：\n\n- f对象因为`Finalizer`的引用而变成了一个临时的强引用，即使没有其他的强引用，还是无法立即被回收；\n- f对象至少经历两次GC才能被回收，因为只有在`FinalizerThread`执行完了f对象的`finalize`方法的情况下才有可能被下次GC回收，而有可能期间已经经历过多次GC了，但是一直还没执行f对象的`finalize`方法；\n- CPU资源比较稀缺的情况下`FinalizerThread`线程有可能因为优先级比较低而延迟执行f对象的`finalize`方法；\n- 因为f对象的`finalize`方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易引发old分代的GC，甚至Full GC，GC暂停时间明显变长；\n- f对象的`finalize`方法被调用后，这个对象其实还并没有被回收，虽然可能在不久的将来会被回收。\n\n## 参考\n1. [JVM 源码分析之 FinalReference 完全解读](https://www.infoq.cn/articles/jvm-source-code-analysis-finalreference)","slug":"JVM源码分析之-FinalReference完全解读","published":1,"updated":"2019-01-04T07:51:13.063Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovp0000i9q1u6ps2l31f","content":"<h1 id=\"JVM源码分析之-FinalReference完全解读\"><a href=\"#JVM源码分析之-FinalReference完全解读\" class=\"headerlink\" title=\"JVM源码分析之 FinalReference完全解读\"></a>JVM源码分析之 FinalReference完全解读</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Java对象引用体系除了强引用之外，出于对性能、可扩展性等方面考虑还特地实现了4种其他引用：<code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference</code>、<code>FinalReference</code>，本文主要想讲的是<code>FinalReference</code>，因为当使用内存分析工具，比如zprofiler、mat等，分析一些oom的heap时，经常能看到 <code>java.lang.ref.Finalizer</code>占用的内存大小远远排在前面，而这个类占用的内存大小又和我们这次的主角<code>FinalReference</code>有着密不可分的关系。</p>\n<p><code>FinalReference</code>及关联的内容可能给我们留下如下印象：</p>\n<ul>\n<li>自己代码里从没有使用过；</li>\n<li>线程dump之后，会看到一个叫做<code>Finalizer</code>的Java线程；</li>\n<li>偶尔能注意到<code>java.lang.ref.Finalizer</code>的存在；</li>\n<li>在类里可能会写<code>finalize</code>方法。</li>\n</ul>\n<p>那<code>FinalReference</code>到底存在的意义是什么，以怎样的形式和我们的代码相关联呢？这是本文要理清的问题。<br><a id=\"more\"></a></p>\n<h2 id=\"JDK中的FinalReference\"><a href=\"#JDK中的FinalReference\" class=\"headerlink\" title=\"JDK中的FinalReference\"></a>JDK中的FinalReference</h2><p>首先我们看看<code>FinalReference</code>在JDK里的实现：</p>\n<pre><code>class FinalReference&amp;lt;T&amp;gt; extends Reference&amp;lt;T&amp;gt; {\n\n    public FinalReference(T referent, ReferenceQueue&amp;lt;? super T&amp;gt; q) {\n        super(referent, q);\n    }\n\n}\n</code></pre><p>大家应该注意到了类访问权限是package的，这也就意味着我们不能直接去对其进行扩展，但是JDK里对此类进行了扩展实现<code>java.lang.ref.Finalizer</code>，这个类在概述里提到的过，而此类的访问权限也是package的，并且是final的，意味着它不能再被扩展了，接下来的重点我们围绕<code>java.lang.ref.Finalizer</code>展开。(PS：后续讲的<code>Finalizer</code>其实也是在说<code>FinalReference</code>。)</p>\n<pre><code>final class Finalizer extends FinalReference { \n   /* Package-private; must be in same package as the \n   Referenceclass */\n\n   /* A native method that invokes an arbitrary object&#39;s  \n   finalize method is  required since the finalize method is \n   protected*/\n    static native void invokeFinalizeMethod(Object o) throws Throwable;\n\n    private static ReferenceQueue queue = new ReferenceQueue();\n    private static Finalizer unfinalized = null;\n    private static final Object lock = new Object();\n\n    private Finalizer\n        next = null,\n        prev = null;\n\n    private Finalizer(Object finalizee) {\n        super(finalizee, queue);\n        add();\n    }\n\n    /* Invoked by VM */\n    static void register(Object finalizee) {\n        new Finalizer(finalizee);\n    }  \n\n    private void add() {\n        synchronized (lock) {\n            if (unfinalized != null) {\n                this.next = unfinalized;\n                unfinalized.prev = this;\n            }\n            unfinalized = this;\n        }\n    }\n\n    ...\n\n   }    \n</code></pre><h3 id=\"Finalizer的构造函数\"><a href=\"#Finalizer的构造函数\" class=\"headerlink\" title=\"Finalizer的构造函数\"></a>Finalizer的构造函数</h3><p><code>Finalizer</code>的构造函数提供了以下几个关键信息：</p>\n<ul>\n<li><code>private</code>：意味着我们无法在当前类之外构建这类的对象；</li>\n<li><code>finalizee</code>参数：<code>FinalReference</code>指向的对象引用；</li>\n<li>调用<code>add</code>方法：将当前对象插入到<code>Finalizer</code>对象链里，链里的对象和<code>Finalizer</code>类静态关联。言外之意是在这个链里的对象都无法被GC掉，除非将这种引用关系剥离（因为<code>Finalizer</code>类无法被unload）。</li>\n</ul>\n<p>虽然外面无法创建<code>Finalizer</code>对象，但是它有一个名为<code>register</code>的静态方法，该方法可以创建这种对象，同时将这个对象加入到<code>Finalizer</code>对象链里，这个方法是被vm调用的，那么问题来了，vm在什么情况下会调用这个方法呢？</p>\n<h2 id=\"Finalizer对象何时被注册到Finalizer对象链里\"><a href=\"#Finalizer对象何时被注册到Finalizer对象链里\" class=\"headerlink\" title=\"Finalizer对象何时被注册到Finalizer对象链里\"></a>Finalizer对象何时被注册到Finalizer对象链里</h2><p>类的修饰有很多，比如final，abstract，public等，如果某个类用final修饰，我们就说这个类是final类，上面列的都是语法层面我们可以显式指定的，在JVM里其实还会给类标记一些其他符号，比如<code>finalizer</code>，表示这个类是一个<code>finalizer</code>类（为了和<code>java.lang.ref.Fianlizer</code>类区分，下文在提到的<code>finalizer</code>类时会简称为f类），GC在处理这种类的对象时要做一些特殊的处理，如在这个对象被回收之前会调用它的<code>finalize</code>方法。</p>\n<h4 id=\"如何判断一个类是不是一个final类\"><a href=\"#如何判断一个类是不是一个final类\" class=\"headerlink\" title=\"如何判断一个类是不是一个final类\"></a>如何判断一个类是不是一个final类</h4><p>在讲这个问题之前，我们先来看下<code>java.lang.Object</code>里的一个方法</p>\n<pre><code>    protected void finalize() throws Throwable { }\n</code></pre><p>在<code>Object</code>类里定义了一个名为<code>finalize</code>的空方法，这意味着Java里的所有类都会继承这个方法，甚至可以覆写该方法，并且根据方法覆写原则，如果子类覆盖此方法，方法访问权限至少protected级别的，这样其子类就算没有覆写此方法也会继承此方法。</p>\n<p>而判断当前类是否是f类的标准并不仅仅是当前类是否含有一个参数为空，返回值为void的<code>finalize</code>方法，还要求<code>finalize方法必须非空</code>，因此Object类虽然含有一个<code>finalize</code>方法，但它并不是f类，Object的对象在被GC回收时其实并不会调用它的<code>finalize</code>方法。</p>\n<p>需要注意的是，类在加载过程中其实就已经被标记为是否为f类了。（JVM在类加载的时候会遍历当前类的所有方法，包括父类的方法，只要有一个参数为空且返回void的非空<code>finalize</code>方法就认为这个类是f类。）</p>\n<h3 id=\"f类的对象何时传到Finalizer-register方法\"><a href=\"#f类的对象何时传到Finalizer-register方法\" class=\"headerlink\" title=\"f类的对象何时传到Finalizer.register方法\"></a>f类的对象何时传到Finalizer.register方法</h3><p>对象的创建其实是被拆分成多个步骤的，比如<code>A a=new A(2)</code>这样一条语句对应的字节码如下：</p>\n<pre><code>0: new           #1                  // class A\n3: dup\n4: iconst_2\n5: invokespecial #11                 // Method &quot;&amp;lt;init&amp;gt;&quot;:(I)V\n</code></pre><p>先执行new分配好对象空间，然后再执行invokespecial调用构造函数，JVM里其实可以让用户在这两个时机中选择一个，将当前对象传递给<code>Finalizer.register</code>方法来注册到<code>Finalizer</code>对象链里，这个选择取决于是否设置了<code>RegisterFinalizersAtInit</code>这个vm参数，默认值为true，也就是在构造函数返回之前调用<code>Finalizer.register</code>方法，如果通过<code>-XX:-RegisterFinalizersAtInit</code>关闭了该参数，那将在对象空间分配好之后将这个对象注册进去。</p>\n<p>另外需要提醒的是，当我们通过clone的方式复制一个对象时，如果当前类是一个f类，那么在clone完成时将调用<code>Finalizer.register</code>方法进行注册。</p>\n<h3 id=\"hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer-register\"><a href=\"#hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer-register\" class=\"headerlink\" title=\"hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register\"></a>hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register</h3><p>这个实现比较有意思，在这简单提一下，我们知道执行一个构造函数时，会去调用父类的构造函数，主要是为了初始化继承自父类的属性，那么任何一个对象的初始化最终都会调用到<code>Object</code>的空构造函数里（任何空的构造函数其实并不空，会含有三条字节码指令，如下代码所示），为了不对所有类的构造函数都埋点调用<code>Finalizer.register</code>方法，hotspot的实现是，在初始化<code>Object</code>类时将构造函数里的<code>return</code>指令替换为<code>_return_register_finalizer</code>指令，该指令并不是标准的字节码指令，是hotspot扩展的指令，这样在处理该指令时调用<code>Finalizer.register</code>方法，以很小的侵入性代价完美地解决了这个问题。</p>\n<pre><code>0: aload_0\n1: invokespecial #21                 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V\n4: return\n</code></pre><h2 id=\"f类对象的GC回收\"><a href=\"#f类对象的GC回收\" class=\"headerlink\" title=\"f类对象的GC回收\"></a>f类对象的GC回收</h2><h3 id=\"FinalizerThread线程\"><a href=\"#FinalizerThread线程\" class=\"headerlink\" title=\"FinalizerThread线程\"></a>FinalizerThread线程</h3><p>在<code>Finalizer</code>类的<code>clinit</code>方法（静态块）里，我们看到它会创建一个<code>FinalizerThread</code>守护线程，这个线程的优先级并不是最高的，意味着在CPU很紧张的情况下其被调度的优先级可能会受到影响</p>\n<pre><code>  private static class FinalizerThread extends Thread {\n        private volatile boolean running;\n        FinalizerThread(ThreadGroup g) {\n            super(g, &quot;Finalizer&quot;);\n        }\n        public void run() {\n            if (running)\n                return;\n            running = true;\n            for (;;) {\n                try {\n                    Finalizer f = (Finalizer)queue.remove();\n                    f.runFinalizer();\n                } catch (InterruptedException x) {\n                    continue;\n                }\n            }\n        }\n    }\n\n    static {\n        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n        for (ThreadGroup tgn = tg;\n             tgn != null;\n             tg = tgn, tgn = tg.getParent());\n        Thread finalizer = new FinalizerThread(tg);\n        finalizer.setPriority(Thread.MAX_PRIORITY - 2);\n        finalizer.setDaemon(true);\n        finalizer.start();\n    }\n</code></pre><p>这个线程用来从queue里获取<code>Finalizer</code>对象，然后执行该对象的<code>runFinalizer</code>方法，该方法会将<code>Finalizer</code>对象从<code>Finalizer</code>对象链里剥离出来，这样意味着下次GC发生时就可以将其关联的f对象回收了，最后将这个<code>Finalizer</code>对象关联的f对象传给一个native方法<code>invokeFinalizeMethod</code></p>\n<pre><code>private void runFinalizer() {\n        synchronized (this) {\n            if (hasBeenFinalized()) return;\n            remove();\n        }\n        try {\n            Object finalizee = this.get();\n            if (finalizee != null &amp;&amp; !(finalizee instanceof java.lang.Enum)) {\n                invokeFinalizeMethod(finalizee);\n                /* Clear stack slot containing this variable, to decrease\n                   the chances of false retention with a conservative GC */\n                finalizee = null;\n            }\n        } catch (Throwable x) { }\n        super.clear();\n    }\n\n static native void invokeFinalizeMethod(Object o) throws Throwable;\n</code></pre><p>其实<code>invokeFinalizeMethod</code>方法就是调了这个f对象的finalize方法，看到这里大家应该恍然大悟了，整个过程都串起来了。</p>\n<pre><code>JNIEXPORT void JNICALL\nJava_java_lang_ref_Finalizer_invokeFinalizeMethod(JNIEnv *env, jclass clazz,\n                                                  jobject ob)\n{\n    jclass cls;\n    jmethodID mid;\n\n    cls = (*env)-&amp;gt;GetObjectClass(env, ob);\n    if (cls == NULL) return;\n    mid = (*env)-&amp;gt;GetMethodID(env, cls, &quot;finalize&quot;, &quot;()V&quot;);\n    if (mid == NULL) return;\n    (*env)-&amp;gt;CallVoidMethod(env, ob, mid);\n}\n</code></pre><h3 id=\"f对象的finalize方法抛出异常会导致FinalizeThread退出吗\"><a href=\"#f对象的finalize方法抛出异常会导致FinalizeThread退出吗\" class=\"headerlink\" title=\"f对象的finalize方法抛出异常会导致FinalizeThread退出吗\"></a>f对象的finalize方法抛出异常会导致FinalizeThread退出吗</h3><p>不知道大家有没有想过如果f对象的<code>finalize</code>方法抛了一个没捕获的异常，这个<code>FinalizerThread</code>会不会退出呢，细心的读者看上面的代码其实就可以找到答案，<code>runFinalizer</code>方法里对<code>Throwable</code>的异常进行了捕获，因此不可能出现<code>FinalizerThread</code>因异常未捕获而退出的情况。</p>\n<h3 id=\"f对象的finalize方法会执行多次吗\"><a href=\"#f对象的finalize方法会执行多次吗\" class=\"headerlink\" title=\"f对象的finalize方法会执行多次吗\"></a>f对象的finalize方法会执行多次吗</h3><p>如果我们在f对象的<code>finalize</code>方法里重新将当前对象赋值，变成可达对象，当这个f对象再次变成不可达时还会执行<code>finalize</code>方法吗？答案是否定的，因为在执行完第一次<code>finalize</code>方法后，这个f对象已经和之前的<code>Finalizer</code>对象剥离了，也就是下次GC的时候不会再发现<code>Finalizer</code>对象指向该f对象了，自然也就不会调用这个f对象的<code>finalize</code>方法了。</p>\n<h3 id=\"Finalizer对象何时被放到ReferenceQueue里\"><a href=\"#Finalizer对象何时被放到ReferenceQueue里\" class=\"headerlink\" title=\"Finalizer对象何时被放到ReferenceQueue里\"></a>Finalizer对象何时被放到ReferenceQueue里</h3><p>除了这里接下来要介绍的环节之外，整个过程大家应该都比较清楚了。</p>\n<p>当GC发生时，GC算法会判断f类对象是不是只被<code>Finalizer</code>类引用（f类对象被<code>Finalizer</code>对象引用，然后放到<code>Finalizer</code>对象链里），如果这个类仅仅被<code>Finalizer</code>对象引用，说明这个对象在不久的将来会被回收，现在可以执行它的<code>finalize</code>方法了，于是会将这个<code>Finalizer</code>对象放到<code>Finalizer</code>类的<code>ReferenceQueue</code>里，但是这个f类对象其实并没有被回收，因为<code>Finalizer</code>这个类还对它们保持引用，在GC完成之前，JVM会调用<code>ReferenceQueue</code>中lock对象的notify方法（当<code>ReferenceQueue</code>为空时，<code>FinalizerThread</code>线程会调用<code>ReferenceQueue</code>的lock对象的wait方法直到被JVM唤醒），此时就会执行上面FinalizeThread线程里看到的其他逻辑了。</p>\n<h2 id=\"Finalizer导致的内存泄露\"><a href=\"#Finalizer导致的内存泄露\" class=\"headerlink\" title=\"Finalizer导致的内存泄露\"></a>Finalizer导致的内存泄露</h2><p>这里举一个简单的例子，我们使用挺广的Socket通信，<code>SocksSocketImpl</code>的父类其实就实现了<code>finalize</code>方法:</p>\n<pre><code>/**\n * Cleans up if the user forgets to close it.\n */\nprotected void finalize() throws IOException {\n    close();\n}\n</code></pre><p>其实这么做的主要目的是万一用户忘记关闭Socket，那么在这个对象被回收时能主动关闭Socket来释放一些系统资源，但是如果用户真的忘记关闭，那这些<code>socket</code>对象可能因为<code>FinalizeThread</code>迟迟没有执行这些<code>socket</code>对象的<code>finalize</code>方法，而导致内存泄露，这种问题我们碰到过多次，因此对于这类情况除了大家好好注意貌似没有什么更好的方法了，该做的事真不能省.</p>\n<h2 id=\"Finalizer的客观评价\"><a href=\"#Finalizer的客观评价\" class=\"headerlink\" title=\"Finalizer的客观评价\"></a>Finalizer的客观评价</h2><p>上面的过程基本对<code>Finalizer</code>的实现细节进行了完整剖析，Java里我们看到有构造函数，但是并没有看到析构函数一说，<code>Finalizer</code>其实是实现了析构函数的概念，我们在对象被回收前可以执行一些“收拾性”的逻辑，应该说是一个特殊场景的补充，但是这种概念的实现给f对象生命周期以及GC等带来了一些影响：</p>\n<ul>\n<li>f对象因为<code>Finalizer</code>的引用而变成了一个临时的强引用，即使没有其他的强引用，还是无法立即被回收；</li>\n<li>f对象至少经历两次GC才能被回收，因为只有在<code>FinalizerThread</code>执行完了f对象的<code>finalize</code>方法的情况下才有可能被下次GC回收，而有可能期间已经经历过多次GC了，但是一直还没执行f对象的<code>finalize</code>方法；</li>\n<li>CPU资源比较稀缺的情况下<code>FinalizerThread</code>线程有可能因为优先级比较低而延迟执行f对象的<code>finalize</code>方法；</li>\n<li>因为f对象的<code>finalize</code>方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易引发old分代的GC，甚至Full GC，GC暂停时间明显变长；</li>\n<li>f对象的<code>finalize</code>方法被调用后，这个对象其实还并没有被回收，虽然可能在不久的将来会被回收。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.infoq.cn/articles/jvm-source-code-analysis-finalreference\" target=\"_blank\" rel=\"noopener\">JVM 源码分析之 FinalReference 完全解读</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"JVM源码分析之-FinalReference完全解读\"><a href=\"#JVM源码分析之-FinalReference完全解读\" class=\"headerlink\" title=\"JVM源码分析之 FinalReference完全解读\"></a>JVM源码分析之 FinalReference完全解读</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Java对象引用体系除了强引用之外，出于对性能、可扩展性等方面考虑还特地实现了4种其他引用：<code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference</code>、<code>FinalReference</code>，本文主要想讲的是<code>FinalReference</code>，因为当使用内存分析工具，比如zprofiler、mat等，分析一些oom的heap时，经常能看到 <code>java.lang.ref.Finalizer</code>占用的内存大小远远排在前面，而这个类占用的内存大小又和我们这次的主角<code>FinalReference</code>有着密不可分的关系。</p>\n<p><code>FinalReference</code>及关联的内容可能给我们留下如下印象：</p>\n<ul>\n<li>自己代码里从没有使用过；</li>\n<li>线程dump之后，会看到一个叫做<code>Finalizer</code>的Java线程；</li>\n<li>偶尔能注意到<code>java.lang.ref.Finalizer</code>的存在；</li>\n<li>在类里可能会写<code>finalize</code>方法。</li>\n</ul>\n<p>那<code>FinalReference</code>到底存在的意义是什么，以怎样的形式和我们的代码相关联呢？这是本文要理清的问题。<br>","more":"</p>\n<h2 id=\"JDK中的FinalReference\"><a href=\"#JDK中的FinalReference\" class=\"headerlink\" title=\"JDK中的FinalReference\"></a>JDK中的FinalReference</h2><p>首先我们看看<code>FinalReference</code>在JDK里的实现：</p>\n<pre><code>class FinalReference&amp;lt;T&amp;gt; extends Reference&amp;lt;T&amp;gt; {\n\n    public FinalReference(T referent, ReferenceQueue&amp;lt;? super T&amp;gt; q) {\n        super(referent, q);\n    }\n\n}\n</code></pre><p>大家应该注意到了类访问权限是package的，这也就意味着我们不能直接去对其进行扩展，但是JDK里对此类进行了扩展实现<code>java.lang.ref.Finalizer</code>，这个类在概述里提到的过，而此类的访问权限也是package的，并且是final的，意味着它不能再被扩展了，接下来的重点我们围绕<code>java.lang.ref.Finalizer</code>展开。(PS：后续讲的<code>Finalizer</code>其实也是在说<code>FinalReference</code>。)</p>\n<pre><code>final class Finalizer extends FinalReference { \n   /* Package-private; must be in same package as the \n   Referenceclass */\n\n   /* A native method that invokes an arbitrary object&#39;s  \n   finalize method is  required since the finalize method is \n   protected*/\n    static native void invokeFinalizeMethod(Object o) throws Throwable;\n\n    private static ReferenceQueue queue = new ReferenceQueue();\n    private static Finalizer unfinalized = null;\n    private static final Object lock = new Object();\n\n    private Finalizer\n        next = null,\n        prev = null;\n\n    private Finalizer(Object finalizee) {\n        super(finalizee, queue);\n        add();\n    }\n\n    /* Invoked by VM */\n    static void register(Object finalizee) {\n        new Finalizer(finalizee);\n    }  \n\n    private void add() {\n        synchronized (lock) {\n            if (unfinalized != null) {\n                this.next = unfinalized;\n                unfinalized.prev = this;\n            }\n            unfinalized = this;\n        }\n    }\n\n    ...\n\n   }    \n</code></pre><h3 id=\"Finalizer的构造函数\"><a href=\"#Finalizer的构造函数\" class=\"headerlink\" title=\"Finalizer的构造函数\"></a>Finalizer的构造函数</h3><p><code>Finalizer</code>的构造函数提供了以下几个关键信息：</p>\n<ul>\n<li><code>private</code>：意味着我们无法在当前类之外构建这类的对象；</li>\n<li><code>finalizee</code>参数：<code>FinalReference</code>指向的对象引用；</li>\n<li>调用<code>add</code>方法：将当前对象插入到<code>Finalizer</code>对象链里，链里的对象和<code>Finalizer</code>类静态关联。言外之意是在这个链里的对象都无法被GC掉，除非将这种引用关系剥离（因为<code>Finalizer</code>类无法被unload）。</li>\n</ul>\n<p>虽然外面无法创建<code>Finalizer</code>对象，但是它有一个名为<code>register</code>的静态方法，该方法可以创建这种对象，同时将这个对象加入到<code>Finalizer</code>对象链里，这个方法是被vm调用的，那么问题来了，vm在什么情况下会调用这个方法呢？</p>\n<h2 id=\"Finalizer对象何时被注册到Finalizer对象链里\"><a href=\"#Finalizer对象何时被注册到Finalizer对象链里\" class=\"headerlink\" title=\"Finalizer对象何时被注册到Finalizer对象链里\"></a>Finalizer对象何时被注册到Finalizer对象链里</h2><p>类的修饰有很多，比如final，abstract，public等，如果某个类用final修饰，我们就说这个类是final类，上面列的都是语法层面我们可以显式指定的，在JVM里其实还会给类标记一些其他符号，比如<code>finalizer</code>，表示这个类是一个<code>finalizer</code>类（为了和<code>java.lang.ref.Fianlizer</code>类区分，下文在提到的<code>finalizer</code>类时会简称为f类），GC在处理这种类的对象时要做一些特殊的处理，如在这个对象被回收之前会调用它的<code>finalize</code>方法。</p>\n<h4 id=\"如何判断一个类是不是一个final类\"><a href=\"#如何判断一个类是不是一个final类\" class=\"headerlink\" title=\"如何判断一个类是不是一个final类\"></a>如何判断一个类是不是一个final类</h4><p>在讲这个问题之前，我们先来看下<code>java.lang.Object</code>里的一个方法</p>\n<pre><code>    protected void finalize() throws Throwable { }\n</code></pre><p>在<code>Object</code>类里定义了一个名为<code>finalize</code>的空方法，这意味着Java里的所有类都会继承这个方法，甚至可以覆写该方法，并且根据方法覆写原则，如果子类覆盖此方法，方法访问权限至少protected级别的，这样其子类就算没有覆写此方法也会继承此方法。</p>\n<p>而判断当前类是否是f类的标准并不仅仅是当前类是否含有一个参数为空，返回值为void的<code>finalize</code>方法，还要求<code>finalize方法必须非空</code>，因此Object类虽然含有一个<code>finalize</code>方法，但它并不是f类，Object的对象在被GC回收时其实并不会调用它的<code>finalize</code>方法。</p>\n<p>需要注意的是，类在加载过程中其实就已经被标记为是否为f类了。（JVM在类加载的时候会遍历当前类的所有方法，包括父类的方法，只要有一个参数为空且返回void的非空<code>finalize</code>方法就认为这个类是f类。）</p>\n<h3 id=\"f类的对象何时传到Finalizer-register方法\"><a href=\"#f类的对象何时传到Finalizer-register方法\" class=\"headerlink\" title=\"f类的对象何时传到Finalizer.register方法\"></a>f类的对象何时传到Finalizer.register方法</h3><p>对象的创建其实是被拆分成多个步骤的，比如<code>A a=new A(2)</code>这样一条语句对应的字节码如下：</p>\n<pre><code>0: new           #1                  // class A\n3: dup\n4: iconst_2\n5: invokespecial #11                 // Method &quot;&amp;lt;init&amp;gt;&quot;:(I)V\n</code></pre><p>先执行new分配好对象空间，然后再执行invokespecial调用构造函数，JVM里其实可以让用户在这两个时机中选择一个，将当前对象传递给<code>Finalizer.register</code>方法来注册到<code>Finalizer</code>对象链里，这个选择取决于是否设置了<code>RegisterFinalizersAtInit</code>这个vm参数，默认值为true，也就是在构造函数返回之前调用<code>Finalizer.register</code>方法，如果通过<code>-XX:-RegisterFinalizersAtInit</code>关闭了该参数，那将在对象空间分配好之后将这个对象注册进去。</p>\n<p>另外需要提醒的是，当我们通过clone的方式复制一个对象时，如果当前类是一个f类，那么在clone完成时将调用<code>Finalizer.register</code>方法进行注册。</p>\n<h3 id=\"hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer-register\"><a href=\"#hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer-register\" class=\"headerlink\" title=\"hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register\"></a>hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register</h3><p>这个实现比较有意思，在这简单提一下，我们知道执行一个构造函数时，会去调用父类的构造函数，主要是为了初始化继承自父类的属性，那么任何一个对象的初始化最终都会调用到<code>Object</code>的空构造函数里（任何空的构造函数其实并不空，会含有三条字节码指令，如下代码所示），为了不对所有类的构造函数都埋点调用<code>Finalizer.register</code>方法，hotspot的实现是，在初始化<code>Object</code>类时将构造函数里的<code>return</code>指令替换为<code>_return_register_finalizer</code>指令，该指令并不是标准的字节码指令，是hotspot扩展的指令，这样在处理该指令时调用<code>Finalizer.register</code>方法，以很小的侵入性代价完美地解决了这个问题。</p>\n<pre><code>0: aload_0\n1: invokespecial #21                 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V\n4: return\n</code></pre><h2 id=\"f类对象的GC回收\"><a href=\"#f类对象的GC回收\" class=\"headerlink\" title=\"f类对象的GC回收\"></a>f类对象的GC回收</h2><h3 id=\"FinalizerThread线程\"><a href=\"#FinalizerThread线程\" class=\"headerlink\" title=\"FinalizerThread线程\"></a>FinalizerThread线程</h3><p>在<code>Finalizer</code>类的<code>clinit</code>方法（静态块）里，我们看到它会创建一个<code>FinalizerThread</code>守护线程，这个线程的优先级并不是最高的，意味着在CPU很紧张的情况下其被调度的优先级可能会受到影响</p>\n<pre><code>  private static class FinalizerThread extends Thread {\n        private volatile boolean running;\n        FinalizerThread(ThreadGroup g) {\n            super(g, &quot;Finalizer&quot;);\n        }\n        public void run() {\n            if (running)\n                return;\n            running = true;\n            for (;;) {\n                try {\n                    Finalizer f = (Finalizer)queue.remove();\n                    f.runFinalizer();\n                } catch (InterruptedException x) {\n                    continue;\n                }\n            }\n        }\n    }\n\n    static {\n        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n        for (ThreadGroup tgn = tg;\n             tgn != null;\n             tg = tgn, tgn = tg.getParent());\n        Thread finalizer = new FinalizerThread(tg);\n        finalizer.setPriority(Thread.MAX_PRIORITY - 2);\n        finalizer.setDaemon(true);\n        finalizer.start();\n    }\n</code></pre><p>这个线程用来从queue里获取<code>Finalizer</code>对象，然后执行该对象的<code>runFinalizer</code>方法，该方法会将<code>Finalizer</code>对象从<code>Finalizer</code>对象链里剥离出来，这样意味着下次GC发生时就可以将其关联的f对象回收了，最后将这个<code>Finalizer</code>对象关联的f对象传给一个native方法<code>invokeFinalizeMethod</code></p>\n<pre><code>private void runFinalizer() {\n        synchronized (this) {\n            if (hasBeenFinalized()) return;\n            remove();\n        }\n        try {\n            Object finalizee = this.get();\n            if (finalizee != null &amp;&amp; !(finalizee instanceof java.lang.Enum)) {\n                invokeFinalizeMethod(finalizee);\n                /* Clear stack slot containing this variable, to decrease\n                   the chances of false retention with a conservative GC */\n                finalizee = null;\n            }\n        } catch (Throwable x) { }\n        super.clear();\n    }\n\n static native void invokeFinalizeMethod(Object o) throws Throwable;\n</code></pre><p>其实<code>invokeFinalizeMethod</code>方法就是调了这个f对象的finalize方法，看到这里大家应该恍然大悟了，整个过程都串起来了。</p>\n<pre><code>JNIEXPORT void JNICALL\nJava_java_lang_ref_Finalizer_invokeFinalizeMethod(JNIEnv *env, jclass clazz,\n                                                  jobject ob)\n{\n    jclass cls;\n    jmethodID mid;\n\n    cls = (*env)-&amp;gt;GetObjectClass(env, ob);\n    if (cls == NULL) return;\n    mid = (*env)-&amp;gt;GetMethodID(env, cls, &quot;finalize&quot;, &quot;()V&quot;);\n    if (mid == NULL) return;\n    (*env)-&amp;gt;CallVoidMethod(env, ob, mid);\n}\n</code></pre><h3 id=\"f对象的finalize方法抛出异常会导致FinalizeThread退出吗\"><a href=\"#f对象的finalize方法抛出异常会导致FinalizeThread退出吗\" class=\"headerlink\" title=\"f对象的finalize方法抛出异常会导致FinalizeThread退出吗\"></a>f对象的finalize方法抛出异常会导致FinalizeThread退出吗</h3><p>不知道大家有没有想过如果f对象的<code>finalize</code>方法抛了一个没捕获的异常，这个<code>FinalizerThread</code>会不会退出呢，细心的读者看上面的代码其实就可以找到答案，<code>runFinalizer</code>方法里对<code>Throwable</code>的异常进行了捕获，因此不可能出现<code>FinalizerThread</code>因异常未捕获而退出的情况。</p>\n<h3 id=\"f对象的finalize方法会执行多次吗\"><a href=\"#f对象的finalize方法会执行多次吗\" class=\"headerlink\" title=\"f对象的finalize方法会执行多次吗\"></a>f对象的finalize方法会执行多次吗</h3><p>如果我们在f对象的<code>finalize</code>方法里重新将当前对象赋值，变成可达对象，当这个f对象再次变成不可达时还会执行<code>finalize</code>方法吗？答案是否定的，因为在执行完第一次<code>finalize</code>方法后，这个f对象已经和之前的<code>Finalizer</code>对象剥离了，也就是下次GC的时候不会再发现<code>Finalizer</code>对象指向该f对象了，自然也就不会调用这个f对象的<code>finalize</code>方法了。</p>\n<h3 id=\"Finalizer对象何时被放到ReferenceQueue里\"><a href=\"#Finalizer对象何时被放到ReferenceQueue里\" class=\"headerlink\" title=\"Finalizer对象何时被放到ReferenceQueue里\"></a>Finalizer对象何时被放到ReferenceQueue里</h3><p>除了这里接下来要介绍的环节之外，整个过程大家应该都比较清楚了。</p>\n<p>当GC发生时，GC算法会判断f类对象是不是只被<code>Finalizer</code>类引用（f类对象被<code>Finalizer</code>对象引用，然后放到<code>Finalizer</code>对象链里），如果这个类仅仅被<code>Finalizer</code>对象引用，说明这个对象在不久的将来会被回收，现在可以执行它的<code>finalize</code>方法了，于是会将这个<code>Finalizer</code>对象放到<code>Finalizer</code>类的<code>ReferenceQueue</code>里，但是这个f类对象其实并没有被回收，因为<code>Finalizer</code>这个类还对它们保持引用，在GC完成之前，JVM会调用<code>ReferenceQueue</code>中lock对象的notify方法（当<code>ReferenceQueue</code>为空时，<code>FinalizerThread</code>线程会调用<code>ReferenceQueue</code>的lock对象的wait方法直到被JVM唤醒），此时就会执行上面FinalizeThread线程里看到的其他逻辑了。</p>\n<h2 id=\"Finalizer导致的内存泄露\"><a href=\"#Finalizer导致的内存泄露\" class=\"headerlink\" title=\"Finalizer导致的内存泄露\"></a>Finalizer导致的内存泄露</h2><p>这里举一个简单的例子，我们使用挺广的Socket通信，<code>SocksSocketImpl</code>的父类其实就实现了<code>finalize</code>方法:</p>\n<pre><code>/**\n * Cleans up if the user forgets to close it.\n */\nprotected void finalize() throws IOException {\n    close();\n}\n</code></pre><p>其实这么做的主要目的是万一用户忘记关闭Socket，那么在这个对象被回收时能主动关闭Socket来释放一些系统资源，但是如果用户真的忘记关闭，那这些<code>socket</code>对象可能因为<code>FinalizeThread</code>迟迟没有执行这些<code>socket</code>对象的<code>finalize</code>方法，而导致内存泄露，这种问题我们碰到过多次，因此对于这类情况除了大家好好注意貌似没有什么更好的方法了，该做的事真不能省.</p>\n<h2 id=\"Finalizer的客观评价\"><a href=\"#Finalizer的客观评价\" class=\"headerlink\" title=\"Finalizer的客观评价\"></a>Finalizer的客观评价</h2><p>上面的过程基本对<code>Finalizer</code>的实现细节进行了完整剖析，Java里我们看到有构造函数，但是并没有看到析构函数一说，<code>Finalizer</code>其实是实现了析构函数的概念，我们在对象被回收前可以执行一些“收拾性”的逻辑，应该说是一个特殊场景的补充，但是这种概念的实现给f对象生命周期以及GC等带来了一些影响：</p>\n<ul>\n<li>f对象因为<code>Finalizer</code>的引用而变成了一个临时的强引用，即使没有其他的强引用，还是无法立即被回收；</li>\n<li>f对象至少经历两次GC才能被回收，因为只有在<code>FinalizerThread</code>执行完了f对象的<code>finalize</code>方法的情况下才有可能被下次GC回收，而有可能期间已经经历过多次GC了，但是一直还没执行f对象的<code>finalize</code>方法；</li>\n<li>CPU资源比较稀缺的情况下<code>FinalizerThread</code>线程有可能因为优先级比较低而延迟执行f对象的<code>finalize</code>方法；</li>\n<li>因为f对象的<code>finalize</code>方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易引发old分代的GC，甚至Full GC，GC暂停时间明显变长；</li>\n<li>f对象的<code>finalize</code>方法被调用后，这个对象其实还并没有被回收，虽然可能在不久的将来会被回收。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.infoq.cn/articles/jvm-source-code-analysis-finalreference\" target=\"_blank\" rel=\"noopener\">JVM 源码分析之 FinalReference 完全解读</a></li>\n</ol>"},{"title":"Java Reference详解","author":"枫秀天涯","abbrlink":28002,"date":"2019-01-04T02:25:00.000Z","_content":"# Java Reference详解\n\n### 概述\n\nJava引用体系中我们最熟悉的就是强引用类型，如 A a= new A();这是我们经常说的强引用StrongReference，jvm gc时会检测对象是否存在强引用，如果存在由根对象对其有传递的强引用，则不会对其进行回收，即使内存不足抛出OutOfMemoryError。\n\n除了强引用外，Java还引入了SoftReference，WeakReference，PhantomReference，FinalReference ，这些类放在java.lang.ref包下，类的继承体系如下图。Java额外引入这个四种类型引用主要目的是在jvm 在gc时，按照引用类型的不同，在回收时采用不同的逻辑。可以把这些引用看作是对对象的一层包裹，jvm根据外层不同的包裹，对其包裹的对象采用不同的回收策略，或特殊逻辑处理。 这几种类型的引用主要在jvm内存缓存、资源释放、对象可达性事件处理等场景会用到。\n\n![输入图片说明](https://static.oschina.net/uploads/img/201701/21153037_ubGO.png)\n\n本篇文章主要讲解前面三种SoftReference，WeakReference和PhantomReference的使用，以及ReferenceQueue的使用。至于FinalRefeence会在另一篇文章中讲解。\n<!-- more -->\n主要内容如下\n\n1. 对象可达性判断\n2. ReferenceQueue 简介\n3. SoftReference简介及使用\n4. WeakReference简介及使用\n5. PhantomReference简介及使用\n6. 总结\n\n**本文名称使用说明**名称说明下：Reference指代引用对象本身，Referent指代被引用对象，下文介绍会以Reference，Referent形式出现。 \n\n### 1. 对象可达性判断\n\njvm gc时，判断一个对象是否存在引用时，都是从根结合引用(Root Set of References)开始去标识,往往到达一个对象的引用路径会存在多条，如下图。 ![输入图片说明](https://static.oschina.net/uploads/img/201701/21165610_kkb9.png)\n\n那么 垃圾回收时会依据两个原则来判断对象的可达性：\n\n- 单一路径中，以最弱的引用为准\n- 多路径中，以最强的引用为准\n\n例如Obj4的引用，存在3个路径:1->6、2->5、3->4, 那么从根对象到Obj4最强的引用是2->5，因为它们都是强引用。如果仅仅存在一个路径对Obj4有引用时，比如现在只剩1->6,那么根对象到Obj4的引用就是以最弱的为准，就是SoftReference引用,Obj4就是softly-reachable对象。如果是WeakReference引用，就称作weakly-reachable对象。只要一个对象是强引用可达，那么这个对象就不会被gc，即使发生OOM也不会回收这个对象。\n\n### 2. ReferenceQueue 简介\n\n引用队列，在检测到适当的可到达性更改后，即Referent对象的可达性发生适当的改变时，垃圾回收器将已注册的引用对象reference添加到该队列中。\n\n简单用下面代码来说明\n\n```java\nObject object = new Object();\nReferenceQueue  queue = new ReferenceQueue();\nSoftReference<Objecct> soft = new SoftReference<>(object,queue);\nobject = null;\nSysten.gc();\n//休眠一会，等待gc完成\nThread.sleep(100);\nSystem.out.println(queue.poll() == soft);\nSystem.out.println(soft.get() == null)\n```\n\n输出结果：\n\n```java\ntrue\ntrue\n```\n\n结果分析：\n\n对应上面第一句话，就是说当soft引用对象包含的object对象被gc之后，其可达性就会发生改变，同时会将soft对象注册到queue这个引用队列中。可以使用poll()这个方法取出被所有可达性改变的引用对象。\n\nReferenceQueue实现了一个队列的入队(enqueue)和出队(poll,remove)操作，内部元素就是泛型的Reference，并且Queue的实现，是由Reference自身的链表结构( 单向循环链表 )所实现的。\n\nReferenceQueue名义上是一个队列，但实际内部并非有实际的存储结构，它的存储是依赖于内部节点之间的关系来表达。可以理解为queue是一个类似于链表的结构，这里的节点其实就是reference本身。可以理解为queue为一个链表的容器，其自己仅存储当前的head节点，而后面的节点由每个reference节点自己通过next来保持即可。\n\n具体源码分析可以参考这个网站：[ReferenceQueue源码分析参考](http://www.importnew.com/26250.html)\n\n因此可以看出，当reference与referenQueue联合使用的主要作用就是当reference指向的referent回收时，提供一种通知机制，通过queue取到这些reference，来做额外的处理工作。当然，如果我们不需要这种通知机制，在创建Reference对象时不传入queue对象即可。\n\n### 3. SoftReference简介及使用\n\n根据上面我们讲的对象可达性原理，我们把一个对象存在根对象对其有直接或间接的SoftReference，并没有其他强引用路径，我们把该对象成为softly-reachable对象。JVM保证在抛出OutOfMemoryError前会回收这些softly-reachable对象。JVM会根据当前内存的情况来决定是否回收softly-reachable对象，但只要referent有强引用存在，该referent就一定不会被清理，因此SoftReference适合用来实现memory-sensitive caches。\n\n可见，SoftReference在一定程度上会影响JVM GC的，例如softly-reachable对应的referent多次垃圾回收仍然不满足释放条件，那么它会停留在heap old区，占据很大部分空间，在JVM没有抛出OutOfMemoryError前，它有可能会导致频繁的Full GC。\n\n下面是我使用SoftReference做的一个简单的缓存图片的测试\n\n```java\npublic class SoftReferenceImageTest {\n    public static void main(String[] args) throws IOException {\n        testImageLoad();\n    }\n\n    public static void testImageLoad() throws IOException {\n        String s = \"xmind.png\";\n        HashMap<String, SoftReference<byte[]>> map = new HashMap<>(100);\n        for (int i = 0; i < 100; i++) {\n            FileInputStream inputStream = new FileInputStream(s);\n            byte[] bytes = new byte[(int) inputStream.getChannel().size()];\n            while (inputStream.read(bytes) > 0) ;\n            inputStream.close();\n            map.put(s + i, new SoftReference<byte[]>(bytes));\n        }\n        for (int i = 0; i < map.size(); i++) {\n\n            Optional.ofNullable(map.get(s + i))\n                    .filter(softReference -> softReference.get() != null)\n                    .ifPresent(softReference -> {\n                        System.out.println(\"ok\");\n                    });\n        }\n\n    }\n}\n```\n\n运行这段代码时，加上jvm参数(**-Xms10M -Xmx10M -Xmn5M -XX:+PrintGCDetails**)\n\n运行结果为空，因为我加载的图片是5M，而分配给运行时的jvm是10M,所以每次加载完一张图片之后，在下一次加载就会清理这个SoftReference对象，因此最后得到的结果为空。\n\n### 4. WeakReference简介及使用\n\n当一个对象被WeakReference引用时，处于weakly-reachable状态时，只要发生GC时，就会被清除，同时会把WeakReference注册到引用队列中(如果存在的话)。 WeakReference不阻碍或影响它们对应的referent被终结(finalized)和回收(reclaimed)，因此，WeakReference经常被用作实现规范映射(canonicalizing mappings)。相比SoftReference来说，WeakReference对JVM GC几乎是没有影响的。\n\n下面是一个简单的demo\n\n```java\npublic class WeakReferenceTest {\n    public static void main(String[] args) {\n        weak();\n    }\n\n    public static void weak() {\n        ReferenceQueue<Integer> referenceQueue = new ReferenceQueue<>();\n        WeakReference<Integer> weak = new WeakReference<Integer>(new Integer(100), \n                                                                 referenceQueue);\n        System.out.println(\"GC 前===>\" + weak.get());\n        System.gc();\n        System.out.println(\"GC 后===>\" + weak.get());\n      \n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(referenceQueue.poll() == weak);\n    }\n}\n```\n\n运行结果\n\n```java\nGC 前===>100\nGC 后===>null\ntrue\n```\n\n结果分析：\n\n从上面我么可以看到，WeakReference所对应的Referent对象被回收了，因此验证了只要发生gc，weakly-reachable对象就会被gc回收。\n\n另外可以查看这篇文章，仔细说明jdk中WeakHashMap在Tomact中使用的场景[WeakHashMap使用场景](https://blog.csdn.net/kaka0509/article/details/73459419)\n\n### 5. PhantomReference简介及使用\n\n PhantomReference 不同于WeakReference、SoftReference，它存在的意义不是为了获取referent,因为你也永远获取不到，因为它的get如下\n\n```java\n public T get() {\n        return null;\n }\n```\n\nPhantomReference主要作为其指向的referent被回收时的一种通知机制,它就是利用上文讲到的ReferenceQueue实现的。当referent被gc回收时，JVM自动把PhantomReference对象(reference)本身加入到ReferenceQueue中，像发出信号通知一样，表明该reference指向的referent被回收。然后可以通过去queue中取到reference，此时说明其指向的referent已经被回收，可以通过这个通知机制来做额外的清场工作。 因此有些情况可以用PhantomReference 代替finalize()，做资源释放更明智。\n\n下面举个例子，用PhantomReference来自动关闭文件流。\n\n```java\npublic class ResourcePhantomReference<T> extends PhantomReference<T> {\n\n    private List<Closeable> closeables;\n\n    public ResourcePhantomReference(T referent, ReferenceQueue<? super T> q, List<Closeable> resource) {\n        super(referent, q);\n        closeables = resource;\n    }\n\n    public void cleanUp() {\n        if (closeables == null || closeables.size() == 0)\n            return;\n        for (Closeable closeable : closeables) {\n            try {\n                closeable.close();\n                System.out.println(\"clean up:\"+closeable);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n```java\npublic class ResourceCloseDeamon extends Thread {\n\n    private static ReferenceQueue QUEUE = new ReferenceQueue();\n\n    //保持对reference的引用,防止reference本身被回收\n    private static List<Reference> references=new ArrayList<>();\n    @Override\n    public void run() {\n        this.setName(\"ResourceCloseDeamon\");\n        while (true) {\n            try {\n                ResourcePhantomReference reference = (ResourcePhantomReference) QUEUE.remove();\n                reference.cleanUp();\n                references.remove(reference);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void register(Object referent, List<Closeable> closeables) {\n        references.add(new ResourcePhantomReference(referent,QUEUE,closeables));\n    }\n\n\n}\n```\n\n```java\npublic class FileOperation {\n\n    private FileOutputStream outputStream;\n\n    private FileInputStream inputStream;\n\n    public FileOperation(FileInputStream inputStream, FileOutputStream outputStream) {\n        this.outputStream = outputStream;\n        this.inputStream = inputStream;\n    }\n\n    public void operate() {\n        try {\n            inputStream.getChannel().transferTo(0, inputStream.getChannel().size(), outputStream.getChannel());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n}\n```\n\n测试代码：\n\n```java\npublic class PhantomTest {\n\n    public static void main(String[] args) throws Exception {\n        //打开回收\n        ResourceCloseDeamon deamon = new ResourceCloseDeamon();\n        deamon.setDaemon(true);\n        deamon.start();\n\n        // touch a.txt b.txt\n        // echo \"hello\" > a.txt\n\n        //保留对象,防止gc把stream回收掉,其不到演示效果\n        List<Closeable> all=new ArrayList<>();\n        FileInputStream inputStream;\n        FileOutputStream outputStream;\n\n        for (int i = 0; i < 100000; i++) {\n            inputStream = new FileInputStream(\"/Users/robin/a.txt\");\n            outputStream = new FileOutputStream(\"/Users/robin/b.txt\");\n            FileOperation operation = new FileOperation(inputStream, outputStream);\n            operation.operate();\n            TimeUnit.MILLISECONDS.sleep(100);\n\n            List<Closeable>closeables=new ArrayList<>();\n            closeables.add(inputStream);\n            closeables.add(outputStream);\n            all.addAll(closeables);\n            ResourceCloseDeamon.register(operation,closeables);\n            //用下面命令查看文件句柄,如果把上面register注释掉,就会发现句柄数量不断上升\n            //jps | grep PhantomTest | awk '{print $1}' |head -1 | xargs  lsof -p  | grep /User/robin\n            System.gc();\n\n        }\n\n\n    }\n}\n```\n\n运行上面的代码，通过jps | grep PhantomTest | awk '{print $1}' |head -1 | xargs lsof -p | grep /User/robin ｜ wc -l 可以看到句柄没有上升，而去掉ResourceCloseDeamon.register(operation,closeables);时，句柄就不会被释放。\n\nPhantomReference使用时一定要传一个referenceQueue,当然也可以传null,但是这样就毫无意义了。因为PhantomReference的get结果为null,如果在把queue设为null,那么在其指向的referent被回收时，reference本身将永远不会可能被加入队列中，这里我们可以看ReferenceQueue的源码。\n\n### 6. 总结\n\n#### 引用类型对比\n\n| 序号 | 引用类型 | 取得目标对象方式 | 垃圾回收条件   | 是否可能内存泄漏 |\n| ---- | -------- | ---------------- | -------------- | ---------------- |\n| 1    | 强引用   | 直接调用         | 不回收         | 可能             |\n| 2    | 软引用   | 通过 get()方法   | 视内存情况回收 | 不可能           |\n| 3    | 弱引用   | 通过 get()方法   | 永远回收       | 不可能           |\n| 4    | 虚引用   | 无法取得         | 不回收         | 可能             |\n\n通过对SoftReference，WeakReference，PhantomReference 的介绍，可以看出JDK提供这些类型的reference 主要是用来和GC交互的，根据reference的不同，让JVM采用不同策略来进行对对象的回收(reclaim)。softly-reachable的referent在保证在OutOfMemoryError之前回收对象，weakly-reachable的referent在发生GC时就会被回收,同时这些reference和referenceQueue在一起提供通知机制，PhantomReference的作用就是仅仅就是提供对象回收通知机制，Finalizer借助这种机制实现referent的finalize执行，SoftReference、WeakReference也可以配合referenceQueue使用，实现对象回收通知机制。\n\n### 参考\n\n[Java中的四种引用类型](https://www.jianshu.com/p/147793693edc)\n\n[Java Reference详解](https://my.oschina.net/robinyao/blog/829983)\n\n[Reference、ReferenceQueue 详解](http://www.importnew.com/26250.html)\n\n[用弱引用堵住内存泄漏](","source":"_posts/Java-Reference详解.md","raw":"title: Java Reference详解\nauthor: 枫秀天涯\nabbrlink: 28002\ntags:\n  - java\n  - java引用\ncategories:\n  - java\ndate: 2019-01-04 10:25:00\n---\n# Java Reference详解\n\n### 概述\n\nJava引用体系中我们最熟悉的就是强引用类型，如 A a= new A();这是我们经常说的强引用StrongReference，jvm gc时会检测对象是否存在强引用，如果存在由根对象对其有传递的强引用，则不会对其进行回收，即使内存不足抛出OutOfMemoryError。\n\n除了强引用外，Java还引入了SoftReference，WeakReference，PhantomReference，FinalReference ，这些类放在java.lang.ref包下，类的继承体系如下图。Java额外引入这个四种类型引用主要目的是在jvm 在gc时，按照引用类型的不同，在回收时采用不同的逻辑。可以把这些引用看作是对对象的一层包裹，jvm根据外层不同的包裹，对其包裹的对象采用不同的回收策略，或特殊逻辑处理。 这几种类型的引用主要在jvm内存缓存、资源释放、对象可达性事件处理等场景会用到。\n\n![输入图片说明](https://static.oschina.net/uploads/img/201701/21153037_ubGO.png)\n\n本篇文章主要讲解前面三种SoftReference，WeakReference和PhantomReference的使用，以及ReferenceQueue的使用。至于FinalRefeence会在另一篇文章中讲解。\n<!-- more -->\n主要内容如下\n\n1. 对象可达性判断\n2. ReferenceQueue 简介\n3. SoftReference简介及使用\n4. WeakReference简介及使用\n5. PhantomReference简介及使用\n6. 总结\n\n**本文名称使用说明**名称说明下：Reference指代引用对象本身，Referent指代被引用对象，下文介绍会以Reference，Referent形式出现。 \n\n### 1. 对象可达性判断\n\njvm gc时，判断一个对象是否存在引用时，都是从根结合引用(Root Set of References)开始去标识,往往到达一个对象的引用路径会存在多条，如下图。 ![输入图片说明](https://static.oschina.net/uploads/img/201701/21165610_kkb9.png)\n\n那么 垃圾回收时会依据两个原则来判断对象的可达性：\n\n- 单一路径中，以最弱的引用为准\n- 多路径中，以最强的引用为准\n\n例如Obj4的引用，存在3个路径:1->6、2->5、3->4, 那么从根对象到Obj4最强的引用是2->5，因为它们都是强引用。如果仅仅存在一个路径对Obj4有引用时，比如现在只剩1->6,那么根对象到Obj4的引用就是以最弱的为准，就是SoftReference引用,Obj4就是softly-reachable对象。如果是WeakReference引用，就称作weakly-reachable对象。只要一个对象是强引用可达，那么这个对象就不会被gc，即使发生OOM也不会回收这个对象。\n\n### 2. ReferenceQueue 简介\n\n引用队列，在检测到适当的可到达性更改后，即Referent对象的可达性发生适当的改变时，垃圾回收器将已注册的引用对象reference添加到该队列中。\n\n简单用下面代码来说明\n\n```java\nObject object = new Object();\nReferenceQueue  queue = new ReferenceQueue();\nSoftReference<Objecct> soft = new SoftReference<>(object,queue);\nobject = null;\nSysten.gc();\n//休眠一会，等待gc完成\nThread.sleep(100);\nSystem.out.println(queue.poll() == soft);\nSystem.out.println(soft.get() == null)\n```\n\n输出结果：\n\n```java\ntrue\ntrue\n```\n\n结果分析：\n\n对应上面第一句话，就是说当soft引用对象包含的object对象被gc之后，其可达性就会发生改变，同时会将soft对象注册到queue这个引用队列中。可以使用poll()这个方法取出被所有可达性改变的引用对象。\n\nReferenceQueue实现了一个队列的入队(enqueue)和出队(poll,remove)操作，内部元素就是泛型的Reference，并且Queue的实现，是由Reference自身的链表结构( 单向循环链表 )所实现的。\n\nReferenceQueue名义上是一个队列，但实际内部并非有实际的存储结构，它的存储是依赖于内部节点之间的关系来表达。可以理解为queue是一个类似于链表的结构，这里的节点其实就是reference本身。可以理解为queue为一个链表的容器，其自己仅存储当前的head节点，而后面的节点由每个reference节点自己通过next来保持即可。\n\n具体源码分析可以参考这个网站：[ReferenceQueue源码分析参考](http://www.importnew.com/26250.html)\n\n因此可以看出，当reference与referenQueue联合使用的主要作用就是当reference指向的referent回收时，提供一种通知机制，通过queue取到这些reference，来做额外的处理工作。当然，如果我们不需要这种通知机制，在创建Reference对象时不传入queue对象即可。\n\n### 3. SoftReference简介及使用\n\n根据上面我们讲的对象可达性原理，我们把一个对象存在根对象对其有直接或间接的SoftReference，并没有其他强引用路径，我们把该对象成为softly-reachable对象。JVM保证在抛出OutOfMemoryError前会回收这些softly-reachable对象。JVM会根据当前内存的情况来决定是否回收softly-reachable对象，但只要referent有强引用存在，该referent就一定不会被清理，因此SoftReference适合用来实现memory-sensitive caches。\n\n可见，SoftReference在一定程度上会影响JVM GC的，例如softly-reachable对应的referent多次垃圾回收仍然不满足释放条件，那么它会停留在heap old区，占据很大部分空间，在JVM没有抛出OutOfMemoryError前，它有可能会导致频繁的Full GC。\n\n下面是我使用SoftReference做的一个简单的缓存图片的测试\n\n```java\npublic class SoftReferenceImageTest {\n    public static void main(String[] args) throws IOException {\n        testImageLoad();\n    }\n\n    public static void testImageLoad() throws IOException {\n        String s = \"xmind.png\";\n        HashMap<String, SoftReference<byte[]>> map = new HashMap<>(100);\n        for (int i = 0; i < 100; i++) {\n            FileInputStream inputStream = new FileInputStream(s);\n            byte[] bytes = new byte[(int) inputStream.getChannel().size()];\n            while (inputStream.read(bytes) > 0) ;\n            inputStream.close();\n            map.put(s + i, new SoftReference<byte[]>(bytes));\n        }\n        for (int i = 0; i < map.size(); i++) {\n\n            Optional.ofNullable(map.get(s + i))\n                    .filter(softReference -> softReference.get() != null)\n                    .ifPresent(softReference -> {\n                        System.out.println(\"ok\");\n                    });\n        }\n\n    }\n}\n```\n\n运行这段代码时，加上jvm参数(**-Xms10M -Xmx10M -Xmn5M -XX:+PrintGCDetails**)\n\n运行结果为空，因为我加载的图片是5M，而分配给运行时的jvm是10M,所以每次加载完一张图片之后，在下一次加载就会清理这个SoftReference对象，因此最后得到的结果为空。\n\n### 4. WeakReference简介及使用\n\n当一个对象被WeakReference引用时，处于weakly-reachable状态时，只要发生GC时，就会被清除，同时会把WeakReference注册到引用队列中(如果存在的话)。 WeakReference不阻碍或影响它们对应的referent被终结(finalized)和回收(reclaimed)，因此，WeakReference经常被用作实现规范映射(canonicalizing mappings)。相比SoftReference来说，WeakReference对JVM GC几乎是没有影响的。\n\n下面是一个简单的demo\n\n```java\npublic class WeakReferenceTest {\n    public static void main(String[] args) {\n        weak();\n    }\n\n    public static void weak() {\n        ReferenceQueue<Integer> referenceQueue = new ReferenceQueue<>();\n        WeakReference<Integer> weak = new WeakReference<Integer>(new Integer(100), \n                                                                 referenceQueue);\n        System.out.println(\"GC 前===>\" + weak.get());\n        System.gc();\n        System.out.println(\"GC 后===>\" + weak.get());\n      \n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(referenceQueue.poll() == weak);\n    }\n}\n```\n\n运行结果\n\n```java\nGC 前===>100\nGC 后===>null\ntrue\n```\n\n结果分析：\n\n从上面我么可以看到，WeakReference所对应的Referent对象被回收了，因此验证了只要发生gc，weakly-reachable对象就会被gc回收。\n\n另外可以查看这篇文章，仔细说明jdk中WeakHashMap在Tomact中使用的场景[WeakHashMap使用场景](https://blog.csdn.net/kaka0509/article/details/73459419)\n\n### 5. PhantomReference简介及使用\n\n PhantomReference 不同于WeakReference、SoftReference，它存在的意义不是为了获取referent,因为你也永远获取不到，因为它的get如下\n\n```java\n public T get() {\n        return null;\n }\n```\n\nPhantomReference主要作为其指向的referent被回收时的一种通知机制,它就是利用上文讲到的ReferenceQueue实现的。当referent被gc回收时，JVM自动把PhantomReference对象(reference)本身加入到ReferenceQueue中，像发出信号通知一样，表明该reference指向的referent被回收。然后可以通过去queue中取到reference，此时说明其指向的referent已经被回收，可以通过这个通知机制来做额外的清场工作。 因此有些情况可以用PhantomReference 代替finalize()，做资源释放更明智。\n\n下面举个例子，用PhantomReference来自动关闭文件流。\n\n```java\npublic class ResourcePhantomReference<T> extends PhantomReference<T> {\n\n    private List<Closeable> closeables;\n\n    public ResourcePhantomReference(T referent, ReferenceQueue<? super T> q, List<Closeable> resource) {\n        super(referent, q);\n        closeables = resource;\n    }\n\n    public void cleanUp() {\n        if (closeables == null || closeables.size() == 0)\n            return;\n        for (Closeable closeable : closeables) {\n            try {\n                closeable.close();\n                System.out.println(\"clean up:\"+closeable);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n```java\npublic class ResourceCloseDeamon extends Thread {\n\n    private static ReferenceQueue QUEUE = new ReferenceQueue();\n\n    //保持对reference的引用,防止reference本身被回收\n    private static List<Reference> references=new ArrayList<>();\n    @Override\n    public void run() {\n        this.setName(\"ResourceCloseDeamon\");\n        while (true) {\n            try {\n                ResourcePhantomReference reference = (ResourcePhantomReference) QUEUE.remove();\n                reference.cleanUp();\n                references.remove(reference);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void register(Object referent, List<Closeable> closeables) {\n        references.add(new ResourcePhantomReference(referent,QUEUE,closeables));\n    }\n\n\n}\n```\n\n```java\npublic class FileOperation {\n\n    private FileOutputStream outputStream;\n\n    private FileInputStream inputStream;\n\n    public FileOperation(FileInputStream inputStream, FileOutputStream outputStream) {\n        this.outputStream = outputStream;\n        this.inputStream = inputStream;\n    }\n\n    public void operate() {\n        try {\n            inputStream.getChannel().transferTo(0, inputStream.getChannel().size(), outputStream.getChannel());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n}\n```\n\n测试代码：\n\n```java\npublic class PhantomTest {\n\n    public static void main(String[] args) throws Exception {\n        //打开回收\n        ResourceCloseDeamon deamon = new ResourceCloseDeamon();\n        deamon.setDaemon(true);\n        deamon.start();\n\n        // touch a.txt b.txt\n        // echo \"hello\" > a.txt\n\n        //保留对象,防止gc把stream回收掉,其不到演示效果\n        List<Closeable> all=new ArrayList<>();\n        FileInputStream inputStream;\n        FileOutputStream outputStream;\n\n        for (int i = 0; i < 100000; i++) {\n            inputStream = new FileInputStream(\"/Users/robin/a.txt\");\n            outputStream = new FileOutputStream(\"/Users/robin/b.txt\");\n            FileOperation operation = new FileOperation(inputStream, outputStream);\n            operation.operate();\n            TimeUnit.MILLISECONDS.sleep(100);\n\n            List<Closeable>closeables=new ArrayList<>();\n            closeables.add(inputStream);\n            closeables.add(outputStream);\n            all.addAll(closeables);\n            ResourceCloseDeamon.register(operation,closeables);\n            //用下面命令查看文件句柄,如果把上面register注释掉,就会发现句柄数量不断上升\n            //jps | grep PhantomTest | awk '{print $1}' |head -1 | xargs  lsof -p  | grep /User/robin\n            System.gc();\n\n        }\n\n\n    }\n}\n```\n\n运行上面的代码，通过jps | grep PhantomTest | awk '{print $1}' |head -1 | xargs lsof -p | grep /User/robin ｜ wc -l 可以看到句柄没有上升，而去掉ResourceCloseDeamon.register(operation,closeables);时，句柄就不会被释放。\n\nPhantomReference使用时一定要传一个referenceQueue,当然也可以传null,但是这样就毫无意义了。因为PhantomReference的get结果为null,如果在把queue设为null,那么在其指向的referent被回收时，reference本身将永远不会可能被加入队列中，这里我们可以看ReferenceQueue的源码。\n\n### 6. 总结\n\n#### 引用类型对比\n\n| 序号 | 引用类型 | 取得目标对象方式 | 垃圾回收条件   | 是否可能内存泄漏 |\n| ---- | -------- | ---------------- | -------------- | ---------------- |\n| 1    | 强引用   | 直接调用         | 不回收         | 可能             |\n| 2    | 软引用   | 通过 get()方法   | 视内存情况回收 | 不可能           |\n| 3    | 弱引用   | 通过 get()方法   | 永远回收       | 不可能           |\n| 4    | 虚引用   | 无法取得         | 不回收         | 可能             |\n\n通过对SoftReference，WeakReference，PhantomReference 的介绍，可以看出JDK提供这些类型的reference 主要是用来和GC交互的，根据reference的不同，让JVM采用不同策略来进行对对象的回收(reclaim)。softly-reachable的referent在保证在OutOfMemoryError之前回收对象，weakly-reachable的referent在发生GC时就会被回收,同时这些reference和referenceQueue在一起提供通知机制，PhantomReference的作用就是仅仅就是提供对象回收通知机制，Finalizer借助这种机制实现referent的finalize执行，SoftReference、WeakReference也可以配合referenceQueue使用，实现对象回收通知机制。\n\n### 参考\n\n[Java中的四种引用类型](https://www.jianshu.com/p/147793693edc)\n\n[Java Reference详解](https://my.oschina.net/robinyao/blog/829983)\n\n[Reference、ReferenceQueue 详解](http://www.importnew.com/26250.html)\n\n[用弱引用堵住内存泄漏](","slug":"Java-Reference详解","published":1,"updated":"2019-01-04T07:51:13.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovp3000k9q1utu61m7dk","content":"<h1 id=\"Java-Reference详解\"><a href=\"#Java-Reference详解\" class=\"headerlink\" title=\"Java Reference详解\"></a>Java Reference详解</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Java引用体系中我们最熟悉的就是强引用类型，如 A a= new A();这是我们经常说的强引用StrongReference，jvm gc时会检测对象是否存在强引用，如果存在由根对象对其有传递的强引用，则不会对其进行回收，即使内存不足抛出OutOfMemoryError。</p>\n<p>除了强引用外，Java还引入了SoftReference，WeakReference，PhantomReference，FinalReference ，这些类放在java.lang.ref包下，类的继承体系如下图。Java额外引入这个四种类型引用主要目的是在jvm 在gc时，按照引用类型的不同，在回收时采用不同的逻辑。可以把这些引用看作是对对象的一层包裹，jvm根据外层不同的包裹，对其包裹的对象采用不同的回收策略，或特殊逻辑处理。 这几种类型的引用主要在jvm内存缓存、资源释放、对象可达性事件处理等场景会用到。</p>\n<p><img src=\"https://static.oschina.net/uploads/img/201701/21153037_ubGO.png\" alt=\"输入图片说明\"></p>\n<p>本篇文章主要讲解前面三种SoftReference，WeakReference和PhantomReference的使用，以及ReferenceQueue的使用。至于FinalRefeence会在另一篇文章中讲解。<br><a id=\"more\"></a><br>主要内容如下</p>\n<ol>\n<li>对象可达性判断</li>\n<li>ReferenceQueue 简介</li>\n<li>SoftReference简介及使用</li>\n<li>WeakReference简介及使用</li>\n<li>PhantomReference简介及使用</li>\n<li>总结</li>\n</ol>\n<p><strong>本文名称使用说明</strong>名称说明下：Reference指代引用对象本身，Referent指代被引用对象，下文介绍会以Reference，Referent形式出现。 </p>\n<h3 id=\"1-对象可达性判断\"><a href=\"#1-对象可达性判断\" class=\"headerlink\" title=\"1. 对象可达性判断\"></a>1. 对象可达性判断</h3><p>jvm gc时，判断一个对象是否存在引用时，都是从根结合引用(Root Set of References)开始去标识,往往到达一个对象的引用路径会存在多条，如下图。 <img src=\"https://static.oschina.net/uploads/img/201701/21165610_kkb9.png\" alt=\"输入图片说明\"></p>\n<p>那么 垃圾回收时会依据两个原则来判断对象的可达性：</p>\n<ul>\n<li>单一路径中，以最弱的引用为准</li>\n<li>多路径中，以最强的引用为准</li>\n</ul>\n<p>例如Obj4的引用，存在3个路径:1-&gt;6、2-&gt;5、3-&gt;4, 那么从根对象到Obj4最强的引用是2-&gt;5，因为它们都是强引用。如果仅仅存在一个路径对Obj4有引用时，比如现在只剩1-&gt;6,那么根对象到Obj4的引用就是以最弱的为准，就是SoftReference引用,Obj4就是softly-reachable对象。如果是WeakReference引用，就称作weakly-reachable对象。只要一个对象是强引用可达，那么这个对象就不会被gc，即使发生OOM也不会回收这个对象。</p>\n<h3 id=\"2-ReferenceQueue-简介\"><a href=\"#2-ReferenceQueue-简介\" class=\"headerlink\" title=\"2. ReferenceQueue 简介\"></a>2. ReferenceQueue 简介</h3><p>引用队列，在检测到适当的可到达性更改后，即Referent对象的可达性发生适当的改变时，垃圾回收器将已注册的引用对象reference添加到该队列中。</p>\n<p>简单用下面代码来说明</p>\n<pre><code class=\"java\">Object object = new Object();\nReferenceQueue  queue = new ReferenceQueue();\nSoftReference&lt;Objecct&gt; soft = new SoftReference&lt;&gt;(object,queue);\nobject = null;\nSysten.gc();\n//休眠一会，等待gc完成\nThread.sleep(100);\nSystem.out.println(queue.poll() == soft);\nSystem.out.println(soft.get() == null)\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"java\">true\ntrue\n</code></pre>\n<p>结果分析：</p>\n<p>对应上面第一句话，就是说当soft引用对象包含的object对象被gc之后，其可达性就会发生改变，同时会将soft对象注册到queue这个引用队列中。可以使用poll()这个方法取出被所有可达性改变的引用对象。</p>\n<p>ReferenceQueue实现了一个队列的入队(enqueue)和出队(poll,remove)操作，内部元素就是泛型的Reference，并且Queue的实现，是由Reference自身的链表结构( 单向循环链表 )所实现的。</p>\n<p>ReferenceQueue名义上是一个队列，但实际内部并非有实际的存储结构，它的存储是依赖于内部节点之间的关系来表达。可以理解为queue是一个类似于链表的结构，这里的节点其实就是reference本身。可以理解为queue为一个链表的容器，其自己仅存储当前的head节点，而后面的节点由每个reference节点自己通过next来保持即可。</p>\n<p>具体源码分析可以参考这个网站：<a href=\"http://www.importnew.com/26250.html\" target=\"_blank\" rel=\"noopener\">ReferenceQueue源码分析参考</a></p>\n<p>因此可以看出，当reference与referenQueue联合使用的主要作用就是当reference指向的referent回收时，提供一种通知机制，通过queue取到这些reference，来做额外的处理工作。当然，如果我们不需要这种通知机制，在创建Reference对象时不传入queue对象即可。</p>\n<h3 id=\"3-SoftReference简介及使用\"><a href=\"#3-SoftReference简介及使用\" class=\"headerlink\" title=\"3. SoftReference简介及使用\"></a>3. SoftReference简介及使用</h3><p>根据上面我们讲的对象可达性原理，我们把一个对象存在根对象对其有直接或间接的SoftReference，并没有其他强引用路径，我们把该对象成为softly-reachable对象。JVM保证在抛出OutOfMemoryError前会回收这些softly-reachable对象。JVM会根据当前内存的情况来决定是否回收softly-reachable对象，但只要referent有强引用存在，该referent就一定不会被清理，因此SoftReference适合用来实现memory-sensitive caches。</p>\n<p>可见，SoftReference在一定程度上会影响JVM GC的，例如softly-reachable对应的referent多次垃圾回收仍然不满足释放条件，那么它会停留在heap old区，占据很大部分空间，在JVM没有抛出OutOfMemoryError前，它有可能会导致频繁的Full GC。</p>\n<p>下面是我使用SoftReference做的一个简单的缓存图片的测试</p>\n<pre><code class=\"java\">public class SoftReferenceImageTest {\n    public static void main(String[] args) throws IOException {\n        testImageLoad();\n    }\n\n    public static void testImageLoad() throws IOException {\n        String s = &quot;xmind.png&quot;;\n        HashMap&lt;String, SoftReference&lt;byte[]&gt;&gt; map = new HashMap&lt;&gt;(100);\n        for (int i = 0; i &lt; 100; i++) {\n            FileInputStream inputStream = new FileInputStream(s);\n            byte[] bytes = new byte[(int) inputStream.getChannel().size()];\n            while (inputStream.read(bytes) &gt; 0) ;\n            inputStream.close();\n            map.put(s + i, new SoftReference&lt;byte[]&gt;(bytes));\n        }\n        for (int i = 0; i &lt; map.size(); i++) {\n\n            Optional.ofNullable(map.get(s + i))\n                    .filter(softReference -&gt; softReference.get() != null)\n                    .ifPresent(softReference -&gt; {\n                        System.out.println(&quot;ok&quot;);\n                    });\n        }\n\n    }\n}\n</code></pre>\n<p>运行这段代码时，加上jvm参数(<strong>-Xms10M -Xmx10M -Xmn5M -XX:+PrintGCDetails</strong>)</p>\n<p>运行结果为空，因为我加载的图片是5M，而分配给运行时的jvm是10M,所以每次加载完一张图片之后，在下一次加载就会清理这个SoftReference对象，因此最后得到的结果为空。</p>\n<h3 id=\"4-WeakReference简介及使用\"><a href=\"#4-WeakReference简介及使用\" class=\"headerlink\" title=\"4. WeakReference简介及使用\"></a>4. WeakReference简介及使用</h3><p>当一个对象被WeakReference引用时，处于weakly-reachable状态时，只要发生GC时，就会被清除，同时会把WeakReference注册到引用队列中(如果存在的话)。 WeakReference不阻碍或影响它们对应的referent被终结(finalized)和回收(reclaimed)，因此，WeakReference经常被用作实现规范映射(canonicalizing mappings)。相比SoftReference来说，WeakReference对JVM GC几乎是没有影响的。</p>\n<p>下面是一个简单的demo</p>\n<pre><code class=\"java\">public class WeakReferenceTest {\n    public static void main(String[] args) {\n        weak();\n    }\n\n    public static void weak() {\n        ReferenceQueue&lt;Integer&gt; referenceQueue = new ReferenceQueue&lt;&gt;();\n        WeakReference&lt;Integer&gt; weak = new WeakReference&lt;Integer&gt;(new Integer(100), \n                                                                 referenceQueue);\n        System.out.println(&quot;GC 前===&gt;&quot; + weak.get());\n        System.gc();\n        System.out.println(&quot;GC 后===&gt;&quot; + weak.get());\n\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(referenceQueue.poll() == weak);\n    }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code class=\"java\">GC 前===&gt;100\nGC 后===&gt;null\ntrue\n</code></pre>\n<p>结果分析：</p>\n<p>从上面我么可以看到，WeakReference所对应的Referent对象被回收了，因此验证了只要发生gc，weakly-reachable对象就会被gc回收。</p>\n<p>另外可以查看这篇文章，仔细说明jdk中WeakHashMap在Tomact中使用的场景<a href=\"https://blog.csdn.net/kaka0509/article/details/73459419\" target=\"_blank\" rel=\"noopener\">WeakHashMap使用场景</a></p>\n<h3 id=\"5-PhantomReference简介及使用\"><a href=\"#5-PhantomReference简介及使用\" class=\"headerlink\" title=\"5. PhantomReference简介及使用\"></a>5. PhantomReference简介及使用</h3><p> PhantomReference 不同于WeakReference、SoftReference，它存在的意义不是为了获取referent,因为你也永远获取不到，因为它的get如下</p>\n<pre><code class=\"java\"> public T get() {\n        return null;\n }\n</code></pre>\n<p>PhantomReference主要作为其指向的referent被回收时的一种通知机制,它就是利用上文讲到的ReferenceQueue实现的。当referent被gc回收时，JVM自动把PhantomReference对象(reference)本身加入到ReferenceQueue中，像发出信号通知一样，表明该reference指向的referent被回收。然后可以通过去queue中取到reference，此时说明其指向的referent已经被回收，可以通过这个通知机制来做额外的清场工作。 因此有些情况可以用PhantomReference 代替finalize()，做资源释放更明智。</p>\n<p>下面举个例子，用PhantomReference来自动关闭文件流。</p>\n<pre><code class=\"java\">public class ResourcePhantomReference&lt;T&gt; extends PhantomReference&lt;T&gt; {\n\n    private List&lt;Closeable&gt; closeables;\n\n    public ResourcePhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q, List&lt;Closeable&gt; resource) {\n        super(referent, q);\n        closeables = resource;\n    }\n\n    public void cleanUp() {\n        if (closeables == null || closeables.size() == 0)\n            return;\n        for (Closeable closeable : closeables) {\n            try {\n                closeable.close();\n                System.out.println(&quot;clean up:&quot;+closeable);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"java\">public class ResourceCloseDeamon extends Thread {\n\n    private static ReferenceQueue QUEUE = new ReferenceQueue();\n\n    //保持对reference的引用,防止reference本身被回收\n    private static List&lt;Reference&gt; references=new ArrayList&lt;&gt;();\n    @Override\n    public void run() {\n        this.setName(&quot;ResourceCloseDeamon&quot;);\n        while (true) {\n            try {\n                ResourcePhantomReference reference = (ResourcePhantomReference) QUEUE.remove();\n                reference.cleanUp();\n                references.remove(reference);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void register(Object referent, List&lt;Closeable&gt; closeables) {\n        references.add(new ResourcePhantomReference(referent,QUEUE,closeables));\n    }\n\n\n}\n</code></pre>\n<pre><code class=\"java\">public class FileOperation {\n\n    private FileOutputStream outputStream;\n\n    private FileInputStream inputStream;\n\n    public FileOperation(FileInputStream inputStream, FileOutputStream outputStream) {\n        this.outputStream = outputStream;\n        this.inputStream = inputStream;\n    }\n\n    public void operate() {\n        try {\n            inputStream.getChannel().transferTo(0, inputStream.getChannel().size(), outputStream.getChannel());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n}\n</code></pre>\n<p>测试代码：</p>\n<pre><code class=\"java\">public class PhantomTest {\n\n    public static void main(String[] args) throws Exception {\n        //打开回收\n        ResourceCloseDeamon deamon = new ResourceCloseDeamon();\n        deamon.setDaemon(true);\n        deamon.start();\n\n        // touch a.txt b.txt\n        // echo &quot;hello&quot; &gt; a.txt\n\n        //保留对象,防止gc把stream回收掉,其不到演示效果\n        List&lt;Closeable&gt; all=new ArrayList&lt;&gt;();\n        FileInputStream inputStream;\n        FileOutputStream outputStream;\n\n        for (int i = 0; i &lt; 100000; i++) {\n            inputStream = new FileInputStream(&quot;/Users/robin/a.txt&quot;);\n            outputStream = new FileOutputStream(&quot;/Users/robin/b.txt&quot;);\n            FileOperation operation = new FileOperation(inputStream, outputStream);\n            operation.operate();\n            TimeUnit.MILLISECONDS.sleep(100);\n\n            List&lt;Closeable&gt;closeables=new ArrayList&lt;&gt;();\n            closeables.add(inputStream);\n            closeables.add(outputStream);\n            all.addAll(closeables);\n            ResourceCloseDeamon.register(operation,closeables);\n            //用下面命令查看文件句柄,如果把上面register注释掉,就会发现句柄数量不断上升\n            //jps | grep PhantomTest | awk &#39;{print $1}&#39; |head -1 | xargs  lsof -p  | grep /User/robin\n            System.gc();\n\n        }\n\n\n    }\n}\n</code></pre>\n<p>运行上面的代码，通过jps | grep PhantomTest | awk ‘{print $1}’ |head -1 | xargs lsof -p | grep /User/robin ｜ wc -l 可以看到句柄没有上升，而去掉ResourceCloseDeamon.register(operation,closeables);时，句柄就不会被释放。</p>\n<p>PhantomReference使用时一定要传一个referenceQueue,当然也可以传null,但是这样就毫无意义了。因为PhantomReference的get结果为null,如果在把queue设为null,那么在其指向的referent被回收时，reference本身将永远不会可能被加入队列中，这里我们可以看ReferenceQueue的源码。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><h4 id=\"引用类型对比\"><a href=\"#引用类型对比\" class=\"headerlink\" title=\"引用类型对比\"></a>引用类型对比</h4><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>引用类型</th>\n<th>取得目标对象方式</th>\n<th>垃圾回收条件</th>\n<th>是否可能内存泄漏</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>强引用</td>\n<td>直接调用</td>\n<td>不回收</td>\n<td>可能</td>\n</tr>\n<tr>\n<td>2</td>\n<td>软引用</td>\n<td>通过 get()方法</td>\n<td>视内存情况回收</td>\n<td>不可能</td>\n</tr>\n<tr>\n<td>3</td>\n<td>弱引用</td>\n<td>通过 get()方法</td>\n<td>永远回收</td>\n<td>不可能</td>\n</tr>\n<tr>\n<td>4</td>\n<td>虚引用</td>\n<td>无法取得</td>\n<td>不回收</td>\n<td>可能</td>\n</tr>\n</tbody>\n</table>\n<p>通过对SoftReference，WeakReference，PhantomReference 的介绍，可以看出JDK提供这些类型的reference 主要是用来和GC交互的，根据reference的不同，让JVM采用不同策略来进行对对象的回收(reclaim)。softly-reachable的referent在保证在OutOfMemoryError之前回收对象，weakly-reachable的referent在发生GC时就会被回收,同时这些reference和referenceQueue在一起提供通知机制，PhantomReference的作用就是仅仅就是提供对象回收通知机制，Finalizer借助这种机制实现referent的finalize执行，SoftReference、WeakReference也可以配合referenceQueue使用，实现对象回收通知机制。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.jianshu.com/p/147793693edc\" target=\"_blank\" rel=\"noopener\">Java中的四种引用类型</a></p>\n<p><a href=\"https://my.oschina.net/robinyao/blog/829983\" target=\"_blank\" rel=\"noopener\">Java Reference详解</a></p>\n<p><a href=\"http://www.importnew.com/26250.html\" target=\"_blank\" rel=\"noopener\">Reference、ReferenceQueue 详解</a></p>\n<p>[用弱引用堵住内存泄漏](</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java-Reference详解\"><a href=\"#Java-Reference详解\" class=\"headerlink\" title=\"Java Reference详解\"></a>Java Reference详解</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Java引用体系中我们最熟悉的就是强引用类型，如 A a= new A();这是我们经常说的强引用StrongReference，jvm gc时会检测对象是否存在强引用，如果存在由根对象对其有传递的强引用，则不会对其进行回收，即使内存不足抛出OutOfMemoryError。</p>\n<p>除了强引用外，Java还引入了SoftReference，WeakReference，PhantomReference，FinalReference ，这些类放在java.lang.ref包下，类的继承体系如下图。Java额外引入这个四种类型引用主要目的是在jvm 在gc时，按照引用类型的不同，在回收时采用不同的逻辑。可以把这些引用看作是对对象的一层包裹，jvm根据外层不同的包裹，对其包裹的对象采用不同的回收策略，或特殊逻辑处理。 这几种类型的引用主要在jvm内存缓存、资源释放、对象可达性事件处理等场景会用到。</p>\n<p><img src=\"https://static.oschina.net/uploads/img/201701/21153037_ubGO.png\" alt=\"输入图片说明\"></p>\n<p>本篇文章主要讲解前面三种SoftReference，WeakReference和PhantomReference的使用，以及ReferenceQueue的使用。至于FinalRefeence会在另一篇文章中讲解。<br>","more":"<br>主要内容如下</p>\n<ol>\n<li>对象可达性判断</li>\n<li>ReferenceQueue 简介</li>\n<li>SoftReference简介及使用</li>\n<li>WeakReference简介及使用</li>\n<li>PhantomReference简介及使用</li>\n<li>总结</li>\n</ol>\n<p><strong>本文名称使用说明</strong>名称说明下：Reference指代引用对象本身，Referent指代被引用对象，下文介绍会以Reference，Referent形式出现。 </p>\n<h3 id=\"1-对象可达性判断\"><a href=\"#1-对象可达性判断\" class=\"headerlink\" title=\"1. 对象可达性判断\"></a>1. 对象可达性判断</h3><p>jvm gc时，判断一个对象是否存在引用时，都是从根结合引用(Root Set of References)开始去标识,往往到达一个对象的引用路径会存在多条，如下图。 <img src=\"https://static.oschina.net/uploads/img/201701/21165610_kkb9.png\" alt=\"输入图片说明\"></p>\n<p>那么 垃圾回收时会依据两个原则来判断对象的可达性：</p>\n<ul>\n<li>单一路径中，以最弱的引用为准</li>\n<li>多路径中，以最强的引用为准</li>\n</ul>\n<p>例如Obj4的引用，存在3个路径:1-&gt;6、2-&gt;5、3-&gt;4, 那么从根对象到Obj4最强的引用是2-&gt;5，因为它们都是强引用。如果仅仅存在一个路径对Obj4有引用时，比如现在只剩1-&gt;6,那么根对象到Obj4的引用就是以最弱的为准，就是SoftReference引用,Obj4就是softly-reachable对象。如果是WeakReference引用，就称作weakly-reachable对象。只要一个对象是强引用可达，那么这个对象就不会被gc，即使发生OOM也不会回收这个对象。</p>\n<h3 id=\"2-ReferenceQueue-简介\"><a href=\"#2-ReferenceQueue-简介\" class=\"headerlink\" title=\"2. ReferenceQueue 简介\"></a>2. ReferenceQueue 简介</h3><p>引用队列，在检测到适当的可到达性更改后，即Referent对象的可达性发生适当的改变时，垃圾回收器将已注册的引用对象reference添加到该队列中。</p>\n<p>简单用下面代码来说明</p>\n<pre><code class=\"java\">Object object = new Object();\nReferenceQueue  queue = new ReferenceQueue();\nSoftReference&lt;Objecct&gt; soft = new SoftReference&lt;&gt;(object,queue);\nobject = null;\nSysten.gc();\n//休眠一会，等待gc完成\nThread.sleep(100);\nSystem.out.println(queue.poll() == soft);\nSystem.out.println(soft.get() == null)\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"java\">true\ntrue\n</code></pre>\n<p>结果分析：</p>\n<p>对应上面第一句话，就是说当soft引用对象包含的object对象被gc之后，其可达性就会发生改变，同时会将soft对象注册到queue这个引用队列中。可以使用poll()这个方法取出被所有可达性改变的引用对象。</p>\n<p>ReferenceQueue实现了一个队列的入队(enqueue)和出队(poll,remove)操作，内部元素就是泛型的Reference，并且Queue的实现，是由Reference自身的链表结构( 单向循环链表 )所实现的。</p>\n<p>ReferenceQueue名义上是一个队列，但实际内部并非有实际的存储结构，它的存储是依赖于内部节点之间的关系来表达。可以理解为queue是一个类似于链表的结构，这里的节点其实就是reference本身。可以理解为queue为一个链表的容器，其自己仅存储当前的head节点，而后面的节点由每个reference节点自己通过next来保持即可。</p>\n<p>具体源码分析可以参考这个网站：<a href=\"http://www.importnew.com/26250.html\" target=\"_blank\" rel=\"noopener\">ReferenceQueue源码分析参考</a></p>\n<p>因此可以看出，当reference与referenQueue联合使用的主要作用就是当reference指向的referent回收时，提供一种通知机制，通过queue取到这些reference，来做额外的处理工作。当然，如果我们不需要这种通知机制，在创建Reference对象时不传入queue对象即可。</p>\n<h3 id=\"3-SoftReference简介及使用\"><a href=\"#3-SoftReference简介及使用\" class=\"headerlink\" title=\"3. SoftReference简介及使用\"></a>3. SoftReference简介及使用</h3><p>根据上面我们讲的对象可达性原理，我们把一个对象存在根对象对其有直接或间接的SoftReference，并没有其他强引用路径，我们把该对象成为softly-reachable对象。JVM保证在抛出OutOfMemoryError前会回收这些softly-reachable对象。JVM会根据当前内存的情况来决定是否回收softly-reachable对象，但只要referent有强引用存在，该referent就一定不会被清理，因此SoftReference适合用来实现memory-sensitive caches。</p>\n<p>可见，SoftReference在一定程度上会影响JVM GC的，例如softly-reachable对应的referent多次垃圾回收仍然不满足释放条件，那么它会停留在heap old区，占据很大部分空间，在JVM没有抛出OutOfMemoryError前，它有可能会导致频繁的Full GC。</p>\n<p>下面是我使用SoftReference做的一个简单的缓存图片的测试</p>\n<pre><code class=\"java\">public class SoftReferenceImageTest {\n    public static void main(String[] args) throws IOException {\n        testImageLoad();\n    }\n\n    public static void testImageLoad() throws IOException {\n        String s = &quot;xmind.png&quot;;\n        HashMap&lt;String, SoftReference&lt;byte[]&gt;&gt; map = new HashMap&lt;&gt;(100);\n        for (int i = 0; i &lt; 100; i++) {\n            FileInputStream inputStream = new FileInputStream(s);\n            byte[] bytes = new byte[(int) inputStream.getChannel().size()];\n            while (inputStream.read(bytes) &gt; 0) ;\n            inputStream.close();\n            map.put(s + i, new SoftReference&lt;byte[]&gt;(bytes));\n        }\n        for (int i = 0; i &lt; map.size(); i++) {\n\n            Optional.ofNullable(map.get(s + i))\n                    .filter(softReference -&gt; softReference.get() != null)\n                    .ifPresent(softReference -&gt; {\n                        System.out.println(&quot;ok&quot;);\n                    });\n        }\n\n    }\n}\n</code></pre>\n<p>运行这段代码时，加上jvm参数(<strong>-Xms10M -Xmx10M -Xmn5M -XX:+PrintGCDetails</strong>)</p>\n<p>运行结果为空，因为我加载的图片是5M，而分配给运行时的jvm是10M,所以每次加载完一张图片之后，在下一次加载就会清理这个SoftReference对象，因此最后得到的结果为空。</p>\n<h3 id=\"4-WeakReference简介及使用\"><a href=\"#4-WeakReference简介及使用\" class=\"headerlink\" title=\"4. WeakReference简介及使用\"></a>4. WeakReference简介及使用</h3><p>当一个对象被WeakReference引用时，处于weakly-reachable状态时，只要发生GC时，就会被清除，同时会把WeakReference注册到引用队列中(如果存在的话)。 WeakReference不阻碍或影响它们对应的referent被终结(finalized)和回收(reclaimed)，因此，WeakReference经常被用作实现规范映射(canonicalizing mappings)。相比SoftReference来说，WeakReference对JVM GC几乎是没有影响的。</p>\n<p>下面是一个简单的demo</p>\n<pre><code class=\"java\">public class WeakReferenceTest {\n    public static void main(String[] args) {\n        weak();\n    }\n\n    public static void weak() {\n        ReferenceQueue&lt;Integer&gt; referenceQueue = new ReferenceQueue&lt;&gt;();\n        WeakReference&lt;Integer&gt; weak = new WeakReference&lt;Integer&gt;(new Integer(100), \n                                                                 referenceQueue);\n        System.out.println(&quot;GC 前===&gt;&quot; + weak.get());\n        System.gc();\n        System.out.println(&quot;GC 后===&gt;&quot; + weak.get());\n\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(referenceQueue.poll() == weak);\n    }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code class=\"java\">GC 前===&gt;100\nGC 后===&gt;null\ntrue\n</code></pre>\n<p>结果分析：</p>\n<p>从上面我么可以看到，WeakReference所对应的Referent对象被回收了，因此验证了只要发生gc，weakly-reachable对象就会被gc回收。</p>\n<p>另外可以查看这篇文章，仔细说明jdk中WeakHashMap在Tomact中使用的场景<a href=\"https://blog.csdn.net/kaka0509/article/details/73459419\" target=\"_blank\" rel=\"noopener\">WeakHashMap使用场景</a></p>\n<h3 id=\"5-PhantomReference简介及使用\"><a href=\"#5-PhantomReference简介及使用\" class=\"headerlink\" title=\"5. PhantomReference简介及使用\"></a>5. PhantomReference简介及使用</h3><p> PhantomReference 不同于WeakReference、SoftReference，它存在的意义不是为了获取referent,因为你也永远获取不到，因为它的get如下</p>\n<pre><code class=\"java\"> public T get() {\n        return null;\n }\n</code></pre>\n<p>PhantomReference主要作为其指向的referent被回收时的一种通知机制,它就是利用上文讲到的ReferenceQueue实现的。当referent被gc回收时，JVM自动把PhantomReference对象(reference)本身加入到ReferenceQueue中，像发出信号通知一样，表明该reference指向的referent被回收。然后可以通过去queue中取到reference，此时说明其指向的referent已经被回收，可以通过这个通知机制来做额外的清场工作。 因此有些情况可以用PhantomReference 代替finalize()，做资源释放更明智。</p>\n<p>下面举个例子，用PhantomReference来自动关闭文件流。</p>\n<pre><code class=\"java\">public class ResourcePhantomReference&lt;T&gt; extends PhantomReference&lt;T&gt; {\n\n    private List&lt;Closeable&gt; closeables;\n\n    public ResourcePhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q, List&lt;Closeable&gt; resource) {\n        super(referent, q);\n        closeables = resource;\n    }\n\n    public void cleanUp() {\n        if (closeables == null || closeables.size() == 0)\n            return;\n        for (Closeable closeable : closeables) {\n            try {\n                closeable.close();\n                System.out.println(&quot;clean up:&quot;+closeable);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"java\">public class ResourceCloseDeamon extends Thread {\n\n    private static ReferenceQueue QUEUE = new ReferenceQueue();\n\n    //保持对reference的引用,防止reference本身被回收\n    private static List&lt;Reference&gt; references=new ArrayList&lt;&gt;();\n    @Override\n    public void run() {\n        this.setName(&quot;ResourceCloseDeamon&quot;);\n        while (true) {\n            try {\n                ResourcePhantomReference reference = (ResourcePhantomReference) QUEUE.remove();\n                reference.cleanUp();\n                references.remove(reference);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void register(Object referent, List&lt;Closeable&gt; closeables) {\n        references.add(new ResourcePhantomReference(referent,QUEUE,closeables));\n    }\n\n\n}\n</code></pre>\n<pre><code class=\"java\">public class FileOperation {\n\n    private FileOutputStream outputStream;\n\n    private FileInputStream inputStream;\n\n    public FileOperation(FileInputStream inputStream, FileOutputStream outputStream) {\n        this.outputStream = outputStream;\n        this.inputStream = inputStream;\n    }\n\n    public void operate() {\n        try {\n            inputStream.getChannel().transferTo(0, inputStream.getChannel().size(), outputStream.getChannel());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n}\n</code></pre>\n<p>测试代码：</p>\n<pre><code class=\"java\">public class PhantomTest {\n\n    public static void main(String[] args) throws Exception {\n        //打开回收\n        ResourceCloseDeamon deamon = new ResourceCloseDeamon();\n        deamon.setDaemon(true);\n        deamon.start();\n\n        // touch a.txt b.txt\n        // echo &quot;hello&quot; &gt; a.txt\n\n        //保留对象,防止gc把stream回收掉,其不到演示效果\n        List&lt;Closeable&gt; all=new ArrayList&lt;&gt;();\n        FileInputStream inputStream;\n        FileOutputStream outputStream;\n\n        for (int i = 0; i &lt; 100000; i++) {\n            inputStream = new FileInputStream(&quot;/Users/robin/a.txt&quot;);\n            outputStream = new FileOutputStream(&quot;/Users/robin/b.txt&quot;);\n            FileOperation operation = new FileOperation(inputStream, outputStream);\n            operation.operate();\n            TimeUnit.MILLISECONDS.sleep(100);\n\n            List&lt;Closeable&gt;closeables=new ArrayList&lt;&gt;();\n            closeables.add(inputStream);\n            closeables.add(outputStream);\n            all.addAll(closeables);\n            ResourceCloseDeamon.register(operation,closeables);\n            //用下面命令查看文件句柄,如果把上面register注释掉,就会发现句柄数量不断上升\n            //jps | grep PhantomTest | awk &#39;{print $1}&#39; |head -1 | xargs  lsof -p  | grep /User/robin\n            System.gc();\n\n        }\n\n\n    }\n}\n</code></pre>\n<p>运行上面的代码，通过jps | grep PhantomTest | awk ‘{print $1}’ |head -1 | xargs lsof -p | grep /User/robin ｜ wc -l 可以看到句柄没有上升，而去掉ResourceCloseDeamon.register(operation,closeables);时，句柄就不会被释放。</p>\n<p>PhantomReference使用时一定要传一个referenceQueue,当然也可以传null,但是这样就毫无意义了。因为PhantomReference的get结果为null,如果在把queue设为null,那么在其指向的referent被回收时，reference本身将永远不会可能被加入队列中，这里我们可以看ReferenceQueue的源码。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><h4 id=\"引用类型对比\"><a href=\"#引用类型对比\" class=\"headerlink\" title=\"引用类型对比\"></a>引用类型对比</h4><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>引用类型</th>\n<th>取得目标对象方式</th>\n<th>垃圾回收条件</th>\n<th>是否可能内存泄漏</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>强引用</td>\n<td>直接调用</td>\n<td>不回收</td>\n<td>可能</td>\n</tr>\n<tr>\n<td>2</td>\n<td>软引用</td>\n<td>通过 get()方法</td>\n<td>视内存情况回收</td>\n<td>不可能</td>\n</tr>\n<tr>\n<td>3</td>\n<td>弱引用</td>\n<td>通过 get()方法</td>\n<td>永远回收</td>\n<td>不可能</td>\n</tr>\n<tr>\n<td>4</td>\n<td>虚引用</td>\n<td>无法取得</td>\n<td>不回收</td>\n<td>可能</td>\n</tr>\n</tbody>\n</table>\n<p>通过对SoftReference，WeakReference，PhantomReference 的介绍，可以看出JDK提供这些类型的reference 主要是用来和GC交互的，根据reference的不同，让JVM采用不同策略来进行对对象的回收(reclaim)。softly-reachable的referent在保证在OutOfMemoryError之前回收对象，weakly-reachable的referent在发生GC时就会被回收,同时这些reference和referenceQueue在一起提供通知机制，PhantomReference的作用就是仅仅就是提供对象回收通知机制，Finalizer借助这种机制实现referent的finalize执行，SoftReference、WeakReference也可以配合referenceQueue使用，实现对象回收通知机制。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.jianshu.com/p/147793693edc\" target=\"_blank\" rel=\"noopener\">Java中的四种引用类型</a></p>\n<p><a href=\"https://my.oschina.net/robinyao/blog/829983\" target=\"_blank\" rel=\"noopener\">Java Reference详解</a></p>\n<p><a href=\"http://www.importnew.com/26250.html\" target=\"_blank\" rel=\"noopener\">Reference、ReferenceQueue 详解</a></p>\n<p>[用弱引用堵住内存泄漏](</p>"},{"title":"LockSupport","author":"zhangke","abbrlink":34693,"date":"2018-12-13T07:21:00.000Z","_content":"---\n# LockSupport\n\n### 概述\n\n1. 用法简介\n2. 源码分析\n3. 底层实现原理\n\n### 1. 用法简介\n\nLockSupport是用来创建锁和其他同步类的基本**线程阻塞**原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。\n\npark()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。\n\n如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。\n<!-- more -->\n需要特别注意的一点：**park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法**。从这个意义上说，park 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 unpark 配对使用才更高效。\n\n官方推介的使用方式如下\n\n```java\nwhile(!canprocess()){\n    ....\n    LockSupport.park(this);\n}\n```\n\n\n\n三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。\n看下线程dump的结果来理解blocker的作用。\n\n![线程dump结果对比](https://segmentfault.com/img/bVJuIP?w=783&h=375)\n\n从线程dump结果可以看出：\n有blocker的可以传递给开发人员更多的现场信息，可以查看到当前线程的阻塞对象，方便定位问题。所以java6新增加带blocker入参的系列park方法，替代原有的park方法。\n\n#### demo1\n\n看一个Java docs中的示例用法：一个先进先出非重入锁类的框架\n\n```java\nclass FIFOMutex {\n    private final AtomicBoolean locked = new AtomicBoolean(false);\n    private final Queue<Thread> waiters\n      = new ConcurrentLinkedQueue<Thread>();\n \n    public void lock() {\n      boolean wasInterrupted = false;\n      Thread current = Thread.currentThread();\n      waiters.add(current);\n \n      // Block while not first in queue or cannot acquire lock\n      while (waiters.peek() != current ||\n             !locked.compareAndSet(false, true)) {\n        LockSupport.park(this);\n        if (Thread.interrupted()) // ignore interrupts while waiting\n          wasInterrupted = true;\n      }\n\n      waiters.remove();\n      if (wasInterrupted)          // reassert interrupt status on exit\n        current.interrupt();\n    }\n \n    public void unlock() {\n      locked.set(false);\n      LockSupport.unpark(waiters.peek());\n    }\n  }}\n  \n  //具体使用\n  public class LockSupportDemo {\n    public static void main(String[] args) throws InterruptedException {\n        final FIFOMutex lock = new FIFOMutex();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    private static Runnable generateTask(final FIFOMutex lock, \n    \t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n运行结果\n\n```\nThread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n从结果可以看出，运行结果可以看出，确实是先进先出类型的锁，同时也验证了没有俩个线程同时获取修改list的时机，因为如果同时修改List回抛出异常，这里没有。从侧面验证了锁的正确性\n\n#### demo2 \n\n验证一下，在park之前多次调用unpark，是否会累加\n\n```\npublic class LockSupportStudy2 {\n\n    public static void main(String[] args) {\n        //在park之前不管有多少个unpark，都只能释放一个park\n        LockSupport.unpark(Thread.currentThread());\n        LockSupport.unpark(Thread.currentThread());\n        System.out.println(\"暂停线程\");\n        LockSupport.park();\n        System.out.println(\"线程继续\");\n        LockSupport.park();\n        System.out.println(\"线程继续\");\n    }\n}\n```\n\n运行结果\n\n```\n暂停线程\n线程继续\n。。。。。\n```\n\n从实验结果可以看出，不管在park之前调用了多少次的unpark，只会唤醒一次相应的线程阻塞。\n\n另外这个实验可以看出park和unpark的先后顺序是不重要的，因此park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。\n\n### 2. 源码分析\n\n1. LockSupport中主要的两个成员变量：\n\n```\n\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long parkBlockerOffset;\n```\n\nunsafe:全名sun.misc.Unsafe可以直接操控内存，被JDK广泛用于自己的包中，如java.nio和java.util.concurrent。但是不建议在生产环境中使用这个类。因为这个API十分不安全、不轻便、而且不稳定。\nLockSupport的方法底层都是调用Unsafe的方法实现。\n\n再来看parkBlockerOffset:\nparkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。\n\n```\n static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> tk = Thread.class;\n            parkBlockerOffset = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(\"parkBlocker\"));\n        } catch (Exception ex) { throw new Error(ex); }\n }\n```\n\n从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.\n\nJVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。\n\n为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？\n仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。\n\n2.LockSupport的方法：\n\n```\npublic static  Object getBlocker(Thread t)\npublic static  void park()\npublic static  void park(Object blocker)\npublic static  void parkNanos(long nanos)\npublic static  void parkNanos(Object blocker, long nanos)\npublic static  void parkUntil(long deadline)\npublic static  void parkUntil(Object blocker, long deadline)\n```\n\n\n\n可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。\n\n```\n private static void setBlocker(Thread t, Object arg) {\n        // Even though volatile, hotspot doesn't need a write barrier here.\n        UNSAFE.putObject(t, parkBlockerOffset, arg);\n  }\n```\n\n对给定线程t的parkBlocker赋值。\n\n```\n    public static Object getBlocker(Thread t) {\n        if (t == null)\n            throw new NullPointerException();\n        return UNSAFE.getObjectVolatile(t, parkBlockerOffset);\n    }\n  \n```\n\n从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。\n\n接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法\n\n**阻塞线程**\n\n- park()\n\n```\npublic static void park() {\n        UNSAFE.park(false, 0L);\n}\n```\n\n调用native方法阻塞当前线程。\n\n- parkNanos(long nanos)\n\n```\npublic static void parkNanos(long nanos) {\n        if (nanos > 0)\n            UNSAFE.park(false, nanos);\n}\n```\n\n阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。\n\n- parkUntil(long deadline)\n\n```\npublic static void parkUntil(long deadline) {\n  UNSAFE.park(true, deadline);\n}\n```\n\n阻塞当前线程，知道deadline时间（deadline - 毫秒数）。\n\nJDK1.6引入这三个方法对应的拥有Blocker版本。\n\n- park(Object blocker)\n\n```\npublic static void park(Object blocker) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(false, 0L);\n  setBlocker(t, null);\n}\n```\n\n1) 记录当前线程等待的对象（阻塞对象）；\n2) 阻塞当前线程；\n3) 当前线程等待对象置为null。\n\n- parkNanos(Object blocker, long nanos)\n\n```\npublic static void parkNanos(Object blocker, long nanos) {\n  if (nanos > 0) {\n      Thread t = Thread.currentThread();\n      setBlocker(t, blocker);\n      UNSAFE.park(false, nanos);\n      setBlocker(t, null);\n  }\n}\n```\n\n阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。\n\n- parkUntil(Object blocker, long deadline)\n\n```\npublic static void parkUntil(Object blocker, long deadline) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(true, deadline);\n  setBlocker(t, null);\n}\n```\n\n阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。\n\n**唤醒线程**\n\n- unpark(Thread thread)\n\n```\npublic static void unpark(Thread thread) {\n  if (thread != null)\n      UNSAFE.unpark(thread);\n}\n```\n\n唤醒处于阻塞状态的线程Thread。\n\n### 3. 底层实现原理\n\n从LockSupport源码可以看出，park和unpark的实现都是调用Unsafe.park和Unsafe.unpark，因此只要找到这俩个的底层实现原理，就可以明白park和unpark的底层实现。\n\n#### HotSpot 里 park/unpark 的实现\n\n每个 java 线程都有一个 Parker 实例，Parker 类是这样定义的：\n\n```\nclass Parker : public os::PlatformParker {\nprivate:\n  volatile int _counter ;\n  ...\npublic:\n  void park(bool isAbsolute, jlong time);\n  void unpark();\n  ...\n}\nclass PlatformParker : public CHeapObj<mtInternal> {\n  protected:\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [1] ;\n    ...\n}\n```\n\n可以看到 Parker 类实际上用 Posix 的 mutex，condition 来实现的。\n\n在 Parker 类里的_counter 字段，就是用来记录所谓的 “许可” 的。\n\n当调用 park 时，先尝试直接能否直接拿到 “许可”，即_counter>0 时，如果成功，则把_counter 设置为 0, 并返回：\n\n```\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &_counter) > 0) return;\n```\n\n如果不成功，则构造一个 ThreadBlockInVM，然后检查_counter 是不是 > 0，如果是，则把_counter 设置为 0，unlock mutex 并返回：\n\n```\n  ThreadBlockInVM tbivm(jt);\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n```\n\n否则，再判断等待的时间，然后再调用 pthread_cond_wait 函数等待，如果等待返回，则把_counter 设置为 0，unlock mutex 并返回\n\n```\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  OrderAccess::fence();\n```\n\n当 unpark 时，则简单多了，直接设置_counter 为 1，再 unlock mutext 返回。如果_counter 之前的值是 0，则还要调用 pthread_cond_signal 唤醒在 park 中等待的线程\n\n```\nvoid Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n     if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") ;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n     } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") \n     }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n```\n\n简而言之，是用 mutex 和 condition 保护了一个_counter 的变量，当 park 时，这个变量置为了 0，当 unpark 时，这个变量置为 1。\n\n值得注意的是在 park 函数里，调用 pthread_cond_wait 时，并没有用 while 来判断，所以 posix condition 里的 \"Spurious wakeup\" 一样会传递到上层 Java 的代码里，这也是官方为什么推介使用while方式的原因。\n\n关于 \"Spurious wakeup\"，参考这篇文章：[Why does pthread_cond_wait have spurious wakeups?](https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups)\n\n不过在看这篇文章之前，最好看看《Unix环境高级编程》这本书第11章节\n\n```\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n```\n\n这也就是为什么 Java dos 里提到，当下面三种情况下 park 函数会返回：\n\n- Some other thread invokes unpark with the current thread as the target; or\n- Some other thread interrupts the current thread; or\n- **The call spuriously (that is, for no reason) returns.**\n\n相关的实现代码在：\n\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp\n\n### 参考\n\n1. [浅谈Java并发编程系列（八）—— LockSupport原理剖析](https://segmentfault.com/a/1190000008420938)\n2. [并行编程之条件变量（posix condition variables）](https://blog.csdn.net/hengyunabc/article/details/27969613)\n3. [Java的LockSupport.park()实现分析](https://blog.csdn.net/hengyunabc/article/details/28126139)","source":"_posts/LockSupport.md","raw":"title: LockSupport\ntags:\n  - JUC\ncategories:\n  - java\nauthor: zhangke\nabbrlink: 34693\ndate: 2018-12-13 15:21:00\n---\n---\n# LockSupport\n\n### 概述\n\n1. 用法简介\n2. 源码分析\n3. 底层实现原理\n\n### 1. 用法简介\n\nLockSupport是用来创建锁和其他同步类的基本**线程阻塞**原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。\n\npark()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。\n\n如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。\n<!-- more -->\n需要特别注意的一点：**park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法**。从这个意义上说，park 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 unpark 配对使用才更高效。\n\n官方推介的使用方式如下\n\n```java\nwhile(!canprocess()){\n    ....\n    LockSupport.park(this);\n}\n```\n\n\n\n三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。\n看下线程dump的结果来理解blocker的作用。\n\n![线程dump结果对比](https://segmentfault.com/img/bVJuIP?w=783&h=375)\n\n从线程dump结果可以看出：\n有blocker的可以传递给开发人员更多的现场信息，可以查看到当前线程的阻塞对象，方便定位问题。所以java6新增加带blocker入参的系列park方法，替代原有的park方法。\n\n#### demo1\n\n看一个Java docs中的示例用法：一个先进先出非重入锁类的框架\n\n```java\nclass FIFOMutex {\n    private final AtomicBoolean locked = new AtomicBoolean(false);\n    private final Queue<Thread> waiters\n      = new ConcurrentLinkedQueue<Thread>();\n \n    public void lock() {\n      boolean wasInterrupted = false;\n      Thread current = Thread.currentThread();\n      waiters.add(current);\n \n      // Block while not first in queue or cannot acquire lock\n      while (waiters.peek() != current ||\n             !locked.compareAndSet(false, true)) {\n        LockSupport.park(this);\n        if (Thread.interrupted()) // ignore interrupts while waiting\n          wasInterrupted = true;\n      }\n\n      waiters.remove();\n      if (wasInterrupted)          // reassert interrupt status on exit\n        current.interrupt();\n    }\n \n    public void unlock() {\n      locked.set(false);\n      LockSupport.unpark(waiters.peek());\n    }\n  }}\n  \n  //具体使用\n  public class LockSupportDemo {\n    public static void main(String[] args) throws InterruptedException {\n        final FIFOMutex lock = new FIFOMutex();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    private static Runnable generateTask(final FIFOMutex lock, \n    \t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n运行结果\n\n```\nThread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n从结果可以看出，运行结果可以看出，确实是先进先出类型的锁，同时也验证了没有俩个线程同时获取修改list的时机，因为如果同时修改List回抛出异常，这里没有。从侧面验证了锁的正确性\n\n#### demo2 \n\n验证一下，在park之前多次调用unpark，是否会累加\n\n```\npublic class LockSupportStudy2 {\n\n    public static void main(String[] args) {\n        //在park之前不管有多少个unpark，都只能释放一个park\n        LockSupport.unpark(Thread.currentThread());\n        LockSupport.unpark(Thread.currentThread());\n        System.out.println(\"暂停线程\");\n        LockSupport.park();\n        System.out.println(\"线程继续\");\n        LockSupport.park();\n        System.out.println(\"线程继续\");\n    }\n}\n```\n\n运行结果\n\n```\n暂停线程\n线程继续\n。。。。。\n```\n\n从实验结果可以看出，不管在park之前调用了多少次的unpark，只会唤醒一次相应的线程阻塞。\n\n另外这个实验可以看出park和unpark的先后顺序是不重要的，因此park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。\n\n### 2. 源码分析\n\n1. LockSupport中主要的两个成员变量：\n\n```\n\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long parkBlockerOffset;\n```\n\nunsafe:全名sun.misc.Unsafe可以直接操控内存，被JDK广泛用于自己的包中，如java.nio和java.util.concurrent。但是不建议在生产环境中使用这个类。因为这个API十分不安全、不轻便、而且不稳定。\nLockSupport的方法底层都是调用Unsafe的方法实现。\n\n再来看parkBlockerOffset:\nparkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。\n\n```\n static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> tk = Thread.class;\n            parkBlockerOffset = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(\"parkBlocker\"));\n        } catch (Exception ex) { throw new Error(ex); }\n }\n```\n\n从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.\n\nJVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。\n\n为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？\n仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。\n\n2.LockSupport的方法：\n\n```\npublic static  Object getBlocker(Thread t)\npublic static  void park()\npublic static  void park(Object blocker)\npublic static  void parkNanos(long nanos)\npublic static  void parkNanos(Object blocker, long nanos)\npublic static  void parkUntil(long deadline)\npublic static  void parkUntil(Object blocker, long deadline)\n```\n\n\n\n可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。\n\n```\n private static void setBlocker(Thread t, Object arg) {\n        // Even though volatile, hotspot doesn't need a write barrier here.\n        UNSAFE.putObject(t, parkBlockerOffset, arg);\n  }\n```\n\n对给定线程t的parkBlocker赋值。\n\n```\n    public static Object getBlocker(Thread t) {\n        if (t == null)\n            throw new NullPointerException();\n        return UNSAFE.getObjectVolatile(t, parkBlockerOffset);\n    }\n  \n```\n\n从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。\n\n接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法\n\n**阻塞线程**\n\n- park()\n\n```\npublic static void park() {\n        UNSAFE.park(false, 0L);\n}\n```\n\n调用native方法阻塞当前线程。\n\n- parkNanos(long nanos)\n\n```\npublic static void parkNanos(long nanos) {\n        if (nanos > 0)\n            UNSAFE.park(false, nanos);\n}\n```\n\n阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。\n\n- parkUntil(long deadline)\n\n```\npublic static void parkUntil(long deadline) {\n  UNSAFE.park(true, deadline);\n}\n```\n\n阻塞当前线程，知道deadline时间（deadline - 毫秒数）。\n\nJDK1.6引入这三个方法对应的拥有Blocker版本。\n\n- park(Object blocker)\n\n```\npublic static void park(Object blocker) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(false, 0L);\n  setBlocker(t, null);\n}\n```\n\n1) 记录当前线程等待的对象（阻塞对象）；\n2) 阻塞当前线程；\n3) 当前线程等待对象置为null。\n\n- parkNanos(Object blocker, long nanos)\n\n```\npublic static void parkNanos(Object blocker, long nanos) {\n  if (nanos > 0) {\n      Thread t = Thread.currentThread();\n      setBlocker(t, blocker);\n      UNSAFE.park(false, nanos);\n      setBlocker(t, null);\n  }\n}\n```\n\n阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。\n\n- parkUntil(Object blocker, long deadline)\n\n```\npublic static void parkUntil(Object blocker, long deadline) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(true, deadline);\n  setBlocker(t, null);\n}\n```\n\n阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。\n\n**唤醒线程**\n\n- unpark(Thread thread)\n\n```\npublic static void unpark(Thread thread) {\n  if (thread != null)\n      UNSAFE.unpark(thread);\n}\n```\n\n唤醒处于阻塞状态的线程Thread。\n\n### 3. 底层实现原理\n\n从LockSupport源码可以看出，park和unpark的实现都是调用Unsafe.park和Unsafe.unpark，因此只要找到这俩个的底层实现原理，就可以明白park和unpark的底层实现。\n\n#### HotSpot 里 park/unpark 的实现\n\n每个 java 线程都有一个 Parker 实例，Parker 类是这样定义的：\n\n```\nclass Parker : public os::PlatformParker {\nprivate:\n  volatile int _counter ;\n  ...\npublic:\n  void park(bool isAbsolute, jlong time);\n  void unpark();\n  ...\n}\nclass PlatformParker : public CHeapObj<mtInternal> {\n  protected:\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [1] ;\n    ...\n}\n```\n\n可以看到 Parker 类实际上用 Posix 的 mutex，condition 来实现的。\n\n在 Parker 类里的_counter 字段，就是用来记录所谓的 “许可” 的。\n\n当调用 park 时，先尝试直接能否直接拿到 “许可”，即_counter>0 时，如果成功，则把_counter 设置为 0, 并返回：\n\n```\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &_counter) > 0) return;\n```\n\n如果不成功，则构造一个 ThreadBlockInVM，然后检查_counter 是不是 > 0，如果是，则把_counter 设置为 0，unlock mutex 并返回：\n\n```\n  ThreadBlockInVM tbivm(jt);\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n```\n\n否则，再判断等待的时间，然后再调用 pthread_cond_wait 函数等待，如果等待返回，则把_counter 设置为 0，unlock mutex 并返回\n\n```\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  OrderAccess::fence();\n```\n\n当 unpark 时，则简单多了，直接设置_counter 为 1，再 unlock mutext 返回。如果_counter 之前的值是 0，则还要调用 pthread_cond_signal 唤醒在 park 中等待的线程\n\n```\nvoid Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n     if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") ;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n     } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") \n     }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n```\n\n简而言之，是用 mutex 和 condition 保护了一个_counter 的变量，当 park 时，这个变量置为了 0，当 unpark 时，这个变量置为 1。\n\n值得注意的是在 park 函数里，调用 pthread_cond_wait 时，并没有用 while 来判断，所以 posix condition 里的 \"Spurious wakeup\" 一样会传递到上层 Java 的代码里，这也是官方为什么推介使用while方式的原因。\n\n关于 \"Spurious wakeup\"，参考这篇文章：[Why does pthread_cond_wait have spurious wakeups?](https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups)\n\n不过在看这篇文章之前，最好看看《Unix环境高级编程》这本书第11章节\n\n```\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n```\n\n这也就是为什么 Java dos 里提到，当下面三种情况下 park 函数会返回：\n\n- Some other thread invokes unpark with the current thread as the target; or\n- Some other thread interrupts the current thread; or\n- **The call spuriously (that is, for no reason) returns.**\n\n相关的实现代码在：\n\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp\n\n### 参考\n\n1. [浅谈Java并发编程系列（八）—— LockSupport原理剖析](https://segmentfault.com/a/1190000008420938)\n2. [并行编程之条件变量（posix condition variables）](https://blog.csdn.net/hengyunabc/article/details/27969613)\n3. [Java的LockSupport.park()实现分析](https://blog.csdn.net/hengyunabc/article/details/28126139)","slug":"LockSupport","published":1,"updated":"2019-01-04T01:48:59.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovp6000m9q1ulocdchqo","content":"<hr>\n<h1 id=\"LockSupport\"><a href=\"#LockSupport\" class=\"headerlink\" title=\"LockSupport\"></a>LockSupport</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>用法简介</li>\n<li>源码分析</li>\n<li>底层实现原理</li>\n</ol>\n<h3 id=\"1-用法简介\"><a href=\"#1-用法简介\" class=\"headerlink\" title=\"1. 用法简介\"></a>1. 用法简介</h3><p>LockSupport是用来创建锁和其他同步类的基本<strong>线程阻塞</strong>原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。</p>\n<p>park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p>\n<p>如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。<br><a id=\"more\"></a><br>需要特别注意的一点：<strong>park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法</strong>。从这个意义上说，park 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 unpark 配对使用才更高效。</p>\n<p>官方推介的使用方式如下</p>\n<pre><code class=\"java\">while(!canprocess()){\n    ....\n    LockSupport.park(this);\n}\n</code></pre>\n<p>三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。<br>看下线程dump的结果来理解blocker的作用。</p>\n<p><img src=\"https://segmentfault.com/img/bVJuIP?w=783&amp;h=375\" alt=\"线程dump结果对比\"></p>\n<p>从线程dump结果可以看出：<br>有blocker的可以传递给开发人员更多的现场信息，可以查看到当前线程的阻塞对象，方便定位问题。所以java6新增加带blocker入参的系列park方法，替代原有的park方法。</p>\n<h4 id=\"demo1\"><a href=\"#demo1\" class=\"headerlink\" title=\"demo1\"></a>demo1</h4><p>看一个Java docs中的示例用法：一个先进先出非重入锁类的框架</p>\n<pre><code class=\"java\">class FIFOMutex {\n    private final AtomicBoolean locked = new AtomicBoolean(false);\n    private final Queue&lt;Thread&gt; waiters\n      = new ConcurrentLinkedQueue&lt;Thread&gt;();\n\n    public void lock() {\n      boolean wasInterrupted = false;\n      Thread current = Thread.currentThread();\n      waiters.add(current);\n\n      // Block while not first in queue or cannot acquire lock\n      while (waiters.peek() != current ||\n             !locked.compareAndSet(false, true)) {\n        LockSupport.park(this);\n        if (Thread.interrupted()) // ignore interrupts while waiting\n          wasInterrupted = true;\n      }\n\n      waiters.remove();\n      if (wasInterrupted)          // reassert interrupt status on exit\n        current.interrupt();\n    }\n\n    public void unlock() {\n      locked.set(false);\n      LockSupport.unpark(waiters.peek());\n    }\n  }}\n\n  //具体使用\n  public class LockSupportDemo {\n    public static void main(String[] args) throws InterruptedException {\n        final FIFOMutex lock = new FIFOMutex();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    private static Runnable generateTask(final FIFOMutex lock, \n                    final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>Thread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre><p>从结果可以看出，运行结果可以看出，确实是先进先出类型的锁，同时也验证了没有俩个线程同时获取修改list的时机，因为如果同时修改List回抛出异常，这里没有。从侧面验证了锁的正确性</p>\n<h4 id=\"demo2\"><a href=\"#demo2\" class=\"headerlink\" title=\"demo2\"></a>demo2</h4><p>验证一下，在park之前多次调用unpark，是否会累加</p>\n<pre><code>public class LockSupportStudy2 {\n\n    public static void main(String[] args) {\n        //在park之前不管有多少个unpark，都只能释放一个park\n        LockSupport.unpark(Thread.currentThread());\n        LockSupport.unpark(Thread.currentThread());\n        System.out.println(&quot;暂停线程&quot;);\n        LockSupport.park();\n        System.out.println(&quot;线程继续&quot;);\n        LockSupport.park();\n        System.out.println(&quot;线程继续&quot;);\n    }\n}\n</code></pre><p>运行结果</p>\n<pre><code>暂停线程\n线程继续\n。。。。。\n</code></pre><p>从实验结果可以看出，不管在park之前调用了多少次的unpark，只会唤醒一次相应的线程阻塞。</p>\n<p>另外这个实验可以看出park和unpark的先后顺序是不重要的，因此park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p>\n<h3 id=\"2-源码分析\"><a href=\"#2-源码分析\" class=\"headerlink\" title=\"2. 源码分析\"></a>2. 源码分析</h3><ol>\n<li>LockSupport中主要的两个成员变量：</li>\n</ol>\n<pre><code>\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long parkBlockerOffset;\n</code></pre><p>unsafe:全名sun.misc.Unsafe可以直接操控内存，被JDK广泛用于自己的包中，如java.nio和java.util.concurrent。但是不建议在生产环境中使用这个类。因为这个API十分不安全、不轻便、而且不稳定。<br>LockSupport的方法底层都是调用Unsafe的方法实现。</p>\n<p>再来看parkBlockerOffset:<br>parkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。</p>\n<pre><code> static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class&lt;?&gt; tk = Thread.class;\n            parkBlockerOffset = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(&quot;parkBlocker&quot;));\n        } catch (Exception ex) { throw new Error(ex); }\n }\n</code></pre><p>从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.</p>\n<p>JVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。</p>\n<p>为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？<br>仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。</p>\n<p>2.LockSupport的方法：</p>\n<pre><code>public static  Object getBlocker(Thread t)\npublic static  void park()\npublic static  void park(Object blocker)\npublic static  void parkNanos(long nanos)\npublic static  void parkNanos(Object blocker, long nanos)\npublic static  void parkUntil(long deadline)\npublic static  void parkUntil(Object blocker, long deadline)\n</code></pre><p>可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。</p>\n<pre><code> private static void setBlocker(Thread t, Object arg) {\n        // Even though volatile, hotspot doesn&#39;t need a write barrier here.\n        UNSAFE.putObject(t, parkBlockerOffset, arg);\n  }\n</code></pre><p>对给定线程t的parkBlocker赋值。</p>\n<pre><code>    public static Object getBlocker(Thread t) {\n        if (t == null)\n            throw new NullPointerException();\n        return UNSAFE.getObjectVolatile(t, parkBlockerOffset);\n    }\n\n</code></pre><p>从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。</p>\n<p>接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法</p>\n<p><strong>阻塞线程</strong></p>\n<ul>\n<li>park()</li>\n</ul>\n<pre><code>public static void park() {\n        UNSAFE.park(false, 0L);\n}\n</code></pre><p>调用native方法阻塞当前线程。</p>\n<ul>\n<li>parkNanos(long nanos)</li>\n</ul>\n<pre><code>public static void parkNanos(long nanos) {\n        if (nanos &gt; 0)\n            UNSAFE.park(false, nanos);\n}\n</code></pre><p>阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。</p>\n<ul>\n<li>parkUntil(long deadline)</li>\n</ul>\n<pre><code>public static void parkUntil(long deadline) {\n  UNSAFE.park(true, deadline);\n}\n</code></pre><p>阻塞当前线程，知道deadline时间（deadline - 毫秒数）。</p>\n<p>JDK1.6引入这三个方法对应的拥有Blocker版本。</p>\n<ul>\n<li>park(Object blocker)</li>\n</ul>\n<pre><code>public static void park(Object blocker) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(false, 0L);\n  setBlocker(t, null);\n}\n</code></pre><p>1) 记录当前线程等待的对象（阻塞对象）；<br>2) 阻塞当前线程；<br>3) 当前线程等待对象置为null。</p>\n<ul>\n<li>parkNanos(Object blocker, long nanos)</li>\n</ul>\n<pre><code>public static void parkNanos(Object blocker, long nanos) {\n  if (nanos &gt; 0) {\n      Thread t = Thread.currentThread();\n      setBlocker(t, blocker);\n      UNSAFE.park(false, nanos);\n      setBlocker(t, null);\n  }\n}\n</code></pre><p>阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。</p>\n<ul>\n<li>parkUntil(Object blocker, long deadline)</li>\n</ul>\n<pre><code>public static void parkUntil(Object blocker, long deadline) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(true, deadline);\n  setBlocker(t, null);\n}\n</code></pre><p>阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。</p>\n<p><strong>唤醒线程</strong></p>\n<ul>\n<li>unpark(Thread thread)</li>\n</ul>\n<pre><code>public static void unpark(Thread thread) {\n  if (thread != null)\n      UNSAFE.unpark(thread);\n}\n</code></pre><p>唤醒处于阻塞状态的线程Thread。</p>\n<h3 id=\"3-底层实现原理\"><a href=\"#3-底层实现原理\" class=\"headerlink\" title=\"3. 底层实现原理\"></a>3. 底层实现原理</h3><p>从LockSupport源码可以看出，park和unpark的实现都是调用Unsafe.park和Unsafe.unpark，因此只要找到这俩个的底层实现原理，就可以明白park和unpark的底层实现。</p>\n<h4 id=\"HotSpot-里-park-unpark-的实现\"><a href=\"#HotSpot-里-park-unpark-的实现\" class=\"headerlink\" title=\"HotSpot 里 park/unpark 的实现\"></a>HotSpot 里 park/unpark 的实现</h4><p>每个 java 线程都有一个 Parker 实例，Parker 类是这样定义的：</p>\n<pre><code>class Parker : public os::PlatformParker {\nprivate:\n  volatile int _counter ;\n  ...\npublic:\n  void park(bool isAbsolute, jlong time);\n  void unpark();\n  ...\n}\nclass PlatformParker : public CHeapObj&lt;mtInternal&gt; {\n  protected:\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [1] ;\n    ...\n}\n</code></pre><p>可以看到 Parker 类实际上用 Posix 的 mutex，condition 来实现的。</p>\n<p>在 Parker 类里的_counter 字段，就是用来记录所谓的 “许可” 的。</p>\n<p>当调用 park 时，先尝试直接能否直接拿到 “许可”，即_counter&gt;0 时，如果成功，则把_counter 设置为 0, 并返回：</p>\n<pre><code>void Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we&#39;d do something useful while spinning, such\n  // as calling unpackTime().\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;\n</code></pre><p>如果不成功，则构造一个 ThreadBlockInVM，然后检查_counter 是不是 &gt; 0，如果是，则把_counter 设置为 0，unlock mutex 并返回：</p>\n<pre><code>  ThreadBlockInVM tbivm(jt);\n  if (_counter &gt; 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n</code></pre><p>否则，再判断等待的时间，然后再调用 pthread_cond_wait 函数等待，如果等待返回，则把_counter 设置为 0，unlock mutex 并返回</p>\n<pre><code>  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, &quot;invariant&quot;) ;\n  OrderAccess::fence();\n</code></pre><p>当 unpark 时，则简单多了，直接设置_counter 为 1，再 unlock mutext 返回。如果_counter 之前的值是 0，则还要调用 pthread_cond_signal 唤醒在 park 中等待的线程</p>\n<pre><code>void Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, &quot;invariant&quot;) ;\n  s = _counter;\n  _counter = 1;\n  if (s &lt; 1) {\n     if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, &quot;invariant&quot;) ;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, &quot;invariant&quot;) ;\n     } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, &quot;invariant&quot;) ;\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, &quot;invariant&quot;) \n     }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, &quot;invariant&quot;) ;\n  }\n}\n</code></pre><p>简而言之，是用 mutex 和 condition 保护了一个_counter 的变量，当 park 时，这个变量置为了 0，当 unpark 时，这个变量置为 1。</p>\n<p>值得注意的是在 park 函数里，调用 pthread_cond_wait 时，并没有用 while 来判断，所以 posix condition 里的 “Spurious wakeup” 一样会传递到上层 Java 的代码里，这也是官方为什么推介使用while方式的原因。</p>\n<p>关于 “Spurious wakeup”，参考这篇文章：<a href=\"https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups\" target=\"_blank\" rel=\"noopener\">Why does pthread_cond_wait have spurious wakeups?</a></p>\n<p>不过在看这篇文章之前，最好看看《Unix环境高级编程》这本书第11章节</p>\n<pre><code>  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n</code></pre><p>这也就是为什么 Java dos 里提到，当下面三种情况下 park 函数会返回：</p>\n<ul>\n<li>Some other thread invokes unpark with the current thread as the target; or</li>\n<li>Some other thread interrupts the current thread; or</li>\n<li><strong>The call spuriously (that is, for no reason) returns.</strong></li>\n</ul>\n<p>相关的实现代码在：</p>\n<p><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp</a></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000008420938\" target=\"_blank\" rel=\"noopener\">浅谈Java并发编程系列（八）—— LockSupport原理剖析</a></li>\n<li><a href=\"https://blog.csdn.net/hengyunabc/article/details/27969613\" target=\"_blank\" rel=\"noopener\">并行编程之条件变量（posix condition variables）</a></li>\n<li><a href=\"https://blog.csdn.net/hengyunabc/article/details/28126139\" target=\"_blank\" rel=\"noopener\">Java的LockSupport.park()实现分析</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<hr>\n<h1 id=\"LockSupport\"><a href=\"#LockSupport\" class=\"headerlink\" title=\"LockSupport\"></a>LockSupport</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>用法简介</li>\n<li>源码分析</li>\n<li>底层实现原理</li>\n</ol>\n<h3 id=\"1-用法简介\"><a href=\"#1-用法简介\" class=\"headerlink\" title=\"1. 用法简介\"></a>1. 用法简介</h3><p>LockSupport是用来创建锁和其他同步类的基本<strong>线程阻塞</strong>原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。</p>\n<p>park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p>\n<p>如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。<br>","more":"<br>需要特别注意的一点：<strong>park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法</strong>。从这个意义上说，park 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 unpark 配对使用才更高效。</p>\n<p>官方推介的使用方式如下</p>\n<pre><code class=\"java\">while(!canprocess()){\n    ....\n    LockSupport.park(this);\n}\n</code></pre>\n<p>三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。<br>看下线程dump的结果来理解blocker的作用。</p>\n<p><img src=\"https://segmentfault.com/img/bVJuIP?w=783&amp;h=375\" alt=\"线程dump结果对比\"></p>\n<p>从线程dump结果可以看出：<br>有blocker的可以传递给开发人员更多的现场信息，可以查看到当前线程的阻塞对象，方便定位问题。所以java6新增加带blocker入参的系列park方法，替代原有的park方法。</p>\n<h4 id=\"demo1\"><a href=\"#demo1\" class=\"headerlink\" title=\"demo1\"></a>demo1</h4><p>看一个Java docs中的示例用法：一个先进先出非重入锁类的框架</p>\n<pre><code class=\"java\">class FIFOMutex {\n    private final AtomicBoolean locked = new AtomicBoolean(false);\n    private final Queue&lt;Thread&gt; waiters\n      = new ConcurrentLinkedQueue&lt;Thread&gt;();\n\n    public void lock() {\n      boolean wasInterrupted = false;\n      Thread current = Thread.currentThread();\n      waiters.add(current);\n\n      // Block while not first in queue or cannot acquire lock\n      while (waiters.peek() != current ||\n             !locked.compareAndSet(false, true)) {\n        LockSupport.park(this);\n        if (Thread.interrupted()) // ignore interrupts while waiting\n          wasInterrupted = true;\n      }\n\n      waiters.remove();\n      if (wasInterrupted)          // reassert interrupt status on exit\n        current.interrupt();\n    }\n\n    public void unlock() {\n      locked.set(false);\n      LockSupport.unpark(waiters.peek());\n    }\n  }}\n\n  //具体使用\n  public class LockSupportDemo {\n    public static void main(String[] args) throws InterruptedException {\n        final FIFOMutex lock = new FIFOMutex();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    private static Runnable generateTask(final FIFOMutex lock, \n                    final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>Thread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre><p>从结果可以看出，运行结果可以看出，确实是先进先出类型的锁，同时也验证了没有俩个线程同时获取修改list的时机，因为如果同时修改List回抛出异常，这里没有。从侧面验证了锁的正确性</p>\n<h4 id=\"demo2\"><a href=\"#demo2\" class=\"headerlink\" title=\"demo2\"></a>demo2</h4><p>验证一下，在park之前多次调用unpark，是否会累加</p>\n<pre><code>public class LockSupportStudy2 {\n\n    public static void main(String[] args) {\n        //在park之前不管有多少个unpark，都只能释放一个park\n        LockSupport.unpark(Thread.currentThread());\n        LockSupport.unpark(Thread.currentThread());\n        System.out.println(&quot;暂停线程&quot;);\n        LockSupport.park();\n        System.out.println(&quot;线程继续&quot;);\n        LockSupport.park();\n        System.out.println(&quot;线程继续&quot;);\n    }\n}\n</code></pre><p>运行结果</p>\n<pre><code>暂停线程\n线程继续\n。。。。。\n</code></pre><p>从实验结果可以看出，不管在park之前调用了多少次的unpark，只会唤醒一次相应的线程阻塞。</p>\n<p>另外这个实验可以看出park和unpark的先后顺序是不重要的，因此park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p>\n<h3 id=\"2-源码分析\"><a href=\"#2-源码分析\" class=\"headerlink\" title=\"2. 源码分析\"></a>2. 源码分析</h3><ol>\n<li>LockSupport中主要的两个成员变量：</li>\n</ol>\n<pre><code>\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long parkBlockerOffset;\n</code></pre><p>unsafe:全名sun.misc.Unsafe可以直接操控内存，被JDK广泛用于自己的包中，如java.nio和java.util.concurrent。但是不建议在生产环境中使用这个类。因为这个API十分不安全、不轻便、而且不稳定。<br>LockSupport的方法底层都是调用Unsafe的方法实现。</p>\n<p>再来看parkBlockerOffset:<br>parkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。</p>\n<pre><code> static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class&lt;?&gt; tk = Thread.class;\n            parkBlockerOffset = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(&quot;parkBlocker&quot;));\n        } catch (Exception ex) { throw new Error(ex); }\n }\n</code></pre><p>从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.</p>\n<p>JVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。</p>\n<p>为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？<br>仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。</p>\n<p>2.LockSupport的方法：</p>\n<pre><code>public static  Object getBlocker(Thread t)\npublic static  void park()\npublic static  void park(Object blocker)\npublic static  void parkNanos(long nanos)\npublic static  void parkNanos(Object blocker, long nanos)\npublic static  void parkUntil(long deadline)\npublic static  void parkUntil(Object blocker, long deadline)\n</code></pre><p>可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。</p>\n<pre><code> private static void setBlocker(Thread t, Object arg) {\n        // Even though volatile, hotspot doesn&#39;t need a write barrier here.\n        UNSAFE.putObject(t, parkBlockerOffset, arg);\n  }\n</code></pre><p>对给定线程t的parkBlocker赋值。</p>\n<pre><code>    public static Object getBlocker(Thread t) {\n        if (t == null)\n            throw new NullPointerException();\n        return UNSAFE.getObjectVolatile(t, parkBlockerOffset);\n    }\n\n</code></pre><p>从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。</p>\n<p>接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法</p>\n<p><strong>阻塞线程</strong></p>\n<ul>\n<li>park()</li>\n</ul>\n<pre><code>public static void park() {\n        UNSAFE.park(false, 0L);\n}\n</code></pre><p>调用native方法阻塞当前线程。</p>\n<ul>\n<li>parkNanos(long nanos)</li>\n</ul>\n<pre><code>public static void parkNanos(long nanos) {\n        if (nanos &gt; 0)\n            UNSAFE.park(false, nanos);\n}\n</code></pre><p>阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。</p>\n<ul>\n<li>parkUntil(long deadline)</li>\n</ul>\n<pre><code>public static void parkUntil(long deadline) {\n  UNSAFE.park(true, deadline);\n}\n</code></pre><p>阻塞当前线程，知道deadline时间（deadline - 毫秒数）。</p>\n<p>JDK1.6引入这三个方法对应的拥有Blocker版本。</p>\n<ul>\n<li>park(Object blocker)</li>\n</ul>\n<pre><code>public static void park(Object blocker) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(false, 0L);\n  setBlocker(t, null);\n}\n</code></pre><p>1) 记录当前线程等待的对象（阻塞对象）；<br>2) 阻塞当前线程；<br>3) 当前线程等待对象置为null。</p>\n<ul>\n<li>parkNanos(Object blocker, long nanos)</li>\n</ul>\n<pre><code>public static void parkNanos(Object blocker, long nanos) {\n  if (nanos &gt; 0) {\n      Thread t = Thread.currentThread();\n      setBlocker(t, blocker);\n      UNSAFE.park(false, nanos);\n      setBlocker(t, null);\n  }\n}\n</code></pre><p>阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。</p>\n<ul>\n<li>parkUntil(Object blocker, long deadline)</li>\n</ul>\n<pre><code>public static void parkUntil(Object blocker, long deadline) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(true, deadline);\n  setBlocker(t, null);\n}\n</code></pre><p>阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。</p>\n<p><strong>唤醒线程</strong></p>\n<ul>\n<li>unpark(Thread thread)</li>\n</ul>\n<pre><code>public static void unpark(Thread thread) {\n  if (thread != null)\n      UNSAFE.unpark(thread);\n}\n</code></pre><p>唤醒处于阻塞状态的线程Thread。</p>\n<h3 id=\"3-底层实现原理\"><a href=\"#3-底层实现原理\" class=\"headerlink\" title=\"3. 底层实现原理\"></a>3. 底层实现原理</h3><p>从LockSupport源码可以看出，park和unpark的实现都是调用Unsafe.park和Unsafe.unpark，因此只要找到这俩个的底层实现原理，就可以明白park和unpark的底层实现。</p>\n<h4 id=\"HotSpot-里-park-unpark-的实现\"><a href=\"#HotSpot-里-park-unpark-的实现\" class=\"headerlink\" title=\"HotSpot 里 park/unpark 的实现\"></a>HotSpot 里 park/unpark 的实现</h4><p>每个 java 线程都有一个 Parker 实例，Parker 类是这样定义的：</p>\n<pre><code>class Parker : public os::PlatformParker {\nprivate:\n  volatile int _counter ;\n  ...\npublic:\n  void park(bool isAbsolute, jlong time);\n  void unpark();\n  ...\n}\nclass PlatformParker : public CHeapObj&lt;mtInternal&gt; {\n  protected:\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [1] ;\n    ...\n}\n</code></pre><p>可以看到 Parker 类实际上用 Posix 的 mutex，condition 来实现的。</p>\n<p>在 Parker 类里的_counter 字段，就是用来记录所谓的 “许可” 的。</p>\n<p>当调用 park 时，先尝试直接能否直接拿到 “许可”，即_counter&gt;0 时，如果成功，则把_counter 设置为 0, 并返回：</p>\n<pre><code>void Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we&#39;d do something useful while spinning, such\n  // as calling unpackTime().\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;\n</code></pre><p>如果不成功，则构造一个 ThreadBlockInVM，然后检查_counter 是不是 &gt; 0，如果是，则把_counter 设置为 0，unlock mutex 并返回：</p>\n<pre><code>  ThreadBlockInVM tbivm(jt);\n  if (_counter &gt; 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n</code></pre><p>否则，再判断等待的时间，然后再调用 pthread_cond_wait 函数等待，如果等待返回，则把_counter 设置为 0，unlock mutex 并返回</p>\n<pre><code>  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, &quot;invariant&quot;) ;\n  OrderAccess::fence();\n</code></pre><p>当 unpark 时，则简单多了，直接设置_counter 为 1，再 unlock mutext 返回。如果_counter 之前的值是 0，则还要调用 pthread_cond_signal 唤醒在 park 中等待的线程</p>\n<pre><code>void Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, &quot;invariant&quot;) ;\n  s = _counter;\n  _counter = 1;\n  if (s &lt; 1) {\n     if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, &quot;invariant&quot;) ;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, &quot;invariant&quot;) ;\n     } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, &quot;invariant&quot;) ;\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, &quot;invariant&quot;) \n     }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, &quot;invariant&quot;) ;\n  }\n}\n</code></pre><p>简而言之，是用 mutex 和 condition 保护了一个_counter 的变量，当 park 时，这个变量置为了 0，当 unpark 时，这个变量置为 1。</p>\n<p>值得注意的是在 park 函数里，调用 pthread_cond_wait 时，并没有用 while 来判断，所以 posix condition 里的 “Spurious wakeup” 一样会传递到上层 Java 的代码里，这也是官方为什么推介使用while方式的原因。</p>\n<p>关于 “Spurious wakeup”，参考这篇文章：<a href=\"https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups\" target=\"_blank\" rel=\"noopener\">Why does pthread_cond_wait have spurious wakeups?</a></p>\n<p>不过在看这篇文章之前，最好看看《Unix环境高级编程》这本书第11章节</p>\n<pre><code>  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n</code></pre><p>这也就是为什么 Java dos 里提到，当下面三种情况下 park 函数会返回：</p>\n<ul>\n<li>Some other thread invokes unpark with the current thread as the target; or</li>\n<li>Some other thread interrupts the current thread; or</li>\n<li><strong>The call spuriously (that is, for no reason) returns.</strong></li>\n</ul>\n<p>相关的实现代码在：</p>\n<p><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp</a></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000008420938\" target=\"_blank\" rel=\"noopener\">浅谈Java并发编程系列（八）—— LockSupport原理剖析</a></li>\n<li><a href=\"https://blog.csdn.net/hengyunabc/article/details/27969613\" target=\"_blank\" rel=\"noopener\">并行编程之条件变量（posix condition variables）</a></li>\n<li><a href=\"https://blog.csdn.net/hengyunabc/article/details/28126139\" target=\"_blank\" rel=\"noopener\">Java的LockSupport.park()实现分析</a></li>\n</ol>"},{"title":"String、StringBuffer和StringBuilder对比","author":"zhangke","abbrlink":10143,"date":"2019-01-02T05:24:00.000Z","_content":"---\n# String、StringBuffer和StringBuilder对比\n\n### 概述\n\n1. 简单介绍\n2. 性能对比\n3. 字符串常量池\n<!-- more -->\n\n### 1. 简单介绍\n\n这里只对这三个类做个简单的总结，如果你希望详细了解这三个类，可以看一下三篇文章，我觉得写得很好。\n\n1.  [String 详解(String系列之1)](https://www.cnblogs.com/skywang12345/p/string01.html)\n2.  [StringBuilder 详解 (String系列之2)](http://www.cnblogs.com/skywang12345/p/string02.html)\n3.  [StringBuffer 详解 (String系列之3)](http://www.cnblogs.com/skywang12345/p/string03.html)\n\n首先一个简单的对比\n\n**String 字符串常量**\n\n**StringBuffer 字符串变量（线程安全）**\n\n**StringBuilder 字符串变量（非线程安全）**\n\nStringBuffer与StringBuilder的实现几乎是一样的，只是StringBufferr为了保证线程安全，在方法前面加上Synchronize关键字来保证安全性，因此下面先用StringBuffer来和String进行对比\n\nString 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。\n 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：\n\n```java\n String S1 = “This is only a” + “ simple” + “ test”;\n StringBuffer Sb = new StringBuffer(“This is only a”).append(“ simple”).append(“ test”);\n```\n\n测试结果：\n\n```\n\nBenchmark                         Mode  Cnt   Score    Error  Units\nStringBenchmark.testString        avgt    3   5.701 ±  2.431  ns/op\nStringBenchmark.testStringBuffer  avgt    3  27.077 ± 21.828  ns/op\n```\n\n**其中score对应是每次操作花费的纳秒说**\n\n 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个\n**String S1 = “This is only a” + “ simple” + “test”; **其实就是：\n** String S1 = “This is only a simple test”**; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：\n\n```\nString S2 = “This is only a”;\nString S3 = “ simple”;\nString S4 = “ test”;\nString S1 = S2 +S3 + S4;\n```\n\n这时候 JVM 会规规矩矩的按照原来的方式去做\n在大部分情况下 StringBuffer的性能要好于 String\n**StringBuffer**\nJava.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。\n例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(\"le\") 会使字符串缓冲区包含“startle”，而 z.insert(4, \"le\") 将更改字符串缓冲区，使之包含“starlet”。\n在大部分情况下 StringBuilder > StringBuffer\n\n**StringBuilder**\njava.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。\n\n### 2. 性能对比\n\n测试性能源码(使用了JMH来进行基准测试)\n\n```\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 3)\n@Measurement(iterations = 3, time = 3)\n@Threads(1)\n@Fork(1)\n@State(Scope.Thread)\npublic class StringBenchmark {\n\n    String s1;\n\n    StringBuffer stringBuffer;\n\n    StringBuilder stringBuilder;\n\n\n    @Setup(Level.Iteration)\n    public void before() {\n        s1 = \"s1\";\n        stringBuffer = new StringBuffer(\"s1\");\n        stringBuilder = new StringBuilder(\"s1\");\n\n    }\n\n\n    @TearDown\n    public void after() {\n\n    }\n\n\n    @Benchmark\n    public String testStringAppend() {\n\n        return s1 += \"s2\";\n    }\n\n\n    @Benchmark\n    public StringBuffer testStringBufferAppend() {\n\n        return stringBuffer.append(\"s2\");\n\n    }\n\n\n    @Benchmark\n    public StringBuilder testStringBuilderAppend() {\n        //下面这个还会单独生成一个String对象，因此性能上有所损失，所以调整一下\n//        return new StringBuilder(\"s1\").append(\"s2\").toString();\n\n        return stringBuilder.append(\"s2\");\n    }\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(StringBenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n```\n\n测试结果\n\n```\nBenchmark                                Mode  Cnt      Score       Error  Units\nStringBenchmark.testStringAppend         avgt    3  28179.211 ± 25587.942  ns/op\nStringBenchmark.testStringBufferAppend   avgt    3     26.152 ±   189.157  ns/op\nStringBenchmark.testStringBuilderAppend  avgt    3     21.150 ±    48.648  ns/op\n```\n\n从结果可以验证，在上面简单介绍中所说的，如果字符串拼接操作，最好选择StringBuilder，如果要保证线程安全选择StringBuffer，另外上面结果有一点需要注意的是，从测试结果看，StringBuffer和StringBuilder的性能差不多，这是因为我是在jdk8上运行的，JVM在运行时，因为只有一个线程，因此对Synchronize做了优化，使得StringBuffer性能得到提升。\n\n### 3. 字符串常量池\n\n我觉得这篇文章已经写得非常好因此可以看这篇文章\n\n[String：字符串常量池](https://segmentfault.com/a/1190000009888357)\n\n但是我对这个持有疑问\n\n**String str2 = new String(\"ABC\") + \"ABC\" ; 会创建多少个对象?**\n\nstr2 ：\n字符串常量池：\"ABC\" : 1个\n堆：new String(\"ABC\") ：1个\n引用： str2 ：1个\n总共 ： 3个\n\n我认为结果是这样的：\n\n字符串常量池 “ABC” 1个\n\n堆：new String(\"ABC\"),new String(\"ABCABC\"),new StringBuilder()\n\nNew String(\"ABCABC\") 是由于new String(\"ABC\") +\"ABC\"在编译的时候会按照下面这种方式来生成\n\n```java\nStringBuilder  stringBuilder = new StringBuilder();\nstringBuilder.append(\"ABC\");\nstringBuilder.append(\"ABC);\nstringBuilder.toString();// 这时就会产生 new String(\"ABCABC)\n```\n\n另外由于这个是使用new String(\"ABC\") + \"ABC\"，因此ABCABC不会进入常量池，除非调用String.intern()方法\n\n不知道对不对，欢迎大家讨论\n\n### 参考\n\n1.  [String,StringBuffer与StringBuilder的区别|线程安全与线程不安全](https://www.cnblogs.com/xingzc/p/6277581.html)\n2. [字面量和常量池初探](https://mccxj.github.io/blog/20130615_java-string-constant-pool.html) 基于java1.6","source":"_posts/String、StringBuffer和StringBuilder对比.md","raw":"---\ntitle: String、StringBuffer和StringBuilder对比\ntags:\n  - java\n  - java基础\n  - String\ncategories:\n  - java\nauthor: zhangke\nabbrlink: 10143\ndate: 2019-01-02 13:24:00\n---\n---\n# String、StringBuffer和StringBuilder对比\n\n### 概述\n\n1. 简单介绍\n2. 性能对比\n3. 字符串常量池\n<!-- more -->\n\n### 1. 简单介绍\n\n这里只对这三个类做个简单的总结，如果你希望详细了解这三个类，可以看一下三篇文章，我觉得写得很好。\n\n1.  [String 详解(String系列之1)](https://www.cnblogs.com/skywang12345/p/string01.html)\n2.  [StringBuilder 详解 (String系列之2)](http://www.cnblogs.com/skywang12345/p/string02.html)\n3.  [StringBuffer 详解 (String系列之3)](http://www.cnblogs.com/skywang12345/p/string03.html)\n\n首先一个简单的对比\n\n**String 字符串常量**\n\n**StringBuffer 字符串变量（线程安全）**\n\n**StringBuilder 字符串变量（非线程安全）**\n\nStringBuffer与StringBuilder的实现几乎是一样的，只是StringBufferr为了保证线程安全，在方法前面加上Synchronize关键字来保证安全性，因此下面先用StringBuffer来和String进行对比\n\nString 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。\n 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：\n\n```java\n String S1 = “This is only a” + “ simple” + “ test”;\n StringBuffer Sb = new StringBuffer(“This is only a”).append(“ simple”).append(“ test”);\n```\n\n测试结果：\n\n```\n\nBenchmark                         Mode  Cnt   Score    Error  Units\nStringBenchmark.testString        avgt    3   5.701 ±  2.431  ns/op\nStringBenchmark.testStringBuffer  avgt    3  27.077 ± 21.828  ns/op\n```\n\n**其中score对应是每次操作花费的纳秒说**\n\n 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个\n**String S1 = “This is only a” + “ simple” + “test”; **其实就是：\n** String S1 = “This is only a simple test”**; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：\n\n```\nString S2 = “This is only a”;\nString S3 = “ simple”;\nString S4 = “ test”;\nString S1 = S2 +S3 + S4;\n```\n\n这时候 JVM 会规规矩矩的按照原来的方式去做\n在大部分情况下 StringBuffer的性能要好于 String\n**StringBuffer**\nJava.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。\n例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(\"le\") 会使字符串缓冲区包含“startle”，而 z.insert(4, \"le\") 将更改字符串缓冲区，使之包含“starlet”。\n在大部分情况下 StringBuilder > StringBuffer\n\n**StringBuilder**\njava.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。\n\n### 2. 性能对比\n\n测试性能源码(使用了JMH来进行基准测试)\n\n```\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 3)\n@Measurement(iterations = 3, time = 3)\n@Threads(1)\n@Fork(1)\n@State(Scope.Thread)\npublic class StringBenchmark {\n\n    String s1;\n\n    StringBuffer stringBuffer;\n\n    StringBuilder stringBuilder;\n\n\n    @Setup(Level.Iteration)\n    public void before() {\n        s1 = \"s1\";\n        stringBuffer = new StringBuffer(\"s1\");\n        stringBuilder = new StringBuilder(\"s1\");\n\n    }\n\n\n    @TearDown\n    public void after() {\n\n    }\n\n\n    @Benchmark\n    public String testStringAppend() {\n\n        return s1 += \"s2\";\n    }\n\n\n    @Benchmark\n    public StringBuffer testStringBufferAppend() {\n\n        return stringBuffer.append(\"s2\");\n\n    }\n\n\n    @Benchmark\n    public StringBuilder testStringBuilderAppend() {\n        //下面这个还会单独生成一个String对象，因此性能上有所损失，所以调整一下\n//        return new StringBuilder(\"s1\").append(\"s2\").toString();\n\n        return stringBuilder.append(\"s2\");\n    }\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(StringBenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n```\n\n测试结果\n\n```\nBenchmark                                Mode  Cnt      Score       Error  Units\nStringBenchmark.testStringAppend         avgt    3  28179.211 ± 25587.942  ns/op\nStringBenchmark.testStringBufferAppend   avgt    3     26.152 ±   189.157  ns/op\nStringBenchmark.testStringBuilderAppend  avgt    3     21.150 ±    48.648  ns/op\n```\n\n从结果可以验证，在上面简单介绍中所说的，如果字符串拼接操作，最好选择StringBuilder，如果要保证线程安全选择StringBuffer，另外上面结果有一点需要注意的是，从测试结果看，StringBuffer和StringBuilder的性能差不多，这是因为我是在jdk8上运行的，JVM在运行时，因为只有一个线程，因此对Synchronize做了优化，使得StringBuffer性能得到提升。\n\n### 3. 字符串常量池\n\n我觉得这篇文章已经写得非常好因此可以看这篇文章\n\n[String：字符串常量池](https://segmentfault.com/a/1190000009888357)\n\n但是我对这个持有疑问\n\n**String str2 = new String(\"ABC\") + \"ABC\" ; 会创建多少个对象?**\n\nstr2 ：\n字符串常量池：\"ABC\" : 1个\n堆：new String(\"ABC\") ：1个\n引用： str2 ：1个\n总共 ： 3个\n\n我认为结果是这样的：\n\n字符串常量池 “ABC” 1个\n\n堆：new String(\"ABC\"),new String(\"ABCABC\"),new StringBuilder()\n\nNew String(\"ABCABC\") 是由于new String(\"ABC\") +\"ABC\"在编译的时候会按照下面这种方式来生成\n\n```java\nStringBuilder  stringBuilder = new StringBuilder();\nstringBuilder.append(\"ABC\");\nstringBuilder.append(\"ABC);\nstringBuilder.toString();// 这时就会产生 new String(\"ABCABC)\n```\n\n另外由于这个是使用new String(\"ABC\") + \"ABC\"，因此ABCABC不会进入常量池，除非调用String.intern()方法\n\n不知道对不对，欢迎大家讨论\n\n### 参考\n\n1.  [String,StringBuffer与StringBuilder的区别|线程安全与线程不安全](https://www.cnblogs.com/xingzc/p/6277581.html)\n2. [字面量和常量池初探](https://mccxj.github.io/blog/20130615_java-string-constant-pool.html) 基于java1.6","slug":"String、StringBuffer和StringBuilder对比","published":1,"updated":"2019-01-02T05:50:19.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovp7000n9q1uxhhtw6ug","content":"<hr>\n<h1 id=\"String、StringBuffer和StringBuilder对比\"><a href=\"#String、StringBuffer和StringBuilder对比\" class=\"headerlink\" title=\"String、StringBuffer和StringBuilder对比\"></a>String、StringBuffer和StringBuilder对比</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>简单介绍</li>\n<li>性能对比</li>\n<li>字符串常量池<a id=\"more\"></a>\n</li>\n</ol>\n<h3 id=\"1-简单介绍\"><a href=\"#1-简单介绍\" class=\"headerlink\" title=\"1. 简单介绍\"></a>1. 简单介绍</h3><p>这里只对这三个类做个简单的总结，如果你希望详细了解这三个类，可以看一下三篇文章，我觉得写得很好。</p>\n<ol>\n<li><a href=\"https://www.cnblogs.com/skywang12345/p/string01.html\" target=\"_blank\" rel=\"noopener\">String 详解(String系列之1)</a></li>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/string02.html\" target=\"_blank\" rel=\"noopener\">StringBuilder 详解 (String系列之2)</a></li>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/string03.html\" target=\"_blank\" rel=\"noopener\">StringBuffer 详解 (String系列之3)</a></li>\n</ol>\n<p>首先一个简单的对比</p>\n<p><strong>String 字符串常量</strong></p>\n<p><strong>StringBuffer 字符串变量（线程安全）</strong></p>\n<p><strong>StringBuilder 字符串变量（非线程安全）</strong></p>\n<p>StringBuffer与StringBuilder的实现几乎是一样的，只是StringBufferr为了保证线程安全，在方法前面加上Synchronize关键字来保证安全性，因此下面先用StringBuffer来和String进行对比</p>\n<p>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。<br> 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>\n<pre><code class=\"java\"> String S1 = “This is only a” + “ simple” + “ test”;\n StringBuffer Sb = new StringBuffer(“This is only a”).append(“ simple”).append(“ test”);\n</code></pre>\n<p>测试结果：</p>\n<pre><code>\nBenchmark                         Mode  Cnt   Score    Error  Units\nStringBenchmark.testString        avgt    3   5.701 ±  2.431  ns/op\nStringBenchmark.testStringBuffer  avgt    3  27.077 ± 21.828  ns/op\n</code></pre><p><strong>其中score对应是每次操作花费的纳秒说</strong></p>\n<p> 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个<br><strong>String S1 = “This is only a” + “ simple” + “test”; </strong>其实就是：<br><strong> String S1 = “This is only a simple test”</strong>; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：</p>\n<pre><code>String S2 = “This is only a”;\nString S3 = “ simple”;\nString S4 = “ test”;\nString S1 = S2 +S3 + S4;\n</code></pre><p>这时候 JVM 会规规矩矩的按照原来的方式去做<br>在大部分情况下 StringBuffer的性能要好于 String<br><strong>StringBuffer</strong><br>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。<br>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。<br>在大部分情况下 StringBuilder &gt; StringBuffer</p>\n<p><strong>StringBuilder</strong><br>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>\n<h3 id=\"2-性能对比\"><a href=\"#2-性能对比\" class=\"headerlink\" title=\"2. 性能对比\"></a>2. 性能对比</h3><p>测试性能源码(使用了JMH来进行基准测试)</p>\n<pre><code>@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 3)\n@Measurement(iterations = 3, time = 3)\n@Threads(1)\n@Fork(1)\n@State(Scope.Thread)\npublic class StringBenchmark {\n\n    String s1;\n\n    StringBuffer stringBuffer;\n\n    StringBuilder stringBuilder;\n\n\n    @Setup(Level.Iteration)\n    public void before() {\n        s1 = &quot;s1&quot;;\n        stringBuffer = new StringBuffer(&quot;s1&quot;);\n        stringBuilder = new StringBuilder(&quot;s1&quot;);\n\n    }\n\n\n    @TearDown\n    public void after() {\n\n    }\n\n\n    @Benchmark\n    public String testStringAppend() {\n\n        return s1 += &quot;s2&quot;;\n    }\n\n\n    @Benchmark\n    public StringBuffer testStringBufferAppend() {\n\n        return stringBuffer.append(&quot;s2&quot;);\n\n    }\n\n\n    @Benchmark\n    public StringBuilder testStringBuilderAppend() {\n        //下面这个还会单独生成一个String对象，因此性能上有所损失，所以调整一下\n//        return new StringBuilder(&quot;s1&quot;).append(&quot;s2&quot;).toString();\n\n        return stringBuilder.append(&quot;s2&quot;);\n    }\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(StringBenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n</code></pre><p>测试结果</p>\n<pre><code>Benchmark                                Mode  Cnt      Score       Error  Units\nStringBenchmark.testStringAppend         avgt    3  28179.211 ± 25587.942  ns/op\nStringBenchmark.testStringBufferAppend   avgt    3     26.152 ±   189.157  ns/op\nStringBenchmark.testStringBuilderAppend  avgt    3     21.150 ±    48.648  ns/op\n</code></pre><p>从结果可以验证，在上面简单介绍中所说的，如果字符串拼接操作，最好选择StringBuilder，如果要保证线程安全选择StringBuffer，另外上面结果有一点需要注意的是，从测试结果看，StringBuffer和StringBuilder的性能差不多，这是因为我是在jdk8上运行的，JVM在运行时，因为只有一个线程，因此对Synchronize做了优化，使得StringBuffer性能得到提升。</p>\n<h3 id=\"3-字符串常量池\"><a href=\"#3-字符串常量池\" class=\"headerlink\" title=\"3. 字符串常量池\"></a>3. 字符串常量池</h3><p>我觉得这篇文章已经写得非常好因此可以看这篇文章</p>\n<p><a href=\"https://segmentfault.com/a/1190000009888357\" target=\"_blank\" rel=\"noopener\">String：字符串常量池</a></p>\n<p>但是我对这个持有疑问</p>\n<p><strong>String str2 = new String(“ABC”) + “ABC” ; 会创建多少个对象?</strong></p>\n<p>str2 ：<br>字符串常量池：”ABC” : 1个<br>堆：new String(“ABC”) ：1个<br>引用： str2 ：1个<br>总共 ： 3个</p>\n<p>我认为结果是这样的：</p>\n<p>字符串常量池 “ABC” 1个</p>\n<p>堆：new String(“ABC”),new String(“ABCABC”),new StringBuilder()</p>\n<p>New String(“ABCABC”) 是由于new String(“ABC”) +”ABC”在编译的时候会按照下面这种方式来生成</p>\n<pre><code class=\"java\">StringBuilder  stringBuilder = new StringBuilder();\nstringBuilder.append(&quot;ABC&quot;);\nstringBuilder.append(&quot;ABC);\nstringBuilder.toString();// 这时就会产生 new String(&quot;ABCABC)\n</code></pre>\n<p>另外由于这个是使用new String(“ABC”) + “ABC”，因此ABCABC不会进入常量池，除非调用String.intern()方法</p>\n<p>不知道对不对，欢迎大家讨论</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://www.cnblogs.com/xingzc/p/6277581.html\" target=\"_blank\" rel=\"noopener\">String,StringBuffer与StringBuilder的区别|线程安全与线程不安全</a></li>\n<li><a href=\"https://mccxj.github.io/blog/20130615_java-string-constant-pool.html\" target=\"_blank\" rel=\"noopener\">字面量和常量池初探</a> 基于java1.6</li>\n</ol>\n","site":{"data":{}},"excerpt":"<hr>\n<h1 id=\"String、StringBuffer和StringBuilder对比\"><a href=\"#String、StringBuffer和StringBuilder对比\" class=\"headerlink\" title=\"String、StringBuffer和StringBuilder对比\"></a>String、StringBuffer和StringBuilder对比</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>简单介绍</li>\n<li>性能对比</li>\n<li>字符串常量池","more":"</li>\n</ol>\n<h3 id=\"1-简单介绍\"><a href=\"#1-简单介绍\" class=\"headerlink\" title=\"1. 简单介绍\"></a>1. 简单介绍</h3><p>这里只对这三个类做个简单的总结，如果你希望详细了解这三个类，可以看一下三篇文章，我觉得写得很好。</p>\n<ol>\n<li><a href=\"https://www.cnblogs.com/skywang12345/p/string01.html\" target=\"_blank\" rel=\"noopener\">String 详解(String系列之1)</a></li>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/string02.html\" target=\"_blank\" rel=\"noopener\">StringBuilder 详解 (String系列之2)</a></li>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/string03.html\" target=\"_blank\" rel=\"noopener\">StringBuffer 详解 (String系列之3)</a></li>\n</ol>\n<p>首先一个简单的对比</p>\n<p><strong>String 字符串常量</strong></p>\n<p><strong>StringBuffer 字符串变量（线程安全）</strong></p>\n<p><strong>StringBuilder 字符串变量（非线程安全）</strong></p>\n<p>StringBuffer与StringBuilder的实现几乎是一样的，只是StringBufferr为了保证线程安全，在方法前面加上Synchronize关键字来保证安全性，因此下面先用StringBuffer来和String进行对比</p>\n<p>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。<br> 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>\n<pre><code class=\"java\"> String S1 = “This is only a” + “ simple” + “ test”;\n StringBuffer Sb = new StringBuffer(“This is only a”).append(“ simple”).append(“ test”);\n</code></pre>\n<p>测试结果：</p>\n<pre><code>\nBenchmark                         Mode  Cnt   Score    Error  Units\nStringBenchmark.testString        avgt    3   5.701 ±  2.431  ns/op\nStringBenchmark.testStringBuffer  avgt    3  27.077 ± 21.828  ns/op\n</code></pre><p><strong>其中score对应是每次操作花费的纳秒说</strong></p>\n<p> 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个<br><strong>String S1 = “This is only a” + “ simple” + “test”; </strong>其实就是：<br><strong> String S1 = “This is only a simple test”</strong>; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：</p>\n<pre><code>String S2 = “This is only a”;\nString S3 = “ simple”;\nString S4 = “ test”;\nString S1 = S2 +S3 + S4;\n</code></pre><p>这时候 JVM 会规规矩矩的按照原来的方式去做<br>在大部分情况下 StringBuffer的性能要好于 String<br><strong>StringBuffer</strong><br>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。<br>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。<br>在大部分情况下 StringBuilder &gt; StringBuffer</p>\n<p><strong>StringBuilder</strong><br>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>\n<h3 id=\"2-性能对比\"><a href=\"#2-性能对比\" class=\"headerlink\" title=\"2. 性能对比\"></a>2. 性能对比</h3><p>测试性能源码(使用了JMH来进行基准测试)</p>\n<pre><code>@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 3)\n@Measurement(iterations = 3, time = 3)\n@Threads(1)\n@Fork(1)\n@State(Scope.Thread)\npublic class StringBenchmark {\n\n    String s1;\n\n    StringBuffer stringBuffer;\n\n    StringBuilder stringBuilder;\n\n\n    @Setup(Level.Iteration)\n    public void before() {\n        s1 = &quot;s1&quot;;\n        stringBuffer = new StringBuffer(&quot;s1&quot;);\n        stringBuilder = new StringBuilder(&quot;s1&quot;);\n\n    }\n\n\n    @TearDown\n    public void after() {\n\n    }\n\n\n    @Benchmark\n    public String testStringAppend() {\n\n        return s1 += &quot;s2&quot;;\n    }\n\n\n    @Benchmark\n    public StringBuffer testStringBufferAppend() {\n\n        return stringBuffer.append(&quot;s2&quot;);\n\n    }\n\n\n    @Benchmark\n    public StringBuilder testStringBuilderAppend() {\n        //下面这个还会单独生成一个String对象，因此性能上有所损失，所以调整一下\n//        return new StringBuilder(&quot;s1&quot;).append(&quot;s2&quot;).toString();\n\n        return stringBuilder.append(&quot;s2&quot;);\n    }\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(StringBenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n</code></pre><p>测试结果</p>\n<pre><code>Benchmark                                Mode  Cnt      Score       Error  Units\nStringBenchmark.testStringAppend         avgt    3  28179.211 ± 25587.942  ns/op\nStringBenchmark.testStringBufferAppend   avgt    3     26.152 ±   189.157  ns/op\nStringBenchmark.testStringBuilderAppend  avgt    3     21.150 ±    48.648  ns/op\n</code></pre><p>从结果可以验证，在上面简单介绍中所说的，如果字符串拼接操作，最好选择StringBuilder，如果要保证线程安全选择StringBuffer，另外上面结果有一点需要注意的是，从测试结果看，StringBuffer和StringBuilder的性能差不多，这是因为我是在jdk8上运行的，JVM在运行时，因为只有一个线程，因此对Synchronize做了优化，使得StringBuffer性能得到提升。</p>\n<h3 id=\"3-字符串常量池\"><a href=\"#3-字符串常量池\" class=\"headerlink\" title=\"3. 字符串常量池\"></a>3. 字符串常量池</h3><p>我觉得这篇文章已经写得非常好因此可以看这篇文章</p>\n<p><a href=\"https://segmentfault.com/a/1190000009888357\" target=\"_blank\" rel=\"noopener\">String：字符串常量池</a></p>\n<p>但是我对这个持有疑问</p>\n<p><strong>String str2 = new String(“ABC”) + “ABC” ; 会创建多少个对象?</strong></p>\n<p>str2 ：<br>字符串常量池：”ABC” : 1个<br>堆：new String(“ABC”) ：1个<br>引用： str2 ：1个<br>总共 ： 3个</p>\n<p>我认为结果是这样的：</p>\n<p>字符串常量池 “ABC” 1个</p>\n<p>堆：new String(“ABC”),new String(“ABCABC”),new StringBuilder()</p>\n<p>New String(“ABCABC”) 是由于new String(“ABC”) +”ABC”在编译的时候会按照下面这种方式来生成</p>\n<pre><code class=\"java\">StringBuilder  stringBuilder = new StringBuilder();\nstringBuilder.append(&quot;ABC&quot;);\nstringBuilder.append(&quot;ABC);\nstringBuilder.toString();// 这时就会产生 new String(&quot;ABCABC)\n</code></pre>\n<p>另外由于这个是使用new String(“ABC”) + “ABC”，因此ABCABC不会进入常量池，除非调用String.intern()方法</p>\n<p>不知道对不对，欢迎大家讨论</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://www.cnblogs.com/xingzc/p/6277581.html\" target=\"_blank\" rel=\"noopener\">String,StringBuffer与StringBuilder的区别|线程安全与线程不安全</a></li>\n<li><a href=\"https://mccxj.github.io/blog/20130615_java-string-constant-pool.html\" target=\"_blank\" rel=\"noopener\">字面量和常量池初探</a> 基于java1.6</li>\n</ol>"},{"abbrlink":13,"title":"Iterator 和 Iterable 区别","author":"zhangke","date":"2017-12-23T11:31:00.000Z","_content":"# Iterator 和 Iterable 区别\n\n### Iterator（迭代器）\n\n作为一种设计模式，迭代器可以用于遍历一个对象，而开发人员不用去了解这个对象的底层结构。\n\n这里就不仔细说迭代器这种设计模式，因为我们主要的目的是探索 java 中 Iterator 和 Iterable 之间的区别\n\n### 用法\n\n首先来说一下他们各自是怎么使用，不会用谈什么都是瞎搞。\n\n#### Iterator 用法\n\n首先来说一下 Iterator 这个接口，他定义了迭代器基本的功能。\n\n#### 源码如下\n\n```\npackage java.util;\n\npublic interface Iterator<E> {\n    boolean hasNext();   //返回是否有下一个元素\n    E next();            //返回下一个元素\n    void remove();\t\t //移除当前元素\n}\n\n\n```\n\n#### 如何使用这个接口\n\n```\npublic class main {\n\n    public static void main(String[] args) {\n        MyIterator mi = new MyIterator();\n        while (mi.hasNext()){\n            System.out.printf(\"%s\\t\",mi.next());\n        }\n    }\n}\n\nclass MyIterator implements Iterator<String>{\n    private String[] words = (\"And that is how \"\n            + \"we know the Earth to be banana-shaped.\").split(\" \");\n    private int count = 0;\n    public MyIterator() {\n    }\n\n    @Override\n    public boolean hasNext() {\n        return count < words.length;\n    }\n\n    @Override\n    public String next() {\n        return words[count++];\n    }\n}\n```\n\n代码很简单，所以就不过多的解释了，但是有一点需要注意的是，下面这样使用上面定义的 MyIterator 类是错误的，你可以试一下。\n\n```\nfor (String s:new MyIterator){\n            System.out.printf(\"%s\\t\",s);\n }\n```\n\n### Iterable 用法\n\n#### 源码\n\n```\npackage java.lang;\n\nimport java.util.Iterator;\n\npublic interface Iterable<T> {\n\n    Iterator<T> iterator();\n}\n```\n\n#### 如何使用\n\n```\npublic class main {\n\n    public static void main(String[] args) {\n\n      MyIterable myIterable= new MyIterable();\n        Iterator<String> mIterator = myIterable.iterator();\n        for (String s:myIterable){\n            System.out.printf(\"%s\\t\",s);\n        }\n    }\n}\n\nclass MyIterable implements Iterable<String>{\n    private String[] words = (\"And that is how \"\n            + \"we know the Earth to be banana-shaped.\").split(\" \");\n\n    @Override\n    public Iterator<String> iterator() {\n        return new Iterator<String>() {\n            private int i = 0;\n            @Override\n            public boolean hasNext() {\n                return i < words.length;\n            }\n\n            @Override\n            public String next() {\n                return words[i++];\n            }\n        };\n    }\n}\n```\n\n与上面 Iterator 不同的是，这个类还可以下面这样使用\n\n```\n\t\tMyIterable mi = new MyIterable().iterator();\n        while (mi.hasNext()){\n            System.out.printf(\"%s\\t\",mi.next());\n        } \n```\n\n### 区别\n\n基本用法已经说完，相信你也能看出其中的一些区别\n\n1. Iterator 是迭代器类(这个类是指定义了迭代器基本需要的方法)，而 Iterable 是接口。 这个从他们的包名就可以看出来。\n\n```Java\njava.lang.Iterable\njava.util.Iterator\n```\n\n1. Iterator 不嫩用于 foreach 循环语句，Iterable 可以\n\n2. 为什么一定要实现 Iterable 接口，为什么不直接实现 Iterator 接口呢？\n\n   看一下 JDK 中的集合类，比如 List 一族或者 Set 一族，都是实现了 Iterable 接口，但并不直接实现 Iterator 接口。\n\n   这并不是没有道理的。\n\n   ​ 因为 Iterator 接口的核心方法 next()或者 hasNext() 是依赖于迭代器的当前迭代位置的。\n\n   如果 Collection 直接实现 Iterator 接口，势必导致集合对象中包含当前迭代位置的数据(指针)。\n\n   ​ 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么 next()方法的结果会变成不可预知。 除非再为 Iterator 接口添加一个 reset()方法，用来重置当前迭代位置。 但即时这样，Collection 也只能同时存在一个当前迭代位置。\n\n   而 Iterable 则不然，每次调用都会返回一个从头开始计数的迭代器。\n\n   多个迭代器是互不干扰的\n\n### 扩展\n\n你在看 ArrayList 源码的时候，你会发现这样一段代码\n\n```Java\n   private class Itr implements Iterator<E> {\n       int cursor;       // 返回下一个元素的索引\n\n     \tint lastRet = -1; // 返回最后一个元素的索引，如果空，返回-1\n\n       int expectedModCount = modCount; //用于检测当前集合是否执行了添加删除操作，其中modCount，是当前集合中元素的个数\n\n       public boolean hasNext() {\n           return cursor != size;\n       }\n\n       @SuppressWarnings(\"unchecked\")\n       public E next() {\n           checkForComodification(); //检测集合元素是否执行添加删除操作\n           int i = cursor;\n           if (i >= size)\n               throw new NoSuchElementException();\n           Object[] elementData = ArrayList.this.elementData;\n           if (i >= elementData.length)\n               throw new ConcurrentModificationException();\n           cursor = i + 1;\n           return (E) elementData[lastRet = i];\n       }\n\n       public void remove() {\n           if (lastRet < 0)\n               throw new IllegalStateException();\n           checkForComodification();\n\n           try {\n               ArrayList.this.remove(lastRet);\n               cursor = lastRet;\n               lastRet = -1;\n               expectedModCount = modCount;\n           } catch (IndexOutOfBoundsException ex) {\n               throw new ConcurrentModificationException();\n           }\n       }\n\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void forEachRemaining(Consumer<? super E> consumer) {\n           Objects.requireNonNull(consumer);\n           final int size = ArrayList.this.size;\n           int i = cursor;\n           if (i >= size) {\n               return;\n           }\n           final Object[] elementData = ArrayList.this.elementData;\n           if (i >= elementData.length) {\n               throw new ConcurrentModificationException();\n           }\n           while (i != size && modCount == expectedModCount) {\n               consumer.accept((E) elementData[i++]);\n           }\n           // update once at end of iteration to reduce heap write traffic\n           cursor = i;\n           lastRet = i - 1;\n           checkForComodification();\n       }\n\t\t//如果发生添加删除操作，则抛出错误。\n       final void checkForComodification() {\n           if (modCount != expectedModCount)\n               throw new ConcurrentModificationException();\n       }\n   }\n```\n\n​ 对于上述的代码不难看懂，有点疑惑的是 int expectedModCount = modCount;这句代码\n\n​其实这是集合迭代中的一种**快速失败**机制，这种机制提供迭代过程中集合的安全性。阅读源码​ 就可以知道 ArrayList 中存在 modCount 对象，增删操作都会使 modCount++，通过两者的对比​ 迭代器可以快速的知道迭代过程中是否存在 list.add()类似的操作，存在的话快速失败!\n\n## Fail-Fast(快速失败)机制\n\n仔细观察上述的各个方法，我们在源码中就会发现一个特别的属性 modCount，API 解释如下：\n\n​ The number of times this list has been structurally modified. Structural modifications are those​ that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress​ may yield incorrect results.\n\n记录修改此列表的次数：包括改变列表的结构，改变列表的大小，打乱列表的顺序等使正在进行 迭代产生 错误的结果。\n\nTips:仅仅设置元素的值并不是结构的修改\n\n我们知道的是 ArrayList 是线程不安全的，如果在使用迭代器的过程中有其他的线程修改了 List 就会抛出 ConcurrentModificationException 这就是 Fail-Fast 机制。那么快速失败究竟是个什么意思呢？在 ArrayList 类创建迭代器之后，除非通过迭代器自身 remove 或 add 对列表结构进行修改，否则在其他线程中以任何形式对列表进行修改，迭代器马上会抛出异常，快速失败。\n\n### 迭代器的好处\n\n## 迭代器的好处\n\n​ 通过上述我们明白了迭代是到底是个什么，迭代器的使用也十分的简单。现在简要的总结下使用迭代器的好处吧。\n\n​ **1、迭代器可以提供统一的迭代方式。**\n\n**​ 2、 迭代器也可以在对客户端透明的情况下，提供各种不同的迭代方式。**\n\n​ **3、迭代器提供一种快速失败机制，防止多线程下迭代的不安全操作。**\n\n​ 不过对于第三点尚需注意的是：就像上述事例代码一样，我们不能保证迭代过程中出现**快速失败**的都是因为同步造成的，因此为了保证迭代操作的正确性而去依赖此类异常是错误的！","source":"_posts/java 中 Iterator 和 Iterable 区别.md","raw":"abbrlink: 13\ntitle: Iterator 和 Iterable 区别\ntags:\n  - java\ncategories:\n  - java\nauthor: zhangke\ndate: 2017-12-23 19:31:00\n---\n# Iterator 和 Iterable 区别\n\n### Iterator（迭代器）\n\n作为一种设计模式，迭代器可以用于遍历一个对象，而开发人员不用去了解这个对象的底层结构。\n\n这里就不仔细说迭代器这种设计模式，因为我们主要的目的是探索 java 中 Iterator 和 Iterable 之间的区别\n\n### 用法\n\n首先来说一下他们各自是怎么使用，不会用谈什么都是瞎搞。\n\n#### Iterator 用法\n\n首先来说一下 Iterator 这个接口，他定义了迭代器基本的功能。\n\n#### 源码如下\n\n```\npackage java.util;\n\npublic interface Iterator<E> {\n    boolean hasNext();   //返回是否有下一个元素\n    E next();            //返回下一个元素\n    void remove();\t\t //移除当前元素\n}\n\n\n```\n\n#### 如何使用这个接口\n\n```\npublic class main {\n\n    public static void main(String[] args) {\n        MyIterator mi = new MyIterator();\n        while (mi.hasNext()){\n            System.out.printf(\"%s\\t\",mi.next());\n        }\n    }\n}\n\nclass MyIterator implements Iterator<String>{\n    private String[] words = (\"And that is how \"\n            + \"we know the Earth to be banana-shaped.\").split(\" \");\n    private int count = 0;\n    public MyIterator() {\n    }\n\n    @Override\n    public boolean hasNext() {\n        return count < words.length;\n    }\n\n    @Override\n    public String next() {\n        return words[count++];\n    }\n}\n```\n\n代码很简单，所以就不过多的解释了，但是有一点需要注意的是，下面这样使用上面定义的 MyIterator 类是错误的，你可以试一下。\n\n```\nfor (String s:new MyIterator){\n            System.out.printf(\"%s\\t\",s);\n }\n```\n\n### Iterable 用法\n\n#### 源码\n\n```\npackage java.lang;\n\nimport java.util.Iterator;\n\npublic interface Iterable<T> {\n\n    Iterator<T> iterator();\n}\n```\n\n#### 如何使用\n\n```\npublic class main {\n\n    public static void main(String[] args) {\n\n      MyIterable myIterable= new MyIterable();\n        Iterator<String> mIterator = myIterable.iterator();\n        for (String s:myIterable){\n            System.out.printf(\"%s\\t\",s);\n        }\n    }\n}\n\nclass MyIterable implements Iterable<String>{\n    private String[] words = (\"And that is how \"\n            + \"we know the Earth to be banana-shaped.\").split(\" \");\n\n    @Override\n    public Iterator<String> iterator() {\n        return new Iterator<String>() {\n            private int i = 0;\n            @Override\n            public boolean hasNext() {\n                return i < words.length;\n            }\n\n            @Override\n            public String next() {\n                return words[i++];\n            }\n        };\n    }\n}\n```\n\n与上面 Iterator 不同的是，这个类还可以下面这样使用\n\n```\n\t\tMyIterable mi = new MyIterable().iterator();\n        while (mi.hasNext()){\n            System.out.printf(\"%s\\t\",mi.next());\n        } \n```\n\n### 区别\n\n基本用法已经说完，相信你也能看出其中的一些区别\n\n1. Iterator 是迭代器类(这个类是指定义了迭代器基本需要的方法)，而 Iterable 是接口。 这个从他们的包名就可以看出来。\n\n```Java\njava.lang.Iterable\njava.util.Iterator\n```\n\n1. Iterator 不嫩用于 foreach 循环语句，Iterable 可以\n\n2. 为什么一定要实现 Iterable 接口，为什么不直接实现 Iterator 接口呢？\n\n   看一下 JDK 中的集合类，比如 List 一族或者 Set 一族，都是实现了 Iterable 接口，但并不直接实现 Iterator 接口。\n\n   这并不是没有道理的。\n\n   ​ 因为 Iterator 接口的核心方法 next()或者 hasNext() 是依赖于迭代器的当前迭代位置的。\n\n   如果 Collection 直接实现 Iterator 接口，势必导致集合对象中包含当前迭代位置的数据(指针)。\n\n   ​ 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么 next()方法的结果会变成不可预知。 除非再为 Iterator 接口添加一个 reset()方法，用来重置当前迭代位置。 但即时这样，Collection 也只能同时存在一个当前迭代位置。\n\n   而 Iterable 则不然，每次调用都会返回一个从头开始计数的迭代器。\n\n   多个迭代器是互不干扰的\n\n### 扩展\n\n你在看 ArrayList 源码的时候，你会发现这样一段代码\n\n```Java\n   private class Itr implements Iterator<E> {\n       int cursor;       // 返回下一个元素的索引\n\n     \tint lastRet = -1; // 返回最后一个元素的索引，如果空，返回-1\n\n       int expectedModCount = modCount; //用于检测当前集合是否执行了添加删除操作，其中modCount，是当前集合中元素的个数\n\n       public boolean hasNext() {\n           return cursor != size;\n       }\n\n       @SuppressWarnings(\"unchecked\")\n       public E next() {\n           checkForComodification(); //检测集合元素是否执行添加删除操作\n           int i = cursor;\n           if (i >= size)\n               throw new NoSuchElementException();\n           Object[] elementData = ArrayList.this.elementData;\n           if (i >= elementData.length)\n               throw new ConcurrentModificationException();\n           cursor = i + 1;\n           return (E) elementData[lastRet = i];\n       }\n\n       public void remove() {\n           if (lastRet < 0)\n               throw new IllegalStateException();\n           checkForComodification();\n\n           try {\n               ArrayList.this.remove(lastRet);\n               cursor = lastRet;\n               lastRet = -1;\n               expectedModCount = modCount;\n           } catch (IndexOutOfBoundsException ex) {\n               throw new ConcurrentModificationException();\n           }\n       }\n\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void forEachRemaining(Consumer<? super E> consumer) {\n           Objects.requireNonNull(consumer);\n           final int size = ArrayList.this.size;\n           int i = cursor;\n           if (i >= size) {\n               return;\n           }\n           final Object[] elementData = ArrayList.this.elementData;\n           if (i >= elementData.length) {\n               throw new ConcurrentModificationException();\n           }\n           while (i != size && modCount == expectedModCount) {\n               consumer.accept((E) elementData[i++]);\n           }\n           // update once at end of iteration to reduce heap write traffic\n           cursor = i;\n           lastRet = i - 1;\n           checkForComodification();\n       }\n\t\t//如果发生添加删除操作，则抛出错误。\n       final void checkForComodification() {\n           if (modCount != expectedModCount)\n               throw new ConcurrentModificationException();\n       }\n   }\n```\n\n​ 对于上述的代码不难看懂，有点疑惑的是 int expectedModCount = modCount;这句代码\n\n​其实这是集合迭代中的一种**快速失败**机制，这种机制提供迭代过程中集合的安全性。阅读源码​ 就可以知道 ArrayList 中存在 modCount 对象，增删操作都会使 modCount++，通过两者的对比​ 迭代器可以快速的知道迭代过程中是否存在 list.add()类似的操作，存在的话快速失败!\n\n## Fail-Fast(快速失败)机制\n\n仔细观察上述的各个方法，我们在源码中就会发现一个特别的属性 modCount，API 解释如下：\n\n​ The number of times this list has been structurally modified. Structural modifications are those​ that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress​ may yield incorrect results.\n\n记录修改此列表的次数：包括改变列表的结构，改变列表的大小，打乱列表的顺序等使正在进行 迭代产生 错误的结果。\n\nTips:仅仅设置元素的值并不是结构的修改\n\n我们知道的是 ArrayList 是线程不安全的，如果在使用迭代器的过程中有其他的线程修改了 List 就会抛出 ConcurrentModificationException 这就是 Fail-Fast 机制。那么快速失败究竟是个什么意思呢？在 ArrayList 类创建迭代器之后，除非通过迭代器自身 remove 或 add 对列表结构进行修改，否则在其他线程中以任何形式对列表进行修改，迭代器马上会抛出异常，快速失败。\n\n### 迭代器的好处\n\n## 迭代器的好处\n\n​ 通过上述我们明白了迭代是到底是个什么，迭代器的使用也十分的简单。现在简要的总结下使用迭代器的好处吧。\n\n​ **1、迭代器可以提供统一的迭代方式。**\n\n**​ 2、 迭代器也可以在对客户端透明的情况下，提供各种不同的迭代方式。**\n\n​ **3、迭代器提供一种快速失败机制，防止多线程下迭代的不安全操作。**\n\n​ 不过对于第三点尚需注意的是：就像上述事例代码一样，我们不能保证迭代过程中出现**快速失败**的都是因为同步造成的，因此为了保证迭代操作的正确性而去依赖此类异常是错误的！","slug":"java 中 Iterator 和 Iterable 区别","published":1,"updated":"2019-01-04T01:48:59.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovp8000q9q1uaoxnrewp","content":"<h1 id=\"Iterator-和-Iterable-区别\"><a href=\"#Iterator-和-Iterable-区别\" class=\"headerlink\" title=\"Iterator 和 Iterable 区别\"></a>Iterator 和 Iterable 区别</h1><h3 id=\"Iterator（迭代器）\"><a href=\"#Iterator（迭代器）\" class=\"headerlink\" title=\"Iterator（迭代器）\"></a>Iterator（迭代器）</h3><p>作为一种设计模式，迭代器可以用于遍历一个对象，而开发人员不用去了解这个对象的底层结构。</p>\n<p>这里就不仔细说迭代器这种设计模式，因为我们主要的目的是探索 java 中 Iterator 和 Iterable 之间的区别</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>首先来说一下他们各自是怎么使用，不会用谈什么都是瞎搞。</p>\n<h4 id=\"Iterator-用法\"><a href=\"#Iterator-用法\" class=\"headerlink\" title=\"Iterator 用法\"></a>Iterator 用法</h4><p>首先来说一下 Iterator 这个接口，他定义了迭代器基本的功能。</p>\n<h4 id=\"源码如下\"><a href=\"#源码如下\" class=\"headerlink\" title=\"源码如下\"></a>源码如下</h4><pre><code>package java.util;\n\npublic interface Iterator&lt;E&gt; {\n    boolean hasNext();   //返回是否有下一个元素\n    E next();            //返回下一个元素\n    void remove();         //移除当前元素\n}\n\n\n</code></pre><h4 id=\"如何使用这个接口\"><a href=\"#如何使用这个接口\" class=\"headerlink\" title=\"如何使用这个接口\"></a>如何使用这个接口</h4><pre><code>public class main {\n\n    public static void main(String[] args) {\n        MyIterator mi = new MyIterator();\n        while (mi.hasNext()){\n            System.out.printf(&quot;%s\\t&quot;,mi.next());\n        }\n    }\n}\n\nclass MyIterator implements Iterator&lt;String&gt;{\n    private String[] words = (&quot;And that is how &quot;\n            + &quot;we know the Earth to be banana-shaped.&quot;).split(&quot; &quot;);\n    private int count = 0;\n    public MyIterator() {\n    }\n\n    @Override\n    public boolean hasNext() {\n        return count &lt; words.length;\n    }\n\n    @Override\n    public String next() {\n        return words[count++];\n    }\n}\n</code></pre><p>代码很简单，所以就不过多的解释了，但是有一点需要注意的是，下面这样使用上面定义的 MyIterator 类是错误的，你可以试一下。</p>\n<pre><code>for (String s:new MyIterator){\n            System.out.printf(&quot;%s\\t&quot;,s);\n }\n</code></pre><h3 id=\"Iterable-用法\"><a href=\"#Iterable-用法\" class=\"headerlink\" title=\"Iterable 用法\"></a>Iterable 用法</h3><h4 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h4><pre><code>package java.lang;\n\nimport java.util.Iterator;\n\npublic interface Iterable&lt;T&gt; {\n\n    Iterator&lt;T&gt; iterator();\n}\n</code></pre><h4 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h4><pre><code>public class main {\n\n    public static void main(String[] args) {\n\n      MyIterable myIterable= new MyIterable();\n        Iterator&lt;String&gt; mIterator = myIterable.iterator();\n        for (String s:myIterable){\n            System.out.printf(&quot;%s\\t&quot;,s);\n        }\n    }\n}\n\nclass MyIterable implements Iterable&lt;String&gt;{\n    private String[] words = (&quot;And that is how &quot;\n            + &quot;we know the Earth to be banana-shaped.&quot;).split(&quot; &quot;);\n\n    @Override\n    public Iterator&lt;String&gt; iterator() {\n        return new Iterator&lt;String&gt;() {\n            private int i = 0;\n            @Override\n            public boolean hasNext() {\n                return i &lt; words.length;\n            }\n\n            @Override\n            public String next() {\n                return words[i++];\n            }\n        };\n    }\n}\n</code></pre><p>与上面 Iterator 不同的是，这个类还可以下面这样使用</p>\n<pre><code>        MyIterable mi = new MyIterable().iterator();\n        while (mi.hasNext()){\n            System.out.printf(&quot;%s\\t&quot;,mi.next());\n        } \n</code></pre><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p>基本用法已经说完，相信你也能看出其中的一些区别</p>\n<ol>\n<li>Iterator 是迭代器类(这个类是指定义了迭代器基本需要的方法)，而 Iterable 是接口。 这个从他们的包名就可以看出来。</li>\n</ol>\n<pre><code class=\"Java\">java.lang.Iterable\njava.util.Iterator\n</code></pre>\n<ol>\n<li><p>Iterator 不嫩用于 foreach 循环语句，Iterable 可以</p>\n</li>\n<li><p>为什么一定要实现 Iterable 接口，为什么不直接实现 Iterator 接口呢？</p>\n<p>看一下 JDK 中的集合类，比如 List 一族或者 Set 一族，都是实现了 Iterable 接口，但并不直接实现 Iterator 接口。</p>\n<p>这并不是没有道理的。</p>\n<p>​ 因为 Iterator 接口的核心方法 next()或者 hasNext() 是依赖于迭代器的当前迭代位置的。</p>\n<p>如果 Collection 直接实现 Iterator 接口，势必导致集合对象中包含当前迭代位置的数据(指针)。</p>\n<p>​ 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么 next()方法的结果会变成不可预知。 除非再为 Iterator 接口添加一个 reset()方法，用来重置当前迭代位置。 但即时这样，Collection 也只能同时存在一个当前迭代位置。</p>\n<p>而 Iterable 则不然，每次调用都会返回一个从头开始计数的迭代器。</p>\n<p>多个迭代器是互不干扰的</p>\n</li>\n</ol>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p>你在看 ArrayList 源码的时候，你会发现这样一段代码</p>\n<pre><code class=\"Java\">   private class Itr implements Iterator&lt;E&gt; {\n       int cursor;       // 返回下一个元素的索引\n\n         int lastRet = -1; // 返回最后一个元素的索引，如果空，返回-1\n\n       int expectedModCount = modCount; //用于检测当前集合是否执行了添加删除操作，其中modCount，是当前集合中元素的个数\n\n       public boolean hasNext() {\n           return cursor != size;\n       }\n\n       @SuppressWarnings(&quot;unchecked&quot;)\n       public E next() {\n           checkForComodification(); //检测集合元素是否执行添加删除操作\n           int i = cursor;\n           if (i &gt;= size)\n               throw new NoSuchElementException();\n           Object[] elementData = ArrayList.this.elementData;\n           if (i &gt;= elementData.length)\n               throw new ConcurrentModificationException();\n           cursor = i + 1;\n           return (E) elementData[lastRet = i];\n       }\n\n       public void remove() {\n           if (lastRet &lt; 0)\n               throw new IllegalStateException();\n           checkForComodification();\n\n           try {\n               ArrayList.this.remove(lastRet);\n               cursor = lastRet;\n               lastRet = -1;\n               expectedModCount = modCount;\n           } catch (IndexOutOfBoundsException ex) {\n               throw new ConcurrentModificationException();\n           }\n       }\n\n       @Override\n       @SuppressWarnings(&quot;unchecked&quot;)\n       public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {\n           Objects.requireNonNull(consumer);\n           final int size = ArrayList.this.size;\n           int i = cursor;\n           if (i &gt;= size) {\n               return;\n           }\n           final Object[] elementData = ArrayList.this.elementData;\n           if (i &gt;= elementData.length) {\n               throw new ConcurrentModificationException();\n           }\n           while (i != size &amp;&amp; modCount == expectedModCount) {\n               consumer.accept((E) elementData[i++]);\n           }\n           // update once at end of iteration to reduce heap write traffic\n           cursor = i;\n           lastRet = i - 1;\n           checkForComodification();\n       }\n        //如果发生添加删除操作，则抛出错误。\n       final void checkForComodification() {\n           if (modCount != expectedModCount)\n               throw new ConcurrentModificationException();\n       }\n   }\n</code></pre>\n<p>​ 对于上述的代码不难看懂，有点疑惑的是 int expectedModCount = modCount;这句代码</p>\n<p>​其实这是集合迭代中的一种<strong>快速失败</strong>机制，这种机制提供迭代过程中集合的安全性。阅读源码​ 就可以知道 ArrayList 中存在 modCount 对象，增删操作都会使 modCount++，通过两者的对比​ 迭代器可以快速的知道迭代过程中是否存在 list.add()类似的操作，存在的话快速失败!</p>\n<h2 id=\"Fail-Fast-快速失败-机制\"><a href=\"#Fail-Fast-快速失败-机制\" class=\"headerlink\" title=\"Fail-Fast(快速失败)机制\"></a>Fail-Fast(快速失败)机制</h2><p>仔细观察上述的各个方法，我们在源码中就会发现一个特别的属性 modCount，API 解释如下：</p>\n<p>​ The number of times this list has been structurally modified. Structural modifications are those​ that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress​ may yield incorrect results.</p>\n<p>记录修改此列表的次数：包括改变列表的结构，改变列表的大小，打乱列表的顺序等使正在进行 迭代产生 错误的结果。</p>\n<p>Tips:仅仅设置元素的值并不是结构的修改</p>\n<p>我们知道的是 ArrayList 是线程不安全的，如果在使用迭代器的过程中有其他的线程修改了 List 就会抛出 ConcurrentModificationException 这就是 Fail-Fast 机制。那么快速失败究竟是个什么意思呢？在 ArrayList 类创建迭代器之后，除非通过迭代器自身 remove 或 add 对列表结构进行修改，否则在其他线程中以任何形式对列表进行修改，迭代器马上会抛出异常，快速失败。</p>\n<h3 id=\"迭代器的好处\"><a href=\"#迭代器的好处\" class=\"headerlink\" title=\"迭代器的好处\"></a>迭代器的好处</h3><h2 id=\"迭代器的好处-1\"><a href=\"#迭代器的好处-1\" class=\"headerlink\" title=\"迭代器的好处\"></a>迭代器的好处</h2><p>​ 通过上述我们明白了迭代是到底是个什么，迭代器的使用也十分的简单。现在简要的总结下使用迭代器的好处吧。</p>\n<p>​ <strong>1、迭代器可以提供统一的迭代方式。</strong></p>\n<p><strong>​ 2、 迭代器也可以在对客户端透明的情况下，提供各种不同的迭代方式。</strong></p>\n<p>​ <strong>3、迭代器提供一种快速失败机制，防止多线程下迭代的不安全操作。</strong></p>\n<p>​ 不过对于第三点尚需注意的是：就像上述事例代码一样，我们不能保证迭代过程中出现<strong>快速失败</strong>的都是因为同步造成的，因此为了保证迭代操作的正确性而去依赖此类异常是错误的！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Iterator-和-Iterable-区别\"><a href=\"#Iterator-和-Iterable-区别\" class=\"headerlink\" title=\"Iterator 和 Iterable 区别\"></a>Iterator 和 Iterable 区别</h1><h3 id=\"Iterator（迭代器）\"><a href=\"#Iterator（迭代器）\" class=\"headerlink\" title=\"Iterator（迭代器）\"></a>Iterator（迭代器）</h3><p>作为一种设计模式，迭代器可以用于遍历一个对象，而开发人员不用去了解这个对象的底层结构。</p>\n<p>这里就不仔细说迭代器这种设计模式，因为我们主要的目的是探索 java 中 Iterator 和 Iterable 之间的区别</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>首先来说一下他们各自是怎么使用，不会用谈什么都是瞎搞。</p>\n<h4 id=\"Iterator-用法\"><a href=\"#Iterator-用法\" class=\"headerlink\" title=\"Iterator 用法\"></a>Iterator 用法</h4><p>首先来说一下 Iterator 这个接口，他定义了迭代器基本的功能。</p>\n<h4 id=\"源码如下\"><a href=\"#源码如下\" class=\"headerlink\" title=\"源码如下\"></a>源码如下</h4><pre><code>package java.util;\n\npublic interface Iterator&lt;E&gt; {\n    boolean hasNext();   //返回是否有下一个元素\n    E next();            //返回下一个元素\n    void remove();         //移除当前元素\n}\n\n\n</code></pre><h4 id=\"如何使用这个接口\"><a href=\"#如何使用这个接口\" class=\"headerlink\" title=\"如何使用这个接口\"></a>如何使用这个接口</h4><pre><code>public class main {\n\n    public static void main(String[] args) {\n        MyIterator mi = new MyIterator();\n        while (mi.hasNext()){\n            System.out.printf(&quot;%s\\t&quot;,mi.next());\n        }\n    }\n}\n\nclass MyIterator implements Iterator&lt;String&gt;{\n    private String[] words = (&quot;And that is how &quot;\n            + &quot;we know the Earth to be banana-shaped.&quot;).split(&quot; &quot;);\n    private int count = 0;\n    public MyIterator() {\n    }\n\n    @Override\n    public boolean hasNext() {\n        return count &lt; words.length;\n    }\n\n    @Override\n    public String next() {\n        return words[count++];\n    }\n}\n</code></pre><p>代码很简单，所以就不过多的解释了，但是有一点需要注意的是，下面这样使用上面定义的 MyIterator 类是错误的，你可以试一下。</p>\n<pre><code>for (String s:new MyIterator){\n            System.out.printf(&quot;%s\\t&quot;,s);\n }\n</code></pre><h3 id=\"Iterable-用法\"><a href=\"#Iterable-用法\" class=\"headerlink\" title=\"Iterable 用法\"></a>Iterable 用法</h3><h4 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h4><pre><code>package java.lang;\n\nimport java.util.Iterator;\n\npublic interface Iterable&lt;T&gt; {\n\n    Iterator&lt;T&gt; iterator();\n}\n</code></pre><h4 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h4><pre><code>public class main {\n\n    public static void main(String[] args) {\n\n      MyIterable myIterable= new MyIterable();\n        Iterator&lt;String&gt; mIterator = myIterable.iterator();\n        for (String s:myIterable){\n            System.out.printf(&quot;%s\\t&quot;,s);\n        }\n    }\n}\n\nclass MyIterable implements Iterable&lt;String&gt;{\n    private String[] words = (&quot;And that is how &quot;\n            + &quot;we know the Earth to be banana-shaped.&quot;).split(&quot; &quot;);\n\n    @Override\n    public Iterator&lt;String&gt; iterator() {\n        return new Iterator&lt;String&gt;() {\n            private int i = 0;\n            @Override\n            public boolean hasNext() {\n                return i &lt; words.length;\n            }\n\n            @Override\n            public String next() {\n                return words[i++];\n            }\n        };\n    }\n}\n</code></pre><p>与上面 Iterator 不同的是，这个类还可以下面这样使用</p>\n<pre><code>        MyIterable mi = new MyIterable().iterator();\n        while (mi.hasNext()){\n            System.out.printf(&quot;%s\\t&quot;,mi.next());\n        } \n</code></pre><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p>基本用法已经说完，相信你也能看出其中的一些区别</p>\n<ol>\n<li>Iterator 是迭代器类(这个类是指定义了迭代器基本需要的方法)，而 Iterable 是接口。 这个从他们的包名就可以看出来。</li>\n</ol>\n<pre><code class=\"Java\">java.lang.Iterable\njava.util.Iterator\n</code></pre>\n<ol>\n<li><p>Iterator 不嫩用于 foreach 循环语句，Iterable 可以</p>\n</li>\n<li><p>为什么一定要实现 Iterable 接口，为什么不直接实现 Iterator 接口呢？</p>\n<p>看一下 JDK 中的集合类，比如 List 一族或者 Set 一族，都是实现了 Iterable 接口，但并不直接实现 Iterator 接口。</p>\n<p>这并不是没有道理的。</p>\n<p>​ 因为 Iterator 接口的核心方法 next()或者 hasNext() 是依赖于迭代器的当前迭代位置的。</p>\n<p>如果 Collection 直接实现 Iterator 接口，势必导致集合对象中包含当前迭代位置的数据(指针)。</p>\n<p>​ 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么 next()方法的结果会变成不可预知。 除非再为 Iterator 接口添加一个 reset()方法，用来重置当前迭代位置。 但即时这样，Collection 也只能同时存在一个当前迭代位置。</p>\n<p>而 Iterable 则不然，每次调用都会返回一个从头开始计数的迭代器。</p>\n<p>多个迭代器是互不干扰的</p>\n</li>\n</ol>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p>你在看 ArrayList 源码的时候，你会发现这样一段代码</p>\n<pre><code class=\"Java\">   private class Itr implements Iterator&lt;E&gt; {\n       int cursor;       // 返回下一个元素的索引\n\n         int lastRet = -1; // 返回最后一个元素的索引，如果空，返回-1\n\n       int expectedModCount = modCount; //用于检测当前集合是否执行了添加删除操作，其中modCount，是当前集合中元素的个数\n\n       public boolean hasNext() {\n           return cursor != size;\n       }\n\n       @SuppressWarnings(&quot;unchecked&quot;)\n       public E next() {\n           checkForComodification(); //检测集合元素是否执行添加删除操作\n           int i = cursor;\n           if (i &gt;= size)\n               throw new NoSuchElementException();\n           Object[] elementData = ArrayList.this.elementData;\n           if (i &gt;= elementData.length)\n               throw new ConcurrentModificationException();\n           cursor = i + 1;\n           return (E) elementData[lastRet = i];\n       }\n\n       public void remove() {\n           if (lastRet &lt; 0)\n               throw new IllegalStateException();\n           checkForComodification();\n\n           try {\n               ArrayList.this.remove(lastRet);\n               cursor = lastRet;\n               lastRet = -1;\n               expectedModCount = modCount;\n           } catch (IndexOutOfBoundsException ex) {\n               throw new ConcurrentModificationException();\n           }\n       }\n\n       @Override\n       @SuppressWarnings(&quot;unchecked&quot;)\n       public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {\n           Objects.requireNonNull(consumer);\n           final int size = ArrayList.this.size;\n           int i = cursor;\n           if (i &gt;= size) {\n               return;\n           }\n           final Object[] elementData = ArrayList.this.elementData;\n           if (i &gt;= elementData.length) {\n               throw new ConcurrentModificationException();\n           }\n           while (i != size &amp;&amp; modCount == expectedModCount) {\n               consumer.accept((E) elementData[i++]);\n           }\n           // update once at end of iteration to reduce heap write traffic\n           cursor = i;\n           lastRet = i - 1;\n           checkForComodification();\n       }\n        //如果发生添加删除操作，则抛出错误。\n       final void checkForComodification() {\n           if (modCount != expectedModCount)\n               throw new ConcurrentModificationException();\n       }\n   }\n</code></pre>\n<p>​ 对于上述的代码不难看懂，有点疑惑的是 int expectedModCount = modCount;这句代码</p>\n<p>​其实这是集合迭代中的一种<strong>快速失败</strong>机制，这种机制提供迭代过程中集合的安全性。阅读源码​ 就可以知道 ArrayList 中存在 modCount 对象，增删操作都会使 modCount++，通过两者的对比​ 迭代器可以快速的知道迭代过程中是否存在 list.add()类似的操作，存在的话快速失败!</p>\n<h2 id=\"Fail-Fast-快速失败-机制\"><a href=\"#Fail-Fast-快速失败-机制\" class=\"headerlink\" title=\"Fail-Fast(快速失败)机制\"></a>Fail-Fast(快速失败)机制</h2><p>仔细观察上述的各个方法，我们在源码中就会发现一个特别的属性 modCount，API 解释如下：</p>\n<p>​ The number of times this list has been structurally modified. Structural modifications are those​ that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress​ may yield incorrect results.</p>\n<p>记录修改此列表的次数：包括改变列表的结构，改变列表的大小，打乱列表的顺序等使正在进行 迭代产生 错误的结果。</p>\n<p>Tips:仅仅设置元素的值并不是结构的修改</p>\n<p>我们知道的是 ArrayList 是线程不安全的，如果在使用迭代器的过程中有其他的线程修改了 List 就会抛出 ConcurrentModificationException 这就是 Fail-Fast 机制。那么快速失败究竟是个什么意思呢？在 ArrayList 类创建迭代器之后，除非通过迭代器自身 remove 或 add 对列表结构进行修改，否则在其他线程中以任何形式对列表进行修改，迭代器马上会抛出异常，快速失败。</p>\n<h3 id=\"迭代器的好处\"><a href=\"#迭代器的好处\" class=\"headerlink\" title=\"迭代器的好处\"></a>迭代器的好处</h3><h2 id=\"迭代器的好处-1\"><a href=\"#迭代器的好处-1\" class=\"headerlink\" title=\"迭代器的好处\"></a>迭代器的好处</h2><p>​ 通过上述我们明白了迭代是到底是个什么，迭代器的使用也十分的简单。现在简要的总结下使用迭代器的好处吧。</p>\n<p>​ <strong>1、迭代器可以提供统一的迭代方式。</strong></p>\n<p><strong>​ 2、 迭代器也可以在对客户端透明的情况下，提供各种不同的迭代方式。</strong></p>\n<p>​ <strong>3、迭代器提供一种快速失败机制，防止多线程下迭代的不安全操作。</strong></p>\n<p>​ 不过对于第三点尚需注意的是：就像上述事例代码一样，我们不能保证迭代过程中出现<strong>快速失败</strong>的都是因为同步造成的，因此为了保证迭代操作的正确性而去依赖此类异常是错误的！</p>\n"},{"abbrlink":4,"title":"java多线系列之 04 线程让步和join","author":"zhangke","date":"2018-07-13T03:09:00.000Z","_content":"# java 多线系列之 04 线程让步和join\n\n### 概要\n\n>1.  yield()介绍以及示例\n>2.  yield() 与 wait()的比较\n>3.  join() 介绍及示例\n\n### 1. yield介绍以及示例\n\n>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！\n>\n>下面，通过示例查看它的用法。\n>\n>```\n>// YieldTest.java的源码\n>class ThreadA extends Thread{\n>    public ThreadA(String name){ \n>        super(name); \n>    } \n>    public synchronized void run(){ \n>        for(int i=0; i <10; i++){ \n>            System.out.printf(\"%s [%d]:%d\\n\", this.getName(), \n>            \t\t\t\t\tthis.getPriority(), i); \n>            // i整除4时，调用yield\n>            if (i%4 == 0)\n>                Thread.yield();\n>        } \n>    } \n>} \n>\n>public class YieldTest{ \n>    public static void main(String[] args){ \n>        ThreadA t1 = new ThreadA(\"t1\"); \n>        ThreadA t2 = new ThreadA(\"t2\"); \n>        t1.start(); \n>        t2.start();\n>    } \n>}\n>```\n>\n>运行结果：（你的可能和我不相同）\n>\n>```\n>t1 [5]:0\n>t2 [5]:0\n>t1 [5]:1\n>t1 [5]:2\n>t1 [5]:3\n>t1 [5]:4\n>t1 [5]:5\n>t1 [5]:6\n>t1 [5]:7\n>t1 [5]:8\n>t1 [5]:9\n>t2 [5]:1\n>t2 [5]:2\n>t2 [5]:3\n>t2 [5]:4\n>t2 [5]:5\n>t2 [5]:6\n>t2 [5]:7\n>t2 [5]:8\n>t2 [5]:9\n>```\n>\n>**结果说明**： “线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。\n\n###  2. **yield() 与 wait()的比较**\n\n>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是： \n>\n>(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。\n>\n> (02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。\n>\n>下面通过示例演示yield()是不会释放锁的。\n>\n>```\n>// YieldLockTest.java 的源码\n>public class YieldLockTest{ \n>\n>    private static Object obj = new Object();\n>\n>    public static void main(String[] args){ \n>        ThreadA t1 = new ThreadA(\"t1\"); \n>        ThreadA t2 = new ThreadA(\"t2\"); \n>        t1.start(); \n>        t2.start();\n>    } \n>\n>    static class ThreadA extends Thread{\n>        public ThreadA(String name){ \n>            super(name); \n>        } \n>        public void run(){ \n>            // 获取obj对象的同步锁\n>            synchronized (obj) {\n>                for(int i=0; i <10; i++){ \n>                    System.out.printf(\"%s [%d]:%d\\n\", this.getName(), this.getPriority(), i); \n>                    // i整除4时，调用yield\n>                    if (i%4 == 0)\n>                        Thread.yield();\n>                }\n>            }\n>        } \n>    } \n>}\n>```\n>\n>运行结果\n>\n>```\n>t1 [5]:0\n>t1 [5]:1\n>t1 [5]:2\n>t1 [5]:3\n>t1 [5]:4\n>t1 [5]:5\n>t1 [5]:6\n>t1 [5]:7\n>t1 [5]:8\n>t1 [5]:9\n>t2 [5]:0\n>t2 [5]:1\n>t2 [5]:2\n>t2 [5]:3\n>t2 [5]:4\n>t2 [5]:5\n>t2 [5]:6\n>t2 [5]:7\n>t2 [5]:8\n>t2 [5]:9\n>```\n>\n>**结果说明**： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！\n\n### 3. join()介绍及示例\n\n>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解：\n>\n>```\n>// 主线程\n>public class Father extends Thread {\n>    public void run() {\n>        Son s = new Son();\n>        s.start();\n>        s.join();\n>        ...\n>    }\n>}\n>// 子线程\n>public class Son extends Thread {\n>    public void run() {\n>        ...\n>    }\n>}\n>```\n>\n>**说明**：\n>上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。\n>在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！\n>\n>join源码分析\n>\n>````\n>public final void join() throws InterruptedException {\n>    join(0);\n>}\n>\n>public final synchronized void join(long millis)\n>throws InterruptedException {\n>    long base = System.currentTimeMillis();\n>    long now = 0;\n>\n>    if (millis < 0) {\n>        throw new IllegalArgumentException(\"timeout value is negative\");\n>    }\n>\n>    if (millis == 0) {\n>        while (isAlive()) {\n>            wait(0);\n>        }\n>    } else {\n>        while (isAlive()) {\n>            long delay = millis - now;\n>            if (delay <= 0) {\n>                break;\n>            }\n>            wait(delay);\n>            now = System.currentTimeMillis() - base;\n>        }\n>    }\n>}\n>````\n>\n>**说明**： \n>\n>从代码中，我们可以发现。当millis==0时，会进入while(isAlive())循环；\n>\n>即只要子线程是活的，主线程就不停的等待。 我们根据上面解释join()作用时的代码来理解join()的用法！\n>\n> **问题**： 虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让\"子线程等待才对(因为调用子线程对象s的wait方法嘛)\"？ \n>\n>**答案**：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！\n>\n>join示例\n>\n>```\n>// JoinTest.java的源码\n>public class JoinTest{ \n>\n>    public static void main(String[] args){ \n>        try {\n>            ThreadA t1 = new ThreadA(\"t1\"); // 新建“线程t1”\n>\n>            t1.start();                     // 启动“线程t1”\n>            t1.join();                        // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成”\n>            System.out.printf(\"%s finish\\n\", Thread.currentThread().getName()); \n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>    } \n>\n>    static class ThreadA extends Thread{\n>\n>        public ThreadA(String name){ \n>            super(name); \n>        } \n>        public void run(){ \n>            System.out.printf(\"%s start\\n\", this.getName()); \n>\n>            // 延时操作\n>            for(int i=0; i <1000000; i++)\n>               ;\n>\n>            System.out.printf(\"%s finish\\n\", this.getName()); \n>        } \n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 start\n>t1 finish\n>main finish\n>```\n>\n>**结果说明**：\n>运行流程如图 \n>(01) 在“主线程main”中通过 new ThreadA(\"t1\") 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。\n>(02) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。\n>\n>![](https://images0.cnblogs.com/blog/497634/201312/18184312-a72a58e2bda54b17bf669f325ecda377.png)\n>\n>\n>\n>\n\n","source":"_posts/java 多线系列之 04 线程让步和join.md","raw":"abbrlink: 4\ntitle: java多线系列之 04 线程让步和join\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-13 11:09:00\n---\n# java 多线系列之 04 线程让步和join\n\n### 概要\n\n>1.  yield()介绍以及示例\n>2.  yield() 与 wait()的比较\n>3.  join() 介绍及示例\n\n### 1. yield介绍以及示例\n\n>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！\n>\n>下面，通过示例查看它的用法。\n>\n>```\n>// YieldTest.java的源码\n>class ThreadA extends Thread{\n>    public ThreadA(String name){ \n>        super(name); \n>    } \n>    public synchronized void run(){ \n>        for(int i=0; i <10; i++){ \n>            System.out.printf(\"%s [%d]:%d\\n\", this.getName(), \n>            \t\t\t\t\tthis.getPriority(), i); \n>            // i整除4时，调用yield\n>            if (i%4 == 0)\n>                Thread.yield();\n>        } \n>    } \n>} \n>\n>public class YieldTest{ \n>    public static void main(String[] args){ \n>        ThreadA t1 = new ThreadA(\"t1\"); \n>        ThreadA t2 = new ThreadA(\"t2\"); \n>        t1.start(); \n>        t2.start();\n>    } \n>}\n>```\n>\n>运行结果：（你的可能和我不相同）\n>\n>```\n>t1 [5]:0\n>t2 [5]:0\n>t1 [5]:1\n>t1 [5]:2\n>t1 [5]:3\n>t1 [5]:4\n>t1 [5]:5\n>t1 [5]:6\n>t1 [5]:7\n>t1 [5]:8\n>t1 [5]:9\n>t2 [5]:1\n>t2 [5]:2\n>t2 [5]:3\n>t2 [5]:4\n>t2 [5]:5\n>t2 [5]:6\n>t2 [5]:7\n>t2 [5]:8\n>t2 [5]:9\n>```\n>\n>**结果说明**： “线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。\n\n###  2. **yield() 与 wait()的比较**\n\n>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是： \n>\n>(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。\n>\n> (02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。\n>\n>下面通过示例演示yield()是不会释放锁的。\n>\n>```\n>// YieldLockTest.java 的源码\n>public class YieldLockTest{ \n>\n>    private static Object obj = new Object();\n>\n>    public static void main(String[] args){ \n>        ThreadA t1 = new ThreadA(\"t1\"); \n>        ThreadA t2 = new ThreadA(\"t2\"); \n>        t1.start(); \n>        t2.start();\n>    } \n>\n>    static class ThreadA extends Thread{\n>        public ThreadA(String name){ \n>            super(name); \n>        } \n>        public void run(){ \n>            // 获取obj对象的同步锁\n>            synchronized (obj) {\n>                for(int i=0; i <10; i++){ \n>                    System.out.printf(\"%s [%d]:%d\\n\", this.getName(), this.getPriority(), i); \n>                    // i整除4时，调用yield\n>                    if (i%4 == 0)\n>                        Thread.yield();\n>                }\n>            }\n>        } \n>    } \n>}\n>```\n>\n>运行结果\n>\n>```\n>t1 [5]:0\n>t1 [5]:1\n>t1 [5]:2\n>t1 [5]:3\n>t1 [5]:4\n>t1 [5]:5\n>t1 [5]:6\n>t1 [5]:7\n>t1 [5]:8\n>t1 [5]:9\n>t2 [5]:0\n>t2 [5]:1\n>t2 [5]:2\n>t2 [5]:3\n>t2 [5]:4\n>t2 [5]:5\n>t2 [5]:6\n>t2 [5]:7\n>t2 [5]:8\n>t2 [5]:9\n>```\n>\n>**结果说明**： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！\n\n### 3. join()介绍及示例\n\n>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解：\n>\n>```\n>// 主线程\n>public class Father extends Thread {\n>    public void run() {\n>        Son s = new Son();\n>        s.start();\n>        s.join();\n>        ...\n>    }\n>}\n>// 子线程\n>public class Son extends Thread {\n>    public void run() {\n>        ...\n>    }\n>}\n>```\n>\n>**说明**：\n>上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。\n>在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！\n>\n>join源码分析\n>\n>````\n>public final void join() throws InterruptedException {\n>    join(0);\n>}\n>\n>public final synchronized void join(long millis)\n>throws InterruptedException {\n>    long base = System.currentTimeMillis();\n>    long now = 0;\n>\n>    if (millis < 0) {\n>        throw new IllegalArgumentException(\"timeout value is negative\");\n>    }\n>\n>    if (millis == 0) {\n>        while (isAlive()) {\n>            wait(0);\n>        }\n>    } else {\n>        while (isAlive()) {\n>            long delay = millis - now;\n>            if (delay <= 0) {\n>                break;\n>            }\n>            wait(delay);\n>            now = System.currentTimeMillis() - base;\n>        }\n>    }\n>}\n>````\n>\n>**说明**： \n>\n>从代码中，我们可以发现。当millis==0时，会进入while(isAlive())循环；\n>\n>即只要子线程是活的，主线程就不停的等待。 我们根据上面解释join()作用时的代码来理解join()的用法！\n>\n> **问题**： 虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让\"子线程等待才对(因为调用子线程对象s的wait方法嘛)\"？ \n>\n>**答案**：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！\n>\n>join示例\n>\n>```\n>// JoinTest.java的源码\n>public class JoinTest{ \n>\n>    public static void main(String[] args){ \n>        try {\n>            ThreadA t1 = new ThreadA(\"t1\"); // 新建“线程t1”\n>\n>            t1.start();                     // 启动“线程t1”\n>            t1.join();                        // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成”\n>            System.out.printf(\"%s finish\\n\", Thread.currentThread().getName()); \n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>    } \n>\n>    static class ThreadA extends Thread{\n>\n>        public ThreadA(String name){ \n>            super(name); \n>        } \n>        public void run(){ \n>            System.out.printf(\"%s start\\n\", this.getName()); \n>\n>            // 延时操作\n>            for(int i=0; i <1000000; i++)\n>               ;\n>\n>            System.out.printf(\"%s finish\\n\", this.getName()); \n>        } \n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 start\n>t1 finish\n>main finish\n>```\n>\n>**结果说明**：\n>运行流程如图 \n>(01) 在“主线程main”中通过 new ThreadA(\"t1\") 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。\n>(02) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。\n>\n>![](https://images0.cnblogs.com/blog/497634/201312/18184312-a72a58e2bda54b17bf669f325ecda377.png)\n>\n>\n>\n>\n\n","slug":"java 多线系列之 04 线程让步和join","published":1,"updated":"2019-01-04T01:48:59.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovp9000t9q1usbhuj4dj","content":"<h1 id=\"java-多线系列之-04-线程让步和join\"><a href=\"#java-多线系列之-04-线程让步和join\" class=\"headerlink\" title=\"java 多线系列之 04 线程让步和join\"></a>java 多线系列之 04 线程让步和join</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>yield()介绍以及示例</li>\n<li>yield() 与 wait()的比较</li>\n<li>join() 介绍及示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-yield介绍以及示例\"><a href=\"#1-yield介绍以及示例\" class=\"headerlink\" title=\"1. yield介绍以及示例\"></a>1. yield介绍以及示例</h3><blockquote>\n<p>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！</p>\n<p>下面，通过示例查看它的用法。</p>\n<pre><code>// YieldTest.java的源码\nclass ThreadA extends Thread{\n   public ThreadA(String name){ \n       super(name); \n   } \n   public synchronized void run(){ \n       for(int i=0; i &lt;10; i++){ \n           System.out.printf(&quot;%s [%d]:%d\\n&quot;, this.getName(), \n                               this.getPriority(), i); \n           // i整除4时，调用yield\n           if (i%4 == 0)\n               Thread.yield();\n       } \n   } \n} \n\npublic class YieldTest{ \n   public static void main(String[] args){ \n       ThreadA t1 = new ThreadA(&quot;t1&quot;); \n       ThreadA t2 = new ThreadA(&quot;t2&quot;); \n       t1.start(); \n       t2.start();\n   } \n}\n</code></pre><p>运行结果：（你的可能和我不相同）</p>\n<pre><code>t1 [5]:0\nt2 [5]:0\nt1 [5]:1\nt1 [5]:2\nt1 [5]:3\nt1 [5]:4\nt1 [5]:5\nt1 [5]:6\nt1 [5]:7\nt1 [5]:8\nt1 [5]:9\nt2 [5]:1\nt2 [5]:2\nt2 [5]:3\nt2 [5]:4\nt2 [5]:5\nt2 [5]:6\nt2 [5]:7\nt2 [5]:8\nt2 [5]:9\n</code></pre><p><strong>结果说明</strong>： “线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。</p>\n</blockquote>\n<h3 id=\"2-yield-与-wait-的比较\"><a href=\"#2-yield-与-wait-的比较\" class=\"headerlink\" title=\"2. yield() 与 wait()的比较\"></a>2. <strong>yield() 与 wait()的比较</strong></h3><blockquote>\n<p>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是： </p>\n<p>(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。</p>\n<p>(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。</p>\n<p>下面通过示例演示yield()是不会释放锁的。</p>\n<pre><code>// YieldLockTest.java 的源码\npublic class YieldLockTest{ \n\n   private static Object obj = new Object();\n\n   public static void main(String[] args){ \n       ThreadA t1 = new ThreadA(&quot;t1&quot;); \n       ThreadA t2 = new ThreadA(&quot;t2&quot;); \n       t1.start(); \n       t2.start();\n   } \n\n   static class ThreadA extends Thread{\n       public ThreadA(String name){ \n           super(name); \n       } \n       public void run(){ \n           // 获取obj对象的同步锁\n           synchronized (obj) {\n               for(int i=0; i &lt;10; i++){ \n                   System.out.printf(&quot;%s [%d]:%d\\n&quot;, this.getName(), this.getPriority(), i); \n                   // i整除4时，调用yield\n                   if (i%4 == 0)\n                       Thread.yield();\n               }\n           }\n       } \n   } \n}\n</code></pre><p>运行结果</p>\n<pre><code>t1 [5]:0\nt1 [5]:1\nt1 [5]:2\nt1 [5]:3\nt1 [5]:4\nt1 [5]:5\nt1 [5]:6\nt1 [5]:7\nt1 [5]:8\nt1 [5]:9\nt2 [5]:0\nt2 [5]:1\nt2 [5]:2\nt2 [5]:3\nt2 [5]:4\nt2 [5]:5\nt2 [5]:6\nt2 [5]:7\nt2 [5]:8\nt2 [5]:9\n</code></pre><p><strong>结果说明</strong>： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！</p>\n</blockquote>\n<h3 id=\"3-join-介绍及示例\"><a href=\"#3-join-介绍及示例\" class=\"headerlink\" title=\"3. join()介绍及示例\"></a>3. join()介绍及示例</h3><blockquote>\n<p>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解：</p>\n<pre><code>// 主线程\npublic class Father extends Thread {\n   public void run() {\n       Son s = new Son();\n       s.start();\n       s.join();\n       ...\n   }\n}\n// 子线程\npublic class Son extends Thread {\n   public void run() {\n       ...\n   }\n}\n</code></pre><p><strong>说明</strong>：<br>上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。<br>在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！</p>\n<p>join源码分析</p>\n<pre><code>public final void join() throws InterruptedException {\n   join(0);\n}\n\npublic final synchronized void join(long millis)\nthrows InterruptedException {\n   long base = System.currentTimeMillis();\n   long now = 0;\n\n   if (millis &lt; 0) {\n       throw new IllegalArgumentException(&quot;timeout value is negative&quot;);\n   }\n\n   if (millis == 0) {\n       while (isAlive()) {\n           wait(0);\n       }\n   } else {\n       while (isAlive()) {\n           long delay = millis - now;\n           if (delay &lt;= 0) {\n               break;\n           }\n           wait(delay);\n           now = System.currentTimeMillis() - base;\n       }\n   }\n}\n</code></pre><p><strong>说明</strong>： </p>\n<p>从代码中，我们可以发现。当millis==0时，会进入while(isAlive())循环；</p>\n<p>即只要子线程是活的，主线程就不停的等待。 我们根据上面解释join()作用时的代码来理解join()的用法！</p>\n<p><strong>问题</strong>： 虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让”子线程等待才对(因为调用子线程对象s的wait方法嘛)”？ </p>\n<p><strong>答案</strong>：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！</p>\n<p>join示例</p>\n<pre><code>// JoinTest.java的源码\npublic class JoinTest{ \n\n   public static void main(String[] args){ \n       try {\n           ThreadA t1 = new ThreadA(&quot;t1&quot;); // 新建“线程t1”\n\n           t1.start();                     // 启动“线程t1”\n           t1.join();                        // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成”\n           System.out.printf(&quot;%s finish\\n&quot;, Thread.currentThread().getName()); \n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n   } \n\n   static class ThreadA extends Thread{\n\n       public ThreadA(String name){ \n           super(name); \n       } \n       public void run(){ \n           System.out.printf(&quot;%s start\\n&quot;, this.getName()); \n\n           // 延时操作\n           for(int i=0; i &lt;1000000; i++)\n              ;\n\n           System.out.printf(&quot;%s finish\\n&quot;, this.getName()); \n       } \n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 start\nt1 finish\nmain finish\n</code></pre><p><strong>结果说明</strong>：<br>运行流程如图<br>(01) 在“主线程main”中通过 new ThreadA(“t1”) 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。<br>(02) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18184312-a72a58e2bda54b17bf669f325ecda377.png\" alt=\"\"></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java-多线系列之-04-线程让步和join\"><a href=\"#java-多线系列之-04-线程让步和join\" class=\"headerlink\" title=\"java 多线系列之 04 线程让步和join\"></a>java 多线系列之 04 线程让步和join</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>yield()介绍以及示例</li>\n<li>yield() 与 wait()的比较</li>\n<li>join() 介绍及示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-yield介绍以及示例\"><a href=\"#1-yield介绍以及示例\" class=\"headerlink\" title=\"1. yield介绍以及示例\"></a>1. yield介绍以及示例</h3><blockquote>\n<p>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！</p>\n<p>下面，通过示例查看它的用法。</p>\n<pre><code>// YieldTest.java的源码\nclass ThreadA extends Thread{\n   public ThreadA(String name){ \n       super(name); \n   } \n   public synchronized void run(){ \n       for(int i=0; i &lt;10; i++){ \n           System.out.printf(&quot;%s [%d]:%d\\n&quot;, this.getName(), \n                               this.getPriority(), i); \n           // i整除4时，调用yield\n           if (i%4 == 0)\n               Thread.yield();\n       } \n   } \n} \n\npublic class YieldTest{ \n   public static void main(String[] args){ \n       ThreadA t1 = new ThreadA(&quot;t1&quot;); \n       ThreadA t2 = new ThreadA(&quot;t2&quot;); \n       t1.start(); \n       t2.start();\n   } \n}\n</code></pre><p>运行结果：（你的可能和我不相同）</p>\n<pre><code>t1 [5]:0\nt2 [5]:0\nt1 [5]:1\nt1 [5]:2\nt1 [5]:3\nt1 [5]:4\nt1 [5]:5\nt1 [5]:6\nt1 [5]:7\nt1 [5]:8\nt1 [5]:9\nt2 [5]:1\nt2 [5]:2\nt2 [5]:3\nt2 [5]:4\nt2 [5]:5\nt2 [5]:6\nt2 [5]:7\nt2 [5]:8\nt2 [5]:9\n</code></pre><p><strong>结果说明</strong>： “线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。</p>\n</blockquote>\n<h3 id=\"2-yield-与-wait-的比较\"><a href=\"#2-yield-与-wait-的比较\" class=\"headerlink\" title=\"2. yield() 与 wait()的比较\"></a>2. <strong>yield() 与 wait()的比较</strong></h3><blockquote>\n<p>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是： </p>\n<p>(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。</p>\n<p>(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。</p>\n<p>下面通过示例演示yield()是不会释放锁的。</p>\n<pre><code>// YieldLockTest.java 的源码\npublic class YieldLockTest{ \n\n   private static Object obj = new Object();\n\n   public static void main(String[] args){ \n       ThreadA t1 = new ThreadA(&quot;t1&quot;); \n       ThreadA t2 = new ThreadA(&quot;t2&quot;); \n       t1.start(); \n       t2.start();\n   } \n\n   static class ThreadA extends Thread{\n       public ThreadA(String name){ \n           super(name); \n       } \n       public void run(){ \n           // 获取obj对象的同步锁\n           synchronized (obj) {\n               for(int i=0; i &lt;10; i++){ \n                   System.out.printf(&quot;%s [%d]:%d\\n&quot;, this.getName(), this.getPriority(), i); \n                   // i整除4时，调用yield\n                   if (i%4 == 0)\n                       Thread.yield();\n               }\n           }\n       } \n   } \n}\n</code></pre><p>运行结果</p>\n<pre><code>t1 [5]:0\nt1 [5]:1\nt1 [5]:2\nt1 [5]:3\nt1 [5]:4\nt1 [5]:5\nt1 [5]:6\nt1 [5]:7\nt1 [5]:8\nt1 [5]:9\nt2 [5]:0\nt2 [5]:1\nt2 [5]:2\nt2 [5]:3\nt2 [5]:4\nt2 [5]:5\nt2 [5]:6\nt2 [5]:7\nt2 [5]:8\nt2 [5]:9\n</code></pre><p><strong>结果说明</strong>： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！</p>\n</blockquote>\n<h3 id=\"3-join-介绍及示例\"><a href=\"#3-join-介绍及示例\" class=\"headerlink\" title=\"3. join()介绍及示例\"></a>3. join()介绍及示例</h3><blockquote>\n<p>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解：</p>\n<pre><code>// 主线程\npublic class Father extends Thread {\n   public void run() {\n       Son s = new Son();\n       s.start();\n       s.join();\n       ...\n   }\n}\n// 子线程\npublic class Son extends Thread {\n   public void run() {\n       ...\n   }\n}\n</code></pre><p><strong>说明</strong>：<br>上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。<br>在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！</p>\n<p>join源码分析</p>\n<pre><code>public final void join() throws InterruptedException {\n   join(0);\n}\n\npublic final synchronized void join(long millis)\nthrows InterruptedException {\n   long base = System.currentTimeMillis();\n   long now = 0;\n\n   if (millis &lt; 0) {\n       throw new IllegalArgumentException(&quot;timeout value is negative&quot;);\n   }\n\n   if (millis == 0) {\n       while (isAlive()) {\n           wait(0);\n       }\n   } else {\n       while (isAlive()) {\n           long delay = millis - now;\n           if (delay &lt;= 0) {\n               break;\n           }\n           wait(delay);\n           now = System.currentTimeMillis() - base;\n       }\n   }\n}\n</code></pre><p><strong>说明</strong>： </p>\n<p>从代码中，我们可以发现。当millis==0时，会进入while(isAlive())循环；</p>\n<p>即只要子线程是活的，主线程就不停的等待。 我们根据上面解释join()作用时的代码来理解join()的用法！</p>\n<p><strong>问题</strong>： 虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让”子线程等待才对(因为调用子线程对象s的wait方法嘛)”？ </p>\n<p><strong>答案</strong>：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！</p>\n<p>join示例</p>\n<pre><code>// JoinTest.java的源码\npublic class JoinTest{ \n\n   public static void main(String[] args){ \n       try {\n           ThreadA t1 = new ThreadA(&quot;t1&quot;); // 新建“线程t1”\n\n           t1.start();                     // 启动“线程t1”\n           t1.join();                        // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成”\n           System.out.printf(&quot;%s finish\\n&quot;, Thread.currentThread().getName()); \n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n   } \n\n   static class ThreadA extends Thread{\n\n       public ThreadA(String name){ \n           super(name); \n       } \n       public void run(){ \n           System.out.printf(&quot;%s start\\n&quot;, this.getName()); \n\n           // 延时操作\n           for(int i=0; i &lt;1000000; i++)\n              ;\n\n           System.out.printf(&quot;%s finish\\n&quot;, this.getName()); \n       } \n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 start\nt1 finish\nmain finish\n</code></pre><p><strong>结果说明</strong>：<br>运行流程如图<br>(01) 在“主线程main”中通过 new ThreadA(“t1”) 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。<br>(02) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18184312-a72a58e2bda54b17bf669f325ecda377.png\" alt=\"\"></p>\n</blockquote>\n"},{"abbrlink":19,"title":"java 打包技术之jar文件","author":"zhangke","date":"2019-01-08T00:55:00.000Z","_content":"# java 打包技术之jar文件\n\n### 概述\n\n1. jar技术简介及使用\n2. Manifest文件\n\n### jar技术简介及使用\n\n本文主要是参照[Lesson: Packaging Programs in JAR Files](https://docs.oracle.com/javase/tutorial/deployment/jar/apiindex.html)来写，如果你的英文不错，可以直接看这个java官方教程。\n\n在开始看下文你需要确认你安装的jdk环境带有jar命令，只需要在命令行中输入**jar -h**看看能不能找到命令即可。如果你安装的是oracle JDK，那么这个命令已经内置在java开发套件中。\n\n下文所使用的源代码地址[gihub](https://github.com/fengxiutianya/blogsource/tree/master/jarstudy)\n<!-- more -->\n**jar技术是什么以及可以用来干什么？**\n\n官方给出的解释如下：JAR文件以zip文件格式打包，因此您可以将其用于无损数据压缩、归档、解压缩和归档解包等任务。这些任务是JAR文件最常见的用途之一，您只需使用这些基本特性就可以实现许多JAR文件的好处。\n\n我这里先不解释这句话，先看看例子，最后我们来总结一些自己理解的jar技术。\n\n#### 创建jar文件\n\n基本的命令格式\n\n```\njar cf jar-file input-file(s)\n```\n\n命令解释：\n\n1. `c` :代表创建一个jar文件\n2. `f`: 代表将创建的jar文件输入到指定的文件而不是stdout\n3. `jar-file`： 表示创建这个jar文件的名字，通常是以jar后缀结尾，但这不是必须。\n4. `input-file(s)`: 代表要包含在jar文件包中的一个或更多的文件，如果是多个文件，以空格隔开，也可以使用通配符`*`来表示所有的文件，如果指定的是文件夹，将递归的将此文件夹中所有的文件都打包进jar中。\n\n参数`c`和`f`的顺序可以是任意的。此命令还会创建一个默认的manifest文件（这个后面会说）。\n\n下面这些参数都是可选的，可以和上面一起使用\n\n|  可选项   |                             意义                             |\n| :-------: | :----------------------------------------------------------: |\n|     v     |                当创建jar文件时，打印创建过程                 |\n| 0（zero） |                          不压缩文件                          |\n|     M     |                   不创建默认的manifest文件                   |\n|     m     | 用来包含指定manifest信息从指定文件中<br />使用格式如下<br />`jar cmf jar-file existing-manifest input-file(s)` |\n|    -C     |               用于修改打包过程中文件的具体位置               |\n\n具体例子:\n\n文件夹内容如下\n\n```\ndemo1\n\tMain.class\n\timages\n\t\ttest.png\n\t\tico.gif \n\taudio\n\t\ttest.log\n```\n\n\n\n打包所有文件到一个单个jar文件，命令如下：\n\n```\njar cvf demo1.jar Main.clss audio images\n```\n\n执行命令结果\n\n```\n已添加清单\n正在添加: Main.class(输入 = 409) (输出 = 282)(压缩了 31%)\n正在添加: audio/(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: images/(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: images/test.png(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: images/ico.gif(输入 = 0) (输出 = 0)(存储了 0%)\n```\n\n从上面的结果可以看出，这个命令在打包过程中压缩了文件。\n\n如果不想压缩使用如下命令\n\n```\njar cvf0 demo1.jar Main.clss audio images\n```\n\n如果打包的是整个文件夹下的内容，也可以采用下面的命令\n\n```\njar cvf demo1.jar *\n```\n\n如果你希望在打包过程中改变某个文件的位置，可以使用`-C`参数，注意这里是大写的C\n\n```\njar cvf demo1.jar Main.class -C audio . -C images .\n```\n\n打包之后，demo1.jar包中的文件位置如下\n\n```\nMETA-INF/\nMETA-INF/MANIFEST.MF\nMain.class\ntest.log\ntest.png\nico.gif\n```\n\n如果没有使用`-C`则包中的文件位置如下\n\n```\nMETA-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\n```\n\n#### 查看jar文件的内容\n\n这个也是我上面为什么能显示包中文件位置使用的命令。\n\n基本命令格式\n\n```\njar tf jar-file\n```\n\n命令解释\n\n1. `t`: 表示显示jar文件的目录\n2. `f`:表示显示的jar文件在命令的参数中\n3. Jar-file:显示的文件的具体位置\n\n具体例子\n\n```\njar tf demo1.jar\n```\n\n输出结果\n\n```\nMETA-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\n```\n\n使用选项`V`也可以显示额外的信息，具体的就不演示。\n\n#### 解压jar文件的内容\n\n基本的命令格式\n\n```ba&#39;sh\njar xf jar-file [archived-file(s)]\n```\n\n命令解释：\n\n1. `x`:表示解压这个jar\n\n2. `[archived-file(s)]`:如果没有这个参数，则解压所有的文件，如果有这个文件解压所有的文件\n\n   其他的和上面的命令一样\n\n具体例子\n\n```bash\n## 解压所有的内容\njar xf demo1.jar\n\n## 解压指定的文件\njar xf demo1.jar Main.class images/ico.gif\n\n```\n\n上面的命令会解压所有的文件或者指定的文件到当前目录中，如果当前目录中不存在则创建。\n\n#### 更新jar文件\n\n基本的命令格式\n\n```\njar uf jar-file input-file(s)\n```\n\n命令解释：\n\n1. `u`:表示更新文件\n\n其他选项和参数与上面一样\n\n例子\n\n**demo1.jar**的内容如下\n\n```\nMETA-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\n```\n\n执行下面命令\n\n```\njar uf demo1.jar ../demo2/tem.log\n```\n\n**demo1.jar**文件内容如下\n\n```\nMETA-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\ndemo2/tem.log\n```\n\n#### 运行jar\n\n如果你看到这里可以跳过，先看后面的内容然后再来看这一块的内容。\n\n如果你希望你打包的jar可以运行，那么就需要在mainfest文件中添加这样一行内容**Main-class: 入口函数，也就是main函数所在的类**，具体怎么添加可以看下文。\n\n运行命令\n\n```\njava -jar jar-filename\n```\n**总结：**其实jar文件就是按照某个特定格式打包的文件，和普通的zip打包的文件没什么区别，这点你可以用解压软件来测试。只不过这个打包的文件里面需要按照java官方规定放置一些特定的文件来方便jar运行或者引用时使用。\n\n### Manifest文件\n\nJAR文件支持广泛的功能，包括电子签名、版本控制、包密封等。什么使JAR文件具有这种多功能性？答案是JAR文件的清单。清单是一个特殊的文件，可以包含关于打包在JAR文件中的文件的信息。通过定制清单包含的这个“元”信息，您可以使JAR文件满足各种目的。\n\n#### 默认Manifest\n\n在前面我们也说过，当创建jar文件时，会默认创建**META-INF/MANIFEST.MF**这样的文件，这个也就是我们所说的manifest文件，只不过是默认生成的，里面的具体内容是什么呢，主要是下面俩行：\n\n```\nManifest-Version: 当前jar的版本号\nCreated-By: 创建的jdk名称和版本号\n```\n\n通过上面俩行你大概也猜出这个文件的具体格式**header:value**每一对是通过换行符分割开。\n\n#### 修改Manifest文件\n\n基本命令格式\n\n```\njar cfm jar-file manifest-addition input-file(s)\n```\n\n命令解释\n\n1. m：表示希望合并指定文件中的内容到manifest文件中去。\n2. `manifest-addition`:希望合并到manifest文件中的文件名\n\nm和f参数的具体位置必须和上面的相同。\n\n#### 设置应用的入口点\n\n设置入口点也就是增加main函数所在位置，主要是在Manifest文件中加入这一行即可`Main-Class: classname`\n\n加入这行代码之后，就可以使用`jar -jar jar-name`来运行这个jar。\n\n具体例子\n\n首先在当前目录下创建一个文件，名字Manifest.txt,内容如下**这里需要特别注意一点，在这行后面敲一个换行符，要不然这行是添加不进Manifest文件中去，这个在java官方文档中也有说**\n\n```\nMain-class: Main (类名要根据你的具体环境来配置，是类的完整路径) \n```\n\n创建jar\n\n```\njar cfm demo1.jar Manifest.txt *.class\n```\n\n使用`jar tf demo1.jar`查看文件的内容如下\n\n```\nMETA-INF/\nMETA-INF/MANIFEST.MF\nMain.class\n```\n\n使用`jar xf demo1.jar  META-INF/MANIFEST.MF` 解压指定的文件，查看内容如下\n\n```\nManifest-Version: 1.0\nCreated-By: 1.8.0_144 (Oracle Corporation)\nMain-class: Main\n\n```\n\n运行jar\n\n```\njava -jar demo1.jar\n```\n\n结果\n\n```\nzhangke\n```\n\n运行正确，我在main函数里面就打印了一下我的名称。\n\n通过上面例子我们实现了一个简单的可运行的jar，并且熟悉了前面的内容。\n\n#### 添加类路径到jar文件的类路径中\n\n一般我们在开发项目中，都会用到其他的包，那么我们就需要将这些jar添加到当前jar的类路径中。\n\n也就是添加下面这样一行\n\n```\nClass-Path: jar1-name jar2-name directory-name/jar3-name\n```\n\n注意的一点是：路径头指向本地网络上的类或JAR文件，而不是JAR文件中的JAR文件或通过Internet协议访问的类。要将JAR文件中的JAR文件中的类加载到类路径中，必须编写自定义代码来加载这些类。例如，如果myjar.jar包含另一个jar文件myutils.jar，则不能使用myjar.jar清单中的类路径头将myutils.jar中的类加载到类路径中\n\n具体例子\n\n1. 创建demo2文件夹，将上面demo1打包成demo1.jar,注意这里不写Main-class，直接使用\n\n   ```\n   jar  cf demo1.jar *.class\n   ```\n\n2. 将上面打包的demo1.jar,放到lib目录下面\n\n3. 创建manifest.txt添加如下内容\n\n   ```\n   Main-class: Main\n   Class-path: lib/demo1.jar\n   ```\n\n4. 打包此目录\n\n   ```\n    jar cfm demo2.jar Manifest.txt *\n   ```\n\n5. 运行jar\n\n   ```\n   java -jar demo2.jar\n   ### 运行结果\n   zhangke\n   ```\n\n   说明导入的jar已经生效。这有点类似于设置java.ext.path选项，不过我觉得这种比较好，因为将所有的jar打包到jar中，不用在单独的下载所有的依赖。\n\n#### package sealing \n\n我感觉翻译过来不怎好，就没翻译，直接使用英文。\n\n那么什么是package sealing，简单的说就是将你使用的外部依赖直接打包到你当前的文件中去，和上面添加类路径我现在还没感觉到有什么区别。这里就先不说。后面如果发现了，再来添加。\n\n主要格式如下,在manifest文件中加入下面俩行\n\n```\nName: 包名\nSealed: true\n```\n\n如果你有多个不同的包，可以设置多行，\n\n如果希望将所有的包都sealing，那么直接写上，`Sealed:true`\n\n具体的例子可以看这篇[Java中 Package Sealing 的探秘之旅](https://blog.csdn.net/TechNerd/article/details/8945587)\n\n\n\n从官方的解释可以看出，jar是采用zip来进行打包，只不过打包的后缀名都已jar来命名，因大家习惯上就成为jar文件，另外如果希望jar能够被使用或者运行，那么就需要遵循java委员会定义的一些规则。\n\n### 参考\n\n1. [ JAR : MANIFEST.MF Class-Path referencing a directory](http://todayguesswhat.blogspot.com/2011/03/jar-manifestmf-class-path-referencing.html) 设置class-path路径，对比了绝对和相对路径\n2. [Java中 Package Sealing 的探秘之旅](https://blog.csdn.net/TechNerd/article/details/8945587)","source":"_posts/java 打包技术之jar文件.md","raw":"abbrlink: 19\ntitle: java 打包技术之jar文件\ntags:\n  - java\n  - jar\ncategories:\n  - java\nauthor: zhangke\ndate: 2019-01-08 08:55:00\n---\n# java 打包技术之jar文件\n\n### 概述\n\n1. jar技术简介及使用\n2. Manifest文件\n\n### jar技术简介及使用\n\n本文主要是参照[Lesson: Packaging Programs in JAR Files](https://docs.oracle.com/javase/tutorial/deployment/jar/apiindex.html)来写，如果你的英文不错，可以直接看这个java官方教程。\n\n在开始看下文你需要确认你安装的jdk环境带有jar命令，只需要在命令行中输入**jar -h**看看能不能找到命令即可。如果你安装的是oracle JDK，那么这个命令已经内置在java开发套件中。\n\n下文所使用的源代码地址[gihub](https://github.com/fengxiutianya/blogsource/tree/master/jarstudy)\n<!-- more -->\n**jar技术是什么以及可以用来干什么？**\n\n官方给出的解释如下：JAR文件以zip文件格式打包，因此您可以将其用于无损数据压缩、归档、解压缩和归档解包等任务。这些任务是JAR文件最常见的用途之一，您只需使用这些基本特性就可以实现许多JAR文件的好处。\n\n我这里先不解释这句话，先看看例子，最后我们来总结一些自己理解的jar技术。\n\n#### 创建jar文件\n\n基本的命令格式\n\n```\njar cf jar-file input-file(s)\n```\n\n命令解释：\n\n1. `c` :代表创建一个jar文件\n2. `f`: 代表将创建的jar文件输入到指定的文件而不是stdout\n3. `jar-file`： 表示创建这个jar文件的名字，通常是以jar后缀结尾，但这不是必须。\n4. `input-file(s)`: 代表要包含在jar文件包中的一个或更多的文件，如果是多个文件，以空格隔开，也可以使用通配符`*`来表示所有的文件，如果指定的是文件夹，将递归的将此文件夹中所有的文件都打包进jar中。\n\n参数`c`和`f`的顺序可以是任意的。此命令还会创建一个默认的manifest文件（这个后面会说）。\n\n下面这些参数都是可选的，可以和上面一起使用\n\n|  可选项   |                             意义                             |\n| :-------: | :----------------------------------------------------------: |\n|     v     |                当创建jar文件时，打印创建过程                 |\n| 0（zero） |                          不压缩文件                          |\n|     M     |                   不创建默认的manifest文件                   |\n|     m     | 用来包含指定manifest信息从指定文件中<br />使用格式如下<br />`jar cmf jar-file existing-manifest input-file(s)` |\n|    -C     |               用于修改打包过程中文件的具体位置               |\n\n具体例子:\n\n文件夹内容如下\n\n```\ndemo1\n\tMain.class\n\timages\n\t\ttest.png\n\t\tico.gif \n\taudio\n\t\ttest.log\n```\n\n\n\n打包所有文件到一个单个jar文件，命令如下：\n\n```\njar cvf demo1.jar Main.clss audio images\n```\n\n执行命令结果\n\n```\n已添加清单\n正在添加: Main.class(输入 = 409) (输出 = 282)(压缩了 31%)\n正在添加: audio/(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: images/(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: images/test.png(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: images/ico.gif(输入 = 0) (输出 = 0)(存储了 0%)\n```\n\n从上面的结果可以看出，这个命令在打包过程中压缩了文件。\n\n如果不想压缩使用如下命令\n\n```\njar cvf0 demo1.jar Main.clss audio images\n```\n\n如果打包的是整个文件夹下的内容，也可以采用下面的命令\n\n```\njar cvf demo1.jar *\n```\n\n如果你希望在打包过程中改变某个文件的位置，可以使用`-C`参数，注意这里是大写的C\n\n```\njar cvf demo1.jar Main.class -C audio . -C images .\n```\n\n打包之后，demo1.jar包中的文件位置如下\n\n```\nMETA-INF/\nMETA-INF/MANIFEST.MF\nMain.class\ntest.log\ntest.png\nico.gif\n```\n\n如果没有使用`-C`则包中的文件位置如下\n\n```\nMETA-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\n```\n\n#### 查看jar文件的内容\n\n这个也是我上面为什么能显示包中文件位置使用的命令。\n\n基本命令格式\n\n```\njar tf jar-file\n```\n\n命令解释\n\n1. `t`: 表示显示jar文件的目录\n2. `f`:表示显示的jar文件在命令的参数中\n3. Jar-file:显示的文件的具体位置\n\n具体例子\n\n```\njar tf demo1.jar\n```\n\n输出结果\n\n```\nMETA-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\n```\n\n使用选项`V`也可以显示额外的信息，具体的就不演示。\n\n#### 解压jar文件的内容\n\n基本的命令格式\n\n```ba&#39;sh\njar xf jar-file [archived-file(s)]\n```\n\n命令解释：\n\n1. `x`:表示解压这个jar\n\n2. `[archived-file(s)]`:如果没有这个参数，则解压所有的文件，如果有这个文件解压所有的文件\n\n   其他的和上面的命令一样\n\n具体例子\n\n```bash\n## 解压所有的内容\njar xf demo1.jar\n\n## 解压指定的文件\njar xf demo1.jar Main.class images/ico.gif\n\n```\n\n上面的命令会解压所有的文件或者指定的文件到当前目录中，如果当前目录中不存在则创建。\n\n#### 更新jar文件\n\n基本的命令格式\n\n```\njar uf jar-file input-file(s)\n```\n\n命令解释：\n\n1. `u`:表示更新文件\n\n其他选项和参数与上面一样\n\n例子\n\n**demo1.jar**的内容如下\n\n```\nMETA-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\n```\n\n执行下面命令\n\n```\njar uf demo1.jar ../demo2/tem.log\n```\n\n**demo1.jar**文件内容如下\n\n```\nMETA-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\ndemo2/tem.log\n```\n\n#### 运行jar\n\n如果你看到这里可以跳过，先看后面的内容然后再来看这一块的内容。\n\n如果你希望你打包的jar可以运行，那么就需要在mainfest文件中添加这样一行内容**Main-class: 入口函数，也就是main函数所在的类**，具体怎么添加可以看下文。\n\n运行命令\n\n```\njava -jar jar-filename\n```\n**总结：**其实jar文件就是按照某个特定格式打包的文件，和普通的zip打包的文件没什么区别，这点你可以用解压软件来测试。只不过这个打包的文件里面需要按照java官方规定放置一些特定的文件来方便jar运行或者引用时使用。\n\n### Manifest文件\n\nJAR文件支持广泛的功能，包括电子签名、版本控制、包密封等。什么使JAR文件具有这种多功能性？答案是JAR文件的清单。清单是一个特殊的文件，可以包含关于打包在JAR文件中的文件的信息。通过定制清单包含的这个“元”信息，您可以使JAR文件满足各种目的。\n\n#### 默认Manifest\n\n在前面我们也说过，当创建jar文件时，会默认创建**META-INF/MANIFEST.MF**这样的文件，这个也就是我们所说的manifest文件，只不过是默认生成的，里面的具体内容是什么呢，主要是下面俩行：\n\n```\nManifest-Version: 当前jar的版本号\nCreated-By: 创建的jdk名称和版本号\n```\n\n通过上面俩行你大概也猜出这个文件的具体格式**header:value**每一对是通过换行符分割开。\n\n#### 修改Manifest文件\n\n基本命令格式\n\n```\njar cfm jar-file manifest-addition input-file(s)\n```\n\n命令解释\n\n1. m：表示希望合并指定文件中的内容到manifest文件中去。\n2. `manifest-addition`:希望合并到manifest文件中的文件名\n\nm和f参数的具体位置必须和上面的相同。\n\n#### 设置应用的入口点\n\n设置入口点也就是增加main函数所在位置，主要是在Manifest文件中加入这一行即可`Main-Class: classname`\n\n加入这行代码之后，就可以使用`jar -jar jar-name`来运行这个jar。\n\n具体例子\n\n首先在当前目录下创建一个文件，名字Manifest.txt,内容如下**这里需要特别注意一点，在这行后面敲一个换行符，要不然这行是添加不进Manifest文件中去，这个在java官方文档中也有说**\n\n```\nMain-class: Main (类名要根据你的具体环境来配置，是类的完整路径) \n```\n\n创建jar\n\n```\njar cfm demo1.jar Manifest.txt *.class\n```\n\n使用`jar tf demo1.jar`查看文件的内容如下\n\n```\nMETA-INF/\nMETA-INF/MANIFEST.MF\nMain.class\n```\n\n使用`jar xf demo1.jar  META-INF/MANIFEST.MF` 解压指定的文件，查看内容如下\n\n```\nManifest-Version: 1.0\nCreated-By: 1.8.0_144 (Oracle Corporation)\nMain-class: Main\n\n```\n\n运行jar\n\n```\njava -jar demo1.jar\n```\n\n结果\n\n```\nzhangke\n```\n\n运行正确，我在main函数里面就打印了一下我的名称。\n\n通过上面例子我们实现了一个简单的可运行的jar，并且熟悉了前面的内容。\n\n#### 添加类路径到jar文件的类路径中\n\n一般我们在开发项目中，都会用到其他的包，那么我们就需要将这些jar添加到当前jar的类路径中。\n\n也就是添加下面这样一行\n\n```\nClass-Path: jar1-name jar2-name directory-name/jar3-name\n```\n\n注意的一点是：路径头指向本地网络上的类或JAR文件，而不是JAR文件中的JAR文件或通过Internet协议访问的类。要将JAR文件中的JAR文件中的类加载到类路径中，必须编写自定义代码来加载这些类。例如，如果myjar.jar包含另一个jar文件myutils.jar，则不能使用myjar.jar清单中的类路径头将myutils.jar中的类加载到类路径中\n\n具体例子\n\n1. 创建demo2文件夹，将上面demo1打包成demo1.jar,注意这里不写Main-class，直接使用\n\n   ```\n   jar  cf demo1.jar *.class\n   ```\n\n2. 将上面打包的demo1.jar,放到lib目录下面\n\n3. 创建manifest.txt添加如下内容\n\n   ```\n   Main-class: Main\n   Class-path: lib/demo1.jar\n   ```\n\n4. 打包此目录\n\n   ```\n    jar cfm demo2.jar Manifest.txt *\n   ```\n\n5. 运行jar\n\n   ```\n   java -jar demo2.jar\n   ### 运行结果\n   zhangke\n   ```\n\n   说明导入的jar已经生效。这有点类似于设置java.ext.path选项，不过我觉得这种比较好，因为将所有的jar打包到jar中，不用在单独的下载所有的依赖。\n\n#### package sealing \n\n我感觉翻译过来不怎好，就没翻译，直接使用英文。\n\n那么什么是package sealing，简单的说就是将你使用的外部依赖直接打包到你当前的文件中去，和上面添加类路径我现在还没感觉到有什么区别。这里就先不说。后面如果发现了，再来添加。\n\n主要格式如下,在manifest文件中加入下面俩行\n\n```\nName: 包名\nSealed: true\n```\n\n如果你有多个不同的包，可以设置多行，\n\n如果希望将所有的包都sealing，那么直接写上，`Sealed:true`\n\n具体的例子可以看这篇[Java中 Package Sealing 的探秘之旅](https://blog.csdn.net/TechNerd/article/details/8945587)\n\n\n\n从官方的解释可以看出，jar是采用zip来进行打包，只不过打包的后缀名都已jar来命名，因大家习惯上就成为jar文件，另外如果希望jar能够被使用或者运行，那么就需要遵循java委员会定义的一些规则。\n\n### 参考\n\n1. [ JAR : MANIFEST.MF Class-Path referencing a directory](http://todayguesswhat.blogspot.com/2011/03/jar-manifestmf-class-path-referencing.html) 设置class-path路径，对比了绝对和相对路径\n2. [Java中 Package Sealing 的探秘之旅](https://blog.csdn.net/TechNerd/article/details/8945587)","slug":"java 打包技术之jar文件","published":1,"updated":"2019-01-14T02:21:36.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovpa000w9q1ud6jt5mt2","content":"<h1 id=\"java-打包技术之jar文件\"><a href=\"#java-打包技术之jar文件\" class=\"headerlink\" title=\"java 打包技术之jar文件\"></a>java 打包技术之jar文件</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>jar技术简介及使用</li>\n<li>Manifest文件</li>\n</ol>\n<h3 id=\"jar技术简介及使用\"><a href=\"#jar技术简介及使用\" class=\"headerlink\" title=\"jar技术简介及使用\"></a>jar技术简介及使用</h3><p>本文主要是参照<a href=\"https://docs.oracle.com/javase/tutorial/deployment/jar/apiindex.html\" target=\"_blank\" rel=\"noopener\">Lesson: Packaging Programs in JAR Files</a>来写，如果你的英文不错，可以直接看这个java官方教程。</p>\n<p>在开始看下文你需要确认你安装的jdk环境带有jar命令，只需要在命令行中输入<strong>jar -h</strong>看看能不能找到命令即可。如果你安装的是oracle JDK，那么这个命令已经内置在java开发套件中。</p>\n<p>下文所使用的源代码地址<a href=\"https://github.com/fengxiutianya/blogsource/tree/master/jarstudy\" target=\"_blank\" rel=\"noopener\">gihub</a><br><a id=\"more\"></a><br><strong>jar技术是什么以及可以用来干什么？</strong></p>\n<p>官方给出的解释如下：JAR文件以zip文件格式打包，因此您可以将其用于无损数据压缩、归档、解压缩和归档解包等任务。这些任务是JAR文件最常见的用途之一，您只需使用这些基本特性就可以实现许多JAR文件的好处。</p>\n<p>我这里先不解释这句话，先看看例子，最后我们来总结一些自己理解的jar技术。</p>\n<h4 id=\"创建jar文件\"><a href=\"#创建jar文件\" class=\"headerlink\" title=\"创建jar文件\"></a>创建jar文件</h4><p>基本的命令格式</p>\n<pre><code>jar cf jar-file input-file(s)\n</code></pre><p>命令解释：</p>\n<ol>\n<li><code>c</code> :代表创建一个jar文件</li>\n<li><code>f</code>: 代表将创建的jar文件输入到指定的文件而不是stdout</li>\n<li><code>jar-file</code>： 表示创建这个jar文件的名字，通常是以jar后缀结尾，但这不是必须。</li>\n<li><code>input-file(s)</code>: 代表要包含在jar文件包中的一个或更多的文件，如果是多个文件，以空格隔开，也可以使用通配符<code>*</code>来表示所有的文件，如果指定的是文件夹，将递归的将此文件夹中所有的文件都打包进jar中。</li>\n</ol>\n<p>参数<code>c</code>和<code>f</code>的顺序可以是任意的。此命令还会创建一个默认的manifest文件（这个后面会说）。</p>\n<p>下面这些参数都是可选的，可以和上面一起使用</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">可选项</th>\n<th style=\"text-align:center\">意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">v</td>\n<td style=\"text-align:center\">当创建jar文件时，打印创建过程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0（zero）</td>\n<td style=\"text-align:center\">不压缩文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">M</td>\n<td style=\"text-align:center\">不创建默认的manifest文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">m</td>\n<td style=\"text-align:center\">用来包含指定manifest信息从指定文件中<br>使用格式如下<br><code>jar cmf jar-file existing-manifest input-file(s)</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-C</td>\n<td style=\"text-align:center\">用于修改打包过程中文件的具体位置</td>\n</tr>\n</tbody>\n</table>\n<p>具体例子:</p>\n<p>文件夹内容如下</p>\n<pre><code>demo1\n    Main.class\n    images\n        test.png\n        ico.gif \n    audio\n        test.log\n</code></pre><p>打包所有文件到一个单个jar文件，命令如下：</p>\n<pre><code>jar cvf demo1.jar Main.clss audio images\n</code></pre><p>执行命令结果</p>\n<pre><code>已添加清单\n正在添加: Main.class(输入 = 409) (输出 = 282)(压缩了 31%)\n正在添加: audio/(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: images/(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: images/test.png(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: images/ico.gif(输入 = 0) (输出 = 0)(存储了 0%)\n</code></pre><p>从上面的结果可以看出，这个命令在打包过程中压缩了文件。</p>\n<p>如果不想压缩使用如下命令</p>\n<pre><code>jar cvf0 demo1.jar Main.clss audio images\n</code></pre><p>如果打包的是整个文件夹下的内容，也可以采用下面的命令</p>\n<pre><code>jar cvf demo1.jar *\n</code></pre><p>如果你希望在打包过程中改变某个文件的位置，可以使用<code>-C</code>参数，注意这里是大写的C</p>\n<pre><code>jar cvf demo1.jar Main.class -C audio . -C images .\n</code></pre><p>打包之后，demo1.jar包中的文件位置如下</p>\n<pre><code>META-INF/\nMETA-INF/MANIFEST.MF\nMain.class\ntest.log\ntest.png\nico.gif\n</code></pre><p>如果没有使用<code>-C</code>则包中的文件位置如下</p>\n<pre><code>META-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\n</code></pre><h4 id=\"查看jar文件的内容\"><a href=\"#查看jar文件的内容\" class=\"headerlink\" title=\"查看jar文件的内容\"></a>查看jar文件的内容</h4><p>这个也是我上面为什么能显示包中文件位置使用的命令。</p>\n<p>基本命令格式</p>\n<pre><code>jar tf jar-file\n</code></pre><p>命令解释</p>\n<ol>\n<li><code>t</code>: 表示显示jar文件的目录</li>\n<li><code>f</code>:表示显示的jar文件在命令的参数中</li>\n<li>Jar-file:显示的文件的具体位置</li>\n</ol>\n<p>具体例子</p>\n<pre><code>jar tf demo1.jar\n</code></pre><p>输出结果</p>\n<pre><code>META-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\n</code></pre><p>使用选项<code>V</code>也可以显示额外的信息，具体的就不演示。</p>\n<h4 id=\"解压jar文件的内容\"><a href=\"#解压jar文件的内容\" class=\"headerlink\" title=\"解压jar文件的内容\"></a>解压jar文件的内容</h4><p>基本的命令格式</p>\n<pre><code class=\"ba&amp;#39;sh\">jar xf jar-file [archived-file(s)]\n</code></pre>\n<p>命令解释：</p>\n<ol>\n<li><p><code>x</code>:表示解压这个jar</p>\n</li>\n<li><p><code>[archived-file(s)]</code>:如果没有这个参数，则解压所有的文件，如果有这个文件解压所有的文件</p>\n<p>其他的和上面的命令一样</p>\n</li>\n</ol>\n<p>具体例子</p>\n<pre><code class=\"bash\">## 解压所有的内容\njar xf demo1.jar\n\n## 解压指定的文件\njar xf demo1.jar Main.class images/ico.gif\n\n</code></pre>\n<p>上面的命令会解压所有的文件或者指定的文件到当前目录中，如果当前目录中不存在则创建。</p>\n<h4 id=\"更新jar文件\"><a href=\"#更新jar文件\" class=\"headerlink\" title=\"更新jar文件\"></a>更新jar文件</h4><p>基本的命令格式</p>\n<pre><code>jar uf jar-file input-file(s)\n</code></pre><p>命令解释：</p>\n<ol>\n<li><code>u</code>:表示更新文件</li>\n</ol>\n<p>其他选项和参数与上面一样</p>\n<p>例子</p>\n<p><strong>demo1.jar</strong>的内容如下</p>\n<pre><code>META-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\n</code></pre><p>执行下面命令</p>\n<pre><code>jar uf demo1.jar ../demo2/tem.log\n</code></pre><p><strong>demo1.jar</strong>文件内容如下</p>\n<pre><code>META-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\ndemo2/tem.log\n</code></pre><h4 id=\"运行jar\"><a href=\"#运行jar\" class=\"headerlink\" title=\"运行jar\"></a>运行jar</h4><p>如果你看到这里可以跳过，先看后面的内容然后再来看这一块的内容。</p>\n<p>如果你希望你打包的jar可以运行，那么就需要在mainfest文件中添加这样一行内容<strong>Main-class: 入口函数，也就是main函数所在的类</strong>，具体怎么添加可以看下文。</p>\n<p>运行命令</p>\n<pre><code>java -jar jar-filename\n</code></pre><p><strong>总结：</strong>其实jar文件就是按照某个特定格式打包的文件，和普通的zip打包的文件没什么区别，这点你可以用解压软件来测试。只不过这个打包的文件里面需要按照java官方规定放置一些特定的文件来方便jar运行或者引用时使用。</p>\n<h3 id=\"Manifest文件\"><a href=\"#Manifest文件\" class=\"headerlink\" title=\"Manifest文件\"></a>Manifest文件</h3><p>JAR文件支持广泛的功能，包括电子签名、版本控制、包密封等。什么使JAR文件具有这种多功能性？答案是JAR文件的清单。清单是一个特殊的文件，可以包含关于打包在JAR文件中的文件的信息。通过定制清单包含的这个“元”信息，您可以使JAR文件满足各种目的。</p>\n<h4 id=\"默认Manifest\"><a href=\"#默认Manifest\" class=\"headerlink\" title=\"默认Manifest\"></a>默认Manifest</h4><p>在前面我们也说过，当创建jar文件时，会默认创建<strong>META-INF/MANIFEST.MF</strong>这样的文件，这个也就是我们所说的manifest文件，只不过是默认生成的，里面的具体内容是什么呢，主要是下面俩行：</p>\n<pre><code>Manifest-Version: 当前jar的版本号\nCreated-By: 创建的jdk名称和版本号\n</code></pre><p>通过上面俩行你大概也猜出这个文件的具体格式<strong>header:value</strong>每一对是通过换行符分割开。</p>\n<h4 id=\"修改Manifest文件\"><a href=\"#修改Manifest文件\" class=\"headerlink\" title=\"修改Manifest文件\"></a>修改Manifest文件</h4><p>基本命令格式</p>\n<pre><code>jar cfm jar-file manifest-addition input-file(s)\n</code></pre><p>命令解释</p>\n<ol>\n<li>m：表示希望合并指定文件中的内容到manifest文件中去。</li>\n<li><code>manifest-addition</code>:希望合并到manifest文件中的文件名</li>\n</ol>\n<p>m和f参数的具体位置必须和上面的相同。</p>\n<h4 id=\"设置应用的入口点\"><a href=\"#设置应用的入口点\" class=\"headerlink\" title=\"设置应用的入口点\"></a>设置应用的入口点</h4><p>设置入口点也就是增加main函数所在位置，主要是在Manifest文件中加入这一行即可<code>Main-Class: classname</code></p>\n<p>加入这行代码之后，就可以使用<code>jar -jar jar-name</code>来运行这个jar。</p>\n<p>具体例子</p>\n<p>首先在当前目录下创建一个文件，名字Manifest.txt,内容如下<strong>这里需要特别注意一点，在这行后面敲一个换行符，要不然这行是添加不进Manifest文件中去，这个在java官方文档中也有说</strong></p>\n<pre><code>Main-class: Main (类名要根据你的具体环境来配置，是类的完整路径) \n</code></pre><p>创建jar</p>\n<pre><code>jar cfm demo1.jar Manifest.txt *.class\n</code></pre><p>使用<code>jar tf demo1.jar</code>查看文件的内容如下</p>\n<pre><code>META-INF/\nMETA-INF/MANIFEST.MF\nMain.class\n</code></pre><p>使用<code>jar xf demo1.jar  META-INF/MANIFEST.MF</code> 解压指定的文件，查看内容如下</p>\n<pre><code>Manifest-Version: 1.0\nCreated-By: 1.8.0_144 (Oracle Corporation)\nMain-class: Main\n\n</code></pre><p>运行jar</p>\n<pre><code>java -jar demo1.jar\n</code></pre><p>结果</p>\n<pre><code>zhangke\n</code></pre><p>运行正确，我在main函数里面就打印了一下我的名称。</p>\n<p>通过上面例子我们实现了一个简单的可运行的jar，并且熟悉了前面的内容。</p>\n<h4 id=\"添加类路径到jar文件的类路径中\"><a href=\"#添加类路径到jar文件的类路径中\" class=\"headerlink\" title=\"添加类路径到jar文件的类路径中\"></a>添加类路径到jar文件的类路径中</h4><p>一般我们在开发项目中，都会用到其他的包，那么我们就需要将这些jar添加到当前jar的类路径中。</p>\n<p>也就是添加下面这样一行</p>\n<pre><code>Class-Path: jar1-name jar2-name directory-name/jar3-name\n</code></pre><p>注意的一点是：路径头指向本地网络上的类或JAR文件，而不是JAR文件中的JAR文件或通过Internet协议访问的类。要将JAR文件中的JAR文件中的类加载到类路径中，必须编写自定义代码来加载这些类。例如，如果myjar.jar包含另一个jar文件myutils.jar，则不能使用myjar.jar清单中的类路径头将myutils.jar中的类加载到类路径中</p>\n<p>具体例子</p>\n<ol>\n<li><p>创建demo2文件夹，将上面demo1打包成demo1.jar,注意这里不写Main-class，直接使用</p>\n<pre><code>jar  cf demo1.jar *.class\n</code></pre></li>\n<li><p>将上面打包的demo1.jar,放到lib目录下面</p>\n</li>\n<li><p>创建manifest.txt添加如下内容</p>\n<pre><code>Main-class: Main\nClass-path: lib/demo1.jar\n</code></pre></li>\n<li><p>打包此目录</p>\n<pre><code> jar cfm demo2.jar Manifest.txt *\n</code></pre></li>\n<li><p>运行jar</p>\n<pre><code>java -jar demo2.jar\n### 运行结果\nzhangke\n</code></pre><p>说明导入的jar已经生效。这有点类似于设置java.ext.path选项，不过我觉得这种比较好，因为将所有的jar打包到jar中，不用在单独的下载所有的依赖。</p>\n</li>\n</ol>\n<h4 id=\"package-sealing\"><a href=\"#package-sealing\" class=\"headerlink\" title=\"package sealing\"></a>package sealing</h4><p>我感觉翻译过来不怎好，就没翻译，直接使用英文。</p>\n<p>那么什么是package sealing，简单的说就是将你使用的外部依赖直接打包到你当前的文件中去，和上面添加类路径我现在还没感觉到有什么区别。这里就先不说。后面如果发现了，再来添加。</p>\n<p>主要格式如下,在manifest文件中加入下面俩行</p>\n<pre><code>Name: 包名\nSealed: true\n</code></pre><p>如果你有多个不同的包，可以设置多行，</p>\n<p>如果希望将所有的包都sealing，那么直接写上，<code>Sealed:true</code></p>\n<p>具体的例子可以看这篇<a href=\"https://blog.csdn.net/TechNerd/article/details/8945587\" target=\"_blank\" rel=\"noopener\">Java中 Package Sealing 的探秘之旅</a></p>\n<p>从官方的解释可以看出，jar是采用zip来进行打包，只不过打包的后缀名都已jar来命名，因大家习惯上就成为jar文件，另外如果希望jar能够被使用或者运行，那么就需要遵循java委员会定义的一些规则。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"http://todayguesswhat.blogspot.com/2011/03/jar-manifestmf-class-path-referencing.html\" target=\"_blank\" rel=\"noopener\"> JAR : MANIFEST.MF Class-Path referencing a directory</a> 设置class-path路径，对比了绝对和相对路径</li>\n<li><a href=\"https://blog.csdn.net/TechNerd/article/details/8945587\" target=\"_blank\" rel=\"noopener\">Java中 Package Sealing 的探秘之旅</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"java-打包技术之jar文件\"><a href=\"#java-打包技术之jar文件\" class=\"headerlink\" title=\"java 打包技术之jar文件\"></a>java 打包技术之jar文件</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>jar技术简介及使用</li>\n<li>Manifest文件</li>\n</ol>\n<h3 id=\"jar技术简介及使用\"><a href=\"#jar技术简介及使用\" class=\"headerlink\" title=\"jar技术简介及使用\"></a>jar技术简介及使用</h3><p>本文主要是参照<a href=\"https://docs.oracle.com/javase/tutorial/deployment/jar/apiindex.html\" target=\"_blank\" rel=\"noopener\">Lesson: Packaging Programs in JAR Files</a>来写，如果你的英文不错，可以直接看这个java官方教程。</p>\n<p>在开始看下文你需要确认你安装的jdk环境带有jar命令，只需要在命令行中输入<strong>jar -h</strong>看看能不能找到命令即可。如果你安装的是oracle JDK，那么这个命令已经内置在java开发套件中。</p>\n<p>下文所使用的源代码地址<a href=\"https://github.com/fengxiutianya/blogsource/tree/master/jarstudy\" target=\"_blank\" rel=\"noopener\">gihub</a><br>","more":"<br><strong>jar技术是什么以及可以用来干什么？</strong></p>\n<p>官方给出的解释如下：JAR文件以zip文件格式打包，因此您可以将其用于无损数据压缩、归档、解压缩和归档解包等任务。这些任务是JAR文件最常见的用途之一，您只需使用这些基本特性就可以实现许多JAR文件的好处。</p>\n<p>我这里先不解释这句话，先看看例子，最后我们来总结一些自己理解的jar技术。</p>\n<h4 id=\"创建jar文件\"><a href=\"#创建jar文件\" class=\"headerlink\" title=\"创建jar文件\"></a>创建jar文件</h4><p>基本的命令格式</p>\n<pre><code>jar cf jar-file input-file(s)\n</code></pre><p>命令解释：</p>\n<ol>\n<li><code>c</code> :代表创建一个jar文件</li>\n<li><code>f</code>: 代表将创建的jar文件输入到指定的文件而不是stdout</li>\n<li><code>jar-file</code>： 表示创建这个jar文件的名字，通常是以jar后缀结尾，但这不是必须。</li>\n<li><code>input-file(s)</code>: 代表要包含在jar文件包中的一个或更多的文件，如果是多个文件，以空格隔开，也可以使用通配符<code>*</code>来表示所有的文件，如果指定的是文件夹，将递归的将此文件夹中所有的文件都打包进jar中。</li>\n</ol>\n<p>参数<code>c</code>和<code>f</code>的顺序可以是任意的。此命令还会创建一个默认的manifest文件（这个后面会说）。</p>\n<p>下面这些参数都是可选的，可以和上面一起使用</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">可选项</th>\n<th style=\"text-align:center\">意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">v</td>\n<td style=\"text-align:center\">当创建jar文件时，打印创建过程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0（zero）</td>\n<td style=\"text-align:center\">不压缩文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">M</td>\n<td style=\"text-align:center\">不创建默认的manifest文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">m</td>\n<td style=\"text-align:center\">用来包含指定manifest信息从指定文件中<br>使用格式如下<br><code>jar cmf jar-file existing-manifest input-file(s)</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-C</td>\n<td style=\"text-align:center\">用于修改打包过程中文件的具体位置</td>\n</tr>\n</tbody>\n</table>\n<p>具体例子:</p>\n<p>文件夹内容如下</p>\n<pre><code>demo1\n    Main.class\n    images\n        test.png\n        ico.gif \n    audio\n        test.log\n</code></pre><p>打包所有文件到一个单个jar文件，命令如下：</p>\n<pre><code>jar cvf demo1.jar Main.clss audio images\n</code></pre><p>执行命令结果</p>\n<pre><code>已添加清单\n正在添加: Main.class(输入 = 409) (输出 = 282)(压缩了 31%)\n正在添加: audio/(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: images/(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: images/test.png(输入 = 0) (输出 = 0)(存储了 0%)\n正在添加: images/ico.gif(输入 = 0) (输出 = 0)(存储了 0%)\n</code></pre><p>从上面的结果可以看出，这个命令在打包过程中压缩了文件。</p>\n<p>如果不想压缩使用如下命令</p>\n<pre><code>jar cvf0 demo1.jar Main.clss audio images\n</code></pre><p>如果打包的是整个文件夹下的内容，也可以采用下面的命令</p>\n<pre><code>jar cvf demo1.jar *\n</code></pre><p>如果你希望在打包过程中改变某个文件的位置，可以使用<code>-C</code>参数，注意这里是大写的C</p>\n<pre><code>jar cvf demo1.jar Main.class -C audio . -C images .\n</code></pre><p>打包之后，demo1.jar包中的文件位置如下</p>\n<pre><code>META-INF/\nMETA-INF/MANIFEST.MF\nMain.class\ntest.log\ntest.png\nico.gif\n</code></pre><p>如果没有使用<code>-C</code>则包中的文件位置如下</p>\n<pre><code>META-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\n</code></pre><h4 id=\"查看jar文件的内容\"><a href=\"#查看jar文件的内容\" class=\"headerlink\" title=\"查看jar文件的内容\"></a>查看jar文件的内容</h4><p>这个也是我上面为什么能显示包中文件位置使用的命令。</p>\n<p>基本命令格式</p>\n<pre><code>jar tf jar-file\n</code></pre><p>命令解释</p>\n<ol>\n<li><code>t</code>: 表示显示jar文件的目录</li>\n<li><code>f</code>:表示显示的jar文件在命令的参数中</li>\n<li>Jar-file:显示的文件的具体位置</li>\n</ol>\n<p>具体例子</p>\n<pre><code>jar tf demo1.jar\n</code></pre><p>输出结果</p>\n<pre><code>META-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\n</code></pre><p>使用选项<code>V</code>也可以显示额外的信息，具体的就不演示。</p>\n<h4 id=\"解压jar文件的内容\"><a href=\"#解压jar文件的内容\" class=\"headerlink\" title=\"解压jar文件的内容\"></a>解压jar文件的内容</h4><p>基本的命令格式</p>\n<pre><code class=\"ba&amp;#39;sh\">jar xf jar-file [archived-file(s)]\n</code></pre>\n<p>命令解释：</p>\n<ol>\n<li><p><code>x</code>:表示解压这个jar</p>\n</li>\n<li><p><code>[archived-file(s)]</code>:如果没有这个参数，则解压所有的文件，如果有这个文件解压所有的文件</p>\n<p>其他的和上面的命令一样</p>\n</li>\n</ol>\n<p>具体例子</p>\n<pre><code class=\"bash\">## 解压所有的内容\njar xf demo1.jar\n\n## 解压指定的文件\njar xf demo1.jar Main.class images/ico.gif\n\n</code></pre>\n<p>上面的命令会解压所有的文件或者指定的文件到当前目录中，如果当前目录中不存在则创建。</p>\n<h4 id=\"更新jar文件\"><a href=\"#更新jar文件\" class=\"headerlink\" title=\"更新jar文件\"></a>更新jar文件</h4><p>基本的命令格式</p>\n<pre><code>jar uf jar-file input-file(s)\n</code></pre><p>命令解释：</p>\n<ol>\n<li><code>u</code>:表示更新文件</li>\n</ol>\n<p>其他选项和参数与上面一样</p>\n<p>例子</p>\n<p><strong>demo1.jar</strong>的内容如下</p>\n<pre><code>META-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\n</code></pre><p>执行下面命令</p>\n<pre><code>jar uf demo1.jar ../demo2/tem.log\n</code></pre><p><strong>demo1.jar</strong>文件内容如下</p>\n<pre><code>META-INF/\nMETA-INF/MANIFEST.MF\nMain.class\naudio/\naudio/test.log\nimages/\nimages/test.png\nimages/ico.gif\ndemo2/tem.log\n</code></pre><h4 id=\"运行jar\"><a href=\"#运行jar\" class=\"headerlink\" title=\"运行jar\"></a>运行jar</h4><p>如果你看到这里可以跳过，先看后面的内容然后再来看这一块的内容。</p>\n<p>如果你希望你打包的jar可以运行，那么就需要在mainfest文件中添加这样一行内容<strong>Main-class: 入口函数，也就是main函数所在的类</strong>，具体怎么添加可以看下文。</p>\n<p>运行命令</p>\n<pre><code>java -jar jar-filename\n</code></pre><p><strong>总结：</strong>其实jar文件就是按照某个特定格式打包的文件，和普通的zip打包的文件没什么区别，这点你可以用解压软件来测试。只不过这个打包的文件里面需要按照java官方规定放置一些特定的文件来方便jar运行或者引用时使用。</p>\n<h3 id=\"Manifest文件\"><a href=\"#Manifest文件\" class=\"headerlink\" title=\"Manifest文件\"></a>Manifest文件</h3><p>JAR文件支持广泛的功能，包括电子签名、版本控制、包密封等。什么使JAR文件具有这种多功能性？答案是JAR文件的清单。清单是一个特殊的文件，可以包含关于打包在JAR文件中的文件的信息。通过定制清单包含的这个“元”信息，您可以使JAR文件满足各种目的。</p>\n<h4 id=\"默认Manifest\"><a href=\"#默认Manifest\" class=\"headerlink\" title=\"默认Manifest\"></a>默认Manifest</h4><p>在前面我们也说过，当创建jar文件时，会默认创建<strong>META-INF/MANIFEST.MF</strong>这样的文件，这个也就是我们所说的manifest文件，只不过是默认生成的，里面的具体内容是什么呢，主要是下面俩行：</p>\n<pre><code>Manifest-Version: 当前jar的版本号\nCreated-By: 创建的jdk名称和版本号\n</code></pre><p>通过上面俩行你大概也猜出这个文件的具体格式<strong>header:value</strong>每一对是通过换行符分割开。</p>\n<h4 id=\"修改Manifest文件\"><a href=\"#修改Manifest文件\" class=\"headerlink\" title=\"修改Manifest文件\"></a>修改Manifest文件</h4><p>基本命令格式</p>\n<pre><code>jar cfm jar-file manifest-addition input-file(s)\n</code></pre><p>命令解释</p>\n<ol>\n<li>m：表示希望合并指定文件中的内容到manifest文件中去。</li>\n<li><code>manifest-addition</code>:希望合并到manifest文件中的文件名</li>\n</ol>\n<p>m和f参数的具体位置必须和上面的相同。</p>\n<h4 id=\"设置应用的入口点\"><a href=\"#设置应用的入口点\" class=\"headerlink\" title=\"设置应用的入口点\"></a>设置应用的入口点</h4><p>设置入口点也就是增加main函数所在位置，主要是在Manifest文件中加入这一行即可<code>Main-Class: classname</code></p>\n<p>加入这行代码之后，就可以使用<code>jar -jar jar-name</code>来运行这个jar。</p>\n<p>具体例子</p>\n<p>首先在当前目录下创建一个文件，名字Manifest.txt,内容如下<strong>这里需要特别注意一点，在这行后面敲一个换行符，要不然这行是添加不进Manifest文件中去，这个在java官方文档中也有说</strong></p>\n<pre><code>Main-class: Main (类名要根据你的具体环境来配置，是类的完整路径) \n</code></pre><p>创建jar</p>\n<pre><code>jar cfm demo1.jar Manifest.txt *.class\n</code></pre><p>使用<code>jar tf demo1.jar</code>查看文件的内容如下</p>\n<pre><code>META-INF/\nMETA-INF/MANIFEST.MF\nMain.class\n</code></pre><p>使用<code>jar xf demo1.jar  META-INF/MANIFEST.MF</code> 解压指定的文件，查看内容如下</p>\n<pre><code>Manifest-Version: 1.0\nCreated-By: 1.8.0_144 (Oracle Corporation)\nMain-class: Main\n\n</code></pre><p>运行jar</p>\n<pre><code>java -jar demo1.jar\n</code></pre><p>结果</p>\n<pre><code>zhangke\n</code></pre><p>运行正确，我在main函数里面就打印了一下我的名称。</p>\n<p>通过上面例子我们实现了一个简单的可运行的jar，并且熟悉了前面的内容。</p>\n<h4 id=\"添加类路径到jar文件的类路径中\"><a href=\"#添加类路径到jar文件的类路径中\" class=\"headerlink\" title=\"添加类路径到jar文件的类路径中\"></a>添加类路径到jar文件的类路径中</h4><p>一般我们在开发项目中，都会用到其他的包，那么我们就需要将这些jar添加到当前jar的类路径中。</p>\n<p>也就是添加下面这样一行</p>\n<pre><code>Class-Path: jar1-name jar2-name directory-name/jar3-name\n</code></pre><p>注意的一点是：路径头指向本地网络上的类或JAR文件，而不是JAR文件中的JAR文件或通过Internet协议访问的类。要将JAR文件中的JAR文件中的类加载到类路径中，必须编写自定义代码来加载这些类。例如，如果myjar.jar包含另一个jar文件myutils.jar，则不能使用myjar.jar清单中的类路径头将myutils.jar中的类加载到类路径中</p>\n<p>具体例子</p>\n<ol>\n<li><p>创建demo2文件夹，将上面demo1打包成demo1.jar,注意这里不写Main-class，直接使用</p>\n<pre><code>jar  cf demo1.jar *.class\n</code></pre></li>\n<li><p>将上面打包的demo1.jar,放到lib目录下面</p>\n</li>\n<li><p>创建manifest.txt添加如下内容</p>\n<pre><code>Main-class: Main\nClass-path: lib/demo1.jar\n</code></pre></li>\n<li><p>打包此目录</p>\n<pre><code> jar cfm demo2.jar Manifest.txt *\n</code></pre></li>\n<li><p>运行jar</p>\n<pre><code>java -jar demo2.jar\n### 运行结果\nzhangke\n</code></pre><p>说明导入的jar已经生效。这有点类似于设置java.ext.path选项，不过我觉得这种比较好，因为将所有的jar打包到jar中，不用在单独的下载所有的依赖。</p>\n</li>\n</ol>\n<h4 id=\"package-sealing\"><a href=\"#package-sealing\" class=\"headerlink\" title=\"package sealing\"></a>package sealing</h4><p>我感觉翻译过来不怎好，就没翻译，直接使用英文。</p>\n<p>那么什么是package sealing，简单的说就是将你使用的外部依赖直接打包到你当前的文件中去，和上面添加类路径我现在还没感觉到有什么区别。这里就先不说。后面如果发现了，再来添加。</p>\n<p>主要格式如下,在manifest文件中加入下面俩行</p>\n<pre><code>Name: 包名\nSealed: true\n</code></pre><p>如果你有多个不同的包，可以设置多行，</p>\n<p>如果希望将所有的包都sealing，那么直接写上，<code>Sealed:true</code></p>\n<p>具体的例子可以看这篇<a href=\"https://blog.csdn.net/TechNerd/article/details/8945587\" target=\"_blank\" rel=\"noopener\">Java中 Package Sealing 的探秘之旅</a></p>\n<p>从官方的解释可以看出，jar是采用zip来进行打包，只不过打包的后缀名都已jar来命名，因大家习惯上就成为jar文件，另外如果希望jar能够被使用或者运行，那么就需要遵循java委员会定义的一些规则。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"http://todayguesswhat.blogspot.com/2011/03/jar-manifestmf-class-path-referencing.html\" target=\"_blank\" rel=\"noopener\"> JAR : MANIFEST.MF Class-Path referencing a directory</a> 设置class-path路径，对比了绝对和相对路径</li>\n<li><a href=\"https://blog.csdn.net/TechNerd/article/details/8945587\" target=\"_blank\" rel=\"noopener\">Java中 Package Sealing 的探秘之旅</a></li>\n</ol>"},{"abbrlink":17,"title":"泛型中 < ? extends T > 和 < ? extends T > 的区别","author":"zhangke","date":"2018-01-11T05:55:00.000Z","_content":"# 泛型中 < ? extends T > 和 < ? extends T > 的区别\n\n这俩个主要用于对参数的保护，如果你看过Java api 源码的话，你经常看到方法参数类似上面的写法。\n\n### 概要\n\n>1. 类型擦除\n>2. 逆变与协变\n>3. ？ 的用法 \n>4. extends 的用法\n>5. super的用法\n>6. PECS原则\n\n### 类型擦除\n\n>```java\n>import java.util.*;\n>public class main{\n>  public static void main(String[] args){\n>    Class c1 = new ArrayList< String>().getClass();\n>    Class c2 = new ArrayList< Integer>().getClass();\n>    System.out.println(c1 == c2);\n>  }\n>}\n>```\n>\n>上面程序运行的结果是true。出现这个结果的原因正是类型擦除。\n>\n>在Java语言中，泛型是通过类型擦除来实现的，这意味着当你在使用泛型时，任何具体的类型都将被擦除，你唯一知道的就是你正在使用的是一个对象。因此上面List< String> 和List< Integer>在运行时事实上是同样的类型。（泛型类型只有在静态类型检查期间才出现，静态类型检查：基于程序的源代码来验证类型安全的过程；动态类型检查：在程序运行期间验证类型安全的过程；）\n>\n>#### 擦除带来的问题\n>\n>```java\n>class HasF{\n>  public void f(){\n>    System.out.println(\"f\");\n>  }\n>}\n>class Manipulator< T>{\n>  private T obj;\n>  public Manipulator(T x){\n>    obj = x;\n>  }\n>  public void manipulate(){\n>    obj.f();\n>  }\n>}\n>public class main{\n>  \n>  public static  void main(String[] args){\n>    HasF hasf = new HasF();\n>    Manipulator< HasF> m = new Manipulator< HasF>(hasf);\n>    m.manipulate()  // error\n>  }\n>}\n>```\n>\n>上面这段代码会报错，正是由于类型擦除导致的。因为类型擦除，所以泛型内部无法知道类型的信息，当你调用object没有的方法时，就会报错。\n>\n>### 补充一点：边界\n>\n>>因为擦除在方法体中移除了类型信息，所以运行时，你就需要辨别边界，边界是指：对象进入和离开方法的地点，这里是指泛型的方法体。\n>>\n>>```java\n>>public class ArrayMaker< T> {\n>>  private Class< T> kind;\n>>  public ArrayMaker(Class<T> kind) {\n>>    this.kind = kind;\n>>  }\n>>  @SuppressWarnings(\"unchecked\")\n>>  T[] create(int size) {\n>>    return (T[])Array.newInstance(kind, size);\n>>  }\n>>  public static void main(String[] args) {\n>>    ArrayMaker< String> stringMaker =\n>>      new ArrayMaker< String>(String.class);\n>>    String[] stringArray = stringMaker.create(9);\n>>    System.out.println(Arrays.toString(stringArray));\n>>  }\n>>} /* Output:\n>>[null, null, null, null, null, null, null, null, null]\n>>*///:~\n>>```\n>>\n>>上面这段代码就是因为在泛型的方法体中初始化，所以就把所有的类型当成了Object类型，因此输出的结果都是null。如果是String对象的话，输出的是**“  ”**\n>>\n>>仔细查看下面俩段代码：\n>>\n>>```java\n>>// 不存在泛型\n>>public class SimpleHolder {\n>>  private Object obj;\n>>  public void set(Object obj) { this.obj = obj; }\n>>  public Object get() { return obj; }\n>>  public static void main(String[] args) {\n>>    SimpleHolder holder = new SimpleHolder();\n>>    holder.set(\"Item\");\n>>    String s = (String)holder.get();\n>>  }\n>>} ///:~\n>>```\n>>\n>>```java\n>>/// 存在泛型\n>>public class GenericHolder<T> {\n>>  private T obj;\n>>  public void set(T obj) { this.obj = obj; }\n>>  public T get() { return obj; }\n>>  public static void main(String[] args) {\n>>    GenericHolder< String > holder =\n>>      new GenericHolder< String >();\n>>    holder.set(\"Item\");\n>>    String s = holder.get();\n>>  }\n>>} \n>>```\n>>\n>>但是如果你仔细查看俩段代码的字节码，你会发现是相同的。并且你会发现泛型所有的动作都是发生在边界处，会对传进来的值进行额外的编译检查，并插入对传递出去的值的类型。所以，可以得出一个结论，边界就是发生动作的地方。\n\n### 逆变与协变\n\n>协变与逆变这来个术语是用来描述类型转换（type transformations）后的继承关系。定义如下：A,B表示类型**≤ **表示继承关系.(比如：A ≤B表示A是B派生出来的子类  )\n>\n>- 逆变（contravariant），当A≤B时，B可以转化成A。\n>- 协变（covariant），A≤B时，A可以转换成B。\n>- 不变（invariant），如果上述俩种均不能使用。\n>\n>先来看一个简单的例子：\n>\n>考虑List< A >是否是协变，逆变，不变？协变意味着List< String >是List< Object>的子类，逆变意味着List\n>\n>< Object>是List< String>的子类，不变意味着上面俩种都不是。在java中List< String>和List< Object>是不变的类型。下面的代码在java中是编译不过去的，验证了集合在java中是不变的。\n>\n>```java\n>ArrayList<String> strings = new ArrayList<Object>();\n>ArrayList<Object> objects = new ArrayList<String>();\n>```\n>\n>\n>\n>在来看另外一个例子，数组 A[]，判断数组是逆变，协变，不变三个的哪一种？很容易可以证明，在java中数组是协变的\n>\n>```java\n>Object[] objs = new String[3]\n>```\n>\n>下面这个例子是来研究方法,直接通过一个例子来说明\n>\n>```java\n>Number[] method(ArrayList<Number> list) {\n>  ...\n>}\n>//下面三个没有一个能编译过\n>Integer[] result = method(new ArrayList<Integer>());\n>Number[] result = method(new ArrayList<Integer>());\n>Object[] result = method(new ArrayList<Object>());\n>//下面俩个能编译过\n>Number[] result = method(new ArrayList<Number>());\n>Object[] result = method(new ArrayList<Number>());\n>\n>```\n>\n>调用方法`result = method(n)`；传入形参的类型应为method形参的子类型，即`typeof(n)≤typeof(method's parameter)`；result应为method返回值的基类型，即`typeof(methods's return)≤typeof(result)`：\n>\n>在Java 1.4中，子类覆盖（override）父类方法时，形参与返回值的类型必须与父类保持一致：\n>\n>```java\n>class Super {\n>    Number method(Number n) { ... }\n>}\n>\n>class Sub extends Super {\n>    @Override \n>    Number method(Number n) { ... }\n>}\n>```\n>\n>从Java 1.5开始，子类覆盖父类方法时允许协变返回更为具体的类型：\n>\n>```java\n>class Super {\n>    Number method(Number n) { ... }\n>}\n>\n>class Sub extends Super {\n>    @Override \n>    Integer method(Number n) { ... }\n>}\n>```\n\n### ？ 的用法 \n\n>下面是使用案例\n>\n>```Java\n>public class UnboundedWildcardsl {\n>    static List list1;\n>    static List<?> list2;\n>    static List<? extends Object> list3;\n>//    @SuppressWarnings(\"unchecked\")\n>    static void assign1(List list){\n>        list1 = list;\n>        list2 = list;\n>\n>        list3 = list;     //未检查的转换\n>    }\n>    static void assign2(List<?> list){\n>        list1 = list;\n>        list2 = list;\n>        list3 = list;\n>    }\n>    static void assign3(List<? extends Object> list){\n>        list1 = list;\n>        list2 = list;\n>        list3 = list;\n>    }\n>\n>    public static void main(String[] args) {\n>        assign1(new ArrayList());\n>        assign2(new ArrayList());\n>        assign3(new ArrayList());\n>\n>        assign1(new ArrayList<>());\n>        assign2(new ArrayList<>());\n>        assign3(new ArrayList<>());\n>\n>        List<?> wildList = new ArrayList();\n>        wildList = new ArrayList<String>();\n>        assign1(wildList);\n>        assign2(wildList);\n>        assign3(wildList);\n>    }\n>}\n>```\n>\n> 在很多情况下你会看到和这个情况类似，编译器很少关心使用的是原生类型还是< ?>，这些情况< ?> 被认为是一种装饰，不过还是有价值的，即我想用java泛型来编写代码。我在这里并不是要使用原生的类型，但是这种情况下，泛型参数可以支持有任何类型。\n\n### extends 的用法\n\n>extends表示的是上界通配符，下面展示的是如何使用:以 List<? extends Number> 为例来展示使用\n>\n>```Java\n>//Number extends Number \n>List<? extends Number>  foo3 = new ArrayList<? extends Number>();\n>\n>//Integer extends Number\n>List<? extends Number> foo3 = new ArrayList<? extends Integer>();\n>\n>//Double extends Number\n>List<? extends Number> foo3 = new ArrayList<? extends Double>();\n>\n>//下面的是错误使用\n>foo3.add(12);\n>\n>```\n>\n>1. 读取操作通过以上给定的赋值语句，你一定能从foo3列表中读取到的元素的类型是什么呢？你可以读取到Number，因为以上的列表要么包含Number元素，要么包含Number的子类元素。\n>\n>   你不能保证读取到Integer，因为foo3可能指向的是List< Double>。\n>\n>   你不能保证读取到Double，因为foo3可能指向的是List< Integer>。\n>\n>2. 写入操作过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？\n>\n>   你不能插入一个Integer元素，因为foo3可能指向List< Double>。\n>\n>   你不能插入一个Double元素，因为foo3可能指向List< Integer>。\n>\n>   你不能插入一个Number元素，因为foo3可能指向List< Integer>。\n>\n>   你不能往List< ? extends T>中插入任何类型的对象，因为你不能保证列表实际指向的类型是什么，你并不能保证列表中实际存储什么类型的对象。唯一可以保证的是，你可以从中读取到T或者T的子类。这也验证了java集合是不变的，由于无法判断类型，所以你也无法进行插入。\n\n### super 的用法\n\n>super下界通配符，下面以List\\<？ super Integer>来展示super的用法\n>\n>```java\n>//integer is a superClass of Integer \n>List<? super Integer>  foo3 = new ArrayList<Integer>()\n> \n>//Number is a superClass of Integer\n>List<? super Integer> foo3 = new ArrayList<Number>();\n>\n>//Object is superClass of Integer\n>List<? super Integer> foo3 = new ArrayList<Object>();\n>\n>//下面代码是错误的\n>list.get(index);  //不能获取\n>```\n>\n>1. foo3可能指向List< Number>或者List< Object>。\n>\n>   你不能保证读取到Number，因为foo3可能指向List< Object>。\n>\n>   唯一可以保证的是，你可以读取到Object或者Object子类的对象（你并不知道具体的子类是什么）。\n>\n>2. 写入操作通过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？你可以插入Integer对象，因为上述声明的列表都支持Integer。\n>\n>   你可以插入Integer的子类的对象，因为Integer的子类同时也是Integer，原因同上。\n>\n>   你不能插入Double对象，因为foo3可能指向ArrayList< Integer>。\n>\n>   你不能插入Number对象，因为foo3可能指向ArrayList< Integer>。\n>\n>   你不能插入Object对象，因为foo3可能指向ArrayList< Integer>。\n\n#### PECS(Pruducer extends,Consumer super)\n\n>请记住PECS原则：生产者（Producer）使用extends，消费者（Consumer）使用super。\n>\n>- 生产者使用extends\n>\n>如果你需要一个列表提供T类型的元素（即你想从列表中读取T类型的元素），你需要把这个列表声明成\\<? extends T>，比如List\\<? extends Integer>，因此你不能往该列表中添加任何元素。\n>\n>- 消费者使用super\n>\n>如果需要一个列表使用T类型的元素（即你想把T类型的元素加入到列表中），你需要把这个列表声明成\\<? super T>，比如List\\<? super Integer>，因此你不能保证从中读取到的元素的类型。\n>\n>- 即是生产者，也是消费者\n>\n>如果一个列表即要生产，又要消费，你不能使用泛型通配符声明列表，比如List\\<Integer>。\n>\n>请参考java.util.Collections里的copy方法(JDK1.7)：copy使用到了PECS原则，实现了对参数的保护。\n>\n>```Java\n>/**\n>     * Copies all of the elements from one list into another.  After the\n>     * operation, the index of each copied element in the destination list\n>     * will be identical to its index in the source list.  The destination\n>     * list must be at least as long as the source list.  If it is longer, the\n>     * remaining elements in the destination list are unaffected. <p>\n>     *\n>     * This method runs in linear time.\n>     *\n>     * @param  <T> the class of the objects in the lists\n>     * @param  dest The destination list.\n>     * @param  src The source list.\n>     * @throws IndexOutOfBoundsException if the destination list is too small\n>     *         to contain the entire source List.\n>     * @throws UnsupportedOperationException if the destination list's\n>     *         list-iterator does not support the <tt>set</tt> operation.\n>     */\n>    public static < T> void copy(List< ? super T> dest, List<? extends T> src) {\n>        int srcSize = src.size();\n>        if (srcSize > dest.size())\n>            throw new IndexOutOfBoundsException(\"Source does not fit in dest\");\n>\n>        if (srcSize < COPY_THRESHOLD ||\n>            (src instanceof RandomAccess && dest instanceof RandomAccess)) {\n>            for (int i=0; i<srcSize; i++)\n>                dest.set(i, src.get(i));\n>        } else {\n>            ListIterator< ? super T> di=dest.listIterator();\n>            ListIterator< ? extends T> si=src.listIterator();\n>            for (int i=0; i<srcSize; i++) {\n>                di.next();\n>                di.set(si.next());\n>            }\n>        }\n>    }\n>```\n>\n>\n\n\n\n\n\n","source":"_posts/super 和 extends.md","raw":"abbrlink: 17\ntitle: 泛型中 < ? extends T > 和 < ? extends T > 的区别\ntags:\n  - java\n  - 泛型\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-01-11 13:55:00\n---\n# 泛型中 < ? extends T > 和 < ? extends T > 的区别\n\n这俩个主要用于对参数的保护，如果你看过Java api 源码的话，你经常看到方法参数类似上面的写法。\n\n### 概要\n\n>1. 类型擦除\n>2. 逆变与协变\n>3. ？ 的用法 \n>4. extends 的用法\n>5. super的用法\n>6. PECS原则\n\n### 类型擦除\n\n>```java\n>import java.util.*;\n>public class main{\n>  public static void main(String[] args){\n>    Class c1 = new ArrayList< String>().getClass();\n>    Class c2 = new ArrayList< Integer>().getClass();\n>    System.out.println(c1 == c2);\n>  }\n>}\n>```\n>\n>上面程序运行的结果是true。出现这个结果的原因正是类型擦除。\n>\n>在Java语言中，泛型是通过类型擦除来实现的，这意味着当你在使用泛型时，任何具体的类型都将被擦除，你唯一知道的就是你正在使用的是一个对象。因此上面List< String> 和List< Integer>在运行时事实上是同样的类型。（泛型类型只有在静态类型检查期间才出现，静态类型检查：基于程序的源代码来验证类型安全的过程；动态类型检查：在程序运行期间验证类型安全的过程；）\n>\n>#### 擦除带来的问题\n>\n>```java\n>class HasF{\n>  public void f(){\n>    System.out.println(\"f\");\n>  }\n>}\n>class Manipulator< T>{\n>  private T obj;\n>  public Manipulator(T x){\n>    obj = x;\n>  }\n>  public void manipulate(){\n>    obj.f();\n>  }\n>}\n>public class main{\n>  \n>  public static  void main(String[] args){\n>    HasF hasf = new HasF();\n>    Manipulator< HasF> m = new Manipulator< HasF>(hasf);\n>    m.manipulate()  // error\n>  }\n>}\n>```\n>\n>上面这段代码会报错，正是由于类型擦除导致的。因为类型擦除，所以泛型内部无法知道类型的信息，当你调用object没有的方法时，就会报错。\n>\n>### 补充一点：边界\n>\n>>因为擦除在方法体中移除了类型信息，所以运行时，你就需要辨别边界，边界是指：对象进入和离开方法的地点，这里是指泛型的方法体。\n>>\n>>```java\n>>public class ArrayMaker< T> {\n>>  private Class< T> kind;\n>>  public ArrayMaker(Class<T> kind) {\n>>    this.kind = kind;\n>>  }\n>>  @SuppressWarnings(\"unchecked\")\n>>  T[] create(int size) {\n>>    return (T[])Array.newInstance(kind, size);\n>>  }\n>>  public static void main(String[] args) {\n>>    ArrayMaker< String> stringMaker =\n>>      new ArrayMaker< String>(String.class);\n>>    String[] stringArray = stringMaker.create(9);\n>>    System.out.println(Arrays.toString(stringArray));\n>>  }\n>>} /* Output:\n>>[null, null, null, null, null, null, null, null, null]\n>>*///:~\n>>```\n>>\n>>上面这段代码就是因为在泛型的方法体中初始化，所以就把所有的类型当成了Object类型，因此输出的结果都是null。如果是String对象的话，输出的是**“  ”**\n>>\n>>仔细查看下面俩段代码：\n>>\n>>```java\n>>// 不存在泛型\n>>public class SimpleHolder {\n>>  private Object obj;\n>>  public void set(Object obj) { this.obj = obj; }\n>>  public Object get() { return obj; }\n>>  public static void main(String[] args) {\n>>    SimpleHolder holder = new SimpleHolder();\n>>    holder.set(\"Item\");\n>>    String s = (String)holder.get();\n>>  }\n>>} ///:~\n>>```\n>>\n>>```java\n>>/// 存在泛型\n>>public class GenericHolder<T> {\n>>  private T obj;\n>>  public void set(T obj) { this.obj = obj; }\n>>  public T get() { return obj; }\n>>  public static void main(String[] args) {\n>>    GenericHolder< String > holder =\n>>      new GenericHolder< String >();\n>>    holder.set(\"Item\");\n>>    String s = holder.get();\n>>  }\n>>} \n>>```\n>>\n>>但是如果你仔细查看俩段代码的字节码，你会发现是相同的。并且你会发现泛型所有的动作都是发生在边界处，会对传进来的值进行额外的编译检查，并插入对传递出去的值的类型。所以，可以得出一个结论，边界就是发生动作的地方。\n\n### 逆变与协变\n\n>协变与逆变这来个术语是用来描述类型转换（type transformations）后的继承关系。定义如下：A,B表示类型**≤ **表示继承关系.(比如：A ≤B表示A是B派生出来的子类  )\n>\n>- 逆变（contravariant），当A≤B时，B可以转化成A。\n>- 协变（covariant），A≤B时，A可以转换成B。\n>- 不变（invariant），如果上述俩种均不能使用。\n>\n>先来看一个简单的例子：\n>\n>考虑List< A >是否是协变，逆变，不变？协变意味着List< String >是List< Object>的子类，逆变意味着List\n>\n>< Object>是List< String>的子类，不变意味着上面俩种都不是。在java中List< String>和List< Object>是不变的类型。下面的代码在java中是编译不过去的，验证了集合在java中是不变的。\n>\n>```java\n>ArrayList<String> strings = new ArrayList<Object>();\n>ArrayList<Object> objects = new ArrayList<String>();\n>```\n>\n>\n>\n>在来看另外一个例子，数组 A[]，判断数组是逆变，协变，不变三个的哪一种？很容易可以证明，在java中数组是协变的\n>\n>```java\n>Object[] objs = new String[3]\n>```\n>\n>下面这个例子是来研究方法,直接通过一个例子来说明\n>\n>```java\n>Number[] method(ArrayList<Number> list) {\n>  ...\n>}\n>//下面三个没有一个能编译过\n>Integer[] result = method(new ArrayList<Integer>());\n>Number[] result = method(new ArrayList<Integer>());\n>Object[] result = method(new ArrayList<Object>());\n>//下面俩个能编译过\n>Number[] result = method(new ArrayList<Number>());\n>Object[] result = method(new ArrayList<Number>());\n>\n>```\n>\n>调用方法`result = method(n)`；传入形参的类型应为method形参的子类型，即`typeof(n)≤typeof(method's parameter)`；result应为method返回值的基类型，即`typeof(methods's return)≤typeof(result)`：\n>\n>在Java 1.4中，子类覆盖（override）父类方法时，形参与返回值的类型必须与父类保持一致：\n>\n>```java\n>class Super {\n>    Number method(Number n) { ... }\n>}\n>\n>class Sub extends Super {\n>    @Override \n>    Number method(Number n) { ... }\n>}\n>```\n>\n>从Java 1.5开始，子类覆盖父类方法时允许协变返回更为具体的类型：\n>\n>```java\n>class Super {\n>    Number method(Number n) { ... }\n>}\n>\n>class Sub extends Super {\n>    @Override \n>    Integer method(Number n) { ... }\n>}\n>```\n\n### ？ 的用法 \n\n>下面是使用案例\n>\n>```Java\n>public class UnboundedWildcardsl {\n>    static List list1;\n>    static List<?> list2;\n>    static List<? extends Object> list3;\n>//    @SuppressWarnings(\"unchecked\")\n>    static void assign1(List list){\n>        list1 = list;\n>        list2 = list;\n>\n>        list3 = list;     //未检查的转换\n>    }\n>    static void assign2(List<?> list){\n>        list1 = list;\n>        list2 = list;\n>        list3 = list;\n>    }\n>    static void assign3(List<? extends Object> list){\n>        list1 = list;\n>        list2 = list;\n>        list3 = list;\n>    }\n>\n>    public static void main(String[] args) {\n>        assign1(new ArrayList());\n>        assign2(new ArrayList());\n>        assign3(new ArrayList());\n>\n>        assign1(new ArrayList<>());\n>        assign2(new ArrayList<>());\n>        assign3(new ArrayList<>());\n>\n>        List<?> wildList = new ArrayList();\n>        wildList = new ArrayList<String>();\n>        assign1(wildList);\n>        assign2(wildList);\n>        assign3(wildList);\n>    }\n>}\n>```\n>\n> 在很多情况下你会看到和这个情况类似，编译器很少关心使用的是原生类型还是< ?>，这些情况< ?> 被认为是一种装饰，不过还是有价值的，即我想用java泛型来编写代码。我在这里并不是要使用原生的类型，但是这种情况下，泛型参数可以支持有任何类型。\n\n### extends 的用法\n\n>extends表示的是上界通配符，下面展示的是如何使用:以 List<? extends Number> 为例来展示使用\n>\n>```Java\n>//Number extends Number \n>List<? extends Number>  foo3 = new ArrayList<? extends Number>();\n>\n>//Integer extends Number\n>List<? extends Number> foo3 = new ArrayList<? extends Integer>();\n>\n>//Double extends Number\n>List<? extends Number> foo3 = new ArrayList<? extends Double>();\n>\n>//下面的是错误使用\n>foo3.add(12);\n>\n>```\n>\n>1. 读取操作通过以上给定的赋值语句，你一定能从foo3列表中读取到的元素的类型是什么呢？你可以读取到Number，因为以上的列表要么包含Number元素，要么包含Number的子类元素。\n>\n>   你不能保证读取到Integer，因为foo3可能指向的是List< Double>。\n>\n>   你不能保证读取到Double，因为foo3可能指向的是List< Integer>。\n>\n>2. 写入操作过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？\n>\n>   你不能插入一个Integer元素，因为foo3可能指向List< Double>。\n>\n>   你不能插入一个Double元素，因为foo3可能指向List< Integer>。\n>\n>   你不能插入一个Number元素，因为foo3可能指向List< Integer>。\n>\n>   你不能往List< ? extends T>中插入任何类型的对象，因为你不能保证列表实际指向的类型是什么，你并不能保证列表中实际存储什么类型的对象。唯一可以保证的是，你可以从中读取到T或者T的子类。这也验证了java集合是不变的，由于无法判断类型，所以你也无法进行插入。\n\n### super 的用法\n\n>super下界通配符，下面以List\\<？ super Integer>来展示super的用法\n>\n>```java\n>//integer is a superClass of Integer \n>List<? super Integer>  foo3 = new ArrayList<Integer>()\n> \n>//Number is a superClass of Integer\n>List<? super Integer> foo3 = new ArrayList<Number>();\n>\n>//Object is superClass of Integer\n>List<? super Integer> foo3 = new ArrayList<Object>();\n>\n>//下面代码是错误的\n>list.get(index);  //不能获取\n>```\n>\n>1. foo3可能指向List< Number>或者List< Object>。\n>\n>   你不能保证读取到Number，因为foo3可能指向List< Object>。\n>\n>   唯一可以保证的是，你可以读取到Object或者Object子类的对象（你并不知道具体的子类是什么）。\n>\n>2. 写入操作通过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？你可以插入Integer对象，因为上述声明的列表都支持Integer。\n>\n>   你可以插入Integer的子类的对象，因为Integer的子类同时也是Integer，原因同上。\n>\n>   你不能插入Double对象，因为foo3可能指向ArrayList< Integer>。\n>\n>   你不能插入Number对象，因为foo3可能指向ArrayList< Integer>。\n>\n>   你不能插入Object对象，因为foo3可能指向ArrayList< Integer>。\n\n#### PECS(Pruducer extends,Consumer super)\n\n>请记住PECS原则：生产者（Producer）使用extends，消费者（Consumer）使用super。\n>\n>- 生产者使用extends\n>\n>如果你需要一个列表提供T类型的元素（即你想从列表中读取T类型的元素），你需要把这个列表声明成\\<? extends T>，比如List\\<? extends Integer>，因此你不能往该列表中添加任何元素。\n>\n>- 消费者使用super\n>\n>如果需要一个列表使用T类型的元素（即你想把T类型的元素加入到列表中），你需要把这个列表声明成\\<? super T>，比如List\\<? super Integer>，因此你不能保证从中读取到的元素的类型。\n>\n>- 即是生产者，也是消费者\n>\n>如果一个列表即要生产，又要消费，你不能使用泛型通配符声明列表，比如List\\<Integer>。\n>\n>请参考java.util.Collections里的copy方法(JDK1.7)：copy使用到了PECS原则，实现了对参数的保护。\n>\n>```Java\n>/**\n>     * Copies all of the elements from one list into another.  After the\n>     * operation, the index of each copied element in the destination list\n>     * will be identical to its index in the source list.  The destination\n>     * list must be at least as long as the source list.  If it is longer, the\n>     * remaining elements in the destination list are unaffected. <p>\n>     *\n>     * This method runs in linear time.\n>     *\n>     * @param  <T> the class of the objects in the lists\n>     * @param  dest The destination list.\n>     * @param  src The source list.\n>     * @throws IndexOutOfBoundsException if the destination list is too small\n>     *         to contain the entire source List.\n>     * @throws UnsupportedOperationException if the destination list's\n>     *         list-iterator does not support the <tt>set</tt> operation.\n>     */\n>    public static < T> void copy(List< ? super T> dest, List<? extends T> src) {\n>        int srcSize = src.size();\n>        if (srcSize > dest.size())\n>            throw new IndexOutOfBoundsException(\"Source does not fit in dest\");\n>\n>        if (srcSize < COPY_THRESHOLD ||\n>            (src instanceof RandomAccess && dest instanceof RandomAccess)) {\n>            for (int i=0; i<srcSize; i++)\n>                dest.set(i, src.get(i));\n>        } else {\n>            ListIterator< ? super T> di=dest.listIterator();\n>            ListIterator< ? extends T> si=src.listIterator();\n>            for (int i=0; i<srcSize; i++) {\n>                di.next();\n>                di.set(si.next());\n>            }\n>        }\n>    }\n>```\n>\n>\n\n\n\n\n\n","slug":"super 和 extends","published":1,"updated":"2019-01-04T01:48:59.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovpb000z9q1u83nnpp1i","content":"<h1 id=\"泛型中-lt-extends-T-gt-和-lt-extends-T-gt-的区别\"><a href=\"#泛型中-lt-extends-T-gt-和-lt-extends-T-gt-的区别\" class=\"headerlink\" title=\"泛型中 &lt; ? extends T &gt; 和 &lt; ? extends T &gt; 的区别\"></a>泛型中 &lt; ? extends T &gt; 和 &lt; ? extends T &gt; 的区别</h1><p>这俩个主要用于对参数的保护，如果你看过Java api 源码的话，你经常看到方法参数类似上面的写法。</p>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>类型擦除</li>\n<li>逆变与协变</li>\n<li>？ 的用法 </li>\n<li>extends 的用法</li>\n<li>super的用法</li>\n<li>PECS原则</li>\n</ol>\n</blockquote>\n<h3 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h3><blockquote>\n<pre><code class=\"java\">import java.util.*;\npublic class main{\n public static void main(String[] args){\n   Class c1 = new ArrayList&lt; String&gt;().getClass();\n   Class c2 = new ArrayList&lt; Integer&gt;().getClass();\n   System.out.println(c1 == c2);\n }\n}\n</code></pre>\n<p>上面程序运行的结果是true。出现这个结果的原因正是类型擦除。</p>\n<p>在Java语言中，泛型是通过类型擦除来实现的，这意味着当你在使用泛型时，任何具体的类型都将被擦除，你唯一知道的就是你正在使用的是一个对象。因此上面List&lt; String&gt; 和List&lt; Integer&gt;在运行时事实上是同样的类型。（泛型类型只有在静态类型检查期间才出现，静态类型检查：基于程序的源代码来验证类型安全的过程；动态类型检查：在程序运行期间验证类型安全的过程；）</p>\n<h4 id=\"擦除带来的问题\"><a href=\"#擦除带来的问题\" class=\"headerlink\" title=\"擦除带来的问题\"></a>擦除带来的问题</h4><pre><code class=\"java\">class HasF{\n public void f(){\n   System.out.println(&quot;f&quot;);\n }\n}\nclass Manipulator&lt; T&gt;{\n private T obj;\n public Manipulator(T x){\n   obj = x;\n }\n public void manipulate(){\n   obj.f();\n }\n}\npublic class main{\n\n public static  void main(String[] args){\n   HasF hasf = new HasF();\n   Manipulator&lt; HasF&gt; m = new Manipulator&lt; HasF&gt;(hasf);\n   m.manipulate()  // error\n }\n}\n</code></pre>\n<p>上面这段代码会报错，正是由于类型擦除导致的。因为类型擦除，所以泛型内部无法知道类型的信息，当你调用object没有的方法时，就会报错。</p>\n<h3 id=\"补充一点：边界\"><a href=\"#补充一点：边界\" class=\"headerlink\" title=\"补充一点：边界\"></a>补充一点：边界</h3><blockquote>\n<p>因为擦除在方法体中移除了类型信息，所以运行时，你就需要辨别边界，边界是指：对象进入和离开方法的地点，这里是指泛型的方法体。</p>\n<pre><code class=\"java\">public class ArrayMaker&lt; T&gt; {\n private Class&lt; T&gt; kind;\n public ArrayMaker(Class&lt;T&gt; kind) {\n   this.kind = kind;\n }\n @SuppressWarnings(&quot;unchecked&quot;)\n T[] create(int size) {\n   return (T[])Array.newInstance(kind, size);\n }\n public static void main(String[] args) {\n   ArrayMaker&lt; String&gt; stringMaker =\n     new ArrayMaker&lt; String&gt;(String.class);\n   String[] stringArray = stringMaker.create(9);\n   System.out.println(Arrays.toString(stringArray));\n }\n} /* Output:\n[null, null, null, null, null, null, null, null, null]\n*///:~\n</code></pre>\n<p>上面这段代码就是因为在泛型的方法体中初始化，所以就把所有的类型当成了Object类型，因此输出的结果都是null。如果是String对象的话，输出的是<strong>“  ”</strong></p>\n<p>仔细查看下面俩段代码：</p>\n<pre><code class=\"java\">// 不存在泛型\npublic class SimpleHolder {\n private Object obj;\n public void set(Object obj) { this.obj = obj; }\n public Object get() { return obj; }\n public static void main(String[] args) {\n   SimpleHolder holder = new SimpleHolder();\n   holder.set(&quot;Item&quot;);\n   String s = (String)holder.get();\n }\n} ///:~\n</code></pre>\n<pre><code class=\"java\">/// 存在泛型\npublic class GenericHolder&lt;T&gt; {\n private T obj;\n public void set(T obj) { this.obj = obj; }\n public T get() { return obj; }\n public static void main(String[] args) {\n   GenericHolder&lt; String &gt; holder =\n     new GenericHolder&lt; String &gt;();\n   holder.set(&quot;Item&quot;);\n   String s = holder.get();\n }\n} \n</code></pre>\n<p>但是如果你仔细查看俩段代码的字节码，你会发现是相同的。并且你会发现泛型所有的动作都是发生在边界处，会对传进来的值进行额外的编译检查，并插入对传递出去的值的类型。所以，可以得出一个结论，边界就是发生动作的地方。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"逆变与协变\"><a href=\"#逆变与协变\" class=\"headerlink\" title=\"逆变与协变\"></a>逆变与协变</h3><blockquote>\n<p>协变与逆变这来个术语是用来描述类型转换（type transformations）后的继承关系。定义如下：A,B表示类型<strong>≤ </strong>表示继承关系.(比如：A ≤B表示A是B派生出来的子类  )</p>\n<ul>\n<li>逆变（contravariant），当A≤B时，B可以转化成A。</li>\n<li>协变（covariant），A≤B时，A可以转换成B。</li>\n<li>不变（invariant），如果上述俩种均不能使用。</li>\n</ul>\n<p>先来看一个简单的例子：</p>\n<p>考虑List&lt; A &gt;是否是协变，逆变，不变？协变意味着List&lt; String &gt;是List&lt; Object&gt;的子类，逆变意味着List</p>\n<p>&lt; Object&gt;是List&lt; String&gt;的子类，不变意味着上面俩种都不是。在java中List&lt; String&gt;和List&lt; Object&gt;是不变的类型。下面的代码在java中是编译不过去的，验证了集合在java中是不变的。</p>\n<pre><code class=\"java\">ArrayList&lt;String&gt; strings = new ArrayList&lt;Object&gt;();\nArrayList&lt;Object&gt; objects = new ArrayList&lt;String&gt;();\n</code></pre>\n<p>在来看另外一个例子，数组 A[]，判断数组是逆变，协变，不变三个的哪一种？很容易可以证明，在java中数组是协变的</p>\n<pre><code class=\"java\">Object[] objs = new String[3]\n</code></pre>\n<p>下面这个例子是来研究方法,直接通过一个例子来说明</p>\n<pre><code class=\"java\">Number[] method(ArrayList&lt;Number&gt; list) {\n ...\n}\n//下面三个没有一个能编译过\nInteger[] result = method(new ArrayList&lt;Integer&gt;());\nNumber[] result = method(new ArrayList&lt;Integer&gt;());\nObject[] result = method(new ArrayList&lt;Object&gt;());\n//下面俩个能编译过\nNumber[] result = method(new ArrayList&lt;Number&gt;());\nObject[] result = method(new ArrayList&lt;Number&gt;());\n\n</code></pre>\n<p>调用方法<code>result = method(n)</code>；传入形参的类型应为method形参的子类型，即<code>typeof(n)≤typeof(method&#39;s parameter)</code>；result应为method返回值的基类型，即<code>typeof(methods&#39;s return)≤typeof(result)</code>：</p>\n<p>在Java 1.4中，子类覆盖（override）父类方法时，形参与返回值的类型必须与父类保持一致：</p>\n<pre><code class=\"java\">class Super {\n   Number method(Number n) { ... }\n}\n\nclass Sub extends Super {\n   @Override \n   Number method(Number n) { ... }\n}\n</code></pre>\n<p>从Java 1.5开始，子类覆盖父类方法时允许协变返回更为具体的类型：</p>\n<pre><code class=\"java\">class Super {\n   Number method(Number n) { ... }\n}\n\nclass Sub extends Super {\n   @Override \n   Integer method(Number n) { ... }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"？-的用法\"><a href=\"#？-的用法\" class=\"headerlink\" title=\"？ 的用法\"></a>？ 的用法</h3><blockquote>\n<p>下面是使用案例</p>\n<pre><code class=\"Java\">public class UnboundedWildcardsl {\n   static List list1;\n   static List&lt;?&gt; list2;\n   static List&lt;? extends Object&gt; list3;\n//    @SuppressWarnings(&quot;unchecked&quot;)\n   static void assign1(List list){\n       list1 = list;\n       list2 = list;\n\n       list3 = list;     //未检查的转换\n   }\n   static void assign2(List&lt;?&gt; list){\n       list1 = list;\n       list2 = list;\n       list3 = list;\n   }\n   static void assign3(List&lt;? extends Object&gt; list){\n       list1 = list;\n       list2 = list;\n       list3 = list;\n   }\n\n   public static void main(String[] args) {\n       assign1(new ArrayList());\n       assign2(new ArrayList());\n       assign3(new ArrayList());\n\n       assign1(new ArrayList&lt;&gt;());\n       assign2(new ArrayList&lt;&gt;());\n       assign3(new ArrayList&lt;&gt;());\n\n       List&lt;?&gt; wildList = new ArrayList();\n       wildList = new ArrayList&lt;String&gt;();\n       assign1(wildList);\n       assign2(wildList);\n       assign3(wildList);\n   }\n}\n</code></pre>\n<p>在很多情况下你会看到和这个情况类似，编译器很少关心使用的是原生类型还是&lt; ?&gt;，这些情况&lt; ?&gt; 被认为是一种装饰，不过还是有价值的，即我想用java泛型来编写代码。我在这里并不是要使用原生的类型，但是这种情况下，泛型参数可以支持有任何类型。</p>\n</blockquote>\n<h3 id=\"extends-的用法\"><a href=\"#extends-的用法\" class=\"headerlink\" title=\"extends 的用法\"></a>extends 的用法</h3><blockquote>\n<p>extends表示的是上界通配符，下面展示的是如何使用:以 List&lt;? extends Number&gt; 为例来展示使用</p>\n<pre><code class=\"Java\">//Number extends Number \nList&lt;? extends Number&gt;  foo3 = new ArrayList&lt;? extends Number&gt;();\n\n//Integer extends Number\nList&lt;? extends Number&gt; foo3 = new ArrayList&lt;? extends Integer&gt;();\n\n//Double extends Number\nList&lt;? extends Number&gt; foo3 = new ArrayList&lt;? extends Double&gt;();\n\n//下面的是错误使用\nfoo3.add(12);\n\n</code></pre>\n<ol>\n<li><p>读取操作通过以上给定的赋值语句，你一定能从foo3列表中读取到的元素的类型是什么呢？你可以读取到Number，因为以上的列表要么包含Number元素，要么包含Number的子类元素。</p>\n<p>你不能保证读取到Integer，因为foo3可能指向的是List&lt; Double&gt;。</p>\n<p>你不能保证读取到Double，因为foo3可能指向的是List&lt; Integer&gt;。</p>\n</li>\n<li><p>写入操作过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？</p>\n<p>你不能插入一个Integer元素，因为foo3可能指向List&lt; Double&gt;。</p>\n<p>你不能插入一个Double元素，因为foo3可能指向List&lt; Integer&gt;。</p>\n<p>你不能插入一个Number元素，因为foo3可能指向List&lt; Integer&gt;。</p>\n<p>你不能往List&lt; ? extends T&gt;中插入任何类型的对象，因为你不能保证列表实际指向的类型是什么，你并不能保证列表中实际存储什么类型的对象。唯一可以保证的是，你可以从中读取到T或者T的子类。这也验证了java集合是不变的，由于无法判断类型，所以你也无法进行插入。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"super-的用法\"><a href=\"#super-的用法\" class=\"headerlink\" title=\"super 的用法\"></a>super 的用法</h3><blockquote>\n<p>super下界通配符，下面以List\\&lt;？ super Integer&gt;来展示super的用法</p>\n<pre><code class=\"java\">//integer is a superClass of Integer \nList&lt;? super Integer&gt;  foo3 = new ArrayList&lt;Integer&gt;()\n\n//Number is a superClass of Integer\nList&lt;? super Integer&gt; foo3 = new ArrayList&lt;Number&gt;();\n\n//Object is superClass of Integer\nList&lt;? super Integer&gt; foo3 = new ArrayList&lt;Object&gt;();\n\n//下面代码是错误的\nlist.get(index);  //不能获取\n</code></pre>\n<ol>\n<li><p>foo3可能指向List&lt; Number&gt;或者List&lt; Object&gt;。</p>\n<p>你不能保证读取到Number，因为foo3可能指向List&lt; Object&gt;。</p>\n<p>唯一可以保证的是，你可以读取到Object或者Object子类的对象（你并不知道具体的子类是什么）。</p>\n</li>\n<li><p>写入操作通过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？你可以插入Integer对象，因为上述声明的列表都支持Integer。</p>\n<p>你可以插入Integer的子类的对象，因为Integer的子类同时也是Integer，原因同上。</p>\n<p>你不能插入Double对象，因为foo3可能指向ArrayList&lt; Integer&gt;。</p>\n<p>你不能插入Number对象，因为foo3可能指向ArrayList&lt; Integer&gt;。</p>\n<p>你不能插入Object对象，因为foo3可能指向ArrayList&lt; Integer&gt;。</p>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"PECS-Pruducer-extends-Consumer-super\"><a href=\"#PECS-Pruducer-extends-Consumer-super\" class=\"headerlink\" title=\"PECS(Pruducer extends,Consumer super)\"></a>PECS(Pruducer extends,Consumer super)</h4><blockquote>\n<p>请记住PECS原则：生产者（Producer）使用extends，消费者（Consumer）使用super。</p>\n<ul>\n<li>生产者使用extends</li>\n</ul>\n<p>如果你需要一个列表提供T类型的元素（即你想从列表中读取T类型的元素），你需要把这个列表声明成\\&lt;? extends T&gt;，比如List\\&lt;? extends Integer&gt;，因此你不能往该列表中添加任何元素。</p>\n<ul>\n<li>消费者使用super</li>\n</ul>\n<p>如果需要一个列表使用T类型的元素（即你想把T类型的元素加入到列表中），你需要把这个列表声明成\\&lt;? super T&gt;，比如List\\&lt;? super Integer&gt;，因此你不能保证从中读取到的元素的类型。</p>\n<ul>\n<li>即是生产者，也是消费者</li>\n</ul>\n<p>如果一个列表即要生产，又要消费，你不能使用泛型通配符声明列表，比如List\\<integer>。</integer></p>\n<p>请参考java.util.Collections里的copy方法(JDK1.7)：copy使用到了PECS原则，实现了对参数的保护。</p>\n<pre><code class=\"Java\">/**\n    * Copies all of the elements from one list into another.  After the\n    * operation, the index of each copied element in the destination list\n    * will be identical to its index in the source list.  The destination\n    * list must be at least as long as the source list.  If it is longer, the\n    * remaining elements in the destination list are unaffected. &lt;p&gt;\n    *\n    * This method runs in linear time.\n    *\n    * @param  &lt;T&gt; the class of the objects in the lists\n    * @param  dest The destination list.\n    * @param  src The source list.\n    * @throws IndexOutOfBoundsException if the destination list is too small\n    *         to contain the entire source List.\n    * @throws UnsupportedOperationException if the destination list&#39;s\n    *         list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.\n    */\n   public static &lt; T&gt; void copy(List&lt; ? super T&gt; dest, List&lt;? extends T&gt; src) {\n       int srcSize = src.size();\n       if (srcSize &gt; dest.size())\n           throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);\n\n       if (srcSize &lt; COPY_THRESHOLD ||\n           (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) {\n           for (int i=0; i&lt;srcSize; i++)\n               dest.set(i, src.get(i));\n       } else {\n           ListIterator&lt; ? super T&gt; di=dest.listIterator();\n           ListIterator&lt; ? extends T&gt; si=src.listIterator();\n           for (int i=0; i&lt;srcSize; i++) {\n               di.next();\n               di.set(si.next());\n           }\n       }\n   }\n</code></pre>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"泛型中-lt-extends-T-gt-和-lt-extends-T-gt-的区别\"><a href=\"#泛型中-lt-extends-T-gt-和-lt-extends-T-gt-的区别\" class=\"headerlink\" title=\"泛型中 &lt; ? extends T &gt; 和 &lt; ? extends T &gt; 的区别\"></a>泛型中 &lt; ? extends T &gt; 和 &lt; ? extends T &gt; 的区别</h1><p>这俩个主要用于对参数的保护，如果你看过Java api 源码的话，你经常看到方法参数类似上面的写法。</p>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>类型擦除</li>\n<li>逆变与协变</li>\n<li>？ 的用法 </li>\n<li>extends 的用法</li>\n<li>super的用法</li>\n<li>PECS原则</li>\n</ol>\n</blockquote>\n<h3 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h3><blockquote>\n<pre><code class=\"java\">import java.util.*;\npublic class main{\n public static void main(String[] args){\n   Class c1 = new ArrayList&lt; String&gt;().getClass();\n   Class c2 = new ArrayList&lt; Integer&gt;().getClass();\n   System.out.println(c1 == c2);\n }\n}\n</code></pre>\n<p>上面程序运行的结果是true。出现这个结果的原因正是类型擦除。</p>\n<p>在Java语言中，泛型是通过类型擦除来实现的，这意味着当你在使用泛型时，任何具体的类型都将被擦除，你唯一知道的就是你正在使用的是一个对象。因此上面List&lt; String&gt; 和List&lt; Integer&gt;在运行时事实上是同样的类型。（泛型类型只有在静态类型检查期间才出现，静态类型检查：基于程序的源代码来验证类型安全的过程；动态类型检查：在程序运行期间验证类型安全的过程；）</p>\n<h4 id=\"擦除带来的问题\"><a href=\"#擦除带来的问题\" class=\"headerlink\" title=\"擦除带来的问题\"></a>擦除带来的问题</h4><pre><code class=\"java\">class HasF{\n public void f(){\n   System.out.println(&quot;f&quot;);\n }\n}\nclass Manipulator&lt; T&gt;{\n private T obj;\n public Manipulator(T x){\n   obj = x;\n }\n public void manipulate(){\n   obj.f();\n }\n}\npublic class main{\n\n public static  void main(String[] args){\n   HasF hasf = new HasF();\n   Manipulator&lt; HasF&gt; m = new Manipulator&lt; HasF&gt;(hasf);\n   m.manipulate()  // error\n }\n}\n</code></pre>\n<p>上面这段代码会报错，正是由于类型擦除导致的。因为类型擦除，所以泛型内部无法知道类型的信息，当你调用object没有的方法时，就会报错。</p>\n<h3 id=\"补充一点：边界\"><a href=\"#补充一点：边界\" class=\"headerlink\" title=\"补充一点：边界\"></a>补充一点：边界</h3><blockquote>\n<p>因为擦除在方法体中移除了类型信息，所以运行时，你就需要辨别边界，边界是指：对象进入和离开方法的地点，这里是指泛型的方法体。</p>\n<pre><code class=\"java\">public class ArrayMaker&lt; T&gt; {\n private Class&lt; T&gt; kind;\n public ArrayMaker(Class&lt;T&gt; kind) {\n   this.kind = kind;\n }\n @SuppressWarnings(&quot;unchecked&quot;)\n T[] create(int size) {\n   return (T[])Array.newInstance(kind, size);\n }\n public static void main(String[] args) {\n   ArrayMaker&lt; String&gt; stringMaker =\n     new ArrayMaker&lt; String&gt;(String.class);\n   String[] stringArray = stringMaker.create(9);\n   System.out.println(Arrays.toString(stringArray));\n }\n} /* Output:\n[null, null, null, null, null, null, null, null, null]\n*///:~\n</code></pre>\n<p>上面这段代码就是因为在泛型的方法体中初始化，所以就把所有的类型当成了Object类型，因此输出的结果都是null。如果是String对象的话，输出的是<strong>“  ”</strong></p>\n<p>仔细查看下面俩段代码：</p>\n<pre><code class=\"java\">// 不存在泛型\npublic class SimpleHolder {\n private Object obj;\n public void set(Object obj) { this.obj = obj; }\n public Object get() { return obj; }\n public static void main(String[] args) {\n   SimpleHolder holder = new SimpleHolder();\n   holder.set(&quot;Item&quot;);\n   String s = (String)holder.get();\n }\n} ///:~\n</code></pre>\n<pre><code class=\"java\">/// 存在泛型\npublic class GenericHolder&lt;T&gt; {\n private T obj;\n public void set(T obj) { this.obj = obj; }\n public T get() { return obj; }\n public static void main(String[] args) {\n   GenericHolder&lt; String &gt; holder =\n     new GenericHolder&lt; String &gt;();\n   holder.set(&quot;Item&quot;);\n   String s = holder.get();\n }\n} \n</code></pre>\n<p>但是如果你仔细查看俩段代码的字节码，你会发现是相同的。并且你会发现泛型所有的动作都是发生在边界处，会对传进来的值进行额外的编译检查，并插入对传递出去的值的类型。所以，可以得出一个结论，边界就是发生动作的地方。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"逆变与协变\"><a href=\"#逆变与协变\" class=\"headerlink\" title=\"逆变与协变\"></a>逆变与协变</h3><blockquote>\n<p>协变与逆变这来个术语是用来描述类型转换（type transformations）后的继承关系。定义如下：A,B表示类型<strong>≤ </strong>表示继承关系.(比如：A ≤B表示A是B派生出来的子类  )</p>\n<ul>\n<li>逆变（contravariant），当A≤B时，B可以转化成A。</li>\n<li>协变（covariant），A≤B时，A可以转换成B。</li>\n<li>不变（invariant），如果上述俩种均不能使用。</li>\n</ul>\n<p>先来看一个简单的例子：</p>\n<p>考虑List&lt; A &gt;是否是协变，逆变，不变？协变意味着List&lt; String &gt;是List&lt; Object&gt;的子类，逆变意味着List</p>\n<p>&lt; Object&gt;是List&lt; String&gt;的子类，不变意味着上面俩种都不是。在java中List&lt; String&gt;和List&lt; Object&gt;是不变的类型。下面的代码在java中是编译不过去的，验证了集合在java中是不变的。</p>\n<pre><code class=\"java\">ArrayList&lt;String&gt; strings = new ArrayList&lt;Object&gt;();\nArrayList&lt;Object&gt; objects = new ArrayList&lt;String&gt;();\n</code></pre>\n<p>在来看另外一个例子，数组 A[]，判断数组是逆变，协变，不变三个的哪一种？很容易可以证明，在java中数组是协变的</p>\n<pre><code class=\"java\">Object[] objs = new String[3]\n</code></pre>\n<p>下面这个例子是来研究方法,直接通过一个例子来说明</p>\n<pre><code class=\"java\">Number[] method(ArrayList&lt;Number&gt; list) {\n ...\n}\n//下面三个没有一个能编译过\nInteger[] result = method(new ArrayList&lt;Integer&gt;());\nNumber[] result = method(new ArrayList&lt;Integer&gt;());\nObject[] result = method(new ArrayList&lt;Object&gt;());\n//下面俩个能编译过\nNumber[] result = method(new ArrayList&lt;Number&gt;());\nObject[] result = method(new ArrayList&lt;Number&gt;());\n\n</code></pre>\n<p>调用方法<code>result = method(n)</code>；传入形参的类型应为method形参的子类型，即<code>typeof(n)≤typeof(method&#39;s parameter)</code>；result应为method返回值的基类型，即<code>typeof(methods&#39;s return)≤typeof(result)</code>：</p>\n<p>在Java 1.4中，子类覆盖（override）父类方法时，形参与返回值的类型必须与父类保持一致：</p>\n<pre><code class=\"java\">class Super {\n   Number method(Number n) { ... }\n}\n\nclass Sub extends Super {\n   @Override \n   Number method(Number n) { ... }\n}\n</code></pre>\n<p>从Java 1.5开始，子类覆盖父类方法时允许协变返回更为具体的类型：</p>\n<pre><code class=\"java\">class Super {\n   Number method(Number n) { ... }\n}\n\nclass Sub extends Super {\n   @Override \n   Integer method(Number n) { ... }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"？-的用法\"><a href=\"#？-的用法\" class=\"headerlink\" title=\"？ 的用法\"></a>？ 的用法</h3><blockquote>\n<p>下面是使用案例</p>\n<pre><code class=\"Java\">public class UnboundedWildcardsl {\n   static List list1;\n   static List&lt;?&gt; list2;\n   static List&lt;? extends Object&gt; list3;\n//    @SuppressWarnings(&quot;unchecked&quot;)\n   static void assign1(List list){\n       list1 = list;\n       list2 = list;\n\n       list3 = list;     //未检查的转换\n   }\n   static void assign2(List&lt;?&gt; list){\n       list1 = list;\n       list2 = list;\n       list3 = list;\n   }\n   static void assign3(List&lt;? extends Object&gt; list){\n       list1 = list;\n       list2 = list;\n       list3 = list;\n   }\n\n   public static void main(String[] args) {\n       assign1(new ArrayList());\n       assign2(new ArrayList());\n       assign3(new ArrayList());\n\n       assign1(new ArrayList&lt;&gt;());\n       assign2(new ArrayList&lt;&gt;());\n       assign3(new ArrayList&lt;&gt;());\n\n       List&lt;?&gt; wildList = new ArrayList();\n       wildList = new ArrayList&lt;String&gt;();\n       assign1(wildList);\n       assign2(wildList);\n       assign3(wildList);\n   }\n}\n</code></pre>\n<p>在很多情况下你会看到和这个情况类似，编译器很少关心使用的是原生类型还是&lt; ?&gt;，这些情况&lt; ?&gt; 被认为是一种装饰，不过还是有价值的，即我想用java泛型来编写代码。我在这里并不是要使用原生的类型，但是这种情况下，泛型参数可以支持有任何类型。</p>\n</blockquote>\n<h3 id=\"extends-的用法\"><a href=\"#extends-的用法\" class=\"headerlink\" title=\"extends 的用法\"></a>extends 的用法</h3><blockquote>\n<p>extends表示的是上界通配符，下面展示的是如何使用:以 List&lt;? extends Number&gt; 为例来展示使用</p>\n<pre><code class=\"Java\">//Number extends Number \nList&lt;? extends Number&gt;  foo3 = new ArrayList&lt;? extends Number&gt;();\n\n//Integer extends Number\nList&lt;? extends Number&gt; foo3 = new ArrayList&lt;? extends Integer&gt;();\n\n//Double extends Number\nList&lt;? extends Number&gt; foo3 = new ArrayList&lt;? extends Double&gt;();\n\n//下面的是错误使用\nfoo3.add(12);\n\n</code></pre>\n<ol>\n<li><p>读取操作通过以上给定的赋值语句，你一定能从foo3列表中读取到的元素的类型是什么呢？你可以读取到Number，因为以上的列表要么包含Number元素，要么包含Number的子类元素。</p>\n<p>你不能保证读取到Integer，因为foo3可能指向的是List&lt; Double&gt;。</p>\n<p>你不能保证读取到Double，因为foo3可能指向的是List&lt; Integer&gt;。</p>\n</li>\n<li><p>写入操作过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？</p>\n<p>你不能插入一个Integer元素，因为foo3可能指向List&lt; Double&gt;。</p>\n<p>你不能插入一个Double元素，因为foo3可能指向List&lt; Integer&gt;。</p>\n<p>你不能插入一个Number元素，因为foo3可能指向List&lt; Integer&gt;。</p>\n<p>你不能往List&lt; ? extends T&gt;中插入任何类型的对象，因为你不能保证列表实际指向的类型是什么，你并不能保证列表中实际存储什么类型的对象。唯一可以保证的是，你可以从中读取到T或者T的子类。这也验证了java集合是不变的，由于无法判断类型，所以你也无法进行插入。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"super-的用法\"><a href=\"#super-的用法\" class=\"headerlink\" title=\"super 的用法\"></a>super 的用法</h3><blockquote>\n<p>super下界通配符，下面以List\\&lt;？ super Integer&gt;来展示super的用法</p>\n<pre><code class=\"java\">//integer is a superClass of Integer \nList&lt;? super Integer&gt;  foo3 = new ArrayList&lt;Integer&gt;()\n\n//Number is a superClass of Integer\nList&lt;? super Integer&gt; foo3 = new ArrayList&lt;Number&gt;();\n\n//Object is superClass of Integer\nList&lt;? super Integer&gt; foo3 = new ArrayList&lt;Object&gt;();\n\n//下面代码是错误的\nlist.get(index);  //不能获取\n</code></pre>\n<ol>\n<li><p>foo3可能指向List&lt; Number&gt;或者List&lt; Object&gt;。</p>\n<p>你不能保证读取到Number，因为foo3可能指向List&lt; Object&gt;。</p>\n<p>唯一可以保证的是，你可以读取到Object或者Object子类的对象（你并不知道具体的子类是什么）。</p>\n</li>\n<li><p>写入操作通过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？你可以插入Integer对象，因为上述声明的列表都支持Integer。</p>\n<p>你可以插入Integer的子类的对象，因为Integer的子类同时也是Integer，原因同上。</p>\n<p>你不能插入Double对象，因为foo3可能指向ArrayList&lt; Integer&gt;。</p>\n<p>你不能插入Number对象，因为foo3可能指向ArrayList&lt; Integer&gt;。</p>\n<p>你不能插入Object对象，因为foo3可能指向ArrayList&lt; Integer&gt;。</p>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"PECS-Pruducer-extends-Consumer-super\"><a href=\"#PECS-Pruducer-extends-Consumer-super\" class=\"headerlink\" title=\"PECS(Pruducer extends,Consumer super)\"></a>PECS(Pruducer extends,Consumer super)</h4><blockquote>\n<p>请记住PECS原则：生产者（Producer）使用extends，消费者（Consumer）使用super。</p>\n<ul>\n<li>生产者使用extends</li>\n</ul>\n<p>如果你需要一个列表提供T类型的元素（即你想从列表中读取T类型的元素），你需要把这个列表声明成\\&lt;? extends T&gt;，比如List\\&lt;? extends Integer&gt;，因此你不能往该列表中添加任何元素。</p>\n<ul>\n<li>消费者使用super</li>\n</ul>\n<p>如果需要一个列表使用T类型的元素（即你想把T类型的元素加入到列表中），你需要把这个列表声明成\\&lt;? super T&gt;，比如List\\&lt;? super Integer&gt;，因此你不能保证从中读取到的元素的类型。</p>\n<ul>\n<li>即是生产者，也是消费者</li>\n</ul>\n<p>如果一个列表即要生产，又要消费，你不能使用泛型通配符声明列表，比如List\\<integer>。</integer></p>\n<p>请参考java.util.Collections里的copy方法(JDK1.7)：copy使用到了PECS原则，实现了对参数的保护。</p>\n<pre><code class=\"Java\">/**\n    * Copies all of the elements from one list into another.  After the\n    * operation, the index of each copied element in the destination list\n    * will be identical to its index in the source list.  The destination\n    * list must be at least as long as the source list.  If it is longer, the\n    * remaining elements in the destination list are unaffected. &lt;p&gt;\n    *\n    * This method runs in linear time.\n    *\n    * @param  &lt;T&gt; the class of the objects in the lists\n    * @param  dest The destination list.\n    * @param  src The source list.\n    * @throws IndexOutOfBoundsException if the destination list is too small\n    *         to contain the entire source List.\n    * @throws UnsupportedOperationException if the destination list&#39;s\n    *         list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.\n    */\n   public static &lt; T&gt; void copy(List&lt; ? super T&gt; dest, List&lt;? extends T&gt; src) {\n       int srcSize = src.size();\n       if (srcSize &gt; dest.size())\n           throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);\n\n       if (srcSize &lt; COPY_THRESHOLD ||\n           (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) {\n           for (int i=0; i&lt;srcSize; i++)\n               dest.set(i, src.get(i));\n       } else {\n           ListIterator&lt; ? super T&gt; di=dest.listIterator();\n           ListIterator&lt; ? extends T&gt; si=src.listIterator();\n           for (int i=0; i&lt;srcSize; i++) {\n               di.next();\n               di.set(si.next());\n           }\n       }\n   }\n</code></pre>\n</blockquote>\n"},{"abbrlink":15,"title":"内部类的定义与分类","author":"zhangke","date":"2018-03-22T09:14:00.000Z","_content":"# 内部类的定义与分类\n\n>在《Thinking in Java》这本书里面给出的定义是：可以将一个类的定义放在另一个类的定义内部就是内部类。用一段代码来说明就是下面这样的\n>\n>```\n>class Outter{\n>  class InnerClass{}\n>}\n>```\n>\n>其中InnerClass就是内部类。\n>\n>内部类大体上可以划分为以下几种：成员内部类，局部内部类，静态内部类，匿名内部类。下面我将依次讲解这几种内部类。\n>\n>\n\n### 成员内部类\n\n> 成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，即使是private属性成员和方法也可以访问。但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。\n>\n> 在成员内部类中要注意的几点：\n>\n> **第一：**成员内部类中不能存在任何static的变量和方法；\n>\n> **第二：**成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。\n>\n> **第三**：成员内部类也是有包的权限的，如果是public，则在任何一个包下面都可以使用，没有权限修饰符的则  \n>\n> ​           只能在当前包下面使用。private则只能在当前类中使用，protected则可以在子类中使用。\n>\n> 下面我们来看一个案例\n>\n> ```java\n> public class OuterClass {\n>    private String str;\n>    \n>    public void outerDisplay(){\n>        System.out.println(\"outerClass...\");\n>    }\n>    \n>    public class InnerClass{\n>        public void innerDisplay(){\n>            //使用外围内的属性\n>            str = \"chenssy...\";\n>            System.out.println(str);\n>            //使用外围内的方法\n>            outerDisplay();\n>        }\n>    }\n>    \n>    /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */\n>    public InnerClass getInnerClass(){\n>        return new InnerClass();\n>    }\n>    \n>    public static void main(String[] args) {\n>        OuterClass outer = new OuterClass();\n>        OuterClass.InnerClass inner = outer.getInnerClass();\n>        inner.innerDisplay();\n>    }\n> }\n> --------------------\n> chenssy...\n> outerClass...\n> ```\n>\n> ### .this 和 .new的使用\n>\n> 如果你需要在内部类生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。\n>\n> ### **.this**使用\n>\n> >```\n> >public class OutterClass {\n> >\n> >\n> >    private int key = 0;\n> >    private int key2 = 0;\n> >\n> >\n> >    public static void main(String[] args) {\n> >        OutterClass k1 = new OutterClass();\n> >        InnerClass in = k1.new InnerClass(); //生成内部类\n> >        OutterClass k2 = in.getOutterClass(); //通过 .this 来生成外部类\n> >        System.out.println(k1 == k2); //true 说明俩个对象指向同一个引用\n> >    }\n> >\n> >    public int getKey() {\n> >        return this.key;\n> >    }\n> >\n> >    public class InnerClass {\n> >\n> >        public InnerClass() {\n> >            key = 12;\n> >            key2 = 13;\n> >        }\n> >\n> >        public int getKey() {\n> >            // 通过 .this 来使用外部类的getKey\n> >            return OutterClass.this.getKey();\n> >        }\n> >\t\t// 使用 .this 返回外部类对象\n> >        public OutterClass getOutterClass() {\n> >            return OutterClass.this;\n> >        }\n> >    }\n> >}\n> >---------------\n> >outPut:\n> >true\n> >```\n> >\n> >这个例子演示了**.this**的使用，同时也证明了**.this**返回的就是外部类生成的对象。\n>\n> ###  **.new **使用\n>\n> > 如果希望创建内部类对象，则必须先拥有外部类对象前提下才能创建，这是因为内部类对象会暗暗地连接到创建它的外部类对象上。这里就先不仔细说明，等看过例子之后在来说明好理解一些。创建内部类的格式是\n> >\n> > ```\n> > outterObject.new    outterclass.innerClass\n> > ```\n> >\n> > 也就是外部类的对象后面跟上圆点和new。\n> >\n> > ```\n> > public class OuterClass {\n> >    private String name ;\n> >    private int age;\n> >\n> >    /**省略getter和setter方法**/\n> >    \n> >    public class InnerClass{\n> >        public InnerClass(){\n> >            name = \"chenssy\";\n> >            age = 23;\n> >        }\n> >        \n> >        public void display(){\n> >            System.out.println(\"name：\" + getName() +\"   ;age：\" + getAge());\n> >        }\n> >    }\n> >    \n> >    public static void main(String[] args) {\n> >        OuterClass outerClass = new OuterClass();\n> >        OuterClass.InnerClass innerClass = outerClass.new InnerClass();\n> >        innerClass.display();\n> >    }\n> > }\n> > --------------\n> > Output：\n> > name：chenssy   ;age：23\n> > ```\n> >\n> > \n>\n> \n>\n> 通过上面的例子你大概能明白**.this**和**.new**的作用。\n>\n> 通过上面的介绍相信你对成员内部类有一定的了解了，但肯定也会有一些以后，为什么内部类会自动拥有对其外部类所有成员的访问权。这是如何做到的呢？当某个外部类创建完一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，当你访问此外围类的成员时，就是用那个引用来选择外围类的成员。幸运的是，编译器会帮你处理所有的细节。\n>\n> \n>\n> \n\n### 局部内部类\n\n>其实这个名字不是太好，但是又不知道起什么名字。这一部分讲解的类主要是在方法和作用域内的内部类。在一个方法里面或者任意的作用域内定义内部类的理由有俩个：\n>\n>1. 实现了某类型的接口，于是可以创建并返回对其的引用。\n>2. 你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但又不希望这个类是公共可用的。\n>\n>下面使用来个具体的例子来讲解，因为这一部分没有什么好讲解的，主要是自己体会。\n>\n>```Java\n>public class Parcel5{\n>  private int i= 0;\n>  public Destination destination(String s ){\n>    class PDestination implements Destination{\n>      private String label;\n>      private PDestination(Strng whereTo){\n>        label = whereTo;\n>      }\n>      public String readLable(){\n>        return label;\n>      }\n>    }\n>    return new PDestination(s);\n>  }\n>  public static void main(String[] args){\n>    Parcel5 p =new Parcel5();\n>    Destination d = p.destination(\"fuyang\");\n>  }\n>}\n>```\n>\n>上面的代码演示的是定义在方法中的内部类，不过在这里有一点需要注意的是，这个内部类的范围是在方法内。也就是他的作用域就在方法内部。所以方法外面的属性是访问不到的，但是可以访问方法内的变量。\n>\n>```java\n>public class Parcel6 {\n>    private void internalTracking(boolean b){\n>        if(b){\n>            class TrackingSlip{\n>                private String id;\n>                TrackingSlip(String s) {\n>                    id = s;\n>                }\n>                String getSlip(){\n>                    return id;\n>                }\n>            }\n>            TrackingSlip ts = new TrackingSlip(\"chenssy\");\n>            String string = ts.getSlip();\n>        }\n>      \n>      \t// 到这里就不能使用上面定义的TrackingSlip内部类了。\n>        //下面这句话就会编译报错\n>      \t// TrackingSlip ts = new TrackingSlip(\"chenssy\");\n>    }\n>    \n>    public void track(){\n>        internalTracking(true);\n>    }\n>    \n>    public static void main(String[] args) {\n>        Parcel6 parcel6 = new Parcel6();\n>        parcel6.track();\n>    }\n>}\n>```\n>\n>\n>\n>\n\n### 静态内部类\n\n> 使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：\n>\n> ​      **1、** 它的创建是不需要依赖于外围类的。\n>\n> ​      **2、** 它不能使用任何外围类的非static成员变量和方法。\n>\n> ```java\n> public class OuterClass {\n>    private String sex;\n>    public static String name = \"chenssy\";\n>    \n>    /**\n>     *静态内部类\n>     */\n>    static class InnerClass1{\n>        /* 在静态内部类中可以存在静态成员 */\n>        public static String _name1 = \"chenssy_static\";\n>        \n>        public void display(){\n>            /* \n>             * 静态内部类只能访问外围类的静态成员变量和方法\n>             * 不能访问外围类的非静态成员变量和方法\n>             */\n>            System.out.println(\"OutClass name :\" + name);\n>        }\n>    }\n>    \n>    /**\n>     * 非静态内部类\n>     */\n>    class InnerClass2{\n>        /* 非静态内部类中不能存在静态成员 */\n>        public String _name2 = \"chenssy_inner\";\n>        /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */\n>        public void display(){\n>            System.out.println(\"OuterClass name：\" + name);\n>        }\n>    }\n>    \n>  \n>    public void display(){\n>        /* 外围类访问静态内部类：内部类. */\n>        System.out.println(InnerClass1._name1);\n>        /* 静态内部类 可以直接创建实例不需要依赖于外围类 */\n>        new InnerClass1().display();\n>        \n>        /* 非静态内部的创建需要依赖于外围类 */\n>        OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2();\n>        /* 方位非静态内部类的成员需要使用非静态内部类的实例 */\n>        System.out.println(inner2._name2);\n>        inner2.display();\n>    }\n>    \n>    public static void main(String[] args) {\n>        OuterClass outer = new OuterClass();\n>        outer.display();\n>    }\n> }\n> ----------------\n> Output:\n> chenssy_static\n> OutClass name :chenssy\n> chenssy_inner\n> OuterClass name：chenssy\n> ```\n>\n> \n>\n> \n\n### 匿名内部类\n\n>匿名内部类可以简单理解就是没有名字的类。我们直接用例子演示可以说的更清楚。\n>\n>```java\n>button2.addActionListener(  \n>                new ActionListener(){  \n>                    public void actionPerformed(ActionEvent e) {  \n>                        System.out.println(\"你按了按钮二\");  \n>                    }  \n>                });\n>```\n>\n>相信很多人都写过与上面类似的代码，这其实就是匿名类。其实就是在定义的时候就创建这个类的对象，但因为没有类名，所以以后就不能在创建使用。\n>\n>````java\n>public class OuterClass {\n>    public InnerClass getInnerClass(final int num,String str2){\n>        return new InnerClass(){\n>            int number = num + 3;\n>            public int getNumber(){\n>                return number;\n>            }\n>        };  /* 注意：分号不能省 */\n>    }\n>    \n>    public static void main(String[] args) {\n>        OuterClass out = new OuterClass();\n>        InnerClass inner = out.getInnerClass(2, \"chenssy\");\n>        System.out.println(inner.getNumber());\n>    }\n>}\n>\n>interface InnerClass {\n>    int getNumber();\n>}\n>\n>----------------\n>Output:\n>````\n>\n>  这里我们就需要看清几个地方\n>\n>​        **1、** 匿名内部类是没有访问修饰符的。\n>\n>​        **2、** new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。\n>\n>​         **3、** 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。\n>\n>​        **4、** 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。\n>\n>\n>\n>\n\n### 为什么要使用内部类\n\n>​        使用内部类最吸引人的原因是：**每个内部类都能独立的继承自一个接口的实现，所以无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响**。\n>\n>​         在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。\n>\n>同时使用内部类还可以获得以下的一些特性：\n>\n>1. 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围里对象的信息相互独立。\n>2. 在单个外围类中，可以多个内部类以不同的方式实现同一个接口或者继承同一个类。\n>3. 创建内部类对象的时刻并不依赖于外部类的创建。\n>4. 内部类并没有令人迷惑的\"is-a\"关系，他就是一个独立的实体。\n>\n>以上主要摘自《Thinking in java》","source":"_posts/内部类.md","raw":"abbrlink: 15\ntitle: 内部类的定义与分类\ntags:\n  - java基础\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-03-22 17:14:00\n---\n# 内部类的定义与分类\n\n>在《Thinking in Java》这本书里面给出的定义是：可以将一个类的定义放在另一个类的定义内部就是内部类。用一段代码来说明就是下面这样的\n>\n>```\n>class Outter{\n>  class InnerClass{}\n>}\n>```\n>\n>其中InnerClass就是内部类。\n>\n>内部类大体上可以划分为以下几种：成员内部类，局部内部类，静态内部类，匿名内部类。下面我将依次讲解这几种内部类。\n>\n>\n\n### 成员内部类\n\n> 成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，即使是private属性成员和方法也可以访问。但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。\n>\n> 在成员内部类中要注意的几点：\n>\n> **第一：**成员内部类中不能存在任何static的变量和方法；\n>\n> **第二：**成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。\n>\n> **第三**：成员内部类也是有包的权限的，如果是public，则在任何一个包下面都可以使用，没有权限修饰符的则  \n>\n> ​           只能在当前包下面使用。private则只能在当前类中使用，protected则可以在子类中使用。\n>\n> 下面我们来看一个案例\n>\n> ```java\n> public class OuterClass {\n>    private String str;\n>    \n>    public void outerDisplay(){\n>        System.out.println(\"outerClass...\");\n>    }\n>    \n>    public class InnerClass{\n>        public void innerDisplay(){\n>            //使用外围内的属性\n>            str = \"chenssy...\";\n>            System.out.println(str);\n>            //使用外围内的方法\n>            outerDisplay();\n>        }\n>    }\n>    \n>    /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */\n>    public InnerClass getInnerClass(){\n>        return new InnerClass();\n>    }\n>    \n>    public static void main(String[] args) {\n>        OuterClass outer = new OuterClass();\n>        OuterClass.InnerClass inner = outer.getInnerClass();\n>        inner.innerDisplay();\n>    }\n> }\n> --------------------\n> chenssy...\n> outerClass...\n> ```\n>\n> ### .this 和 .new的使用\n>\n> 如果你需要在内部类生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。\n>\n> ### **.this**使用\n>\n> >```\n> >public class OutterClass {\n> >\n> >\n> >    private int key = 0;\n> >    private int key2 = 0;\n> >\n> >\n> >    public static void main(String[] args) {\n> >        OutterClass k1 = new OutterClass();\n> >        InnerClass in = k1.new InnerClass(); //生成内部类\n> >        OutterClass k2 = in.getOutterClass(); //通过 .this 来生成外部类\n> >        System.out.println(k1 == k2); //true 说明俩个对象指向同一个引用\n> >    }\n> >\n> >    public int getKey() {\n> >        return this.key;\n> >    }\n> >\n> >    public class InnerClass {\n> >\n> >        public InnerClass() {\n> >            key = 12;\n> >            key2 = 13;\n> >        }\n> >\n> >        public int getKey() {\n> >            // 通过 .this 来使用外部类的getKey\n> >            return OutterClass.this.getKey();\n> >        }\n> >\t\t// 使用 .this 返回外部类对象\n> >        public OutterClass getOutterClass() {\n> >            return OutterClass.this;\n> >        }\n> >    }\n> >}\n> >---------------\n> >outPut:\n> >true\n> >```\n> >\n> >这个例子演示了**.this**的使用，同时也证明了**.this**返回的就是外部类生成的对象。\n>\n> ###  **.new **使用\n>\n> > 如果希望创建内部类对象，则必须先拥有外部类对象前提下才能创建，这是因为内部类对象会暗暗地连接到创建它的外部类对象上。这里就先不仔细说明，等看过例子之后在来说明好理解一些。创建内部类的格式是\n> >\n> > ```\n> > outterObject.new    outterclass.innerClass\n> > ```\n> >\n> > 也就是外部类的对象后面跟上圆点和new。\n> >\n> > ```\n> > public class OuterClass {\n> >    private String name ;\n> >    private int age;\n> >\n> >    /**省略getter和setter方法**/\n> >    \n> >    public class InnerClass{\n> >        public InnerClass(){\n> >            name = \"chenssy\";\n> >            age = 23;\n> >        }\n> >        \n> >        public void display(){\n> >            System.out.println(\"name：\" + getName() +\"   ;age：\" + getAge());\n> >        }\n> >    }\n> >    \n> >    public static void main(String[] args) {\n> >        OuterClass outerClass = new OuterClass();\n> >        OuterClass.InnerClass innerClass = outerClass.new InnerClass();\n> >        innerClass.display();\n> >    }\n> > }\n> > --------------\n> > Output：\n> > name：chenssy   ;age：23\n> > ```\n> >\n> > \n>\n> \n>\n> 通过上面的例子你大概能明白**.this**和**.new**的作用。\n>\n> 通过上面的介绍相信你对成员内部类有一定的了解了，但肯定也会有一些以后，为什么内部类会自动拥有对其外部类所有成员的访问权。这是如何做到的呢？当某个外部类创建完一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，当你访问此外围类的成员时，就是用那个引用来选择外围类的成员。幸运的是，编译器会帮你处理所有的细节。\n>\n> \n>\n> \n\n### 局部内部类\n\n>其实这个名字不是太好，但是又不知道起什么名字。这一部分讲解的类主要是在方法和作用域内的内部类。在一个方法里面或者任意的作用域内定义内部类的理由有俩个：\n>\n>1. 实现了某类型的接口，于是可以创建并返回对其的引用。\n>2. 你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但又不希望这个类是公共可用的。\n>\n>下面使用来个具体的例子来讲解，因为这一部分没有什么好讲解的，主要是自己体会。\n>\n>```Java\n>public class Parcel5{\n>  private int i= 0;\n>  public Destination destination(String s ){\n>    class PDestination implements Destination{\n>      private String label;\n>      private PDestination(Strng whereTo){\n>        label = whereTo;\n>      }\n>      public String readLable(){\n>        return label;\n>      }\n>    }\n>    return new PDestination(s);\n>  }\n>  public static void main(String[] args){\n>    Parcel5 p =new Parcel5();\n>    Destination d = p.destination(\"fuyang\");\n>  }\n>}\n>```\n>\n>上面的代码演示的是定义在方法中的内部类，不过在这里有一点需要注意的是，这个内部类的范围是在方法内。也就是他的作用域就在方法内部。所以方法外面的属性是访问不到的，但是可以访问方法内的变量。\n>\n>```java\n>public class Parcel6 {\n>    private void internalTracking(boolean b){\n>        if(b){\n>            class TrackingSlip{\n>                private String id;\n>                TrackingSlip(String s) {\n>                    id = s;\n>                }\n>                String getSlip(){\n>                    return id;\n>                }\n>            }\n>            TrackingSlip ts = new TrackingSlip(\"chenssy\");\n>            String string = ts.getSlip();\n>        }\n>      \n>      \t// 到这里就不能使用上面定义的TrackingSlip内部类了。\n>        //下面这句话就会编译报错\n>      \t// TrackingSlip ts = new TrackingSlip(\"chenssy\");\n>    }\n>    \n>    public void track(){\n>        internalTracking(true);\n>    }\n>    \n>    public static void main(String[] args) {\n>        Parcel6 parcel6 = new Parcel6();\n>        parcel6.track();\n>    }\n>}\n>```\n>\n>\n>\n>\n\n### 静态内部类\n\n> 使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：\n>\n> ​      **1、** 它的创建是不需要依赖于外围类的。\n>\n> ​      **2、** 它不能使用任何外围类的非static成员变量和方法。\n>\n> ```java\n> public class OuterClass {\n>    private String sex;\n>    public static String name = \"chenssy\";\n>    \n>    /**\n>     *静态内部类\n>     */\n>    static class InnerClass1{\n>        /* 在静态内部类中可以存在静态成员 */\n>        public static String _name1 = \"chenssy_static\";\n>        \n>        public void display(){\n>            /* \n>             * 静态内部类只能访问外围类的静态成员变量和方法\n>             * 不能访问外围类的非静态成员变量和方法\n>             */\n>            System.out.println(\"OutClass name :\" + name);\n>        }\n>    }\n>    \n>    /**\n>     * 非静态内部类\n>     */\n>    class InnerClass2{\n>        /* 非静态内部类中不能存在静态成员 */\n>        public String _name2 = \"chenssy_inner\";\n>        /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */\n>        public void display(){\n>            System.out.println(\"OuterClass name：\" + name);\n>        }\n>    }\n>    \n>  \n>    public void display(){\n>        /* 外围类访问静态内部类：内部类. */\n>        System.out.println(InnerClass1._name1);\n>        /* 静态内部类 可以直接创建实例不需要依赖于外围类 */\n>        new InnerClass1().display();\n>        \n>        /* 非静态内部的创建需要依赖于外围类 */\n>        OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2();\n>        /* 方位非静态内部类的成员需要使用非静态内部类的实例 */\n>        System.out.println(inner2._name2);\n>        inner2.display();\n>    }\n>    \n>    public static void main(String[] args) {\n>        OuterClass outer = new OuterClass();\n>        outer.display();\n>    }\n> }\n> ----------------\n> Output:\n> chenssy_static\n> OutClass name :chenssy\n> chenssy_inner\n> OuterClass name：chenssy\n> ```\n>\n> \n>\n> \n\n### 匿名内部类\n\n>匿名内部类可以简单理解就是没有名字的类。我们直接用例子演示可以说的更清楚。\n>\n>```java\n>button2.addActionListener(  \n>                new ActionListener(){  \n>                    public void actionPerformed(ActionEvent e) {  \n>                        System.out.println(\"你按了按钮二\");  \n>                    }  \n>                });\n>```\n>\n>相信很多人都写过与上面类似的代码，这其实就是匿名类。其实就是在定义的时候就创建这个类的对象，但因为没有类名，所以以后就不能在创建使用。\n>\n>````java\n>public class OuterClass {\n>    public InnerClass getInnerClass(final int num,String str2){\n>        return new InnerClass(){\n>            int number = num + 3;\n>            public int getNumber(){\n>                return number;\n>            }\n>        };  /* 注意：分号不能省 */\n>    }\n>    \n>    public static void main(String[] args) {\n>        OuterClass out = new OuterClass();\n>        InnerClass inner = out.getInnerClass(2, \"chenssy\");\n>        System.out.println(inner.getNumber());\n>    }\n>}\n>\n>interface InnerClass {\n>    int getNumber();\n>}\n>\n>----------------\n>Output:\n>````\n>\n>  这里我们就需要看清几个地方\n>\n>​        **1、** 匿名内部类是没有访问修饰符的。\n>\n>​        **2、** new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。\n>\n>​         **3、** 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。\n>\n>​        **4、** 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。\n>\n>\n>\n>\n\n### 为什么要使用内部类\n\n>​        使用内部类最吸引人的原因是：**每个内部类都能独立的继承自一个接口的实现，所以无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响**。\n>\n>​         在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。\n>\n>同时使用内部类还可以获得以下的一些特性：\n>\n>1. 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围里对象的信息相互独立。\n>2. 在单个外围类中，可以多个内部类以不同的方式实现同一个接口或者继承同一个类。\n>3. 创建内部类对象的时刻并不依赖于外部类的创建。\n>4. 内部类并没有令人迷惑的\"is-a\"关系，他就是一个独立的实体。\n>\n>以上主要摘自《Thinking in java》","slug":"内部类","published":1,"updated":"2019-01-04T01:48:59.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovpc00119q1uryousl6k","content":"<h1 id=\"内部类的定义与分类\"><a href=\"#内部类的定义与分类\" class=\"headerlink\" title=\"内部类的定义与分类\"></a>内部类的定义与分类</h1><blockquote>\n<p>在《Thinking in Java》这本书里面给出的定义是：可以将一个类的定义放在另一个类的定义内部就是内部类。用一段代码来说明就是下面这样的</p>\n<pre><code>class Outter{\n class InnerClass{}\n}\n</code></pre><p>其中InnerClass就是内部类。</p>\n<p>内部类大体上可以划分为以下几种：成员内部类，局部内部类，静态内部类，匿名内部类。下面我将依次讲解这几种内部类。</p>\n</blockquote>\n<h3 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h3><blockquote>\n<p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，即使是private属性成员和方法也可以访问。但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。</p>\n<p>在成员内部类中要注意的几点：</p>\n<p><strong>第一：</strong>成员内部类中不能存在任何static的变量和方法；</p>\n<p><strong>第二：</strong>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。</p>\n<p><strong>第三</strong>：成员内部类也是有包的权限的，如果是public，则在任何一个包下面都可以使用，没有权限修饰符的则  </p>\n<p>​           只能在当前包下面使用。private则只能在当前类中使用，protected则可以在子类中使用。</p>\n<p>下面我们来看一个案例</p>\n<pre><code class=\"java\">public class OuterClass {\n   private String str;\n\n   public void outerDisplay(){\n       System.out.println(&quot;outerClass...&quot;);\n   }\n\n   public class InnerClass{\n       public void innerDisplay(){\n           //使用外围内的属性\n           str = &quot;chenssy...&quot;;\n           System.out.println(str);\n           //使用外围内的方法\n           outerDisplay();\n       }\n   }\n\n   /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */\n   public InnerClass getInnerClass(){\n       return new InnerClass();\n   }\n\n   public static void main(String[] args) {\n       OuterClass outer = new OuterClass();\n       OuterClass.InnerClass inner = outer.getInnerClass();\n       inner.innerDisplay();\n   }\n}\n--------------------\nchenssy...\nouterClass...\n</code></pre>\n<h3 id=\"this-和-new的使用\"><a href=\"#this-和-new的使用\" class=\"headerlink\" title=\".this 和 .new的使用\"></a>.this 和 .new的使用</h3><p>如果你需要在内部类生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。</p>\n<h3 id=\"this使用\"><a href=\"#this使用\" class=\"headerlink\" title=\".this使用\"></a><strong>.this</strong>使用</h3><blockquote>\n<pre><code>public class OutterClass {\n\n\n   private int key = 0;\n   private int key2 = 0;\n\n\n   public static void main(String[] args) {\n       OutterClass k1 = new OutterClass();\n       InnerClass in = k1.new InnerClass(); //生成内部类\n       OutterClass k2 = in.getOutterClass(); //通过 .this 来生成外部类\n       System.out.println(k1 == k2); //true 说明俩个对象指向同一个引用\n   }\n\n   public int getKey() {\n       return this.key;\n   }\n\n   public class InnerClass {\n\n       public InnerClass() {\n           key = 12;\n           key2 = 13;\n       }\n\n       public int getKey() {\n           // 通过 .this 来使用外部类的getKey\n           return OutterClass.this.getKey();\n       }\n       // 使用 .this 返回外部类对象\n       public OutterClass getOutterClass() {\n           return OutterClass.this;\n       }\n   }\n}\n---------------\noutPut:\ntrue\n</code></pre><p>这个例子演示了<strong>.this</strong>的使用，同时也证明了<strong>.this</strong>返回的就是外部类生成的对象。</p>\n</blockquote>\n<h3 id=\"new-使用\"><a href=\"#new-使用\" class=\"headerlink\" title=\".new 使用\"></a><strong>.new </strong>使用</h3><blockquote>\n<p>如果希望创建内部类对象，则必须先拥有外部类对象前提下才能创建，这是因为内部类对象会暗暗地连接到创建它的外部类对象上。这里就先不仔细说明，等看过例子之后在来说明好理解一些。创建内部类的格式是</p>\n<pre><code>outterObject.new    outterclass.innerClass\n</code></pre><p>也就是外部类的对象后面跟上圆点和new。</p>\n<pre><code>public class OuterClass {\n   private String name ;\n   private int age;\n\n   /**省略getter和setter方法**/\n\n   public class InnerClass{\n       public InnerClass(){\n           name = &quot;chenssy&quot;;\n           age = 23;\n       }\n\n       public void display(){\n           System.out.println(&quot;name：&quot; + getName() +&quot;   ;age：&quot; + getAge());\n       }\n   }\n\n   public static void main(String[] args) {\n       OuterClass outerClass = new OuterClass();\n       OuterClass.InnerClass innerClass = outerClass.new InnerClass();\n       innerClass.display();\n   }\n}\n--------------\nOutput：\nname：chenssy   ;age：23\n</code></pre></blockquote>\n<p>通过上面的例子你大概能明白<strong>.this</strong>和<strong>.new</strong>的作用。</p>\n<p>通过上面的介绍相信你对成员内部类有一定的了解了，但肯定也会有一些以后，为什么内部类会自动拥有对其外部类所有成员的访问权。这是如何做到的呢？当某个外部类创建完一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，当你访问此外围类的成员时，就是用那个引用来选择外围类的成员。幸运的是，编译器会帮你处理所有的细节。</p>\n</blockquote>\n<h3 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h3><blockquote>\n<p>其实这个名字不是太好，但是又不知道起什么名字。这一部分讲解的类主要是在方法和作用域内的内部类。在一个方法里面或者任意的作用域内定义内部类的理由有俩个：</p>\n<ol>\n<li>实现了某类型的接口，于是可以创建并返回对其的引用。</li>\n<li>你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但又不希望这个类是公共可用的。</li>\n</ol>\n<p>下面使用来个具体的例子来讲解，因为这一部分没有什么好讲解的，主要是自己体会。</p>\n<pre><code class=\"Java\">public class Parcel5{\n private int i= 0;\n public Destination destination(String s ){\n   class PDestination implements Destination{\n     private String label;\n     private PDestination(Strng whereTo){\n       label = whereTo;\n     }\n     public String readLable(){\n       return label;\n     }\n   }\n   return new PDestination(s);\n }\n public static void main(String[] args){\n   Parcel5 p =new Parcel5();\n   Destination d = p.destination(&quot;fuyang&quot;);\n }\n}\n</code></pre>\n<p>上面的代码演示的是定义在方法中的内部类，不过在这里有一点需要注意的是，这个内部类的范围是在方法内。也就是他的作用域就在方法内部。所以方法外面的属性是访问不到的，但是可以访问方法内的变量。</p>\n<pre><code class=\"java\">public class Parcel6 {\n   private void internalTracking(boolean b){\n       if(b){\n           class TrackingSlip{\n               private String id;\n               TrackingSlip(String s) {\n                   id = s;\n               }\n               String getSlip(){\n                   return id;\n               }\n           }\n           TrackingSlip ts = new TrackingSlip(&quot;chenssy&quot;);\n           String string = ts.getSlip();\n       }\n\n         // 到这里就不能使用上面定义的TrackingSlip内部类了。\n       //下面这句话就会编译报错\n         // TrackingSlip ts = new TrackingSlip(&quot;chenssy&quot;);\n   }\n\n   public void track(){\n       internalTracking(true);\n   }\n\n   public static void main(String[] args) {\n       Parcel6 parcel6 = new Parcel6();\n       parcel6.track();\n   }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><blockquote>\n<p>使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：</p>\n<p>​      <strong>1、</strong> 它的创建是不需要依赖于外围类的。</p>\n<p>​      <strong>2、</strong> 它不能使用任何外围类的非static成员变量和方法。</p>\n<pre><code class=\"java\">public class OuterClass {\n   private String sex;\n   public static String name = &quot;chenssy&quot;;\n\n   /**\n    *静态内部类\n    */\n   static class InnerClass1{\n       /* 在静态内部类中可以存在静态成员 */\n       public static String _name1 = &quot;chenssy_static&quot;;\n\n       public void display(){\n           /* \n            * 静态内部类只能访问外围类的静态成员变量和方法\n            * 不能访问外围类的非静态成员变量和方法\n            */\n           System.out.println(&quot;OutClass name :&quot; + name);\n       }\n   }\n\n   /**\n    * 非静态内部类\n    */\n   class InnerClass2{\n       /* 非静态内部类中不能存在静态成员 */\n       public String _name2 = &quot;chenssy_inner&quot;;\n       /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */\n       public void display(){\n           System.out.println(&quot;OuterClass name：&quot; + name);\n       }\n   }\n\n\n   public void display(){\n       /* 外围类访问静态内部类：内部类. */\n       System.out.println(InnerClass1._name1);\n       /* 静态内部类 可以直接创建实例不需要依赖于外围类 */\n       new InnerClass1().display();\n\n       /* 非静态内部的创建需要依赖于外围类 */\n       OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2();\n       /* 方位非静态内部类的成员需要使用非静态内部类的实例 */\n       System.out.println(inner2._name2);\n       inner2.display();\n   }\n\n   public static void main(String[] args) {\n       OuterClass outer = new OuterClass();\n       outer.display();\n   }\n}\n----------------\nOutput:\nchenssy_static\nOutClass name :chenssy\nchenssy_inner\nOuterClass name：chenssy\n</code></pre>\n</blockquote>\n<h3 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h3><blockquote>\n<p>匿名内部类可以简单理解就是没有名字的类。我们直接用例子演示可以说的更清楚。</p>\n<pre><code class=\"java\">button2.addActionListener(  \n               new ActionListener(){  \n                   public void actionPerformed(ActionEvent e) {  \n                       System.out.println(&quot;你按了按钮二&quot;);  \n                   }  \n               });\n</code></pre>\n<p>相信很多人都写过与上面类似的代码，这其实就是匿名类。其实就是在定义的时候就创建这个类的对象，但因为没有类名，所以以后就不能在创建使用。</p>\n<pre><code class=\"java\">public class OuterClass {\n   public InnerClass getInnerClass(final int num,String str2){\n       return new InnerClass(){\n           int number = num + 3;\n           public int getNumber(){\n               return number;\n           }\n       };  /* 注意：分号不能省 */\n   }\n\n   public static void main(String[] args) {\n       OuterClass out = new OuterClass();\n       InnerClass inner = out.getInnerClass(2, &quot;chenssy&quot;);\n       System.out.println(inner.getNumber());\n   }\n}\n\ninterface InnerClass {\n   int getNumber();\n}\n\n----------------\nOutput:\n</code></pre>\n<p> 这里我们就需要看清几个地方</p>\n<p>​        <strong>1、</strong> 匿名内部类是没有访问修饰符的。</p>\n<p>​        <strong>2、</strong> new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。</p>\n<p>​         <strong>3、</strong> 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。</p>\n<p>​        <strong>4、</strong> 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。</p>\n</blockquote>\n<h3 id=\"为什么要使用内部类\"><a href=\"#为什么要使用内部类\" class=\"headerlink\" title=\"为什么要使用内部类\"></a>为什么要使用内部类</h3><blockquote>\n<p>​        使用内部类最吸引人的原因是：<strong>每个内部类都能独立的继承自一个接口的实现，所以无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响</strong>。</p>\n<p>​         在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>\n<p>同时使用内部类还可以获得以下的一些特性：</p>\n<ol>\n<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围里对象的信息相互独立。</li>\n<li>在单个外围类中，可以多个内部类以不同的方式实现同一个接口或者继承同一个类。</li>\n<li>创建内部类对象的时刻并不依赖于外部类的创建。</li>\n<li>内部类并没有令人迷惑的”is-a”关系，他就是一个独立的实体。</li>\n</ol>\n<p>以上主要摘自《Thinking in java》</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内部类的定义与分类\"><a href=\"#内部类的定义与分类\" class=\"headerlink\" title=\"内部类的定义与分类\"></a>内部类的定义与分类</h1><blockquote>\n<p>在《Thinking in Java》这本书里面给出的定义是：可以将一个类的定义放在另一个类的定义内部就是内部类。用一段代码来说明就是下面这样的</p>\n<pre><code>class Outter{\n class InnerClass{}\n}\n</code></pre><p>其中InnerClass就是内部类。</p>\n<p>内部类大体上可以划分为以下几种：成员内部类，局部内部类，静态内部类，匿名内部类。下面我将依次讲解这几种内部类。</p>\n</blockquote>\n<h3 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h3><blockquote>\n<p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，即使是private属性成员和方法也可以访问。但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。</p>\n<p>在成员内部类中要注意的几点：</p>\n<p><strong>第一：</strong>成员内部类中不能存在任何static的变量和方法；</p>\n<p><strong>第二：</strong>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。</p>\n<p><strong>第三</strong>：成员内部类也是有包的权限的，如果是public，则在任何一个包下面都可以使用，没有权限修饰符的则  </p>\n<p>​           只能在当前包下面使用。private则只能在当前类中使用，protected则可以在子类中使用。</p>\n<p>下面我们来看一个案例</p>\n<pre><code class=\"java\">public class OuterClass {\n   private String str;\n\n   public void outerDisplay(){\n       System.out.println(&quot;outerClass...&quot;);\n   }\n\n   public class InnerClass{\n       public void innerDisplay(){\n           //使用外围内的属性\n           str = &quot;chenssy...&quot;;\n           System.out.println(str);\n           //使用外围内的方法\n           outerDisplay();\n       }\n   }\n\n   /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */\n   public InnerClass getInnerClass(){\n       return new InnerClass();\n   }\n\n   public static void main(String[] args) {\n       OuterClass outer = new OuterClass();\n       OuterClass.InnerClass inner = outer.getInnerClass();\n       inner.innerDisplay();\n   }\n}\n--------------------\nchenssy...\nouterClass...\n</code></pre>\n<h3 id=\"this-和-new的使用\"><a href=\"#this-和-new的使用\" class=\"headerlink\" title=\".this 和 .new的使用\"></a>.this 和 .new的使用</h3><p>如果你需要在内部类生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。</p>\n<h3 id=\"this使用\"><a href=\"#this使用\" class=\"headerlink\" title=\".this使用\"></a><strong>.this</strong>使用</h3><blockquote>\n<pre><code>public class OutterClass {\n\n\n   private int key = 0;\n   private int key2 = 0;\n\n\n   public static void main(String[] args) {\n       OutterClass k1 = new OutterClass();\n       InnerClass in = k1.new InnerClass(); //生成内部类\n       OutterClass k2 = in.getOutterClass(); //通过 .this 来生成外部类\n       System.out.println(k1 == k2); //true 说明俩个对象指向同一个引用\n   }\n\n   public int getKey() {\n       return this.key;\n   }\n\n   public class InnerClass {\n\n       public InnerClass() {\n           key = 12;\n           key2 = 13;\n       }\n\n       public int getKey() {\n           // 通过 .this 来使用外部类的getKey\n           return OutterClass.this.getKey();\n       }\n       // 使用 .this 返回外部类对象\n       public OutterClass getOutterClass() {\n           return OutterClass.this;\n       }\n   }\n}\n---------------\noutPut:\ntrue\n</code></pre><p>这个例子演示了<strong>.this</strong>的使用，同时也证明了<strong>.this</strong>返回的就是外部类生成的对象。</p>\n</blockquote>\n<h3 id=\"new-使用\"><a href=\"#new-使用\" class=\"headerlink\" title=\".new 使用\"></a><strong>.new </strong>使用</h3><blockquote>\n<p>如果希望创建内部类对象，则必须先拥有外部类对象前提下才能创建，这是因为内部类对象会暗暗地连接到创建它的外部类对象上。这里就先不仔细说明，等看过例子之后在来说明好理解一些。创建内部类的格式是</p>\n<pre><code>outterObject.new    outterclass.innerClass\n</code></pre><p>也就是外部类的对象后面跟上圆点和new。</p>\n<pre><code>public class OuterClass {\n   private String name ;\n   private int age;\n\n   /**省略getter和setter方法**/\n\n   public class InnerClass{\n       public InnerClass(){\n           name = &quot;chenssy&quot;;\n           age = 23;\n       }\n\n       public void display(){\n           System.out.println(&quot;name：&quot; + getName() +&quot;   ;age：&quot; + getAge());\n       }\n   }\n\n   public static void main(String[] args) {\n       OuterClass outerClass = new OuterClass();\n       OuterClass.InnerClass innerClass = outerClass.new InnerClass();\n       innerClass.display();\n   }\n}\n--------------\nOutput：\nname：chenssy   ;age：23\n</code></pre></blockquote>\n<p>通过上面的例子你大概能明白<strong>.this</strong>和<strong>.new</strong>的作用。</p>\n<p>通过上面的介绍相信你对成员内部类有一定的了解了，但肯定也会有一些以后，为什么内部类会自动拥有对其外部类所有成员的访问权。这是如何做到的呢？当某个外部类创建完一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，当你访问此外围类的成员时，就是用那个引用来选择外围类的成员。幸运的是，编译器会帮你处理所有的细节。</p>\n</blockquote>\n<h3 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h3><blockquote>\n<p>其实这个名字不是太好，但是又不知道起什么名字。这一部分讲解的类主要是在方法和作用域内的内部类。在一个方法里面或者任意的作用域内定义内部类的理由有俩个：</p>\n<ol>\n<li>实现了某类型的接口，于是可以创建并返回对其的引用。</li>\n<li>你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但又不希望这个类是公共可用的。</li>\n</ol>\n<p>下面使用来个具体的例子来讲解，因为这一部分没有什么好讲解的，主要是自己体会。</p>\n<pre><code class=\"Java\">public class Parcel5{\n private int i= 0;\n public Destination destination(String s ){\n   class PDestination implements Destination{\n     private String label;\n     private PDestination(Strng whereTo){\n       label = whereTo;\n     }\n     public String readLable(){\n       return label;\n     }\n   }\n   return new PDestination(s);\n }\n public static void main(String[] args){\n   Parcel5 p =new Parcel5();\n   Destination d = p.destination(&quot;fuyang&quot;);\n }\n}\n</code></pre>\n<p>上面的代码演示的是定义在方法中的内部类，不过在这里有一点需要注意的是，这个内部类的范围是在方法内。也就是他的作用域就在方法内部。所以方法外面的属性是访问不到的，但是可以访问方法内的变量。</p>\n<pre><code class=\"java\">public class Parcel6 {\n   private void internalTracking(boolean b){\n       if(b){\n           class TrackingSlip{\n               private String id;\n               TrackingSlip(String s) {\n                   id = s;\n               }\n               String getSlip(){\n                   return id;\n               }\n           }\n           TrackingSlip ts = new TrackingSlip(&quot;chenssy&quot;);\n           String string = ts.getSlip();\n       }\n\n         // 到这里就不能使用上面定义的TrackingSlip内部类了。\n       //下面这句话就会编译报错\n         // TrackingSlip ts = new TrackingSlip(&quot;chenssy&quot;);\n   }\n\n   public void track(){\n       internalTracking(true);\n   }\n\n   public static void main(String[] args) {\n       Parcel6 parcel6 = new Parcel6();\n       parcel6.track();\n   }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><blockquote>\n<p>使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：</p>\n<p>​      <strong>1、</strong> 它的创建是不需要依赖于外围类的。</p>\n<p>​      <strong>2、</strong> 它不能使用任何外围类的非static成员变量和方法。</p>\n<pre><code class=\"java\">public class OuterClass {\n   private String sex;\n   public static String name = &quot;chenssy&quot;;\n\n   /**\n    *静态内部类\n    */\n   static class InnerClass1{\n       /* 在静态内部类中可以存在静态成员 */\n       public static String _name1 = &quot;chenssy_static&quot;;\n\n       public void display(){\n           /* \n            * 静态内部类只能访问外围类的静态成员变量和方法\n            * 不能访问外围类的非静态成员变量和方法\n            */\n           System.out.println(&quot;OutClass name :&quot; + name);\n       }\n   }\n\n   /**\n    * 非静态内部类\n    */\n   class InnerClass2{\n       /* 非静态内部类中不能存在静态成员 */\n       public String _name2 = &quot;chenssy_inner&quot;;\n       /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */\n       public void display(){\n           System.out.println(&quot;OuterClass name：&quot; + name);\n       }\n   }\n\n\n   public void display(){\n       /* 外围类访问静态内部类：内部类. */\n       System.out.println(InnerClass1._name1);\n       /* 静态内部类 可以直接创建实例不需要依赖于外围类 */\n       new InnerClass1().display();\n\n       /* 非静态内部的创建需要依赖于外围类 */\n       OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2();\n       /* 方位非静态内部类的成员需要使用非静态内部类的实例 */\n       System.out.println(inner2._name2);\n       inner2.display();\n   }\n\n   public static void main(String[] args) {\n       OuterClass outer = new OuterClass();\n       outer.display();\n   }\n}\n----------------\nOutput:\nchenssy_static\nOutClass name :chenssy\nchenssy_inner\nOuterClass name：chenssy\n</code></pre>\n</blockquote>\n<h3 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h3><blockquote>\n<p>匿名内部类可以简单理解就是没有名字的类。我们直接用例子演示可以说的更清楚。</p>\n<pre><code class=\"java\">button2.addActionListener(  \n               new ActionListener(){  \n                   public void actionPerformed(ActionEvent e) {  \n                       System.out.println(&quot;你按了按钮二&quot;);  \n                   }  \n               });\n</code></pre>\n<p>相信很多人都写过与上面类似的代码，这其实就是匿名类。其实就是在定义的时候就创建这个类的对象，但因为没有类名，所以以后就不能在创建使用。</p>\n<pre><code class=\"java\">public class OuterClass {\n   public InnerClass getInnerClass(final int num,String str2){\n       return new InnerClass(){\n           int number = num + 3;\n           public int getNumber(){\n               return number;\n           }\n       };  /* 注意：分号不能省 */\n   }\n\n   public static void main(String[] args) {\n       OuterClass out = new OuterClass();\n       InnerClass inner = out.getInnerClass(2, &quot;chenssy&quot;);\n       System.out.println(inner.getNumber());\n   }\n}\n\ninterface InnerClass {\n   int getNumber();\n}\n\n----------------\nOutput:\n</code></pre>\n<p> 这里我们就需要看清几个地方</p>\n<p>​        <strong>1、</strong> 匿名内部类是没有访问修饰符的。</p>\n<p>​        <strong>2、</strong> new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。</p>\n<p>​         <strong>3、</strong> 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。</p>\n<p>​        <strong>4、</strong> 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。</p>\n</blockquote>\n<h3 id=\"为什么要使用内部类\"><a href=\"#为什么要使用内部类\" class=\"headerlink\" title=\"为什么要使用内部类\"></a>为什么要使用内部类</h3><blockquote>\n<p>​        使用内部类最吸引人的原因是：<strong>每个内部类都能独立的继承自一个接口的实现，所以无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响</strong>。</p>\n<p>​         在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>\n<p>同时使用内部类还可以获得以下的一些特性：</p>\n<ol>\n<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围里对象的信息相互独立。</li>\n<li>在单个外围类中，可以多个内部类以不同的方式实现同一个接口或者继承同一个类。</li>\n<li>创建内部类对象的时刻并不依赖于外部类的创建。</li>\n<li>内部类并没有令人迷惑的”is-a”关系，他就是一个独立的实体。</li>\n</ol>\n<p>以上主要摘自《Thinking in java》</p>\n</blockquote>\n"},{"title":"深入分析ThreadLocal","author":"zhangke","abbrlink":"400f00a6","date":"2018-09-12T02:28:00.000Z","_content":"###  概述\n>1. ThreadLocal是什么\n>2. 如何使用ThreadLocal\n>3. ThreadLocal源码分析\n>4. 总结\n\n### ThreadLocal 是什么\n>首先我们要明白一点，线程同步主要是为了完成线程间数据共享和同步，保持数据的完整性。而ThreadLocal正如他的名字一样是线程的本地变量，也就是线程所私有的。因此他和线程同步无关，（因为不存在线程之间共享变量的问题，就不需要使用同步机制）。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？\n<!-- more --->\n>\n>#### API是这样介绍它的：\n>\n>**This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).**\n>\n>#### 中文翻译\n>\n>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其`get` 或 `set`方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。`ThreadLocal`实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。正如这句话所说，spring 中的事务就使用了ThreadLocal来保证同一个线程中的所有操作使用的是同一个数据库连接。\n>\n>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。\n\n### 如何使用ThreadLocal\n\n>简单案例\n>\n>```JAVA\n>public class SeqCount {\n>\n>    private static ThreadLocal<Integer> seqCount = new ThreadLocal<Integer>(){\n>        // 实现initialValue()\n>        public Integer initialValue() {\n>            return 0;\n>        }\n>    };\n>\n>    public int nextSeq(){\n>        seqCount.set(seqCount.get() + 1);\n>\n>        return seqCount.get();\n>    }\n>\n>    public static void main(String[] args){\n>        SeqCount seqCount = new SeqCount();\n>\n>        SeqThread thread1 = new SeqThread(seqCount);\n>        SeqThread thread2 = new SeqThread(seqCount);\n>        SeqThread thread3 = new SeqThread(seqCount);\n>        SeqThread thread4 = new SeqThread(seqCount);\n>\n>        thread1.start();\n>        thread2.start();\n>        thread3.start();\n>        thread4.start();\n>    }\n>\n>    private static class SeqThread extends Thread{\n>        private SeqCount seqCount;\n>\n>        SeqThread(SeqCount seqCount){\n>            this.seqCount = seqCount;\n>        }\n>\n>        public void run() {\n>            for(int i = 0 ; i < 3 ; i++){\n>                System.out.println(Thread.currentThread().getName() + \" seqCount :\" + seqCount.nextSeq());\n>            }\n>        }\n>    }\n>}\n>```\n>\n>运行结果\n>\n>```\n>Thread-1 seqCount :1\n>Thread-0 seqCount :1\n>Thread-2 seqCount :1\n>Thread-3 seqCount :1\n>Thread-1 seqCount :2\n>Thread-0 seqCount :2\n>Thread-2 seqCount :2\n>Thread-3 seqCount :2\n>Thread-1 seqCount :3\n>Thread-0 seqCount :3\n>Thread-2 seqCount :3\n>Thread-3 seqCount :3\n>```\n>\n>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。\n>\n>**不过这里要注意一个问题，不要使用对象的引用来设置ThreadLocal的初始值，这样会导致线程共享此对象**\n>\n>就像下面这样写\n>\n>```java\n>    A a = new A();\n>    private static ThreadLocal<A> seqCount = new ThreadLocal<A>(){\n>        // 实现initialValue()\n>        public A initialValue() {\n>            return a;\n>        }\n>    };\n>\n>    class A{\n>        // ....\n>    }\n>```\n>\n>具体过程请参考：[对ThreadLocal实现原理的一点思考](http://www.jianshu.com/p/ee8c9dccc953)\n>\n>总结一般使用ThreadLocal的方式是：\n>\n>1. 设置ThreadLocal对象为静态内部私有属性\n>2. 使用initalValue方法进行初始化值的时候，不要使用引用对象，这样会造成线程间共享此对象，从而达不到线程私有变量的的效果。\n>\n>具体代码如下\n>\n>```java\n>private statis ThreadLocal<T> objectName = new  \n>    ThreadLocal(){\n>        private T initialValue() {\n>        \t\t//下面写法肯定有问题，主要是告诉你要声明一个对\n>        \t\t//象，而不是返回对象的引用\n>            return new T() ;\n>        }\n>}\n>```\n>\n>\n\n### ThreadLocal源码解析\n\n>ThreadLocal定义了四个方法：\n>\n>- get()：返回此线程局部变量的当前线程副本中的值。\n>- initialValue()：返回此线程局部变量的当前线程的“初始值”。\n>- remove()：移除此线程局部变量当前线程的值。\n>- set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。\n>\n>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。\n>\n>对于ThreadLocal需要注意的有两点：\n>\n>1. ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。\n>2. 是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。\n>\n>下图是Thread、ThreadLocal、ThreadLocalMap的关系\n>\n>![](http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg)\n>\n>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。\n>\n>### ThreadLocalMap\n>\n>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：\n>\n>```\n>       static class Entry extends WeakReference<ThreadLocal<?>> {\n>            /** The value associated with this ThreadLocal. */\n>            Object value;\n>\n>            Entry(ThreadLocal<?> k, Object v) {\n>                super(k);\n>                value = v;\n>            }\n>        }\n>```\n>\n>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：[Java 理论与实践: 用弱引用堵住内存泄漏](https://www.ibm.com/developerworks/cn/java/j-jtp11225/)）\n>\n>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal> key, Object value)方法。\n>\n>**set(ThreadLocal<?> key, Object value)**\n>\n>```\n>    private void set(ThreadLocal<?> key, Object value) {\n>\n>        ThreadLocal.ThreadLocalMap.Entry[] tab = table;\n>        int len = tab.length;\n>\n>        // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置\n>        int i = key.threadLocalHashCode & (len-1);\n>\n>        // 采用“线性探测法”，寻找合适位置\n>        for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];\n>            e != null;\n>            e = tab[i = nextIndex(i, len)]) {\n>\n>            ThreadLocal<?> k = e.get();\n>\n>            // key 存在，直接覆盖\n>            if (k == key) {\n>                e.value = value;\n>                return;\n>            }\n>\n>            // key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了\n>            if (k == null) {\n>                // 用新元素替换陈旧的元素\n>                replaceStaleEntry(key, value, i);\n>                return;\n>            }\n>        }\n>\n>        // ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个\n>        tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value);\n>\n>        int sz = ++size;\n>\n>        // cleanSomeSlots 清楚陈旧的Entry（key == null）\n>        // 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash\n>        if (!cleanSomeSlots(i, sz) && sz >= threshold)\n>            rehash();\n>    }\n>```\n>\n>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考[散列冲突处理系列博客](http://www.nowamagic.net/academy/detail/3008015)）。掌握了开放地址法该方法就一目了然了。\n>\n>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：\n>\n>```\n>private final int threadLocalHashCode = nextHashCode();\n>```\n>\n>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：\n>\n>```\n>    private static AtomicInteger nextHashCode = new AtomicInteger();\n>\n>    private static final int HASH_INCREMENT = 0x61c88647;\n>\n>    private static int nextHashCode() {\n>        return nextHashCode.getAndAdd(HASH_INCREMENT);\n>    }\n>```\n>\n>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。\n>\n>**getEntry()**\n>\n>```\n>        private Entry getEntry(ThreadLocal<?> key) {\n>            int i = key.threadLocalHashCode & (table.length - 1);\n>            Entry e = table[i];\n>            if (e != null && e.get() == key)\n>                return e;\n>            else\n>                return getEntryAfterMiss(key, i, e);\n>        }\n>```\n>\n>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：\n>\n>```\n>        private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n>            Entry[] tab = table;\n>            int len = tab.length;\n>\n>            while (e != null) {\n>                ThreadLocal<?> k = e.get();\n>                if (k == key)\n>                    return e;\n>                if (k == null)\n>                    expungeStaleEntry(i);\n>                else\n>                    i = nextIndex(i, len);\n>                e = tab[i];\n>            }\n>            return null;\n>        }\n>```\n>\n>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。\n>\n>### get()\n>\n>> 返回当前线程所对应的线程变量\n>\n>```\n>    public T get() {\n>        // 获取当前线程\n>        Thread t = Thread.currentThread();\n>\n>        // 获取当前线程的成员变量 threadLocal\n>        ThreadLocalMap map = getMap(t);\n>        if (map != null) {\n>            // 从当前线程的ThreadLocalMap获取相对应的Entry\n>            ThreadLocalMap.Entry e = map.getEntry(this);\n>            if (e != null) {\n>                @SuppressWarnings(\"unchecked\")\n>\n>                // 获取目标值        \n>                T result = (T)e.value;\n>                return result;\n>            }\n>        }\n>        return setInitialValue();\n>    }\n>```\n>\n>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。\n>\n>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：\n>\n>```\n>    ThreadLocalMap getMap(Thread t) {\n>        return t.threadLocals;\n>    }\n>```\n>\n>### set(T value)\n>\n>> 设置当前线程的线程局部变量的值。\n>\n>```\n>    public void set(T value) {\n>        Thread t = Thread.currentThread();\n>        ThreadLocalMap map = getMap(t);\n>        if (map != null)\n>            map.set(this, value);\n>        else\n>            createMap(t, value);\n>    }\n>```\n>\n>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：\n>\n>```\n>    void createMap(Thread t, T firstValue) {\n>        t.threadLocals = new ThreadLocalMap(this, firstValue);\n>    }\n>```\n>\n>### initialValue()\n>\n>> 返回该线程局部变量的初始值。\n>\n>``` JAVA\n>    protected T initialValue() {\n>        return null;\n>    }\n>```\n>\n>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。\n>\n>### remove()\n>\n>> 将当前线程局部变量的值删除。\n>\n>```java\n>public void remove() {\n>    ThreadLocalMap m =  getMap(Thread.currentThread());\n>    if (m != null)\n>        m.remove(this);\n>}\n>```\n>\n>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。\n>\n> \n\n### 总结\n\n>- ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。\n>- 每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。\n>- ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。\n>\n>这里有一个使用ThreadLocal的案例，可以好好看看，写的很好\n>\n>[透彻理解Spring事务设计思想之手写实现](https://www.jianshu.com/p/1becdc376f5d)\n\n### 参考\n\n1. [深入分析 ThreadLocal 内存泄漏问题](http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/)\n2.  [【死磕Java并发】—–深入分析ThreadLocal](http://cmsblogs.com/?p=2442)","source":"_posts/深入分析ThreadLocal.md","raw":"title: 深入分析ThreadLocal\nauthor: zhangke\nabbrlink: 400f00a6\ntags:\n  - java\n  - 并发\n  - 线程\n  - thread\ncategories:\n  - java\ndate: 2018-09-12 10:28:00\n---\n###  概述\n>1. ThreadLocal是什么\n>2. 如何使用ThreadLocal\n>3. ThreadLocal源码分析\n>4. 总结\n\n### ThreadLocal 是什么\n>首先我们要明白一点，线程同步主要是为了完成线程间数据共享和同步，保持数据的完整性。而ThreadLocal正如他的名字一样是线程的本地变量，也就是线程所私有的。因此他和线程同步无关，（因为不存在线程之间共享变量的问题，就不需要使用同步机制）。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？\n<!-- more --->\n>\n>#### API是这样介绍它的：\n>\n>**This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).**\n>\n>#### 中文翻译\n>\n>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其`get` 或 `set`方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。`ThreadLocal`实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。正如这句话所说，spring 中的事务就使用了ThreadLocal来保证同一个线程中的所有操作使用的是同一个数据库连接。\n>\n>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。\n\n### 如何使用ThreadLocal\n\n>简单案例\n>\n>```JAVA\n>public class SeqCount {\n>\n>    private static ThreadLocal<Integer> seqCount = new ThreadLocal<Integer>(){\n>        // 实现initialValue()\n>        public Integer initialValue() {\n>            return 0;\n>        }\n>    };\n>\n>    public int nextSeq(){\n>        seqCount.set(seqCount.get() + 1);\n>\n>        return seqCount.get();\n>    }\n>\n>    public static void main(String[] args){\n>        SeqCount seqCount = new SeqCount();\n>\n>        SeqThread thread1 = new SeqThread(seqCount);\n>        SeqThread thread2 = new SeqThread(seqCount);\n>        SeqThread thread3 = new SeqThread(seqCount);\n>        SeqThread thread4 = new SeqThread(seqCount);\n>\n>        thread1.start();\n>        thread2.start();\n>        thread3.start();\n>        thread4.start();\n>    }\n>\n>    private static class SeqThread extends Thread{\n>        private SeqCount seqCount;\n>\n>        SeqThread(SeqCount seqCount){\n>            this.seqCount = seqCount;\n>        }\n>\n>        public void run() {\n>            for(int i = 0 ; i < 3 ; i++){\n>                System.out.println(Thread.currentThread().getName() + \" seqCount :\" + seqCount.nextSeq());\n>            }\n>        }\n>    }\n>}\n>```\n>\n>运行结果\n>\n>```\n>Thread-1 seqCount :1\n>Thread-0 seqCount :1\n>Thread-2 seqCount :1\n>Thread-3 seqCount :1\n>Thread-1 seqCount :2\n>Thread-0 seqCount :2\n>Thread-2 seqCount :2\n>Thread-3 seqCount :2\n>Thread-1 seqCount :3\n>Thread-0 seqCount :3\n>Thread-2 seqCount :3\n>Thread-3 seqCount :3\n>```\n>\n>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。\n>\n>**不过这里要注意一个问题，不要使用对象的引用来设置ThreadLocal的初始值，这样会导致线程共享此对象**\n>\n>就像下面这样写\n>\n>```java\n>    A a = new A();\n>    private static ThreadLocal<A> seqCount = new ThreadLocal<A>(){\n>        // 实现initialValue()\n>        public A initialValue() {\n>            return a;\n>        }\n>    };\n>\n>    class A{\n>        // ....\n>    }\n>```\n>\n>具体过程请参考：[对ThreadLocal实现原理的一点思考](http://www.jianshu.com/p/ee8c9dccc953)\n>\n>总结一般使用ThreadLocal的方式是：\n>\n>1. 设置ThreadLocal对象为静态内部私有属性\n>2. 使用initalValue方法进行初始化值的时候，不要使用引用对象，这样会造成线程间共享此对象，从而达不到线程私有变量的的效果。\n>\n>具体代码如下\n>\n>```java\n>private statis ThreadLocal<T> objectName = new  \n>    ThreadLocal(){\n>        private T initialValue() {\n>        \t\t//下面写法肯定有问题，主要是告诉你要声明一个对\n>        \t\t//象，而不是返回对象的引用\n>            return new T() ;\n>        }\n>}\n>```\n>\n>\n\n### ThreadLocal源码解析\n\n>ThreadLocal定义了四个方法：\n>\n>- get()：返回此线程局部变量的当前线程副本中的值。\n>- initialValue()：返回此线程局部变量的当前线程的“初始值”。\n>- remove()：移除此线程局部变量当前线程的值。\n>- set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。\n>\n>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。\n>\n>对于ThreadLocal需要注意的有两点：\n>\n>1. ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。\n>2. 是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。\n>\n>下图是Thread、ThreadLocal、ThreadLocalMap的关系\n>\n>![](http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg)\n>\n>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。\n>\n>### ThreadLocalMap\n>\n>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：\n>\n>```\n>       static class Entry extends WeakReference<ThreadLocal<?>> {\n>            /** The value associated with this ThreadLocal. */\n>            Object value;\n>\n>            Entry(ThreadLocal<?> k, Object v) {\n>                super(k);\n>                value = v;\n>            }\n>        }\n>```\n>\n>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：[Java 理论与实践: 用弱引用堵住内存泄漏](https://www.ibm.com/developerworks/cn/java/j-jtp11225/)）\n>\n>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal> key, Object value)方法。\n>\n>**set(ThreadLocal<?> key, Object value)**\n>\n>```\n>    private void set(ThreadLocal<?> key, Object value) {\n>\n>        ThreadLocal.ThreadLocalMap.Entry[] tab = table;\n>        int len = tab.length;\n>\n>        // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置\n>        int i = key.threadLocalHashCode & (len-1);\n>\n>        // 采用“线性探测法”，寻找合适位置\n>        for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];\n>            e != null;\n>            e = tab[i = nextIndex(i, len)]) {\n>\n>            ThreadLocal<?> k = e.get();\n>\n>            // key 存在，直接覆盖\n>            if (k == key) {\n>                e.value = value;\n>                return;\n>            }\n>\n>            // key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了\n>            if (k == null) {\n>                // 用新元素替换陈旧的元素\n>                replaceStaleEntry(key, value, i);\n>                return;\n>            }\n>        }\n>\n>        // ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个\n>        tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value);\n>\n>        int sz = ++size;\n>\n>        // cleanSomeSlots 清楚陈旧的Entry（key == null）\n>        // 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash\n>        if (!cleanSomeSlots(i, sz) && sz >= threshold)\n>            rehash();\n>    }\n>```\n>\n>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考[散列冲突处理系列博客](http://www.nowamagic.net/academy/detail/3008015)）。掌握了开放地址法该方法就一目了然了。\n>\n>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：\n>\n>```\n>private final int threadLocalHashCode = nextHashCode();\n>```\n>\n>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：\n>\n>```\n>    private static AtomicInteger nextHashCode = new AtomicInteger();\n>\n>    private static final int HASH_INCREMENT = 0x61c88647;\n>\n>    private static int nextHashCode() {\n>        return nextHashCode.getAndAdd(HASH_INCREMENT);\n>    }\n>```\n>\n>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。\n>\n>**getEntry()**\n>\n>```\n>        private Entry getEntry(ThreadLocal<?> key) {\n>            int i = key.threadLocalHashCode & (table.length - 1);\n>            Entry e = table[i];\n>            if (e != null && e.get() == key)\n>                return e;\n>            else\n>                return getEntryAfterMiss(key, i, e);\n>        }\n>```\n>\n>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：\n>\n>```\n>        private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n>            Entry[] tab = table;\n>            int len = tab.length;\n>\n>            while (e != null) {\n>                ThreadLocal<?> k = e.get();\n>                if (k == key)\n>                    return e;\n>                if (k == null)\n>                    expungeStaleEntry(i);\n>                else\n>                    i = nextIndex(i, len);\n>                e = tab[i];\n>            }\n>            return null;\n>        }\n>```\n>\n>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。\n>\n>### get()\n>\n>> 返回当前线程所对应的线程变量\n>\n>```\n>    public T get() {\n>        // 获取当前线程\n>        Thread t = Thread.currentThread();\n>\n>        // 获取当前线程的成员变量 threadLocal\n>        ThreadLocalMap map = getMap(t);\n>        if (map != null) {\n>            // 从当前线程的ThreadLocalMap获取相对应的Entry\n>            ThreadLocalMap.Entry e = map.getEntry(this);\n>            if (e != null) {\n>                @SuppressWarnings(\"unchecked\")\n>\n>                // 获取目标值        \n>                T result = (T)e.value;\n>                return result;\n>            }\n>        }\n>        return setInitialValue();\n>    }\n>```\n>\n>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。\n>\n>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：\n>\n>```\n>    ThreadLocalMap getMap(Thread t) {\n>        return t.threadLocals;\n>    }\n>```\n>\n>### set(T value)\n>\n>> 设置当前线程的线程局部变量的值。\n>\n>```\n>    public void set(T value) {\n>        Thread t = Thread.currentThread();\n>        ThreadLocalMap map = getMap(t);\n>        if (map != null)\n>            map.set(this, value);\n>        else\n>            createMap(t, value);\n>    }\n>```\n>\n>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：\n>\n>```\n>    void createMap(Thread t, T firstValue) {\n>        t.threadLocals = new ThreadLocalMap(this, firstValue);\n>    }\n>```\n>\n>### initialValue()\n>\n>> 返回该线程局部变量的初始值。\n>\n>``` JAVA\n>    protected T initialValue() {\n>        return null;\n>    }\n>```\n>\n>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。\n>\n>### remove()\n>\n>> 将当前线程局部变量的值删除。\n>\n>```java\n>public void remove() {\n>    ThreadLocalMap m =  getMap(Thread.currentThread());\n>    if (m != null)\n>        m.remove(this);\n>}\n>```\n>\n>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。\n>\n> \n\n### 总结\n\n>- ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。\n>- 每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。\n>- ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。\n>\n>这里有一个使用ThreadLocal的案例，可以好好看看，写的很好\n>\n>[透彻理解Spring事务设计思想之手写实现](https://www.jianshu.com/p/1becdc376f5d)\n\n### 参考\n\n1. [深入分析 ThreadLocal 内存泄漏问题](http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/)\n2.  [【死磕Java并发】—–深入分析ThreadLocal](http://cmsblogs.com/?p=2442)","slug":"深入分析ThreadLocal","published":1,"updated":"2019-01-02T05:37:58.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovpf00149q1uiyfpsjmy","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<ol>\n<li>ThreadLocal是什么</li>\n<li>如何使用ThreadLocal</li>\n<li>ThreadLocal源码分析</li>\n<li>总结</li>\n</ol>\n</blockquote>\n<h3 id=\"ThreadLocal-是什么\"><a href=\"#ThreadLocal-是什么\" class=\"headerlink\" title=\"ThreadLocal 是什么\"></a>ThreadLocal 是什么</h3><blockquote>\n<p>首先我们要明白一点，线程同步主要是为了完成线程间数据共享和同步，保持数据的完整性。而ThreadLocal正如他的名字一样是线程的本地变量，也就是线程所私有的。因此他和线程同步无关，（因为不存在线程之间共享变量的问题，就不需要使用同步机制）。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？<br><a id=\"more\"></a></p>\n<h4 id=\"API是这样介绍它的：\"><a href=\"#API是这样介绍它的：\" class=\"headerlink\" title=\"API是这样介绍它的：\"></a>API是这样介绍它的：</h4><p><strong>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).</strong></p>\n<h4 id=\"中文翻译\"><a href=\"#中文翻译\" class=\"headerlink\" title=\"中文翻译\"></a>中文翻译</h4><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其<code>get</code> 或 <code>set</code>方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。<code>ThreadLocal</code>实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。正如这句话所说，spring 中的事务就使用了ThreadLocal来保证同一个线程中的所有操作使用的是同一个数据库连接。</p>\n<p>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。</p>\n</blockquote>\n<h3 id=\"如何使用ThreadLocal\"><a href=\"#如何使用ThreadLocal\" class=\"headerlink\" title=\"如何使用ThreadLocal\"></a>如何使用ThreadLocal</h3><blockquote>\n<p>简单案例</p>\n<pre><code class=\"JAVA\">public class SeqCount {\n\n   private static ThreadLocal&lt;Integer&gt; seqCount = new ThreadLocal&lt;Integer&gt;(){\n       // 实现initialValue()\n       public Integer initialValue() {\n           return 0;\n       }\n   };\n\n   public int nextSeq(){\n       seqCount.set(seqCount.get() + 1);\n\n       return seqCount.get();\n   }\n\n   public static void main(String[] args){\n       SeqCount seqCount = new SeqCount();\n\n       SeqThread thread1 = new SeqThread(seqCount);\n       SeqThread thread2 = new SeqThread(seqCount);\n       SeqThread thread3 = new SeqThread(seqCount);\n       SeqThread thread4 = new SeqThread(seqCount);\n\n       thread1.start();\n       thread2.start();\n       thread3.start();\n       thread4.start();\n   }\n\n   private static class SeqThread extends Thread{\n       private SeqCount seqCount;\n\n       SeqThread(SeqCount seqCount){\n           this.seqCount = seqCount;\n       }\n\n       public void run() {\n           for(int i = 0 ; i &lt; 3 ; i++){\n               System.out.println(Thread.currentThread().getName() + &quot; seqCount :&quot; + seqCount.nextSeq());\n           }\n       }\n   }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>Thread-1 seqCount :1\nThread-0 seqCount :1\nThread-2 seqCount :1\nThread-3 seqCount :1\nThread-1 seqCount :2\nThread-0 seqCount :2\nThread-2 seqCount :2\nThread-3 seqCount :2\nThread-1 seqCount :3\nThread-0 seqCount :3\nThread-2 seqCount :3\nThread-3 seqCount :3\n</code></pre><p>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。</p>\n<p><strong>不过这里要注意一个问题，不要使用对象的引用来设置ThreadLocal的初始值，这样会导致线程共享此对象</strong></p>\n<p>就像下面这样写</p>\n<pre><code class=\"java\">   A a = new A();\n   private static ThreadLocal&lt;A&gt; seqCount = new ThreadLocal&lt;A&gt;(){\n       // 实现initialValue()\n       public A initialValue() {\n           return a;\n       }\n   };\n\n   class A{\n       // ....\n   }\n</code></pre>\n<p>具体过程请参考：<a href=\"http://www.jianshu.com/p/ee8c9dccc953\" target=\"_blank\" rel=\"noopener\">对ThreadLocal实现原理的一点思考</a></p>\n<p>总结一般使用ThreadLocal的方式是：</p>\n<ol>\n<li>设置ThreadLocal对象为静态内部私有属性</li>\n<li>使用initalValue方法进行初始化值的时候，不要使用引用对象，这样会造成线程间共享此对象，从而达不到线程私有变量的的效果。</li>\n</ol>\n<p>具体代码如下</p>\n<pre><code class=\"java\">private statis ThreadLocal&lt;T&gt; objectName = new  \n   ThreadLocal(){\n       private T initialValue() {\n               //下面写法肯定有问题，主要是告诉你要声明一个对\n               //象，而不是返回对象的引用\n           return new T() ;\n       }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"ThreadLocal源码解析\"><a href=\"#ThreadLocal源码解析\" class=\"headerlink\" title=\"ThreadLocal源码解析\"></a>ThreadLocal源码解析</h3><blockquote>\n<p>ThreadLocal定义了四个方法：</p>\n<ul>\n<li>get()：返回此线程局部变量的当前线程副本中的值。</li>\n<li>initialValue()：返回此线程局部变量的当前线程的“初始值”。</li>\n<li>remove()：移除此线程局部变量当前线程的值。</li>\n<li>set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。</li>\n</ul>\n<p>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</p>\n<p>对于ThreadLocal需要注意的有两点：</p>\n<ol>\n<li>ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。</li>\n<li>是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。</li>\n</ol>\n<p>下图是Thread、ThreadLocal、ThreadLocalMap的关系</p>\n<p><img src=\"http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg\" alt=\"\"></p>\n<p>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。</p>\n<h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><p>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：</p>\n<pre><code>      static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n           /** The value associated with this ThreadLocal. */\n           Object value;\n\n           Entry(ThreadLocal&lt;?&gt; k, Object v) {\n               super(k);\n               value = v;\n           }\n       }\n</code></pre><p>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp11225/\" target=\"_blank\" rel=\"noopener\">Java 理论与实践: 用弱引用堵住内存泄漏</a>）</p>\n<p>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal&gt; key, Object value)方法。</p>\n<p><strong>set(ThreadLocal&lt;?&gt; key, Object value)</strong></p>\n<pre><code>   private void set(ThreadLocal&lt;?&gt; key, Object value) {\n\n       ThreadLocal.ThreadLocalMap.Entry[] tab = table;\n       int len = tab.length;\n\n       // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置\n       int i = key.threadLocalHashCode &amp; (len-1);\n\n       // 采用“线性探测法”，寻找合适位置\n       for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];\n           e != null;\n           e = tab[i = nextIndex(i, len)]) {\n\n           ThreadLocal&lt;?&gt; k = e.get();\n\n           // key 存在，直接覆盖\n           if (k == key) {\n               e.value = value;\n               return;\n           }\n\n           // key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了\n           if (k == null) {\n               // 用新元素替换陈旧的元素\n               replaceStaleEntry(key, value, i);\n               return;\n           }\n       }\n\n       // ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个\n       tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value);\n\n       int sz = ++size;\n\n       // cleanSomeSlots 清楚陈旧的Entry（key == null）\n       // 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash\n       if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)\n           rehash();\n   }\n</code></pre><p>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考<a href=\"http://www.nowamagic.net/academy/detail/3008015\" target=\"_blank\" rel=\"noopener\">散列冲突处理系列博客</a>）。掌握了开放地址法该方法就一目了然了。</p>\n<p>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：</p>\n<pre><code>private final int threadLocalHashCode = nextHashCode();\n</code></pre><p>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：</p>\n<pre><code>   private static AtomicInteger nextHashCode = new AtomicInteger();\n\n   private static final int HASH_INCREMENT = 0x61c88647;\n\n   private static int nextHashCode() {\n       return nextHashCode.getAndAdd(HASH_INCREMENT);\n   }\n</code></pre><p>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。</p>\n<p><strong>getEntry()</strong></p>\n<pre><code>       private Entry getEntry(ThreadLocal&lt;?&gt; key) {\n           int i = key.threadLocalHashCode &amp; (table.length - 1);\n           Entry e = table[i];\n           if (e != null &amp;&amp; e.get() == key)\n               return e;\n           else\n               return getEntryAfterMiss(key, i, e);\n       }\n</code></pre><p>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：</p>\n<pre><code>       private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {\n           Entry[] tab = table;\n           int len = tab.length;\n\n           while (e != null) {\n               ThreadLocal&lt;?&gt; k = e.get();\n               if (k == key)\n                   return e;\n               if (k == null)\n                   expungeStaleEntry(i);\n               else\n                   i = nextIndex(i, len);\n               e = tab[i];\n           }\n           return null;\n       }\n</code></pre><p>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><blockquote>\n<p>返回当前线程所对应的线程变量</p>\n</blockquote>\n<pre><code>   public T get() {\n       // 获取当前线程\n       Thread t = Thread.currentThread();\n\n       // 获取当前线程的成员变量 threadLocal\n       ThreadLocalMap map = getMap(t);\n       if (map != null) {\n           // 从当前线程的ThreadLocalMap获取相对应的Entry\n           ThreadLocalMap.Entry e = map.getEntry(this);\n           if (e != null) {\n               @SuppressWarnings(&quot;unchecked&quot;)\n\n               // 获取目标值        \n               T result = (T)e.value;\n               return result;\n           }\n       }\n       return setInitialValue();\n   }\n</code></pre><p>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。</p>\n<p>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：</p>\n<pre><code>   ThreadLocalMap getMap(Thread t) {\n       return t.threadLocals;\n   }\n</code></pre><h3 id=\"set-T-value\"><a href=\"#set-T-value\" class=\"headerlink\" title=\"set(T value)\"></a>set(T value)</h3><blockquote>\n<p>设置当前线程的线程局部变量的值。</p>\n</blockquote>\n<pre><code>   public void set(T value) {\n       Thread t = Thread.currentThread();\n       ThreadLocalMap map = getMap(t);\n       if (map != null)\n           map.set(this, value);\n       else\n           createMap(t, value);\n   }\n</code></pre><p>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：</p>\n<pre><code>   void createMap(Thread t, T firstValue) {\n       t.threadLocals = new ThreadLocalMap(this, firstValue);\n   }\n</code></pre><h3 id=\"initialValue\"><a href=\"#initialValue\" class=\"headerlink\" title=\"initialValue()\"></a>initialValue()</h3><blockquote>\n<p>返回该线程局部变量的初始值。</p>\n</blockquote>\n<pre><code class=\"JAVA\">   protected T initialValue() {\n       return null;\n   }\n</code></pre>\n<p>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><blockquote>\n<p>将当前线程局部变量的值删除。</p>\n</blockquote>\n<pre><code class=\"java\">public void remove() {\n   ThreadLocalMap m =  getMap(Thread.currentThread());\n   if (m != null)\n       m.remove(this);\n}\n</code></pre>\n<p>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<ul>\n<li>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。</li>\n<li>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</li>\n<li>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li>\n</ul>\n<p>这里有一个使用ThreadLocal的案例，可以好好看看，写的很好</p>\n<p><a href=\"https://www.jianshu.com/p/1becdc376f5d\" target=\"_blank\" rel=\"noopener\">透彻理解Spring事务设计思想之手写实现</a></p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/\" target=\"_blank\" rel=\"noopener\">深入分析 ThreadLocal 内存泄漏问题</a></li>\n<li><a href=\"http://cmsblogs.com/?p=2442\" target=\"_blank\" rel=\"noopener\">【死磕Java并发】—–深入分析ThreadLocal</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<ol>\n<li>ThreadLocal是什么</li>\n<li>如何使用ThreadLocal</li>\n<li>ThreadLocal源码分析</li>\n<li>总结</li>\n</ol>\n</blockquote>\n<h3 id=\"ThreadLocal-是什么\"><a href=\"#ThreadLocal-是什么\" class=\"headerlink\" title=\"ThreadLocal 是什么\"></a>ThreadLocal 是什么</h3><blockquote>\n<p>首先我们要明白一点，线程同步主要是为了完成线程间数据共享和同步，保持数据的完整性。而ThreadLocal正如他的名字一样是线程的本地变量，也就是线程所私有的。因此他和线程同步无关，（因为不存在线程之间共享变量的问题，就不需要使用同步机制）。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？<br>","more":"</p>\n<h4 id=\"API是这样介绍它的：\"><a href=\"#API是这样介绍它的：\" class=\"headerlink\" title=\"API是这样介绍它的：\"></a>API是这样介绍它的：</h4><p><strong>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).</strong></p>\n<h4 id=\"中文翻译\"><a href=\"#中文翻译\" class=\"headerlink\" title=\"中文翻译\"></a>中文翻译</h4><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其<code>get</code> 或 <code>set</code>方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。<code>ThreadLocal</code>实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。正如这句话所说，spring 中的事务就使用了ThreadLocal来保证同一个线程中的所有操作使用的是同一个数据库连接。</p>\n<p>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。</p>\n</blockquote>\n<h3 id=\"如何使用ThreadLocal\"><a href=\"#如何使用ThreadLocal\" class=\"headerlink\" title=\"如何使用ThreadLocal\"></a>如何使用ThreadLocal</h3><blockquote>\n<p>简单案例</p>\n<pre><code class=\"JAVA\">public class SeqCount {\n\n   private static ThreadLocal&lt;Integer&gt; seqCount = new ThreadLocal&lt;Integer&gt;(){\n       // 实现initialValue()\n       public Integer initialValue() {\n           return 0;\n       }\n   };\n\n   public int nextSeq(){\n       seqCount.set(seqCount.get() + 1);\n\n       return seqCount.get();\n   }\n\n   public static void main(String[] args){\n       SeqCount seqCount = new SeqCount();\n\n       SeqThread thread1 = new SeqThread(seqCount);\n       SeqThread thread2 = new SeqThread(seqCount);\n       SeqThread thread3 = new SeqThread(seqCount);\n       SeqThread thread4 = new SeqThread(seqCount);\n\n       thread1.start();\n       thread2.start();\n       thread3.start();\n       thread4.start();\n   }\n\n   private static class SeqThread extends Thread{\n       private SeqCount seqCount;\n\n       SeqThread(SeqCount seqCount){\n           this.seqCount = seqCount;\n       }\n\n       public void run() {\n           for(int i = 0 ; i &lt; 3 ; i++){\n               System.out.println(Thread.currentThread().getName() + &quot; seqCount :&quot; + seqCount.nextSeq());\n           }\n       }\n   }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>Thread-1 seqCount :1\nThread-0 seqCount :1\nThread-2 seqCount :1\nThread-3 seqCount :1\nThread-1 seqCount :2\nThread-0 seqCount :2\nThread-2 seqCount :2\nThread-3 seqCount :2\nThread-1 seqCount :3\nThread-0 seqCount :3\nThread-2 seqCount :3\nThread-3 seqCount :3\n</code></pre><p>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。</p>\n<p><strong>不过这里要注意一个问题，不要使用对象的引用来设置ThreadLocal的初始值，这样会导致线程共享此对象</strong></p>\n<p>就像下面这样写</p>\n<pre><code class=\"java\">   A a = new A();\n   private static ThreadLocal&lt;A&gt; seqCount = new ThreadLocal&lt;A&gt;(){\n       // 实现initialValue()\n       public A initialValue() {\n           return a;\n       }\n   };\n\n   class A{\n       // ....\n   }\n</code></pre>\n<p>具体过程请参考：<a href=\"http://www.jianshu.com/p/ee8c9dccc953\" target=\"_blank\" rel=\"noopener\">对ThreadLocal实现原理的一点思考</a></p>\n<p>总结一般使用ThreadLocal的方式是：</p>\n<ol>\n<li>设置ThreadLocal对象为静态内部私有属性</li>\n<li>使用initalValue方法进行初始化值的时候，不要使用引用对象，这样会造成线程间共享此对象，从而达不到线程私有变量的的效果。</li>\n</ol>\n<p>具体代码如下</p>\n<pre><code class=\"java\">private statis ThreadLocal&lt;T&gt; objectName = new  \n   ThreadLocal(){\n       private T initialValue() {\n               //下面写法肯定有问题，主要是告诉你要声明一个对\n               //象，而不是返回对象的引用\n           return new T() ;\n       }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"ThreadLocal源码解析\"><a href=\"#ThreadLocal源码解析\" class=\"headerlink\" title=\"ThreadLocal源码解析\"></a>ThreadLocal源码解析</h3><blockquote>\n<p>ThreadLocal定义了四个方法：</p>\n<ul>\n<li>get()：返回此线程局部变量的当前线程副本中的值。</li>\n<li>initialValue()：返回此线程局部变量的当前线程的“初始值”。</li>\n<li>remove()：移除此线程局部变量当前线程的值。</li>\n<li>set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。</li>\n</ul>\n<p>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</p>\n<p>对于ThreadLocal需要注意的有两点：</p>\n<ol>\n<li>ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。</li>\n<li>是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。</li>\n</ol>\n<p>下图是Thread、ThreadLocal、ThreadLocalMap的关系</p>\n<p><img src=\"http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg\" alt=\"\"></p>\n<p>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。</p>\n<h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><p>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：</p>\n<pre><code>      static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n           /** The value associated with this ThreadLocal. */\n           Object value;\n\n           Entry(ThreadLocal&lt;?&gt; k, Object v) {\n               super(k);\n               value = v;\n           }\n       }\n</code></pre><p>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp11225/\" target=\"_blank\" rel=\"noopener\">Java 理论与实践: 用弱引用堵住内存泄漏</a>）</p>\n<p>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal&gt; key, Object value)方法。</p>\n<p><strong>set(ThreadLocal&lt;?&gt; key, Object value)</strong></p>\n<pre><code>   private void set(ThreadLocal&lt;?&gt; key, Object value) {\n\n       ThreadLocal.ThreadLocalMap.Entry[] tab = table;\n       int len = tab.length;\n\n       // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置\n       int i = key.threadLocalHashCode &amp; (len-1);\n\n       // 采用“线性探测法”，寻找合适位置\n       for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];\n           e != null;\n           e = tab[i = nextIndex(i, len)]) {\n\n           ThreadLocal&lt;?&gt; k = e.get();\n\n           // key 存在，直接覆盖\n           if (k == key) {\n               e.value = value;\n               return;\n           }\n\n           // key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了\n           if (k == null) {\n               // 用新元素替换陈旧的元素\n               replaceStaleEntry(key, value, i);\n               return;\n           }\n       }\n\n       // ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个\n       tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value);\n\n       int sz = ++size;\n\n       // cleanSomeSlots 清楚陈旧的Entry（key == null）\n       // 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash\n       if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)\n           rehash();\n   }\n</code></pre><p>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考<a href=\"http://www.nowamagic.net/academy/detail/3008015\" target=\"_blank\" rel=\"noopener\">散列冲突处理系列博客</a>）。掌握了开放地址法该方法就一目了然了。</p>\n<p>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：</p>\n<pre><code>private final int threadLocalHashCode = nextHashCode();\n</code></pre><p>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：</p>\n<pre><code>   private static AtomicInteger nextHashCode = new AtomicInteger();\n\n   private static final int HASH_INCREMENT = 0x61c88647;\n\n   private static int nextHashCode() {\n       return nextHashCode.getAndAdd(HASH_INCREMENT);\n   }\n</code></pre><p>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。</p>\n<p><strong>getEntry()</strong></p>\n<pre><code>       private Entry getEntry(ThreadLocal&lt;?&gt; key) {\n           int i = key.threadLocalHashCode &amp; (table.length - 1);\n           Entry e = table[i];\n           if (e != null &amp;&amp; e.get() == key)\n               return e;\n           else\n               return getEntryAfterMiss(key, i, e);\n       }\n</code></pre><p>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：</p>\n<pre><code>       private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {\n           Entry[] tab = table;\n           int len = tab.length;\n\n           while (e != null) {\n               ThreadLocal&lt;?&gt; k = e.get();\n               if (k == key)\n                   return e;\n               if (k == null)\n                   expungeStaleEntry(i);\n               else\n                   i = nextIndex(i, len);\n               e = tab[i];\n           }\n           return null;\n       }\n</code></pre><p>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><blockquote>\n<p>返回当前线程所对应的线程变量</p>\n</blockquote>\n<pre><code>   public T get() {\n       // 获取当前线程\n       Thread t = Thread.currentThread();\n\n       // 获取当前线程的成员变量 threadLocal\n       ThreadLocalMap map = getMap(t);\n       if (map != null) {\n           // 从当前线程的ThreadLocalMap获取相对应的Entry\n           ThreadLocalMap.Entry e = map.getEntry(this);\n           if (e != null) {\n               @SuppressWarnings(&quot;unchecked&quot;)\n\n               // 获取目标值        \n               T result = (T)e.value;\n               return result;\n           }\n       }\n       return setInitialValue();\n   }\n</code></pre><p>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。</p>\n<p>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：</p>\n<pre><code>   ThreadLocalMap getMap(Thread t) {\n       return t.threadLocals;\n   }\n</code></pre><h3 id=\"set-T-value\"><a href=\"#set-T-value\" class=\"headerlink\" title=\"set(T value)\"></a>set(T value)</h3><blockquote>\n<p>设置当前线程的线程局部变量的值。</p>\n</blockquote>\n<pre><code>   public void set(T value) {\n       Thread t = Thread.currentThread();\n       ThreadLocalMap map = getMap(t);\n       if (map != null)\n           map.set(this, value);\n       else\n           createMap(t, value);\n   }\n</code></pre><p>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：</p>\n<pre><code>   void createMap(Thread t, T firstValue) {\n       t.threadLocals = new ThreadLocalMap(this, firstValue);\n   }\n</code></pre><h3 id=\"initialValue\"><a href=\"#initialValue\" class=\"headerlink\" title=\"initialValue()\"></a>initialValue()</h3><blockquote>\n<p>返回该线程局部变量的初始值。</p>\n</blockquote>\n<pre><code class=\"JAVA\">   protected T initialValue() {\n       return null;\n   }\n</code></pre>\n<p>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><blockquote>\n<p>将当前线程局部变量的值删除。</p>\n</blockquote>\n<pre><code class=\"java\">public void remove() {\n   ThreadLocalMap m =  getMap(Thread.currentThread());\n   if (m != null)\n       m.remove(this);\n}\n</code></pre>\n<p>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<ul>\n<li>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。</li>\n<li>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</li>\n<li>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li>\n</ul>\n<p>这里有一个使用ThreadLocal的案例，可以好好看看，写的很好</p>\n<p><a href=\"https://www.jianshu.com/p/1becdc376f5d\" target=\"_blank\" rel=\"noopener\">透彻理解Spring事务设计思想之手写实现</a></p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/\" target=\"_blank\" rel=\"noopener\">深入分析 ThreadLocal 内存泄漏问题</a></li>\n<li><a href=\"http://cmsblogs.com/?p=2442\" target=\"_blank\" rel=\"noopener\">【死磕Java并发】—–深入分析ThreadLocal</a></li>\n</ol>"},{"abbrlink":16,"title":"伪共享（false sharing）并发编程无声的性能杀手","author":"zhangke","date":"2018-04-10T11:41:00.000Z","_content":"# 伪共享（false sharing），并发编程无声的性能杀手\n\n在并发编程过程中，我们大部分的焦点都放在如何控制共享变量的访问控制上（代码层面），但是很少人会关注系统硬件及 JVM 底层相关的影响因素。前段时间学习了一个牛X的高性能异步处理框架 Disruptor，它被誉为“最快的消息框架”，其 LMAX 架构能够在一个线程里每秒处理 6百万 订单！在讲到 Disruptor 为什么这么快时，接触到了一个概念——伪共享( false sharing )，其中提到：缓存行上的写竞争是运行在 SMP 系统中并行线程实现可伸缩性最重要的限制因素。由于从代码中很难看出是否会出现伪共享，有人将其描述成无声的性能杀手。\n\n本文仅针对目前所学进行合并整理，目前并无非常深入地研究和实践，希望对大家从零开始理解伪共享提供一些帮助。\n\n> 伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。\n\n下面我们就来详细剖析伪共享产生的前因后果。首先，我们要了解什么是缓存系统。\n\n###  \n\n## **一、CPU 缓存**\n\nCPU 缓存的百度百科定义为：\n\nCPU 缓存（Cache Memory）是位于 CPU 与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。\n高速缓存的出现主要是为了解决 CPU 运算速度与内存读写速度不匹配的矛盾，因为 CPU 运算速度要比内存读写速度快很多，这样会使 CPU 花费很长时间等待数据到来或把数据写入内存。\n在缓存中的数据是内存中的一小部分，但这一小部分是短时间内 CPU 即将访问的，当 CPU 调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。\n\nCPU 和主内存之间有好几层缓存，因为即使直接访问主内存也是非常慢的。如果你正在多次对一块数据做相同的运算，那么在执行运算的时候把它加载到离 CPU 很近的地方就有意义了。\n\n按照数据读取顺序和与 CPU 结合的紧密程度，CPU 缓存可以分为一级缓存，二级缓存，部分高端 CPU 还具有三级缓存。每一级缓存中所储存的全部数据都是下一级缓存的一部分，越靠近 CPU 的缓存越快也越小。所以 L1 缓存很小但很快(译注：L1 表示一级缓存)，并且紧靠着在使用它的 CPU 内核。L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。拥有三级缓存的的 CPU，到三级缓存时能够达到 95% 的命中率，只有不到 5% 的数据需要从内存中查询。\n\n多核机器的存储结构如下图所示：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201221667-1059026925.png)\n\n当 CPU 执行运算的时候，它先去 L1 查找所需的数据，再去 L2，然后是 L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要确保数据在 L1 缓存中。\n\nMartin Thompson 给出了一些缓存未命中的消耗数据，如下所示：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201305464-895015043.png)\n\n## **二、MESI 协议及 RFO 请求**\n\n从上一节中我们知道，每个核都有自己私有的 L1,、L2 缓存。那么多线程编程时, 另外一个核的线程想要访问当前核内 L1、L2 缓存行的数据, 该怎么办呢？\n\n有人说可以通过第 2 个核直接访问第 1 个核的缓存行，这是当然是可行的，但这种方法不够快。跨核访问需要通过 Memory Controller（内存控制器，是计算机系统内部控制内存并且通过内存控制器使内存与 CPU 之间交换数据的重要组成部分），典型的情况是第 2 个核经常访问第 1 个核的这条数据，那么每次都有跨核的消耗.。更糟的情况是，有可能第 2 个核与第 1 个核不在一个插槽内，况且 Memory Controller 的总线带宽是有限的，扛不住这么多数据传输。所以，CPU 设计者们更偏向于另一种办法： 如果第 2 个核需要这份数据，由第 1 个核直接把数据内容发过去，数据只需要传一次。\n\n那么什么时候会发生缓存行的传输呢？答案很简单：当一个核需要读取另外一个核的脏缓存行时发生。但是前者怎么判断后者的缓存行已经被弄脏(写)了呢？\n\n下面将详细地解答以上问题. 首先我们需要谈到一个协议—— MESI 协议。现在主流的处理器都是用它来保证缓存的相干性和内存的相干性。M、E、S 和 I 代表使用 MESI 协议时缓存行所处的四个状态：\n\n* M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；\n* E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；\n* S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；\n* I（无效，Invalid）：缓存行失效, 不能使用。\n\n下面说明这四个状态是如何转换的：\n\n初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。\n\n本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。\n\n本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）\n\n远程读（Remote Read）：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。\n\n远程写（Remote Write）：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。\n\n状态转换由下图做个补充：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201649808-555029301.png)\n\n我们从上节知道，写操作的代价很高，特别当需要发送 RFO 消息时。我们编写程序时，什么时候会发生 RFO 请求呢？有以下两种：\n\n1. 线程的工作从一个处理器移到另一个处理器, 它操作的所有缓存行都需要移到新的处理器上。此后如果再写缓存行，则此缓存行在不同核上有多个拷贝，需要发送 RFO 请求了。\n2. 两个不同的处理器确实都需要操作相同的缓存行\n\n接下来，我们要了解什么是缓存行。\n\n## **缓存行**\n\n为了高效地存取缓存, 不是简单随意地将单条数据写入缓存的.  缓存是由缓存行组成的, 典型的一行是64字节. 读者可以通过下面的shell命令,查看cherency_line_size就知道知道机器的缓存行是多大. \n\n```\n cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size   \n 64  \n```\n\nCPU存取缓存都是按行为最小单位操作的. 在这儿我将不提及缓存的associativity问题, 将问题简化一些. 一个Java long型占8字节, 所以从一条缓存行上你可以获取到8个long型变量. 所以如果你访问一个long型数组, 当有一个long被加载到cache中, 你将无消耗地加载了另外7个. 所以你可以非常快地遍历数组.\n\n下面是利用缓存行来进行的对比实验代码\n\n```java\npublic class L1CacheMiss {  \n    private static final int RUNS = 10;  \n    private static final int DIMENSION_1 = 1024 * 1024;  \n    private static final int DIMENSION_2 = 62;  \n  \n    private static long[][] longs;  \n  \n    public static void main(String[] args) throws Exception {  \n        Thread.sleep(10000);  \n        longs = new long[DIMENSION_1][];  \n        for (int i = 0; i < DIMENSION_1; i++) {  \n            longs[i] = new long[DIMENSION_2];  \n            for (int j = 0; j < DIMENSION_2; j++) {  \n                longs[i][j] = 0L;  \n            }  \n        }  \n        System.out.println(\"starting....\");  \n  \n        final long start = System.nanoTime();  \n        long sum = 0L;  \n        for (int r = 0; r < RUNS; r++) {  \n//          for (int j = 0; j < DIMENSION_2; j++) {  \n//              for (int i = 0; i < DIMENSION_1; i++) {  \n//                  sum += longs[i][j];  \n//              }  \n//          }  \n  \n            for (int i = 0; i < DIMENSION_1; i++) {  \n                for (int j = 0; j < DIMENSION_2; j++) {  \n                    sum += longs[i][j];  \n                }  \n            }  \n        }  \n        System.out.println(\"duration = \" + (System.nanoTime() - start));  \n    }  \n}  \n```\n\n编译运行得到的结果如下\n\n```\n    starting....\n    duration =  850623099\n```\n\n然后我们将22-26行的注释取消, 将28-32行注释, 编译后再次运行,结果是不是比我们预想得还糟? \n\n```\nstarting....\nduration = 8078753353\n```\n\n通过对比可以看出，第二个花的时间是第一个的10倍还多。从上节我们可以知道在加载longs\\[i][j]时, longs\\[i][j+1]很可能也会被加载至cache中, 所以立即访问longs\\[i][j+1]将会命中L1 Cache, 而如果你访问longs\\[i+1][j]情况就不一样了, 这时候很可能会产生 cache miss导致效率低下. \n\n以上我只是示例了在L1 Cache满了之后才会发生的cache miss. 其实cache miss的原因有下面三种: \n\n1. 第一次访问数据, 在cache中根本不存在这条数据, 所以cache miss, 可以通过prefetch解决. \n2. cache冲突, 需要通过补齐来解决. \n3. 就是我示例的这种, cache满, 一般情况下我们需要减少操作的数据大小, 尽量按数据的物理顺序访问数据\n\n## 四、伪共享\n\n在文章开头提到过，缓存系统中是以缓存行（cache line）为单位存储的。缓存行通常是 64 字节（译注：本文基于 64 字节，其他长度的如 32 字节等不适本文讨论的重点），并且它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。所以，如果你访问一个 long 数组，当数组中的一个值被加载到缓存中，它会额外加载另外 7 个，以致你能非常快地遍历这个数组。事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构。而如果你在数据结构中的项在内存中不是彼此相邻的（如链表），你将得不到免费缓存加载所带来的优势，并且在这些数据结构中的每一个项都可能会出现缓存未命中。\n\n如果存在这样的场景，有多个线程操作不同的成员变量，但是相同的缓存行，这个时候会发生什么？。没错，伪共享（False Sharing）问题就发生了！有张 Disruptor 项目的经典示例图，如下：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202002573-736704844.png)\n\n上图中，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送 RFO 消息，占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。\n\n表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。\n\n## *五、遭遇伪共享*\n\n好的，那么接下来我们就用 code 来进行实验和佐证。\n\n```\npublic class FalseShareTest implements Runnable {\n    public static int NUM_THREADS = 4;\n    public final static long ITERATIONS = 500L * 1000L * 1000L;\n    private final int arrayIndex;\n    private static VolatileLong[] longs;\n    public static long SUM_TIME = 0l;\n    public FalseShareTest(final int arrayIndex) {\n        this.arrayIndex = arrayIndex;\n    }\n    public static void main(final String[] args) throws Exception {\n        Thread.sleep(10000);\n        for(int j=0; j<10; j++){\n            System.out.println(j);\n            if (args.length == 1) {\n                NUM_THREADS = Integer.parseInt(args[0]);\n            }\n            longs = new VolatileLong[NUM_THREADS];\n            for (int i = 0; i < longs.length; i++) {\n                longs[i] = new VolatileLong();\n            }\n            final long start = System.nanoTime();\n            runTest();\n            final long end = System.nanoTime();\n            SUM_TIME += end - start;\n        }\n        System.out.println(\"平均耗时：\"+SUM_TIME/10);\n    }\n    private static void runTest() throws InterruptedException {\n        Thread[] threads = new Thread[NUM_THREADS];\n        for (int i = 0; i < threads.length; i++) {\n            threads[i] = new Thread(new FalseShareTest(i));\n        }\n        for (Thread t : threads) {\n            t.start();\n        }\n        for (Thread t : threads) {\n            t.join();\n        }\n    }\n    public void run() {\n        long i = ITERATIONS + 1;\n        while (0 != --i) {\n            longs[arrayIndex].value = i;\n        }\n    }\n    public final static class VolatileLong {\n        public volatile long value = 0L;\n        public long p1, p2, p3, p4, p5, p6;     //屏蔽此行\n    }\n}\n```\n\n上述代码的逻辑很简单，就是四个线程修改一数组不同元素的内容。元素的类型是 VolatileLong，只有一个长整型成员 value 和 6 个没用到的长整型成员。value 设为 volatile 是为了让 value 的修改对所有线程都可见。程序分两种情况执行，第一种情况为不屏蔽倒数第三行（见”屏蔽此行”字样），第二种情况为屏蔽倒数第三行。为了”保证”数据的相对可靠性，程序取 10 次执行的平均时间。执行情况如下（执行环境：32位 windows，四核，8GB 内存）：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202253714-555001087.png)         ![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202308245-492044780.png)\n\n（不屏蔽）                                                          （屏蔽）\n\n两个逻辑一模一样的程序，前者的耗时大概是后者的 2.5 倍，这太不可思议了！那么这个时候，我们再用伪共享（False Sharing）的理论来分析一下。前者 longs 数组的 4 个元素，由于 VolatileLong 只有 1 个长整型成员，所以整个数组都将被加载至同一缓存行，但有4个线程同时操作这条缓存行，于是伪共享就悄悄地发生了。\n\n基于此，我们有理由相信，在一定线程数量范围内（注意思考：为什么强调是一定线程数量范围内），随着线程数量的增加，伪共享发生的频率也越大，直观体现就是执行时间越长。为了证实这个观点，本人在同样的机器上分别用单线程、2、4、8个线程，对有填充和无填充两种情况进行测试。执行场景是取 10 次执行的平均时间，结果如下所示：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202449620-46958750.png)\n\n## 六、如何避免伪共享？**\n\n> 其中一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可。\n\n那么该如何做到呢？其实在我们注释的那行代码中就有答案，那就是缓存行填充（Padding） 。现在分析上面的例子，我们知道一条缓存行有 64 字节，而 Java 程序的对象头固定占 8 字节(32位系统)或 12 字节( 64 位系统默认开启压缩, 不开压缩为 16 字节)，所以我们只需要填 6 个无用的长整型补上6*8=48字节，让不同的 VolatileLong 对象处于不同的缓存行，就避免了伪共享( 64 位系统超过缓存行的 64 字节也无所谓，只要保证不同线程不操作同一缓存行就可以)。\n\n伪共享在多核编程中很容易发生，而且非常隐蔽。例如，在 JDK 的 LinkedBlockingQueue 中，存在指向队列头的引用 head 和指向队列尾的引用 tail 。而这种队列经常在异步编程中使有，这两个引用的值经常的被不同的线程修改，但它们却很可能在同一个缓存行，于是就产生了伪共享。线程越多，核越多，对性能产生的负面效果就越大。\n\n由于某些 Java 编译器的优化策略，那些没有使用到的补齐数据可能会在编译期间被优化掉，我们可以在程序中加入一些代码防止被编译优化。如下：\n\n```\npublic static long preventFromOptimization(VolatileLong v) {  \n        return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;  \n}\n```\n\n> 另外一种技术是使用编译指示，来强制使每一个变量对齐。\n\n下面的代码显式了编译器使用__declspec( align(n) ) 此处 n=64，按照 cache line 边界对齐。\n\n```\n__declspec (align(64)) int thread1_global_variable;\n__declspec (align(64)) int thread2_global_variable;\n```\n\n当使用数组时，在 cache line 尾部填充 padding 来保证数据元素在 cache line 边界开始。如果不能够保证数组按照 cache line 边界对齐，填充数据结构【数组元素】使之是 cache line 大小的两倍。下面的代码显式了填充数据结构使之按照 cache line 对齐。并且通过 __declspec( align(n) ) 语句来保证数组也是对齐的。如果数组是动态分配的，你可以增加分配的大小，并调整指针来对其到 cache line 边界。\n\n```\nstruct ThreadParams\n{\n    // For the following 4 variables: 4*4 = 16 bytes\n    unsigned long thread_id;\n    unsigned long v; // Frequent read/write access variable\n    unsigned long start;\n    unsigned long end;\n    // expand to 64 bytes to avoid false-sharing \n    // (4 unsigned long variables + 12 padding)*4 = 64\n    int padding[12];\n};\n```\n\n除此之外，在网上还有很多对伪共享的研究，提出了一些基于数据融合的方案，有兴趣的同学可以了解下。\n\n## 七、对于伪共享，我们在实际开发中该怎么做？**\n\n通过上面大篇幅的介绍，我们已经知道伪共享的对程序的影响。那么，在实际的生产开发过程中，我们一定要通过缓存行填充去解决掉潜在的伪共享问题吗？\n\n其实并不一定。\n\n首先就是多次强调的，伪共享是很隐蔽的，我们暂时无法从系统层面上通过工具来探测伪共享事件。其次，不同类型的计算机具有不同的微架构（如 32 位系统和 64 位系统的 java 对象所占自己数就不一样），如果设计到跨平台的设计，那就更难以把握了，一个确切的填充方案只适用于一个特定的操作系统。还有，缓存的资源是有限的，如果填充会浪费珍贵的 cache 资源，并不适合大范围应用。最后，目前主流的 Intel 微架构 CPU 的 L1 缓存，已能够达到 80% 以上的命中率。\n\n综上所述，并不是每个系统都适合花大量精力去解决潜在的伪共享问题。\n\n","source":"_posts/伪缓存.md","raw":"abbrlink: 16\ntitle: 伪共享（false sharing）并发编程无声的性能杀手\ntags:\n  - 操作系统\ncategories:\n  - 操作系统\nauthor: zhangke\ndate: 2018-04-10 19:41:00\n---\n# 伪共享（false sharing），并发编程无声的性能杀手\n\n在并发编程过程中，我们大部分的焦点都放在如何控制共享变量的访问控制上（代码层面），但是很少人会关注系统硬件及 JVM 底层相关的影响因素。前段时间学习了一个牛X的高性能异步处理框架 Disruptor，它被誉为“最快的消息框架”，其 LMAX 架构能够在一个线程里每秒处理 6百万 订单！在讲到 Disruptor 为什么这么快时，接触到了一个概念——伪共享( false sharing )，其中提到：缓存行上的写竞争是运行在 SMP 系统中并行线程实现可伸缩性最重要的限制因素。由于从代码中很难看出是否会出现伪共享，有人将其描述成无声的性能杀手。\n\n本文仅针对目前所学进行合并整理，目前并无非常深入地研究和实践，希望对大家从零开始理解伪共享提供一些帮助。\n\n> 伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。\n\n下面我们就来详细剖析伪共享产生的前因后果。首先，我们要了解什么是缓存系统。\n\n###  \n\n## **一、CPU 缓存**\n\nCPU 缓存的百度百科定义为：\n\nCPU 缓存（Cache Memory）是位于 CPU 与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。\n高速缓存的出现主要是为了解决 CPU 运算速度与内存读写速度不匹配的矛盾，因为 CPU 运算速度要比内存读写速度快很多，这样会使 CPU 花费很长时间等待数据到来或把数据写入内存。\n在缓存中的数据是内存中的一小部分，但这一小部分是短时间内 CPU 即将访问的，当 CPU 调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。\n\nCPU 和主内存之间有好几层缓存，因为即使直接访问主内存也是非常慢的。如果你正在多次对一块数据做相同的运算，那么在执行运算的时候把它加载到离 CPU 很近的地方就有意义了。\n\n按照数据读取顺序和与 CPU 结合的紧密程度，CPU 缓存可以分为一级缓存，二级缓存，部分高端 CPU 还具有三级缓存。每一级缓存中所储存的全部数据都是下一级缓存的一部分，越靠近 CPU 的缓存越快也越小。所以 L1 缓存很小但很快(译注：L1 表示一级缓存)，并且紧靠着在使用它的 CPU 内核。L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。拥有三级缓存的的 CPU，到三级缓存时能够达到 95% 的命中率，只有不到 5% 的数据需要从内存中查询。\n\n多核机器的存储结构如下图所示：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201221667-1059026925.png)\n\n当 CPU 执行运算的时候，它先去 L1 查找所需的数据，再去 L2，然后是 L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要确保数据在 L1 缓存中。\n\nMartin Thompson 给出了一些缓存未命中的消耗数据，如下所示：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201305464-895015043.png)\n\n## **二、MESI 协议及 RFO 请求**\n\n从上一节中我们知道，每个核都有自己私有的 L1,、L2 缓存。那么多线程编程时, 另外一个核的线程想要访问当前核内 L1、L2 缓存行的数据, 该怎么办呢？\n\n有人说可以通过第 2 个核直接访问第 1 个核的缓存行，这是当然是可行的，但这种方法不够快。跨核访问需要通过 Memory Controller（内存控制器，是计算机系统内部控制内存并且通过内存控制器使内存与 CPU 之间交换数据的重要组成部分），典型的情况是第 2 个核经常访问第 1 个核的这条数据，那么每次都有跨核的消耗.。更糟的情况是，有可能第 2 个核与第 1 个核不在一个插槽内，况且 Memory Controller 的总线带宽是有限的，扛不住这么多数据传输。所以，CPU 设计者们更偏向于另一种办法： 如果第 2 个核需要这份数据，由第 1 个核直接把数据内容发过去，数据只需要传一次。\n\n那么什么时候会发生缓存行的传输呢？答案很简单：当一个核需要读取另外一个核的脏缓存行时发生。但是前者怎么判断后者的缓存行已经被弄脏(写)了呢？\n\n下面将详细地解答以上问题. 首先我们需要谈到一个协议—— MESI 协议。现在主流的处理器都是用它来保证缓存的相干性和内存的相干性。M、E、S 和 I 代表使用 MESI 协议时缓存行所处的四个状态：\n\n* M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；\n* E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；\n* S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；\n* I（无效，Invalid）：缓存行失效, 不能使用。\n\n下面说明这四个状态是如何转换的：\n\n初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。\n\n本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。\n\n本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）\n\n远程读（Remote Read）：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。\n\n远程写（Remote Write）：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。\n\n状态转换由下图做个补充：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201649808-555029301.png)\n\n我们从上节知道，写操作的代价很高，特别当需要发送 RFO 消息时。我们编写程序时，什么时候会发生 RFO 请求呢？有以下两种：\n\n1. 线程的工作从一个处理器移到另一个处理器, 它操作的所有缓存行都需要移到新的处理器上。此后如果再写缓存行，则此缓存行在不同核上有多个拷贝，需要发送 RFO 请求了。\n2. 两个不同的处理器确实都需要操作相同的缓存行\n\n接下来，我们要了解什么是缓存行。\n\n## **缓存行**\n\n为了高效地存取缓存, 不是简单随意地将单条数据写入缓存的.  缓存是由缓存行组成的, 典型的一行是64字节. 读者可以通过下面的shell命令,查看cherency_line_size就知道知道机器的缓存行是多大. \n\n```\n cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size   \n 64  \n```\n\nCPU存取缓存都是按行为最小单位操作的. 在这儿我将不提及缓存的associativity问题, 将问题简化一些. 一个Java long型占8字节, 所以从一条缓存行上你可以获取到8个long型变量. 所以如果你访问一个long型数组, 当有一个long被加载到cache中, 你将无消耗地加载了另外7个. 所以你可以非常快地遍历数组.\n\n下面是利用缓存行来进行的对比实验代码\n\n```java\npublic class L1CacheMiss {  \n    private static final int RUNS = 10;  \n    private static final int DIMENSION_1 = 1024 * 1024;  \n    private static final int DIMENSION_2 = 62;  \n  \n    private static long[][] longs;  \n  \n    public static void main(String[] args) throws Exception {  \n        Thread.sleep(10000);  \n        longs = new long[DIMENSION_1][];  \n        for (int i = 0; i < DIMENSION_1; i++) {  \n            longs[i] = new long[DIMENSION_2];  \n            for (int j = 0; j < DIMENSION_2; j++) {  \n                longs[i][j] = 0L;  \n            }  \n        }  \n        System.out.println(\"starting....\");  \n  \n        final long start = System.nanoTime();  \n        long sum = 0L;  \n        for (int r = 0; r < RUNS; r++) {  \n//          for (int j = 0; j < DIMENSION_2; j++) {  \n//              for (int i = 0; i < DIMENSION_1; i++) {  \n//                  sum += longs[i][j];  \n//              }  \n//          }  \n  \n            for (int i = 0; i < DIMENSION_1; i++) {  \n                for (int j = 0; j < DIMENSION_2; j++) {  \n                    sum += longs[i][j];  \n                }  \n            }  \n        }  \n        System.out.println(\"duration = \" + (System.nanoTime() - start));  \n    }  \n}  \n```\n\n编译运行得到的结果如下\n\n```\n    starting....\n    duration =  850623099\n```\n\n然后我们将22-26行的注释取消, 将28-32行注释, 编译后再次运行,结果是不是比我们预想得还糟? \n\n```\nstarting....\nduration = 8078753353\n```\n\n通过对比可以看出，第二个花的时间是第一个的10倍还多。从上节我们可以知道在加载longs\\[i][j]时, longs\\[i][j+1]很可能也会被加载至cache中, 所以立即访问longs\\[i][j+1]将会命中L1 Cache, 而如果你访问longs\\[i+1][j]情况就不一样了, 这时候很可能会产生 cache miss导致效率低下. \n\n以上我只是示例了在L1 Cache满了之后才会发生的cache miss. 其实cache miss的原因有下面三种: \n\n1. 第一次访问数据, 在cache中根本不存在这条数据, 所以cache miss, 可以通过prefetch解决. \n2. cache冲突, 需要通过补齐来解决. \n3. 就是我示例的这种, cache满, 一般情况下我们需要减少操作的数据大小, 尽量按数据的物理顺序访问数据\n\n## 四、伪共享\n\n在文章开头提到过，缓存系统中是以缓存行（cache line）为单位存储的。缓存行通常是 64 字节（译注：本文基于 64 字节，其他长度的如 32 字节等不适本文讨论的重点），并且它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。所以，如果你访问一个 long 数组，当数组中的一个值被加载到缓存中，它会额外加载另外 7 个，以致你能非常快地遍历这个数组。事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构。而如果你在数据结构中的项在内存中不是彼此相邻的（如链表），你将得不到免费缓存加载所带来的优势，并且在这些数据结构中的每一个项都可能会出现缓存未命中。\n\n如果存在这样的场景，有多个线程操作不同的成员变量，但是相同的缓存行，这个时候会发生什么？。没错，伪共享（False Sharing）问题就发生了！有张 Disruptor 项目的经典示例图，如下：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202002573-736704844.png)\n\n上图中，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送 RFO 消息，占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。\n\n表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。\n\n## *五、遭遇伪共享*\n\n好的，那么接下来我们就用 code 来进行实验和佐证。\n\n```\npublic class FalseShareTest implements Runnable {\n    public static int NUM_THREADS = 4;\n    public final static long ITERATIONS = 500L * 1000L * 1000L;\n    private final int arrayIndex;\n    private static VolatileLong[] longs;\n    public static long SUM_TIME = 0l;\n    public FalseShareTest(final int arrayIndex) {\n        this.arrayIndex = arrayIndex;\n    }\n    public static void main(final String[] args) throws Exception {\n        Thread.sleep(10000);\n        for(int j=0; j<10; j++){\n            System.out.println(j);\n            if (args.length == 1) {\n                NUM_THREADS = Integer.parseInt(args[0]);\n            }\n            longs = new VolatileLong[NUM_THREADS];\n            for (int i = 0; i < longs.length; i++) {\n                longs[i] = new VolatileLong();\n            }\n            final long start = System.nanoTime();\n            runTest();\n            final long end = System.nanoTime();\n            SUM_TIME += end - start;\n        }\n        System.out.println(\"平均耗时：\"+SUM_TIME/10);\n    }\n    private static void runTest() throws InterruptedException {\n        Thread[] threads = new Thread[NUM_THREADS];\n        for (int i = 0; i < threads.length; i++) {\n            threads[i] = new Thread(new FalseShareTest(i));\n        }\n        for (Thread t : threads) {\n            t.start();\n        }\n        for (Thread t : threads) {\n            t.join();\n        }\n    }\n    public void run() {\n        long i = ITERATIONS + 1;\n        while (0 != --i) {\n            longs[arrayIndex].value = i;\n        }\n    }\n    public final static class VolatileLong {\n        public volatile long value = 0L;\n        public long p1, p2, p3, p4, p5, p6;     //屏蔽此行\n    }\n}\n```\n\n上述代码的逻辑很简单，就是四个线程修改一数组不同元素的内容。元素的类型是 VolatileLong，只有一个长整型成员 value 和 6 个没用到的长整型成员。value 设为 volatile 是为了让 value 的修改对所有线程都可见。程序分两种情况执行，第一种情况为不屏蔽倒数第三行（见”屏蔽此行”字样），第二种情况为屏蔽倒数第三行。为了”保证”数据的相对可靠性，程序取 10 次执行的平均时间。执行情况如下（执行环境：32位 windows，四核，8GB 内存）：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202253714-555001087.png)         ![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202308245-492044780.png)\n\n（不屏蔽）                                                          （屏蔽）\n\n两个逻辑一模一样的程序，前者的耗时大概是后者的 2.5 倍，这太不可思议了！那么这个时候，我们再用伪共享（False Sharing）的理论来分析一下。前者 longs 数组的 4 个元素，由于 VolatileLong 只有 1 个长整型成员，所以整个数组都将被加载至同一缓存行，但有4个线程同时操作这条缓存行，于是伪共享就悄悄地发生了。\n\n基于此，我们有理由相信，在一定线程数量范围内（注意思考：为什么强调是一定线程数量范围内），随着线程数量的增加，伪共享发生的频率也越大，直观体现就是执行时间越长。为了证实这个观点，本人在同样的机器上分别用单线程、2、4、8个线程，对有填充和无填充两种情况进行测试。执行场景是取 10 次执行的平均时间，结果如下所示：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202449620-46958750.png)\n\n## 六、如何避免伪共享？**\n\n> 其中一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可。\n\n那么该如何做到呢？其实在我们注释的那行代码中就有答案，那就是缓存行填充（Padding） 。现在分析上面的例子，我们知道一条缓存行有 64 字节，而 Java 程序的对象头固定占 8 字节(32位系统)或 12 字节( 64 位系统默认开启压缩, 不开压缩为 16 字节)，所以我们只需要填 6 个无用的长整型补上6*8=48字节，让不同的 VolatileLong 对象处于不同的缓存行，就避免了伪共享( 64 位系统超过缓存行的 64 字节也无所谓，只要保证不同线程不操作同一缓存行就可以)。\n\n伪共享在多核编程中很容易发生，而且非常隐蔽。例如，在 JDK 的 LinkedBlockingQueue 中，存在指向队列头的引用 head 和指向队列尾的引用 tail 。而这种队列经常在异步编程中使有，这两个引用的值经常的被不同的线程修改，但它们却很可能在同一个缓存行，于是就产生了伪共享。线程越多，核越多，对性能产生的负面效果就越大。\n\n由于某些 Java 编译器的优化策略，那些没有使用到的补齐数据可能会在编译期间被优化掉，我们可以在程序中加入一些代码防止被编译优化。如下：\n\n```\npublic static long preventFromOptimization(VolatileLong v) {  \n        return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;  \n}\n```\n\n> 另外一种技术是使用编译指示，来强制使每一个变量对齐。\n\n下面的代码显式了编译器使用__declspec( align(n) ) 此处 n=64，按照 cache line 边界对齐。\n\n```\n__declspec (align(64)) int thread1_global_variable;\n__declspec (align(64)) int thread2_global_variable;\n```\n\n当使用数组时，在 cache line 尾部填充 padding 来保证数据元素在 cache line 边界开始。如果不能够保证数组按照 cache line 边界对齐，填充数据结构【数组元素】使之是 cache line 大小的两倍。下面的代码显式了填充数据结构使之按照 cache line 对齐。并且通过 __declspec( align(n) ) 语句来保证数组也是对齐的。如果数组是动态分配的，你可以增加分配的大小，并调整指针来对其到 cache line 边界。\n\n```\nstruct ThreadParams\n{\n    // For the following 4 variables: 4*4 = 16 bytes\n    unsigned long thread_id;\n    unsigned long v; // Frequent read/write access variable\n    unsigned long start;\n    unsigned long end;\n    // expand to 64 bytes to avoid false-sharing \n    // (4 unsigned long variables + 12 padding)*4 = 64\n    int padding[12];\n};\n```\n\n除此之外，在网上还有很多对伪共享的研究，提出了一些基于数据融合的方案，有兴趣的同学可以了解下。\n\n## 七、对于伪共享，我们在实际开发中该怎么做？**\n\n通过上面大篇幅的介绍，我们已经知道伪共享的对程序的影响。那么，在实际的生产开发过程中，我们一定要通过缓存行填充去解决掉潜在的伪共享问题吗？\n\n其实并不一定。\n\n首先就是多次强调的，伪共享是很隐蔽的，我们暂时无法从系统层面上通过工具来探测伪共享事件。其次，不同类型的计算机具有不同的微架构（如 32 位系统和 64 位系统的 java 对象所占自己数就不一样），如果设计到跨平台的设计，那就更难以把握了，一个确切的填充方案只适用于一个特定的操作系统。还有，缓存的资源是有限的，如果填充会浪费珍贵的 cache 资源，并不适合大范围应用。最后，目前主流的 Intel 微架构 CPU 的 L1 缓存，已能够达到 80% 以上的命中率。\n\n综上所述，并不是每个系统都适合花大量精力去解决潜在的伪共享问题。\n\n","slug":"伪缓存","published":1,"updated":"2019-01-04T01:48:59.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovqk00219q1uh2oiu2s0","content":"<h1 id=\"伪共享（false-sharing），并发编程无声的性能杀手\"><a href=\"#伪共享（false-sharing），并发编程无声的性能杀手\" class=\"headerlink\" title=\"伪共享（false sharing），并发编程无声的性能杀手\"></a>伪共享（false sharing），并发编程无声的性能杀手</h1><p>在并发编程过程中，我们大部分的焦点都放在如何控制共享变量的访问控制上（代码层面），但是很少人会关注系统硬件及 JVM 底层相关的影响因素。前段时间学习了一个牛X的高性能异步处理框架 Disruptor，它被誉为“最快的消息框架”，其 LMAX 架构能够在一个线程里每秒处理 6百万 订单！在讲到 Disruptor 为什么这么快时，接触到了一个概念——伪共享( false sharing )，其中提到：缓存行上的写竞争是运行在 SMP 系统中并行线程实现可伸缩性最重要的限制因素。由于从代码中很难看出是否会出现伪共享，有人将其描述成无声的性能杀手。</p>\n<p>本文仅针对目前所学进行合并整理，目前并无非常深入地研究和实践，希望对大家从零开始理解伪共享提供一些帮助。</p>\n<blockquote>\n<p>伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>\n</blockquote>\n<p>下面我们就来详细剖析伪共享产生的前因后果。首先，我们要了解什么是缓存系统。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h3><h2 id=\"一、CPU-缓存\"><a href=\"#一、CPU-缓存\" class=\"headerlink\" title=\"一、CPU 缓存\"></a><strong>一、CPU 缓存</strong></h2><p>CPU 缓存的百度百科定义为：</p>\n<p>CPU 缓存（Cache Memory）是位于 CPU 与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。<br>高速缓存的出现主要是为了解决 CPU 运算速度与内存读写速度不匹配的矛盾，因为 CPU 运算速度要比内存读写速度快很多，这样会使 CPU 花费很长时间等待数据到来或把数据写入内存。<br>在缓存中的数据是内存中的一小部分，但这一小部分是短时间内 CPU 即将访问的，当 CPU 调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。</p>\n<p>CPU 和主内存之间有好几层缓存，因为即使直接访问主内存也是非常慢的。如果你正在多次对一块数据做相同的运算，那么在执行运算的时候把它加载到离 CPU 很近的地方就有意义了。</p>\n<p>按照数据读取顺序和与 CPU 结合的紧密程度，CPU 缓存可以分为一级缓存，二级缓存，部分高端 CPU 还具有三级缓存。每一级缓存中所储存的全部数据都是下一级缓存的一部分，越靠近 CPU 的缓存越快也越小。所以 L1 缓存很小但很快(译注：L1 表示一级缓存)，并且紧靠着在使用它的 CPU 内核。L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。拥有三级缓存的的 CPU，到三级缓存时能够达到 95% 的命中率，只有不到 5% 的数据需要从内存中查询。</p>\n<p>多核机器的存储结构如下图所示：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201221667-1059026925.png\" alt=\"img\"></p>\n<p>当 CPU 执行运算的时候，它先去 L1 查找所需的数据，再去 L2，然后是 L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要确保数据在 L1 缓存中。</p>\n<p>Martin Thompson 给出了一些缓存未命中的消耗数据，如下所示：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201305464-895015043.png\" alt=\"img\"></p>\n<h2 id=\"二、MESI-协议及-RFO-请求\"><a href=\"#二、MESI-协议及-RFO-请求\" class=\"headerlink\" title=\"二、MESI 协议及 RFO 请求\"></a><strong>二、MESI 协议及 RFO 请求</strong></h2><p>从上一节中我们知道，每个核都有自己私有的 L1,、L2 缓存。那么多线程编程时, 另外一个核的线程想要访问当前核内 L1、L2 缓存行的数据, 该怎么办呢？</p>\n<p>有人说可以通过第 2 个核直接访问第 1 个核的缓存行，这是当然是可行的，但这种方法不够快。跨核访问需要通过 Memory Controller（内存控制器，是计算机系统内部控制内存并且通过内存控制器使内存与 CPU 之间交换数据的重要组成部分），典型的情况是第 2 个核经常访问第 1 个核的这条数据，那么每次都有跨核的消耗.。更糟的情况是，有可能第 2 个核与第 1 个核不在一个插槽内，况且 Memory Controller 的总线带宽是有限的，扛不住这么多数据传输。所以，CPU 设计者们更偏向于另一种办法： 如果第 2 个核需要这份数据，由第 1 个核直接把数据内容发过去，数据只需要传一次。</p>\n<p>那么什么时候会发生缓存行的传输呢？答案很简单：当一个核需要读取另外一个核的脏缓存行时发生。但是前者怎么判断后者的缓存行已经被弄脏(写)了呢？</p>\n<p>下面将详细地解答以上问题. 首先我们需要谈到一个协议—— MESI 协议。现在主流的处理器都是用它来保证缓存的相干性和内存的相干性。M、E、S 和 I 代表使用 MESI 协议时缓存行所处的四个状态：</p>\n<ul>\n<li>M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；</li>\n<li>E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；</li>\n<li>S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；</li>\n<li>I（无效，Invalid）：缓存行失效, 不能使用。</li>\n</ul>\n<p>下面说明这四个状态是如何转换的：</p>\n<p>初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。</p>\n<p>本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。</p>\n<p>本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）</p>\n<p>远程读（Remote Read）：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。</p>\n<p>远程写（Remote Write）：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。</p>\n<p>状态转换由下图做个补充：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201649808-555029301.png\" alt=\"img\"></p>\n<p>我们从上节知道，写操作的代价很高，特别当需要发送 RFO 消息时。我们编写程序时，什么时候会发生 RFO 请求呢？有以下两种：</p>\n<ol>\n<li>线程的工作从一个处理器移到另一个处理器, 它操作的所有缓存行都需要移到新的处理器上。此后如果再写缓存行，则此缓存行在不同核上有多个拷贝，需要发送 RFO 请求了。</li>\n<li>两个不同的处理器确实都需要操作相同的缓存行</li>\n</ol>\n<p>接下来，我们要了解什么是缓存行。</p>\n<h2 id=\"缓存行\"><a href=\"#缓存行\" class=\"headerlink\" title=\"缓存行\"></a><strong>缓存行</strong></h2><p>为了高效地存取缓存, 不是简单随意地将单条数据写入缓存的.  缓存是由缓存行组成的, 典型的一行是64字节. 读者可以通过下面的shell命令,查看cherency_line_size就知道知道机器的缓存行是多大. </p>\n<pre><code> cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size   \n 64  \n</code></pre><p>CPU存取缓存都是按行为最小单位操作的. 在这儿我将不提及缓存的associativity问题, 将问题简化一些. 一个Java long型占8字节, 所以从一条缓存行上你可以获取到8个long型变量. 所以如果你访问一个long型数组, 当有一个long被加载到cache中, 你将无消耗地加载了另外7个. 所以你可以非常快地遍历数组.</p>\n<p>下面是利用缓存行来进行的对比实验代码</p>\n<pre><code class=\"java\">public class L1CacheMiss {  \n    private static final int RUNS = 10;  \n    private static final int DIMENSION_1 = 1024 * 1024;  \n    private static final int DIMENSION_2 = 62;  \n\n    private static long[][] longs;  \n\n    public static void main(String[] args) throws Exception {  \n        Thread.sleep(10000);  \n        longs = new long[DIMENSION_1][];  \n        for (int i = 0; i &lt; DIMENSION_1; i++) {  \n            longs[i] = new long[DIMENSION_2];  \n            for (int j = 0; j &lt; DIMENSION_2; j++) {  \n                longs[i][j] = 0L;  \n            }  \n        }  \n        System.out.println(&quot;starting....&quot;);  \n\n        final long start = System.nanoTime();  \n        long sum = 0L;  \n        for (int r = 0; r &lt; RUNS; r++) {  \n//          for (int j = 0; j &lt; DIMENSION_2; j++) {  \n//              for (int i = 0; i &lt; DIMENSION_1; i++) {  \n//                  sum += longs[i][j];  \n//              }  \n//          }  \n\n            for (int i = 0; i &lt; DIMENSION_1; i++) {  \n                for (int j = 0; j &lt; DIMENSION_2; j++) {  \n                    sum += longs[i][j];  \n                }  \n            }  \n        }  \n        System.out.println(&quot;duration = &quot; + (System.nanoTime() - start));  \n    }  \n}  \n</code></pre>\n<p>编译运行得到的结果如下</p>\n<pre><code>    starting....\n    duration =  850623099\n</code></pre><p>然后我们将22-26行的注释取消, 将28-32行注释, 编译后再次运行,结果是不是比我们预想得还糟? </p>\n<pre><code>starting....\nduration = 8078753353\n</code></pre><p>通过对比可以看出，第二个花的时间是第一个的10倍还多。从上节我们可以知道在加载longs[i][j]时, longs[i][j+1]很可能也会被加载至cache中, 所以立即访问longs[i][j+1]将会命中L1 Cache, 而如果你访问longs[i+1][j]情况就不一样了, 这时候很可能会产生 cache miss导致效率低下. </p>\n<p>以上我只是示例了在L1 Cache满了之后才会发生的cache miss. 其实cache miss的原因有下面三种: </p>\n<ol>\n<li>第一次访问数据, 在cache中根本不存在这条数据, 所以cache miss, 可以通过prefetch解决. </li>\n<li>cache冲突, 需要通过补齐来解决. </li>\n<li>就是我示例的这种, cache满, 一般情况下我们需要减少操作的数据大小, 尽量按数据的物理顺序访问数据</li>\n</ol>\n<h2 id=\"四、伪共享\"><a href=\"#四、伪共享\" class=\"headerlink\" title=\"四、伪共享\"></a>四、伪共享</h2><p>在文章开头提到过，缓存系统中是以缓存行（cache line）为单位存储的。缓存行通常是 64 字节（译注：本文基于 64 字节，其他长度的如 32 字节等不适本文讨论的重点），并且它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。所以，如果你访问一个 long 数组，当数组中的一个值被加载到缓存中，它会额外加载另外 7 个，以致你能非常快地遍历这个数组。事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构。而如果你在数据结构中的项在内存中不是彼此相邻的（如链表），你将得不到免费缓存加载所带来的优势，并且在这些数据结构中的每一个项都可能会出现缓存未命中。</p>\n<p>如果存在这样的场景，有多个线程操作不同的成员变量，但是相同的缓存行，这个时候会发生什么？。没错，伪共享（False Sharing）问题就发生了！有张 Disruptor 项目的经典示例图，如下：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202002573-736704844.png\" alt=\"img\"></p>\n<p>上图中，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送 RFO 消息，占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。</p>\n<p>表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。</p>\n<h2 id=\"五、遭遇伪共享\"><a href=\"#五、遭遇伪共享\" class=\"headerlink\" title=\"五、遭遇伪共享\"></a><em>五、遭遇伪共享</em></h2><p>好的，那么接下来我们就用 code 来进行实验和佐证。</p>\n<pre><code>public class FalseShareTest implements Runnable {\n    public static int NUM_THREADS = 4;\n    public final static long ITERATIONS = 500L * 1000L * 1000L;\n    private final int arrayIndex;\n    private static VolatileLong[] longs;\n    public static long SUM_TIME = 0l;\n    public FalseShareTest(final int arrayIndex) {\n        this.arrayIndex = arrayIndex;\n    }\n    public static void main(final String[] args) throws Exception {\n        Thread.sleep(10000);\n        for(int j=0; j&lt;10; j++){\n            System.out.println(j);\n            if (args.length == 1) {\n                NUM_THREADS = Integer.parseInt(args[0]);\n            }\n            longs = new VolatileLong[NUM_THREADS];\n            for (int i = 0; i &lt; longs.length; i++) {\n                longs[i] = new VolatileLong();\n            }\n            final long start = System.nanoTime();\n            runTest();\n            final long end = System.nanoTime();\n            SUM_TIME += end - start;\n        }\n        System.out.println(&quot;平均耗时：&quot;+SUM_TIME/10);\n    }\n    private static void runTest() throws InterruptedException {\n        Thread[] threads = new Thread[NUM_THREADS];\n        for (int i = 0; i &lt; threads.length; i++) {\n            threads[i] = new Thread(new FalseShareTest(i));\n        }\n        for (Thread t : threads) {\n            t.start();\n        }\n        for (Thread t : threads) {\n            t.join();\n        }\n    }\n    public void run() {\n        long i = ITERATIONS + 1;\n        while (0 != --i) {\n            longs[arrayIndex].value = i;\n        }\n    }\n    public final static class VolatileLong {\n        public volatile long value = 0L;\n        public long p1, p2, p3, p4, p5, p6;     //屏蔽此行\n    }\n}\n</code></pre><p>上述代码的逻辑很简单，就是四个线程修改一数组不同元素的内容。元素的类型是 VolatileLong，只有一个长整型成员 value 和 6 个没用到的长整型成员。value 设为 volatile 是为了让 value 的修改对所有线程都可见。程序分两种情况执行，第一种情况为不屏蔽倒数第三行（见”屏蔽此行”字样），第二种情况为屏蔽倒数第三行。为了”保证”数据的相对可靠性，程序取 10 次执行的平均时间。执行情况如下（执行环境：32位 windows，四核，8GB 内存）：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202253714-555001087.png\" alt=\"img\">         <img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202308245-492044780.png\" alt=\"img\"></p>\n<p>（不屏蔽）                                                          （屏蔽）</p>\n<p>两个逻辑一模一样的程序，前者的耗时大概是后者的 2.5 倍，这太不可思议了！那么这个时候，我们再用伪共享（False Sharing）的理论来分析一下。前者 longs 数组的 4 个元素，由于 VolatileLong 只有 1 个长整型成员，所以整个数组都将被加载至同一缓存行，但有4个线程同时操作这条缓存行，于是伪共享就悄悄地发生了。</p>\n<p>基于此，我们有理由相信，在一定线程数量范围内（注意思考：为什么强调是一定线程数量范围内），随着线程数量的增加，伪共享发生的频率也越大，直观体现就是执行时间越长。为了证实这个观点，本人在同样的机器上分别用单线程、2、4、8个线程，对有填充和无填充两种情况进行测试。执行场景是取 10 次执行的平均时间，结果如下所示：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202449620-46958750.png\" alt=\"img\"></p>\n<h2 id=\"六、如何避免伪共享？\"><a href=\"#六、如何避免伪共享？\" class=\"headerlink\" title=\"六、如何避免伪共享？**\"></a>六、如何避免伪共享？**</h2><blockquote>\n<p>其中一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可。</p>\n</blockquote>\n<p>那么该如何做到呢？其实在我们注释的那行代码中就有答案，那就是缓存行填充（Padding） 。现在分析上面的例子，我们知道一条缓存行有 64 字节，而 Java 程序的对象头固定占 8 字节(32位系统)或 12 字节( 64 位系统默认开启压缩, 不开压缩为 16 字节)，所以我们只需要填 6 个无用的长整型补上6*8=48字节，让不同的 VolatileLong 对象处于不同的缓存行，就避免了伪共享( 64 位系统超过缓存行的 64 字节也无所谓，只要保证不同线程不操作同一缓存行就可以)。</p>\n<p>伪共享在多核编程中很容易发生，而且非常隐蔽。例如，在 JDK 的 LinkedBlockingQueue 中，存在指向队列头的引用 head 和指向队列尾的引用 tail 。而这种队列经常在异步编程中使有，这两个引用的值经常的被不同的线程修改，但它们却很可能在同一个缓存行，于是就产生了伪共享。线程越多，核越多，对性能产生的负面效果就越大。</p>\n<p>由于某些 Java 编译器的优化策略，那些没有使用到的补齐数据可能会在编译期间被优化掉，我们可以在程序中加入一些代码防止被编译优化。如下：</p>\n<pre><code>public static long preventFromOptimization(VolatileLong v) {  \n        return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;  \n}\n</code></pre><blockquote>\n<p>另外一种技术是使用编译指示，来强制使每一个变量对齐。</p>\n</blockquote>\n<p>下面的代码显式了编译器使用__declspec( align(n) ) 此处 n=64，按照 cache line 边界对齐。</p>\n<pre><code>__declspec (align(64)) int thread1_global_variable;\n__declspec (align(64)) int thread2_global_variable;\n</code></pre><p>当使用数组时，在 cache line 尾部填充 padding 来保证数据元素在 cache line 边界开始。如果不能够保证数组按照 cache line 边界对齐，填充数据结构【数组元素】使之是 cache line 大小的两倍。下面的代码显式了填充数据结构使之按照 cache line 对齐。并且通过 __declspec( align(n) ) 语句来保证数组也是对齐的。如果数组是动态分配的，你可以增加分配的大小，并调整指针来对其到 cache line 边界。</p>\n<pre><code>struct ThreadParams\n{\n    // For the following 4 variables: 4*4 = 16 bytes\n    unsigned long thread_id;\n    unsigned long v; // Frequent read/write access variable\n    unsigned long start;\n    unsigned long end;\n    // expand to 64 bytes to avoid false-sharing \n    // (4 unsigned long variables + 12 padding)*4 = 64\n    int padding[12];\n};\n</code></pre><p>除此之外，在网上还有很多对伪共享的研究，提出了一些基于数据融合的方案，有兴趣的同学可以了解下。</p>\n<h2 id=\"七、对于伪共享，我们在实际开发中该怎么做？\"><a href=\"#七、对于伪共享，我们在实际开发中该怎么做？\" class=\"headerlink\" title=\"七、对于伪共享，我们在实际开发中该怎么做？**\"></a>七、对于伪共享，我们在实际开发中该怎么做？**</h2><p>通过上面大篇幅的介绍，我们已经知道伪共享的对程序的影响。那么，在实际的生产开发过程中，我们一定要通过缓存行填充去解决掉潜在的伪共享问题吗？</p>\n<p>其实并不一定。</p>\n<p>首先就是多次强调的，伪共享是很隐蔽的，我们暂时无法从系统层面上通过工具来探测伪共享事件。其次，不同类型的计算机具有不同的微架构（如 32 位系统和 64 位系统的 java 对象所占自己数就不一样），如果设计到跨平台的设计，那就更难以把握了，一个确切的填充方案只适用于一个特定的操作系统。还有，缓存的资源是有限的，如果填充会浪费珍贵的 cache 资源，并不适合大范围应用。最后，目前主流的 Intel 微架构 CPU 的 L1 缓存，已能够达到 80% 以上的命中率。</p>\n<p>综上所述，并不是每个系统都适合花大量精力去解决潜在的伪共享问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"伪共享（false-sharing），并发编程无声的性能杀手\"><a href=\"#伪共享（false-sharing），并发编程无声的性能杀手\" class=\"headerlink\" title=\"伪共享（false sharing），并发编程无声的性能杀手\"></a>伪共享（false sharing），并发编程无声的性能杀手</h1><p>在并发编程过程中，我们大部分的焦点都放在如何控制共享变量的访问控制上（代码层面），但是很少人会关注系统硬件及 JVM 底层相关的影响因素。前段时间学习了一个牛X的高性能异步处理框架 Disruptor，它被誉为“最快的消息框架”，其 LMAX 架构能够在一个线程里每秒处理 6百万 订单！在讲到 Disruptor 为什么这么快时，接触到了一个概念——伪共享( false sharing )，其中提到：缓存行上的写竞争是运行在 SMP 系统中并行线程实现可伸缩性最重要的限制因素。由于从代码中很难看出是否会出现伪共享，有人将其描述成无声的性能杀手。</p>\n<p>本文仅针对目前所学进行合并整理，目前并无非常深入地研究和实践，希望对大家从零开始理解伪共享提供一些帮助。</p>\n<blockquote>\n<p>伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>\n</blockquote>\n<p>下面我们就来详细剖析伪共享产生的前因后果。首先，我们要了解什么是缓存系统。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h3><h2 id=\"一、CPU-缓存\"><a href=\"#一、CPU-缓存\" class=\"headerlink\" title=\"一、CPU 缓存\"></a><strong>一、CPU 缓存</strong></h2><p>CPU 缓存的百度百科定义为：</p>\n<p>CPU 缓存（Cache Memory）是位于 CPU 与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。<br>高速缓存的出现主要是为了解决 CPU 运算速度与内存读写速度不匹配的矛盾，因为 CPU 运算速度要比内存读写速度快很多，这样会使 CPU 花费很长时间等待数据到来或把数据写入内存。<br>在缓存中的数据是内存中的一小部分，但这一小部分是短时间内 CPU 即将访问的，当 CPU 调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。</p>\n<p>CPU 和主内存之间有好几层缓存，因为即使直接访问主内存也是非常慢的。如果你正在多次对一块数据做相同的运算，那么在执行运算的时候把它加载到离 CPU 很近的地方就有意义了。</p>\n<p>按照数据读取顺序和与 CPU 结合的紧密程度，CPU 缓存可以分为一级缓存，二级缓存，部分高端 CPU 还具有三级缓存。每一级缓存中所储存的全部数据都是下一级缓存的一部分，越靠近 CPU 的缓存越快也越小。所以 L1 缓存很小但很快(译注：L1 表示一级缓存)，并且紧靠着在使用它的 CPU 内核。L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。拥有三级缓存的的 CPU，到三级缓存时能够达到 95% 的命中率，只有不到 5% 的数据需要从内存中查询。</p>\n<p>多核机器的存储结构如下图所示：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201221667-1059026925.png\" alt=\"img\"></p>\n<p>当 CPU 执行运算的时候，它先去 L1 查找所需的数据，再去 L2，然后是 L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要确保数据在 L1 缓存中。</p>\n<p>Martin Thompson 给出了一些缓存未命中的消耗数据，如下所示：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201305464-895015043.png\" alt=\"img\"></p>\n<h2 id=\"二、MESI-协议及-RFO-请求\"><a href=\"#二、MESI-协议及-RFO-请求\" class=\"headerlink\" title=\"二、MESI 协议及 RFO 请求\"></a><strong>二、MESI 协议及 RFO 请求</strong></h2><p>从上一节中我们知道，每个核都有自己私有的 L1,、L2 缓存。那么多线程编程时, 另外一个核的线程想要访问当前核内 L1、L2 缓存行的数据, 该怎么办呢？</p>\n<p>有人说可以通过第 2 个核直接访问第 1 个核的缓存行，这是当然是可行的，但这种方法不够快。跨核访问需要通过 Memory Controller（内存控制器，是计算机系统内部控制内存并且通过内存控制器使内存与 CPU 之间交换数据的重要组成部分），典型的情况是第 2 个核经常访问第 1 个核的这条数据，那么每次都有跨核的消耗.。更糟的情况是，有可能第 2 个核与第 1 个核不在一个插槽内，况且 Memory Controller 的总线带宽是有限的，扛不住这么多数据传输。所以，CPU 设计者们更偏向于另一种办法： 如果第 2 个核需要这份数据，由第 1 个核直接把数据内容发过去，数据只需要传一次。</p>\n<p>那么什么时候会发生缓存行的传输呢？答案很简单：当一个核需要读取另外一个核的脏缓存行时发生。但是前者怎么判断后者的缓存行已经被弄脏(写)了呢？</p>\n<p>下面将详细地解答以上问题. 首先我们需要谈到一个协议—— MESI 协议。现在主流的处理器都是用它来保证缓存的相干性和内存的相干性。M、E、S 和 I 代表使用 MESI 协议时缓存行所处的四个状态：</p>\n<ul>\n<li>M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；</li>\n<li>E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；</li>\n<li>S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；</li>\n<li>I（无效，Invalid）：缓存行失效, 不能使用。</li>\n</ul>\n<p>下面说明这四个状态是如何转换的：</p>\n<p>初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。</p>\n<p>本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。</p>\n<p>本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）</p>\n<p>远程读（Remote Read）：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。</p>\n<p>远程写（Remote Write）：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。</p>\n<p>状态转换由下图做个补充：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201649808-555029301.png\" alt=\"img\"></p>\n<p>我们从上节知道，写操作的代价很高，特别当需要发送 RFO 消息时。我们编写程序时，什么时候会发生 RFO 请求呢？有以下两种：</p>\n<ol>\n<li>线程的工作从一个处理器移到另一个处理器, 它操作的所有缓存行都需要移到新的处理器上。此后如果再写缓存行，则此缓存行在不同核上有多个拷贝，需要发送 RFO 请求了。</li>\n<li>两个不同的处理器确实都需要操作相同的缓存行</li>\n</ol>\n<p>接下来，我们要了解什么是缓存行。</p>\n<h2 id=\"缓存行\"><a href=\"#缓存行\" class=\"headerlink\" title=\"缓存行\"></a><strong>缓存行</strong></h2><p>为了高效地存取缓存, 不是简单随意地将单条数据写入缓存的.  缓存是由缓存行组成的, 典型的一行是64字节. 读者可以通过下面的shell命令,查看cherency_line_size就知道知道机器的缓存行是多大. </p>\n<pre><code> cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size   \n 64  \n</code></pre><p>CPU存取缓存都是按行为最小单位操作的. 在这儿我将不提及缓存的associativity问题, 将问题简化一些. 一个Java long型占8字节, 所以从一条缓存行上你可以获取到8个long型变量. 所以如果你访问一个long型数组, 当有一个long被加载到cache中, 你将无消耗地加载了另外7个. 所以你可以非常快地遍历数组.</p>\n<p>下面是利用缓存行来进行的对比实验代码</p>\n<pre><code class=\"java\">public class L1CacheMiss {  \n    private static final int RUNS = 10;  \n    private static final int DIMENSION_1 = 1024 * 1024;  \n    private static final int DIMENSION_2 = 62;  \n\n    private static long[][] longs;  \n\n    public static void main(String[] args) throws Exception {  \n        Thread.sleep(10000);  \n        longs = new long[DIMENSION_1][];  \n        for (int i = 0; i &lt; DIMENSION_1; i++) {  \n            longs[i] = new long[DIMENSION_2];  \n            for (int j = 0; j &lt; DIMENSION_2; j++) {  \n                longs[i][j] = 0L;  \n            }  \n        }  \n        System.out.println(&quot;starting....&quot;);  \n\n        final long start = System.nanoTime();  \n        long sum = 0L;  \n        for (int r = 0; r &lt; RUNS; r++) {  \n//          for (int j = 0; j &lt; DIMENSION_2; j++) {  \n//              for (int i = 0; i &lt; DIMENSION_1; i++) {  \n//                  sum += longs[i][j];  \n//              }  \n//          }  \n\n            for (int i = 0; i &lt; DIMENSION_1; i++) {  \n                for (int j = 0; j &lt; DIMENSION_2; j++) {  \n                    sum += longs[i][j];  \n                }  \n            }  \n        }  \n        System.out.println(&quot;duration = &quot; + (System.nanoTime() - start));  \n    }  \n}  \n</code></pre>\n<p>编译运行得到的结果如下</p>\n<pre><code>    starting....\n    duration =  850623099\n</code></pre><p>然后我们将22-26行的注释取消, 将28-32行注释, 编译后再次运行,结果是不是比我们预想得还糟? </p>\n<pre><code>starting....\nduration = 8078753353\n</code></pre><p>通过对比可以看出，第二个花的时间是第一个的10倍还多。从上节我们可以知道在加载longs[i][j]时, longs[i][j+1]很可能也会被加载至cache中, 所以立即访问longs[i][j+1]将会命中L1 Cache, 而如果你访问longs[i+1][j]情况就不一样了, 这时候很可能会产生 cache miss导致效率低下. </p>\n<p>以上我只是示例了在L1 Cache满了之后才会发生的cache miss. 其实cache miss的原因有下面三种: </p>\n<ol>\n<li>第一次访问数据, 在cache中根本不存在这条数据, 所以cache miss, 可以通过prefetch解决. </li>\n<li>cache冲突, 需要通过补齐来解决. </li>\n<li>就是我示例的这种, cache满, 一般情况下我们需要减少操作的数据大小, 尽量按数据的物理顺序访问数据</li>\n</ol>\n<h2 id=\"四、伪共享\"><a href=\"#四、伪共享\" class=\"headerlink\" title=\"四、伪共享\"></a>四、伪共享</h2><p>在文章开头提到过，缓存系统中是以缓存行（cache line）为单位存储的。缓存行通常是 64 字节（译注：本文基于 64 字节，其他长度的如 32 字节等不适本文讨论的重点），并且它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。所以，如果你访问一个 long 数组，当数组中的一个值被加载到缓存中，它会额外加载另外 7 个，以致你能非常快地遍历这个数组。事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构。而如果你在数据结构中的项在内存中不是彼此相邻的（如链表），你将得不到免费缓存加载所带来的优势，并且在这些数据结构中的每一个项都可能会出现缓存未命中。</p>\n<p>如果存在这样的场景，有多个线程操作不同的成员变量，但是相同的缓存行，这个时候会发生什么？。没错，伪共享（False Sharing）问题就发生了！有张 Disruptor 项目的经典示例图，如下：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202002573-736704844.png\" alt=\"img\"></p>\n<p>上图中，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送 RFO 消息，占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。</p>\n<p>表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。</p>\n<h2 id=\"五、遭遇伪共享\"><a href=\"#五、遭遇伪共享\" class=\"headerlink\" title=\"五、遭遇伪共享\"></a><em>五、遭遇伪共享</em></h2><p>好的，那么接下来我们就用 code 来进行实验和佐证。</p>\n<pre><code>public class FalseShareTest implements Runnable {\n    public static int NUM_THREADS = 4;\n    public final static long ITERATIONS = 500L * 1000L * 1000L;\n    private final int arrayIndex;\n    private static VolatileLong[] longs;\n    public static long SUM_TIME = 0l;\n    public FalseShareTest(final int arrayIndex) {\n        this.arrayIndex = arrayIndex;\n    }\n    public static void main(final String[] args) throws Exception {\n        Thread.sleep(10000);\n        for(int j=0; j&lt;10; j++){\n            System.out.println(j);\n            if (args.length == 1) {\n                NUM_THREADS = Integer.parseInt(args[0]);\n            }\n            longs = new VolatileLong[NUM_THREADS];\n            for (int i = 0; i &lt; longs.length; i++) {\n                longs[i] = new VolatileLong();\n            }\n            final long start = System.nanoTime();\n            runTest();\n            final long end = System.nanoTime();\n            SUM_TIME += end - start;\n        }\n        System.out.println(&quot;平均耗时：&quot;+SUM_TIME/10);\n    }\n    private static void runTest() throws InterruptedException {\n        Thread[] threads = new Thread[NUM_THREADS];\n        for (int i = 0; i &lt; threads.length; i++) {\n            threads[i] = new Thread(new FalseShareTest(i));\n        }\n        for (Thread t : threads) {\n            t.start();\n        }\n        for (Thread t : threads) {\n            t.join();\n        }\n    }\n    public void run() {\n        long i = ITERATIONS + 1;\n        while (0 != --i) {\n            longs[arrayIndex].value = i;\n        }\n    }\n    public final static class VolatileLong {\n        public volatile long value = 0L;\n        public long p1, p2, p3, p4, p5, p6;     //屏蔽此行\n    }\n}\n</code></pre><p>上述代码的逻辑很简单，就是四个线程修改一数组不同元素的内容。元素的类型是 VolatileLong，只有一个长整型成员 value 和 6 个没用到的长整型成员。value 设为 volatile 是为了让 value 的修改对所有线程都可见。程序分两种情况执行，第一种情况为不屏蔽倒数第三行（见”屏蔽此行”字样），第二种情况为屏蔽倒数第三行。为了”保证”数据的相对可靠性，程序取 10 次执行的平均时间。执行情况如下（执行环境：32位 windows，四核，8GB 内存）：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202253714-555001087.png\" alt=\"img\">         <img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202308245-492044780.png\" alt=\"img\"></p>\n<p>（不屏蔽）                                                          （屏蔽）</p>\n<p>两个逻辑一模一样的程序，前者的耗时大概是后者的 2.5 倍，这太不可思议了！那么这个时候，我们再用伪共享（False Sharing）的理论来分析一下。前者 longs 数组的 4 个元素，由于 VolatileLong 只有 1 个长整型成员，所以整个数组都将被加载至同一缓存行，但有4个线程同时操作这条缓存行，于是伪共享就悄悄地发生了。</p>\n<p>基于此，我们有理由相信，在一定线程数量范围内（注意思考：为什么强调是一定线程数量范围内），随着线程数量的增加，伪共享发生的频率也越大，直观体现就是执行时间越长。为了证实这个观点，本人在同样的机器上分别用单线程、2、4、8个线程，对有填充和无填充两种情况进行测试。执行场景是取 10 次执行的平均时间，结果如下所示：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202449620-46958750.png\" alt=\"img\"></p>\n<h2 id=\"六、如何避免伪共享？\"><a href=\"#六、如何避免伪共享？\" class=\"headerlink\" title=\"六、如何避免伪共享？**\"></a>六、如何避免伪共享？**</h2><blockquote>\n<p>其中一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可。</p>\n</blockquote>\n<p>那么该如何做到呢？其实在我们注释的那行代码中就有答案，那就是缓存行填充（Padding） 。现在分析上面的例子，我们知道一条缓存行有 64 字节，而 Java 程序的对象头固定占 8 字节(32位系统)或 12 字节( 64 位系统默认开启压缩, 不开压缩为 16 字节)，所以我们只需要填 6 个无用的长整型补上6*8=48字节，让不同的 VolatileLong 对象处于不同的缓存行，就避免了伪共享( 64 位系统超过缓存行的 64 字节也无所谓，只要保证不同线程不操作同一缓存行就可以)。</p>\n<p>伪共享在多核编程中很容易发生，而且非常隐蔽。例如，在 JDK 的 LinkedBlockingQueue 中，存在指向队列头的引用 head 和指向队列尾的引用 tail 。而这种队列经常在异步编程中使有，这两个引用的值经常的被不同的线程修改，但它们却很可能在同一个缓存行，于是就产生了伪共享。线程越多，核越多，对性能产生的负面效果就越大。</p>\n<p>由于某些 Java 编译器的优化策略，那些没有使用到的补齐数据可能会在编译期间被优化掉，我们可以在程序中加入一些代码防止被编译优化。如下：</p>\n<pre><code>public static long preventFromOptimization(VolatileLong v) {  \n        return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;  \n}\n</code></pre><blockquote>\n<p>另外一种技术是使用编译指示，来强制使每一个变量对齐。</p>\n</blockquote>\n<p>下面的代码显式了编译器使用__declspec( align(n) ) 此处 n=64，按照 cache line 边界对齐。</p>\n<pre><code>__declspec (align(64)) int thread1_global_variable;\n__declspec (align(64)) int thread2_global_variable;\n</code></pre><p>当使用数组时，在 cache line 尾部填充 padding 来保证数据元素在 cache line 边界开始。如果不能够保证数组按照 cache line 边界对齐，填充数据结构【数组元素】使之是 cache line 大小的两倍。下面的代码显式了填充数据结构使之按照 cache line 对齐。并且通过 __declspec( align(n) ) 语句来保证数组也是对齐的。如果数组是动态分配的，你可以增加分配的大小，并调整指针来对其到 cache line 边界。</p>\n<pre><code>struct ThreadParams\n{\n    // For the following 4 variables: 4*4 = 16 bytes\n    unsigned long thread_id;\n    unsigned long v; // Frequent read/write access variable\n    unsigned long start;\n    unsigned long end;\n    // expand to 64 bytes to avoid false-sharing \n    // (4 unsigned long variables + 12 padding)*4 = 64\n    int padding[12];\n};\n</code></pre><p>除此之外，在网上还有很多对伪共享的研究，提出了一些基于数据融合的方案，有兴趣的同学可以了解下。</p>\n<h2 id=\"七、对于伪共享，我们在实际开发中该怎么做？\"><a href=\"#七、对于伪共享，我们在实际开发中该怎么做？\" class=\"headerlink\" title=\"七、对于伪共享，我们在实际开发中该怎么做？**\"></a>七、对于伪共享，我们在实际开发中该怎么做？**</h2><p>通过上面大篇幅的介绍，我们已经知道伪共享的对程序的影响。那么，在实际的生产开发过程中，我们一定要通过缓存行填充去解决掉潜在的伪共享问题吗？</p>\n<p>其实并不一定。</p>\n<p>首先就是多次强调的，伪共享是很隐蔽的，我们暂时无法从系统层面上通过工具来探测伪共享事件。其次，不同类型的计算机具有不同的微架构（如 32 位系统和 64 位系统的 java 对象所占自己数就不一样），如果设计到跨平台的设计，那就更难以把握了，一个确切的填充方案只适用于一个特定的操作系统。还有，缓存的资源是有限的，如果填充会浪费珍贵的 cache 资源，并不适合大范围应用。最后，目前主流的 Intel 微架构 CPU 的 L1 缓存，已能够达到 80% 以上的命中率。</p>\n<p>综上所述，并不是每个系统都适合花大量精力去解决潜在的伪共享问题。</p>\n"},{"abbrlink":14,"title":"枚举","author":"zhangke","date":"2018-03-07T01:24:00.000Z","_content":"# 枚举\n\n### 概要 \n\n>本篇博客的内容如下\n>\n>1. 使用背景\n>2. 枚举定义和使用\n>3. 枚举的总结\n>4. 深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\n\n### 1.  使用背景\n\n>在java语言还没有引入枚举类型之前，表示枚举类型的常用模式是声明一组int常量。之前通常利用public final static 方法定义。下面是一个小案例，分别用1 表示春天 2 表示夏天 3 表示秋天 4 表示冬天\n>\n>```java\n>public class Season {\n>    public static final int SPRING = 1;\n>    public static final int SUMMER = 2;\n>    public static final int AUTUMN = 3;\n>    public static final int WINTER = 4;\n>}\n>```\n>\n>这种方式称作int枚举模式。但是这种模式有一些问题。通常我们写出的代码都会从以下三个方面来进行分析，安全性、易用性和可读性。首先我们考虑一下他的安全性。当然这种模式不是类型安全的。比如我们设计一个函数，要求传入春夏秋冬的某个值。但是使用int类型，我们无法保证传入的值为合法。代码如下所示\n>\n>```java\n>private String getChineseSeason(int season){\n>        StringBuffer result = new StringBuffer();\n>        switch(season){\n>            case Season.SPRING :\n>                result.append(\"春天\");\n>                break;\n>            case Season.SUMMER :\n>                result.append(\"夏天\");\n>                break;\n>            case Season.AUTUMN :\n>                result.append(\"秋天\");\n>                break;\n>            case Season.WINTER :\n>                result.append(\"冬天\");\n>                break;\n>            default :\n>                result.append(\"地球没有的季节\");\n>                break;\n>        }\n>        return result.toString();\n>    }\n>\n>    public void doSomething(){\n>        //这是正常的场景\n>        System.out.println(this.getChineseSeason(Season.SPRING));\n>        //这个却是不正常的场景，这就导致了类型不安全问题\n>        System.out.println(this.getChineseSeason(5));\n>    }\n>```\n>\n>程序`getChineseSeason(Season.SPRING)`是我们预期的使用方法。可`getChineseSeason(5)`显然就不是了，而且编译很通过，在运行时会出现什么情况，我们就不得而知了。这显然就不符合`Java`程序的类型安全。\n>\n>接下来我们考虑一下这种模式的可读性。使用枚举的大多数场合，我们都需要方便的到枚举类型的字符串表达式。如果将int枚举常量打印出来，我们所见到的就是一组数字，这是没什么太大的用处。我们可能会想到是一个String常量来代替int常量。虽然他为这些常量提供了可打印的字符串，但是他会导致性能问题，因为他依赖于字符串的比较操作，所以这种模式也是我们不期望的。从类型安全性和程序可读性俩方面考虑，int和String枚举模式的缺点就显露出来。幸运的是，从`Java1.5`发行版本开始，就提出了另一种可以替代的解决方案，可以避免`int`和`String`枚举模式的缺点，并提供了许多额外的好处。那就是枚举类型（`enum type`）。接下来的章节将介绍枚举类型的定义、特征、应用场景和优缺点。\n>\n>\n\n\n\n### 2. 枚举定义和使用\n\n>枚举类型(enum type)是指由一组固定的常量组成合法的类型。java中由关键字enum来定义一个枚举类型。下面就是java枚举类型的定义:\n>\n>```java\n>publi enum Season{\n>   SPRING, SUMMER, AUTUMN, WINER;\n>}\n>```\n>\n>枚举的用法主要由以下几种：\n>\n>1. 常量，就如上面定义那样使用\n>\n>2. switch\n>\n>   ```java\n>   enum Signal {  \n>       GREEN, YELLOW, RED  \n>   }  \n>   public class TrafficLight {  \n>       Signal color = Signal.RED;  \n>       public void change() {  \n>           switch (color) {  \n>           case RED:  \n>               color = Signal.GREEN;  \n>               break;  \n>           case YELLOW:  \n>               color = Signal.RED;  \n>               break;  \n>           case GREEN:  \n>               color = Signal.YELLOW;  \n>               break;  \n>           }  \n>       }  \n>   }  \n>   ```\n>\n>3. 向枚举中添加新的方法\n>\n>   ```java\n>   public enum Color {  \n>       RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n>       // 成员变量  \n>       private String name;  \n>       private int index;  \n>       // 构造方法  \n>       private Color(String name, int index) {  \n>           this.name = name;  \n>           this.index = index;  \n>       }  \n>       // 普通方法  \n>       public static String getName(int index) {  \n>           for (Color c : Color.values()) {  \n>               if (c.getIndex() == index) {  \n>                   return c.name;  \n>               }  \n>           }  \n>           return null;  \n>       }  \n>       // get set 方法  \n>       public String getName() {  \n>           return name;  \n>       }  \n>       public void setName(String name) {  \n>           this.name = name;  \n>       }  \n>       public int getIndex() {  \n>           return index;  \n>       }  \n>       public void setIndex(int index) {  \n>           this.index = index;  \n>       }  \n>   }  \n>   ```\n>\n>4.  覆盖枚举的方法\n>\n>   ```java\n>   public enum Color {  \n>       RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n>       // 成员变量  \n>       private String name;  \n>       private int index;  \n>       // 构造方法  \n>       private Color(String name, int index) {  \n>           this.name = name;  \n>           this.index = index;  \n>       }  \n>       //覆盖方法  \n>       @Override  \n>       public String toString() {  \n>           return this.index+\"_\"+this.name;  \n>       }  \n>   }  \n>   ```\n>\n>5. 实现接口\n>\n>   ```java\n>   public interface Behaviour {  \n>       void print();  \n>       String getInfo();  \n>   }  \n>   public enum Color implements Behaviour{  \n>       RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n>       // 成员变量  \n>       private String name;  \n>       private int index;  \n>       // 构造方法  \n>       private Color(String name, int index) {  \n>           this.name = name;  \n>           this.index = index;  \n>       }  \n>   //接口方法  \n>       @Override  \n>       public String getInfo() {  \n>           return this.name;  \n>       }  \n>       //接口方法  \n>       @Override  \n>       public void print() {  \n>           System.out.println(this.index+\":\"+this.name);  \n>       }  \n>   }  \n>   ```\n>\n>6. 使用接口组织枚举\n>\n>   ```\n>   public interface Food {  \n>       enum Coffee implements Food{  \n>           BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO  \n>       }  \n>       enum Dessert implements Food{  \n>           FRUIT, CAKE, GELATO  \n>       }  \n>   }\n>   ```\n>\n>7. 常量相关的方法\n>\n>   ```java\n>   public enum Constantmethod{\n>     DATE_TIME{\n>       String getInfo(){\n>         System.out.println(\"date_time\");\n>       }\n>     }\n>     CLASSPATH{\n>       String getInfo(){\n>         System.out.println(\"classpath\");\n>       }\n>     }\n>     //定义每个常量都要实现的方法\n>     abstract String getInfo();\n>   }\n>   ```\n>\n>基本使用\n>\n>```java\n>public enum Season {\n>    SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);\n>\n>    private int code;\n>    private Season(int code){\n>        this.code = code;\n>    }\n>\n>    public int getCode(){\n>        return code;\n>    }\n>}\n>public class UseSeason {\n>    /**\n>     * 将英文的季节转换成中文季节\n>     * @param season\n>     * @return\n>     */\n>    public String getChineseSeason(Season season){\n>        StringBuffer result = new StringBuffer();\n>        switch(season){\n>            case SPRING :\n>                result.append(\"[中文：春天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            case AUTUMN :\n>                result.append(\"[中文：秋天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            case SUMMER : \n>                result.append(\"[中文：夏天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            case WINTER :\n>                result.append(\"[中文：冬天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            default :\n>                result.append(\"地球没有的季节 \" + season.name());\n>                break;\n>        }\n>        return result.toString();\n>    }\n>\n>    public void doSomething(){\n>        for(Season s : Season.values()){\n>            System.out.println(getChineseSeason(s));//这是正常的场景\n>        }\n>        //System.out.println(getChineseSeason(5));\n>        //此处已经是编译不通过了，这就保证了类型安全\n>    }\n>\n>    public static void main(String[] arg){\n>        UseSeason useSeason = new UseSeason();\n>        useSeason.doSomething();\n>    }\n>}\n>```\n>\n>\n\n### 3. 枚举的使用总结\n\n>其实枚举的定义很像类的定义，只不过枚举有一些限制，你甚至可以在枚举里面写main方法，这也是可以运行通过的。不过枚举不能继承类，至于原因接下来的博客会说明，但是枚举可以实现接口，就像上面展示的用法一样。\n\n### 4.深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\n\n>#### 1. 枚举是如何保证线程安全\n>\n>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：\n>\n>```\n>public enum t {\n>    SPRING,SUMMER,AUTUMN,WINTER;\n>}\n>```\n>\n>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译（[Java的反编译](http://www.hollischuang.com/archives/58)）后代码内容如下：\n>\n>```\n>public final class T extends Enum\n>{\n>    private T(String s, int i)\n>    {\n>        super(s, i);\n>    }\n>    public static T[] values()\n>    {\n>        T at[];\n>        int i;\n>        T at1[];\n>        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);\n>        return at1;\n>    }\n>\n>    public static T valueOf(String s)\n>    {\n>        return (T)Enum.valueOf(demo/T, s);\n>    }\n>\n>    public static final T SPRING;\n>    public static final T SUMMER;\n>    public static final T AUTUMN;\n>    public static final T WINTER;\n>    private static final T ENUM$VALUES[];\n>    static\n>    {\n>        SPRING = new T(\"SPRING\", 0);\n>        SUMMER = new T(\"SUMMER\", 1);\n>        AUTUMN = new T(\"AUTUMN\", 2);\n>        WINTER = new T(\"WINTER\", 3);\n>        ENUM$VALUES = (new T[] {\n>            SPRING, SUMMER, AUTUMN, WINTER\n>        });\n>    }\n>}\n>```\n>\n>通过反编译后代码我们可以看到，`public final class T extends Enum`，说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。当我们使用`enmu`来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类,所以枚举类型不能被继承，我们看到这个类中有几个属性和方法。\n>\n>我们可以看到：\n>\n>```\n>        public static final T SPRING;\n>        public static final T SUMMER;\n>        public static final T AUTUMN;\n>        public static final T WINTER;\n>        private static final T ENUM$VALUES[];\n>        static\n>        {\n>            SPRING = new T(\"SPRING\", 0);\n>            SUMMER = new T(\"SUMMER\", 1);\n>            AUTUMN = new T(\"AUTUMN\", 2);\n>            WINTER = new T(\"WINTER\", 3);\n>            ENUM$VALUES = (new T[] {\n>                SPRING, SUMMER, AUTUMN, WINTER\n>            });\n>        }\n>```\n>\n>都是static类型的，因为static类型的属性会在类被加载之后被初始化，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，**创建一个enum类型是线程安全的**。\n>\n>### 为什么用枚举实现的单例是最好的方式\n>\n>在[[转+注\\]单例模式的七种写法](http://www.hollischuang.com/archives/205)中，我们看到一共有七种实现单例的方式，其中，**Effective Java**作者`Josh Bloch` 提倡使用枚举的方式，既然大神说这种方式好，那我们就要知道它为什么好？\n>\n>**1. 枚举写法简单**\n>\n>> 写法简单这个大家看看[[转+注\\]单例模式的七种写法]()里面的实现就知道区别了。\n>\n>```\n>public enum EasySingleton{\n>    INSTANCE;\n>}\n>```\n>\n>你可以通过`EasySingleton.INSTANCE`来访问。\n>\n>**2. 枚举自己处理序列化**\n>\n>> 我们知道，以前的所有的单例模式都有一个比较大的问题，就是一旦实现了Serializable接口之后，就不再是单例得了，因为，每次调用 readObject()方法返回的都是一个新创建出来的对象，有一种解决办法就是使用readResolve()方法来避免此事发生。但是，**为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定。**原文如下：\n>>\n>> > Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant’s name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant’s enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.\n>>\n>> 大概意思就是说，在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。 我们看一下这个`valueOf`方法：\n>\n>```\n>public static <T extends Enum<T>> T valueOf(Class<T> enumType,String name) {  \n>            T result = enumType.enumConstantDirectory().get(name);  \n>            if (result != null)  \n>                return result;  \n>            if (name == null)  \n>                throw new NullPointerException(\"Name is null\");  \n>            throw new IllegalArgumentException(  \n>                \"No enum const \" + enumType +\".\" + name);  \n>        }  \n>```\n>\n>从代码中可以看到，代码会尝试从调用`enumType`这个`Class`对象的`enumConstantDirectory()`方法返回的`map`中获取名字为`name`的枚举对象，如果不存在就会抛出异常。再进一步跟到`enumConstantDirectory()`方法，就会发现到最后会以反射的方式调用`enumType`这个类型的`values()`静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充`enumType`这个`Class`对象中的`enumConstantDirectory`属性。\n>\n>所以，**JVM对序列化有保证。**\n>\n>**3.枚举实例创建是thread-safe(线程安全的)**\n>\n>> 当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，**创建一个enum类型是线程安全的**。","source":"_posts/枚举初探.md","raw":"abbrlink: 14\ntitle: 枚举\ntags:\n  - java基础\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-03-07 09:24:00\n---\n# 枚举\n\n### 概要 \n\n>本篇博客的内容如下\n>\n>1. 使用背景\n>2. 枚举定义和使用\n>3. 枚举的总结\n>4. 深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\n\n### 1.  使用背景\n\n>在java语言还没有引入枚举类型之前，表示枚举类型的常用模式是声明一组int常量。之前通常利用public final static 方法定义。下面是一个小案例，分别用1 表示春天 2 表示夏天 3 表示秋天 4 表示冬天\n>\n>```java\n>public class Season {\n>    public static final int SPRING = 1;\n>    public static final int SUMMER = 2;\n>    public static final int AUTUMN = 3;\n>    public static final int WINTER = 4;\n>}\n>```\n>\n>这种方式称作int枚举模式。但是这种模式有一些问题。通常我们写出的代码都会从以下三个方面来进行分析，安全性、易用性和可读性。首先我们考虑一下他的安全性。当然这种模式不是类型安全的。比如我们设计一个函数，要求传入春夏秋冬的某个值。但是使用int类型，我们无法保证传入的值为合法。代码如下所示\n>\n>```java\n>private String getChineseSeason(int season){\n>        StringBuffer result = new StringBuffer();\n>        switch(season){\n>            case Season.SPRING :\n>                result.append(\"春天\");\n>                break;\n>            case Season.SUMMER :\n>                result.append(\"夏天\");\n>                break;\n>            case Season.AUTUMN :\n>                result.append(\"秋天\");\n>                break;\n>            case Season.WINTER :\n>                result.append(\"冬天\");\n>                break;\n>            default :\n>                result.append(\"地球没有的季节\");\n>                break;\n>        }\n>        return result.toString();\n>    }\n>\n>    public void doSomething(){\n>        //这是正常的场景\n>        System.out.println(this.getChineseSeason(Season.SPRING));\n>        //这个却是不正常的场景，这就导致了类型不安全问题\n>        System.out.println(this.getChineseSeason(5));\n>    }\n>```\n>\n>程序`getChineseSeason(Season.SPRING)`是我们预期的使用方法。可`getChineseSeason(5)`显然就不是了，而且编译很通过，在运行时会出现什么情况，我们就不得而知了。这显然就不符合`Java`程序的类型安全。\n>\n>接下来我们考虑一下这种模式的可读性。使用枚举的大多数场合，我们都需要方便的到枚举类型的字符串表达式。如果将int枚举常量打印出来，我们所见到的就是一组数字，这是没什么太大的用处。我们可能会想到是一个String常量来代替int常量。虽然他为这些常量提供了可打印的字符串，但是他会导致性能问题，因为他依赖于字符串的比较操作，所以这种模式也是我们不期望的。从类型安全性和程序可读性俩方面考虑，int和String枚举模式的缺点就显露出来。幸运的是，从`Java1.5`发行版本开始，就提出了另一种可以替代的解决方案，可以避免`int`和`String`枚举模式的缺点，并提供了许多额外的好处。那就是枚举类型（`enum type`）。接下来的章节将介绍枚举类型的定义、特征、应用场景和优缺点。\n>\n>\n\n\n\n### 2. 枚举定义和使用\n\n>枚举类型(enum type)是指由一组固定的常量组成合法的类型。java中由关键字enum来定义一个枚举类型。下面就是java枚举类型的定义:\n>\n>```java\n>publi enum Season{\n>   SPRING, SUMMER, AUTUMN, WINER;\n>}\n>```\n>\n>枚举的用法主要由以下几种：\n>\n>1. 常量，就如上面定义那样使用\n>\n>2. switch\n>\n>   ```java\n>   enum Signal {  \n>       GREEN, YELLOW, RED  \n>   }  \n>   public class TrafficLight {  \n>       Signal color = Signal.RED;  \n>       public void change() {  \n>           switch (color) {  \n>           case RED:  \n>               color = Signal.GREEN;  \n>               break;  \n>           case YELLOW:  \n>               color = Signal.RED;  \n>               break;  \n>           case GREEN:  \n>               color = Signal.YELLOW;  \n>               break;  \n>           }  \n>       }  \n>   }  \n>   ```\n>\n>3. 向枚举中添加新的方法\n>\n>   ```java\n>   public enum Color {  \n>       RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n>       // 成员变量  \n>       private String name;  \n>       private int index;  \n>       // 构造方法  \n>       private Color(String name, int index) {  \n>           this.name = name;  \n>           this.index = index;  \n>       }  \n>       // 普通方法  \n>       public static String getName(int index) {  \n>           for (Color c : Color.values()) {  \n>               if (c.getIndex() == index) {  \n>                   return c.name;  \n>               }  \n>           }  \n>           return null;  \n>       }  \n>       // get set 方法  \n>       public String getName() {  \n>           return name;  \n>       }  \n>       public void setName(String name) {  \n>           this.name = name;  \n>       }  \n>       public int getIndex() {  \n>           return index;  \n>       }  \n>       public void setIndex(int index) {  \n>           this.index = index;  \n>       }  \n>   }  \n>   ```\n>\n>4.  覆盖枚举的方法\n>\n>   ```java\n>   public enum Color {  \n>       RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n>       // 成员变量  \n>       private String name;  \n>       private int index;  \n>       // 构造方法  \n>       private Color(String name, int index) {  \n>           this.name = name;  \n>           this.index = index;  \n>       }  \n>       //覆盖方法  \n>       @Override  \n>       public String toString() {  \n>           return this.index+\"_\"+this.name;  \n>       }  \n>   }  \n>   ```\n>\n>5. 实现接口\n>\n>   ```java\n>   public interface Behaviour {  \n>       void print();  \n>       String getInfo();  \n>   }  \n>   public enum Color implements Behaviour{  \n>       RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n>       // 成员变量  \n>       private String name;  \n>       private int index;  \n>       // 构造方法  \n>       private Color(String name, int index) {  \n>           this.name = name;  \n>           this.index = index;  \n>       }  \n>   //接口方法  \n>       @Override  \n>       public String getInfo() {  \n>           return this.name;  \n>       }  \n>       //接口方法  \n>       @Override  \n>       public void print() {  \n>           System.out.println(this.index+\":\"+this.name);  \n>       }  \n>   }  \n>   ```\n>\n>6. 使用接口组织枚举\n>\n>   ```\n>   public interface Food {  \n>       enum Coffee implements Food{  \n>           BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO  \n>       }  \n>       enum Dessert implements Food{  \n>           FRUIT, CAKE, GELATO  \n>       }  \n>   }\n>   ```\n>\n>7. 常量相关的方法\n>\n>   ```java\n>   public enum Constantmethod{\n>     DATE_TIME{\n>       String getInfo(){\n>         System.out.println(\"date_time\");\n>       }\n>     }\n>     CLASSPATH{\n>       String getInfo(){\n>         System.out.println(\"classpath\");\n>       }\n>     }\n>     //定义每个常量都要实现的方法\n>     abstract String getInfo();\n>   }\n>   ```\n>\n>基本使用\n>\n>```java\n>public enum Season {\n>    SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);\n>\n>    private int code;\n>    private Season(int code){\n>        this.code = code;\n>    }\n>\n>    public int getCode(){\n>        return code;\n>    }\n>}\n>public class UseSeason {\n>    /**\n>     * 将英文的季节转换成中文季节\n>     * @param season\n>     * @return\n>     */\n>    public String getChineseSeason(Season season){\n>        StringBuffer result = new StringBuffer();\n>        switch(season){\n>            case SPRING :\n>                result.append(\"[中文：春天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            case AUTUMN :\n>                result.append(\"[中文：秋天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            case SUMMER : \n>                result.append(\"[中文：夏天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            case WINTER :\n>                result.append(\"[中文：冬天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            default :\n>                result.append(\"地球没有的季节 \" + season.name());\n>                break;\n>        }\n>        return result.toString();\n>    }\n>\n>    public void doSomething(){\n>        for(Season s : Season.values()){\n>            System.out.println(getChineseSeason(s));//这是正常的场景\n>        }\n>        //System.out.println(getChineseSeason(5));\n>        //此处已经是编译不通过了，这就保证了类型安全\n>    }\n>\n>    public static void main(String[] arg){\n>        UseSeason useSeason = new UseSeason();\n>        useSeason.doSomething();\n>    }\n>}\n>```\n>\n>\n\n### 3. 枚举的使用总结\n\n>其实枚举的定义很像类的定义，只不过枚举有一些限制，你甚至可以在枚举里面写main方法，这也是可以运行通过的。不过枚举不能继承类，至于原因接下来的博客会说明，但是枚举可以实现接口，就像上面展示的用法一样。\n\n### 4.深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\n\n>#### 1. 枚举是如何保证线程安全\n>\n>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：\n>\n>```\n>public enum t {\n>    SPRING,SUMMER,AUTUMN,WINTER;\n>}\n>```\n>\n>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译（[Java的反编译](http://www.hollischuang.com/archives/58)）后代码内容如下：\n>\n>```\n>public final class T extends Enum\n>{\n>    private T(String s, int i)\n>    {\n>        super(s, i);\n>    }\n>    public static T[] values()\n>    {\n>        T at[];\n>        int i;\n>        T at1[];\n>        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);\n>        return at1;\n>    }\n>\n>    public static T valueOf(String s)\n>    {\n>        return (T)Enum.valueOf(demo/T, s);\n>    }\n>\n>    public static final T SPRING;\n>    public static final T SUMMER;\n>    public static final T AUTUMN;\n>    public static final T WINTER;\n>    private static final T ENUM$VALUES[];\n>    static\n>    {\n>        SPRING = new T(\"SPRING\", 0);\n>        SUMMER = new T(\"SUMMER\", 1);\n>        AUTUMN = new T(\"AUTUMN\", 2);\n>        WINTER = new T(\"WINTER\", 3);\n>        ENUM$VALUES = (new T[] {\n>            SPRING, SUMMER, AUTUMN, WINTER\n>        });\n>    }\n>}\n>```\n>\n>通过反编译后代码我们可以看到，`public final class T extends Enum`，说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。当我们使用`enmu`来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类,所以枚举类型不能被继承，我们看到这个类中有几个属性和方法。\n>\n>我们可以看到：\n>\n>```\n>        public static final T SPRING;\n>        public static final T SUMMER;\n>        public static final T AUTUMN;\n>        public static final T WINTER;\n>        private static final T ENUM$VALUES[];\n>        static\n>        {\n>            SPRING = new T(\"SPRING\", 0);\n>            SUMMER = new T(\"SUMMER\", 1);\n>            AUTUMN = new T(\"AUTUMN\", 2);\n>            WINTER = new T(\"WINTER\", 3);\n>            ENUM$VALUES = (new T[] {\n>                SPRING, SUMMER, AUTUMN, WINTER\n>            });\n>        }\n>```\n>\n>都是static类型的，因为static类型的属性会在类被加载之后被初始化，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，**创建一个enum类型是线程安全的**。\n>\n>### 为什么用枚举实现的单例是最好的方式\n>\n>在[[转+注\\]单例模式的七种写法](http://www.hollischuang.com/archives/205)中，我们看到一共有七种实现单例的方式，其中，**Effective Java**作者`Josh Bloch` 提倡使用枚举的方式，既然大神说这种方式好，那我们就要知道它为什么好？\n>\n>**1. 枚举写法简单**\n>\n>> 写法简单这个大家看看[[转+注\\]单例模式的七种写法]()里面的实现就知道区别了。\n>\n>```\n>public enum EasySingleton{\n>    INSTANCE;\n>}\n>```\n>\n>你可以通过`EasySingleton.INSTANCE`来访问。\n>\n>**2. 枚举自己处理序列化**\n>\n>> 我们知道，以前的所有的单例模式都有一个比较大的问题，就是一旦实现了Serializable接口之后，就不再是单例得了，因为，每次调用 readObject()方法返回的都是一个新创建出来的对象，有一种解决办法就是使用readResolve()方法来避免此事发生。但是，**为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定。**原文如下：\n>>\n>> > Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant’s name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant’s enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.\n>>\n>> 大概意思就是说，在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。 我们看一下这个`valueOf`方法：\n>\n>```\n>public static <T extends Enum<T>> T valueOf(Class<T> enumType,String name) {  \n>            T result = enumType.enumConstantDirectory().get(name);  \n>            if (result != null)  \n>                return result;  \n>            if (name == null)  \n>                throw new NullPointerException(\"Name is null\");  \n>            throw new IllegalArgumentException(  \n>                \"No enum const \" + enumType +\".\" + name);  \n>        }  \n>```\n>\n>从代码中可以看到，代码会尝试从调用`enumType`这个`Class`对象的`enumConstantDirectory()`方法返回的`map`中获取名字为`name`的枚举对象，如果不存在就会抛出异常。再进一步跟到`enumConstantDirectory()`方法，就会发现到最后会以反射的方式调用`enumType`这个类型的`values()`静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充`enumType`这个`Class`对象中的`enumConstantDirectory`属性。\n>\n>所以，**JVM对序列化有保证。**\n>\n>**3.枚举实例创建是thread-safe(线程安全的)**\n>\n>> 当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，**创建一个enum类型是线程安全的**。","slug":"枚举初探","published":1,"updated":"2019-01-04T01:48:59.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovqv00229q1uglyyn02q","content":"<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<p>本篇博客的内容如下</p>\n<ol>\n<li>使用背景</li>\n<li>枚举定义和使用</li>\n<li>枚举的总结</li>\n<li>深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</li>\n</ol>\n</blockquote>\n<h3 id=\"1-使用背景\"><a href=\"#1-使用背景\" class=\"headerlink\" title=\"1.  使用背景\"></a>1.  使用背景</h3><blockquote>\n<p>在java语言还没有引入枚举类型之前，表示枚举类型的常用模式是声明一组int常量。之前通常利用public final static 方法定义。下面是一个小案例，分别用1 表示春天 2 表示夏天 3 表示秋天 4 表示冬天</p>\n<pre><code class=\"java\">public class Season {\n   public static final int SPRING = 1;\n   public static final int SUMMER = 2;\n   public static final int AUTUMN = 3;\n   public static final int WINTER = 4;\n}\n</code></pre>\n<p>这种方式称作int枚举模式。但是这种模式有一些问题。通常我们写出的代码都会从以下三个方面来进行分析，安全性、易用性和可读性。首先我们考虑一下他的安全性。当然这种模式不是类型安全的。比如我们设计一个函数，要求传入春夏秋冬的某个值。但是使用int类型，我们无法保证传入的值为合法。代码如下所示</p>\n<pre><code class=\"java\">private String getChineseSeason(int season){\n       StringBuffer result = new StringBuffer();\n       switch(season){\n           case Season.SPRING :\n               result.append(&quot;春天&quot;);\n               break;\n           case Season.SUMMER :\n               result.append(&quot;夏天&quot;);\n               break;\n           case Season.AUTUMN :\n               result.append(&quot;秋天&quot;);\n               break;\n           case Season.WINTER :\n               result.append(&quot;冬天&quot;);\n               break;\n           default :\n               result.append(&quot;地球没有的季节&quot;);\n               break;\n       }\n       return result.toString();\n   }\n\n   public void doSomething(){\n       //这是正常的场景\n       System.out.println(this.getChineseSeason(Season.SPRING));\n       //这个却是不正常的场景，这就导致了类型不安全问题\n       System.out.println(this.getChineseSeason(5));\n   }\n</code></pre>\n<p>程序<code>getChineseSeason(Season.SPRING)</code>是我们预期的使用方法。可<code>getChineseSeason(5)</code>显然就不是了，而且编译很通过，在运行时会出现什么情况，我们就不得而知了。这显然就不符合<code>Java</code>程序的类型安全。</p>\n<p>接下来我们考虑一下这种模式的可读性。使用枚举的大多数场合，我们都需要方便的到枚举类型的字符串表达式。如果将int枚举常量打印出来，我们所见到的就是一组数字，这是没什么太大的用处。我们可能会想到是一个String常量来代替int常量。虽然他为这些常量提供了可打印的字符串，但是他会导致性能问题，因为他依赖于字符串的比较操作，所以这种模式也是我们不期望的。从类型安全性和程序可读性俩方面考虑，int和String枚举模式的缺点就显露出来。幸运的是，从<code>Java1.5</code>发行版本开始，就提出了另一种可以替代的解决方案，可以避免<code>int</code>和<code>String</code>枚举模式的缺点，并提供了许多额外的好处。那就是枚举类型（<code>enum type</code>）。接下来的章节将介绍枚举类型的定义、特征、应用场景和优缺点。</p>\n</blockquote>\n<h3 id=\"2-枚举定义和使用\"><a href=\"#2-枚举定义和使用\" class=\"headerlink\" title=\"2. 枚举定义和使用\"></a>2. 枚举定义和使用</h3><blockquote>\n<p>枚举类型(enum type)是指由一组固定的常量组成合法的类型。java中由关键字enum来定义一个枚举类型。下面就是java枚举类型的定义:</p>\n<pre><code class=\"java\">publi enum Season{\n  SPRING, SUMMER, AUTUMN, WINER;\n}\n</code></pre>\n<p>枚举的用法主要由以下几种：</p>\n<ol>\n<li><p>常量，就如上面定义那样使用</p>\n</li>\n<li><p>switch</p>\n<pre><code class=\"java\">enum Signal {  \n   GREEN, YELLOW, RED  \n}  \npublic class TrafficLight {  \n   Signal color = Signal.RED;  \n   public void change() {  \n       switch (color) {  \n       case RED:  \n           color = Signal.GREEN;  \n           break;  \n       case YELLOW:  \n           color = Signal.RED;  \n           break;  \n       case GREEN:  \n           color = Signal.YELLOW;  \n           break;  \n       }  \n   }  \n}  \n</code></pre>\n</li>\n<li><p>向枚举中添加新的方法</p>\n<pre><code class=\"java\">public enum Color {  \n   RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  \n   // 成员变量  \n   private String name;  \n   private int index;  \n   // 构造方法  \n   private Color(String name, int index) {  \n       this.name = name;  \n       this.index = index;  \n   }  \n   // 普通方法  \n   public static String getName(int index) {  \n       for (Color c : Color.values()) {  \n           if (c.getIndex() == index) {  \n               return c.name;  \n           }  \n       }  \n       return null;  \n   }  \n   // get set 方法  \n   public String getName() {  \n       return name;  \n   }  \n   public void setName(String name) {  \n       this.name = name;  \n   }  \n   public int getIndex() {  \n       return index;  \n   }  \n   public void setIndex(int index) {  \n       this.index = index;  \n   }  \n}  \n</code></pre>\n</li>\n<li><p>覆盖枚举的方法</p>\n<pre><code class=\"java\">public enum Color {  \n  RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  \n  // 成员变量  \n  private String name;  \n  private int index;  \n  // 构造方法  \n  private Color(String name, int index) {  \n      this.name = name;  \n      this.index = index;  \n  }  \n  //覆盖方法  \n  @Override  \n  public String toString() {  \n      return this.index+&quot;_&quot;+this.name;  \n  }  \n}  \n</code></pre>\n</li>\n<li><p>实现接口</p>\n<pre><code class=\"java\">public interface Behaviour {  \n   void print();  \n   String getInfo();  \n}  \npublic enum Color implements Behaviour{  \n   RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  \n   // 成员变量  \n   private String name;  \n   private int index;  \n   // 构造方法  \n   private Color(String name, int index) {  \n       this.name = name;  \n       this.index = index;  \n   }  \n//接口方法  \n   @Override  \n   public String getInfo() {  \n       return this.name;  \n   }  \n   //接口方法  \n   @Override  \n   public void print() {  \n       System.out.println(this.index+&quot;:&quot;+this.name);  \n   }  \n}  \n</code></pre>\n</li>\n<li><p>使用接口组织枚举</p>\n<pre><code>public interface Food {  \n   enum Coffee implements Food{  \n       BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO  \n   }  \n   enum Dessert implements Food{  \n       FRUIT, CAKE, GELATO  \n   }  \n}\n</code></pre></li>\n<li><p>常量相关的方法</p>\n<pre><code class=\"java\">public enum Constantmethod{\n DATE_TIME{\n   String getInfo(){\n     System.out.println(&quot;date_time&quot;);\n   }\n }\n CLASSPATH{\n   String getInfo(){\n     System.out.println(&quot;classpath&quot;);\n   }\n }\n //定义每个常量都要实现的方法\n abstract String getInfo();\n}\n</code></pre>\n</li>\n</ol>\n<p>基本使用</p>\n<pre><code class=\"java\">public enum Season {\n   SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);\n\n   private int code;\n   private Season(int code){\n       this.code = code;\n   }\n\n   public int getCode(){\n       return code;\n   }\n}\npublic class UseSeason {\n   /**\n    * 将英文的季节转换成中文季节\n    * @param season\n    * @return\n    */\n   public String getChineseSeason(Season season){\n       StringBuffer result = new StringBuffer();\n       switch(season){\n           case SPRING :\n               result.append(&quot;[中文：春天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           case AUTUMN :\n               result.append(&quot;[中文：秋天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           case SUMMER : \n               result.append(&quot;[中文：夏天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           case WINTER :\n               result.append(&quot;[中文：冬天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           default :\n               result.append(&quot;地球没有的季节 &quot; + season.name());\n               break;\n       }\n       return result.toString();\n   }\n\n   public void doSomething(){\n       for(Season s : Season.values()){\n           System.out.println(getChineseSeason(s));//这是正常的场景\n       }\n       //System.out.println(getChineseSeason(5));\n       //此处已经是编译不通过了，这就保证了类型安全\n   }\n\n   public static void main(String[] arg){\n       UseSeason useSeason = new UseSeason();\n       useSeason.doSomething();\n   }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"3-枚举的使用总结\"><a href=\"#3-枚举的使用总结\" class=\"headerlink\" title=\"3. 枚举的使用总结\"></a>3. 枚举的使用总结</h3><blockquote>\n<p>其实枚举的定义很像类的定义，只不过枚举有一些限制，你甚至可以在枚举里面写main方法，这也是可以运行通过的。不过枚举不能继承类，至于原因接下来的博客会说明，但是枚举可以实现接口，就像上面展示的用法一样。</p>\n</blockquote>\n<h3 id=\"4-深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\"><a href=\"#4-深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\" class=\"headerlink\" title=\"4.深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\"></a>4.深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</h3><blockquote>\n<h4 id=\"1-枚举是如何保证线程安全\"><a href=\"#1-枚举是如何保证线程安全\" class=\"headerlink\" title=\"1. 枚举是如何保证线程安全\"></a>1. 枚举是如何保证线程安全</h4><p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：</p>\n<pre><code>public enum t {\n   SPRING,SUMMER,AUTUMN,WINTER;\n}\n</code></pre><p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译（<a href=\"http://www.hollischuang.com/archives/58\" target=\"_blank\" rel=\"noopener\">Java的反编译</a>）后代码内容如下：</p>\n<pre><code>public final class T extends Enum\n{\n   private T(String s, int i)\n   {\n       super(s, i);\n   }\n   public static T[] values()\n   {\n       T at[];\n       int i;\n       T at1[];\n       System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);\n       return at1;\n   }\n\n   public static T valueOf(String s)\n   {\n       return (T)Enum.valueOf(demo/T, s);\n   }\n\n   public static final T SPRING;\n   public static final T SUMMER;\n   public static final T AUTUMN;\n   public static final T WINTER;\n   private static final T ENUM$VALUES[];\n   static\n   {\n       SPRING = new T(&quot;SPRING&quot;, 0);\n       SUMMER = new T(&quot;SUMMER&quot;, 1);\n       AUTUMN = new T(&quot;AUTUMN&quot;, 2);\n       WINTER = new T(&quot;WINTER&quot;, 3);\n       ENUM$VALUES = (new T[] {\n           SPRING, SUMMER, AUTUMN, WINTER\n       });\n   }\n}\n</code></pre><p>通过反编译后代码我们可以看到，<code>public final class T extends Enum</code>，说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。当我们使用<code>enmu</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类,所以枚举类型不能被继承，我们看到这个类中有几个属性和方法。</p>\n<p>我们可以看到：</p>\n<pre><code>       public static final T SPRING;\n       public static final T SUMMER;\n       public static final T AUTUMN;\n       public static final T WINTER;\n       private static final T ENUM$VALUES[];\n       static\n       {\n           SPRING = new T(&quot;SPRING&quot;, 0);\n           SUMMER = new T(&quot;SUMMER&quot;, 1);\n           AUTUMN = new T(&quot;AUTUMN&quot;, 2);\n           WINTER = new T(&quot;WINTER&quot;, 3);\n           ENUM$VALUES = (new T[] {\n               SPRING, SUMMER, AUTUMN, WINTER\n           });\n       }\n</code></pre><p>都是static类型的，因为static类型的属性会在类被加载之后被初始化，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，<strong>创建一个enum类型是线程安全的</strong>。</p>\n<h3 id=\"为什么用枚举实现的单例是最好的方式\"><a href=\"#为什么用枚举实现的单例是最好的方式\" class=\"headerlink\" title=\"为什么用枚举实现的单例是最好的方式\"></a>为什么用枚举实现的单例是最好的方式</h3><p>在<a href=\"http://www.hollischuang.com/archives/205\" target=\"_blank\" rel=\"noopener\">[转+注]单例模式的七种写法</a>中，我们看到一共有七种实现单例的方式，其中，<strong>Effective Java</strong>作者<code>Josh Bloch</code> 提倡使用枚举的方式，既然大神说这种方式好，那我们就要知道它为什么好？</p>\n<p><strong>1. 枚举写法简单</strong></p>\n<blockquote>\n<p>写法简单这个大家看看<a href=\"\">[转+注]单例模式的七种写法</a>里面的实现就知道区别了。</p>\n</blockquote>\n<pre><code>public enum EasySingleton{\n   INSTANCE;\n}\n</code></pre><p>你可以通过<code>EasySingleton.INSTANCE</code>来访问。</p>\n<p><strong>2. 枚举自己处理序列化</strong></p>\n<blockquote>\n<p>我们知道，以前的所有的单例模式都有一个比较大的问题，就是一旦实现了Serializable接口之后，就不再是单例得了，因为，每次调用 readObject()方法返回的都是一个新创建出来的对象，有一种解决办法就是使用readResolve()方法来避免此事发生。但是，<strong>为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定。</strong>原文如下：</p>\n<blockquote>\n<p>Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant’s name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant’s enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.</p>\n</blockquote>\n<p>大概意思就是说，在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。 我们看一下这个<code>valueOf</code>方法：</p>\n</blockquote>\n<pre><code>public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name) {  \n           T result = enumType.enumConstantDirectory().get(name);  \n           if (result != null)  \n               return result;  \n           if (name == null)  \n               throw new NullPointerException(&quot;Name is null&quot;);  \n           throw new IllegalArgumentException(  \n               &quot;No enum const &quot; + enumType +&quot;.&quot; + name);  \n       }  \n</code></pre><p>从代码中可以看到，代码会尝试从调用<code>enumType</code>这个<code>Class</code>对象的<code>enumConstantDirectory()</code>方法返回的<code>map</code>中获取名字为<code>name</code>的枚举对象，如果不存在就会抛出异常。再进一步跟到<code>enumConstantDirectory()</code>方法，就会发现到最后会以反射的方式调用<code>enumType</code>这个类型的<code>values()</code>静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充<code>enumType</code>这个<code>Class</code>对象中的<code>enumConstantDirectory</code>属性。</p>\n<p>所以，<strong>JVM对序列化有保证。</strong></p>\n<p><strong>3.枚举实例创建是thread-safe(线程安全的)</strong></p>\n<blockquote>\n<p>当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，<strong>创建一个enum类型是线程安全的</strong>。</p>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<p>本篇博客的内容如下</p>\n<ol>\n<li>使用背景</li>\n<li>枚举定义和使用</li>\n<li>枚举的总结</li>\n<li>深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</li>\n</ol>\n</blockquote>\n<h3 id=\"1-使用背景\"><a href=\"#1-使用背景\" class=\"headerlink\" title=\"1.  使用背景\"></a>1.  使用背景</h3><blockquote>\n<p>在java语言还没有引入枚举类型之前，表示枚举类型的常用模式是声明一组int常量。之前通常利用public final static 方法定义。下面是一个小案例，分别用1 表示春天 2 表示夏天 3 表示秋天 4 表示冬天</p>\n<pre><code class=\"java\">public class Season {\n   public static final int SPRING = 1;\n   public static final int SUMMER = 2;\n   public static final int AUTUMN = 3;\n   public static final int WINTER = 4;\n}\n</code></pre>\n<p>这种方式称作int枚举模式。但是这种模式有一些问题。通常我们写出的代码都会从以下三个方面来进行分析，安全性、易用性和可读性。首先我们考虑一下他的安全性。当然这种模式不是类型安全的。比如我们设计一个函数，要求传入春夏秋冬的某个值。但是使用int类型，我们无法保证传入的值为合法。代码如下所示</p>\n<pre><code class=\"java\">private String getChineseSeason(int season){\n       StringBuffer result = new StringBuffer();\n       switch(season){\n           case Season.SPRING :\n               result.append(&quot;春天&quot;);\n               break;\n           case Season.SUMMER :\n               result.append(&quot;夏天&quot;);\n               break;\n           case Season.AUTUMN :\n               result.append(&quot;秋天&quot;);\n               break;\n           case Season.WINTER :\n               result.append(&quot;冬天&quot;);\n               break;\n           default :\n               result.append(&quot;地球没有的季节&quot;);\n               break;\n       }\n       return result.toString();\n   }\n\n   public void doSomething(){\n       //这是正常的场景\n       System.out.println(this.getChineseSeason(Season.SPRING));\n       //这个却是不正常的场景，这就导致了类型不安全问题\n       System.out.println(this.getChineseSeason(5));\n   }\n</code></pre>\n<p>程序<code>getChineseSeason(Season.SPRING)</code>是我们预期的使用方法。可<code>getChineseSeason(5)</code>显然就不是了，而且编译很通过，在运行时会出现什么情况，我们就不得而知了。这显然就不符合<code>Java</code>程序的类型安全。</p>\n<p>接下来我们考虑一下这种模式的可读性。使用枚举的大多数场合，我们都需要方便的到枚举类型的字符串表达式。如果将int枚举常量打印出来，我们所见到的就是一组数字，这是没什么太大的用处。我们可能会想到是一个String常量来代替int常量。虽然他为这些常量提供了可打印的字符串，但是他会导致性能问题，因为他依赖于字符串的比较操作，所以这种模式也是我们不期望的。从类型安全性和程序可读性俩方面考虑，int和String枚举模式的缺点就显露出来。幸运的是，从<code>Java1.5</code>发行版本开始，就提出了另一种可以替代的解决方案，可以避免<code>int</code>和<code>String</code>枚举模式的缺点，并提供了许多额外的好处。那就是枚举类型（<code>enum type</code>）。接下来的章节将介绍枚举类型的定义、特征、应用场景和优缺点。</p>\n</blockquote>\n<h3 id=\"2-枚举定义和使用\"><a href=\"#2-枚举定义和使用\" class=\"headerlink\" title=\"2. 枚举定义和使用\"></a>2. 枚举定义和使用</h3><blockquote>\n<p>枚举类型(enum type)是指由一组固定的常量组成合法的类型。java中由关键字enum来定义一个枚举类型。下面就是java枚举类型的定义:</p>\n<pre><code class=\"java\">publi enum Season{\n  SPRING, SUMMER, AUTUMN, WINER;\n}\n</code></pre>\n<p>枚举的用法主要由以下几种：</p>\n<ol>\n<li><p>常量，就如上面定义那样使用</p>\n</li>\n<li><p>switch</p>\n<pre><code class=\"java\">enum Signal {  \n   GREEN, YELLOW, RED  \n}  \npublic class TrafficLight {  \n   Signal color = Signal.RED;  \n   public void change() {  \n       switch (color) {  \n       case RED:  \n           color = Signal.GREEN;  \n           break;  \n       case YELLOW:  \n           color = Signal.RED;  \n           break;  \n       case GREEN:  \n           color = Signal.YELLOW;  \n           break;  \n       }  \n   }  \n}  \n</code></pre>\n</li>\n<li><p>向枚举中添加新的方法</p>\n<pre><code class=\"java\">public enum Color {  \n   RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  \n   // 成员变量  \n   private String name;  \n   private int index;  \n   // 构造方法  \n   private Color(String name, int index) {  \n       this.name = name;  \n       this.index = index;  \n   }  \n   // 普通方法  \n   public static String getName(int index) {  \n       for (Color c : Color.values()) {  \n           if (c.getIndex() == index) {  \n               return c.name;  \n           }  \n       }  \n       return null;  \n   }  \n   // get set 方法  \n   public String getName() {  \n       return name;  \n   }  \n   public void setName(String name) {  \n       this.name = name;  \n   }  \n   public int getIndex() {  \n       return index;  \n   }  \n   public void setIndex(int index) {  \n       this.index = index;  \n   }  \n}  \n</code></pre>\n</li>\n<li><p>覆盖枚举的方法</p>\n<pre><code class=\"java\">public enum Color {  \n  RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  \n  // 成员变量  \n  private String name;  \n  private int index;  \n  // 构造方法  \n  private Color(String name, int index) {  \n      this.name = name;  \n      this.index = index;  \n  }  \n  //覆盖方法  \n  @Override  \n  public String toString() {  \n      return this.index+&quot;_&quot;+this.name;  \n  }  \n}  \n</code></pre>\n</li>\n<li><p>实现接口</p>\n<pre><code class=\"java\">public interface Behaviour {  \n   void print();  \n   String getInfo();  \n}  \npublic enum Color implements Behaviour{  \n   RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  \n   // 成员变量  \n   private String name;  \n   private int index;  \n   // 构造方法  \n   private Color(String name, int index) {  \n       this.name = name;  \n       this.index = index;  \n   }  \n//接口方法  \n   @Override  \n   public String getInfo() {  \n       return this.name;  \n   }  \n   //接口方法  \n   @Override  \n   public void print() {  \n       System.out.println(this.index+&quot;:&quot;+this.name);  \n   }  \n}  \n</code></pre>\n</li>\n<li><p>使用接口组织枚举</p>\n<pre><code>public interface Food {  \n   enum Coffee implements Food{  \n       BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO  \n   }  \n   enum Dessert implements Food{  \n       FRUIT, CAKE, GELATO  \n   }  \n}\n</code></pre></li>\n<li><p>常量相关的方法</p>\n<pre><code class=\"java\">public enum Constantmethod{\n DATE_TIME{\n   String getInfo(){\n     System.out.println(&quot;date_time&quot;);\n   }\n }\n CLASSPATH{\n   String getInfo(){\n     System.out.println(&quot;classpath&quot;);\n   }\n }\n //定义每个常量都要实现的方法\n abstract String getInfo();\n}\n</code></pre>\n</li>\n</ol>\n<p>基本使用</p>\n<pre><code class=\"java\">public enum Season {\n   SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);\n\n   private int code;\n   private Season(int code){\n       this.code = code;\n   }\n\n   public int getCode(){\n       return code;\n   }\n}\npublic class UseSeason {\n   /**\n    * 将英文的季节转换成中文季节\n    * @param season\n    * @return\n    */\n   public String getChineseSeason(Season season){\n       StringBuffer result = new StringBuffer();\n       switch(season){\n           case SPRING :\n               result.append(&quot;[中文：春天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           case AUTUMN :\n               result.append(&quot;[中文：秋天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           case SUMMER : \n               result.append(&quot;[中文：夏天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           case WINTER :\n               result.append(&quot;[中文：冬天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           default :\n               result.append(&quot;地球没有的季节 &quot; + season.name());\n               break;\n       }\n       return result.toString();\n   }\n\n   public void doSomething(){\n       for(Season s : Season.values()){\n           System.out.println(getChineseSeason(s));//这是正常的场景\n       }\n       //System.out.println(getChineseSeason(5));\n       //此处已经是编译不通过了，这就保证了类型安全\n   }\n\n   public static void main(String[] arg){\n       UseSeason useSeason = new UseSeason();\n       useSeason.doSomething();\n   }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"3-枚举的使用总结\"><a href=\"#3-枚举的使用总结\" class=\"headerlink\" title=\"3. 枚举的使用总结\"></a>3. 枚举的使用总结</h3><blockquote>\n<p>其实枚举的定义很像类的定义，只不过枚举有一些限制，你甚至可以在枚举里面写main方法，这也是可以运行通过的。不过枚举不能继承类，至于原因接下来的博客会说明，但是枚举可以实现接口，就像上面展示的用法一样。</p>\n</blockquote>\n<h3 id=\"4-深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\"><a href=\"#4-深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\" class=\"headerlink\" title=\"4.深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\"></a>4.深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</h3><blockquote>\n<h4 id=\"1-枚举是如何保证线程安全\"><a href=\"#1-枚举是如何保证线程安全\" class=\"headerlink\" title=\"1. 枚举是如何保证线程安全\"></a>1. 枚举是如何保证线程安全</h4><p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：</p>\n<pre><code>public enum t {\n   SPRING,SUMMER,AUTUMN,WINTER;\n}\n</code></pre><p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译（<a href=\"http://www.hollischuang.com/archives/58\" target=\"_blank\" rel=\"noopener\">Java的反编译</a>）后代码内容如下：</p>\n<pre><code>public final class T extends Enum\n{\n   private T(String s, int i)\n   {\n       super(s, i);\n   }\n   public static T[] values()\n   {\n       T at[];\n       int i;\n       T at1[];\n       System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);\n       return at1;\n   }\n\n   public static T valueOf(String s)\n   {\n       return (T)Enum.valueOf(demo/T, s);\n   }\n\n   public static final T SPRING;\n   public static final T SUMMER;\n   public static final T AUTUMN;\n   public static final T WINTER;\n   private static final T ENUM$VALUES[];\n   static\n   {\n       SPRING = new T(&quot;SPRING&quot;, 0);\n       SUMMER = new T(&quot;SUMMER&quot;, 1);\n       AUTUMN = new T(&quot;AUTUMN&quot;, 2);\n       WINTER = new T(&quot;WINTER&quot;, 3);\n       ENUM$VALUES = (new T[] {\n           SPRING, SUMMER, AUTUMN, WINTER\n       });\n   }\n}\n</code></pre><p>通过反编译后代码我们可以看到，<code>public final class T extends Enum</code>，说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。当我们使用<code>enmu</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类,所以枚举类型不能被继承，我们看到这个类中有几个属性和方法。</p>\n<p>我们可以看到：</p>\n<pre><code>       public static final T SPRING;\n       public static final T SUMMER;\n       public static final T AUTUMN;\n       public static final T WINTER;\n       private static final T ENUM$VALUES[];\n       static\n       {\n           SPRING = new T(&quot;SPRING&quot;, 0);\n           SUMMER = new T(&quot;SUMMER&quot;, 1);\n           AUTUMN = new T(&quot;AUTUMN&quot;, 2);\n           WINTER = new T(&quot;WINTER&quot;, 3);\n           ENUM$VALUES = (new T[] {\n               SPRING, SUMMER, AUTUMN, WINTER\n           });\n       }\n</code></pre><p>都是static类型的，因为static类型的属性会在类被加载之后被初始化，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，<strong>创建一个enum类型是线程安全的</strong>。</p>\n<h3 id=\"为什么用枚举实现的单例是最好的方式\"><a href=\"#为什么用枚举实现的单例是最好的方式\" class=\"headerlink\" title=\"为什么用枚举实现的单例是最好的方式\"></a>为什么用枚举实现的单例是最好的方式</h3><p>在<a href=\"http://www.hollischuang.com/archives/205\" target=\"_blank\" rel=\"noopener\">[转+注]单例模式的七种写法</a>中，我们看到一共有七种实现单例的方式，其中，<strong>Effective Java</strong>作者<code>Josh Bloch</code> 提倡使用枚举的方式，既然大神说这种方式好，那我们就要知道它为什么好？</p>\n<p><strong>1. 枚举写法简单</strong></p>\n<blockquote>\n<p>写法简单这个大家看看<a href=\"\">[转+注]单例模式的七种写法</a>里面的实现就知道区别了。</p>\n</blockquote>\n<pre><code>public enum EasySingleton{\n   INSTANCE;\n}\n</code></pre><p>你可以通过<code>EasySingleton.INSTANCE</code>来访问。</p>\n<p><strong>2. 枚举自己处理序列化</strong></p>\n<blockquote>\n<p>我们知道，以前的所有的单例模式都有一个比较大的问题，就是一旦实现了Serializable接口之后，就不再是单例得了，因为，每次调用 readObject()方法返回的都是一个新创建出来的对象，有一种解决办法就是使用readResolve()方法来避免此事发生。但是，<strong>为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定。</strong>原文如下：</p>\n<blockquote>\n<p>Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant’s name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant’s enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.</p>\n</blockquote>\n<p>大概意思就是说，在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。 我们看一下这个<code>valueOf</code>方法：</p>\n</blockquote>\n<pre><code>public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name) {  \n           T result = enumType.enumConstantDirectory().get(name);  \n           if (result != null)  \n               return result;  \n           if (name == null)  \n               throw new NullPointerException(&quot;Name is null&quot;);  \n           throw new IllegalArgumentException(  \n               &quot;No enum const &quot; + enumType +&quot;.&quot; + name);  \n       }  \n</code></pre><p>从代码中可以看到，代码会尝试从调用<code>enumType</code>这个<code>Class</code>对象的<code>enumConstantDirectory()</code>方法返回的<code>map</code>中获取名字为<code>name</code>的枚举对象，如果不存在就会抛出异常。再进一步跟到<code>enumConstantDirectory()</code>方法，就会发现到最后会以反射的方式调用<code>enumType</code>这个类型的<code>values()</code>静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充<code>enumType</code>这个<code>Class</code>对象中的<code>enumConstantDirectory</code>属性。</p>\n<p>所以，<strong>JVM对序列化有保证。</strong></p>\n<p><strong>3.枚举实例创建是thread-safe(线程安全的)</strong></p>\n<blockquote>\n<p>当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，<strong>创建一个enum类型是线程安全的</strong>。</p>\n</blockquote>\n</blockquote>\n"},{"abbrlink":1,"title":"java多线程系列 01 基本概念以及实现方式","author":"zhangke","date":"2018-07-11T08:12:00.000Z","_content":"# java 多线程的基本概念以及实现方式\n\n### 概要\n\n1. 线程的基本概念\n2. 常用的实现多线程的方式\n3. Thread中start()和run()的区别\n\n###  1. 线程的基本概念\n\n线程状态图\n\n![](https://images0.cnblogs.com/blog/497634/201312/18152411-a974ea82ebc04e72bd874c3921f8bfec.jpg)\n\n**说明**：\n线程共包括以下5种状态。\n\n1. **新建状态(New)**         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。\n2. **就绪状态(Runnable)**: 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。\n3. **运行状态(Running)** : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。\n4. **阻塞状态(Blocked)**  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：\n   1. 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。\n   2.  同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。\n   3.  其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\n5. **死亡状态(Dead)**    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。需要注意的是，**线程一旦进入死亡状态就不能在调用start()方法来让线程恢复运行。**\n这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。这些内容我们会在后面的章节中逐个进行学习。\n\n**Object类**，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。\n**Thread类**，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。\n**synchronized**，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。\n在后面详细介绍wait(),notify()等方法时，我们会分析为什么**wait(), notify()等方法要定义在Object类，而不是Thread类中**。\n\n### 2. 常用的实现多线程的方式\n\n常用的主要有俩种：Thread类 和Runnable接口\n### **Thread和Runnable简介**\n\n**Runnable** 是一个接口，该接口中只包含了一个run()方法。它的定义如下：\n\n```\npublic interface Runnable {\n    public abstract void run();\n}\n```\n\nRunnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；\n\n然后，通过``new Thread(new A())``等方式新建线程。\n\n**Thread** 是一个类。Thread本身就实现了Runnable接口。它的声明如下：\n\n```\npublic class Thread implements Runnable {\n    \n}\n```\n\nThread的作用，实现多线程。\n\n### **Thread和Runnable的异同点**\n\n**Thread 和 Runnable 的相同点**：都是“多线程的实现方式”。\n\n **Thread 和 Runnable 的不同点**： Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。\n\n 此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。 \n\n通常，建议通过“Runnable”实现多线程！\n\n### **Thread和Runnable的多线程示例**\n\n\n\n#### Thread的多线程示例\n\n```\nclass MyThread extends Thread{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i<20;i++){ \n            if(this.ticket>0){\n                System.out.println(this.getName()+\" 卖票：ticket\"+this.ticket--);\n            }\n        }\n    } \n};\n\npublic class ThreadTest {  \n    public static void main(String[] args) {  \n        // 创建3个线程,每个线程各卖10张票！\n        MyThread t1=new MyThread();\n        MyThread t2=new MyThread();\n        MyThread t3=new MyThread();\n        //启动线程，开始运行\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n```\n\n#### **Runnable的多线程示例**\n\n```\n// 实现Runnable接口\nclass MyThread implements Runnable{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i<20;i++){ \n            if(this.ticket>0){\n                System.out.println(Thread.currentThread().getName()\n                 +\" 卖票：ticket\"+this.ticket--);\n            }\n        }\n    } \n}; \n\npublic class RunnableTest {  \n    public static void main(String[] args) {  \n    \n        //创建实现了Runnable接口的对象\n        MyThread mt=new MyThread();\n\n        // 创建3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！\n        Thread t1=new Thread(mt);\n        Thread t2=new Thread(mt);\n        Thread t3=new Thread(mt);\n        //启动3个线程\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n```\n\n**结果说明**： \n\n1.  和上面“MyThread继承于Thread”不同；这里的MyThread实现了Runnable接口。 \n\n2.  主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。\n\n#### 注意的是:上面不是线程安全的操作\n\n### 3. Thread中start()和run()的区别\n\n**start()** : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。\n\n **run()**   : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！\n\n后面会将Thread类的源码拿出来单独解析说明。这里只是简单的提一下。","source":"_posts/threads/java多线程系列 01基本概念以及实现方式.md","raw":"abbrlink: 1\ntitle: java多线程系列 01 基本概念以及实现方式\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-11 16:12:00\n---\n# java 多线程的基本概念以及实现方式\n\n### 概要\n\n1. 线程的基本概念\n2. 常用的实现多线程的方式\n3. Thread中start()和run()的区别\n\n###  1. 线程的基本概念\n\n线程状态图\n\n![](https://images0.cnblogs.com/blog/497634/201312/18152411-a974ea82ebc04e72bd874c3921f8bfec.jpg)\n\n**说明**：\n线程共包括以下5种状态。\n\n1. **新建状态(New)**         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。\n2. **就绪状态(Runnable)**: 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。\n3. **运行状态(Running)** : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。\n4. **阻塞状态(Blocked)**  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：\n   1. 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。\n   2.  同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。\n   3.  其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\n5. **死亡状态(Dead)**    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。需要注意的是，**线程一旦进入死亡状态就不能在调用start()方法来让线程恢复运行。**\n这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。这些内容我们会在后面的章节中逐个进行学习。\n\n**Object类**，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。\n**Thread类**，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。\n**synchronized**，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。\n在后面详细介绍wait(),notify()等方法时，我们会分析为什么**wait(), notify()等方法要定义在Object类，而不是Thread类中**。\n\n### 2. 常用的实现多线程的方式\n\n常用的主要有俩种：Thread类 和Runnable接口\n### **Thread和Runnable简介**\n\n**Runnable** 是一个接口，该接口中只包含了一个run()方法。它的定义如下：\n\n```\npublic interface Runnable {\n    public abstract void run();\n}\n```\n\nRunnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；\n\n然后，通过``new Thread(new A())``等方式新建线程。\n\n**Thread** 是一个类。Thread本身就实现了Runnable接口。它的声明如下：\n\n```\npublic class Thread implements Runnable {\n    \n}\n```\n\nThread的作用，实现多线程。\n\n### **Thread和Runnable的异同点**\n\n**Thread 和 Runnable 的相同点**：都是“多线程的实现方式”。\n\n **Thread 和 Runnable 的不同点**： Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。\n\n 此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。 \n\n通常，建议通过“Runnable”实现多线程！\n\n### **Thread和Runnable的多线程示例**\n\n\n\n#### Thread的多线程示例\n\n```\nclass MyThread extends Thread{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i<20;i++){ \n            if(this.ticket>0){\n                System.out.println(this.getName()+\" 卖票：ticket\"+this.ticket--);\n            }\n        }\n    } \n};\n\npublic class ThreadTest {  \n    public static void main(String[] args) {  \n        // 创建3个线程,每个线程各卖10张票！\n        MyThread t1=new MyThread();\n        MyThread t2=new MyThread();\n        MyThread t3=new MyThread();\n        //启动线程，开始运行\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n```\n\n#### **Runnable的多线程示例**\n\n```\n// 实现Runnable接口\nclass MyThread implements Runnable{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i<20;i++){ \n            if(this.ticket>0){\n                System.out.println(Thread.currentThread().getName()\n                 +\" 卖票：ticket\"+this.ticket--);\n            }\n        }\n    } \n}; \n\npublic class RunnableTest {  \n    public static void main(String[] args) {  \n    \n        //创建实现了Runnable接口的对象\n        MyThread mt=new MyThread();\n\n        // 创建3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！\n        Thread t1=new Thread(mt);\n        Thread t2=new Thread(mt);\n        Thread t3=new Thread(mt);\n        //启动3个线程\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n```\n\n**结果说明**： \n\n1.  和上面“MyThread继承于Thread”不同；这里的MyThread实现了Runnable接口。 \n\n2.  主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。\n\n#### 注意的是:上面不是线程安全的操作\n\n### 3. Thread中start()和run()的区别\n\n**start()** : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。\n\n **run()**   : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！\n\n后面会将Thread类的源码拿出来单独解析说明。这里只是简单的提一下。","slug":"threads/java多线程系列 01基本概念以及实现方式","published":1,"updated":"2019-01-04T01:48:59.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovqw00249q1uanngac00","content":"<h1 id=\"java-多线程的基本概念以及实现方式\"><a href=\"#java-多线程的基本概念以及实现方式\" class=\"headerlink\" title=\"java 多线程的基本概念以及实现方式\"></a>java 多线程的基本概念以及实现方式</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><ol>\n<li>线程的基本概念</li>\n<li>常用的实现多线程的方式</li>\n<li>Thread中start()和run()的区别</li>\n</ol>\n<h3 id=\"1-线程的基本概念\"><a href=\"#1-线程的基本概念\" class=\"headerlink\" title=\"1. 线程的基本概念\"></a>1. 线程的基本概念</h3><p>线程状态图</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18152411-a974ea82ebc04e72bd874c3921f8bfec.jpg\" alt=\"\"></p>\n<p><strong>说明</strong>：<br>线程共包括以下5种状态。</p>\n<ol>\n<li><strong>新建状态(New)</strong>         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</li>\n<li><strong>就绪状态(Runnable)</strong>: 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li>\n<li><strong>运行状态(Running)</strong> : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li>\n<li><strong>阻塞状态(Blocked)</strong>  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ol>\n<li>等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li>\n<li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li>\n<li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>\n</ol>\n</li>\n<li><strong>死亡状态(Dead)</strong>    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。需要注意的是，<strong>线程一旦进入死亡状态就不能在调用start()方法来让线程恢复运行。</strong><br>这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。这些内容我们会在后面的章节中逐个进行学习。</li>\n</ol>\n<p><strong>Object类</strong>，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。<br><strong>Thread类</strong>，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。<br><strong>synchronized</strong>，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。<br>在后面详细介绍wait(),notify()等方法时，我们会分析为什么<strong>wait(), notify()等方法要定义在Object类，而不是Thread类中</strong>。</p>\n<h3 id=\"2-常用的实现多线程的方式\"><a href=\"#2-常用的实现多线程的方式\" class=\"headerlink\" title=\"2. 常用的实现多线程的方式\"></a>2. 常用的实现多线程的方式</h3><p>常用的主要有俩种：Thread类 和Runnable接口</p>\n<h3 id=\"Thread和Runnable简介\"><a href=\"#Thread和Runnable简介\" class=\"headerlink\" title=\"Thread和Runnable简介\"></a><strong>Thread和Runnable简介</strong></h3><p><strong>Runnable</strong> 是一个接口，该接口中只包含了一个run()方法。它的定义如下：</p>\n<pre><code>public interface Runnable {\n    public abstract void run();\n}\n</code></pre><p>Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；</p>\n<p>然后，通过<code>new Thread(new A())</code>等方式新建线程。</p>\n<p><strong>Thread</strong> 是一个类。Thread本身就实现了Runnable接口。它的声明如下：</p>\n<pre><code>public class Thread implements Runnable {\n\n}\n</code></pre><p>Thread的作用，实现多线程。</p>\n<h3 id=\"Thread和Runnable的异同点\"><a href=\"#Thread和Runnable的异同点\" class=\"headerlink\" title=\"Thread和Runnable的异同点\"></a><strong>Thread和Runnable的异同点</strong></h3><p><strong>Thread 和 Runnable 的相同点</strong>：都是“多线程的实现方式”。</p>\n<p> <strong>Thread 和 Runnable 的不同点</strong>： Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。</p>\n<p> 此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。 </p>\n<p>通常，建议通过“Runnable”实现多线程！</p>\n<h3 id=\"Thread和Runnable的多线程示例\"><a href=\"#Thread和Runnable的多线程示例\" class=\"headerlink\" title=\"Thread和Runnable的多线程示例\"></a><strong>Thread和Runnable的多线程示例</strong></h3><h4 id=\"Thread的多线程示例\"><a href=\"#Thread的多线程示例\" class=\"headerlink\" title=\"Thread的多线程示例\"></a>Thread的多线程示例</h4><pre><code>class MyThread extends Thread{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i&lt;20;i++){ \n            if(this.ticket&gt;0){\n                System.out.println(this.getName()+&quot; 卖票：ticket&quot;+this.ticket--);\n            }\n        }\n    } \n};\n\npublic class ThreadTest {  \n    public static void main(String[] args) {  \n        // 创建3个线程,每个线程各卖10张票！\n        MyThread t1=new MyThread();\n        MyThread t2=new MyThread();\n        MyThread t3=new MyThread();\n        //启动线程，开始运行\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n</code></pre><h4 id=\"Runnable的多线程示例\"><a href=\"#Runnable的多线程示例\" class=\"headerlink\" title=\"Runnable的多线程示例\"></a><strong>Runnable的多线程示例</strong></h4><pre><code>// 实现Runnable接口\nclass MyThread implements Runnable{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i&lt;20;i++){ \n            if(this.ticket&gt;0){\n                System.out.println(Thread.currentThread().getName()\n                 +&quot; 卖票：ticket&quot;+this.ticket--);\n            }\n        }\n    } \n}; \n\npublic class RunnableTest {  \n    public static void main(String[] args) {  \n\n        //创建实现了Runnable接口的对象\n        MyThread mt=new MyThread();\n\n        // 创建3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！\n        Thread t1=new Thread(mt);\n        Thread t2=new Thread(mt);\n        Thread t3=new Thread(mt);\n        //启动3个线程\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n</code></pre><p><strong>结果说明</strong>： </p>\n<ol>\n<li><p>和上面“MyThread继承于Thread”不同；这里的MyThread实现了Runnable接口。 </p>\n</li>\n<li><p>主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。</p>\n</li>\n</ol>\n<h4 id=\"注意的是-上面不是线程安全的操作\"><a href=\"#注意的是-上面不是线程安全的操作\" class=\"headerlink\" title=\"注意的是:上面不是线程安全的操作\"></a>注意的是:上面不是线程安全的操作</h4><h3 id=\"3-Thread中start-和run-的区别\"><a href=\"#3-Thread中start-和run-的区别\" class=\"headerlink\" title=\"3. Thread中start()和run()的区别\"></a>3. Thread中start()和run()的区别</h3><p><strong>start()</strong> : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。</p>\n<p> <strong>run()</strong>   : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！</p>\n<p>后面会将Thread类的源码拿出来单独解析说明。这里只是简单的提一下。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java-多线程的基本概念以及实现方式\"><a href=\"#java-多线程的基本概念以及实现方式\" class=\"headerlink\" title=\"java 多线程的基本概念以及实现方式\"></a>java 多线程的基本概念以及实现方式</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><ol>\n<li>线程的基本概念</li>\n<li>常用的实现多线程的方式</li>\n<li>Thread中start()和run()的区别</li>\n</ol>\n<h3 id=\"1-线程的基本概念\"><a href=\"#1-线程的基本概念\" class=\"headerlink\" title=\"1. 线程的基本概念\"></a>1. 线程的基本概念</h3><p>线程状态图</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18152411-a974ea82ebc04e72bd874c3921f8bfec.jpg\" alt=\"\"></p>\n<p><strong>说明</strong>：<br>线程共包括以下5种状态。</p>\n<ol>\n<li><strong>新建状态(New)</strong>         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</li>\n<li><strong>就绪状态(Runnable)</strong>: 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li>\n<li><strong>运行状态(Running)</strong> : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li>\n<li><strong>阻塞状态(Blocked)</strong>  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ol>\n<li>等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li>\n<li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li>\n<li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>\n</ol>\n</li>\n<li><strong>死亡状态(Dead)</strong>    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。需要注意的是，<strong>线程一旦进入死亡状态就不能在调用start()方法来让线程恢复运行。</strong><br>这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。这些内容我们会在后面的章节中逐个进行学习。</li>\n</ol>\n<p><strong>Object类</strong>，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。<br><strong>Thread类</strong>，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。<br><strong>synchronized</strong>，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。<br>在后面详细介绍wait(),notify()等方法时，我们会分析为什么<strong>wait(), notify()等方法要定义在Object类，而不是Thread类中</strong>。</p>\n<h3 id=\"2-常用的实现多线程的方式\"><a href=\"#2-常用的实现多线程的方式\" class=\"headerlink\" title=\"2. 常用的实现多线程的方式\"></a>2. 常用的实现多线程的方式</h3><p>常用的主要有俩种：Thread类 和Runnable接口</p>\n<h3 id=\"Thread和Runnable简介\"><a href=\"#Thread和Runnable简介\" class=\"headerlink\" title=\"Thread和Runnable简介\"></a><strong>Thread和Runnable简介</strong></h3><p><strong>Runnable</strong> 是一个接口，该接口中只包含了一个run()方法。它的定义如下：</p>\n<pre><code>public interface Runnable {\n    public abstract void run();\n}\n</code></pre><p>Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；</p>\n<p>然后，通过<code>new Thread(new A())</code>等方式新建线程。</p>\n<p><strong>Thread</strong> 是一个类。Thread本身就实现了Runnable接口。它的声明如下：</p>\n<pre><code>public class Thread implements Runnable {\n\n}\n</code></pre><p>Thread的作用，实现多线程。</p>\n<h3 id=\"Thread和Runnable的异同点\"><a href=\"#Thread和Runnable的异同点\" class=\"headerlink\" title=\"Thread和Runnable的异同点\"></a><strong>Thread和Runnable的异同点</strong></h3><p><strong>Thread 和 Runnable 的相同点</strong>：都是“多线程的实现方式”。</p>\n<p> <strong>Thread 和 Runnable 的不同点</strong>： Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。</p>\n<p> 此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。 </p>\n<p>通常，建议通过“Runnable”实现多线程！</p>\n<h3 id=\"Thread和Runnable的多线程示例\"><a href=\"#Thread和Runnable的多线程示例\" class=\"headerlink\" title=\"Thread和Runnable的多线程示例\"></a><strong>Thread和Runnable的多线程示例</strong></h3><h4 id=\"Thread的多线程示例\"><a href=\"#Thread的多线程示例\" class=\"headerlink\" title=\"Thread的多线程示例\"></a>Thread的多线程示例</h4><pre><code>class MyThread extends Thread{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i&lt;20;i++){ \n            if(this.ticket&gt;0){\n                System.out.println(this.getName()+&quot; 卖票：ticket&quot;+this.ticket--);\n            }\n        }\n    } \n};\n\npublic class ThreadTest {  \n    public static void main(String[] args) {  \n        // 创建3个线程,每个线程各卖10张票！\n        MyThread t1=new MyThread();\n        MyThread t2=new MyThread();\n        MyThread t3=new MyThread();\n        //启动线程，开始运行\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n</code></pre><h4 id=\"Runnable的多线程示例\"><a href=\"#Runnable的多线程示例\" class=\"headerlink\" title=\"Runnable的多线程示例\"></a><strong>Runnable的多线程示例</strong></h4><pre><code>// 实现Runnable接口\nclass MyThread implements Runnable{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i&lt;20;i++){ \n            if(this.ticket&gt;0){\n                System.out.println(Thread.currentThread().getName()\n                 +&quot; 卖票：ticket&quot;+this.ticket--);\n            }\n        }\n    } \n}; \n\npublic class RunnableTest {  \n    public static void main(String[] args) {  \n\n        //创建实现了Runnable接口的对象\n        MyThread mt=new MyThread();\n\n        // 创建3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！\n        Thread t1=new Thread(mt);\n        Thread t2=new Thread(mt);\n        Thread t3=new Thread(mt);\n        //启动3个线程\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n</code></pre><p><strong>结果说明</strong>： </p>\n<ol>\n<li><p>和上面“MyThread继承于Thread”不同；这里的MyThread实现了Runnable接口。 </p>\n</li>\n<li><p>主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。</p>\n</li>\n</ol>\n<h4 id=\"注意的是-上面不是线程安全的操作\"><a href=\"#注意的是-上面不是线程安全的操作\" class=\"headerlink\" title=\"注意的是:上面不是线程安全的操作\"></a>注意的是:上面不是线程安全的操作</h4><h3 id=\"3-Thread中start-和run-的区别\"><a href=\"#3-Thread中start-和run-的区别\" class=\"headerlink\" title=\"3. Thread中start()和run()的区别\"></a>3. Thread中start()和run()的区别</h3><p><strong>start()</strong> : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。</p>\n<p> <strong>run()</strong>   : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！</p>\n<p>后面会将Thread类的源码拿出来单独解析说明。这里只是简单的提一下。</p>\n"},{"abbrlink":3,"title":"java多线程系列 06  线程优先级和守护线程","author":"zhangke","date":"2018-07-13T03:16:00.000Z","_content":"# java多线程系列 06  线程优先级和守护线程\n\n### **概要**\n\n> 1. 线程优先级的介绍\n> 2. 线程优先级的示例\n> 3. 守护线程的示例\n\n### **1. 线程优先级的介绍**\n\n> java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。\n>\n> java 中有两种线程：**用户线程**和**守护线程**。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。\n> 用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。\n>\n> JDK 中关于线程优先级和守护线程的介绍如下：\n>\n> ```\n> Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.\n> \n> When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:\n> \n> The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.\n> All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. \n> Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.\n> ```\n>\n> 大致意思是：\n>\n> ```\n> 每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。\n> \n> 当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：\n> (01) 调用了exit()方法，并且exit()有权限被正常执行。\n> (02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。\n> \n> 每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。\n> ```\n>\n> \n>\n>  \n\n### **2. 线程优先级的示例**\n\n我们先看看优先级的示例 \n\n```\nclass MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        for (int i=0; i<5; i++) {\n            System.out.println(Thread.currentThread().getName()\n                    +\"(\"+Thread.currentThread().getPriority()+ \")\"\n                    +\", loop \"+i);\n        }\n    } \n}; \n\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +\"(\"+Thread.currentThread().getPriority()+ \")\");\n\n        Thread t1=new MyThread(\"t1\");    // 新建t1\n        Thread t2=new MyThread(\"t2\");    // 新建t2\n        t1.setPriority(1);                // 设置t1的优先级为1\n        t2.setPriority(10);                // 设置t2的优先级为10\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}\n```\n\n**运行结果**：\n\n```\nmain(5)\nt1(1), loop 0\nt2(10), loop 0\nt1(1), loop 1\nt2(10), loop 1\nt1(1), loop 2\nt2(10), loop 2\nt1(1), loop 3\nt2(10), loop 3\nt1(1), loop 4\nt2(10), loop 4\n```\n\n**结果说明**：\n(01) 主线程main的优先级是5。\n(02) t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。\n\n### **3. 守护线程的示例**\n\n下面是守护线程的示例。\n\n```\n// Demo.java\nclass MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i<5; i++) {\n                Thread.sleep(3);\n                System.out.println(this.getName() \n                \t\t\t+\"(isDaemon=\"+this.isDaemon()+ \")\" \n                \t\t\t+\", loop \"+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}; \n\nclass MyDaemon extends Thread{  \n    public MyDaemon(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i<10000; i++) {\n                Thread.sleep(1);\n                System.out.println(this.getName() +\"(isDaemon=\"+this.isDaemon()+\n                \t\t\")\" +\", loop \"+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +\"(isDaemon=\"+Thread.currentThread().isDaemon()+ \")\");\n\n        Thread t1=new MyThread(\"t1\");    // 新建t1\n        Thread t2=new MyDaemon(\"t2\");    // 新建t2\n        t2.setDaemon(true);                // 设置t2为守护线程\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}=\n```\n\n**运行结果**：\n\n```\nmain(isDaemon=false)\nt2(isDaemon=true), loop 0\nt2(isDaemon=true), loop 1\nt1(isDaemon=false), loop 0\nt2(isDaemon=true), loop 2\nt2(isDaemon=true), loop 3\nt1(isDaemon=false), loop 1\nt2(isDaemon=true), loop 4\nt2(isDaemon=true), loop 5\nt2(isDaemon=true), loop 6\nt1(isDaemon=false), loop 2\nt2(isDaemon=true), loop 7\nt2(isDaemon=true), loop 8\nt2(isDaemon=true), loop 9\nt1(isDaemon=false), loop 3\nt2(isDaemon=true), loop 10\nt2(isDaemon=true), loop 11\nt1(isDaemon=false), loop 4\nt2(isDaemon=true), loop 12\n```\n\n**结果说明**：\n(01) 主线程main是用户线程，它创建的子线程t1也是用户线程。\n(02) t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。\n\n ","source":"_posts/threads/java多线程系列 06  线程优先级和守护线程.md","raw":"abbrlink: 3\ntitle: java多线程系列 06  线程优先级和守护线程\ntags:\n\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-13 11:16:00\n---\n# java多线程系列 06  线程优先级和守护线程\n\n### **概要**\n\n> 1. 线程优先级的介绍\n> 2. 线程优先级的示例\n> 3. 守护线程的示例\n\n### **1. 线程优先级的介绍**\n\n> java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。\n>\n> java 中有两种线程：**用户线程**和**守护线程**。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。\n> 用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。\n>\n> JDK 中关于线程优先级和守护线程的介绍如下：\n>\n> ```\n> Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.\n> \n> When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:\n> \n> The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.\n> All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. \n> Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.\n> ```\n>\n> 大致意思是：\n>\n> ```\n> 每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。\n> \n> 当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：\n> (01) 调用了exit()方法，并且exit()有权限被正常执行。\n> (02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。\n> \n> 每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。\n> ```\n>\n> \n>\n>  \n\n### **2. 线程优先级的示例**\n\n我们先看看优先级的示例 \n\n```\nclass MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        for (int i=0; i<5; i++) {\n            System.out.println(Thread.currentThread().getName()\n                    +\"(\"+Thread.currentThread().getPriority()+ \")\"\n                    +\", loop \"+i);\n        }\n    } \n}; \n\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +\"(\"+Thread.currentThread().getPriority()+ \")\");\n\n        Thread t1=new MyThread(\"t1\");    // 新建t1\n        Thread t2=new MyThread(\"t2\");    // 新建t2\n        t1.setPriority(1);                // 设置t1的优先级为1\n        t2.setPriority(10);                // 设置t2的优先级为10\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}\n```\n\n**运行结果**：\n\n```\nmain(5)\nt1(1), loop 0\nt2(10), loop 0\nt1(1), loop 1\nt2(10), loop 1\nt1(1), loop 2\nt2(10), loop 2\nt1(1), loop 3\nt2(10), loop 3\nt1(1), loop 4\nt2(10), loop 4\n```\n\n**结果说明**：\n(01) 主线程main的优先级是5。\n(02) t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。\n\n### **3. 守护线程的示例**\n\n下面是守护线程的示例。\n\n```\n// Demo.java\nclass MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i<5; i++) {\n                Thread.sleep(3);\n                System.out.println(this.getName() \n                \t\t\t+\"(isDaemon=\"+this.isDaemon()+ \")\" \n                \t\t\t+\", loop \"+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}; \n\nclass MyDaemon extends Thread{  \n    public MyDaemon(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i<10000; i++) {\n                Thread.sleep(1);\n                System.out.println(this.getName() +\"(isDaemon=\"+this.isDaemon()+\n                \t\t\")\" +\", loop \"+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +\"(isDaemon=\"+Thread.currentThread().isDaemon()+ \")\");\n\n        Thread t1=new MyThread(\"t1\");    // 新建t1\n        Thread t2=new MyDaemon(\"t2\");    // 新建t2\n        t2.setDaemon(true);                // 设置t2为守护线程\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}=\n```\n\n**运行结果**：\n\n```\nmain(isDaemon=false)\nt2(isDaemon=true), loop 0\nt2(isDaemon=true), loop 1\nt1(isDaemon=false), loop 0\nt2(isDaemon=true), loop 2\nt2(isDaemon=true), loop 3\nt1(isDaemon=false), loop 1\nt2(isDaemon=true), loop 4\nt2(isDaemon=true), loop 5\nt2(isDaemon=true), loop 6\nt1(isDaemon=false), loop 2\nt2(isDaemon=true), loop 7\nt2(isDaemon=true), loop 8\nt2(isDaemon=true), loop 9\nt1(isDaemon=false), loop 3\nt2(isDaemon=true), loop 10\nt2(isDaemon=true), loop 11\nt1(isDaemon=false), loop 4\nt2(isDaemon=true), loop 12\n```\n\n**结果说明**：\n(01) 主线程main是用户线程，它创建的子线程t1也是用户线程。\n(02) t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。\n\n ","slug":"threads/java多线程系列 06  线程优先级和守护线程","published":1,"updated":"2019-01-04T01:48:59.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovqy00269q1uqj249d33","content":"<h1 id=\"java多线程系列-06-线程优先级和守护线程\"><a href=\"#java多线程系列-06-线程优先级和守护线程\" class=\"headerlink\" title=\"java多线程系列 06  线程优先级和守护线程\"></a>java多线程系列 06  线程优先级和守护线程</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a><strong>概要</strong></h3><blockquote>\n<ol>\n<li>线程优先级的介绍</li>\n<li>线程优先级的示例</li>\n<li>守护线程的示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程优先级的介绍\"><a href=\"#1-线程优先级的介绍\" class=\"headerlink\" title=\"1. 线程优先级的介绍\"></a><strong>1. 线程优先级的介绍</strong></h3><blockquote>\n<p>java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。</p>\n<p>java 中有两种线程：<strong>用户线程</strong>和<strong>守护线程</strong>。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。<br>用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。</p>\n<p>JDK 中关于线程优先级和守护线程的介绍如下：</p>\n<pre><code>Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.\n\nWhen a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:\n\nThe exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.\nAll threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. \nMarks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.\n</code></pre><p>大致意思是：</p>\n<pre><code>每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。\n\n当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：\n(01) 调用了exit()方法，并且exit()有权限被正常执行。\n(02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。\n\n每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。\n</code></pre></blockquote>\n<h3 id=\"2-线程优先级的示例\"><a href=\"#2-线程优先级的示例\" class=\"headerlink\" title=\"2. 线程优先级的示例\"></a><strong>2. 线程优先级的示例</strong></h3><p>我们先看看优先级的示例 </p>\n<pre><code>class MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        for (int i=0; i&lt;5; i++) {\n            System.out.println(Thread.currentThread().getName()\n                    +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot;\n                    +&quot;, loop &quot;+i);\n        }\n    } \n}; \n\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot;);\n\n        Thread t1=new MyThread(&quot;t1&quot;);    // 新建t1\n        Thread t2=new MyThread(&quot;t2&quot;);    // 新建t2\n        t1.setPriority(1);                // 设置t1的优先级为1\n        t2.setPriority(10);                // 设置t2的优先级为10\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>main(5)\nt1(1), loop 0\nt2(10), loop 0\nt1(1), loop 1\nt2(10), loop 1\nt1(1), loop 2\nt2(10), loop 2\nt1(1), loop 3\nt2(10), loop 3\nt1(1), loop 4\nt2(10), loop 4\n</code></pre><p><strong>结果说明</strong>：<br>(01) 主线程main的优先级是5。<br>(02) t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。</p>\n<h3 id=\"3-守护线程的示例\"><a href=\"#3-守护线程的示例\" class=\"headerlink\" title=\"3. 守护线程的示例\"></a><strong>3. 守护线程的示例</strong></h3><p>下面是守护线程的示例。</p>\n<pre><code>// Demo.java\nclass MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i&lt;5; i++) {\n                Thread.sleep(3);\n                System.out.println(this.getName() \n                            +&quot;(isDaemon=&quot;+this.isDaemon()+ &quot;)&quot; \n                            +&quot;, loop &quot;+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}; \n\nclass MyDaemon extends Thread{  \n    public MyDaemon(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i&lt;10000; i++) {\n                Thread.sleep(1);\n                System.out.println(this.getName() +&quot;(isDaemon=&quot;+this.isDaemon()+\n                        &quot;)&quot; +&quot;, loop &quot;+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +&quot;(isDaemon=&quot;+Thread.currentThread().isDaemon()+ &quot;)&quot;);\n\n        Thread t1=new MyThread(&quot;t1&quot;);    // 新建t1\n        Thread t2=new MyDaemon(&quot;t2&quot;);    // 新建t2\n        t2.setDaemon(true);                // 设置t2为守护线程\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}=\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>main(isDaemon=false)\nt2(isDaemon=true), loop 0\nt2(isDaemon=true), loop 1\nt1(isDaemon=false), loop 0\nt2(isDaemon=true), loop 2\nt2(isDaemon=true), loop 3\nt1(isDaemon=false), loop 1\nt2(isDaemon=true), loop 4\nt2(isDaemon=true), loop 5\nt2(isDaemon=true), loop 6\nt1(isDaemon=false), loop 2\nt2(isDaemon=true), loop 7\nt2(isDaemon=true), loop 8\nt2(isDaemon=true), loop 9\nt1(isDaemon=false), loop 3\nt2(isDaemon=true), loop 10\nt2(isDaemon=true), loop 11\nt1(isDaemon=false), loop 4\nt2(isDaemon=true), loop 12\n</code></pre><p><strong>结果说明</strong>：<br>(01) 主线程main是用户线程，它创建的子线程t1也是用户线程。<br>(02) t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-06-线程优先级和守护线程\"><a href=\"#java多线程系列-06-线程优先级和守护线程\" class=\"headerlink\" title=\"java多线程系列 06  线程优先级和守护线程\"></a>java多线程系列 06  线程优先级和守护线程</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a><strong>概要</strong></h3><blockquote>\n<ol>\n<li>线程优先级的介绍</li>\n<li>线程优先级的示例</li>\n<li>守护线程的示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程优先级的介绍\"><a href=\"#1-线程优先级的介绍\" class=\"headerlink\" title=\"1. 线程优先级的介绍\"></a><strong>1. 线程优先级的介绍</strong></h3><blockquote>\n<p>java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。</p>\n<p>java 中有两种线程：<strong>用户线程</strong>和<strong>守护线程</strong>。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。<br>用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。</p>\n<p>JDK 中关于线程优先级和守护线程的介绍如下：</p>\n<pre><code>Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.\n\nWhen a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:\n\nThe exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.\nAll threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. \nMarks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.\n</code></pre><p>大致意思是：</p>\n<pre><code>每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。\n\n当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：\n(01) 调用了exit()方法，并且exit()有权限被正常执行。\n(02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。\n\n每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。\n</code></pre></blockquote>\n<h3 id=\"2-线程优先级的示例\"><a href=\"#2-线程优先级的示例\" class=\"headerlink\" title=\"2. 线程优先级的示例\"></a><strong>2. 线程优先级的示例</strong></h3><p>我们先看看优先级的示例 </p>\n<pre><code>class MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        for (int i=0; i&lt;5; i++) {\n            System.out.println(Thread.currentThread().getName()\n                    +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot;\n                    +&quot;, loop &quot;+i);\n        }\n    } \n}; \n\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot;);\n\n        Thread t1=new MyThread(&quot;t1&quot;);    // 新建t1\n        Thread t2=new MyThread(&quot;t2&quot;);    // 新建t2\n        t1.setPriority(1);                // 设置t1的优先级为1\n        t2.setPriority(10);                // 设置t2的优先级为10\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>main(5)\nt1(1), loop 0\nt2(10), loop 0\nt1(1), loop 1\nt2(10), loop 1\nt1(1), loop 2\nt2(10), loop 2\nt1(1), loop 3\nt2(10), loop 3\nt1(1), loop 4\nt2(10), loop 4\n</code></pre><p><strong>结果说明</strong>：<br>(01) 主线程main的优先级是5。<br>(02) t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。</p>\n<h3 id=\"3-守护线程的示例\"><a href=\"#3-守护线程的示例\" class=\"headerlink\" title=\"3. 守护线程的示例\"></a><strong>3. 守护线程的示例</strong></h3><p>下面是守护线程的示例。</p>\n<pre><code>// Demo.java\nclass MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i&lt;5; i++) {\n                Thread.sleep(3);\n                System.out.println(this.getName() \n                            +&quot;(isDaemon=&quot;+this.isDaemon()+ &quot;)&quot; \n                            +&quot;, loop &quot;+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}; \n\nclass MyDaemon extends Thread{  \n    public MyDaemon(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i&lt;10000; i++) {\n                Thread.sleep(1);\n                System.out.println(this.getName() +&quot;(isDaemon=&quot;+this.isDaemon()+\n                        &quot;)&quot; +&quot;, loop &quot;+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +&quot;(isDaemon=&quot;+Thread.currentThread().isDaemon()+ &quot;)&quot;);\n\n        Thread t1=new MyThread(&quot;t1&quot;);    // 新建t1\n        Thread t2=new MyDaemon(&quot;t2&quot;);    // 新建t2\n        t2.setDaemon(true);                // 设置t2为守护线程\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}=\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>main(isDaemon=false)\nt2(isDaemon=true), loop 0\nt2(isDaemon=true), loop 1\nt1(isDaemon=false), loop 0\nt2(isDaemon=true), loop 2\nt2(isDaemon=true), loop 3\nt1(isDaemon=false), loop 1\nt2(isDaemon=true), loop 4\nt2(isDaemon=true), loop 5\nt2(isDaemon=true), loop 6\nt1(isDaemon=false), loop 2\nt2(isDaemon=true), loop 7\nt2(isDaemon=true), loop 8\nt2(isDaemon=true), loop 9\nt1(isDaemon=false), loop 3\nt2(isDaemon=true), loop 10\nt2(isDaemon=true), loop 11\nt1(isDaemon=false), loop 4\nt2(isDaemon=true), loop 12\n</code></pre><p><strong>结果说明</strong>：<br>(01) 主线程main是用户线程，它创建的子线程t1也是用户线程。<br>(02) t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。</p>\n"},{"abbrlink":8,"title":"java多线程系列 08 ThreadLocal","author":"zhangke","date":"2018-07-13T08:50:00.000Z","_content":"# java多线程系列之 08 ThreadLocal\n\n### 概要\n\n>1. ThreadLocal介绍\n>2. 基本用法\n>3. ThreadLocal引起的内存泄漏\n\n### ThreadLocal 介绍\n\n>ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被GC。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal通常定义为`private static`类型。\n\n### 2. 基本用法\n\n>```\n>public class ThreadLocalTest {\n>    public static void main(String[] args) {\n>        for (int i = 0; i < 10; i++) {\n>            new Thread() {\n>                public void run() {\n>                    ThreadId id = new ThreadId();\n>                    System.out.println(id.get());\n>                }\n>            }.start();\n>        }\n>    }\n>}\n>class ThreadId {\n>    // Atomic integer containing the next thread ID to be assigned\n>    private static final AtomicInteger nextId = new AtomicInteger(0);\n>\n>    // Thread local variable containing each thread's ID\n>    private static final ThreadLocal<Integer> threadId =\n>        new ThreadLocal<Integer>() {\n>            @Override\n>            protected Integer initialValue() {\n>                return nextId.getAndIncrement();\n>            }\n>        };\n>\n>    // Returns the current thread's unique ID, assigning it if necessary\n>    public int get() {\n>        return threadId.get();\n>    }\n>}\n>```\n>\n>运行结果：\n>\n>```\n>9\n>7\n>6\n>8\n>2\n>4\n>0\n>3\n>5\n>1\n>```\n>\n>虽然ThreadLocal对象时static的，但是由于是每个线程独有的，所以各自线程对应的ThreadLocal属性改变，不会影响其他线程的值，因此可以说是线程私有的。也正是因为此，上面的结果才是10个不一样的值。\n>\n>那么，在什么场景下比较适合使用ThreadLocal？stackoverflow上有人给出了还不错的回答。\n> [When and how should I use a ThreadLocal variable?](https://link.jianshu.com?t=http://stackoverflow.com/questions/817856/when-and-how-should-i-use-a-threadlocal-variable)\n> One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid synchronizing access to that object . Instead, give each thread its own instance of the object. \n>\n>\n\n## ThreadLocal引起的内存泄漏\n\n> `ThreadLocal` 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但是如果滥用`ThreadLocal`，就可能会导致内存泄漏。下面，我们将围绕三个方面来分析`ThreadLocal` 内存泄漏的问题\n>\n> - `ThreadLocal` 实现原理\n> - `ThreadLocal`为什么会内存泄漏\n> - `ThreadLocal` 最佳实践\n>\n> ## ThreadLocal 实现原理\n>\n> [![threadlocal](http://incdn1.b0.upaiyun.com/2016/10/2fdbd552107780c5ae5f98126b38d5a4.png)](http://www.importnew.com/?attachment_id=22042)\n>\n> ThreadLocal\n>\n> `ThreadLocal`的实现是这样的：每个`Thread` 维护一个 `ThreadLocalMap` 映射表，这个映射表的 `key` 是 `ThreadLocal`实例本身，`value` 是真正需要存储的 `Object`。\n>\n> 也就是说 `ThreadLocal` 本身并不存储值，它只是作为一个 `key` 来让线程从 `ThreadLocalMap` 获取 `value`。值得注意的是图中的虚线，表示 `ThreadLocalMap` 是使用 `ThreadLocal` 的弱引用作为 `Key` 的，弱引用的对象在 GC 时会被回收。\n>\n> ## `ThreadLocal`为什么会内存泄漏\n>\n> `ThreadLocalMap`使用`ThreadLocal`的弱引用作为`key`，如果一个`ThreadLocal`没有外部强引用来引用它，那么系统 GC 的时候，这个`ThreadLocal`势必会被回收，这样一来，`ThreadLocalMap`中就会出现`key`为`null`的`Entry`，就没有办法访问这些`key`为`null`的`Entry`的`value`，如果当前线程再迟迟不结束的话，这些`key`为`null`的`Entry`的`value`就会一直存在一条强引用链：`Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value`永远无法回收，造成内存泄漏。\n>\n> 其实，`ThreadLocalMap`的设计中已经考虑到这种情况，也加上了一些防护措施：在`ThreadLocal`的`get()`,`set()`,`remove()`的时候都会清除线程`ThreadLocalMap`里所有`key`为`null`的`value`。\n>\n> 但是这些被动的预防措施并不能保证不会内存泄漏：\n>\n> - 使用`static`的`ThreadLocal`，延长了`ThreadLocal`的生命周期，可能导致的内存泄漏（参考[ThreadLocal 内存泄露的实例分析](http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/)）。\n> - 分配使用了`ThreadLocal`又不再调用`get()`,`set()`,`remove()`方法，那么就会导致内存泄漏。\n>\n> ### 为什么使用弱引用\n>\n> 从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析`ThreadLocal`使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？\n>\n> 我们先来看看官方文档的说法：\n>\n> > To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.\n> > 为了应对非常大和长时间的用途，哈希表使用弱引用的 key。\n>\n> 下面我们分两种情况讨论：\n>\n> - **key 使用强引用**：引用的`ThreadLocal`的对象被回收了，但是`ThreadLocalMap`还持有`ThreadLocal`的强引用，如果没有手动删除，`ThreadLocal`不会被回收，导致`Entry`内存泄漏。\n> - **key 使用弱引用**：引用的`ThreadLocal`的对象被回收了，由于`ThreadLocalMap`持有`ThreadLocal`的弱引用，即使没有手动删除，`ThreadLocal`也会被回收。`value`在下一次`ThreadLocalMap`调用`set`,`get`，`remove`的时候会被清除。\n>\n> 比较两种情况，我们可以发现：由于`ThreadLocalMap`的生命周期跟`Thread`一样长，如果都没有手动删除对应`key`，都会导致内存泄漏，但是使用弱引用可以多一层保障：**弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除**。\n>\n> 因此，`ThreadLocal`内存泄漏的根源是：由于`ThreadLocalMap`的生命周期跟`Thread`一样长，如果没有手动删除对应`key`就会导致内存泄漏，而不是因为弱引用。\n>\n> ## ThreadLocal 最佳实践\n>\n> 综合上面的分析，我们可以理解`ThreadLocal`内存泄漏的前因后果，那么怎么避免内存泄漏呢？\n>\n> - 每次使用完`ThreadLocal`，都调用它的`remove()`方法，清除数据。\n>\n> 在使用线程池的情况下，没有及时清理`ThreadLocal`，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用`ThreadLocal`就跟加锁完要解锁一样，用完就清理。\n\n参考文章\n\n[深入分析 ThreadLocal 内存泄漏问题](http://www.importnew.com/22039.html)\n\n[ThreadLocal 内存泄露的实例分析](http://www.importnew.com/22046.html)\n\n[ThreadLocal内存泄露](http://www.importnew.com/22480.html)\n\n\n\n\n\n","source":"_posts/threads/java多线程系列之 08 ThreadLocal.md","raw":"abbrlink: 8\ntitle: java多线程系列 08 ThreadLocal\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-13 16:50:00\n---\n# java多线程系列之 08 ThreadLocal\n\n### 概要\n\n>1. ThreadLocal介绍\n>2. 基本用法\n>3. ThreadLocal引起的内存泄漏\n\n### ThreadLocal 介绍\n\n>ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被GC。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal通常定义为`private static`类型。\n\n### 2. 基本用法\n\n>```\n>public class ThreadLocalTest {\n>    public static void main(String[] args) {\n>        for (int i = 0; i < 10; i++) {\n>            new Thread() {\n>                public void run() {\n>                    ThreadId id = new ThreadId();\n>                    System.out.println(id.get());\n>                }\n>            }.start();\n>        }\n>    }\n>}\n>class ThreadId {\n>    // Atomic integer containing the next thread ID to be assigned\n>    private static final AtomicInteger nextId = new AtomicInteger(0);\n>\n>    // Thread local variable containing each thread's ID\n>    private static final ThreadLocal<Integer> threadId =\n>        new ThreadLocal<Integer>() {\n>            @Override\n>            protected Integer initialValue() {\n>                return nextId.getAndIncrement();\n>            }\n>        };\n>\n>    // Returns the current thread's unique ID, assigning it if necessary\n>    public int get() {\n>        return threadId.get();\n>    }\n>}\n>```\n>\n>运行结果：\n>\n>```\n>9\n>7\n>6\n>8\n>2\n>4\n>0\n>3\n>5\n>1\n>```\n>\n>虽然ThreadLocal对象时static的，但是由于是每个线程独有的，所以各自线程对应的ThreadLocal属性改变，不会影响其他线程的值，因此可以说是线程私有的。也正是因为此，上面的结果才是10个不一样的值。\n>\n>那么，在什么场景下比较适合使用ThreadLocal？stackoverflow上有人给出了还不错的回答。\n> [When and how should I use a ThreadLocal variable?](https://link.jianshu.com?t=http://stackoverflow.com/questions/817856/when-and-how-should-i-use-a-threadlocal-variable)\n> One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid synchronizing access to that object . Instead, give each thread its own instance of the object. \n>\n>\n\n## ThreadLocal引起的内存泄漏\n\n> `ThreadLocal` 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但是如果滥用`ThreadLocal`，就可能会导致内存泄漏。下面，我们将围绕三个方面来分析`ThreadLocal` 内存泄漏的问题\n>\n> - `ThreadLocal` 实现原理\n> - `ThreadLocal`为什么会内存泄漏\n> - `ThreadLocal` 最佳实践\n>\n> ## ThreadLocal 实现原理\n>\n> [![threadlocal](http://incdn1.b0.upaiyun.com/2016/10/2fdbd552107780c5ae5f98126b38d5a4.png)](http://www.importnew.com/?attachment_id=22042)\n>\n> ThreadLocal\n>\n> `ThreadLocal`的实现是这样的：每个`Thread` 维护一个 `ThreadLocalMap` 映射表，这个映射表的 `key` 是 `ThreadLocal`实例本身，`value` 是真正需要存储的 `Object`。\n>\n> 也就是说 `ThreadLocal` 本身并不存储值，它只是作为一个 `key` 来让线程从 `ThreadLocalMap` 获取 `value`。值得注意的是图中的虚线，表示 `ThreadLocalMap` 是使用 `ThreadLocal` 的弱引用作为 `Key` 的，弱引用的对象在 GC 时会被回收。\n>\n> ## `ThreadLocal`为什么会内存泄漏\n>\n> `ThreadLocalMap`使用`ThreadLocal`的弱引用作为`key`，如果一个`ThreadLocal`没有外部强引用来引用它，那么系统 GC 的时候，这个`ThreadLocal`势必会被回收，这样一来，`ThreadLocalMap`中就会出现`key`为`null`的`Entry`，就没有办法访问这些`key`为`null`的`Entry`的`value`，如果当前线程再迟迟不结束的话，这些`key`为`null`的`Entry`的`value`就会一直存在一条强引用链：`Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value`永远无法回收，造成内存泄漏。\n>\n> 其实，`ThreadLocalMap`的设计中已经考虑到这种情况，也加上了一些防护措施：在`ThreadLocal`的`get()`,`set()`,`remove()`的时候都会清除线程`ThreadLocalMap`里所有`key`为`null`的`value`。\n>\n> 但是这些被动的预防措施并不能保证不会内存泄漏：\n>\n> - 使用`static`的`ThreadLocal`，延长了`ThreadLocal`的生命周期，可能导致的内存泄漏（参考[ThreadLocal 内存泄露的实例分析](http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/)）。\n> - 分配使用了`ThreadLocal`又不再调用`get()`,`set()`,`remove()`方法，那么就会导致内存泄漏。\n>\n> ### 为什么使用弱引用\n>\n> 从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析`ThreadLocal`使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？\n>\n> 我们先来看看官方文档的说法：\n>\n> > To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.\n> > 为了应对非常大和长时间的用途，哈希表使用弱引用的 key。\n>\n> 下面我们分两种情况讨论：\n>\n> - **key 使用强引用**：引用的`ThreadLocal`的对象被回收了，但是`ThreadLocalMap`还持有`ThreadLocal`的强引用，如果没有手动删除，`ThreadLocal`不会被回收，导致`Entry`内存泄漏。\n> - **key 使用弱引用**：引用的`ThreadLocal`的对象被回收了，由于`ThreadLocalMap`持有`ThreadLocal`的弱引用，即使没有手动删除，`ThreadLocal`也会被回收。`value`在下一次`ThreadLocalMap`调用`set`,`get`，`remove`的时候会被清除。\n>\n> 比较两种情况，我们可以发现：由于`ThreadLocalMap`的生命周期跟`Thread`一样长，如果都没有手动删除对应`key`，都会导致内存泄漏，但是使用弱引用可以多一层保障：**弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除**。\n>\n> 因此，`ThreadLocal`内存泄漏的根源是：由于`ThreadLocalMap`的生命周期跟`Thread`一样长，如果没有手动删除对应`key`就会导致内存泄漏，而不是因为弱引用。\n>\n> ## ThreadLocal 最佳实践\n>\n> 综合上面的分析，我们可以理解`ThreadLocal`内存泄漏的前因后果，那么怎么避免内存泄漏呢？\n>\n> - 每次使用完`ThreadLocal`，都调用它的`remove()`方法，清除数据。\n>\n> 在使用线程池的情况下，没有及时清理`ThreadLocal`，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用`ThreadLocal`就跟加锁完要解锁一样，用完就清理。\n\n参考文章\n\n[深入分析 ThreadLocal 内存泄漏问题](http://www.importnew.com/22039.html)\n\n[ThreadLocal 内存泄露的实例分析](http://www.importnew.com/22046.html)\n\n[ThreadLocal内存泄露](http://www.importnew.com/22480.html)\n\n\n\n\n\n","slug":"threads/java多线程系列之 08 ThreadLocal","published":1,"updated":"2019-01-04T01:48:59.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovr000299q1u3pczvjg6","content":"<h1 id=\"java多线程系列之-08-ThreadLocal\"><a href=\"#java多线程系列之-08-ThreadLocal\" class=\"headerlink\" title=\"java多线程系列之 08 ThreadLocal\"></a>java多线程系列之 08 ThreadLocal</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>ThreadLocal介绍</li>\n<li>基本用法</li>\n<li>ThreadLocal引起的内存泄漏</li>\n</ol>\n</blockquote>\n<h3 id=\"ThreadLocal-介绍\"><a href=\"#ThreadLocal-介绍\" class=\"headerlink\" title=\"ThreadLocal 介绍\"></a>ThreadLocal 介绍</h3><blockquote>\n<p>ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被GC。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal通常定义为<code>private static</code>类型。</p>\n</blockquote>\n<h3 id=\"2-基本用法\"><a href=\"#2-基本用法\" class=\"headerlink\" title=\"2. 基本用法\"></a>2. 基本用法</h3><blockquote>\n<pre><code>public class ThreadLocalTest {\n   public static void main(String[] args) {\n       for (int i = 0; i &lt; 10; i++) {\n           new Thread() {\n               public void run() {\n                   ThreadId id = new ThreadId();\n                   System.out.println(id.get());\n               }\n           }.start();\n       }\n   }\n}\nclass ThreadId {\n   // Atomic integer containing the next thread ID to be assigned\n   private static final AtomicInteger nextId = new AtomicInteger(0);\n\n   // Thread local variable containing each thread&#39;s ID\n   private static final ThreadLocal&lt;Integer&gt; threadId =\n       new ThreadLocal&lt;Integer&gt;() {\n           @Override\n           protected Integer initialValue() {\n               return nextId.getAndIncrement();\n           }\n       };\n\n   // Returns the current thread&#39;s unique ID, assigning it if necessary\n   public int get() {\n       return threadId.get();\n   }\n}\n</code></pre><p>运行结果：</p>\n<pre><code>9\n7\n6\n8\n2\n4\n0\n3\n5\n1\n</code></pre><p>虽然ThreadLocal对象时static的，但是由于是每个线程独有的，所以各自线程对应的ThreadLocal属性改变，不会影响其他线程的值，因此可以说是线程私有的。也正是因为此，上面的结果才是10个不一样的值。</p>\n<p>那么，在什么场景下比较适合使用ThreadLocal？stackoverflow上有人给出了还不错的回答。<br><a href=\"https://link.jianshu.com?t=http://stackoverflow.com/questions/817856/when-and-how-should-i-use-a-threadlocal-variable\" target=\"_blank\" rel=\"noopener\">When and how should I use a ThreadLocal variable?</a><br>One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid synchronizing access to that object . Instead, give each thread its own instance of the object. </p>\n</blockquote>\n<h2 id=\"ThreadLocal引起的内存泄漏\"><a href=\"#ThreadLocal引起的内存泄漏\" class=\"headerlink\" title=\"ThreadLocal引起的内存泄漏\"></a>ThreadLocal引起的内存泄漏</h2><blockquote>\n<p><code>ThreadLocal</code> 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但是如果滥用<code>ThreadLocal</code>，就可能会导致内存泄漏。下面，我们将围绕三个方面来分析<code>ThreadLocal</code> 内存泄漏的问题</p>\n<ul>\n<li><code>ThreadLocal</code> 实现原理</li>\n<li><code>ThreadLocal</code>为什么会内存泄漏</li>\n<li><code>ThreadLocal</code> 最佳实践</li>\n</ul>\n<h2 id=\"ThreadLocal-实现原理\"><a href=\"#ThreadLocal-实现原理\" class=\"headerlink\" title=\"ThreadLocal 实现原理\"></a>ThreadLocal 实现原理</h2><p><a href=\"http://www.importnew.com/?attachment_id=22042\" target=\"_blank\" rel=\"noopener\"><img src=\"http://incdn1.b0.upaiyun.com/2016/10/2fdbd552107780c5ae5f98126b38d5a4.png\" alt=\"threadlocal\"></a></p>\n<p>ThreadLocal</p>\n<p><code>ThreadLocal</code>的实现是这样的：每个<code>Thread</code> 维护一个 <code>ThreadLocalMap</code> 映射表，这个映射表的 <code>key</code> 是 <code>ThreadLocal</code>实例本身，<code>value</code> 是真正需要存储的 <code>Object</code>。</p>\n<p>也就是说 <code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。值得注意的是图中的虚线，表示 <code>ThreadLocalMap</code> 是使用 <code>ThreadLocal</code> 的弱引用作为 <code>Key</code> 的，弱引用的对象在 GC 时会被回收。</p>\n<h2 id=\"ThreadLocal为什么会内存泄漏\"><a href=\"#ThreadLocal为什么会内存泄漏\" class=\"headerlink\" title=\"ThreadLocal为什么会内存泄漏\"></a><code>ThreadLocal</code>为什么会内存泄漏</h2><p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 GC 的时候，这个<code>ThreadLocal</code>势必会被回收，这样一来，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>，如果当前线程再迟迟不结束的话，这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄漏。</p>\n<p>其实，<code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p>\n<p>但是这些被动的预防措施并不能保证不会内存泄漏：</p>\n<ul>\n<li>使用<code>static</code>的<code>ThreadLocal</code>，延长了<code>ThreadLocal</code>的生命周期，可能导致的内存泄漏（参考<a href=\"http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/\" target=\"_blank\" rel=\"noopener\">ThreadLocal 内存泄露的实例分析</a>）。</li>\n<li>分配使用了<code>ThreadLocal</code>又不再调用<code>get()</code>,<code>set()</code>,<code>remove()</code>方法，那么就会导致内存泄漏。</li>\n</ul>\n<h3 id=\"为什么使用弱引用\"><a href=\"#为什么使用弱引用\" class=\"headerlink\" title=\"为什么使用弱引用\"></a>为什么使用弱引用</h3><p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析<code>ThreadLocal</code>使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</p>\n<p>我们先来看看官方文档的说法：</p>\n<blockquote>\n<p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了应对非常大和长时间的用途，哈希表使用弱引用的 key。</p>\n</blockquote>\n<p>下面我们分两种情况讨论：</p>\n<ul>\n<li><strong>key 使用强引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>不会被回收，导致<code>Entry</code>内存泄漏。</li>\n<li><strong>key 使用弱引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>,<code>get</code>，<code>remove</code>的时候会被清除。</li>\n</ul>\n<p>比较两种情况，我们可以发现：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果都没有手动删除对应<code>key</code>，都会导致内存泄漏，但是使用弱引用可以多一层保障：<strong>弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除</strong>。</p>\n<p>因此，<code>ThreadLocal</code>内存泄漏的根源是：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果没有手动删除对应<code>key</code>就会导致内存泄漏，而不是因为弱引用。</p>\n<h2 id=\"ThreadLocal-最佳实践\"><a href=\"#ThreadLocal-最佳实践\" class=\"headerlink\" title=\"ThreadLocal 最佳实践\"></a>ThreadLocal 最佳实践</h2><p>综合上面的分析，我们可以理解<code>ThreadLocal</code>内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p>\n<ul>\n<li>每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据。</li>\n</ul>\n<p>在使用线程池的情况下，没有及时清理<code>ThreadLocal</code>，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用<code>ThreadLocal</code>就跟加锁完要解锁一样，用完就清理。</p>\n</blockquote>\n<p>参考文章</p>\n<p><a href=\"http://www.importnew.com/22039.html\" target=\"_blank\" rel=\"noopener\">深入分析 ThreadLocal 内存泄漏问题</a></p>\n<p><a href=\"http://www.importnew.com/22046.html\" target=\"_blank\" rel=\"noopener\">ThreadLocal 内存泄露的实例分析</a></p>\n<p><a href=\"http://www.importnew.com/22480.html\" target=\"_blank\" rel=\"noopener\">ThreadLocal内存泄露</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列之-08-ThreadLocal\"><a href=\"#java多线程系列之-08-ThreadLocal\" class=\"headerlink\" title=\"java多线程系列之 08 ThreadLocal\"></a>java多线程系列之 08 ThreadLocal</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>ThreadLocal介绍</li>\n<li>基本用法</li>\n<li>ThreadLocal引起的内存泄漏</li>\n</ol>\n</blockquote>\n<h3 id=\"ThreadLocal-介绍\"><a href=\"#ThreadLocal-介绍\" class=\"headerlink\" title=\"ThreadLocal 介绍\"></a>ThreadLocal 介绍</h3><blockquote>\n<p>ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被GC。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal通常定义为<code>private static</code>类型。</p>\n</blockquote>\n<h3 id=\"2-基本用法\"><a href=\"#2-基本用法\" class=\"headerlink\" title=\"2. 基本用法\"></a>2. 基本用法</h3><blockquote>\n<pre><code>public class ThreadLocalTest {\n   public static void main(String[] args) {\n       for (int i = 0; i &lt; 10; i++) {\n           new Thread() {\n               public void run() {\n                   ThreadId id = new ThreadId();\n                   System.out.println(id.get());\n               }\n           }.start();\n       }\n   }\n}\nclass ThreadId {\n   // Atomic integer containing the next thread ID to be assigned\n   private static final AtomicInteger nextId = new AtomicInteger(0);\n\n   // Thread local variable containing each thread&#39;s ID\n   private static final ThreadLocal&lt;Integer&gt; threadId =\n       new ThreadLocal&lt;Integer&gt;() {\n           @Override\n           protected Integer initialValue() {\n               return nextId.getAndIncrement();\n           }\n       };\n\n   // Returns the current thread&#39;s unique ID, assigning it if necessary\n   public int get() {\n       return threadId.get();\n   }\n}\n</code></pre><p>运行结果：</p>\n<pre><code>9\n7\n6\n8\n2\n4\n0\n3\n5\n1\n</code></pre><p>虽然ThreadLocal对象时static的，但是由于是每个线程独有的，所以各自线程对应的ThreadLocal属性改变，不会影响其他线程的值，因此可以说是线程私有的。也正是因为此，上面的结果才是10个不一样的值。</p>\n<p>那么，在什么场景下比较适合使用ThreadLocal？stackoverflow上有人给出了还不错的回答。<br><a href=\"https://link.jianshu.com?t=http://stackoverflow.com/questions/817856/when-and-how-should-i-use-a-threadlocal-variable\" target=\"_blank\" rel=\"noopener\">When and how should I use a ThreadLocal variable?</a><br>One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid synchronizing access to that object . Instead, give each thread its own instance of the object. </p>\n</blockquote>\n<h2 id=\"ThreadLocal引起的内存泄漏\"><a href=\"#ThreadLocal引起的内存泄漏\" class=\"headerlink\" title=\"ThreadLocal引起的内存泄漏\"></a>ThreadLocal引起的内存泄漏</h2><blockquote>\n<p><code>ThreadLocal</code> 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但是如果滥用<code>ThreadLocal</code>，就可能会导致内存泄漏。下面，我们将围绕三个方面来分析<code>ThreadLocal</code> 内存泄漏的问题</p>\n<ul>\n<li><code>ThreadLocal</code> 实现原理</li>\n<li><code>ThreadLocal</code>为什么会内存泄漏</li>\n<li><code>ThreadLocal</code> 最佳实践</li>\n</ul>\n<h2 id=\"ThreadLocal-实现原理\"><a href=\"#ThreadLocal-实现原理\" class=\"headerlink\" title=\"ThreadLocal 实现原理\"></a>ThreadLocal 实现原理</h2><p><a href=\"http://www.importnew.com/?attachment_id=22042\" target=\"_blank\" rel=\"noopener\"><img src=\"http://incdn1.b0.upaiyun.com/2016/10/2fdbd552107780c5ae5f98126b38d5a4.png\" alt=\"threadlocal\"></a></p>\n<p>ThreadLocal</p>\n<p><code>ThreadLocal</code>的实现是这样的：每个<code>Thread</code> 维护一个 <code>ThreadLocalMap</code> 映射表，这个映射表的 <code>key</code> 是 <code>ThreadLocal</code>实例本身，<code>value</code> 是真正需要存储的 <code>Object</code>。</p>\n<p>也就是说 <code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。值得注意的是图中的虚线，表示 <code>ThreadLocalMap</code> 是使用 <code>ThreadLocal</code> 的弱引用作为 <code>Key</code> 的，弱引用的对象在 GC 时会被回收。</p>\n<h2 id=\"ThreadLocal为什么会内存泄漏\"><a href=\"#ThreadLocal为什么会内存泄漏\" class=\"headerlink\" title=\"ThreadLocal为什么会内存泄漏\"></a><code>ThreadLocal</code>为什么会内存泄漏</h2><p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 GC 的时候，这个<code>ThreadLocal</code>势必会被回收，这样一来，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>，如果当前线程再迟迟不结束的话，这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄漏。</p>\n<p>其实，<code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p>\n<p>但是这些被动的预防措施并不能保证不会内存泄漏：</p>\n<ul>\n<li>使用<code>static</code>的<code>ThreadLocal</code>，延长了<code>ThreadLocal</code>的生命周期，可能导致的内存泄漏（参考<a href=\"http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/\" target=\"_blank\" rel=\"noopener\">ThreadLocal 内存泄露的实例分析</a>）。</li>\n<li>分配使用了<code>ThreadLocal</code>又不再调用<code>get()</code>,<code>set()</code>,<code>remove()</code>方法，那么就会导致内存泄漏。</li>\n</ul>\n<h3 id=\"为什么使用弱引用\"><a href=\"#为什么使用弱引用\" class=\"headerlink\" title=\"为什么使用弱引用\"></a>为什么使用弱引用</h3><p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析<code>ThreadLocal</code>使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</p>\n<p>我们先来看看官方文档的说法：</p>\n<blockquote>\n<p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了应对非常大和长时间的用途，哈希表使用弱引用的 key。</p>\n</blockquote>\n<p>下面我们分两种情况讨论：</p>\n<ul>\n<li><strong>key 使用强引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>不会被回收，导致<code>Entry</code>内存泄漏。</li>\n<li><strong>key 使用弱引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>,<code>get</code>，<code>remove</code>的时候会被清除。</li>\n</ul>\n<p>比较两种情况，我们可以发现：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果都没有手动删除对应<code>key</code>，都会导致内存泄漏，但是使用弱引用可以多一层保障：<strong>弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除</strong>。</p>\n<p>因此，<code>ThreadLocal</code>内存泄漏的根源是：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果没有手动删除对应<code>key</code>就会导致内存泄漏，而不是因为弱引用。</p>\n<h2 id=\"ThreadLocal-最佳实践\"><a href=\"#ThreadLocal-最佳实践\" class=\"headerlink\" title=\"ThreadLocal 最佳实践\"></a>ThreadLocal 最佳实践</h2><p>综合上面的分析，我们可以理解<code>ThreadLocal</code>内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p>\n<ul>\n<li>每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据。</li>\n</ul>\n<p>在使用线程池的情况下，没有及时清理<code>ThreadLocal</code>，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用<code>ThreadLocal</code>就跟加锁完要解锁一样，用完就清理。</p>\n</blockquote>\n<p>参考文章</p>\n<p><a href=\"http://www.importnew.com/22039.html\" target=\"_blank\" rel=\"noopener\">深入分析 ThreadLocal 内存泄漏问题</a></p>\n<p><a href=\"http://www.importnew.com/22046.html\" target=\"_blank\" rel=\"noopener\">ThreadLocal 内存泄露的实例分析</a></p>\n<p><a href=\"http://www.importnew.com/22480.html\" target=\"_blank\" rel=\"noopener\">ThreadLocal内存泄露</a></p>\n"},{"abbrlink":18,"title":"Java CompletableFuture 详解","author":"zhangke","date":"2019-01-04T08:49:00.000Z","_content":"# Java CompletableFuture 详解\n\n### 概述\n\n1. 前言\n2. 准备工作\n3. CompleteableFuture基本使用\n4.  CompletableFuture 类使用示例\n\n### 前言\n\nJava 5 并发库主要关注于异步任务的处理，它采用了这样一种模式，producer 线程创建任务并且利用阻塞队列将其传递给任务的 consumer。这种模型在 Java 7 和 8 中进一步发展，并且开始支持另外一种风格的任务执行，那就是将任务的数据集分解为子集，每个子集都可以由独立且同质的子任务来负责处理。\n\n这种风格的基础库也就是 fork/join 框架，它允许程序员规定数据集该如何进行分割，并且支持将子任务提交到默认的标准线程池中，也就是通用的**ForkJoinPool**。Java 8 中，fork/join 并行功能借助并行流的机制变得更加具有可用性。但是，不是所有的问题都适合这种风格的并行处理：所处理的元素必须是独立的，数据集要足够大，并且在并行加速方面，每个元素的处理成本要足够高，这样才能补偿建立 fork/join 框架所消耗的成本。CompletableFuture 类则是 Java 8 在并行流方面的创新。\n\n<!--  more -->\n\n### 准备工作\n\n这里主要介绍下面我们需要使用的一些知识点，主要是为了是读者可以更好的理解。\n\n#### 异步计算\n\n所谓异步调用其实就是实现一个可无需等待被调用函数的返回值而让操作继续运行的方法。在 Java 语言中，简单的讲就是另启一个线程来完成调用中的部分计算，使调用继续运行或返回，而不需要等待计算结果。但调用者仍需要取线程的计算结果。\n\n#### 回调函数\n\n回调函数比较通用的解释是，它是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外一方调用的，用于对该事件或条件进行响应。\n\n回调函数的机制：\n\n1. 定义一个回调函数；\n2. 提供函数实现的一方在初始化时候，将回调函数的函数指针注册给调用者；\n3. 当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。\n\n回调函数通常与原始调用者处于同一层次，如图 1 所示：\n\n##### 图 1. 回调函数示例图\n\n![]()\n\n#### Future接口\n\nJDK5 新增了 Future 接口，用于描述一个异步计算的结果。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式呢？即当计算结果完成及时通知监听者。\n\n有一些开源框架实现了我们的设想，例如 Netty 的 ChannelFuture 类扩展了 Future 接口，通过提供 addListener 方法实现支持回调方式的异步编程。Netty 中所有的 I/O 操作都是异步的,这意味着任何的 I/O 调用都将立即返回，而不保证这些被请求的 I/O 操作在调用结束的时候已经完成。取而代之地，你会得到一个返回的 ChannelFuture 实例，这个实例将给你一些关于 I/O 操作结果或者状态的信息。当一个 I/O 操作开始的时候，一个新的 Future 对象就会被创建。在开始的时候，新的 Future 是未完成的状态－－它既非成功、失败，也非被取消，因为 I/O 操作还没有结束。如果 I/O 操作以成功、失败或者被取消中的任何一种状态结束了，那么这个 Future 将会被标记为已完成，并包含更多详细的信息（例如：失败的原因）。请注意，即使是失败和被取消的状态，也是属于已完成的状态。阻塞方式的示例代码如清单 1 所示。\n\n##### 清单 1. 阻塞方式示例代码\n\n```java\n`// Start the connection attempt.``ChannelFuture Future = bootstrap.connect(new InetSocketAddress(host, port));``// Wait until the connection is closed or the connection attempt fails.``Future.getChannel().getCloseFuture().awaitUninterruptibly();``// Shut down thread pools to exit.``bootstrap.releaseExternalResources();`\n```\n\n上面代码使用的是 awaitUninterruptibly 方法，源代码如清单 2 所示。\n\n##### 清单 2. awaitUninterruptibly 源代码\n\n```java\npublicChannelFutureawaitUninterruptibly() {\n    boolean interrupted = false;\n    synchronized (this) {\n        //循环等待到完成\n        while (!done) {\n            checkDeadLock();\n            waiters++;\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                //不允许中断\n                interrupted = true;\n            } finally {\n                waiters--;\n            }\n   \t\t }\n\t}\n    if (interrupted) {\n   \t\tThread.currentThread().interrupt();\n\t}\n\treturn this;\n}\n```\n\n##### 清单 3. 异步非阻塞方式示例代码\n\n```java\n// 尝试建立一个连接\nChannelFuture Future = bootstrap.connect(new InetSocketAddress(host, port));\n// 注册连接完成监听器\nFuture.addListener(new ChannelFutureListener(){\n    public void operationComplete(final ChannelFuture Future)\n        throws Exception {    \n        System.out.println(\"连接建立完成\");\n    }\n});\n printTime(\"异步时间：\");\n// 连接关闭，释放资源\nbootstrap.releaseExternalResources();\n```\n\n可以明显的看出，在异步模式下，上面这段代码没有阻塞，在执行 connect 操作后直接执行到** printTime(\"异步时间： \")**，随后 connect 完成，Future 的监听函数输出 connect 操作完成。\n\n非阻塞则是添加监听类 ChannelFutureListener，通过覆盖 ChannelFutureListener 的 operationComplete 执行业务逻辑。\n\n##### 清单 4. 异步非阻塞方式示例代码\n\n```java\n`public void addListener(final ChannelFutureListener listener) {``    ``if (listener == null) {``    ``throw new NullPointerException(\"listener\");``}``    ``booleannotifyNow = false;``    ``synchronized (this) {``        ``if (done) {``        ``notifyNow = true;``    ``} else {``        ``if (firstListener == null) {``        ``//listener 链表头``        ``firstListener = listener;``    ``} else {``        ``if (otherListeners == null) {``        ``otherListeners = new ArrayList<``ChannelFutureListener``>(1);``        ``}``        ``//添加到 listener 链表中，以便操作完成后遍历操作``        ``otherListeners.add(listener);``    ``}``    ``......``    ``if (notifyNow) {``        ``//通知 listener 进行处理``        ``notifyListener(listener);``        ``}``}`\n```\n\n这部分代码的逻辑很简单，就是注册回调函数，当操作完成后自动调用回调函数，就达到了异步的效果。\n\n### CompleteableFuture基本使用\n\n在Java 8中, 新增加了一个包含50个方法左右的类: [CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。\n\n如果想使用以前阻塞或者轮询方式来使用，依然可以通过 CompletableFuture 类来实现，因为CompleteableFuture实现了 CompletionStage 和 Future 接口方，因此也支持这种方式。\n\nCompletableFuture 类声明了 CompletionStage 接口，CompletionStage 接口实际上提供了同步或异步运行计算的舞台，所以我们可以通过实现多个 CompletionStage 命令，并且将这些命令串联在一起的方式实现多个命令之间的触发。\n\n#### 同步方式完成计算\n\nCompletableFuture类实现了[CompletionStage](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html)和[Future](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html)接口，所以你还是可以像以前一样通过阻塞或者轮询的方式获得结果，尽管这种方式不推荐使用。\n\n```java\npublic T \tget()\npublic T \tget(long timeout, TimeUnit unit)\npublic T \tgetNow(T valueIfAbsent)\npublic T \tjoin()\n```\n\n`getNow`有点特殊，如果结果已经计算完则返回结果或者抛出异常，否则返回给定的`valueIfAbsent`值。\n`join`返回计算的结果或者抛出一个unchecked异常(CompletionException)，可以不进行捕捉，它和`get`对抛出的异常的处理有些细微的区别，你可以运行下面的代码进行比较：\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    int i = 1/0;\n    return 100;\n});\n// join的使用方式\n//future.join();\n\n// get必须要捕捉异常，对异常进行处理\n  try {\n            future.get();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n```\n\n尽管Future可以代表在另外的线程中执行的一段异步代码，但是你还是可以在本身线程中执行：\n\n```java\npublic static CompletableFuture<Integer> compute() {\n    final CompletableFuture<Integer> future = new CompletableFuture<>();\n\n    return future;\n}\n```\n\n上面的代码中`future`没有关联任何的`Callback`、线程池、异步任务等，如果客户端调用`future.get`就会一直傻等下去。你可以通过下面的代码完成一个计算，触发客户端的等待：\n\n```\nf.complete(100);\n```\n\n当然你也可以抛出一个异常，而不是一个成功的计算结果：\n\n```\nf.completeExceptionally(new Exception());\n```\n\n完整的代码如下：\n\n```java\npublic class BasicMain {\n    public static CompletableFuture<Integer> compute() {\n        final CompletableFuture<Integer> future = new CompletableFuture<>();\n        return future;\n    }\n    public static void main(String[] args) throws Exception {\n        final CompletableFuture<Integer> f = compute();\n        class Client extends Thread {\n            CompletableFuture<Integer> f;\n            Client(String threadName, CompletableFuture<Integer> f) {\n                super(threadName);\n                this.f = f;\n            }\n            @Override\n            public void run() {\n                try {\n                    System.out.println(this.getName() + \": \" + f.get());\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (ExecutionException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        new Client(\"Client1\", f).start();\n        new Client(\"Client2\", f).start();\n        System.out.println(\"waiting\");\n        f.complete(100);\n        //f.completeExceptionally(new Exception());\n        System.in.read();\n    }\n}\n```\n\n可以看到我们并没有把`f.complete(100);`放在另外的线程中去执行，但是在大部分情况下我们可能会用一个线程池去执行这些异步任务。`CompletableFuture.complete()`、`CompletableFuture.completeExceptionally`只能被调用一次。但是我们有两个后门方法可以重设这个值:`obtrudeValue`、`obtrudeException`，但是使用的时候要小心，因为`complete`已经触发了客户端，有可能导致客户端会得到不期望的结果。\n\n#### 创建CompletableFuture对象\n\n`CompletableFuture.completedFuture`是一个静态辅助方法，用来返回一个已经计算好的`CompletableFuture`。\n\n```java\npublic static <U> CompletableFuture<U> completedFuture(U value)\n```\n\n而以下四个静态方法用来为一段异步执行的代码创建`CompletableFuture`对象：\n\n```java\npublic static CompletableFuture<Void> \trunAsync(Runnable runnable)\npublic static CompletableFuture<Void> \trunAsync(Runnable runnable, Executor executor)\npublic static <U> CompletableFuture<U> \tsupplyAsync(Supplier<U> supplier)\npublic static <U> CompletableFuture<U> \tsupplyAsync(Supplier<U> supplier, Executor executor)\n```\n\n以`Async`结尾并且没有指定`Executor`的方法会使用`ForkJoinPool.commonPool()`作为它的线程池执行异步代码。\n\n`runAsync`方法也好理解，它以`Runnable`函数式接口类型为参数，所以`CompletableFuture`的计算结果为空。\n\n`supplyAsync`方法以`Supplier<U>`函数式接口类型为参数,`CompletableFuture`的计算结果类型为`U`。\n\n因为方法的参数类型都是函数式接口，所以可以使用lambda表达式实现异步任务，比如：\n\n```java\nCompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n    //长时间的计算任务\n    return \"处理完成\";\n});\n```\n\n#### 计算结果完成时的处理\n\n当`CompletableFuture`的计算结果完成，或者抛出异常的时候，我们可以执行特定的`Action`。主要是下面的方法：\n\n```java\npublic CompletableFuture<T> \twhenComplete(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> \twhenCompleteAsync(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> \twhenCompleteAsync(BiConsumer<? super T,? super Throwable> action, Executor executor)\npublic CompletableFuture<T>     exceptionally(Function<Throwable,? extends T> fn)\n```\n\n可以看到`Action`的类型是`BiConsumer<? super T,? super Throwable>`，它可以处理正常的计算结果，或者异常情况。\n方法不以`Async`结尾，意味着`Action`使用相同的线程执行，而`Async`可能会使用其它的线程去执行(如果使用相同的线程池，也可能会被同一个线程选中执行)。\n\n注意这几个方法都会返回`CompletableFuture`，当`Action`执行完毕后它的结果返回原始的`CompletableFuture`的计算结果或者返回异常。\n\n```java\npublic class Main {\n    private static Random rand = new Random();\n    private static long t = System.currentTimeMillis();\n    static int getMoreData() {\n        System.out.println(\"begin to start compute\");\n        try {\n            Thread.sleep(10000);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        System.out.println(\"end to start compute. passed \" + \n                           (System.currentTimeMillis() - t)/1000 + \" seconds\");\n        return rand.nextInt(1000);\n    }\n    public static void main(String[] args) throws Exception {\n        CompletableFuture<Integer> future = \n            CompletableFuture.supplyAsync(Main::getMoreData);\n        Future<Integer> f = future.whenComplete((v, e) -> {\n            System.out.println(v);\n            System.out.println(e);\n        });\n        System.out.println(f.get());\n        System.in.read();\n    }\n}\n```\n\n`exceptionally`方法返回一个新的CompletableFuture，当原始的CompletableFuture抛出异常的时候，就会触发这个CompletableFuture的计算，调用function计算值，否则如果原始的CompletableFuture正常计算完后，这个新的CompletableFuture也计算完成，它的值和原始的CompletableFuture的计算的值相同。也就是这个`exceptionally`方法用来处理异常的情况。\n\n下面一组方法虽然也返回CompletableFuture对象，但是对象的值和原来的CompletableFuture计算的值不同。当原先的CompletableFuture的值计算完成或者抛出异常的时候，会触发这个CompletableFuture对象的计算，结果由`BiFunction`参数计算而得。因此这组方法兼有`whenComplete`和转换的两个功能。\n\n```java\npublic <U> CompletableFuture<U> \thandle(BiFunction<? super T,Throwable,? extends U> fn)\npublic <U> CompletableFuture<U> \thandleAsync(BiFunction<? super T,Throwable,? extends U> fn)\npublic <U> CompletableFuture<U> \thandleAsync(BiFunction<? super T,Throwable,? extends U> fn, Executor executor)\n```\n\n同样，不以`Async`结尾的方法由原来的线程计算，以`Async`结尾的方法由默认的线程池`ForkJoinPool.commonPool()`或者指定的线程池`executor`运行。\n\n#### 组合\n\n`CompletableFuture`可以作为monad(单子)和functor。由于回调风格的实现，我们不必因为等待一个计算完成而阻塞着调用线程，而是告诉`CompletableFuture`当计算完成的时候请执行某个`function`。而且我们还可以将这些操作串联起来，或者将`CompletableFuture`组合起来。\n\n```java\npublic <U> CompletableFuture<U> \tthenApply(Function<? super T,? extends U> fn)\npublic <U> CompletableFuture<U> \tthenApplyAsync(Function<? super T,? extends U> fn)\npublic <U> CompletableFuture<U> \tthenApplyAsync(Function<? super T,? extends U> fn, Executor executor)\n```\n\n这一组函数的功能是当原来的CompletableFuture计算完后，将结果传递给函数`fn`，将`fn`的结果作为新的`CompletableFuture`计算结果。因此它的功能相当于将`CompletableFuture<T>`转换成`CompletableFuture<U>`。\n\n这三个函数的区别和上面介绍的一样，不以`Async`结尾的方法由原来的线程计算，以`Async`结尾的方法由默认的线程池`ForkJoinPool.commonPool()`或者指定的线程池`executor`运行。Java的CompletableFuture类总是遵循这样的原则，下面就不一一赘述了。\n\n使用例子如下：\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    return 100;\n});\nCompletableFuture<String> f =  future\n\t\t\t\t\t\t\t\t.thenApplyAsync(i -> i * 10)\n    \t\t\t\t\t\t\t.thenApply(i -> i.toString());\nSystem.out.println(f.get()); //\"1000\"\n```\n\n需要注意的是，这些转换并不是马上执行的，也不会阻塞，而是在前一个stage完成后继续执行。\n\n**它们与`handle`方法的区别在于`handle`方法会处理正常计算值和异常，因此它可以屏蔽异常，避免异常继续抛出。而`thenApply`方法只是用来处理正常值，因此一旦有异常就会抛出。**\n\n上面的前一个CompleteFuture执行完成执行后一个，下面的是同时执行或者其中一个执行完成就代表执行完成。\n\n```java\npublic <U> CompletableFuture<U> \tthenCompose(Function<? super T,? extends \n                                                CompletionStage<U>> fn)\npublic <U> CompletableFuture<U> \tthenComposeAsync(Function<? super T,? extends \n                                                     CompletionStage<U>> fn)\npublic <U> CompletableFuture<U> \tthenComposeAsync(Function<? super T,? extends \n                                                     CompletionStage<U>> fn,\n                                                     Executor executor)\n```\n\n这一组方法接受一个Function作为参数，这个Function的输入是当前的CompletableFuture的计算值，返回结果将是一个新的CompletableFuture，这个新的CompletableFuture会组合原来的CompletableFuture和函数返回的CompletableFuture。因此它的功能类似:\n\n```\nA +--> B +---> C\n```\n\n记住，`thenCompose`返回的对象并不一定是函数`fn`返回的对象，如果原来的`CompletableFuture`还没有计算出来，它就会生成一个新的组合后的CompletableFuture。\n\n例子：\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    return 100;\n});\nCompletableFuture<String> f =  future.thenCompose( i -> {\n    return CompletableFuture.supplyAsync(() -> {\n        return (i * 10) + \"\";\n    });\n});\nSystem.out.println(f.get()); //1000\n```\n\n而下面的一组方法`thenCombine`用来复合另外一个CompletionStage的结果。它的功能类似：\n\n```\nA +\n  |\n  +------> C\n  +------>\nB +\n```\n\n两个CompletionStage是并行执行的，它们之间并没有先后依赖顺序，other并不会等待先前的CompletableFuture执行完毕后再执行。\n\n```java\npublic <U,V> CompletableFuture<V> \tthenCombine(CompletionStage<? extends U> other, \n                                        BiFunction<? super T,? super U,? extends V> fn)\npublic <U,V> CompletableFuture<V> \tthenCombineAsync(CompletionStage<? extends U> other, \n                                        BiFunction<? super T,? super U,? extends V> fn)\npublic <U,V> CompletableFuture<V> \tthenCombineAsync(CompletionStage<? extends U> other,\n                    BiFunction<? super T,? super U,? extends V> fn, Executor executor)\n```\n\n其实从功能上来讲,它们的功能更类似`thenAcceptBoth`，只不过`thenAcceptBoth`是纯消费，它的函数参数没有返回值，而`thenCombine`的函数参数`fn`有返回值。\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    return 100;\n});\nCompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {\n    return \"abc\";\n});\nCompletableFuture<String> f =  future.thenCombine(future2, (x,y) -> y + \"-\" + x);\nSystem.out.println(f.get()); //abc-100\n```\n\n#### 纯消费(执行Action)\n\n上面的方法是当计算完成的时候，会生成新的计算结果(`thenApply`, `handle`)，或者返回同样的计算结果`whenComplete`，`CompletableFuture`还提供了一种处理结果的方法，只对结果执行`Action`,而不返回新的计算值，因此计算值为`Void`:\n\n```java\npublic CompletableFuture<Void> \tthenAccept(Consumer<? super T> action)\npublic CompletableFuture<Void> \tthenAcceptAsync(Consumer<? super T> action)\npublic CompletableFuture<Void> \tthenAcceptAsync(Consumer<? super T> action, Executor executor)\n```\n\n看它的参数类型也就明白了，它们是函数式接口`Consumer`，这个接口只有输入，没有返回值。\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    return 100;\n});\nCompletableFuture<Void> f =  future.thenAccept(System.out::println);\nSystem.out.println(f.get());\n```\n\n`thenAcceptBoth`以及相关方法提供了类似的功能，当两个CompletionStage都正常完成计算的时候，就会执行提供的`action`，它用来组合另外一个异步的结果。\n\n`runAfterBoth`是当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。\n\n```java\npublic <U> CompletableFuture<Void> \tthenAcceptBoth(CompletionStage<? extends U> other,\n                                             BiConsumer<? super T,? super U> action)\npublic <U> CompletableFuture<Void> \tthenAcceptBothAsync(CompletionStage<? extends U> \n                                        other, BiConsumer<? super T,? super U> action)\npublic <U> CompletableFuture<Void> \tthenAcceptBothAsync(CompletionStage<? extends U> \n                     other, BiConsumer<? super T,? super U> action, Executor executor)\npublic     CompletableFuture<Void> \trunAfterBoth(CompletionStage<?> other, \n                                                 Runnable action)\n```\n\n例子如下：\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    return 100;\n});\nCompletableFuture<Void> f = future.thenAcceptBoth(CompletableFuture.completedFuture(10), \n                         \t\t\t(x, y) -> System.out.println(x * y));\nSystem.out.println(f.get());\n```\n\n更彻底地，下面一组方法当计算完成的时候会执行一个Runnable,与`thenAccept`不同，Runnable并不使用CompletableFuture计算的结果。\n\n```java\npublic CompletableFuture<Void> \tthenRun(Runnable action)\npublic CompletableFuture<Void> \tthenRunAsync(Runnable action)\npublic CompletableFuture<Void> \tthenRunAsync(Runnable action, Executor executor)\n```\n\n因此先前的CompletableFuture计算的结果被忽略了,这个方法返回`CompletableFuture<Void>`类型的对象。\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    return 100;\n});\nCompletableFuture<Void> f =  future.thenRun(() -> System.out.println(\"finished\"));\nSystem.out.println(f.get());\n```\n\n> 因此，你可以根据方法的参数的类型来加速你的记忆。`Runnable`类型的参数会忽略计算的结果，`Consumer`是纯消费计算结果，`BiConsumer`会组合另外一个`CompletionStage`纯消费，`Function`会对计算结果做转换，`BiFunction`会组合另外一个`CompletionStage`的计算结果做转换。\n\n####  Either\n\n`thenAcceptBoth`和`runAfterBoth`是当两个CompletableFuture都计算完成，而我们下面要了解的方法是当任意一个CompletableFuture计算完成的时候就会执行。\n\n```java\npublic CompletableFuture<Void> \tacceptEither(CompletionStage<? extends T> other, Consumer<? super T> action)\npublic CompletableFuture<Void> \tacceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action)\npublic CompletableFuture<Void> \tacceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action, Executor executor)\n\npublic <U> CompletableFuture<U> \tapplyToEither(CompletionStage<? extends T> other, Function<? super T,U> fn)\npublic <U> CompletableFuture<U> \tapplyToEitherAsync(CompletionStage<? extends T> other, Function<? super T,U> fn)\npublic <U> CompletableFuture<U> \tapplyToEitherAsync(CompletionStage<? extends T> other, Function<? super T,U> fn, Executor executor)\n\n```\n\n**acceptEither`方法是当任意一个CompletionStage完成的时候，`action`这个消费者就会被执行。这个方法返回`CompletableFuture<Void>**\n\n**applyToEither`方法是当任意一个CompletionStage完成的时候，`fn`会被执行，它的返回值会当作新的`CompletableFuture<U>的计算结果。**\n\n下面这个例子有时会输出`100`,有时候会输出`200`,哪个Future先完成就会根据它的结果计算。\n\n```java\nRandom rand = new Random();\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 100;\n});\nCompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 200;\n});\nCompletableFuture<String> f =  future.applyToEither(future2,i -> i.toString());\n```\n\n#### 辅助方法 `allOf` 和 `anyOf`\n\n前面我们已经介绍了几个静态方法：`completedFuture`、`runAsync`、`supplyAsync`,下面介绍的这两个方法用来组合多个CompletableFuture。\n\n```java\npublic static CompletableFuture<Void> \t    allOf(CompletableFuture<?>... cfs)\npublic static CompletableFuture<Object> \tanyOf(CompletableFuture<?>... cfs)\n```\n\n`allOf`方法是当所有的`CompletableFuture`都执行完后执行计算。\n\n`anyOf`方法是当任意一个`CompletableFuture`执行完后就会执行计算，计算的结果相同。\n\n下面的代码运行结果有时是100,有时是\"abc\"。但是`anyOf`和`applyToEither`不同。`anyOf`接受任意多的CompletableFuture但是`applyToEither`只是判断两个CompletableFuture,`anyOf`返回值的计算结果是参数中其中一个CompletableFuture的计算结果，`applyToEither`返回值的计算结果却是要经过`fn`处理的。当然还有静态方法的区别，线程池的选择等。\n\n```java\nRandom rand = new Random();\nCompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 100;\n});\nCompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return \"abc\";\n});\n//CompletableFuture<Void> f =  CompletableFuture.allOf(future1,future2);\nCompletableFuture<Object> f =  CompletableFuture.anyOf(future1,future2);\nSystem.out.println(f.get());\n```\n\n我想通过上面的介绍，应该把CompletableFuture的方法和功能介绍完了(`cancel`、`isCompletedExceptionally()`、`isDone()`以及继承于Object的方法无需介绍了， `toCompletableFuture()`返回CompletableFuture本身)，希望你能全面了解CompletableFuture强大的功能，并将它应用到Java的异步编程中。如果你有使用它的开源项目，可以留言分享一下。\n\n\n\n### 参考\n\n1. [Java CompletableFuture 详解](https://colobu.com/2016/02/29/Java-CompletableFuture/)\n2. [通过实例理解 JDK8 的 CompletableFuture](https://www.ibm.com/developerworks/cn/java/j-cf-of-jdk8/index.html)\n\n","source":"_posts/Java CompletableFuture 详解.md","raw":"abbrlink: 18\ntitle: Java CompletableFuture 详解\ntags:\n  - JUC\n  - Future\ncategories:\n  - java\nauthor: zhangke\ndate: 2019-01-04 16:49:00\n---\n# Java CompletableFuture 详解\n\n### 概述\n\n1. 前言\n2. 准备工作\n3. CompleteableFuture基本使用\n4.  CompletableFuture 类使用示例\n\n### 前言\n\nJava 5 并发库主要关注于异步任务的处理，它采用了这样一种模式，producer 线程创建任务并且利用阻塞队列将其传递给任务的 consumer。这种模型在 Java 7 和 8 中进一步发展，并且开始支持另外一种风格的任务执行，那就是将任务的数据集分解为子集，每个子集都可以由独立且同质的子任务来负责处理。\n\n这种风格的基础库也就是 fork/join 框架，它允许程序员规定数据集该如何进行分割，并且支持将子任务提交到默认的标准线程池中，也就是通用的**ForkJoinPool**。Java 8 中，fork/join 并行功能借助并行流的机制变得更加具有可用性。但是，不是所有的问题都适合这种风格的并行处理：所处理的元素必须是独立的，数据集要足够大，并且在并行加速方面，每个元素的处理成本要足够高，这样才能补偿建立 fork/join 框架所消耗的成本。CompletableFuture 类则是 Java 8 在并行流方面的创新。\n\n<!--  more -->\n\n### 准备工作\n\n这里主要介绍下面我们需要使用的一些知识点，主要是为了是读者可以更好的理解。\n\n#### 异步计算\n\n所谓异步调用其实就是实现一个可无需等待被调用函数的返回值而让操作继续运行的方法。在 Java 语言中，简单的讲就是另启一个线程来完成调用中的部分计算，使调用继续运行或返回，而不需要等待计算结果。但调用者仍需要取线程的计算结果。\n\n#### 回调函数\n\n回调函数比较通用的解释是，它是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外一方调用的，用于对该事件或条件进行响应。\n\n回调函数的机制：\n\n1. 定义一个回调函数；\n2. 提供函数实现的一方在初始化时候，将回调函数的函数指针注册给调用者；\n3. 当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。\n\n回调函数通常与原始调用者处于同一层次，如图 1 所示：\n\n##### 图 1. 回调函数示例图\n\n![]()\n\n#### Future接口\n\nJDK5 新增了 Future 接口，用于描述一个异步计算的结果。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式呢？即当计算结果完成及时通知监听者。\n\n有一些开源框架实现了我们的设想，例如 Netty 的 ChannelFuture 类扩展了 Future 接口，通过提供 addListener 方法实现支持回调方式的异步编程。Netty 中所有的 I/O 操作都是异步的,这意味着任何的 I/O 调用都将立即返回，而不保证这些被请求的 I/O 操作在调用结束的时候已经完成。取而代之地，你会得到一个返回的 ChannelFuture 实例，这个实例将给你一些关于 I/O 操作结果或者状态的信息。当一个 I/O 操作开始的时候，一个新的 Future 对象就会被创建。在开始的时候，新的 Future 是未完成的状态－－它既非成功、失败，也非被取消，因为 I/O 操作还没有结束。如果 I/O 操作以成功、失败或者被取消中的任何一种状态结束了，那么这个 Future 将会被标记为已完成，并包含更多详细的信息（例如：失败的原因）。请注意，即使是失败和被取消的状态，也是属于已完成的状态。阻塞方式的示例代码如清单 1 所示。\n\n##### 清单 1. 阻塞方式示例代码\n\n```java\n`// Start the connection attempt.``ChannelFuture Future = bootstrap.connect(new InetSocketAddress(host, port));``// Wait until the connection is closed or the connection attempt fails.``Future.getChannel().getCloseFuture().awaitUninterruptibly();``// Shut down thread pools to exit.``bootstrap.releaseExternalResources();`\n```\n\n上面代码使用的是 awaitUninterruptibly 方法，源代码如清单 2 所示。\n\n##### 清单 2. awaitUninterruptibly 源代码\n\n```java\npublicChannelFutureawaitUninterruptibly() {\n    boolean interrupted = false;\n    synchronized (this) {\n        //循环等待到完成\n        while (!done) {\n            checkDeadLock();\n            waiters++;\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                //不允许中断\n                interrupted = true;\n            } finally {\n                waiters--;\n            }\n   \t\t }\n\t}\n    if (interrupted) {\n   \t\tThread.currentThread().interrupt();\n\t}\n\treturn this;\n}\n```\n\n##### 清单 3. 异步非阻塞方式示例代码\n\n```java\n// 尝试建立一个连接\nChannelFuture Future = bootstrap.connect(new InetSocketAddress(host, port));\n// 注册连接完成监听器\nFuture.addListener(new ChannelFutureListener(){\n    public void operationComplete(final ChannelFuture Future)\n        throws Exception {    \n        System.out.println(\"连接建立完成\");\n    }\n});\n printTime(\"异步时间：\");\n// 连接关闭，释放资源\nbootstrap.releaseExternalResources();\n```\n\n可以明显的看出，在异步模式下，上面这段代码没有阻塞，在执行 connect 操作后直接执行到** printTime(\"异步时间： \")**，随后 connect 完成，Future 的监听函数输出 connect 操作完成。\n\n非阻塞则是添加监听类 ChannelFutureListener，通过覆盖 ChannelFutureListener 的 operationComplete 执行业务逻辑。\n\n##### 清单 4. 异步非阻塞方式示例代码\n\n```java\n`public void addListener(final ChannelFutureListener listener) {``    ``if (listener == null) {``    ``throw new NullPointerException(\"listener\");``}``    ``booleannotifyNow = false;``    ``synchronized (this) {``        ``if (done) {``        ``notifyNow = true;``    ``} else {``        ``if (firstListener == null) {``        ``//listener 链表头``        ``firstListener = listener;``    ``} else {``        ``if (otherListeners == null) {``        ``otherListeners = new ArrayList<``ChannelFutureListener``>(1);``        ``}``        ``//添加到 listener 链表中，以便操作完成后遍历操作``        ``otherListeners.add(listener);``    ``}``    ``......``    ``if (notifyNow) {``        ``//通知 listener 进行处理``        ``notifyListener(listener);``        ``}``}`\n```\n\n这部分代码的逻辑很简单，就是注册回调函数，当操作完成后自动调用回调函数，就达到了异步的效果。\n\n### CompleteableFuture基本使用\n\n在Java 8中, 新增加了一个包含50个方法左右的类: [CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。\n\n如果想使用以前阻塞或者轮询方式来使用，依然可以通过 CompletableFuture 类来实现，因为CompleteableFuture实现了 CompletionStage 和 Future 接口方，因此也支持这种方式。\n\nCompletableFuture 类声明了 CompletionStage 接口，CompletionStage 接口实际上提供了同步或异步运行计算的舞台，所以我们可以通过实现多个 CompletionStage 命令，并且将这些命令串联在一起的方式实现多个命令之间的触发。\n\n#### 同步方式完成计算\n\nCompletableFuture类实现了[CompletionStage](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html)和[Future](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html)接口，所以你还是可以像以前一样通过阻塞或者轮询的方式获得结果，尽管这种方式不推荐使用。\n\n```java\npublic T \tget()\npublic T \tget(long timeout, TimeUnit unit)\npublic T \tgetNow(T valueIfAbsent)\npublic T \tjoin()\n```\n\n`getNow`有点特殊，如果结果已经计算完则返回结果或者抛出异常，否则返回给定的`valueIfAbsent`值。\n`join`返回计算的结果或者抛出一个unchecked异常(CompletionException)，可以不进行捕捉，它和`get`对抛出的异常的处理有些细微的区别，你可以运行下面的代码进行比较：\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    int i = 1/0;\n    return 100;\n});\n// join的使用方式\n//future.join();\n\n// get必须要捕捉异常，对异常进行处理\n  try {\n            future.get();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n```\n\n尽管Future可以代表在另外的线程中执行的一段异步代码，但是你还是可以在本身线程中执行：\n\n```java\npublic static CompletableFuture<Integer> compute() {\n    final CompletableFuture<Integer> future = new CompletableFuture<>();\n\n    return future;\n}\n```\n\n上面的代码中`future`没有关联任何的`Callback`、线程池、异步任务等，如果客户端调用`future.get`就会一直傻等下去。你可以通过下面的代码完成一个计算，触发客户端的等待：\n\n```\nf.complete(100);\n```\n\n当然你也可以抛出一个异常，而不是一个成功的计算结果：\n\n```\nf.completeExceptionally(new Exception());\n```\n\n完整的代码如下：\n\n```java\npublic class BasicMain {\n    public static CompletableFuture<Integer> compute() {\n        final CompletableFuture<Integer> future = new CompletableFuture<>();\n        return future;\n    }\n    public static void main(String[] args) throws Exception {\n        final CompletableFuture<Integer> f = compute();\n        class Client extends Thread {\n            CompletableFuture<Integer> f;\n            Client(String threadName, CompletableFuture<Integer> f) {\n                super(threadName);\n                this.f = f;\n            }\n            @Override\n            public void run() {\n                try {\n                    System.out.println(this.getName() + \": \" + f.get());\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (ExecutionException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        new Client(\"Client1\", f).start();\n        new Client(\"Client2\", f).start();\n        System.out.println(\"waiting\");\n        f.complete(100);\n        //f.completeExceptionally(new Exception());\n        System.in.read();\n    }\n}\n```\n\n可以看到我们并没有把`f.complete(100);`放在另外的线程中去执行，但是在大部分情况下我们可能会用一个线程池去执行这些异步任务。`CompletableFuture.complete()`、`CompletableFuture.completeExceptionally`只能被调用一次。但是我们有两个后门方法可以重设这个值:`obtrudeValue`、`obtrudeException`，但是使用的时候要小心，因为`complete`已经触发了客户端，有可能导致客户端会得到不期望的结果。\n\n#### 创建CompletableFuture对象\n\n`CompletableFuture.completedFuture`是一个静态辅助方法，用来返回一个已经计算好的`CompletableFuture`。\n\n```java\npublic static <U> CompletableFuture<U> completedFuture(U value)\n```\n\n而以下四个静态方法用来为一段异步执行的代码创建`CompletableFuture`对象：\n\n```java\npublic static CompletableFuture<Void> \trunAsync(Runnable runnable)\npublic static CompletableFuture<Void> \trunAsync(Runnable runnable, Executor executor)\npublic static <U> CompletableFuture<U> \tsupplyAsync(Supplier<U> supplier)\npublic static <U> CompletableFuture<U> \tsupplyAsync(Supplier<U> supplier, Executor executor)\n```\n\n以`Async`结尾并且没有指定`Executor`的方法会使用`ForkJoinPool.commonPool()`作为它的线程池执行异步代码。\n\n`runAsync`方法也好理解，它以`Runnable`函数式接口类型为参数，所以`CompletableFuture`的计算结果为空。\n\n`supplyAsync`方法以`Supplier<U>`函数式接口类型为参数,`CompletableFuture`的计算结果类型为`U`。\n\n因为方法的参数类型都是函数式接口，所以可以使用lambda表达式实现异步任务，比如：\n\n```java\nCompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n    //长时间的计算任务\n    return \"处理完成\";\n});\n```\n\n#### 计算结果完成时的处理\n\n当`CompletableFuture`的计算结果完成，或者抛出异常的时候，我们可以执行特定的`Action`。主要是下面的方法：\n\n```java\npublic CompletableFuture<T> \twhenComplete(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> \twhenCompleteAsync(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> \twhenCompleteAsync(BiConsumer<? super T,? super Throwable> action, Executor executor)\npublic CompletableFuture<T>     exceptionally(Function<Throwable,? extends T> fn)\n```\n\n可以看到`Action`的类型是`BiConsumer<? super T,? super Throwable>`，它可以处理正常的计算结果，或者异常情况。\n方法不以`Async`结尾，意味着`Action`使用相同的线程执行，而`Async`可能会使用其它的线程去执行(如果使用相同的线程池，也可能会被同一个线程选中执行)。\n\n注意这几个方法都会返回`CompletableFuture`，当`Action`执行完毕后它的结果返回原始的`CompletableFuture`的计算结果或者返回异常。\n\n```java\npublic class Main {\n    private static Random rand = new Random();\n    private static long t = System.currentTimeMillis();\n    static int getMoreData() {\n        System.out.println(\"begin to start compute\");\n        try {\n            Thread.sleep(10000);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        System.out.println(\"end to start compute. passed \" + \n                           (System.currentTimeMillis() - t)/1000 + \" seconds\");\n        return rand.nextInt(1000);\n    }\n    public static void main(String[] args) throws Exception {\n        CompletableFuture<Integer> future = \n            CompletableFuture.supplyAsync(Main::getMoreData);\n        Future<Integer> f = future.whenComplete((v, e) -> {\n            System.out.println(v);\n            System.out.println(e);\n        });\n        System.out.println(f.get());\n        System.in.read();\n    }\n}\n```\n\n`exceptionally`方法返回一个新的CompletableFuture，当原始的CompletableFuture抛出异常的时候，就会触发这个CompletableFuture的计算，调用function计算值，否则如果原始的CompletableFuture正常计算完后，这个新的CompletableFuture也计算完成，它的值和原始的CompletableFuture的计算的值相同。也就是这个`exceptionally`方法用来处理异常的情况。\n\n下面一组方法虽然也返回CompletableFuture对象，但是对象的值和原来的CompletableFuture计算的值不同。当原先的CompletableFuture的值计算完成或者抛出异常的时候，会触发这个CompletableFuture对象的计算，结果由`BiFunction`参数计算而得。因此这组方法兼有`whenComplete`和转换的两个功能。\n\n```java\npublic <U> CompletableFuture<U> \thandle(BiFunction<? super T,Throwable,? extends U> fn)\npublic <U> CompletableFuture<U> \thandleAsync(BiFunction<? super T,Throwable,? extends U> fn)\npublic <U> CompletableFuture<U> \thandleAsync(BiFunction<? super T,Throwable,? extends U> fn, Executor executor)\n```\n\n同样，不以`Async`结尾的方法由原来的线程计算，以`Async`结尾的方法由默认的线程池`ForkJoinPool.commonPool()`或者指定的线程池`executor`运行。\n\n#### 组合\n\n`CompletableFuture`可以作为monad(单子)和functor。由于回调风格的实现，我们不必因为等待一个计算完成而阻塞着调用线程，而是告诉`CompletableFuture`当计算完成的时候请执行某个`function`。而且我们还可以将这些操作串联起来，或者将`CompletableFuture`组合起来。\n\n```java\npublic <U> CompletableFuture<U> \tthenApply(Function<? super T,? extends U> fn)\npublic <U> CompletableFuture<U> \tthenApplyAsync(Function<? super T,? extends U> fn)\npublic <U> CompletableFuture<U> \tthenApplyAsync(Function<? super T,? extends U> fn, Executor executor)\n```\n\n这一组函数的功能是当原来的CompletableFuture计算完后，将结果传递给函数`fn`，将`fn`的结果作为新的`CompletableFuture`计算结果。因此它的功能相当于将`CompletableFuture<T>`转换成`CompletableFuture<U>`。\n\n这三个函数的区别和上面介绍的一样，不以`Async`结尾的方法由原来的线程计算，以`Async`结尾的方法由默认的线程池`ForkJoinPool.commonPool()`或者指定的线程池`executor`运行。Java的CompletableFuture类总是遵循这样的原则，下面就不一一赘述了。\n\n使用例子如下：\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    return 100;\n});\nCompletableFuture<String> f =  future\n\t\t\t\t\t\t\t\t.thenApplyAsync(i -> i * 10)\n    \t\t\t\t\t\t\t.thenApply(i -> i.toString());\nSystem.out.println(f.get()); //\"1000\"\n```\n\n需要注意的是，这些转换并不是马上执行的，也不会阻塞，而是在前一个stage完成后继续执行。\n\n**它们与`handle`方法的区别在于`handle`方法会处理正常计算值和异常，因此它可以屏蔽异常，避免异常继续抛出。而`thenApply`方法只是用来处理正常值，因此一旦有异常就会抛出。**\n\n上面的前一个CompleteFuture执行完成执行后一个，下面的是同时执行或者其中一个执行完成就代表执行完成。\n\n```java\npublic <U> CompletableFuture<U> \tthenCompose(Function<? super T,? extends \n                                                CompletionStage<U>> fn)\npublic <U> CompletableFuture<U> \tthenComposeAsync(Function<? super T,? extends \n                                                     CompletionStage<U>> fn)\npublic <U> CompletableFuture<U> \tthenComposeAsync(Function<? super T,? extends \n                                                     CompletionStage<U>> fn,\n                                                     Executor executor)\n```\n\n这一组方法接受一个Function作为参数，这个Function的输入是当前的CompletableFuture的计算值，返回结果将是一个新的CompletableFuture，这个新的CompletableFuture会组合原来的CompletableFuture和函数返回的CompletableFuture。因此它的功能类似:\n\n```\nA +--> B +---> C\n```\n\n记住，`thenCompose`返回的对象并不一定是函数`fn`返回的对象，如果原来的`CompletableFuture`还没有计算出来，它就会生成一个新的组合后的CompletableFuture。\n\n例子：\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    return 100;\n});\nCompletableFuture<String> f =  future.thenCompose( i -> {\n    return CompletableFuture.supplyAsync(() -> {\n        return (i * 10) + \"\";\n    });\n});\nSystem.out.println(f.get()); //1000\n```\n\n而下面的一组方法`thenCombine`用来复合另外一个CompletionStage的结果。它的功能类似：\n\n```\nA +\n  |\n  +------> C\n  +------>\nB +\n```\n\n两个CompletionStage是并行执行的，它们之间并没有先后依赖顺序，other并不会等待先前的CompletableFuture执行完毕后再执行。\n\n```java\npublic <U,V> CompletableFuture<V> \tthenCombine(CompletionStage<? extends U> other, \n                                        BiFunction<? super T,? super U,? extends V> fn)\npublic <U,V> CompletableFuture<V> \tthenCombineAsync(CompletionStage<? extends U> other, \n                                        BiFunction<? super T,? super U,? extends V> fn)\npublic <U,V> CompletableFuture<V> \tthenCombineAsync(CompletionStage<? extends U> other,\n                    BiFunction<? super T,? super U,? extends V> fn, Executor executor)\n```\n\n其实从功能上来讲,它们的功能更类似`thenAcceptBoth`，只不过`thenAcceptBoth`是纯消费，它的函数参数没有返回值，而`thenCombine`的函数参数`fn`有返回值。\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    return 100;\n});\nCompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {\n    return \"abc\";\n});\nCompletableFuture<String> f =  future.thenCombine(future2, (x,y) -> y + \"-\" + x);\nSystem.out.println(f.get()); //abc-100\n```\n\n#### 纯消费(执行Action)\n\n上面的方法是当计算完成的时候，会生成新的计算结果(`thenApply`, `handle`)，或者返回同样的计算结果`whenComplete`，`CompletableFuture`还提供了一种处理结果的方法，只对结果执行`Action`,而不返回新的计算值，因此计算值为`Void`:\n\n```java\npublic CompletableFuture<Void> \tthenAccept(Consumer<? super T> action)\npublic CompletableFuture<Void> \tthenAcceptAsync(Consumer<? super T> action)\npublic CompletableFuture<Void> \tthenAcceptAsync(Consumer<? super T> action, Executor executor)\n```\n\n看它的参数类型也就明白了，它们是函数式接口`Consumer`，这个接口只有输入，没有返回值。\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    return 100;\n});\nCompletableFuture<Void> f =  future.thenAccept(System.out::println);\nSystem.out.println(f.get());\n```\n\n`thenAcceptBoth`以及相关方法提供了类似的功能，当两个CompletionStage都正常完成计算的时候，就会执行提供的`action`，它用来组合另外一个异步的结果。\n\n`runAfterBoth`是当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。\n\n```java\npublic <U> CompletableFuture<Void> \tthenAcceptBoth(CompletionStage<? extends U> other,\n                                             BiConsumer<? super T,? super U> action)\npublic <U> CompletableFuture<Void> \tthenAcceptBothAsync(CompletionStage<? extends U> \n                                        other, BiConsumer<? super T,? super U> action)\npublic <U> CompletableFuture<Void> \tthenAcceptBothAsync(CompletionStage<? extends U> \n                     other, BiConsumer<? super T,? super U> action, Executor executor)\npublic     CompletableFuture<Void> \trunAfterBoth(CompletionStage<?> other, \n                                                 Runnable action)\n```\n\n例子如下：\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    return 100;\n});\nCompletableFuture<Void> f = future.thenAcceptBoth(CompletableFuture.completedFuture(10), \n                         \t\t\t(x, y) -> System.out.println(x * y));\nSystem.out.println(f.get());\n```\n\n更彻底地，下面一组方法当计算完成的时候会执行一个Runnable,与`thenAccept`不同，Runnable并不使用CompletableFuture计算的结果。\n\n```java\npublic CompletableFuture<Void> \tthenRun(Runnable action)\npublic CompletableFuture<Void> \tthenRunAsync(Runnable action)\npublic CompletableFuture<Void> \tthenRunAsync(Runnable action, Executor executor)\n```\n\n因此先前的CompletableFuture计算的结果被忽略了,这个方法返回`CompletableFuture<Void>`类型的对象。\n\n```java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    return 100;\n});\nCompletableFuture<Void> f =  future.thenRun(() -> System.out.println(\"finished\"));\nSystem.out.println(f.get());\n```\n\n> 因此，你可以根据方法的参数的类型来加速你的记忆。`Runnable`类型的参数会忽略计算的结果，`Consumer`是纯消费计算结果，`BiConsumer`会组合另外一个`CompletionStage`纯消费，`Function`会对计算结果做转换，`BiFunction`会组合另外一个`CompletionStage`的计算结果做转换。\n\n####  Either\n\n`thenAcceptBoth`和`runAfterBoth`是当两个CompletableFuture都计算完成，而我们下面要了解的方法是当任意一个CompletableFuture计算完成的时候就会执行。\n\n```java\npublic CompletableFuture<Void> \tacceptEither(CompletionStage<? extends T> other, Consumer<? super T> action)\npublic CompletableFuture<Void> \tacceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action)\npublic CompletableFuture<Void> \tacceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action, Executor executor)\n\npublic <U> CompletableFuture<U> \tapplyToEither(CompletionStage<? extends T> other, Function<? super T,U> fn)\npublic <U> CompletableFuture<U> \tapplyToEitherAsync(CompletionStage<? extends T> other, Function<? super T,U> fn)\npublic <U> CompletableFuture<U> \tapplyToEitherAsync(CompletionStage<? extends T> other, Function<? super T,U> fn, Executor executor)\n\n```\n\n**acceptEither`方法是当任意一个CompletionStage完成的时候，`action`这个消费者就会被执行。这个方法返回`CompletableFuture<Void>**\n\n**applyToEither`方法是当任意一个CompletionStage完成的时候，`fn`会被执行，它的返回值会当作新的`CompletableFuture<U>的计算结果。**\n\n下面这个例子有时会输出`100`,有时候会输出`200`,哪个Future先完成就会根据它的结果计算。\n\n```java\nRandom rand = new Random();\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 100;\n});\nCompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 200;\n});\nCompletableFuture<String> f =  future.applyToEither(future2,i -> i.toString());\n```\n\n#### 辅助方法 `allOf` 和 `anyOf`\n\n前面我们已经介绍了几个静态方法：`completedFuture`、`runAsync`、`supplyAsync`,下面介绍的这两个方法用来组合多个CompletableFuture。\n\n```java\npublic static CompletableFuture<Void> \t    allOf(CompletableFuture<?>... cfs)\npublic static CompletableFuture<Object> \tanyOf(CompletableFuture<?>... cfs)\n```\n\n`allOf`方法是当所有的`CompletableFuture`都执行完后执行计算。\n\n`anyOf`方法是当任意一个`CompletableFuture`执行完后就会执行计算，计算的结果相同。\n\n下面的代码运行结果有时是100,有时是\"abc\"。但是`anyOf`和`applyToEither`不同。`anyOf`接受任意多的CompletableFuture但是`applyToEither`只是判断两个CompletableFuture,`anyOf`返回值的计算结果是参数中其中一个CompletableFuture的计算结果，`applyToEither`返回值的计算结果却是要经过`fn`处理的。当然还有静态方法的区别，线程池的选择等。\n\n```java\nRandom rand = new Random();\nCompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 100;\n});\nCompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return \"abc\";\n});\n//CompletableFuture<Void> f =  CompletableFuture.allOf(future1,future2);\nCompletableFuture<Object> f =  CompletableFuture.anyOf(future1,future2);\nSystem.out.println(f.get());\n```\n\n我想通过上面的介绍，应该把CompletableFuture的方法和功能介绍完了(`cancel`、`isCompletedExceptionally()`、`isDone()`以及继承于Object的方法无需介绍了， `toCompletableFuture()`返回CompletableFuture本身)，希望你能全面了解CompletableFuture强大的功能，并将它应用到Java的异步编程中。如果你有使用它的开源项目，可以留言分享一下。\n\n\n\n### 参考\n\n1. [Java CompletableFuture 详解](https://colobu.com/2016/02/29/Java-CompletableFuture/)\n2. [通过实例理解 JDK8 的 CompletableFuture](https://www.ibm.com/developerworks/cn/java/j-cf-of-jdk8/index.html)\n\n","slug":"Java CompletableFuture 详解","published":1,"updated":"2019-01-04T09:19:01.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovs9002g9q1uc52mtywo","content":"<h1 id=\"Java-CompletableFuture-详解\"><a href=\"#Java-CompletableFuture-详解\" class=\"headerlink\" title=\"Java CompletableFuture 详解\"></a>Java CompletableFuture 详解</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>前言</li>\n<li>准备工作</li>\n<li>CompleteableFuture基本使用</li>\n<li>CompletableFuture 类使用示例</li>\n</ol>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Java 5 并发库主要关注于异步任务的处理，它采用了这样一种模式，producer 线程创建任务并且利用阻塞队列将其传递给任务的 consumer。这种模型在 Java 7 和 8 中进一步发展，并且开始支持另外一种风格的任务执行，那就是将任务的数据集分解为子集，每个子集都可以由独立且同质的子任务来负责处理。</p>\n<p>这种风格的基础库也就是 fork/join 框架，它允许程序员规定数据集该如何进行分割，并且支持将子任务提交到默认的标准线程池中，也就是通用的<strong>ForkJoinPool</strong>。Java 8 中，fork/join 并行功能借助并行流的机制变得更加具有可用性。但是，不是所有的问题都适合这种风格的并行处理：所处理的元素必须是独立的，数据集要足够大，并且在并行加速方面，每个元素的处理成本要足够高，这样才能补偿建立 fork/join 框架所消耗的成本。CompletableFuture 类则是 Java 8 在并行流方面的创新。</p>\n<a id=\"more\"></a>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>这里主要介绍下面我们需要使用的一些知识点，主要是为了是读者可以更好的理解。</p>\n<h4 id=\"异步计算\"><a href=\"#异步计算\" class=\"headerlink\" title=\"异步计算\"></a>异步计算</h4><p>所谓异步调用其实就是实现一个可无需等待被调用函数的返回值而让操作继续运行的方法。在 Java 语言中，简单的讲就是另启一个线程来完成调用中的部分计算，使调用继续运行或返回，而不需要等待计算结果。但调用者仍需要取线程的计算结果。</p>\n<h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><p>回调函数比较通用的解释是，它是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外一方调用的，用于对该事件或条件进行响应。</p>\n<p>回调函数的机制：</p>\n<ol>\n<li>定义一个回调函数；</li>\n<li>提供函数实现的一方在初始化时候，将回调函数的函数指针注册给调用者；</li>\n<li>当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。</li>\n</ol>\n<p>回调函数通常与原始调用者处于同一层次，如图 1 所示：</p>\n<h5 id=\"图-1-回调函数示例图\"><a href=\"#图-1-回调函数示例图\" class=\"headerlink\" title=\"图 1. 回调函数示例图\"></a>图 1. 回调函数示例图</h5><p><img src=\"\" alt=\"\"></p>\n<h4 id=\"Future接口\"><a href=\"#Future接口\" class=\"headerlink\" title=\"Future接口\"></a>Future接口</h4><p>JDK5 新增了 Future 接口，用于描述一个异步计算的结果。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式呢？即当计算结果完成及时通知监听者。</p>\n<p>有一些开源框架实现了我们的设想，例如 Netty 的 ChannelFuture 类扩展了 Future 接口，通过提供 addListener 方法实现支持回调方式的异步编程。Netty 中所有的 I/O 操作都是异步的,这意味着任何的 I/O 调用都将立即返回，而不保证这些被请求的 I/O 操作在调用结束的时候已经完成。取而代之地，你会得到一个返回的 ChannelFuture 实例，这个实例将给你一些关于 I/O 操作结果或者状态的信息。当一个 I/O 操作开始的时候，一个新的 Future 对象就会被创建。在开始的时候，新的 Future 是未完成的状态－－它既非成功、失败，也非被取消，因为 I/O 操作还没有结束。如果 I/O 操作以成功、失败或者被取消中的任何一种状态结束了，那么这个 Future 将会被标记为已完成，并包含更多详细的信息（例如：失败的原因）。请注意，即使是失败和被取消的状态，也是属于已完成的状态。阻塞方式的示例代码如清单 1 所示。</p>\n<h5 id=\"清单-1-阻塞方式示例代码\"><a href=\"#清单-1-阻塞方式示例代码\" class=\"headerlink\" title=\"清单 1. 阻塞方式示例代码\"></a>清单 1. 阻塞方式示例代码</h5><pre><code class=\"java\">`// Start the connection attempt.``ChannelFuture Future = bootstrap.connect(new InetSocketAddress(host, port));``// Wait until the connection is closed or the connection attempt fails.``Future.getChannel().getCloseFuture().awaitUninterruptibly();``// Shut down thread pools to exit.``bootstrap.releaseExternalResources();`\n</code></pre>\n<p>上面代码使用的是 awaitUninterruptibly 方法，源代码如清单 2 所示。</p>\n<h5 id=\"清单-2-awaitUninterruptibly-源代码\"><a href=\"#清单-2-awaitUninterruptibly-源代码\" class=\"headerlink\" title=\"清单 2. awaitUninterruptibly 源代码\"></a>清单 2. awaitUninterruptibly 源代码</h5><pre><code class=\"java\">publicChannelFutureawaitUninterruptibly() {\n    boolean interrupted = false;\n    synchronized (this) {\n        //循环等待到完成\n        while (!done) {\n            checkDeadLock();\n            waiters++;\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                //不允许中断\n                interrupted = true;\n            } finally {\n                waiters--;\n            }\n            }\n    }\n    if (interrupted) {\n           Thread.currentThread().interrupt();\n    }\n    return this;\n}\n</code></pre>\n<h5 id=\"清单-3-异步非阻塞方式示例代码\"><a href=\"#清单-3-异步非阻塞方式示例代码\" class=\"headerlink\" title=\"清单 3. 异步非阻塞方式示例代码\"></a>清单 3. 异步非阻塞方式示例代码</h5><pre><code class=\"java\">// 尝试建立一个连接\nChannelFuture Future = bootstrap.connect(new InetSocketAddress(host, port));\n// 注册连接完成监听器\nFuture.addListener(new ChannelFutureListener(){\n    public void operationComplete(final ChannelFuture Future)\n        throws Exception {    \n        System.out.println(&quot;连接建立完成&quot;);\n    }\n});\n printTime(&quot;异步时间：&quot;);\n// 连接关闭，释放资源\nbootstrap.releaseExternalResources();\n</code></pre>\n<p>可以明显的看出，在异步模式下，上面这段代码没有阻塞，在执行 connect 操作后直接执行到<strong> printTime(“异步时间： “)</strong>，随后 connect 完成，Future 的监听函数输出 connect 操作完成。</p>\n<p>非阻塞则是添加监听类 ChannelFutureListener，通过覆盖 ChannelFutureListener 的 operationComplete 执行业务逻辑。</p>\n<h5 id=\"清单-4-异步非阻塞方式示例代码\"><a href=\"#清单-4-异步非阻塞方式示例代码\" class=\"headerlink\" title=\"清单 4. 异步非阻塞方式示例代码\"></a>清单 4. 异步非阻塞方式示例代码</h5><pre><code class=\"java\">`public void addListener(final ChannelFutureListener listener) {``    ``if (listener == null) {``    ``throw new NullPointerException(&quot;listener&quot;);``}``    ``booleannotifyNow = false;``    ``synchronized (this) {``        ``if (done) {``        ``notifyNow = true;``    ``} else {``        ``if (firstListener == null) {``        ``//listener 链表头``        ``firstListener = listener;``    ``} else {``        ``if (otherListeners == null) {``        ``otherListeners = new ArrayList&lt;``ChannelFutureListener``&gt;(1);``        ``}``        ``//添加到 listener 链表中，以便操作完成后遍历操作``        ``otherListeners.add(listener);``    ``}``    ``......``    ``if (notifyNow) {``        ``//通知 listener 进行处理``        ``notifyListener(listener);``        ``}``}`\n</code></pre>\n<p>这部分代码的逻辑很简单，就是注册回调函数，当操作完成后自动调用回调函数，就达到了异步的效果。</p>\n<h3 id=\"CompleteableFuture基本使用\"><a href=\"#CompleteableFuture基本使用\" class=\"headerlink\" title=\"CompleteableFuture基本使用\"></a>CompleteableFuture基本使用</h3><p>在Java 8中, 新增加了一个包含50个方法左右的类: <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html\" target=\"_blank\" rel=\"noopener\">CompletableFuture</a>，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p>\n<p>如果想使用以前阻塞或者轮询方式来使用，依然可以通过 CompletableFuture 类来实现，因为CompleteableFuture实现了 CompletionStage 和 Future 接口方，因此也支持这种方式。</p>\n<p>CompletableFuture 类声明了 CompletionStage 接口，CompletionStage 接口实际上提供了同步或异步运行计算的舞台，所以我们可以通过实现多个 CompletionStage 命令，并且将这些命令串联在一起的方式实现多个命令之间的触发。</p>\n<h4 id=\"同步方式完成计算\"><a href=\"#同步方式完成计算\" class=\"headerlink\" title=\"同步方式完成计算\"></a>同步方式完成计算</h4><p>CompletableFuture类实现了<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html\" target=\"_blank\" rel=\"noopener\">CompletionStage</a>和<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html\" target=\"_blank\" rel=\"noopener\">Future</a>接口，所以你还是可以像以前一样通过阻塞或者轮询的方式获得结果，尽管这种方式不推荐使用。</p>\n<pre><code class=\"java\">public T     get()\npublic T     get(long timeout, TimeUnit unit)\npublic T     getNow(T valueIfAbsent)\npublic T     join()\n</code></pre>\n<p><code>getNow</code>有点特殊，如果结果已经计算完则返回结果或者抛出异常，否则返回给定的<code>valueIfAbsent</code>值。<br><code>join</code>返回计算的结果或者抛出一个unchecked异常(CompletionException)，可以不进行捕捉，它和<code>get</code>对抛出的异常的处理有些细微的区别，你可以运行下面的代码进行比较：</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    int i = 1/0;\n    return 100;\n});\n// join的使用方式\n//future.join();\n\n// get必须要捕捉异常，对异常进行处理\n  try {\n            future.get();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n</code></pre>\n<p>尽管Future可以代表在另外的线程中执行的一段异步代码，但是你还是可以在本身线程中执行：</p>\n<pre><code class=\"java\">public static CompletableFuture&lt;Integer&gt; compute() {\n    final CompletableFuture&lt;Integer&gt; future = new CompletableFuture&lt;&gt;();\n\n    return future;\n}\n</code></pre>\n<p>上面的代码中<code>future</code>没有关联任何的<code>Callback</code>、线程池、异步任务等，如果客户端调用<code>future.get</code>就会一直傻等下去。你可以通过下面的代码完成一个计算，触发客户端的等待：</p>\n<pre><code>f.complete(100);\n</code></pre><p>当然你也可以抛出一个异常，而不是一个成功的计算结果：</p>\n<pre><code>f.completeExceptionally(new Exception());\n</code></pre><p>完整的代码如下：</p>\n<pre><code class=\"java\">public class BasicMain {\n    public static CompletableFuture&lt;Integer&gt; compute() {\n        final CompletableFuture&lt;Integer&gt; future = new CompletableFuture&lt;&gt;();\n        return future;\n    }\n    public static void main(String[] args) throws Exception {\n        final CompletableFuture&lt;Integer&gt; f = compute();\n        class Client extends Thread {\n            CompletableFuture&lt;Integer&gt; f;\n            Client(String threadName, CompletableFuture&lt;Integer&gt; f) {\n                super(threadName);\n                this.f = f;\n            }\n            @Override\n            public void run() {\n                try {\n                    System.out.println(this.getName() + &quot;: &quot; + f.get());\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (ExecutionException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        new Client(&quot;Client1&quot;, f).start();\n        new Client(&quot;Client2&quot;, f).start();\n        System.out.println(&quot;waiting&quot;);\n        f.complete(100);\n        //f.completeExceptionally(new Exception());\n        System.in.read();\n    }\n}\n</code></pre>\n<p>可以看到我们并没有把<code>f.complete(100);</code>放在另外的线程中去执行，但是在大部分情况下我们可能会用一个线程池去执行这些异步任务。<code>CompletableFuture.complete()</code>、<code>CompletableFuture.completeExceptionally</code>只能被调用一次。但是我们有两个后门方法可以重设这个值:<code>obtrudeValue</code>、<code>obtrudeException</code>，但是使用的时候要小心，因为<code>complete</code>已经触发了客户端，有可能导致客户端会得到不期望的结果。</p>\n<h4 id=\"创建CompletableFuture对象\"><a href=\"#创建CompletableFuture对象\" class=\"headerlink\" title=\"创建CompletableFuture对象\"></a>创建CompletableFuture对象</h4><p><code>CompletableFuture.completedFuture</code>是一个静态辅助方法，用来返回一个已经计算好的<code>CompletableFuture</code>。</p>\n<pre><code class=\"java\">public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value)\n</code></pre>\n<p>而以下四个静态方法用来为一段异步执行的代码创建<code>CompletableFuture</code>对象：</p>\n<pre><code class=\"java\">public static CompletableFuture&lt;Void&gt;     runAsync(Runnable runnable)\npublic static CompletableFuture&lt;Void&gt;     runAsync(Runnable runnable, Executor executor)\npublic static &lt;U&gt; CompletableFuture&lt;U&gt;     supplyAsync(Supplier&lt;U&gt; supplier)\npublic static &lt;U&gt; CompletableFuture&lt;U&gt;     supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)\n</code></pre>\n<p>以<code>Async</code>结尾并且没有指定<code>Executor</code>的方法会使用<code>ForkJoinPool.commonPool()</code>作为它的线程池执行异步代码。</p>\n<p><code>runAsync</code>方法也好理解，它以<code>Runnable</code>函数式接口类型为参数，所以<code>CompletableFuture</code>的计算结果为空。</p>\n<p><code>supplyAsync</code>方法以<code>Supplier&lt;U&gt;</code>函数式接口类型为参数,<code>CompletableFuture</code>的计算结果类型为<code>U</code>。</p>\n<p>因为方法的参数类型都是函数式接口，所以可以使用lambda表达式实现异步任务，比如：</p>\n<pre><code class=\"java\">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    //长时间的计算任务\n    return &quot;处理完成&quot;;\n});\n</code></pre>\n<h4 id=\"计算结果完成时的处理\"><a href=\"#计算结果完成时的处理\" class=\"headerlink\" title=\"计算结果完成时的处理\"></a>计算结果完成时的处理</h4><p>当<code>CompletableFuture</code>的计算结果完成，或者抛出异常的时候，我们可以执行特定的<code>Action</code>。主要是下面的方法：</p>\n<pre><code class=\"java\">public CompletableFuture&lt;T&gt;     whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)\npublic CompletableFuture&lt;T&gt;     whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)\npublic CompletableFuture&lt;T&gt;     whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)\npublic CompletableFuture&lt;T&gt;     exceptionally(Function&lt;Throwable,? extends T&gt; fn)\n</code></pre>\n<p>可以看到<code>Action</code>的类型是<code>BiConsumer&lt;? super T,? super Throwable&gt;</code>，它可以处理正常的计算结果，或者异常情况。<br>方法不以<code>Async</code>结尾，意味着<code>Action</code>使用相同的线程执行，而<code>Async</code>可能会使用其它的线程去执行(如果使用相同的线程池，也可能会被同一个线程选中执行)。</p>\n<p>注意这几个方法都会返回<code>CompletableFuture</code>，当<code>Action</code>执行完毕后它的结果返回原始的<code>CompletableFuture</code>的计算结果或者返回异常。</p>\n<pre><code class=\"java\">public class Main {\n    private static Random rand = new Random();\n    private static long t = System.currentTimeMillis();\n    static int getMoreData() {\n        System.out.println(&quot;begin to start compute&quot;);\n        try {\n            Thread.sleep(10000);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        System.out.println(&quot;end to start compute. passed &quot; + \n                           (System.currentTimeMillis() - t)/1000 + &quot; seconds&quot;);\n        return rand.nextInt(1000);\n    }\n    public static void main(String[] args) throws Exception {\n        CompletableFuture&lt;Integer&gt; future = \n            CompletableFuture.supplyAsync(Main::getMoreData);\n        Future&lt;Integer&gt; f = future.whenComplete((v, e) -&gt; {\n            System.out.println(v);\n            System.out.println(e);\n        });\n        System.out.println(f.get());\n        System.in.read();\n    }\n}\n</code></pre>\n<p><code>exceptionally</code>方法返回一个新的CompletableFuture，当原始的CompletableFuture抛出异常的时候，就会触发这个CompletableFuture的计算，调用function计算值，否则如果原始的CompletableFuture正常计算完后，这个新的CompletableFuture也计算完成，它的值和原始的CompletableFuture的计算的值相同。也就是这个<code>exceptionally</code>方法用来处理异常的情况。</p>\n<p>下面一组方法虽然也返回CompletableFuture对象，但是对象的值和原来的CompletableFuture计算的值不同。当原先的CompletableFuture的值计算完成或者抛出异常的时候，会触发这个CompletableFuture对象的计算，结果由<code>BiFunction</code>参数计算而得。因此这组方法兼有<code>whenComplete</code>和转换的两个功能。</p>\n<pre><code class=\"java\">public &lt;U&gt; CompletableFuture&lt;U&gt;     handle(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn, Executor executor)\n</code></pre>\n<p>同样，不以<code>Async</code>结尾的方法由原来的线程计算，以<code>Async</code>结尾的方法由默认的线程池<code>ForkJoinPool.commonPool()</code>或者指定的线程池<code>executor</code>运行。</p>\n<h4 id=\"组合\"><a href=\"#组合\" class=\"headerlink\" title=\"组合\"></a>组合</h4><p><code>CompletableFuture</code>可以作为monad(单子)和functor。由于回调风格的实现，我们不必因为等待一个计算完成而阻塞着调用线程，而是告诉<code>CompletableFuture</code>当计算完成的时候请执行某个<code>function</code>。而且我们还可以将这些操作串联起来，或者将<code>CompletableFuture</code>组合起来。</p>\n<pre><code class=\"java\">public &lt;U&gt; CompletableFuture&lt;U&gt;     thenApply(Function&lt;? super T,? extends U&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)\n</code></pre>\n<p>这一组函数的功能是当原来的CompletableFuture计算完后，将结果传递给函数<code>fn</code>，将<code>fn</code>的结果作为新的<code>CompletableFuture</code>计算结果。因此它的功能相当于将<code>CompletableFuture&lt;T&gt;</code>转换成<code>CompletableFuture&lt;U&gt;</code>。</p>\n<p>这三个函数的区别和上面介绍的一样，不以<code>Async</code>结尾的方法由原来的线程计算，以<code>Async</code>结尾的方法由默认的线程池<code>ForkJoinPool.commonPool()</code>或者指定的线程池<code>executor</code>运行。Java的CompletableFuture类总是遵循这样的原则，下面就不一一赘述了。</p>\n<p>使用例子如下：</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    return 100;\n});\nCompletableFuture&lt;String&gt; f =  future\n                                .thenApplyAsync(i -&gt; i * 10)\n                                .thenApply(i -&gt; i.toString());\nSystem.out.println(f.get()); //&quot;1000&quot;\n</code></pre>\n<p>需要注意的是，这些转换并不是马上执行的，也不会阻塞，而是在前一个stage完成后继续执行。</p>\n<p><strong>它们与<code>handle</code>方法的区别在于<code>handle</code>方法会处理正常计算值和异常，因此它可以屏蔽异常，避免异常继续抛出。而<code>thenApply</code>方法只是用来处理正常值，因此一旦有异常就会抛出。</strong></p>\n<p>上面的前一个CompleteFuture执行完成执行后一个，下面的是同时执行或者其中一个执行完成就代表执行完成。</p>\n<pre><code class=\"java\">public &lt;U&gt; CompletableFuture&lt;U&gt;     thenCompose(Function&lt;? super T,? extends \n                                                CompletionStage&lt;U&gt;&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     thenComposeAsync(Function&lt;? super T,? extends \n                                                     CompletionStage&lt;U&gt;&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     thenComposeAsync(Function&lt;? super T,? extends \n                                                     CompletionStage&lt;U&gt;&gt; fn,\n                                                     Executor executor)\n</code></pre>\n<p>这一组方法接受一个Function作为参数，这个Function的输入是当前的CompletableFuture的计算值，返回结果将是一个新的CompletableFuture，这个新的CompletableFuture会组合原来的CompletableFuture和函数返回的CompletableFuture。因此它的功能类似:</p>\n<pre><code>A +--&gt; B +---&gt; C\n</code></pre><p>记住，<code>thenCompose</code>返回的对象并不一定是函数<code>fn</code>返回的对象，如果原来的<code>CompletableFuture</code>还没有计算出来，它就会生成一个新的组合后的CompletableFuture。</p>\n<p>例子：</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    return 100;\n});\nCompletableFuture&lt;String&gt; f =  future.thenCompose( i -&gt; {\n    return CompletableFuture.supplyAsync(() -&gt; {\n        return (i * 10) + &quot;&quot;;\n    });\n});\nSystem.out.println(f.get()); //1000\n</code></pre>\n<p>而下面的一组方法<code>thenCombine</code>用来复合另外一个CompletionStage的结果。它的功能类似：</p>\n<pre><code>A +\n  |\n  +------&gt; C\n  +------&gt;\nB +\n</code></pre><p>两个CompletionStage是并行执行的，它们之间并没有先后依赖顺序，other并不会等待先前的CompletableFuture执行完毕后再执行。</p>\n<pre><code class=\"java\">public &lt;U,V&gt; CompletableFuture&lt;V&gt;     thenCombine(CompletionStage&lt;? extends U&gt; other, \n                                        BiFunction&lt;? super T,? super U,? extends V&gt; fn)\npublic &lt;U,V&gt; CompletableFuture&lt;V&gt;     thenCombineAsync(CompletionStage&lt;? extends U&gt; other, \n                                        BiFunction&lt;? super T,? super U,? extends V&gt; fn)\npublic &lt;U,V&gt; CompletableFuture&lt;V&gt;     thenCombineAsync(CompletionStage&lt;? extends U&gt; other,\n                    BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor)\n</code></pre>\n<p>其实从功能上来讲,它们的功能更类似<code>thenAcceptBoth</code>，只不过<code>thenAcceptBoth</code>是纯消费，它的函数参数没有返回值，而<code>thenCombine</code>的函数参数<code>fn</code>有返回值。</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    return 100;\n});\nCompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; {\n    return &quot;abc&quot;;\n});\nCompletableFuture&lt;String&gt; f =  future.thenCombine(future2, (x,y) -&gt; y + &quot;-&quot; + x);\nSystem.out.println(f.get()); //abc-100\n</code></pre>\n<h4 id=\"纯消费-执行Action\"><a href=\"#纯消费-执行Action\" class=\"headerlink\" title=\"纯消费(执行Action)\"></a>纯消费(执行Action)</h4><p>上面的方法是当计算完成的时候，会生成新的计算结果(<code>thenApply</code>, <code>handle</code>)，或者返回同样的计算结果<code>whenComplete</code>，<code>CompletableFuture</code>还提供了一种处理结果的方法，只对结果执行<code>Action</code>,而不返回新的计算值，因此计算值为<code>Void</code>:</p>\n<pre><code class=\"java\">public CompletableFuture&lt;Void&gt;     thenAccept(Consumer&lt;? super T&gt; action)\npublic CompletableFuture&lt;Void&gt;     thenAcceptAsync(Consumer&lt;? super T&gt; action)\npublic CompletableFuture&lt;Void&gt;     thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)\n</code></pre>\n<p>看它的参数类型也就明白了，它们是函数式接口<code>Consumer</code>，这个接口只有输入，没有返回值。</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    return 100;\n});\nCompletableFuture&lt;Void&gt; f =  future.thenAccept(System.out::println);\nSystem.out.println(f.get());\n</code></pre>\n<p><code>thenAcceptBoth</code>以及相关方法提供了类似的功能，当两个CompletionStage都正常完成计算的时候，就会执行提供的<code>action</code>，它用来组合另外一个异步的结果。</p>\n<p><code>runAfterBoth</code>是当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。</p>\n<pre><code class=\"java\">public &lt;U&gt; CompletableFuture&lt;Void&gt;     thenAcceptBoth(CompletionStage&lt;? extends U&gt; other,\n                                             BiConsumer&lt;? super T,? super U&gt; action)\npublic &lt;U&gt; CompletableFuture&lt;Void&gt;     thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; \n                                        other, BiConsumer&lt;? super T,? super U&gt; action)\npublic &lt;U&gt; CompletableFuture&lt;Void&gt;     thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; \n                     other, BiConsumer&lt;? super T,? super U&gt; action, Executor executor)\npublic     CompletableFuture&lt;Void&gt;     runAfterBoth(CompletionStage&lt;?&gt; other, \n                                                 Runnable action)\n</code></pre>\n<p>例子如下：</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    return 100;\n});\nCompletableFuture&lt;Void&gt; f = future.thenAcceptBoth(CompletableFuture.completedFuture(10), \n                                     (x, y) -&gt; System.out.println(x * y));\nSystem.out.println(f.get());\n</code></pre>\n<p>更彻底地，下面一组方法当计算完成的时候会执行一个Runnable,与<code>thenAccept</code>不同，Runnable并不使用CompletableFuture计算的结果。</p>\n<pre><code class=\"java\">public CompletableFuture&lt;Void&gt;     thenRun(Runnable action)\npublic CompletableFuture&lt;Void&gt;     thenRunAsync(Runnable action)\npublic CompletableFuture&lt;Void&gt;     thenRunAsync(Runnable action, Executor executor)\n</code></pre>\n<p>因此先前的CompletableFuture计算的结果被忽略了,这个方法返回<code>CompletableFuture&lt;Void&gt;</code>类型的对象。</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    return 100;\n});\nCompletableFuture&lt;Void&gt; f =  future.thenRun(() -&gt; System.out.println(&quot;finished&quot;));\nSystem.out.println(f.get());\n</code></pre>\n<blockquote>\n<p>因此，你可以根据方法的参数的类型来加速你的记忆。<code>Runnable</code>类型的参数会忽略计算的结果，<code>Consumer</code>是纯消费计算结果，<code>BiConsumer</code>会组合另外一个<code>CompletionStage</code>纯消费，<code>Function</code>会对计算结果做转换，<code>BiFunction</code>会组合另外一个<code>CompletionStage</code>的计算结果做转换。</p>\n</blockquote>\n<h4 id=\"Either\"><a href=\"#Either\" class=\"headerlink\" title=\"Either\"></a>Either</h4><p><code>thenAcceptBoth</code>和<code>runAfterBoth</code>是当两个CompletableFuture都计算完成，而我们下面要了解的方法是当任意一个CompletableFuture计算完成的时候就会执行。</p>\n<pre><code class=\"java\">public CompletableFuture&lt;Void&gt;     acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)\npublic CompletableFuture&lt;Void&gt;     acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)\npublic CompletableFuture&lt;Void&gt;     acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)\n\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn, Executor executor)\n\n</code></pre>\n<p><strong>acceptEither<code>方法是当任意一个CompletionStage完成的时候，</code>action<code>这个消费者就会被执行。这个方法返回</code>CompletableFuture<void></void></strong></p>\n<p><strong>applyToEither<code>方法是当任意一个CompletionStage完成的时候，</code>fn<code>会被执行，它的返回值会当作新的</code>CompletableFuture<u>的计算结果。</u></strong></p>\n<p>下面这个例子有时会输出<code>100</code>,有时候会输出<code>200</code>,哪个Future先完成就会根据它的结果计算。</p>\n<pre><code class=\"java\">Random rand = new Random();\nCompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 100;\n});\nCompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 200;\n});\nCompletableFuture&lt;String&gt; f =  future.applyToEither(future2,i -&gt; i.toString());\n</code></pre>\n<h4 id=\"辅助方法-allOf-和-anyOf\"><a href=\"#辅助方法-allOf-和-anyOf\" class=\"headerlink\" title=\"辅助方法 allOf 和 anyOf\"></a>辅助方法 <code>allOf</code> 和 <code>anyOf</code></h4><p>前面我们已经介绍了几个静态方法：<code>completedFuture</code>、<code>runAsync</code>、<code>supplyAsync</code>,下面介绍的这两个方法用来组合多个CompletableFuture。</p>\n<pre><code class=\"java\">public static CompletableFuture&lt;Void&gt;         allOf(CompletableFuture&lt;?&gt;... cfs)\npublic static CompletableFuture&lt;Object&gt;     anyOf(CompletableFuture&lt;?&gt;... cfs)\n</code></pre>\n<p><code>allOf</code>方法是当所有的<code>CompletableFuture</code>都执行完后执行计算。</p>\n<p><code>anyOf</code>方法是当任意一个<code>CompletableFuture</code>执行完后就会执行计算，计算的结果相同。</p>\n<p>下面的代码运行结果有时是100,有时是”abc”。但是<code>anyOf</code>和<code>applyToEither</code>不同。<code>anyOf</code>接受任意多的CompletableFuture但是<code>applyToEither</code>只是判断两个CompletableFuture,<code>anyOf</code>返回值的计算结果是参数中其中一个CompletableFuture的计算结果，<code>applyToEither</code>返回值的计算结果却是要经过<code>fn</code>处理的。当然还有静态方法的区别，线程池的选择等。</p>\n<pre><code class=\"java\">Random rand = new Random();\nCompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 100;\n});\nCompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return &quot;abc&quot;;\n});\n//CompletableFuture&lt;Void&gt; f =  CompletableFuture.allOf(future1,future2);\nCompletableFuture&lt;Object&gt; f =  CompletableFuture.anyOf(future1,future2);\nSystem.out.println(f.get());\n</code></pre>\n<p>我想通过上面的介绍，应该把CompletableFuture的方法和功能介绍完了(<code>cancel</code>、<code>isCompletedExceptionally()</code>、<code>isDone()</code>以及继承于Object的方法无需介绍了， <code>toCompletableFuture()</code>返回CompletableFuture本身)，希望你能全面了解CompletableFuture强大的功能，并将它应用到Java的异步编程中。如果你有使用它的开源项目，可以留言分享一下。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://colobu.com/2016/02/29/Java-CompletableFuture/\" target=\"_blank\" rel=\"noopener\">Java CompletableFuture 详解</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-cf-of-jdk8/index.html\" target=\"_blank\" rel=\"noopener\">通过实例理解 JDK8 的 CompletableFuture</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java-CompletableFuture-详解\"><a href=\"#Java-CompletableFuture-详解\" class=\"headerlink\" title=\"Java CompletableFuture 详解\"></a>Java CompletableFuture 详解</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>前言</li>\n<li>准备工作</li>\n<li>CompleteableFuture基本使用</li>\n<li>CompletableFuture 类使用示例</li>\n</ol>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Java 5 并发库主要关注于异步任务的处理，它采用了这样一种模式，producer 线程创建任务并且利用阻塞队列将其传递给任务的 consumer。这种模型在 Java 7 和 8 中进一步发展，并且开始支持另外一种风格的任务执行，那就是将任务的数据集分解为子集，每个子集都可以由独立且同质的子任务来负责处理。</p>\n<p>这种风格的基础库也就是 fork/join 框架，它允许程序员规定数据集该如何进行分割，并且支持将子任务提交到默认的标准线程池中，也就是通用的<strong>ForkJoinPool</strong>。Java 8 中，fork/join 并行功能借助并行流的机制变得更加具有可用性。但是，不是所有的问题都适合这种风格的并行处理：所处理的元素必须是独立的，数据集要足够大，并且在并行加速方面，每个元素的处理成本要足够高，这样才能补偿建立 fork/join 框架所消耗的成本。CompletableFuture 类则是 Java 8 在并行流方面的创新。</p>","more":"<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>这里主要介绍下面我们需要使用的一些知识点，主要是为了是读者可以更好的理解。</p>\n<h4 id=\"异步计算\"><a href=\"#异步计算\" class=\"headerlink\" title=\"异步计算\"></a>异步计算</h4><p>所谓异步调用其实就是实现一个可无需等待被调用函数的返回值而让操作继续运行的方法。在 Java 语言中，简单的讲就是另启一个线程来完成调用中的部分计算，使调用继续运行或返回，而不需要等待计算结果。但调用者仍需要取线程的计算结果。</p>\n<h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><p>回调函数比较通用的解释是，它是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外一方调用的，用于对该事件或条件进行响应。</p>\n<p>回调函数的机制：</p>\n<ol>\n<li>定义一个回调函数；</li>\n<li>提供函数实现的一方在初始化时候，将回调函数的函数指针注册给调用者；</li>\n<li>当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。</li>\n</ol>\n<p>回调函数通常与原始调用者处于同一层次，如图 1 所示：</p>\n<h5 id=\"图-1-回调函数示例图\"><a href=\"#图-1-回调函数示例图\" class=\"headerlink\" title=\"图 1. 回调函数示例图\"></a>图 1. 回调函数示例图</h5><p><img src=\"\" alt=\"\"></p>\n<h4 id=\"Future接口\"><a href=\"#Future接口\" class=\"headerlink\" title=\"Future接口\"></a>Future接口</h4><p>JDK5 新增了 Future 接口，用于描述一个异步计算的结果。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式呢？即当计算结果完成及时通知监听者。</p>\n<p>有一些开源框架实现了我们的设想，例如 Netty 的 ChannelFuture 类扩展了 Future 接口，通过提供 addListener 方法实现支持回调方式的异步编程。Netty 中所有的 I/O 操作都是异步的,这意味着任何的 I/O 调用都将立即返回，而不保证这些被请求的 I/O 操作在调用结束的时候已经完成。取而代之地，你会得到一个返回的 ChannelFuture 实例，这个实例将给你一些关于 I/O 操作结果或者状态的信息。当一个 I/O 操作开始的时候，一个新的 Future 对象就会被创建。在开始的时候，新的 Future 是未完成的状态－－它既非成功、失败，也非被取消，因为 I/O 操作还没有结束。如果 I/O 操作以成功、失败或者被取消中的任何一种状态结束了，那么这个 Future 将会被标记为已完成，并包含更多详细的信息（例如：失败的原因）。请注意，即使是失败和被取消的状态，也是属于已完成的状态。阻塞方式的示例代码如清单 1 所示。</p>\n<h5 id=\"清单-1-阻塞方式示例代码\"><a href=\"#清单-1-阻塞方式示例代码\" class=\"headerlink\" title=\"清单 1. 阻塞方式示例代码\"></a>清单 1. 阻塞方式示例代码</h5><pre><code class=\"java\">`// Start the connection attempt.``ChannelFuture Future = bootstrap.connect(new InetSocketAddress(host, port));``// Wait until the connection is closed or the connection attempt fails.``Future.getChannel().getCloseFuture().awaitUninterruptibly();``// Shut down thread pools to exit.``bootstrap.releaseExternalResources();`\n</code></pre>\n<p>上面代码使用的是 awaitUninterruptibly 方法，源代码如清单 2 所示。</p>\n<h5 id=\"清单-2-awaitUninterruptibly-源代码\"><a href=\"#清单-2-awaitUninterruptibly-源代码\" class=\"headerlink\" title=\"清单 2. awaitUninterruptibly 源代码\"></a>清单 2. awaitUninterruptibly 源代码</h5><pre><code class=\"java\">publicChannelFutureawaitUninterruptibly() {\n    boolean interrupted = false;\n    synchronized (this) {\n        //循环等待到完成\n        while (!done) {\n            checkDeadLock();\n            waiters++;\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                //不允许中断\n                interrupted = true;\n            } finally {\n                waiters--;\n            }\n            }\n    }\n    if (interrupted) {\n           Thread.currentThread().interrupt();\n    }\n    return this;\n}\n</code></pre>\n<h5 id=\"清单-3-异步非阻塞方式示例代码\"><a href=\"#清单-3-异步非阻塞方式示例代码\" class=\"headerlink\" title=\"清单 3. 异步非阻塞方式示例代码\"></a>清单 3. 异步非阻塞方式示例代码</h5><pre><code class=\"java\">// 尝试建立一个连接\nChannelFuture Future = bootstrap.connect(new InetSocketAddress(host, port));\n// 注册连接完成监听器\nFuture.addListener(new ChannelFutureListener(){\n    public void operationComplete(final ChannelFuture Future)\n        throws Exception {    \n        System.out.println(&quot;连接建立完成&quot;);\n    }\n});\n printTime(&quot;异步时间：&quot;);\n// 连接关闭，释放资源\nbootstrap.releaseExternalResources();\n</code></pre>\n<p>可以明显的看出，在异步模式下，上面这段代码没有阻塞，在执行 connect 操作后直接执行到<strong> printTime(“异步时间： “)</strong>，随后 connect 完成，Future 的监听函数输出 connect 操作完成。</p>\n<p>非阻塞则是添加监听类 ChannelFutureListener，通过覆盖 ChannelFutureListener 的 operationComplete 执行业务逻辑。</p>\n<h5 id=\"清单-4-异步非阻塞方式示例代码\"><a href=\"#清单-4-异步非阻塞方式示例代码\" class=\"headerlink\" title=\"清单 4. 异步非阻塞方式示例代码\"></a>清单 4. 异步非阻塞方式示例代码</h5><pre><code class=\"java\">`public void addListener(final ChannelFutureListener listener) {``    ``if (listener == null) {``    ``throw new NullPointerException(&quot;listener&quot;);``}``    ``booleannotifyNow = false;``    ``synchronized (this) {``        ``if (done) {``        ``notifyNow = true;``    ``} else {``        ``if (firstListener == null) {``        ``//listener 链表头``        ``firstListener = listener;``    ``} else {``        ``if (otherListeners == null) {``        ``otherListeners = new ArrayList&lt;``ChannelFutureListener``&gt;(1);``        ``}``        ``//添加到 listener 链表中，以便操作完成后遍历操作``        ``otherListeners.add(listener);``    ``}``    ``......``    ``if (notifyNow) {``        ``//通知 listener 进行处理``        ``notifyListener(listener);``        ``}``}`\n</code></pre>\n<p>这部分代码的逻辑很简单，就是注册回调函数，当操作完成后自动调用回调函数，就达到了异步的效果。</p>\n<h3 id=\"CompleteableFuture基本使用\"><a href=\"#CompleteableFuture基本使用\" class=\"headerlink\" title=\"CompleteableFuture基本使用\"></a>CompleteableFuture基本使用</h3><p>在Java 8中, 新增加了一个包含50个方法左右的类: <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html\" target=\"_blank\" rel=\"noopener\">CompletableFuture</a>，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p>\n<p>如果想使用以前阻塞或者轮询方式来使用，依然可以通过 CompletableFuture 类来实现，因为CompleteableFuture实现了 CompletionStage 和 Future 接口方，因此也支持这种方式。</p>\n<p>CompletableFuture 类声明了 CompletionStage 接口，CompletionStage 接口实际上提供了同步或异步运行计算的舞台，所以我们可以通过实现多个 CompletionStage 命令，并且将这些命令串联在一起的方式实现多个命令之间的触发。</p>\n<h4 id=\"同步方式完成计算\"><a href=\"#同步方式完成计算\" class=\"headerlink\" title=\"同步方式完成计算\"></a>同步方式完成计算</h4><p>CompletableFuture类实现了<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html\" target=\"_blank\" rel=\"noopener\">CompletionStage</a>和<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html\" target=\"_blank\" rel=\"noopener\">Future</a>接口，所以你还是可以像以前一样通过阻塞或者轮询的方式获得结果，尽管这种方式不推荐使用。</p>\n<pre><code class=\"java\">public T     get()\npublic T     get(long timeout, TimeUnit unit)\npublic T     getNow(T valueIfAbsent)\npublic T     join()\n</code></pre>\n<p><code>getNow</code>有点特殊，如果结果已经计算完则返回结果或者抛出异常，否则返回给定的<code>valueIfAbsent</code>值。<br><code>join</code>返回计算的结果或者抛出一个unchecked异常(CompletionException)，可以不进行捕捉，它和<code>get</code>对抛出的异常的处理有些细微的区别，你可以运行下面的代码进行比较：</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    int i = 1/0;\n    return 100;\n});\n// join的使用方式\n//future.join();\n\n// get必须要捕捉异常，对异常进行处理\n  try {\n            future.get();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n</code></pre>\n<p>尽管Future可以代表在另外的线程中执行的一段异步代码，但是你还是可以在本身线程中执行：</p>\n<pre><code class=\"java\">public static CompletableFuture&lt;Integer&gt; compute() {\n    final CompletableFuture&lt;Integer&gt; future = new CompletableFuture&lt;&gt;();\n\n    return future;\n}\n</code></pre>\n<p>上面的代码中<code>future</code>没有关联任何的<code>Callback</code>、线程池、异步任务等，如果客户端调用<code>future.get</code>就会一直傻等下去。你可以通过下面的代码完成一个计算，触发客户端的等待：</p>\n<pre><code>f.complete(100);\n</code></pre><p>当然你也可以抛出一个异常，而不是一个成功的计算结果：</p>\n<pre><code>f.completeExceptionally(new Exception());\n</code></pre><p>完整的代码如下：</p>\n<pre><code class=\"java\">public class BasicMain {\n    public static CompletableFuture&lt;Integer&gt; compute() {\n        final CompletableFuture&lt;Integer&gt; future = new CompletableFuture&lt;&gt;();\n        return future;\n    }\n    public static void main(String[] args) throws Exception {\n        final CompletableFuture&lt;Integer&gt; f = compute();\n        class Client extends Thread {\n            CompletableFuture&lt;Integer&gt; f;\n            Client(String threadName, CompletableFuture&lt;Integer&gt; f) {\n                super(threadName);\n                this.f = f;\n            }\n            @Override\n            public void run() {\n                try {\n                    System.out.println(this.getName() + &quot;: &quot; + f.get());\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (ExecutionException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        new Client(&quot;Client1&quot;, f).start();\n        new Client(&quot;Client2&quot;, f).start();\n        System.out.println(&quot;waiting&quot;);\n        f.complete(100);\n        //f.completeExceptionally(new Exception());\n        System.in.read();\n    }\n}\n</code></pre>\n<p>可以看到我们并没有把<code>f.complete(100);</code>放在另外的线程中去执行，但是在大部分情况下我们可能会用一个线程池去执行这些异步任务。<code>CompletableFuture.complete()</code>、<code>CompletableFuture.completeExceptionally</code>只能被调用一次。但是我们有两个后门方法可以重设这个值:<code>obtrudeValue</code>、<code>obtrudeException</code>，但是使用的时候要小心，因为<code>complete</code>已经触发了客户端，有可能导致客户端会得到不期望的结果。</p>\n<h4 id=\"创建CompletableFuture对象\"><a href=\"#创建CompletableFuture对象\" class=\"headerlink\" title=\"创建CompletableFuture对象\"></a>创建CompletableFuture对象</h4><p><code>CompletableFuture.completedFuture</code>是一个静态辅助方法，用来返回一个已经计算好的<code>CompletableFuture</code>。</p>\n<pre><code class=\"java\">public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value)\n</code></pre>\n<p>而以下四个静态方法用来为一段异步执行的代码创建<code>CompletableFuture</code>对象：</p>\n<pre><code class=\"java\">public static CompletableFuture&lt;Void&gt;     runAsync(Runnable runnable)\npublic static CompletableFuture&lt;Void&gt;     runAsync(Runnable runnable, Executor executor)\npublic static &lt;U&gt; CompletableFuture&lt;U&gt;     supplyAsync(Supplier&lt;U&gt; supplier)\npublic static &lt;U&gt; CompletableFuture&lt;U&gt;     supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)\n</code></pre>\n<p>以<code>Async</code>结尾并且没有指定<code>Executor</code>的方法会使用<code>ForkJoinPool.commonPool()</code>作为它的线程池执行异步代码。</p>\n<p><code>runAsync</code>方法也好理解，它以<code>Runnable</code>函数式接口类型为参数，所以<code>CompletableFuture</code>的计算结果为空。</p>\n<p><code>supplyAsync</code>方法以<code>Supplier&lt;U&gt;</code>函数式接口类型为参数,<code>CompletableFuture</code>的计算结果类型为<code>U</code>。</p>\n<p>因为方法的参数类型都是函数式接口，所以可以使用lambda表达式实现异步任务，比如：</p>\n<pre><code class=\"java\">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    //长时间的计算任务\n    return &quot;处理完成&quot;;\n});\n</code></pre>\n<h4 id=\"计算结果完成时的处理\"><a href=\"#计算结果完成时的处理\" class=\"headerlink\" title=\"计算结果完成时的处理\"></a>计算结果完成时的处理</h4><p>当<code>CompletableFuture</code>的计算结果完成，或者抛出异常的时候，我们可以执行特定的<code>Action</code>。主要是下面的方法：</p>\n<pre><code class=\"java\">public CompletableFuture&lt;T&gt;     whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)\npublic CompletableFuture&lt;T&gt;     whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)\npublic CompletableFuture&lt;T&gt;     whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)\npublic CompletableFuture&lt;T&gt;     exceptionally(Function&lt;Throwable,? extends T&gt; fn)\n</code></pre>\n<p>可以看到<code>Action</code>的类型是<code>BiConsumer&lt;? super T,? super Throwable&gt;</code>，它可以处理正常的计算结果，或者异常情况。<br>方法不以<code>Async</code>结尾，意味着<code>Action</code>使用相同的线程执行，而<code>Async</code>可能会使用其它的线程去执行(如果使用相同的线程池，也可能会被同一个线程选中执行)。</p>\n<p>注意这几个方法都会返回<code>CompletableFuture</code>，当<code>Action</code>执行完毕后它的结果返回原始的<code>CompletableFuture</code>的计算结果或者返回异常。</p>\n<pre><code class=\"java\">public class Main {\n    private static Random rand = new Random();\n    private static long t = System.currentTimeMillis();\n    static int getMoreData() {\n        System.out.println(&quot;begin to start compute&quot;);\n        try {\n            Thread.sleep(10000);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        System.out.println(&quot;end to start compute. passed &quot; + \n                           (System.currentTimeMillis() - t)/1000 + &quot; seconds&quot;);\n        return rand.nextInt(1000);\n    }\n    public static void main(String[] args) throws Exception {\n        CompletableFuture&lt;Integer&gt; future = \n            CompletableFuture.supplyAsync(Main::getMoreData);\n        Future&lt;Integer&gt; f = future.whenComplete((v, e) -&gt; {\n            System.out.println(v);\n            System.out.println(e);\n        });\n        System.out.println(f.get());\n        System.in.read();\n    }\n}\n</code></pre>\n<p><code>exceptionally</code>方法返回一个新的CompletableFuture，当原始的CompletableFuture抛出异常的时候，就会触发这个CompletableFuture的计算，调用function计算值，否则如果原始的CompletableFuture正常计算完后，这个新的CompletableFuture也计算完成，它的值和原始的CompletableFuture的计算的值相同。也就是这个<code>exceptionally</code>方法用来处理异常的情况。</p>\n<p>下面一组方法虽然也返回CompletableFuture对象，但是对象的值和原来的CompletableFuture计算的值不同。当原先的CompletableFuture的值计算完成或者抛出异常的时候，会触发这个CompletableFuture对象的计算，结果由<code>BiFunction</code>参数计算而得。因此这组方法兼有<code>whenComplete</code>和转换的两个功能。</p>\n<pre><code class=\"java\">public &lt;U&gt; CompletableFuture&lt;U&gt;     handle(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn, Executor executor)\n</code></pre>\n<p>同样，不以<code>Async</code>结尾的方法由原来的线程计算，以<code>Async</code>结尾的方法由默认的线程池<code>ForkJoinPool.commonPool()</code>或者指定的线程池<code>executor</code>运行。</p>\n<h4 id=\"组合\"><a href=\"#组合\" class=\"headerlink\" title=\"组合\"></a>组合</h4><p><code>CompletableFuture</code>可以作为monad(单子)和functor。由于回调风格的实现，我们不必因为等待一个计算完成而阻塞着调用线程，而是告诉<code>CompletableFuture</code>当计算完成的时候请执行某个<code>function</code>。而且我们还可以将这些操作串联起来，或者将<code>CompletableFuture</code>组合起来。</p>\n<pre><code class=\"java\">public &lt;U&gt; CompletableFuture&lt;U&gt;     thenApply(Function&lt;? super T,? extends U&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)\n</code></pre>\n<p>这一组函数的功能是当原来的CompletableFuture计算完后，将结果传递给函数<code>fn</code>，将<code>fn</code>的结果作为新的<code>CompletableFuture</code>计算结果。因此它的功能相当于将<code>CompletableFuture&lt;T&gt;</code>转换成<code>CompletableFuture&lt;U&gt;</code>。</p>\n<p>这三个函数的区别和上面介绍的一样，不以<code>Async</code>结尾的方法由原来的线程计算，以<code>Async</code>结尾的方法由默认的线程池<code>ForkJoinPool.commonPool()</code>或者指定的线程池<code>executor</code>运行。Java的CompletableFuture类总是遵循这样的原则，下面就不一一赘述了。</p>\n<p>使用例子如下：</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    return 100;\n});\nCompletableFuture&lt;String&gt; f =  future\n                                .thenApplyAsync(i -&gt; i * 10)\n                                .thenApply(i -&gt; i.toString());\nSystem.out.println(f.get()); //&quot;1000&quot;\n</code></pre>\n<p>需要注意的是，这些转换并不是马上执行的，也不会阻塞，而是在前一个stage完成后继续执行。</p>\n<p><strong>它们与<code>handle</code>方法的区别在于<code>handle</code>方法会处理正常计算值和异常，因此它可以屏蔽异常，避免异常继续抛出。而<code>thenApply</code>方法只是用来处理正常值，因此一旦有异常就会抛出。</strong></p>\n<p>上面的前一个CompleteFuture执行完成执行后一个，下面的是同时执行或者其中一个执行完成就代表执行完成。</p>\n<pre><code class=\"java\">public &lt;U&gt; CompletableFuture&lt;U&gt;     thenCompose(Function&lt;? super T,? extends \n                                                CompletionStage&lt;U&gt;&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     thenComposeAsync(Function&lt;? super T,? extends \n                                                     CompletionStage&lt;U&gt;&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     thenComposeAsync(Function&lt;? super T,? extends \n                                                     CompletionStage&lt;U&gt;&gt; fn,\n                                                     Executor executor)\n</code></pre>\n<p>这一组方法接受一个Function作为参数，这个Function的输入是当前的CompletableFuture的计算值，返回结果将是一个新的CompletableFuture，这个新的CompletableFuture会组合原来的CompletableFuture和函数返回的CompletableFuture。因此它的功能类似:</p>\n<pre><code>A +--&gt; B +---&gt; C\n</code></pre><p>记住，<code>thenCompose</code>返回的对象并不一定是函数<code>fn</code>返回的对象，如果原来的<code>CompletableFuture</code>还没有计算出来，它就会生成一个新的组合后的CompletableFuture。</p>\n<p>例子：</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    return 100;\n});\nCompletableFuture&lt;String&gt; f =  future.thenCompose( i -&gt; {\n    return CompletableFuture.supplyAsync(() -&gt; {\n        return (i * 10) + &quot;&quot;;\n    });\n});\nSystem.out.println(f.get()); //1000\n</code></pre>\n<p>而下面的一组方法<code>thenCombine</code>用来复合另外一个CompletionStage的结果。它的功能类似：</p>\n<pre><code>A +\n  |\n  +------&gt; C\n  +------&gt;\nB +\n</code></pre><p>两个CompletionStage是并行执行的，它们之间并没有先后依赖顺序，other并不会等待先前的CompletableFuture执行完毕后再执行。</p>\n<pre><code class=\"java\">public &lt;U,V&gt; CompletableFuture&lt;V&gt;     thenCombine(CompletionStage&lt;? extends U&gt; other, \n                                        BiFunction&lt;? super T,? super U,? extends V&gt; fn)\npublic &lt;U,V&gt; CompletableFuture&lt;V&gt;     thenCombineAsync(CompletionStage&lt;? extends U&gt; other, \n                                        BiFunction&lt;? super T,? super U,? extends V&gt; fn)\npublic &lt;U,V&gt; CompletableFuture&lt;V&gt;     thenCombineAsync(CompletionStage&lt;? extends U&gt; other,\n                    BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor)\n</code></pre>\n<p>其实从功能上来讲,它们的功能更类似<code>thenAcceptBoth</code>，只不过<code>thenAcceptBoth</code>是纯消费，它的函数参数没有返回值，而<code>thenCombine</code>的函数参数<code>fn</code>有返回值。</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    return 100;\n});\nCompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; {\n    return &quot;abc&quot;;\n});\nCompletableFuture&lt;String&gt; f =  future.thenCombine(future2, (x,y) -&gt; y + &quot;-&quot; + x);\nSystem.out.println(f.get()); //abc-100\n</code></pre>\n<h4 id=\"纯消费-执行Action\"><a href=\"#纯消费-执行Action\" class=\"headerlink\" title=\"纯消费(执行Action)\"></a>纯消费(执行Action)</h4><p>上面的方法是当计算完成的时候，会生成新的计算结果(<code>thenApply</code>, <code>handle</code>)，或者返回同样的计算结果<code>whenComplete</code>，<code>CompletableFuture</code>还提供了一种处理结果的方法，只对结果执行<code>Action</code>,而不返回新的计算值，因此计算值为<code>Void</code>:</p>\n<pre><code class=\"java\">public CompletableFuture&lt;Void&gt;     thenAccept(Consumer&lt;? super T&gt; action)\npublic CompletableFuture&lt;Void&gt;     thenAcceptAsync(Consumer&lt;? super T&gt; action)\npublic CompletableFuture&lt;Void&gt;     thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)\n</code></pre>\n<p>看它的参数类型也就明白了，它们是函数式接口<code>Consumer</code>，这个接口只有输入，没有返回值。</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    return 100;\n});\nCompletableFuture&lt;Void&gt; f =  future.thenAccept(System.out::println);\nSystem.out.println(f.get());\n</code></pre>\n<p><code>thenAcceptBoth</code>以及相关方法提供了类似的功能，当两个CompletionStage都正常完成计算的时候，就会执行提供的<code>action</code>，它用来组合另外一个异步的结果。</p>\n<p><code>runAfterBoth</code>是当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。</p>\n<pre><code class=\"java\">public &lt;U&gt; CompletableFuture&lt;Void&gt;     thenAcceptBoth(CompletionStage&lt;? extends U&gt; other,\n                                             BiConsumer&lt;? super T,? super U&gt; action)\npublic &lt;U&gt; CompletableFuture&lt;Void&gt;     thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; \n                                        other, BiConsumer&lt;? super T,? super U&gt; action)\npublic &lt;U&gt; CompletableFuture&lt;Void&gt;     thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; \n                     other, BiConsumer&lt;? super T,? super U&gt; action, Executor executor)\npublic     CompletableFuture&lt;Void&gt;     runAfterBoth(CompletionStage&lt;?&gt; other, \n                                                 Runnable action)\n</code></pre>\n<p>例子如下：</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    return 100;\n});\nCompletableFuture&lt;Void&gt; f = future.thenAcceptBoth(CompletableFuture.completedFuture(10), \n                                     (x, y) -&gt; System.out.println(x * y));\nSystem.out.println(f.get());\n</code></pre>\n<p>更彻底地，下面一组方法当计算完成的时候会执行一个Runnable,与<code>thenAccept</code>不同，Runnable并不使用CompletableFuture计算的结果。</p>\n<pre><code class=\"java\">public CompletableFuture&lt;Void&gt;     thenRun(Runnable action)\npublic CompletableFuture&lt;Void&gt;     thenRunAsync(Runnable action)\npublic CompletableFuture&lt;Void&gt;     thenRunAsync(Runnable action, Executor executor)\n</code></pre>\n<p>因此先前的CompletableFuture计算的结果被忽略了,这个方法返回<code>CompletableFuture&lt;Void&gt;</code>类型的对象。</p>\n<pre><code class=\"java\">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    return 100;\n});\nCompletableFuture&lt;Void&gt; f =  future.thenRun(() -&gt; System.out.println(&quot;finished&quot;));\nSystem.out.println(f.get());\n</code></pre>\n<blockquote>\n<p>因此，你可以根据方法的参数的类型来加速你的记忆。<code>Runnable</code>类型的参数会忽略计算的结果，<code>Consumer</code>是纯消费计算结果，<code>BiConsumer</code>会组合另外一个<code>CompletionStage</code>纯消费，<code>Function</code>会对计算结果做转换，<code>BiFunction</code>会组合另外一个<code>CompletionStage</code>的计算结果做转换。</p>\n</blockquote>\n<h4 id=\"Either\"><a href=\"#Either\" class=\"headerlink\" title=\"Either\"></a>Either</h4><p><code>thenAcceptBoth</code>和<code>runAfterBoth</code>是当两个CompletableFuture都计算完成，而我们下面要了解的方法是当任意一个CompletableFuture计算完成的时候就会执行。</p>\n<pre><code class=\"java\">public CompletableFuture&lt;Void&gt;     acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)\npublic CompletableFuture&lt;Void&gt;     acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)\npublic CompletableFuture&lt;Void&gt;     acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)\n\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)\npublic &lt;U&gt; CompletableFuture&lt;U&gt;     applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn, Executor executor)\n\n</code></pre>\n<p><strong>acceptEither<code>方法是当任意一个CompletionStage完成的时候，</code>action<code>这个消费者就会被执行。这个方法返回</code>CompletableFuture<void></void></strong></p>\n<p><strong>applyToEither<code>方法是当任意一个CompletionStage完成的时候，</code>fn<code>会被执行，它的返回值会当作新的</code>CompletableFuture<u>的计算结果。</u></strong></p>\n<p>下面这个例子有时会输出<code>100</code>,有时候会输出<code>200</code>,哪个Future先完成就会根据它的结果计算。</p>\n<pre><code class=\"java\">Random rand = new Random();\nCompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 100;\n});\nCompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 200;\n});\nCompletableFuture&lt;String&gt; f =  future.applyToEither(future2,i -&gt; i.toString());\n</code></pre>\n<h4 id=\"辅助方法-allOf-和-anyOf\"><a href=\"#辅助方法-allOf-和-anyOf\" class=\"headerlink\" title=\"辅助方法 allOf 和 anyOf\"></a>辅助方法 <code>allOf</code> 和 <code>anyOf</code></h4><p>前面我们已经介绍了几个静态方法：<code>completedFuture</code>、<code>runAsync</code>、<code>supplyAsync</code>,下面介绍的这两个方法用来组合多个CompletableFuture。</p>\n<pre><code class=\"java\">public static CompletableFuture&lt;Void&gt;         allOf(CompletableFuture&lt;?&gt;... cfs)\npublic static CompletableFuture&lt;Object&gt;     anyOf(CompletableFuture&lt;?&gt;... cfs)\n</code></pre>\n<p><code>allOf</code>方法是当所有的<code>CompletableFuture</code>都执行完后执行计算。</p>\n<p><code>anyOf</code>方法是当任意一个<code>CompletableFuture</code>执行完后就会执行计算，计算的结果相同。</p>\n<p>下面的代码运行结果有时是100,有时是”abc”。但是<code>anyOf</code>和<code>applyToEither</code>不同。<code>anyOf</code>接受任意多的CompletableFuture但是<code>applyToEither</code>只是判断两个CompletableFuture,<code>anyOf</code>返回值的计算结果是参数中其中一个CompletableFuture的计算结果，<code>applyToEither</code>返回值的计算结果却是要经过<code>fn</code>处理的。当然还有静态方法的区别，线程池的选择等。</p>\n<pre><code class=\"java\">Random rand = new Random();\nCompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 100;\n});\nCompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return &quot;abc&quot;;\n});\n//CompletableFuture&lt;Void&gt; f =  CompletableFuture.allOf(future1,future2);\nCompletableFuture&lt;Object&gt; f =  CompletableFuture.anyOf(future1,future2);\nSystem.out.println(f.get());\n</code></pre>\n<p>我想通过上面的介绍，应该把CompletableFuture的方法和功能介绍完了(<code>cancel</code>、<code>isCompletedExceptionally()</code>、<code>isDone()</code>以及继承于Object的方法无需介绍了， <code>toCompletableFuture()</code>返回CompletableFuture本身)，希望你能全面了解CompletableFuture强大的功能，并将它应用到Java的异步编程中。如果你有使用它的开源项目，可以留言分享一下。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://colobu.com/2016/02/29/Java-CompletableFuture/\" target=\"_blank\" rel=\"noopener\">Java CompletableFuture 详解</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-cf-of-jdk8/index.html\" target=\"_blank\" rel=\"noopener\">通过实例理解 JDK8 的 CompletableFuture</a></li>\n</ol>"},{"title":"自旋锁","author":"zhangke","abbrlink":58330,"date":"2018-12-14T03:27:00.000Z","_content":"---\n# 自旋锁\n\n### 概述\n\n1. 自旋锁是什么\n2. 自旋锁实现\n3. MCS自旋锁\n4. CLH自旋锁\n\n### 1. 自旋锁是什么\n\n自旋锁与**互斥量**(注意这里不是互斥锁)类似，用于多线程同步的一种锁。但他不是休眠使线程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。基本的实现是通过线程反复检查锁特定变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。\n\n自旋锁通常被作为底层原语用于实现其他类型的锁。根据它们所基于与的系统体系结构，可以通过使用测试并设置指令（CAS）有效的实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其它的事情，这也是自旋锁只能够持有一段时间的原因。\n\n有了这一层了解，自旋锁的优势和劣势，以及其适用场景也就一目了然了。\n<!-- more -->\n\n#### 优势：\n\n1. 没有线程阻塞，也就没有了线程上下文切换带来的开销\n2. 自旋操作更加直观，无需分析什么情况下会导致线程阻塞\n\n#### 劣势：\n\n最大的问题就是由于需要一直循环检测锁的状态，因此会浪费CPU Cycles\n\n#### 适用场景：\n\n结合上述的优劣，自旋锁在锁的临界区很小并且锁争抢排队不是非常严重的情况下是非常合适的：\n\n1. 临界区小，因此每个使用锁的线程占用锁的时间不会很长，自旋等待的线程能够快速地获取到锁。\n2. 所争抢排队不严重，因此锁的自旋时间也是可控的，不会有大量线程处于自旋等待的状态中，从而增加浪费CPU Cycles。\n\n### 2. 自旋锁实现\n\n首先需要明确的一点是，对于加锁和释放锁的操作，需要是原子性的。这是能够继续讨论的基石。对于现代处理器，一般通过CAS(Compare And Set)操作来保证原子性。它的原理其实很简单，就是将“对比-设置”这一个流程原子化，保证在符合某种预期的前提下，完成一次写操作。\n\n对应到Java语言层面，就是那一大票的AtomicXXX类型。比如在下面的非公平自旋锁的实现中，会借助AtomicReference类型提供的CAS操作来完成加锁和释放锁的操作。\n\n#### 1. 简单的自旋锁\n\n直接上代码\n\n```java\npackage JUC.spinLock;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 19:38\n *      email  : 398757724@qq.com\n *      Desc   : 简单的自旋锁，哪个线程竞争到，\n *      则获取锁，有可能产生饥饿现象\n ***************************************/\npublic class SpinLock {\n\n    //维护当前拥有锁的线程\n    private AtomicReference<Thread> owner = new AtomicReference<>();\n\n\n    public void lock() {\n        Thread currentThread = Thread.currentThread();\n\n        // 如果锁未被占用，则设置当前线程为锁的拥有者\n        while (!owner.compareAndSet(null, currentThread)) {\n            // 自旋\n        }\n    }\n\n\n    public void unLock() {\n        Thread currentThread = Thread.currentThread();\n        // 只有锁的拥有者才能释放锁，其它的线程因为无法满足Compare，因此不会Set成功\n        owner.compareAndSet(currentThread, null);\n    }\n\n\n    //一下代码属于测试\n    //用于等待所有线程都已结束\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    //所有线程共享的变量，用于测试，如果加锁和释放锁是正确的操作\n    //则在操作此集合时不会产生ConcurrentModificationException\n    static List<String> list = new ArrayList<>();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final SpinLock lock = new SpinLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    \n    private static Runnable generateTask(final SpinLock lock, \n                                        final String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n这里的关键就是加锁和释放锁中的两个CAS操作：\n\n1. 加锁过程:将CAS操作置于一个while循环中，来实现自旋的语义。由于CAS操作成功与否是成功取决于它的boolean返回值，因此当CAS操作失败的情况下，while循环将不会退出，会一直尝试CAS操作直到成功为止，此即所谓的自旋(忙等待)。\n\n1. 释放锁过程:此时不需要循环操作，但是仍然会考虑到只有当前拥有锁的线程才有资格释放锁。这一点还是通过CAS操作来保证。\n\n这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。\n\n**运行结果**:\n\n```\nThread 0 Completed [0]\nThread 9 Completed [0, 9]\nThread 3 Completed [0, 9, 3]\nThread 8 Completed [0, 9, 3, 8]\nThread 4 Completed [0, 9, 3, 8, 4]\nThread 6 Completed [0, 9, 3, 8, 4, 6]\nThread 5 Completed [0, 9, 3, 8, 4, 6, 5]\nThread 7 Completed [0, 9, 3, 8, 4, 6, 5, 7]\nThread 1 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1]\nThread 2 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n[0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n```\n\n从上可以看出，加锁和释放锁正确的实现，和预期的也是一样的，这是一个非公平的自旋锁，不是按照先来先获取锁的方式实现。\n\n#####  缺点\n\n- CAS操作需要硬件的配合；\n- 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；\n- 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。\n\n#### 2.  Ticket Lock\n\nTicket Lock 是为了解决上面的公平性问题，类似于现实中银行柜台的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询。\n\n当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋。\n\n具体代码如下：\n\n```java\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:23\n *      email  : 398757724@qq.com\n *      Desc   : Ticket Lock 简单实现，\n *      此自旋锁保证了FIFI，不会产生饥饿现象\n ***************************************/\npublic class TicketLock {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n\n    public int lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n        return myTicketNum;\n    }\n\n\n    public void unLock(int myTicketNum) {\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n    \n    public static void main(String[] args) throws InterruptedException {\n        final TicketLock lock = new TicketLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n    \n    private static Runnable generateTask(final TicketLock lock, \n    \t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            int myTicketNum = lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock(myTicketNum);\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n加锁和释放锁两个操作的过程如下：\n\n1. 加锁过程。获取一个排队号，当排队号和当前的服务号不相等时自旋等待。\n2. 释放锁过程。当前正被服务的线程释放锁，计算下一个服务号并设置。\n\n这里的AtomicInteger是为了保证服务号和等待号的原子性\n\n运行结果如下\n\n```\nThread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n从运行结果可以看出，确实是按照FIFO的顺序来获取锁，实现了公平性。\n\n不过上面的代码有一个问题，在释放锁的时候需要外部传进来排队号，这样就会带来一个隐患，外部传进来的排队号是可以修改的，也就是线程A获取的排队号是5，但是释放锁的时候却传进来6。这样就有可能导致死锁等问题。下面这个是通过ThreadLocal来改进上面的代码\n\n```java\npublic class TicketLockImprove {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n    //用于保存当前\n    private ThreadLocal<Integer> threadLocalTicketNum = new ThreadLocal<>();\n\n\n    public void lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n        //设置当前线程持有的排队号\n        threadLocalTicketNum.set(myTicketNum);\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n\n    }\n\n\n    public void unLock() {\n        //获取当前线程持有的排队号\n        int myTicketNum = threadLocalTicketNum.get();\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLockImprove lock = new TicketLockImprove();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final TicketLockImprove lock, final String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n这里是通过ThreadLocal来保存每个线程的排队号，这样就不会出现排队号被私自修改问题。其他的和上面的代码一致。\n\n##### 缺点\n\n- Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。\n\n所以，需要有一种办法能够让执行线程不再在同一个共享变量上自旋，避免过高频率的缓存同步操作。下面介绍的CLH锁和MCS锁都是为了解决这个问题的。\n\nMCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。\n\nCLH的发明人是：Craig，Landin and Hagersten。\n\n### 3. MCS 锁\n\nMCS自旋锁是一种基于单向链表的高性能、公平的自旋锁，申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。\n\n先上实现代码，然后在分析重点：\n\n```\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:34\n *      email  : 398757724@qq.com\n *      Desc   : MCS Lock\n ***************************************/\npublic class MCSLock {\n\n    //MCS锁节点\n    public static class MCSNode {\n        //指向后继节点\n        volatile MCSNode next;\n\n        //默认是在等待锁\n        volatile boolean isBlock = true;\n    }\n\n    volatile MCSNode tail; //指向最后一个申请锁的MCSNode\n\n    // 原子更新器\n    private static final AtomicReferenceFieldUpdater<MCSLock, MCSNode> UPDATER\n            = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, \n            \t\t\t\t\t\t\t\t\t\t\tMCSNode.class, \"tail\");\n\n    //用于保存当前节点对应的MCSNode对象\n    ThreadLocal<MCSNode> currentThreadNode = new ThreadLocal<>();\n\n\n    public void lock() {\n\n        //获得当前线程对应的节点\n        MCSNode mcsNode = currentThreadNode.get();\n        if (mcsNode == null) {\n            //初始化节点对象\n            mcsNode = new MCSNode();\n            currentThreadNode.set(mcsNode);\n        }\n        //设置当前队列节点到队尾并获取前置节点\n        MCSNode predecsessor = UPDATER.getAndSet(this, mcsNode); // step 1\n\n        //如果前继节点不为空，则设置前置节点的后继为当前节点，并等待获取锁\n        if (predecsessor != null) {\n            predecsessor.next = mcsNode;  // step 2\n            // 当前线程处于等待状态时自旋(MCSNode的isBlock初始化为true)\n            // 等待前驱节点主动通知，即将isBlock设置为false，表示当前线程可以获取到锁\n            while (mcsNode.isBlock) {\n\n            }\n        } else {\n            // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞 - 表示已经加锁成功\n            mcsNode.isBlock = false;\n        }\n    }\n\n\n    public void unLock() {\n        MCSNode mcsNode = currentThreadNode.get();\n        // 当前线程对应存在节点并且\n        // 锁拥有者进行释放锁才有意义 - 当blocked为true时，表示此线程处于等待状态中，\n        //                          并没有获取到锁，因此没有权利释放锁\n        if (mcsNode == null && mcsNode.isBlock) {\n            return;\n        }\n\n        if (mcsNode.next == null) {\n            if (UPDATER.compareAndSet(this, mcsNode, null)) {\n                // compareAndSet返回true表示确实没有人排在自己后面\n                return;\n            } else {\n                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者\n                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完\n                while (mcsNode.next == null) {\n                }\n            }\n        }\n        // 通知后继节点可以获取锁\n        mcsNode.next.isBlock = false;\n\n        // 将当前节点从链表中断开，方便对当前节点进行GC\n        mcsNode.next = null;// for GC\n        //for GC\n        currentThreadNode.remove();\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final MCSLock lock = new MCSLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    private static Runnable generateTask(final MCSLock lock, \n    \t\t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n实现的代码量虽然不多，但是lock和unlock的设计思想还是有些微妙之处，想要实现正确也并不容易。\n\n需要把握的几个重点：\n\n1. MCS锁的节点对象需要有两个状态，next用来维护单向链表的结构，blocked用来表示节点的状态，true表示处于自旋中；false表示加锁成功\n2. MCS锁的节点状态blocked的改变是由其前驱节点触发改变的\n3. 加锁时会更新链表的末节点并完成链表结构的维护\n4. 释放锁的时候由于链表结构建立的时滞(getAndSet原子方法和链表建立整体而言并非原子性)，可能存在多线程的干扰，需要使用忙等待保证链表结构就绪\n\n### 4. CLH锁\n\n同MCS自旋锁一样，CLH也是一种基于单向链表(隐式创建)的高性能、公平的自旋锁，申请加锁的线程只需要在其前驱节点的本地变量上自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。\n\n实现代码\n\n```\npublic class CLHLock {\n\n    public static class CLHNode {\n        private boolean isLocked = true; // 默认状态为true - 即处于等待状态或者加锁成功(换言之，即此节点处于有效的一种状态)\n    }\n\n    @SuppressWarnings(\"unused\")\n    private volatile CLHNode tail;\n\n    //线程对应CLH节点映射\n    private ThreadLocal<CLHNode> currentThreadNode = new ThreadLocal<>();\n\n\n    /**\n     * CLH 锁获取\n     */\n    public void lock() {\n        CLHNode clhNode = currentThreadNode.get();\n        if (clhNode == null) {\n            clhNode = new CLHNode();\n            currentThreadNode.set(clhNode);\n        }\n        //通过这个操作完成隐式链表的维护，后继节点只需要在前驱节点的locked状态上自旋\n        CLHNode preNode = UPDATER.getAndSet(this, clhNode);\n        if (preNode != null) {  //已有线程占用了锁，进入自旋\n            while (preNode.isLocked) {  //自旋等待前驱节点状态变更 - unlock中进行变更\n\n                //这里这样写，或者isLocked加上voliate，则能观察到变量的变化\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 没有前驱节点表示可以直接获取到锁，由于默认获取锁状态为true，此时可以什么操作都不执行\n        // 能够执行到这里表示已经成功获取到了锁\n\n    }\n\n\n    /**\n     * CLH 锁释放\n     */\n    public void unLock() {\n        CLHNode clhNode = currentThreadNode.get();\n        //只有持有锁的线程才能释放\n        if (clhNode == null || !clhNode.isLocked) {\n            return;\n        }\n\n        //从映射关系中移除当前线程对应的节点\n        currentThreadNode.remove();\n\n        //如果队列里只有当前线程，则释放对当前线程的引用(for GC)\n        // 尝试将tail从currentThread变更为null，因此当tail不为currentThread时表示还有线程在等待加锁\n        if (!UPDATER.compareAndSet(this, clhNode, null)) {\n            //还有后续线程\n            clhNode.isLocked = false; //改变状态，让后续线程结束自旋\n        }\n    }\n\n\n    private static final AtomicReferenceFieldUpdater<CLHLock, CLHNode> UPDATER =\n            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, \"tail\");\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final CLHLock lock = new CLHLock();\n        List<String> list = new ArrayList<>();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final CLHLock lock, \n    \t\t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n            } catch (Exception e) {\n\n            }\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, list));\n//            System.out.println(String.format(\"Thread %s Completed \", taskId));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n实现的代码量相比MCS锁少了很多，也简洁了不少。\n\n需要把握的几个重点：\n\n1. CLH锁的节点对象只有一个isLocked属性，关于其含义前面已经详细讨论过\n2. CLH锁的节点属性isLocked的改变是由其自身触发的\n3. CLH锁是在前驱节点的isLocked属性上进行自旋\n\n众所周知，AbstractQueuedSynchronizer是Java并发包的基石之一，而CLH锁的原理和思想则是AbstractQueuedSynchronizer的基石之一。理解清楚CLH锁的原理和实现对后面学习和理解AbstractQueuedSynchronizer是非常必要的。\n\n在**Doug Lea 写的The java.util.concurrent Synchronizer Framework** 文章中有这么一句话 **CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。**其实只要实现了取消功能，那么超时就比较容易实现。为什么CLH更容易实现取消功能呢。首先在CLH各节点之间只有一条隐形的链表存在，而排队的节点是观察前面节点的信息来判断是否可以获取锁，因此在取消排队节点时，可以不影响前继节点，而对后继节点的影响也比较小，如果MCS自旋锁要取消，则需要前继节点改变后继节点，如果敲好此时前继节点正在拿到锁运行，那此时更改锁就不是那么容易的，而且链表有事单链表，因此更改起来更加麻烦。\n\n### 总结\n\n下面我们来比较一下MCS和CLH锁\n\n首先我们先补充一点知识SMP和NUMA架构\n\n* SMP(Symmetric Multi-Processor)：对称多处理器结构，指服务器中多个 CPU 对称工作，每个 CPU 访问内存地址所需时间相同。其主要特征是共享，包含对 CPU，内存，I/O 等进行共享。SMP 能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着 CPU 数量的增加，每个 CPU 都要访问相同的内存资源，可能导致内存访问冲突，可能会导致 CPU 资源的浪费。常用的 PC 机就属于这种。\n* NUMA(Non-Uniform Memory Access)：非一致存储访问，将 CPU 分为 CPU 模块，每个 CPU 模块由多个 CPU 组成，并且具有独立的本地内存、I/O 槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存 (系统内其它节点的内存) 的速度，这也是非一致存储访问的由来。NUMA 较好地解决 SMP 的扩展问题，当 CPU 数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。\n\nCLH 队列锁的优点是空间复杂度低（如果有 n 个线程，L 个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O（L+n），n 个线程有 n 个myNode，L 个锁有 L 个 tail），CLH 的一种变体被应用在了 JAVA 并发框架中 (AbstractQueuedSynchronizer.Node)。CLH 在 SMP 系统结构下该法是非常有效的。但在 NUMA 系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，一种解决 NUMA 系统结构的思路是 MCS 队列锁。\n\nMSC 与 CLH 最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:CLH 是在前趋结点的 locked 域上自旋等待，而 MCS 是在自己的结点的 locked 域上自旋等待。正因为如此，它解决了 CLH 在 NUMA 系统架构中获取 locked 域状态内存过远的问题。\n\n\n\n### 参考\n\n1. [简单的非公平自旋锁以及基于排队的公平自旋锁的实现](https://blog.csdn.net/dm_vincent/article/details/79677891)\n2. [CLH锁的原理和实现](https://blog.csdn.net/dm_vincent/article/details/79842501)\n3. [MCS锁的原理和实现](https://blog.csdn.net/dm_vincent/article/details/79783104)\n4. [面试必备之深入理解自旋锁](https://segmentfault.com/a/1190000015795906)\n5. [Java自旋锁、排队自旋锁、MCS锁、CLH锁](https://lawrence-zxc.github.io/2015/05/03/lock/)\n6. [CLH锁与MCS锁](https://blog.csdn.net/jackyechina/article/details/73199638)","source":"_posts/自旋锁.md","raw":"---\ntitle: 自旋锁\ntags:\n  - 操作系统\n  - 自旋锁\n  - JUC\ncategories:\n  - java\nauthor: zhangke\nabbrlink: 58330\ndate: 2018-12-14 11:27:00\n---\n---\n# 自旋锁\n\n### 概述\n\n1. 自旋锁是什么\n2. 自旋锁实现\n3. MCS自旋锁\n4. CLH自旋锁\n\n### 1. 自旋锁是什么\n\n自旋锁与**互斥量**(注意这里不是互斥锁)类似，用于多线程同步的一种锁。但他不是休眠使线程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。基本的实现是通过线程反复检查锁特定变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。\n\n自旋锁通常被作为底层原语用于实现其他类型的锁。根据它们所基于与的系统体系结构，可以通过使用测试并设置指令（CAS）有效的实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其它的事情，这也是自旋锁只能够持有一段时间的原因。\n\n有了这一层了解，自旋锁的优势和劣势，以及其适用场景也就一目了然了。\n<!-- more -->\n\n#### 优势：\n\n1. 没有线程阻塞，也就没有了线程上下文切换带来的开销\n2. 自旋操作更加直观，无需分析什么情况下会导致线程阻塞\n\n#### 劣势：\n\n最大的问题就是由于需要一直循环检测锁的状态，因此会浪费CPU Cycles\n\n#### 适用场景：\n\n结合上述的优劣，自旋锁在锁的临界区很小并且锁争抢排队不是非常严重的情况下是非常合适的：\n\n1. 临界区小，因此每个使用锁的线程占用锁的时间不会很长，自旋等待的线程能够快速地获取到锁。\n2. 所争抢排队不严重，因此锁的自旋时间也是可控的，不会有大量线程处于自旋等待的状态中，从而增加浪费CPU Cycles。\n\n### 2. 自旋锁实现\n\n首先需要明确的一点是，对于加锁和释放锁的操作，需要是原子性的。这是能够继续讨论的基石。对于现代处理器，一般通过CAS(Compare And Set)操作来保证原子性。它的原理其实很简单，就是将“对比-设置”这一个流程原子化，保证在符合某种预期的前提下，完成一次写操作。\n\n对应到Java语言层面，就是那一大票的AtomicXXX类型。比如在下面的非公平自旋锁的实现中，会借助AtomicReference类型提供的CAS操作来完成加锁和释放锁的操作。\n\n#### 1. 简单的自旋锁\n\n直接上代码\n\n```java\npackage JUC.spinLock;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 19:38\n *      email  : 398757724@qq.com\n *      Desc   : 简单的自旋锁，哪个线程竞争到，\n *      则获取锁，有可能产生饥饿现象\n ***************************************/\npublic class SpinLock {\n\n    //维护当前拥有锁的线程\n    private AtomicReference<Thread> owner = new AtomicReference<>();\n\n\n    public void lock() {\n        Thread currentThread = Thread.currentThread();\n\n        // 如果锁未被占用，则设置当前线程为锁的拥有者\n        while (!owner.compareAndSet(null, currentThread)) {\n            // 自旋\n        }\n    }\n\n\n    public void unLock() {\n        Thread currentThread = Thread.currentThread();\n        // 只有锁的拥有者才能释放锁，其它的线程因为无法满足Compare，因此不会Set成功\n        owner.compareAndSet(currentThread, null);\n    }\n\n\n    //一下代码属于测试\n    //用于等待所有线程都已结束\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    //所有线程共享的变量，用于测试，如果加锁和释放锁是正确的操作\n    //则在操作此集合时不会产生ConcurrentModificationException\n    static List<String> list = new ArrayList<>();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final SpinLock lock = new SpinLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    \n    private static Runnable generateTask(final SpinLock lock, \n                                        final String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n这里的关键就是加锁和释放锁中的两个CAS操作：\n\n1. 加锁过程:将CAS操作置于一个while循环中，来实现自旋的语义。由于CAS操作成功与否是成功取决于它的boolean返回值，因此当CAS操作失败的情况下，while循环将不会退出，会一直尝试CAS操作直到成功为止，此即所谓的自旋(忙等待)。\n\n1. 释放锁过程:此时不需要循环操作，但是仍然会考虑到只有当前拥有锁的线程才有资格释放锁。这一点还是通过CAS操作来保证。\n\n这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。\n\n**运行结果**:\n\n```\nThread 0 Completed [0]\nThread 9 Completed [0, 9]\nThread 3 Completed [0, 9, 3]\nThread 8 Completed [0, 9, 3, 8]\nThread 4 Completed [0, 9, 3, 8, 4]\nThread 6 Completed [0, 9, 3, 8, 4, 6]\nThread 5 Completed [0, 9, 3, 8, 4, 6, 5]\nThread 7 Completed [0, 9, 3, 8, 4, 6, 5, 7]\nThread 1 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1]\nThread 2 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n[0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n```\n\n从上可以看出，加锁和释放锁正确的实现，和预期的也是一样的，这是一个非公平的自旋锁，不是按照先来先获取锁的方式实现。\n\n#####  缺点\n\n- CAS操作需要硬件的配合；\n- 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；\n- 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。\n\n#### 2.  Ticket Lock\n\nTicket Lock 是为了解决上面的公平性问题，类似于现实中银行柜台的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询。\n\n当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋。\n\n具体代码如下：\n\n```java\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:23\n *      email  : 398757724@qq.com\n *      Desc   : Ticket Lock 简单实现，\n *      此自旋锁保证了FIFI，不会产生饥饿现象\n ***************************************/\npublic class TicketLock {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n\n    public int lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n        return myTicketNum;\n    }\n\n\n    public void unLock(int myTicketNum) {\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n    \n    public static void main(String[] args) throws InterruptedException {\n        final TicketLock lock = new TicketLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n    \n    private static Runnable generateTask(final TicketLock lock, \n    \t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            int myTicketNum = lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock(myTicketNum);\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n加锁和释放锁两个操作的过程如下：\n\n1. 加锁过程。获取一个排队号，当排队号和当前的服务号不相等时自旋等待。\n2. 释放锁过程。当前正被服务的线程释放锁，计算下一个服务号并设置。\n\n这里的AtomicInteger是为了保证服务号和等待号的原子性\n\n运行结果如下\n\n```\nThread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n从运行结果可以看出，确实是按照FIFO的顺序来获取锁，实现了公平性。\n\n不过上面的代码有一个问题，在释放锁的时候需要外部传进来排队号，这样就会带来一个隐患，外部传进来的排队号是可以修改的，也就是线程A获取的排队号是5，但是释放锁的时候却传进来6。这样就有可能导致死锁等问题。下面这个是通过ThreadLocal来改进上面的代码\n\n```java\npublic class TicketLockImprove {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n    //用于保存当前\n    private ThreadLocal<Integer> threadLocalTicketNum = new ThreadLocal<>();\n\n\n    public void lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n        //设置当前线程持有的排队号\n        threadLocalTicketNum.set(myTicketNum);\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n\n    }\n\n\n    public void unLock() {\n        //获取当前线程持有的排队号\n        int myTicketNum = threadLocalTicketNum.get();\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLockImprove lock = new TicketLockImprove();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final TicketLockImprove lock, final String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n这里是通过ThreadLocal来保存每个线程的排队号，这样就不会出现排队号被私自修改问题。其他的和上面的代码一致。\n\n##### 缺点\n\n- Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。\n\n所以，需要有一种办法能够让执行线程不再在同一个共享变量上自旋，避免过高频率的缓存同步操作。下面介绍的CLH锁和MCS锁都是为了解决这个问题的。\n\nMCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。\n\nCLH的发明人是：Craig，Landin and Hagersten。\n\n### 3. MCS 锁\n\nMCS自旋锁是一种基于单向链表的高性能、公平的自旋锁，申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。\n\n先上实现代码，然后在分析重点：\n\n```\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:34\n *      email  : 398757724@qq.com\n *      Desc   : MCS Lock\n ***************************************/\npublic class MCSLock {\n\n    //MCS锁节点\n    public static class MCSNode {\n        //指向后继节点\n        volatile MCSNode next;\n\n        //默认是在等待锁\n        volatile boolean isBlock = true;\n    }\n\n    volatile MCSNode tail; //指向最后一个申请锁的MCSNode\n\n    // 原子更新器\n    private static final AtomicReferenceFieldUpdater<MCSLock, MCSNode> UPDATER\n            = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, \n            \t\t\t\t\t\t\t\t\t\t\tMCSNode.class, \"tail\");\n\n    //用于保存当前节点对应的MCSNode对象\n    ThreadLocal<MCSNode> currentThreadNode = new ThreadLocal<>();\n\n\n    public void lock() {\n\n        //获得当前线程对应的节点\n        MCSNode mcsNode = currentThreadNode.get();\n        if (mcsNode == null) {\n            //初始化节点对象\n            mcsNode = new MCSNode();\n            currentThreadNode.set(mcsNode);\n        }\n        //设置当前队列节点到队尾并获取前置节点\n        MCSNode predecsessor = UPDATER.getAndSet(this, mcsNode); // step 1\n\n        //如果前继节点不为空，则设置前置节点的后继为当前节点，并等待获取锁\n        if (predecsessor != null) {\n            predecsessor.next = mcsNode;  // step 2\n            // 当前线程处于等待状态时自旋(MCSNode的isBlock初始化为true)\n            // 等待前驱节点主动通知，即将isBlock设置为false，表示当前线程可以获取到锁\n            while (mcsNode.isBlock) {\n\n            }\n        } else {\n            // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞 - 表示已经加锁成功\n            mcsNode.isBlock = false;\n        }\n    }\n\n\n    public void unLock() {\n        MCSNode mcsNode = currentThreadNode.get();\n        // 当前线程对应存在节点并且\n        // 锁拥有者进行释放锁才有意义 - 当blocked为true时，表示此线程处于等待状态中，\n        //                          并没有获取到锁，因此没有权利释放锁\n        if (mcsNode == null && mcsNode.isBlock) {\n            return;\n        }\n\n        if (mcsNode.next == null) {\n            if (UPDATER.compareAndSet(this, mcsNode, null)) {\n                // compareAndSet返回true表示确实没有人排在自己后面\n                return;\n            } else {\n                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者\n                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完\n                while (mcsNode.next == null) {\n                }\n            }\n        }\n        // 通知后继节点可以获取锁\n        mcsNode.next.isBlock = false;\n\n        // 将当前节点从链表中断开，方便对当前节点进行GC\n        mcsNode.next = null;// for GC\n        //for GC\n        currentThreadNode.remove();\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final MCSLock lock = new MCSLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    private static Runnable generateTask(final MCSLock lock, \n    \t\t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n实现的代码量虽然不多，但是lock和unlock的设计思想还是有些微妙之处，想要实现正确也并不容易。\n\n需要把握的几个重点：\n\n1. MCS锁的节点对象需要有两个状态，next用来维护单向链表的结构，blocked用来表示节点的状态，true表示处于自旋中；false表示加锁成功\n2. MCS锁的节点状态blocked的改变是由其前驱节点触发改变的\n3. 加锁时会更新链表的末节点并完成链表结构的维护\n4. 释放锁的时候由于链表结构建立的时滞(getAndSet原子方法和链表建立整体而言并非原子性)，可能存在多线程的干扰，需要使用忙等待保证链表结构就绪\n\n### 4. CLH锁\n\n同MCS自旋锁一样，CLH也是一种基于单向链表(隐式创建)的高性能、公平的自旋锁，申请加锁的线程只需要在其前驱节点的本地变量上自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。\n\n实现代码\n\n```\npublic class CLHLock {\n\n    public static class CLHNode {\n        private boolean isLocked = true; // 默认状态为true - 即处于等待状态或者加锁成功(换言之，即此节点处于有效的一种状态)\n    }\n\n    @SuppressWarnings(\"unused\")\n    private volatile CLHNode tail;\n\n    //线程对应CLH节点映射\n    private ThreadLocal<CLHNode> currentThreadNode = new ThreadLocal<>();\n\n\n    /**\n     * CLH 锁获取\n     */\n    public void lock() {\n        CLHNode clhNode = currentThreadNode.get();\n        if (clhNode == null) {\n            clhNode = new CLHNode();\n            currentThreadNode.set(clhNode);\n        }\n        //通过这个操作完成隐式链表的维护，后继节点只需要在前驱节点的locked状态上自旋\n        CLHNode preNode = UPDATER.getAndSet(this, clhNode);\n        if (preNode != null) {  //已有线程占用了锁，进入自旋\n            while (preNode.isLocked) {  //自旋等待前驱节点状态变更 - unlock中进行变更\n\n                //这里这样写，或者isLocked加上voliate，则能观察到变量的变化\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 没有前驱节点表示可以直接获取到锁，由于默认获取锁状态为true，此时可以什么操作都不执行\n        // 能够执行到这里表示已经成功获取到了锁\n\n    }\n\n\n    /**\n     * CLH 锁释放\n     */\n    public void unLock() {\n        CLHNode clhNode = currentThreadNode.get();\n        //只有持有锁的线程才能释放\n        if (clhNode == null || !clhNode.isLocked) {\n            return;\n        }\n\n        //从映射关系中移除当前线程对应的节点\n        currentThreadNode.remove();\n\n        //如果队列里只有当前线程，则释放对当前线程的引用(for GC)\n        // 尝试将tail从currentThread变更为null，因此当tail不为currentThread时表示还有线程在等待加锁\n        if (!UPDATER.compareAndSet(this, clhNode, null)) {\n            //还有后续线程\n            clhNode.isLocked = false; //改变状态，让后续线程结束自旋\n        }\n    }\n\n\n    private static final AtomicReferenceFieldUpdater<CLHLock, CLHNode> UPDATER =\n            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, \"tail\");\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final CLHLock lock = new CLHLock();\n        List<String> list = new ArrayList<>();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final CLHLock lock, \n    \t\t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n            } catch (Exception e) {\n\n            }\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, list));\n//            System.out.println(String.format(\"Thread %s Completed \", taskId));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n实现的代码量相比MCS锁少了很多，也简洁了不少。\n\n需要把握的几个重点：\n\n1. CLH锁的节点对象只有一个isLocked属性，关于其含义前面已经详细讨论过\n2. CLH锁的节点属性isLocked的改变是由其自身触发的\n3. CLH锁是在前驱节点的isLocked属性上进行自旋\n\n众所周知，AbstractQueuedSynchronizer是Java并发包的基石之一，而CLH锁的原理和思想则是AbstractQueuedSynchronizer的基石之一。理解清楚CLH锁的原理和实现对后面学习和理解AbstractQueuedSynchronizer是非常必要的。\n\n在**Doug Lea 写的The java.util.concurrent Synchronizer Framework** 文章中有这么一句话 **CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。**其实只要实现了取消功能，那么超时就比较容易实现。为什么CLH更容易实现取消功能呢。首先在CLH各节点之间只有一条隐形的链表存在，而排队的节点是观察前面节点的信息来判断是否可以获取锁，因此在取消排队节点时，可以不影响前继节点，而对后继节点的影响也比较小，如果MCS自旋锁要取消，则需要前继节点改变后继节点，如果敲好此时前继节点正在拿到锁运行，那此时更改锁就不是那么容易的，而且链表有事单链表，因此更改起来更加麻烦。\n\n### 总结\n\n下面我们来比较一下MCS和CLH锁\n\n首先我们先补充一点知识SMP和NUMA架构\n\n* SMP(Symmetric Multi-Processor)：对称多处理器结构，指服务器中多个 CPU 对称工作，每个 CPU 访问内存地址所需时间相同。其主要特征是共享，包含对 CPU，内存，I/O 等进行共享。SMP 能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着 CPU 数量的增加，每个 CPU 都要访问相同的内存资源，可能导致内存访问冲突，可能会导致 CPU 资源的浪费。常用的 PC 机就属于这种。\n* NUMA(Non-Uniform Memory Access)：非一致存储访问，将 CPU 分为 CPU 模块，每个 CPU 模块由多个 CPU 组成，并且具有独立的本地内存、I/O 槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存 (系统内其它节点的内存) 的速度，这也是非一致存储访问的由来。NUMA 较好地解决 SMP 的扩展问题，当 CPU 数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。\n\nCLH 队列锁的优点是空间复杂度低（如果有 n 个线程，L 个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O（L+n），n 个线程有 n 个myNode，L 个锁有 L 个 tail），CLH 的一种变体被应用在了 JAVA 并发框架中 (AbstractQueuedSynchronizer.Node)。CLH 在 SMP 系统结构下该法是非常有效的。但在 NUMA 系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，一种解决 NUMA 系统结构的思路是 MCS 队列锁。\n\nMSC 与 CLH 最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:CLH 是在前趋结点的 locked 域上自旋等待，而 MCS 是在自己的结点的 locked 域上自旋等待。正因为如此，它解决了 CLH 在 NUMA 系统架构中获取 locked 域状态内存过远的问题。\n\n\n\n### 参考\n\n1. [简单的非公平自旋锁以及基于排队的公平自旋锁的实现](https://blog.csdn.net/dm_vincent/article/details/79677891)\n2. [CLH锁的原理和实现](https://blog.csdn.net/dm_vincent/article/details/79842501)\n3. [MCS锁的原理和实现](https://blog.csdn.net/dm_vincent/article/details/79783104)\n4. [面试必备之深入理解自旋锁](https://segmentfault.com/a/1190000015795906)\n5. [Java自旋锁、排队自旋锁、MCS锁、CLH锁](https://lawrence-zxc.github.io/2015/05/03/lock/)\n6. [CLH锁与MCS锁](https://blog.csdn.net/jackyechina/article/details/73199638)","slug":"自旋锁","published":1,"updated":"2019-01-02T05:50:19.801Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovsa002h9q1u35kwbys4","content":"<hr>\n<h1 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>自旋锁是什么</li>\n<li>自旋锁实现</li>\n<li>MCS自旋锁</li>\n<li>CLH自旋锁</li>\n</ol>\n<h3 id=\"1-自旋锁是什么\"><a href=\"#1-自旋锁是什么\" class=\"headerlink\" title=\"1. 自旋锁是什么\"></a>1. 自旋锁是什么</h3><p>自旋锁与<strong>互斥量</strong>(注意这里不是互斥锁)类似，用于多线程同步的一种锁。但他不是休眠使线程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。基本的实现是通过线程反复检查锁特定变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。</p>\n<p>自旋锁通常被作为底层原语用于实现其他类型的锁。根据它们所基于与的系统体系结构，可以通过使用测试并设置指令（CAS）有效的实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其它的事情，这也是自旋锁只能够持有一段时间的原因。</p>\n<p>有了这一层了解，自旋锁的优势和劣势，以及其适用场景也就一目了然了。<br><a id=\"more\"></a></p>\n<h4 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h4><ol>\n<li>没有线程阻塞，也就没有了线程上下文切换带来的开销</li>\n<li>自旋操作更加直观，无需分析什么情况下会导致线程阻塞</li>\n</ol>\n<h4 id=\"劣势：\"><a href=\"#劣势：\" class=\"headerlink\" title=\"劣势：\"></a>劣势：</h4><p>最大的问题就是由于需要一直循环检测锁的状态，因此会浪费CPU Cycles</p>\n<h4 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h4><p>结合上述的优劣，自旋锁在锁的临界区很小并且锁争抢排队不是非常严重的情况下是非常合适的：</p>\n<ol>\n<li>临界区小，因此每个使用锁的线程占用锁的时间不会很长，自旋等待的线程能够快速地获取到锁。</li>\n<li>所争抢排队不严重，因此锁的自旋时间也是可控的，不会有大量线程处于自旋等待的状态中，从而增加浪费CPU Cycles。</li>\n</ol>\n<h3 id=\"2-自旋锁实现\"><a href=\"#2-自旋锁实现\" class=\"headerlink\" title=\"2. 自旋锁实现\"></a>2. 自旋锁实现</h3><p>首先需要明确的一点是，对于加锁和释放锁的操作，需要是原子性的。这是能够继续讨论的基石。对于现代处理器，一般通过CAS(Compare And Set)操作来保证原子性。它的原理其实很简单，就是将“对比-设置”这一个流程原子化，保证在符合某种预期的前提下，完成一次写操作。</p>\n<p>对应到Java语言层面，就是那一大票的AtomicXXX类型。比如在下面的非公平自旋锁的实现中，会借助AtomicReference类型提供的CAS操作来完成加锁和释放锁的操作。</p>\n<h4 id=\"1-简单的自旋锁\"><a href=\"#1-简单的自旋锁\" class=\"headerlink\" title=\"1. 简单的自旋锁\"></a>1. 简单的自旋锁</h4><p>直接上代码</p>\n<pre><code class=\"java\">package JUC.spinLock;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 19:38\n *      email  : 398757724@qq.com\n *      Desc   : 简单的自旋锁，哪个线程竞争到，\n *      则获取锁，有可能产生饥饿现象\n ***************************************/\npublic class SpinLock {\n\n    //维护当前拥有锁的线程\n    private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;();\n\n\n    public void lock() {\n        Thread currentThread = Thread.currentThread();\n\n        // 如果锁未被占用，则设置当前线程为锁的拥有者\n        while (!owner.compareAndSet(null, currentThread)) {\n            // 自旋\n        }\n    }\n\n\n    public void unLock() {\n        Thread currentThread = Thread.currentThread();\n        // 只有锁的拥有者才能释放锁，其它的线程因为无法满足Compare，因此不会Set成功\n        owner.compareAndSet(currentThread, null);\n    }\n\n\n    //一下代码属于测试\n    //用于等待所有线程都已结束\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    //所有线程共享的变量，用于测试，如果加锁和释放锁是正确的操作\n    //则在操作此集合时不会产生ConcurrentModificationException\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final SpinLock lock = new SpinLock();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n\n    private static Runnable generateTask(final SpinLock lock, \n                                        final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n</code></pre>\n<p>这里的关键就是加锁和释放锁中的两个CAS操作：</p>\n<ol>\n<li><p>加锁过程:将CAS操作置于一个while循环中，来实现自旋的语义。由于CAS操作成功与否是成功取决于它的boolean返回值，因此当CAS操作失败的情况下，while循环将不会退出，会一直尝试CAS操作直到成功为止，此即所谓的自旋(忙等待)。</p>\n</li>\n<li><p>释放锁过程:此时不需要循环操作，但是仍然会考虑到只有当前拥有锁的线程才有资格释放锁。这一点还是通过CAS操作来保证。</p>\n</li>\n</ol>\n<p>这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。</p>\n<p><strong>运行结果</strong>:</p>\n<pre><code>Thread 0 Completed [0]\nThread 9 Completed [0, 9]\nThread 3 Completed [0, 9, 3]\nThread 8 Completed [0, 9, 3, 8]\nThread 4 Completed [0, 9, 3, 8, 4]\nThread 6 Completed [0, 9, 3, 8, 4, 6]\nThread 5 Completed [0, 9, 3, 8, 4, 6, 5]\nThread 7 Completed [0, 9, 3, 8, 4, 6, 5, 7]\nThread 1 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1]\nThread 2 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n[0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n</code></pre><p>从上可以看出，加锁和释放锁正确的实现，和预期的也是一样的，这是一个非公平的自旋锁，不是按照先来先获取锁的方式实现。</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>CAS操作需要硬件的配合；</li>\n<li>保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；</li>\n<li>没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。</li>\n</ul>\n<h4 id=\"2-Ticket-Lock\"><a href=\"#2-Ticket-Lock\" class=\"headerlink\" title=\"2.  Ticket Lock\"></a>2.  Ticket Lock</h4><p>Ticket Lock 是为了解决上面的公平性问题，类似于现实中银行柜台的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询。</p>\n<p>当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋。</p>\n<p>具体代码如下：</p>\n<pre><code class=\"java\">\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:23\n *      email  : 398757724@qq.com\n *      Desc   : Ticket Lock 简单实现，\n *      此自旋锁保证了FIFI，不会产生饥饿现象\n ***************************************/\npublic class TicketLock {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n\n    public int lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n        return myTicketNum;\n    }\n\n\n    public void unLock(int myTicketNum) {\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLock lock = new TicketLock();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n    private static Runnable generateTask(final TicketLock lock, \n            final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            int myTicketNum = lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock(myTicketNum);\n            countDownLatch.countDown();\n        };\n    }\n}\n</code></pre>\n<p>加锁和释放锁两个操作的过程如下：</p>\n<ol>\n<li>加锁过程。获取一个排队号，当排队号和当前的服务号不相等时自旋等待。</li>\n<li>释放锁过程。当前正被服务的线程释放锁，计算下一个服务号并设置。</li>\n</ol>\n<p>这里的AtomicInteger是为了保证服务号和等待号的原子性</p>\n<p>运行结果如下</p>\n<pre><code>Thread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre><p>从运行结果可以看出，确实是按照FIFO的顺序来获取锁，实现了公平性。</p>\n<p>不过上面的代码有一个问题，在释放锁的时候需要外部传进来排队号，这样就会带来一个隐患，外部传进来的排队号是可以修改的，也就是线程A获取的排队号是5，但是释放锁的时候却传进来6。这样就有可能导致死锁等问题。下面这个是通过ThreadLocal来改进上面的代码</p>\n<pre><code class=\"java\">public class TicketLockImprove {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n    //用于保存当前\n    private ThreadLocal&lt;Integer&gt; threadLocalTicketNum = new ThreadLocal&lt;&gt;();\n\n\n    public void lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n        //设置当前线程持有的排队号\n        threadLocalTicketNum.set(myTicketNum);\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n\n    }\n\n\n    public void unLock() {\n        //获取当前线程持有的排队号\n        int myTicketNum = threadLocalTicketNum.get();\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLockImprove lock = new TicketLockImprove();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final TicketLockImprove lock, final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n</code></pre>\n<p>这里是通过ThreadLocal来保存每个线程的排队号，这样就不会出现排队号被私自修改问题。其他的和上面的代码一致。</p>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</li>\n</ul>\n<p>所以，需要有一种办法能够让执行线程不再在同一个共享变量上自旋，避免过高频率的缓存同步操作。下面介绍的CLH锁和MCS锁都是为了解决这个问题的。</p>\n<p>MCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。</p>\n<p>CLH的发明人是：Craig，Landin and Hagersten。</p>\n<h3 id=\"3-MCS-锁\"><a href=\"#3-MCS-锁\" class=\"headerlink\" title=\"3. MCS 锁\"></a>3. MCS 锁</h3><p>MCS自旋锁是一种基于单向链表的高性能、公平的自旋锁，申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。</p>\n<p>先上实现代码，然后在分析重点：</p>\n<pre><code>/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:34\n *      email  : 398757724@qq.com\n *      Desc   : MCS Lock\n ***************************************/\npublic class MCSLock {\n\n    //MCS锁节点\n    public static class MCSNode {\n        //指向后继节点\n        volatile MCSNode next;\n\n        //默认是在等待锁\n        volatile boolean isBlock = true;\n    }\n\n    volatile MCSNode tail; //指向最后一个申请锁的MCSNode\n\n    // 原子更新器\n    private static final AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER\n            = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, \n                                                        MCSNode.class, &quot;tail&quot;);\n\n    //用于保存当前节点对应的MCSNode对象\n    ThreadLocal&lt;MCSNode&gt; currentThreadNode = new ThreadLocal&lt;&gt;();\n\n\n    public void lock() {\n\n        //获得当前线程对应的节点\n        MCSNode mcsNode = currentThreadNode.get();\n        if (mcsNode == null) {\n            //初始化节点对象\n            mcsNode = new MCSNode();\n            currentThreadNode.set(mcsNode);\n        }\n        //设置当前队列节点到队尾并获取前置节点\n        MCSNode predecsessor = UPDATER.getAndSet(this, mcsNode); // step 1\n\n        //如果前继节点不为空，则设置前置节点的后继为当前节点，并等待获取锁\n        if (predecsessor != null) {\n            predecsessor.next = mcsNode;  // step 2\n            // 当前线程处于等待状态时自旋(MCSNode的isBlock初始化为true)\n            // 等待前驱节点主动通知，即将isBlock设置为false，表示当前线程可以获取到锁\n            while (mcsNode.isBlock) {\n\n            }\n        } else {\n            // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞 - 表示已经加锁成功\n            mcsNode.isBlock = false;\n        }\n    }\n\n\n    public void unLock() {\n        MCSNode mcsNode = currentThreadNode.get();\n        // 当前线程对应存在节点并且\n        // 锁拥有者进行释放锁才有意义 - 当blocked为true时，表示此线程处于等待状态中，\n        //                          并没有获取到锁，因此没有权利释放锁\n        if (mcsNode == null &amp;&amp; mcsNode.isBlock) {\n            return;\n        }\n\n        if (mcsNode.next == null) {\n            if (UPDATER.compareAndSet(this, mcsNode, null)) {\n                // compareAndSet返回true表示确实没有人排在自己后面\n                return;\n            } else {\n                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者\n                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完\n                while (mcsNode.next == null) {\n                }\n            }\n        }\n        // 通知后继节点可以获取锁\n        mcsNode.next.isBlock = false;\n\n        // 将当前节点从链表中断开，方便对当前节点进行GC\n        mcsNode.next = null;// for GC\n        //for GC\n        currentThreadNode.remove();\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final MCSLock lock = new MCSLock();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    private static Runnable generateTask(final MCSLock lock, \n                        final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n</code></pre><p>实现的代码量虽然不多，但是lock和unlock的设计思想还是有些微妙之处，想要实现正确也并不容易。</p>\n<p>需要把握的几个重点：</p>\n<ol>\n<li>MCS锁的节点对象需要有两个状态，next用来维护单向链表的结构，blocked用来表示节点的状态，true表示处于自旋中；false表示加锁成功</li>\n<li>MCS锁的节点状态blocked的改变是由其前驱节点触发改变的</li>\n<li>加锁时会更新链表的末节点并完成链表结构的维护</li>\n<li>释放锁的时候由于链表结构建立的时滞(getAndSet原子方法和链表建立整体而言并非原子性)，可能存在多线程的干扰，需要使用忙等待保证链表结构就绪</li>\n</ol>\n<h3 id=\"4-CLH锁\"><a href=\"#4-CLH锁\" class=\"headerlink\" title=\"4. CLH锁\"></a>4. CLH锁</h3><p>同MCS自旋锁一样，CLH也是一种基于单向链表(隐式创建)的高性能、公平的自旋锁，申请加锁的线程只需要在其前驱节点的本地变量上自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。</p>\n<p>实现代码</p>\n<pre><code>public class CLHLock {\n\n    public static class CLHNode {\n        private boolean isLocked = true; // 默认状态为true - 即处于等待状态或者加锁成功(换言之，即此节点处于有效的一种状态)\n    }\n\n    @SuppressWarnings(&quot;unused&quot;)\n    private volatile CLHNode tail;\n\n    //线程对应CLH节点映射\n    private ThreadLocal&lt;CLHNode&gt; currentThreadNode = new ThreadLocal&lt;&gt;();\n\n\n    /**\n     * CLH 锁获取\n     */\n    public void lock() {\n        CLHNode clhNode = currentThreadNode.get();\n        if (clhNode == null) {\n            clhNode = new CLHNode();\n            currentThreadNode.set(clhNode);\n        }\n        //通过这个操作完成隐式链表的维护，后继节点只需要在前驱节点的locked状态上自旋\n        CLHNode preNode = UPDATER.getAndSet(this, clhNode);\n        if (preNode != null) {  //已有线程占用了锁，进入自旋\n            while (preNode.isLocked) {  //自旋等待前驱节点状态变更 - unlock中进行变更\n\n                //这里这样写，或者isLocked加上voliate，则能观察到变量的变化\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 没有前驱节点表示可以直接获取到锁，由于默认获取锁状态为true，此时可以什么操作都不执行\n        // 能够执行到这里表示已经成功获取到了锁\n\n    }\n\n\n    /**\n     * CLH 锁释放\n     */\n    public void unLock() {\n        CLHNode clhNode = currentThreadNode.get();\n        //只有持有锁的线程才能释放\n        if (clhNode == null || !clhNode.isLocked) {\n            return;\n        }\n\n        //从映射关系中移除当前线程对应的节点\n        currentThreadNode.remove();\n\n        //如果队列里只有当前线程，则释放对当前线程的引用(for GC)\n        // 尝试将tail从currentThread变更为null，因此当tail不为currentThread时表示还有线程在等待加锁\n        if (!UPDATER.compareAndSet(this, clhNode, null)) {\n            //还有后续线程\n            clhNode.isLocked = false; //改变状态，让后续线程结束自旋\n        }\n    }\n\n\n    private static final AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER =\n            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, &quot;tail&quot;);\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final CLHLock lock = new CLHLock();\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final CLHLock lock, \n                        final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n            } catch (Exception e) {\n\n            }\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, list));\n//            System.out.println(String.format(&quot;Thread %s Completed &quot;, taskId));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n</code></pre><p>实现的代码量相比MCS锁少了很多，也简洁了不少。</p>\n<p>需要把握的几个重点：</p>\n<ol>\n<li>CLH锁的节点对象只有一个isLocked属性，关于其含义前面已经详细讨论过</li>\n<li>CLH锁的节点属性isLocked的改变是由其自身触发的</li>\n<li>CLH锁是在前驱节点的isLocked属性上进行自旋</li>\n</ol>\n<p>众所周知，AbstractQueuedSynchronizer是Java并发包的基石之一，而CLH锁的原理和思想则是AbstractQueuedSynchronizer的基石之一。理解清楚CLH锁的原理和实现对后面学习和理解AbstractQueuedSynchronizer是非常必要的。</p>\n<p>在<strong>Doug Lea 写的The java.util.concurrent Synchronizer Framework</strong> 文章中有这么一句话 <strong>CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。</strong>其实只要实现了取消功能，那么超时就比较容易实现。为什么CLH更容易实现取消功能呢。首先在CLH各节点之间只有一条隐形的链表存在，而排队的节点是观察前面节点的信息来判断是否可以获取锁，因此在取消排队节点时，可以不影响前继节点，而对后继节点的影响也比较小，如果MCS自旋锁要取消，则需要前继节点改变后继节点，如果敲好此时前继节点正在拿到锁运行，那此时更改锁就不是那么容易的，而且链表有事单链表，因此更改起来更加麻烦。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>下面我们来比较一下MCS和CLH锁</p>\n<p>首先我们先补充一点知识SMP和NUMA架构</p>\n<ul>\n<li>SMP(Symmetric Multi-Processor)：对称多处理器结构，指服务器中多个 CPU 对称工作，每个 CPU 访问内存地址所需时间相同。其主要特征是共享，包含对 CPU，内存，I/O 等进行共享。SMP 能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着 CPU 数量的增加，每个 CPU 都要访问相同的内存资源，可能导致内存访问冲突，可能会导致 CPU 资源的浪费。常用的 PC 机就属于这种。</li>\n<li>NUMA(Non-Uniform Memory Access)：非一致存储访问，将 CPU 分为 CPU 模块，每个 CPU 模块由多个 CPU 组成，并且具有独立的本地内存、I/O 槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存 (系统内其它节点的内存) 的速度，这也是非一致存储访问的由来。NUMA 较好地解决 SMP 的扩展问题，当 CPU 数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。</li>\n</ul>\n<p>CLH 队列锁的优点是空间复杂度低（如果有 n 个线程，L 个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O（L+n），n 个线程有 n 个myNode，L 个锁有 L 个 tail），CLH 的一种变体被应用在了 JAVA 并发框架中 (AbstractQueuedSynchronizer.Node)。CLH 在 SMP 系统结构下该法是非常有效的。但在 NUMA 系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，一种解决 NUMA 系统结构的思路是 MCS 队列锁。</p>\n<p>MSC 与 CLH 最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:CLH 是在前趋结点的 locked 域上自旋等待，而 MCS 是在自己的结点的 locked 域上自旋等待。正因为如此，它解决了 CLH 在 NUMA 系统架构中获取 locked 域状态内存过远的问题。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79677891\" target=\"_blank\" rel=\"noopener\">简单的非公平自旋锁以及基于排队的公平自旋锁的实现</a></li>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79842501\" target=\"_blank\" rel=\"noopener\">CLH锁的原理和实现</a></li>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79783104\" target=\"_blank\" rel=\"noopener\">MCS锁的原理和实现</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015795906\" target=\"_blank\" rel=\"noopener\">面试必备之深入理解自旋锁</a></li>\n<li><a href=\"https://lawrence-zxc.github.io/2015/05/03/lock/\" target=\"_blank\" rel=\"noopener\">Java自旋锁、排队自旋锁、MCS锁、CLH锁</a></li>\n<li><a href=\"https://blog.csdn.net/jackyechina/article/details/73199638\" target=\"_blank\" rel=\"noopener\">CLH锁与MCS锁</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<hr>\n<h1 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>自旋锁是什么</li>\n<li>自旋锁实现</li>\n<li>MCS自旋锁</li>\n<li>CLH自旋锁</li>\n</ol>\n<h3 id=\"1-自旋锁是什么\"><a href=\"#1-自旋锁是什么\" class=\"headerlink\" title=\"1. 自旋锁是什么\"></a>1. 自旋锁是什么</h3><p>自旋锁与<strong>互斥量</strong>(注意这里不是互斥锁)类似，用于多线程同步的一种锁。但他不是休眠使线程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。基本的实现是通过线程反复检查锁特定变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。</p>\n<p>自旋锁通常被作为底层原语用于实现其他类型的锁。根据它们所基于与的系统体系结构，可以通过使用测试并设置指令（CAS）有效的实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其它的事情，这也是自旋锁只能够持有一段时间的原因。</p>\n<p>有了这一层了解，自旋锁的优势和劣势，以及其适用场景也就一目了然了。<br>","more":"</p>\n<h4 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h4><ol>\n<li>没有线程阻塞，也就没有了线程上下文切换带来的开销</li>\n<li>自旋操作更加直观，无需分析什么情况下会导致线程阻塞</li>\n</ol>\n<h4 id=\"劣势：\"><a href=\"#劣势：\" class=\"headerlink\" title=\"劣势：\"></a>劣势：</h4><p>最大的问题就是由于需要一直循环检测锁的状态，因此会浪费CPU Cycles</p>\n<h4 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h4><p>结合上述的优劣，自旋锁在锁的临界区很小并且锁争抢排队不是非常严重的情况下是非常合适的：</p>\n<ol>\n<li>临界区小，因此每个使用锁的线程占用锁的时间不会很长，自旋等待的线程能够快速地获取到锁。</li>\n<li>所争抢排队不严重，因此锁的自旋时间也是可控的，不会有大量线程处于自旋等待的状态中，从而增加浪费CPU Cycles。</li>\n</ol>\n<h3 id=\"2-自旋锁实现\"><a href=\"#2-自旋锁实现\" class=\"headerlink\" title=\"2. 自旋锁实现\"></a>2. 自旋锁实现</h3><p>首先需要明确的一点是，对于加锁和释放锁的操作，需要是原子性的。这是能够继续讨论的基石。对于现代处理器，一般通过CAS(Compare And Set)操作来保证原子性。它的原理其实很简单，就是将“对比-设置”这一个流程原子化，保证在符合某种预期的前提下，完成一次写操作。</p>\n<p>对应到Java语言层面，就是那一大票的AtomicXXX类型。比如在下面的非公平自旋锁的实现中，会借助AtomicReference类型提供的CAS操作来完成加锁和释放锁的操作。</p>\n<h4 id=\"1-简单的自旋锁\"><a href=\"#1-简单的自旋锁\" class=\"headerlink\" title=\"1. 简单的自旋锁\"></a>1. 简单的自旋锁</h4><p>直接上代码</p>\n<pre><code class=\"java\">package JUC.spinLock;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 19:38\n *      email  : 398757724@qq.com\n *      Desc   : 简单的自旋锁，哪个线程竞争到，\n *      则获取锁，有可能产生饥饿现象\n ***************************************/\npublic class SpinLock {\n\n    //维护当前拥有锁的线程\n    private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;();\n\n\n    public void lock() {\n        Thread currentThread = Thread.currentThread();\n\n        // 如果锁未被占用，则设置当前线程为锁的拥有者\n        while (!owner.compareAndSet(null, currentThread)) {\n            // 自旋\n        }\n    }\n\n\n    public void unLock() {\n        Thread currentThread = Thread.currentThread();\n        // 只有锁的拥有者才能释放锁，其它的线程因为无法满足Compare，因此不会Set成功\n        owner.compareAndSet(currentThread, null);\n    }\n\n\n    //一下代码属于测试\n    //用于等待所有线程都已结束\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    //所有线程共享的变量，用于测试，如果加锁和释放锁是正确的操作\n    //则在操作此集合时不会产生ConcurrentModificationException\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final SpinLock lock = new SpinLock();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n\n    private static Runnable generateTask(final SpinLock lock, \n                                        final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n</code></pre>\n<p>这里的关键就是加锁和释放锁中的两个CAS操作：</p>\n<ol>\n<li><p>加锁过程:将CAS操作置于一个while循环中，来实现自旋的语义。由于CAS操作成功与否是成功取决于它的boolean返回值，因此当CAS操作失败的情况下，while循环将不会退出，会一直尝试CAS操作直到成功为止，此即所谓的自旋(忙等待)。</p>\n</li>\n<li><p>释放锁过程:此时不需要循环操作，但是仍然会考虑到只有当前拥有锁的线程才有资格释放锁。这一点还是通过CAS操作来保证。</p>\n</li>\n</ol>\n<p>这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。</p>\n<p><strong>运行结果</strong>:</p>\n<pre><code>Thread 0 Completed [0]\nThread 9 Completed [0, 9]\nThread 3 Completed [0, 9, 3]\nThread 8 Completed [0, 9, 3, 8]\nThread 4 Completed [0, 9, 3, 8, 4]\nThread 6 Completed [0, 9, 3, 8, 4, 6]\nThread 5 Completed [0, 9, 3, 8, 4, 6, 5]\nThread 7 Completed [0, 9, 3, 8, 4, 6, 5, 7]\nThread 1 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1]\nThread 2 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n[0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n</code></pre><p>从上可以看出，加锁和释放锁正确的实现，和预期的也是一样的，这是一个非公平的自旋锁，不是按照先来先获取锁的方式实现。</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>CAS操作需要硬件的配合；</li>\n<li>保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；</li>\n<li>没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。</li>\n</ul>\n<h4 id=\"2-Ticket-Lock\"><a href=\"#2-Ticket-Lock\" class=\"headerlink\" title=\"2.  Ticket Lock\"></a>2.  Ticket Lock</h4><p>Ticket Lock 是为了解决上面的公平性问题，类似于现实中银行柜台的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询。</p>\n<p>当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋。</p>\n<p>具体代码如下：</p>\n<pre><code class=\"java\">\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:23\n *      email  : 398757724@qq.com\n *      Desc   : Ticket Lock 简单实现，\n *      此自旋锁保证了FIFI，不会产生饥饿现象\n ***************************************/\npublic class TicketLock {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n\n    public int lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n        return myTicketNum;\n    }\n\n\n    public void unLock(int myTicketNum) {\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLock lock = new TicketLock();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n    private static Runnable generateTask(final TicketLock lock, \n            final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            int myTicketNum = lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock(myTicketNum);\n            countDownLatch.countDown();\n        };\n    }\n}\n</code></pre>\n<p>加锁和释放锁两个操作的过程如下：</p>\n<ol>\n<li>加锁过程。获取一个排队号，当排队号和当前的服务号不相等时自旋等待。</li>\n<li>释放锁过程。当前正被服务的线程释放锁，计算下一个服务号并设置。</li>\n</ol>\n<p>这里的AtomicInteger是为了保证服务号和等待号的原子性</p>\n<p>运行结果如下</p>\n<pre><code>Thread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre><p>从运行结果可以看出，确实是按照FIFO的顺序来获取锁，实现了公平性。</p>\n<p>不过上面的代码有一个问题，在释放锁的时候需要外部传进来排队号，这样就会带来一个隐患，外部传进来的排队号是可以修改的，也就是线程A获取的排队号是5，但是释放锁的时候却传进来6。这样就有可能导致死锁等问题。下面这个是通过ThreadLocal来改进上面的代码</p>\n<pre><code class=\"java\">public class TicketLockImprove {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n    //用于保存当前\n    private ThreadLocal&lt;Integer&gt; threadLocalTicketNum = new ThreadLocal&lt;&gt;();\n\n\n    public void lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n        //设置当前线程持有的排队号\n        threadLocalTicketNum.set(myTicketNum);\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n\n    }\n\n\n    public void unLock() {\n        //获取当前线程持有的排队号\n        int myTicketNum = threadLocalTicketNum.get();\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLockImprove lock = new TicketLockImprove();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final TicketLockImprove lock, final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n</code></pre>\n<p>这里是通过ThreadLocal来保存每个线程的排队号，这样就不会出现排队号被私自修改问题。其他的和上面的代码一致。</p>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</li>\n</ul>\n<p>所以，需要有一种办法能够让执行线程不再在同一个共享变量上自旋，避免过高频率的缓存同步操作。下面介绍的CLH锁和MCS锁都是为了解决这个问题的。</p>\n<p>MCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。</p>\n<p>CLH的发明人是：Craig，Landin and Hagersten。</p>\n<h3 id=\"3-MCS-锁\"><a href=\"#3-MCS-锁\" class=\"headerlink\" title=\"3. MCS 锁\"></a>3. MCS 锁</h3><p>MCS自旋锁是一种基于单向链表的高性能、公平的自旋锁，申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。</p>\n<p>先上实现代码，然后在分析重点：</p>\n<pre><code>/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:34\n *      email  : 398757724@qq.com\n *      Desc   : MCS Lock\n ***************************************/\npublic class MCSLock {\n\n    //MCS锁节点\n    public static class MCSNode {\n        //指向后继节点\n        volatile MCSNode next;\n\n        //默认是在等待锁\n        volatile boolean isBlock = true;\n    }\n\n    volatile MCSNode tail; //指向最后一个申请锁的MCSNode\n\n    // 原子更新器\n    private static final AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER\n            = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, \n                                                        MCSNode.class, &quot;tail&quot;);\n\n    //用于保存当前节点对应的MCSNode对象\n    ThreadLocal&lt;MCSNode&gt; currentThreadNode = new ThreadLocal&lt;&gt;();\n\n\n    public void lock() {\n\n        //获得当前线程对应的节点\n        MCSNode mcsNode = currentThreadNode.get();\n        if (mcsNode == null) {\n            //初始化节点对象\n            mcsNode = new MCSNode();\n            currentThreadNode.set(mcsNode);\n        }\n        //设置当前队列节点到队尾并获取前置节点\n        MCSNode predecsessor = UPDATER.getAndSet(this, mcsNode); // step 1\n\n        //如果前继节点不为空，则设置前置节点的后继为当前节点，并等待获取锁\n        if (predecsessor != null) {\n            predecsessor.next = mcsNode;  // step 2\n            // 当前线程处于等待状态时自旋(MCSNode的isBlock初始化为true)\n            // 等待前驱节点主动通知，即将isBlock设置为false，表示当前线程可以获取到锁\n            while (mcsNode.isBlock) {\n\n            }\n        } else {\n            // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞 - 表示已经加锁成功\n            mcsNode.isBlock = false;\n        }\n    }\n\n\n    public void unLock() {\n        MCSNode mcsNode = currentThreadNode.get();\n        // 当前线程对应存在节点并且\n        // 锁拥有者进行释放锁才有意义 - 当blocked为true时，表示此线程处于等待状态中，\n        //                          并没有获取到锁，因此没有权利释放锁\n        if (mcsNode == null &amp;&amp; mcsNode.isBlock) {\n            return;\n        }\n\n        if (mcsNode.next == null) {\n            if (UPDATER.compareAndSet(this, mcsNode, null)) {\n                // compareAndSet返回true表示确实没有人排在自己后面\n                return;\n            } else {\n                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者\n                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完\n                while (mcsNode.next == null) {\n                }\n            }\n        }\n        // 通知后继节点可以获取锁\n        mcsNode.next.isBlock = false;\n\n        // 将当前节点从链表中断开，方便对当前节点进行GC\n        mcsNode.next = null;// for GC\n        //for GC\n        currentThreadNode.remove();\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final MCSLock lock = new MCSLock();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    private static Runnable generateTask(final MCSLock lock, \n                        final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n</code></pre><p>实现的代码量虽然不多，但是lock和unlock的设计思想还是有些微妙之处，想要实现正确也并不容易。</p>\n<p>需要把握的几个重点：</p>\n<ol>\n<li>MCS锁的节点对象需要有两个状态，next用来维护单向链表的结构，blocked用来表示节点的状态，true表示处于自旋中；false表示加锁成功</li>\n<li>MCS锁的节点状态blocked的改变是由其前驱节点触发改变的</li>\n<li>加锁时会更新链表的末节点并完成链表结构的维护</li>\n<li>释放锁的时候由于链表结构建立的时滞(getAndSet原子方法和链表建立整体而言并非原子性)，可能存在多线程的干扰，需要使用忙等待保证链表结构就绪</li>\n</ol>\n<h3 id=\"4-CLH锁\"><a href=\"#4-CLH锁\" class=\"headerlink\" title=\"4. CLH锁\"></a>4. CLH锁</h3><p>同MCS自旋锁一样，CLH也是一种基于单向链表(隐式创建)的高性能、公平的自旋锁，申请加锁的线程只需要在其前驱节点的本地变量上自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。</p>\n<p>实现代码</p>\n<pre><code>public class CLHLock {\n\n    public static class CLHNode {\n        private boolean isLocked = true; // 默认状态为true - 即处于等待状态或者加锁成功(换言之，即此节点处于有效的一种状态)\n    }\n\n    @SuppressWarnings(&quot;unused&quot;)\n    private volatile CLHNode tail;\n\n    //线程对应CLH节点映射\n    private ThreadLocal&lt;CLHNode&gt; currentThreadNode = new ThreadLocal&lt;&gt;();\n\n\n    /**\n     * CLH 锁获取\n     */\n    public void lock() {\n        CLHNode clhNode = currentThreadNode.get();\n        if (clhNode == null) {\n            clhNode = new CLHNode();\n            currentThreadNode.set(clhNode);\n        }\n        //通过这个操作完成隐式链表的维护，后继节点只需要在前驱节点的locked状态上自旋\n        CLHNode preNode = UPDATER.getAndSet(this, clhNode);\n        if (preNode != null) {  //已有线程占用了锁，进入自旋\n            while (preNode.isLocked) {  //自旋等待前驱节点状态变更 - unlock中进行变更\n\n                //这里这样写，或者isLocked加上voliate，则能观察到变量的变化\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 没有前驱节点表示可以直接获取到锁，由于默认获取锁状态为true，此时可以什么操作都不执行\n        // 能够执行到这里表示已经成功获取到了锁\n\n    }\n\n\n    /**\n     * CLH 锁释放\n     */\n    public void unLock() {\n        CLHNode clhNode = currentThreadNode.get();\n        //只有持有锁的线程才能释放\n        if (clhNode == null || !clhNode.isLocked) {\n            return;\n        }\n\n        //从映射关系中移除当前线程对应的节点\n        currentThreadNode.remove();\n\n        //如果队列里只有当前线程，则释放对当前线程的引用(for GC)\n        // 尝试将tail从currentThread变更为null，因此当tail不为currentThread时表示还有线程在等待加锁\n        if (!UPDATER.compareAndSet(this, clhNode, null)) {\n            //还有后续线程\n            clhNode.isLocked = false; //改变状态，让后续线程结束自旋\n        }\n    }\n\n\n    private static final AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER =\n            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, &quot;tail&quot;);\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final CLHLock lock = new CLHLock();\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final CLHLock lock, \n                        final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n            } catch (Exception e) {\n\n            }\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, list));\n//            System.out.println(String.format(&quot;Thread %s Completed &quot;, taskId));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n</code></pre><p>实现的代码量相比MCS锁少了很多，也简洁了不少。</p>\n<p>需要把握的几个重点：</p>\n<ol>\n<li>CLH锁的节点对象只有一个isLocked属性，关于其含义前面已经详细讨论过</li>\n<li>CLH锁的节点属性isLocked的改变是由其自身触发的</li>\n<li>CLH锁是在前驱节点的isLocked属性上进行自旋</li>\n</ol>\n<p>众所周知，AbstractQueuedSynchronizer是Java并发包的基石之一，而CLH锁的原理和思想则是AbstractQueuedSynchronizer的基石之一。理解清楚CLH锁的原理和实现对后面学习和理解AbstractQueuedSynchronizer是非常必要的。</p>\n<p>在<strong>Doug Lea 写的The java.util.concurrent Synchronizer Framework</strong> 文章中有这么一句话 <strong>CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。</strong>其实只要实现了取消功能，那么超时就比较容易实现。为什么CLH更容易实现取消功能呢。首先在CLH各节点之间只有一条隐形的链表存在，而排队的节点是观察前面节点的信息来判断是否可以获取锁，因此在取消排队节点时，可以不影响前继节点，而对后继节点的影响也比较小，如果MCS自旋锁要取消，则需要前继节点改变后继节点，如果敲好此时前继节点正在拿到锁运行，那此时更改锁就不是那么容易的，而且链表有事单链表，因此更改起来更加麻烦。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>下面我们来比较一下MCS和CLH锁</p>\n<p>首先我们先补充一点知识SMP和NUMA架构</p>\n<ul>\n<li>SMP(Symmetric Multi-Processor)：对称多处理器结构，指服务器中多个 CPU 对称工作，每个 CPU 访问内存地址所需时间相同。其主要特征是共享，包含对 CPU，内存，I/O 等进行共享。SMP 能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着 CPU 数量的增加，每个 CPU 都要访问相同的内存资源，可能导致内存访问冲突，可能会导致 CPU 资源的浪费。常用的 PC 机就属于这种。</li>\n<li>NUMA(Non-Uniform Memory Access)：非一致存储访问，将 CPU 分为 CPU 模块，每个 CPU 模块由多个 CPU 组成，并且具有独立的本地内存、I/O 槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存 (系统内其它节点的内存) 的速度，这也是非一致存储访问的由来。NUMA 较好地解决 SMP 的扩展问题，当 CPU 数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。</li>\n</ul>\n<p>CLH 队列锁的优点是空间复杂度低（如果有 n 个线程，L 个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O（L+n），n 个线程有 n 个myNode，L 个锁有 L 个 tail），CLH 的一种变体被应用在了 JAVA 并发框架中 (AbstractQueuedSynchronizer.Node)。CLH 在 SMP 系统结构下该法是非常有效的。但在 NUMA 系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，一种解决 NUMA 系统结构的思路是 MCS 队列锁。</p>\n<p>MSC 与 CLH 最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:CLH 是在前趋结点的 locked 域上自旋等待，而 MCS 是在自己的结点的 locked 域上自旋等待。正因为如此，它解决了 CLH 在 NUMA 系统架构中获取 locked 域状态内存过远的问题。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79677891\" target=\"_blank\" rel=\"noopener\">简单的非公平自旋锁以及基于排队的公平自旋锁的实现</a></li>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79842501\" target=\"_blank\" rel=\"noopener\">CLH锁的原理和实现</a></li>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79783104\" target=\"_blank\" rel=\"noopener\">MCS锁的原理和实现</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015795906\" target=\"_blank\" rel=\"noopener\">面试必备之深入理解自旋锁</a></li>\n<li><a href=\"https://lawrence-zxc.github.io/2015/05/03/lock/\" target=\"_blank\" rel=\"noopener\">Java自旋锁、排队自旋锁、MCS锁、CLH锁</a></li>\n<li><a href=\"https://blog.csdn.net/jackyechina/article/details/73199638\" target=\"_blank\" rel=\"noopener\">CLH锁与MCS锁</a></li>\n</ol>"},{"abbrlink":7,"title":"java多线程系列 07 ThreadGroup","author":"zhangke","date":"2018-07-13T07:27:00.000Z","_content":"# java多线程系列之07 ThreadGroup\n\n### 概要\n\n>1. ThreadGroup 介绍\n>2. 基本API的使用与介绍\n\n### 1. ThreadGroup 介绍\n\n> 在java的多线程处理中有线程组ThreadGroup的概念，ThreadGroup是为了方便线程管理出现了，可以统一设定线程组的一些属性，比如setDaemon，设置未处理异常的处理方法，设置统一的安全策略等等；也可以通过线程组方便的获得线程的一些信息。\n>\n> 每一个ThreadGroup都可以包含一组的子线程和一组子线程组，在一个进程中线程组是以树形的方式存在，通常情况下根线程组是system线程组。system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。\n\n### 2. 基本API介绍\n\n>```\n>// 构造函数 \n>ThreadGroup(String name)  \n>ThreadGroup(ThreadGroup parent, String name)\n>\n>// 基本API\n>int\tactiveCount()  //返回一个预估的当前TreadGroup和子group中存活线程的数量\n>int\tactiveGroupCount() //返回一个预估的当前TreadGroup所包含的group中存活ThreadGroup的数量\n>void\tcheckAccess() //判断当前运行的线程是否有权限修改此group\n>void\tdestroy()   //销毁当前group和子group\n>int\tenumerate(Thread[] list) //拷贝当前group和子group中的没有dead的线程\n>int\tenumerate(Thread[] list,boolean recurs)//和上一个的区别就是是否需要拷贝子group中的线程\n>int\tenumerate(ThreadGroup[] list)  //拷贝当前group和子group中ThreadGroup\n>int\tenumerate(ThreadGroup[] list, boolean recurse) //是否需要子Group\n>String\tgetName()\n>ThreadGroup\tgetParent()\n>void\tinterrupt()  //设置当前ThreadGroup中所有的线程中断标记为true\n>boolean\tisDaemon()\n>boolean\tisDestroyed()  //判断当前group是否被销毁\n>void\tlist() //打印当前group中的信息去标准输入流\n>boolean\tparentOf(ThreadGroup g)\n>void\tsetDaemon(boolean daemon)  //改变当前group中的线程为daemon线程\n>void\tsetMaxPriority(int pri)  //设置当前group的权限最大值\n>int\t    getMaxPriority() //返回当前ThreadGroup的最大权限\n>\n>void\tuncaughtException(Thread t, Throwable e)\n>```\n>\n>### 创建ThreadGroup\n>\n>简单demo\n>\n>```\n>  //创建ThreadGroup\n>    public static void createThreadGroup() {\n>        //获取当前的ThreadGroup\n>        ThreadGroup currentGroup = Thread.currentThread().getThreadGroup();\n>\n>        //定义一个新的ThreadGroup，默认panrent为当前线程所对应的group\n>        ThreadGroup group1 = new ThreadGroup(\"Group1\");\n>\n>        //判断当前线程对应的ThreadGroup是否是group1的parentgroup\n>        System.out.println(currentGroup == group1.getParent());\n>\n>        //定义一个新的group2，其parent为group1\n>        ThreadGroup group2 = new ThreadGroup(group1, \"group2\");\n>\n>        //使用ThreadGroup自带的API判断group1是否是group2的parent\n>        System.out.println(group1.parentOf(group2));\n>    }\n>```\n>\n>运行结果\n>\n>```\n>true\n>true\n>```\n>\n>结果分析：说明如果没有指定创建ThreadGroup的parent，则默认为当前线程所对应的ThreadGroup，另外需要注意的是，ThreadGroup是树形的分布，这课树的根是system，也就是在类加载时就建立好的，接着在main线程启动时，创建了一个以main为名的ThreadGroup。\n>\n>### 使用enumerate 获取当前thread\n>\n>```\n>    //使用enumerate 复制Thread\n>    public static void enumerateThread() throws InterruptedException {\n>        //创建一个新的ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group\");\n>\n>        //创建线程，设置ThreadGroup\n>        Thread thread = new Thread(group, () -> {\n>            while (true) {\n>                try {\n>                    TimeUnit.SECONDS.sleep(1);\n>                } catch (Exception e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        });\n>\n>        thread.start();\n>        TimeUnit.MILLISECONDS.sleep(2);\n>\n>        //得到当前线程对应的ThreadGroup\n>        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();\n>\n>        //创建存储当前ThreadGroup对应线程的数组\n>        Thread[] list = new Thread[mainGroup.activeCount()];\n>\n>        int recuresize = mainGroup.enumerate(list);\n>        System.out.println(recuresize);\n>\n>        recuresize = mainGroup.enumerate(list, false);\n>        System.out.println(recuresize);\n>    }\n>```\n>\n>运行结果:\n>\n>```\n>2\n>1\n>```\n>\n>### 基本API的使用\n>\n>```\n> //一些基本API的操作\n>    public static void testAPI() throws InterruptedException {\n>        //创建一个ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group1\");\n>\n>        //创建线程，设置ThreadGroup\n>        Thread thread = new Thread(group, () -> {\n>            while (true) {\n>                try {\n>                    TimeUnit.SECONDS.sleep(2);\n>                } catch (Exception e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        });\n>        thread.setDaemon(true);\n>        thread.start();\n>\n>\n>        //确保thread开启\n>        TimeUnit.MILLISECONDS.sleep(2);\n>        ThreadGroup mainThreadGroup = Thread.currentThread().getThreadGroup();\n>        System.out.println(\"activeCount = \" + mainThreadGroup.activeCount());\n>        System.out.println(\"activeGroupCount=\" + mainThreadGroup.activeGroupCount());\n>        System.out.println(\"getMaxPriority = \" + mainThreadGroup.getMaxPriority());\n>        System.out.println(\"getName = \" + mainThreadGroup.getName());\n>        System.out.println(\"getParent = \" + mainThreadGroup.getName());\n>        mainThreadGroup.list();\n>        System.out.println(\"------------------------------------\");\n>        System.out.println(\"parentOf = \" + mainThreadGroup.parentOf(group));\n>        System.out.println(\"parentOf = \" + mainThreadGroup.parentOf(mainThreadGroup));\n>\n>    }\n>```\n>\n>运行结果：\n>\n>```\n>activeCount = 2\n>activeGroupCount=1\n>getMaxPriority = 10\n>getName = main\n>getParent = main\n>java.lang.ThreadGroup[name=main,maxpri=10]\n>    Thread[main,5,main]\n>    java.lang.ThreadGroup[name=group1,maxpri=10]\n>        Thread[Thread-0,5,group1]\n>------------------------------------\n>parentOf = true\n>parentOf = true\n>```\n>\n>最后需要注意的是，group的parent也可以是自己本身，这不知道是不是bug。\n>\n>### setMaxPriority\n>\n>```\n>//线程组优先级设置\n>    public static void threadGroupPriority() {\n>        //创建一个ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group1\");\n>\n>        //创建线程，设置ThreadGroup\n>        Thread thread = new Thread(group, () -> {\n>            while (true) {\n>                try {\n>                    TimeUnit.SECONDS.sleep(2);\n>                } catch (Exception e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        });\n>        thread.setDaemon(true);\n>        thread.start();\n>        System.out.println(\"group getMaxPriority()=\" + group.getMaxPriority());\n>        System.out.println(\"thread.getPriority()=\" + thread.getPriority());\n>\n>        //改变group的最大优先级\n>        group.setMaxPriority(3);\n>        System.out.println(\"group getMaxPriority()=\" + group.getMaxPriority());\n>        System.out.println(\"thread.getPriority()=\" + thread.getPriority());\n>    }\n>```\n>\n>运行结果\n>\n>```\n>group getMaxPriority()=10\n>thread.getPriority()=5\n>group getMaxPriority()=3\n>thread.getPriority()=5\n>```\n>\n>在ThreadGroup中线程的优先级是不能大于ThreadGroup设置的最大优先级，但是上面的结果显示线程的优先级大于了ThreadGroup的最大优先级。这是因为，线程在添加时优先级是不大于ThreadGroup的最大优先级，但是后来ThreadGroup修改了最大优先级，但由于线程的优先级已经设置好了，ThreadGroup将不能去更改这个优先级，所以就存在线程组中有大于线程组最大优先级的线程。但是在这之后添加的线程就不会大于线程组的优先级。\n>\n>### ThreadGroup的Damon设置和destory\n>\n>```\n>//守护ThreadGroup 和destory\n>    public static void threadGroupDaemon() throws InterruptedException {\n>        //创建一个ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group1\");\n>\n>        //创建线程，设置ThreadGroup\n>        new Thread(group, () -> {\n>\n>            try {\n>                TimeUnit.SECONDS.sleep(1);\n>            } catch (Exception e) {\n>                e.printStackTrace();\n>            }\n>\n>        }, \"group1-thread\").start();\n>        //创建一个ThreadGroup\n>        ThreadGroup group2 = new ThreadGroup(\"group2\");\n>\n>        //创建线程，设置ThreadGroup\n>        new Thread(group2, () -> {\n>\n>            try {\n>                TimeUnit.SECONDS.sleep(1);\n>            } catch (Exception e) {\n>                e.printStackTrace();\n>            }\n>\n>        }, \"group2-thread\").start();\n>\n>        //设置group2为daemon为true\n>        group2.setDaemon(true);\n>        TimeUnit.SECONDS.sleep(3);\n>        System.out.println(group.isDestroyed());\n>        System.out.println(group2.isDestroyed());\n>    }\n>```\n>\n>运行结果:\n>\n>```\n>false\n>true\n>```\n>\n>当线程组设置为daemon之后，只要线程组中不存在活跃的线程，线程组则自动destory。但是如果线程组没有设置daemon为true，即使线程组中没有活跃的线程，也不会自动destory。\n>\n>注意一点是：destory只有当线程组和子线程组中没有活跃的线程才能调用，否则抛出异常。\n>\n>\n>\n>\n>\n>","source":"_posts/threads/java多线程系列 07 ThreadGroup.md","raw":"abbrlink: 7\ntitle: java多线程系列 07 ThreadGroup\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-13 15:27:00\n---\n# java多线程系列之07 ThreadGroup\n\n### 概要\n\n>1. ThreadGroup 介绍\n>2. 基本API的使用与介绍\n\n### 1. ThreadGroup 介绍\n\n> 在java的多线程处理中有线程组ThreadGroup的概念，ThreadGroup是为了方便线程管理出现了，可以统一设定线程组的一些属性，比如setDaemon，设置未处理异常的处理方法，设置统一的安全策略等等；也可以通过线程组方便的获得线程的一些信息。\n>\n> 每一个ThreadGroup都可以包含一组的子线程和一组子线程组，在一个进程中线程组是以树形的方式存在，通常情况下根线程组是system线程组。system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。\n\n### 2. 基本API介绍\n\n>```\n>// 构造函数 \n>ThreadGroup(String name)  \n>ThreadGroup(ThreadGroup parent, String name)\n>\n>// 基本API\n>int\tactiveCount()  //返回一个预估的当前TreadGroup和子group中存活线程的数量\n>int\tactiveGroupCount() //返回一个预估的当前TreadGroup所包含的group中存活ThreadGroup的数量\n>void\tcheckAccess() //判断当前运行的线程是否有权限修改此group\n>void\tdestroy()   //销毁当前group和子group\n>int\tenumerate(Thread[] list) //拷贝当前group和子group中的没有dead的线程\n>int\tenumerate(Thread[] list,boolean recurs)//和上一个的区别就是是否需要拷贝子group中的线程\n>int\tenumerate(ThreadGroup[] list)  //拷贝当前group和子group中ThreadGroup\n>int\tenumerate(ThreadGroup[] list, boolean recurse) //是否需要子Group\n>String\tgetName()\n>ThreadGroup\tgetParent()\n>void\tinterrupt()  //设置当前ThreadGroup中所有的线程中断标记为true\n>boolean\tisDaemon()\n>boolean\tisDestroyed()  //判断当前group是否被销毁\n>void\tlist() //打印当前group中的信息去标准输入流\n>boolean\tparentOf(ThreadGroup g)\n>void\tsetDaemon(boolean daemon)  //改变当前group中的线程为daemon线程\n>void\tsetMaxPriority(int pri)  //设置当前group的权限最大值\n>int\t    getMaxPriority() //返回当前ThreadGroup的最大权限\n>\n>void\tuncaughtException(Thread t, Throwable e)\n>```\n>\n>### 创建ThreadGroup\n>\n>简单demo\n>\n>```\n>  //创建ThreadGroup\n>    public static void createThreadGroup() {\n>        //获取当前的ThreadGroup\n>        ThreadGroup currentGroup = Thread.currentThread().getThreadGroup();\n>\n>        //定义一个新的ThreadGroup，默认panrent为当前线程所对应的group\n>        ThreadGroup group1 = new ThreadGroup(\"Group1\");\n>\n>        //判断当前线程对应的ThreadGroup是否是group1的parentgroup\n>        System.out.println(currentGroup == group1.getParent());\n>\n>        //定义一个新的group2，其parent为group1\n>        ThreadGroup group2 = new ThreadGroup(group1, \"group2\");\n>\n>        //使用ThreadGroup自带的API判断group1是否是group2的parent\n>        System.out.println(group1.parentOf(group2));\n>    }\n>```\n>\n>运行结果\n>\n>```\n>true\n>true\n>```\n>\n>结果分析：说明如果没有指定创建ThreadGroup的parent，则默认为当前线程所对应的ThreadGroup，另外需要注意的是，ThreadGroup是树形的分布，这课树的根是system，也就是在类加载时就建立好的，接着在main线程启动时，创建了一个以main为名的ThreadGroup。\n>\n>### 使用enumerate 获取当前thread\n>\n>```\n>    //使用enumerate 复制Thread\n>    public static void enumerateThread() throws InterruptedException {\n>        //创建一个新的ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group\");\n>\n>        //创建线程，设置ThreadGroup\n>        Thread thread = new Thread(group, () -> {\n>            while (true) {\n>                try {\n>                    TimeUnit.SECONDS.sleep(1);\n>                } catch (Exception e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        });\n>\n>        thread.start();\n>        TimeUnit.MILLISECONDS.sleep(2);\n>\n>        //得到当前线程对应的ThreadGroup\n>        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();\n>\n>        //创建存储当前ThreadGroup对应线程的数组\n>        Thread[] list = new Thread[mainGroup.activeCount()];\n>\n>        int recuresize = mainGroup.enumerate(list);\n>        System.out.println(recuresize);\n>\n>        recuresize = mainGroup.enumerate(list, false);\n>        System.out.println(recuresize);\n>    }\n>```\n>\n>运行结果:\n>\n>```\n>2\n>1\n>```\n>\n>### 基本API的使用\n>\n>```\n> //一些基本API的操作\n>    public static void testAPI() throws InterruptedException {\n>        //创建一个ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group1\");\n>\n>        //创建线程，设置ThreadGroup\n>        Thread thread = new Thread(group, () -> {\n>            while (true) {\n>                try {\n>                    TimeUnit.SECONDS.sleep(2);\n>                } catch (Exception e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        });\n>        thread.setDaemon(true);\n>        thread.start();\n>\n>\n>        //确保thread开启\n>        TimeUnit.MILLISECONDS.sleep(2);\n>        ThreadGroup mainThreadGroup = Thread.currentThread().getThreadGroup();\n>        System.out.println(\"activeCount = \" + mainThreadGroup.activeCount());\n>        System.out.println(\"activeGroupCount=\" + mainThreadGroup.activeGroupCount());\n>        System.out.println(\"getMaxPriority = \" + mainThreadGroup.getMaxPriority());\n>        System.out.println(\"getName = \" + mainThreadGroup.getName());\n>        System.out.println(\"getParent = \" + mainThreadGroup.getName());\n>        mainThreadGroup.list();\n>        System.out.println(\"------------------------------------\");\n>        System.out.println(\"parentOf = \" + mainThreadGroup.parentOf(group));\n>        System.out.println(\"parentOf = \" + mainThreadGroup.parentOf(mainThreadGroup));\n>\n>    }\n>```\n>\n>运行结果：\n>\n>```\n>activeCount = 2\n>activeGroupCount=1\n>getMaxPriority = 10\n>getName = main\n>getParent = main\n>java.lang.ThreadGroup[name=main,maxpri=10]\n>    Thread[main,5,main]\n>    java.lang.ThreadGroup[name=group1,maxpri=10]\n>        Thread[Thread-0,5,group1]\n>------------------------------------\n>parentOf = true\n>parentOf = true\n>```\n>\n>最后需要注意的是，group的parent也可以是自己本身，这不知道是不是bug。\n>\n>### setMaxPriority\n>\n>```\n>//线程组优先级设置\n>    public static void threadGroupPriority() {\n>        //创建一个ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group1\");\n>\n>        //创建线程，设置ThreadGroup\n>        Thread thread = new Thread(group, () -> {\n>            while (true) {\n>                try {\n>                    TimeUnit.SECONDS.sleep(2);\n>                } catch (Exception e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        });\n>        thread.setDaemon(true);\n>        thread.start();\n>        System.out.println(\"group getMaxPriority()=\" + group.getMaxPriority());\n>        System.out.println(\"thread.getPriority()=\" + thread.getPriority());\n>\n>        //改变group的最大优先级\n>        group.setMaxPriority(3);\n>        System.out.println(\"group getMaxPriority()=\" + group.getMaxPriority());\n>        System.out.println(\"thread.getPriority()=\" + thread.getPriority());\n>    }\n>```\n>\n>运行结果\n>\n>```\n>group getMaxPriority()=10\n>thread.getPriority()=5\n>group getMaxPriority()=3\n>thread.getPriority()=5\n>```\n>\n>在ThreadGroup中线程的优先级是不能大于ThreadGroup设置的最大优先级，但是上面的结果显示线程的优先级大于了ThreadGroup的最大优先级。这是因为，线程在添加时优先级是不大于ThreadGroup的最大优先级，但是后来ThreadGroup修改了最大优先级，但由于线程的优先级已经设置好了，ThreadGroup将不能去更改这个优先级，所以就存在线程组中有大于线程组最大优先级的线程。但是在这之后添加的线程就不会大于线程组的优先级。\n>\n>### ThreadGroup的Damon设置和destory\n>\n>```\n>//守护ThreadGroup 和destory\n>    public static void threadGroupDaemon() throws InterruptedException {\n>        //创建一个ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group1\");\n>\n>        //创建线程，设置ThreadGroup\n>        new Thread(group, () -> {\n>\n>            try {\n>                TimeUnit.SECONDS.sleep(1);\n>            } catch (Exception e) {\n>                e.printStackTrace();\n>            }\n>\n>        }, \"group1-thread\").start();\n>        //创建一个ThreadGroup\n>        ThreadGroup group2 = new ThreadGroup(\"group2\");\n>\n>        //创建线程，设置ThreadGroup\n>        new Thread(group2, () -> {\n>\n>            try {\n>                TimeUnit.SECONDS.sleep(1);\n>            } catch (Exception e) {\n>                e.printStackTrace();\n>            }\n>\n>        }, \"group2-thread\").start();\n>\n>        //设置group2为daemon为true\n>        group2.setDaemon(true);\n>        TimeUnit.SECONDS.sleep(3);\n>        System.out.println(group.isDestroyed());\n>        System.out.println(group2.isDestroyed());\n>    }\n>```\n>\n>运行结果:\n>\n>```\n>false\n>true\n>```\n>\n>当线程组设置为daemon之后，只要线程组中不存在活跃的线程，线程组则自动destory。但是如果线程组没有设置daemon为true，即使线程组中没有活跃的线程，也不会自动destory。\n>\n>注意一点是：destory只有当线程组和子线程组中没有活跃的线程才能调用，否则抛出异常。\n>\n>\n>\n>\n>\n>","slug":"threads/java多线程系列 07 ThreadGroup","published":1,"updated":"2019-01-04T01:48:59.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovsb002j9q1u95ohgy15","content":"<h1 id=\"java多线程系列之07-ThreadGroup\"><a href=\"#java多线程系列之07-ThreadGroup\" class=\"headerlink\" title=\"java多线程系列之07 ThreadGroup\"></a>java多线程系列之07 ThreadGroup</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>ThreadGroup 介绍</li>\n<li>基本API的使用与介绍</li>\n</ol>\n</blockquote>\n<h3 id=\"1-ThreadGroup-介绍\"><a href=\"#1-ThreadGroup-介绍\" class=\"headerlink\" title=\"1. ThreadGroup 介绍\"></a>1. ThreadGroup 介绍</h3><blockquote>\n<p>在java的多线程处理中有线程组ThreadGroup的概念，ThreadGroup是为了方便线程管理出现了，可以统一设定线程组的一些属性，比如setDaemon，设置未处理异常的处理方法，设置统一的安全策略等等；也可以通过线程组方便的获得线程的一些信息。</p>\n<p>每一个ThreadGroup都可以包含一组的子线程和一组子线程组，在一个进程中线程组是以树形的方式存在，通常情况下根线程组是system线程组。system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。</p>\n</blockquote>\n<h3 id=\"2-基本API介绍\"><a href=\"#2-基本API介绍\" class=\"headerlink\" title=\"2. 基本API介绍\"></a>2. 基本API介绍</h3><blockquote>\n<pre><code>// 构造函数 \nThreadGroup(String name)  \nThreadGroup(ThreadGroup parent, String name)\n\n// 基本API\nint    activeCount()  //返回一个预估的当前TreadGroup和子group中存活线程的数量\nint    activeGroupCount() //返回一个预估的当前TreadGroup所包含的group中存活ThreadGroup的数量\nvoid    checkAccess() //判断当前运行的线程是否有权限修改此group\nvoid    destroy()   //销毁当前group和子group\nint    enumerate(Thread[] list) //拷贝当前group和子group中的没有dead的线程\nint    enumerate(Thread[] list,boolean recurs)//和上一个的区别就是是否需要拷贝子group中的线程\nint    enumerate(ThreadGroup[] list)  //拷贝当前group和子group中ThreadGroup\nint    enumerate(ThreadGroup[] list, boolean recurse) //是否需要子Group\nString    getName()\nThreadGroup    getParent()\nvoid    interrupt()  //设置当前ThreadGroup中所有的线程中断标记为true\nboolean    isDaemon()\nboolean    isDestroyed()  //判断当前group是否被销毁\nvoid    list() //打印当前group中的信息去标准输入流\nboolean    parentOf(ThreadGroup g)\nvoid    setDaemon(boolean daemon)  //改变当前group中的线程为daemon线程\nvoid    setMaxPriority(int pri)  //设置当前group的权限最大值\nint        getMaxPriority() //返回当前ThreadGroup的最大权限\n\nvoid    uncaughtException(Thread t, Throwable e)\n</code></pre><h3 id=\"创建ThreadGroup\"><a href=\"#创建ThreadGroup\" class=\"headerlink\" title=\"创建ThreadGroup\"></a>创建ThreadGroup</h3><p>简单demo</p>\n<pre><code> //创建ThreadGroup\n   public static void createThreadGroup() {\n       //获取当前的ThreadGroup\n       ThreadGroup currentGroup = Thread.currentThread().getThreadGroup();\n\n       //定义一个新的ThreadGroup，默认panrent为当前线程所对应的group\n       ThreadGroup group1 = new ThreadGroup(&quot;Group1&quot;);\n\n       //判断当前线程对应的ThreadGroup是否是group1的parentgroup\n       System.out.println(currentGroup == group1.getParent());\n\n       //定义一个新的group2，其parent为group1\n       ThreadGroup group2 = new ThreadGroup(group1, &quot;group2&quot;);\n\n       //使用ThreadGroup自带的API判断group1是否是group2的parent\n       System.out.println(group1.parentOf(group2));\n   }\n</code></pre><p>运行结果</p>\n<pre><code>true\ntrue\n</code></pre><p>结果分析：说明如果没有指定创建ThreadGroup的parent，则默认为当前线程所对应的ThreadGroup，另外需要注意的是，ThreadGroup是树形的分布，这课树的根是system，也就是在类加载时就建立好的，接着在main线程启动时，创建了一个以main为名的ThreadGroup。</p>\n<h3 id=\"使用enumerate-获取当前thread\"><a href=\"#使用enumerate-获取当前thread\" class=\"headerlink\" title=\"使用enumerate 获取当前thread\"></a>使用enumerate 获取当前thread</h3><pre><code>   //使用enumerate 复制Thread\n   public static void enumerateThread() throws InterruptedException {\n       //创建一个新的ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group&quot;);\n\n       //创建线程，设置ThreadGroup\n       Thread thread = new Thread(group, () -&gt; {\n           while (true) {\n               try {\n                   TimeUnit.SECONDS.sleep(1);\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n           }\n       });\n\n       thread.start();\n       TimeUnit.MILLISECONDS.sleep(2);\n\n       //得到当前线程对应的ThreadGroup\n       ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();\n\n       //创建存储当前ThreadGroup对应线程的数组\n       Thread[] list = new Thread[mainGroup.activeCount()];\n\n       int recuresize = mainGroup.enumerate(list);\n       System.out.println(recuresize);\n\n       recuresize = mainGroup.enumerate(list, false);\n       System.out.println(recuresize);\n   }\n</code></pre><p>运行结果:</p>\n<pre><code>2\n1\n</code></pre><h3 id=\"基本API的使用\"><a href=\"#基本API的使用\" class=\"headerlink\" title=\"基本API的使用\"></a>基本API的使用</h3><pre><code>//一些基本API的操作\n   public static void testAPI() throws InterruptedException {\n       //创建一个ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group1&quot;);\n\n       //创建线程，设置ThreadGroup\n       Thread thread = new Thread(group, () -&gt; {\n           while (true) {\n               try {\n                   TimeUnit.SECONDS.sleep(2);\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n           }\n       });\n       thread.setDaemon(true);\n       thread.start();\n\n\n       //确保thread开启\n       TimeUnit.MILLISECONDS.sleep(2);\n       ThreadGroup mainThreadGroup = Thread.currentThread().getThreadGroup();\n       System.out.println(&quot;activeCount = &quot; + mainThreadGroup.activeCount());\n       System.out.println(&quot;activeGroupCount=&quot; + mainThreadGroup.activeGroupCount());\n       System.out.println(&quot;getMaxPriority = &quot; + mainThreadGroup.getMaxPriority());\n       System.out.println(&quot;getName = &quot; + mainThreadGroup.getName());\n       System.out.println(&quot;getParent = &quot; + mainThreadGroup.getName());\n       mainThreadGroup.list();\n       System.out.println(&quot;------------------------------------&quot;);\n       System.out.println(&quot;parentOf = &quot; + mainThreadGroup.parentOf(group));\n       System.out.println(&quot;parentOf = &quot; + mainThreadGroup.parentOf(mainThreadGroup));\n\n   }\n</code></pre><p>运行结果：</p>\n<pre><code>activeCount = 2\nactiveGroupCount=1\ngetMaxPriority = 10\ngetName = main\ngetParent = main\njava.lang.ThreadGroup[name=main,maxpri=10]\n   Thread[main,5,main]\n   java.lang.ThreadGroup[name=group1,maxpri=10]\n       Thread[Thread-0,5,group1]\n------------------------------------\nparentOf = true\nparentOf = true\n</code></pre><p>最后需要注意的是，group的parent也可以是自己本身，这不知道是不是bug。</p>\n<h3 id=\"setMaxPriority\"><a href=\"#setMaxPriority\" class=\"headerlink\" title=\"setMaxPriority\"></a>setMaxPriority</h3><pre><code>//线程组优先级设置\n   public static void threadGroupPriority() {\n       //创建一个ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group1&quot;);\n\n       //创建线程，设置ThreadGroup\n       Thread thread = new Thread(group, () -&gt; {\n           while (true) {\n               try {\n                   TimeUnit.SECONDS.sleep(2);\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n           }\n       });\n       thread.setDaemon(true);\n       thread.start();\n       System.out.println(&quot;group getMaxPriority()=&quot; + group.getMaxPriority());\n       System.out.println(&quot;thread.getPriority()=&quot; + thread.getPriority());\n\n       //改变group的最大优先级\n       group.setMaxPriority(3);\n       System.out.println(&quot;group getMaxPriority()=&quot; + group.getMaxPriority());\n       System.out.println(&quot;thread.getPriority()=&quot; + thread.getPriority());\n   }\n</code></pre><p>运行结果</p>\n<pre><code>group getMaxPriority()=10\nthread.getPriority()=5\ngroup getMaxPriority()=3\nthread.getPriority()=5\n</code></pre><p>在ThreadGroup中线程的优先级是不能大于ThreadGroup设置的最大优先级，但是上面的结果显示线程的优先级大于了ThreadGroup的最大优先级。这是因为，线程在添加时优先级是不大于ThreadGroup的最大优先级，但是后来ThreadGroup修改了最大优先级，但由于线程的优先级已经设置好了，ThreadGroup将不能去更改这个优先级，所以就存在线程组中有大于线程组最大优先级的线程。但是在这之后添加的线程就不会大于线程组的优先级。</p>\n<h3 id=\"ThreadGroup的Damon设置和destory\"><a href=\"#ThreadGroup的Damon设置和destory\" class=\"headerlink\" title=\"ThreadGroup的Damon设置和destory\"></a>ThreadGroup的Damon设置和destory</h3><pre><code>//守护ThreadGroup 和destory\n   public static void threadGroupDaemon() throws InterruptedException {\n       //创建一个ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group1&quot;);\n\n       //创建线程，设置ThreadGroup\n       new Thread(group, () -&gt; {\n\n           try {\n               TimeUnit.SECONDS.sleep(1);\n           } catch (Exception e) {\n               e.printStackTrace();\n           }\n\n       }, &quot;group1-thread&quot;).start();\n       //创建一个ThreadGroup\n       ThreadGroup group2 = new ThreadGroup(&quot;group2&quot;);\n\n       //创建线程，设置ThreadGroup\n       new Thread(group2, () -&gt; {\n\n           try {\n               TimeUnit.SECONDS.sleep(1);\n           } catch (Exception e) {\n               e.printStackTrace();\n           }\n\n       }, &quot;group2-thread&quot;).start();\n\n       //设置group2为daemon为true\n       group2.setDaemon(true);\n       TimeUnit.SECONDS.sleep(3);\n       System.out.println(group.isDestroyed());\n       System.out.println(group2.isDestroyed());\n   }\n</code></pre><p>运行结果:</p>\n<pre><code>false\ntrue\n</code></pre><p>当线程组设置为daemon之后，只要线程组中不存在活跃的线程，线程组则自动destory。但是如果线程组没有设置daemon为true，即使线程组中没有活跃的线程，也不会自动destory。</p>\n<p>注意一点是：destory只有当线程组和子线程组中没有活跃的线程才能调用，否则抛出异常。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列之07-ThreadGroup\"><a href=\"#java多线程系列之07-ThreadGroup\" class=\"headerlink\" title=\"java多线程系列之07 ThreadGroup\"></a>java多线程系列之07 ThreadGroup</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>ThreadGroup 介绍</li>\n<li>基本API的使用与介绍</li>\n</ol>\n</blockquote>\n<h3 id=\"1-ThreadGroup-介绍\"><a href=\"#1-ThreadGroup-介绍\" class=\"headerlink\" title=\"1. ThreadGroup 介绍\"></a>1. ThreadGroup 介绍</h3><blockquote>\n<p>在java的多线程处理中有线程组ThreadGroup的概念，ThreadGroup是为了方便线程管理出现了，可以统一设定线程组的一些属性，比如setDaemon，设置未处理异常的处理方法，设置统一的安全策略等等；也可以通过线程组方便的获得线程的一些信息。</p>\n<p>每一个ThreadGroup都可以包含一组的子线程和一组子线程组，在一个进程中线程组是以树形的方式存在，通常情况下根线程组是system线程组。system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。</p>\n</blockquote>\n<h3 id=\"2-基本API介绍\"><a href=\"#2-基本API介绍\" class=\"headerlink\" title=\"2. 基本API介绍\"></a>2. 基本API介绍</h3><blockquote>\n<pre><code>// 构造函数 \nThreadGroup(String name)  \nThreadGroup(ThreadGroup parent, String name)\n\n// 基本API\nint    activeCount()  //返回一个预估的当前TreadGroup和子group中存活线程的数量\nint    activeGroupCount() //返回一个预估的当前TreadGroup所包含的group中存活ThreadGroup的数量\nvoid    checkAccess() //判断当前运行的线程是否有权限修改此group\nvoid    destroy()   //销毁当前group和子group\nint    enumerate(Thread[] list) //拷贝当前group和子group中的没有dead的线程\nint    enumerate(Thread[] list,boolean recurs)//和上一个的区别就是是否需要拷贝子group中的线程\nint    enumerate(ThreadGroup[] list)  //拷贝当前group和子group中ThreadGroup\nint    enumerate(ThreadGroup[] list, boolean recurse) //是否需要子Group\nString    getName()\nThreadGroup    getParent()\nvoid    interrupt()  //设置当前ThreadGroup中所有的线程中断标记为true\nboolean    isDaemon()\nboolean    isDestroyed()  //判断当前group是否被销毁\nvoid    list() //打印当前group中的信息去标准输入流\nboolean    parentOf(ThreadGroup g)\nvoid    setDaemon(boolean daemon)  //改变当前group中的线程为daemon线程\nvoid    setMaxPriority(int pri)  //设置当前group的权限最大值\nint        getMaxPriority() //返回当前ThreadGroup的最大权限\n\nvoid    uncaughtException(Thread t, Throwable e)\n</code></pre><h3 id=\"创建ThreadGroup\"><a href=\"#创建ThreadGroup\" class=\"headerlink\" title=\"创建ThreadGroup\"></a>创建ThreadGroup</h3><p>简单demo</p>\n<pre><code> //创建ThreadGroup\n   public static void createThreadGroup() {\n       //获取当前的ThreadGroup\n       ThreadGroup currentGroup = Thread.currentThread().getThreadGroup();\n\n       //定义一个新的ThreadGroup，默认panrent为当前线程所对应的group\n       ThreadGroup group1 = new ThreadGroup(&quot;Group1&quot;);\n\n       //判断当前线程对应的ThreadGroup是否是group1的parentgroup\n       System.out.println(currentGroup == group1.getParent());\n\n       //定义一个新的group2，其parent为group1\n       ThreadGroup group2 = new ThreadGroup(group1, &quot;group2&quot;);\n\n       //使用ThreadGroup自带的API判断group1是否是group2的parent\n       System.out.println(group1.parentOf(group2));\n   }\n</code></pre><p>运行结果</p>\n<pre><code>true\ntrue\n</code></pre><p>结果分析：说明如果没有指定创建ThreadGroup的parent，则默认为当前线程所对应的ThreadGroup，另外需要注意的是，ThreadGroup是树形的分布，这课树的根是system，也就是在类加载时就建立好的，接着在main线程启动时，创建了一个以main为名的ThreadGroup。</p>\n<h3 id=\"使用enumerate-获取当前thread\"><a href=\"#使用enumerate-获取当前thread\" class=\"headerlink\" title=\"使用enumerate 获取当前thread\"></a>使用enumerate 获取当前thread</h3><pre><code>   //使用enumerate 复制Thread\n   public static void enumerateThread() throws InterruptedException {\n       //创建一个新的ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group&quot;);\n\n       //创建线程，设置ThreadGroup\n       Thread thread = new Thread(group, () -&gt; {\n           while (true) {\n               try {\n                   TimeUnit.SECONDS.sleep(1);\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n           }\n       });\n\n       thread.start();\n       TimeUnit.MILLISECONDS.sleep(2);\n\n       //得到当前线程对应的ThreadGroup\n       ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();\n\n       //创建存储当前ThreadGroup对应线程的数组\n       Thread[] list = new Thread[mainGroup.activeCount()];\n\n       int recuresize = mainGroup.enumerate(list);\n       System.out.println(recuresize);\n\n       recuresize = mainGroup.enumerate(list, false);\n       System.out.println(recuresize);\n   }\n</code></pre><p>运行结果:</p>\n<pre><code>2\n1\n</code></pre><h3 id=\"基本API的使用\"><a href=\"#基本API的使用\" class=\"headerlink\" title=\"基本API的使用\"></a>基本API的使用</h3><pre><code>//一些基本API的操作\n   public static void testAPI() throws InterruptedException {\n       //创建一个ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group1&quot;);\n\n       //创建线程，设置ThreadGroup\n       Thread thread = new Thread(group, () -&gt; {\n           while (true) {\n               try {\n                   TimeUnit.SECONDS.sleep(2);\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n           }\n       });\n       thread.setDaemon(true);\n       thread.start();\n\n\n       //确保thread开启\n       TimeUnit.MILLISECONDS.sleep(2);\n       ThreadGroup mainThreadGroup = Thread.currentThread().getThreadGroup();\n       System.out.println(&quot;activeCount = &quot; + mainThreadGroup.activeCount());\n       System.out.println(&quot;activeGroupCount=&quot; + mainThreadGroup.activeGroupCount());\n       System.out.println(&quot;getMaxPriority = &quot; + mainThreadGroup.getMaxPriority());\n       System.out.println(&quot;getName = &quot; + mainThreadGroup.getName());\n       System.out.println(&quot;getParent = &quot; + mainThreadGroup.getName());\n       mainThreadGroup.list();\n       System.out.println(&quot;------------------------------------&quot;);\n       System.out.println(&quot;parentOf = &quot; + mainThreadGroup.parentOf(group));\n       System.out.println(&quot;parentOf = &quot; + mainThreadGroup.parentOf(mainThreadGroup));\n\n   }\n</code></pre><p>运行结果：</p>\n<pre><code>activeCount = 2\nactiveGroupCount=1\ngetMaxPriority = 10\ngetName = main\ngetParent = main\njava.lang.ThreadGroup[name=main,maxpri=10]\n   Thread[main,5,main]\n   java.lang.ThreadGroup[name=group1,maxpri=10]\n       Thread[Thread-0,5,group1]\n------------------------------------\nparentOf = true\nparentOf = true\n</code></pre><p>最后需要注意的是，group的parent也可以是自己本身，这不知道是不是bug。</p>\n<h3 id=\"setMaxPriority\"><a href=\"#setMaxPriority\" class=\"headerlink\" title=\"setMaxPriority\"></a>setMaxPriority</h3><pre><code>//线程组优先级设置\n   public static void threadGroupPriority() {\n       //创建一个ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group1&quot;);\n\n       //创建线程，设置ThreadGroup\n       Thread thread = new Thread(group, () -&gt; {\n           while (true) {\n               try {\n                   TimeUnit.SECONDS.sleep(2);\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n           }\n       });\n       thread.setDaemon(true);\n       thread.start();\n       System.out.println(&quot;group getMaxPriority()=&quot; + group.getMaxPriority());\n       System.out.println(&quot;thread.getPriority()=&quot; + thread.getPriority());\n\n       //改变group的最大优先级\n       group.setMaxPriority(3);\n       System.out.println(&quot;group getMaxPriority()=&quot; + group.getMaxPriority());\n       System.out.println(&quot;thread.getPriority()=&quot; + thread.getPriority());\n   }\n</code></pre><p>运行结果</p>\n<pre><code>group getMaxPriority()=10\nthread.getPriority()=5\ngroup getMaxPriority()=3\nthread.getPriority()=5\n</code></pre><p>在ThreadGroup中线程的优先级是不能大于ThreadGroup设置的最大优先级，但是上面的结果显示线程的优先级大于了ThreadGroup的最大优先级。这是因为，线程在添加时优先级是不大于ThreadGroup的最大优先级，但是后来ThreadGroup修改了最大优先级，但由于线程的优先级已经设置好了，ThreadGroup将不能去更改这个优先级，所以就存在线程组中有大于线程组最大优先级的线程。但是在这之后添加的线程就不会大于线程组的优先级。</p>\n<h3 id=\"ThreadGroup的Damon设置和destory\"><a href=\"#ThreadGroup的Damon设置和destory\" class=\"headerlink\" title=\"ThreadGroup的Damon设置和destory\"></a>ThreadGroup的Damon设置和destory</h3><pre><code>//守护ThreadGroup 和destory\n   public static void threadGroupDaemon() throws InterruptedException {\n       //创建一个ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group1&quot;);\n\n       //创建线程，设置ThreadGroup\n       new Thread(group, () -&gt; {\n\n           try {\n               TimeUnit.SECONDS.sleep(1);\n           } catch (Exception e) {\n               e.printStackTrace();\n           }\n\n       }, &quot;group1-thread&quot;).start();\n       //创建一个ThreadGroup\n       ThreadGroup group2 = new ThreadGroup(&quot;group2&quot;);\n\n       //创建线程，设置ThreadGroup\n       new Thread(group2, () -&gt; {\n\n           try {\n               TimeUnit.SECONDS.sleep(1);\n           } catch (Exception e) {\n               e.printStackTrace();\n           }\n\n       }, &quot;group2-thread&quot;).start();\n\n       //设置group2为daemon为true\n       group2.setDaemon(true);\n       TimeUnit.SECONDS.sleep(3);\n       System.out.println(group.isDestroyed());\n       System.out.println(group2.isDestroyed());\n   }\n</code></pre><p>运行结果:</p>\n<pre><code>false\ntrue\n</code></pre><p>当线程组设置为daemon之后，只要线程组中不存在活跃的线程，线程组则自动destory。但是如果线程组没有设置daemon为true，即使线程组中没有活跃的线程，也不会自动destory。</p>\n<p>注意一点是：destory只有当线程组和子线程组中没有活跃的线程才能调用，否则抛出异常。</p>\n</blockquote>\n"},{"abbrlink":36,"title":"Java NIO之浅谈内存映射文件原理与DirectMemory","date":"2019-01-14T00:40:08.000Z","_content":"# Java NIO之浅谈内存映射文件原理与DirectMemory\n\n### 概述\n\n1. 传统文件IO操作原理\n2. 什么是内存映射\n3. NIO中内存映射\n4. 直接缓冲区（DirectMemory）\n\n学习了很久的NIO，但是一直对NIO中内存映射和DirectMemory有很多的不理解，恰好最近在读《深入理解操作系统》，对其中一些不理解的地点有了自己的一些感悟。此篇文章将结合操作系统谈谈自己对NIO中的内存映射和DirectMemory的理解。\n\n<!-- more -->\n\n### 1.传统文件IO操作原理\n\n在传统的文件IO操作中，我们都是调用操作系统提供的底层标准IO系统调用函数  read()、write() ，此时调用此函数的进程（在JAVA中即java进程）会从用户态切换到内核态，然后OS的内核代码负责将相应的文件数据读取到内核的IO缓冲区，然后再把数据从内核IO缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。至于为什么要多此一举搞一个内核IO缓冲区把原本只需一次拷贝数据的事情搞成需要2次数据拷贝呢？ 我想学过操作系统或者计算机系统结构的人都知道，这么做是为了减少磁盘的IO操作，为了提高性能而考虑的，因为我们的程序访问一般都带有局部性，也就是所谓的局部性原理，在这里主要是指的空间局部性，即我们访问了文件的某一段数据，那么接下去很可能还会访问接下去的一段数据，由于磁盘IO操作的速度比直接访问内存慢了好几个数量级，所以OS根据局部性原理会在一次 read()系统调用过程中预读更多的文件数据缓存在内核IO缓冲区中，当继续访问的文件数据在缓冲区中时便直接拷贝数据到进程私有空间，避免了再次的低效率磁盘IO操作。在JAVA中当我们采用IO包下的文件操作流，如：  \n\n```\n   FileInputStream in = new FileInputStream(\"D:\\\\java.txt\");\n   in.read();\n```\n\n   JAVA虚拟机内部便会调用OS底层的 read()系统调用完成操作，如上所述，在第二次调用 in.read()的时候可能就是从内核缓冲区直接返回数据了（可能还有经过 native堆做一次中转，因为这些函数都被声明为 native，即本地平台相关，所以可能在C代码中有做一次中转，如 win32中是通过 C代码从OS读取数据，然后再传给JVM内存）。既然如此，JAVA的IO包中为啥还要提供一个 BufferedInputStream 类来作为缓冲区呢。关键在于四个字，\"系统调用\"！当读取OS内核缓冲区数据的时候，便发起了一次系统调用操作（通过native的C函数调用），而系统调用的代价相对来说是比较高的，涉及到进程用户态和内核态的上下文切换等一系列操作，所以我们经常采用如下的包装：\n\n```java\n   FileInputStream in = new FileInputStream(\"D:\\\\java.txt\"); \n   BufferedInputStream buf_in = new BufferedInputStream(in);\n   buf_in.read();\n```\n\n  这样一来，我们每一次 buf_in.read() 时候，BufferedInputStream 会根据情况自动为我们预读更多的字节数据到它自己维护的一个内部字节数组缓冲区中，这样我们便可以减少系统调用次数，从而达到其缓冲区的目的。所以要明确的一点是 BufferedInputStream 的作用不是减少磁盘IO操作次数（这个OS已经帮我们做了），而是通过减少系统调用次数来提高性能的。同理 BufferedOuputStream , BufferedReader/Writer 也是一样的。在 C语言的函数库中也有类似的实现，如 fread()，这个函数就是 C语言中的缓冲IO，作用与BufferedInputStream()相同.\n\n​    这里简单的引用下JDK8 中 BufferedInputStream 的源码验证下：\n\n```java\npublic\nclass BufferedInputStream extends FilterInputStream {\n\t\n    /**\n    * 只列出了重要的部分\n    */\n\n    protected volatile byte buf[];\n\n    public synchronized int read() throws IOException {\n        if (pos >= count) {\n            fill();\n            if (pos >= count)\n                return -1;\n        }\n        return getBufIfOpen()[pos++] & 0xff;\n    }\n\n  \n\n```\n\n\n\n   我们可以看到，BufferedInputStream 内部维护着一个 字节数组 byte[] buf 来实现缓冲区的功能，我们调用的  buf_in.read() 方法在返回数据之前有做一个 if 判断，如果 buf 数组的当前索引不在有效的索引范围之内，即 if 条件成立， buf 字段维护的缓冲区已经不够了，这时候会调用 内部的 fill() 方法进行填充，而fill()会预读更多的数据到 buf 数组缓冲区中去，然后再返回当前字节数据，如果 if 条件不成立便直接从 buf缓冲区数组返回数据了。其中getBufIfOpen()返回的就是 buf字段的引用。顺便说下，源码中的 buf 字段声明为  protected volatile byte buf[];  主要是为了通过 volatile 关键字保证 buf数组在多线程并发环境中的内存可见性.\n\n### 2. 什么是内存映射\n\nLinux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。虚拟内存区域可以映射到俩种类型的对象一种：\n\n1. linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分。并且磁盘文件区被分成页大小的片，每一片包含一个虚拟页面的初始内容。此时并没有拷贝数据到内存中去，而是当进程代码第一次引用这段代码内的虚拟地址时，触发了缺页异常，这时候OS根据映射关系直接将文件的相关部分数据拷贝到进程的用户私有空间中去，当有操作第N页数据的时候重复这样的OS页面调度程序操作。**现在终于找出内存映射效率高的原因，原来内存映射文件的效率比标准IO高的重要原因就是因为少了把数据拷贝到OS内核缓冲区这一步（可能还少了native堆中转这一步）。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。**\n2. 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件时有内核穿件的，包含的去不是二进制零。CPU第一次引用这样的一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，经这个页面标记为是驻留在内存中的。注意在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制零的页。\n\n**注：如果你对虚拟内存不是很明白，推介你去看《深入理解操作系统》第九章**\n\n### 3.NIO中内存映射\n\n上面介绍了普通文件IO和内存映射，已经总结了为什么内存映射比普通的IO函数要快。现在来了解java中的内存映射，这也是NIO中的一个特性。其实java中的内存映射就是用c语言封装了一层，方便我们用java来调用，因此在了解概念的基础后，我们来看看如何使用。\n\n  java中提供了3种内存映射模式，即：只读(readonly)、读写(read_write)、专用(private) ，\n\n1. 对于只读模式来说，如果程序试图进行写操作，则会抛出ReadOnlyBufferException异常；\n2. 第二种的读写模式表明了通过内存映射文件的方式写或修改文件内容的话是会立刻反映到磁盘文件中去的，别的进程如果共享了同一个映射文件，那么也会立即看到变化！而不是像标准IO那样每个进程有各自的内核缓冲区，比如JAVA代码中，没有执行 IO输出流的 flush() 或者  close() 操作，那么对文件的修改不会更新到磁盘去，除非进程运行结束；\n3. 最后一种专用模式采用的是OS的“写时拷贝”原则，即在没有发生写操作的情况下，多个进程之间都是共享文件的同一块物理内存（进程各自的虚拟地址指向同一片物理地址），一旦某个进程进行写操作，那么将会把受影响的文件数据单独拷贝一份到进程的私有缓冲区中，不会反映到物理文件中去。\n\n   在JAVA NIO中可以很容易的创建一块内存映射区域，代码如下：\n\n```java\nFile file = new File(\"E:\\download\\office2007pro.chs.ISO\");\nFileInputStream in = new FileInputStream(file);\nFileChannel channel = in.getChannel();\n\nMappedByteBuffer buff = channel.map(FileChannel.MapMode.READ_ONLY, 0,channel.size());\n```\n\n  这里创建了一个只读模式的内存映射文件区域，接下来我就来测试下与普通NIO中的通道操作相比性能上的优势，先看如下代码：\n\n```java\npublic class MapperToBasic {\n\n    static final int BUFFER_SIZE = 1024;\n\n    String path =\"/Users/zhangke/code/java/tem/wechat.dmg\";\n\n    @Test\n    public void mapperTest() {\n        File file = new File(path);\n\n        FileInputStream in = null;\n        FileChannel channel = null;\n        try {\n            in = new FileInputStream(file);\n            channel = in.getChannel();\n            MappedByteBuffer buff = \n                channel.map(FileChannel.MapMode.READ_ONLY, \n                            0, channel.size());\n\n            byte[] b = new byte[1024];\n            int len = (int) file.length();\n\n            long begin = System.currentTimeMillis();\n\n            for (int offset = 0; offset < len; offset += \n                 1024) {\n\n                if (len - offset > BUFFER_SIZE) {\n                    buff.get(b);\n                } else {\n                    buff.get(new byte[len - offset]);\n                }\n            }\n\n            long end = System.currentTimeMillis();\n            System.out.println(\"time is:\" + (end - begin));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n\n            Optional.ofNullable(channel).ifPresent(c -> {\n                try {\n\n                    c.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void basiTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.flip();\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"time is:\" + (end - begin));\n        \n\n    }\n```\n\n上面第一个函数是测试NIO和普通IO读取文件大小为100M的文件内容的时间NIO读取完所有的内容大概花了30毫秒，普通IO大概花了160毫秒。文件越大，差距便越大。所以内存映射文件特别适合于对大文件的操作，JAVA中的限制是最大不得超过 Integer.MAX_VALUE，即2G左右，不过我们可以通过多次映射文件(channel.map)的不同部分来达到操作整个文件的目的。\n\n按照jdk文档的官方说法，内存映射文件属于JVM中的直接缓冲区，还可以通过 ByteBuffer.allocateDirect() ，即DirectMemory的方式来创建直接缓冲区。他们相比基础的 IO操作来说就是少了中间缓冲区的数据拷贝开销。同时他们属于JVM堆外内存，不受JVM堆内存大小的限制。\n\n### 4. 直接内存\n\nDirectMemory 默认的大小是等同于JVM最大堆，理论上说受限于进程的虚拟地址空间大小，比如 32位的windows上，每个进程有4G的虚拟空间除去 2G为OS内核保留外，再减去 JVM堆的最大值，剩余的才是DirectMemory大小。通过设置 JVM参数 -Xmx64M，即JVM最大堆为64M，然后执行以下程序可以证明DirectMemory不受JVM堆大小控制：\n\n```java\n public static void main(String[] args) {\t   \n   ByteBuffer.allocateDirect(1024*1024*100); // 100MB\n   }\n```\n我们设置了JVM堆 64M限制，然后在 直接内存上分配了 100MB空间，程序执行后直接报错：**Exception in thread \"main\" java.lang.OutOfMemoryError: Direct buffer memory**。接着我设置 -Xmx200M，程序正常结束。然后我修改配置： -Xmx64M  -XX:MaxDirectMemorySize=200M，程序正常结束。因此得出结论： 直接内存DirectMemory的大小默认为 -Xmx 的JVM堆的最大值，但是并不受其限制，而是由JVM参数 MaxDirectMemorySize单独控制。接下来我们来证明直接内存不是分配在JVM堆中。我们先执行以下程序，并设置 JVM参数       **-XX:+PrintGC** \n\n```\n public static void main(String[] args) {\t   \n\t for(int i=0;i<20000;i++) {\n            ByteBuffer.allocateDirect(1024*100);  //100K\n       }\n   }\n```\n\n  输出结果如下：\n\n     [GC 1371K->1328K(61312K), 0.0070033 secs]\n     [Full GC 1328K->1297K(61312K), 0.0329592 secs]\n     [GC 3029K->2481K(61312K), 0.0037401 secs]\n     [Full GC 2481K->2435K(61312K), 0.0102255 secs]\n\n   我们看到这里执行 GC的次数较少，但是触发了 两次 Full GC，原因在于直接内存不受 GC(新生代的Minor GC)影响，只有当执行老年代的 Full GC时候才会顺便回收直接内存！而直接内存是通过存储在JVM堆中的DirectByteBuffer对象来引用的，所以当众多的DirectByteBuffer对象从新生代被送入老年代后才触发了 full gc。\n\n  再看直接在JVM堆上分配内存区域的情况：\n\n ```java\n   public static void main(String[] args) {\t   \n\tfor(int i=0;i<10000;i++) {\n             ByteBuffer.allocate(1024*100);  //100K\n\t }\n   }\n ```\n\n  ByteBuffer.allocate 意味着直接在 JVM堆上分配内存，所以受 新生代的 Minor GC影响，输出如下：\n\n\n        [GC 16023K->224K(61312K), 0.0012432 secs]\n        [GC 16211K->192K(77376K), 0.0006917 secs]\n        [GC 32242K->176K(77376K), 0.0010613 secs]\n        [GC 32225K->224K(109504K), 0.0005539 secs]\n        [GC 64423K->192K(109504K), 0.0006151 secs]\n        [GC 64376K->192K(171392K), 0.0004968 secs]\n        [GC 128646K->204K(171392K), 0.0007423 secs]\n        [GC 128646K->204K(299968K), 0.0002067 secs]\n        [GC 257190K->204K(299968K), 0.0003862 secs]\n        [GC 257193K->204K(287680K), 0.0001718 secs]\n        [GC 245103K->204K(276480K), 0.0001994 secs]\n        [GC 233662K->204K(265344K), 0.0001828 secs]\n        [GC 222782K->172K(255232K), 0.0001998 secs]\n        [GC 212374K->172K(245120K), 0.0002217 secs]\n\n   可以看到，由于直接在 JVM堆上分配内存，所以触发了多次GC，且不会触及  Full GC，因为对象根本没机会进入老年代。\n\n在这里要来探讨一下内存映射和DirectMemory的内存回收问题。NIO中的DirectMemory和内存文件映射同属于直接缓冲区，但是前者和 -Xmx和-XX:MaxDirectMemorySize有关，而后者完全没有JVM参数可以影响和控制，这让我不禁怀疑两者的直接缓冲区是否相同，前者指的是 JAVA进程中的 native堆，即涉及底层平台如 win32的dll 部分，因为 C语言中的 malloc()分配的内存就属于 native堆，不属于 JVM堆，这也是DirectMemory能在一些场景中显著提高性能的原因，因为它避免了在 native堆和jvm堆之间数据的来回复制；而后者则是没有经过 native堆，是由 JAVA进程直接建立起 某一段虚拟地址空间和文件对象的关联映射关系，参见 Linux虚拟存储器图中的 “Memory mapped region for shared libraries”  区域，所以内存映射文件的区域并不在JVM GC的回收范围内，因为它本身就不属于堆区，卸载这部分区域只能通过系统调用 unmap()来实现 (Linux)中，而 JAVA API 只提供了 FileChannel.map 的形式创建内存映射区域，却没有提供对应的 unmap()。\n\n事实是由JVM帮助我们自动回收这部分内存，在定义这些类时，通过一个虚引用包裹这些创建的NIO对象，当JVM进行GC时检测指向这些内存映射或者直接内存的java对象是否被回收（java对象都是保存在堆上，只是对象中使用变量空间指向对外内存）。如果这些对象被回收，那么JVM就会自动的帮助我们回收这些堆外内存。具体参考：[堆外内存 之 DirectByteBuffer 详解](https://www.jianshu.com/p/007052ee3773)\n\n最后再试试通过 DirectMemory来操作前面 内存映射和基本通道操作的例子，来看看直接内存操作的话，程序的性能如何：\n\n```\n    @Test\n    public void directBufferTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n        \n        ByteBuffer buff = ByteBuffer.allocateDirect(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"time is:\" + (end - begin));\n        in.close();\n    }\n```\n\n\n\n程序输出为 130毫秒，看来比普通的NIO通道操作（160毫秒）来的快，但是比 mmap 内存映射的 30差距太多了，我想应该不至于吧，通过修改：\n\n```\nByteBuffer buff = ByteBuffer.allocateDirect(1024);  \n//将上面语句修改如下\nByteBuffer buff = ByteBuffer.allocateDirect((int)file.length())，\n```\n\n即一次性分配整个文件长度大小的堆外内存，最终输出为 78毫秒，由此可以得出两个结论：\n\n1. 堆外内存的分配耗时比较大.  \n\n2. 还是比mmap内存映射来得慢，都不要说通过mmap读取数据的时候还涉及缺页异常、页面调度的系统调用了。\n\n最后一点为 DirectMemory的内存只有在 JVM执行 full gc 的时候才会被回收，那么如果在其上分配过大的内存空间，那么也将出现 OutofMemoryError，即便 JVM 堆中的很多内存处于空闲状态。\n\n **补充下额外的一个知识点，关于 JVM堆大小的设置是不受限于物理内存，而是受限于虚拟内存空间大小，理论上来说是进程的虚拟地址空间大小，但是实际上我们的虚拟内存空间是有限制的，一般windows上默认在C盘，大小为物理内存的2倍左右。我做了个实验：我机子是 64位的win7，那么理论上说进程虚拟空间是几乎无限大，物理内存为4G，而我设置 -Xms5000M， 即在启动JAVA程序的时候一次性申请到超过物理内存大小的5000M内存，程序正常启动，而当我加到 -Xms8000M的时候就报OOM错误了，然后我修改增加 win7的虚拟内存，程序又正常启动了，说明 -Xms 受限于虚拟内存的大小。我设置-Xms5000M，即超过了4G物理内存，并在一个死循环中不断创建对象，并保证不会被GC回收。程序运行一会后整个电脑几乎死机状态，即卡住了，反映很慢很慢，推测是发生了系统颠簸，即频繁的页面调度置换导致，说明 -Xms -Xmx不是局限于物理内存的大小，而是综合虚拟内存了，JVM会根据电脑虚拟内存的设置来控制。**\n\n###  参考\n\n1. [JAVA NIO之浅谈内存映射文件原理与DirectMemory](https://blog.csdn.net/fcbayernmunchen/article/details/8635427)","source":"_posts/nio/JAVA NIO之浅谈内存映射文件原理与DirectBuffer.md","raw":"abbrlink: 36\ntitle: Java NIO之浅谈内存映射文件原理与DirectMemory\ndate: 2019-01-14 08:40:08\n---\n# Java NIO之浅谈内存映射文件原理与DirectMemory\n\n### 概述\n\n1. 传统文件IO操作原理\n2. 什么是内存映射\n3. NIO中内存映射\n4. 直接缓冲区（DirectMemory）\n\n学习了很久的NIO，但是一直对NIO中内存映射和DirectMemory有很多的不理解，恰好最近在读《深入理解操作系统》，对其中一些不理解的地点有了自己的一些感悟。此篇文章将结合操作系统谈谈自己对NIO中的内存映射和DirectMemory的理解。\n\n<!-- more -->\n\n### 1.传统文件IO操作原理\n\n在传统的文件IO操作中，我们都是调用操作系统提供的底层标准IO系统调用函数  read()、write() ，此时调用此函数的进程（在JAVA中即java进程）会从用户态切换到内核态，然后OS的内核代码负责将相应的文件数据读取到内核的IO缓冲区，然后再把数据从内核IO缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。至于为什么要多此一举搞一个内核IO缓冲区把原本只需一次拷贝数据的事情搞成需要2次数据拷贝呢？ 我想学过操作系统或者计算机系统结构的人都知道，这么做是为了减少磁盘的IO操作，为了提高性能而考虑的，因为我们的程序访问一般都带有局部性，也就是所谓的局部性原理，在这里主要是指的空间局部性，即我们访问了文件的某一段数据，那么接下去很可能还会访问接下去的一段数据，由于磁盘IO操作的速度比直接访问内存慢了好几个数量级，所以OS根据局部性原理会在一次 read()系统调用过程中预读更多的文件数据缓存在内核IO缓冲区中，当继续访问的文件数据在缓冲区中时便直接拷贝数据到进程私有空间，避免了再次的低效率磁盘IO操作。在JAVA中当我们采用IO包下的文件操作流，如：  \n\n```\n   FileInputStream in = new FileInputStream(\"D:\\\\java.txt\");\n   in.read();\n```\n\n   JAVA虚拟机内部便会调用OS底层的 read()系统调用完成操作，如上所述，在第二次调用 in.read()的时候可能就是从内核缓冲区直接返回数据了（可能还有经过 native堆做一次中转，因为这些函数都被声明为 native，即本地平台相关，所以可能在C代码中有做一次中转，如 win32中是通过 C代码从OS读取数据，然后再传给JVM内存）。既然如此，JAVA的IO包中为啥还要提供一个 BufferedInputStream 类来作为缓冲区呢。关键在于四个字，\"系统调用\"！当读取OS内核缓冲区数据的时候，便发起了一次系统调用操作（通过native的C函数调用），而系统调用的代价相对来说是比较高的，涉及到进程用户态和内核态的上下文切换等一系列操作，所以我们经常采用如下的包装：\n\n```java\n   FileInputStream in = new FileInputStream(\"D:\\\\java.txt\"); \n   BufferedInputStream buf_in = new BufferedInputStream(in);\n   buf_in.read();\n```\n\n  这样一来，我们每一次 buf_in.read() 时候，BufferedInputStream 会根据情况自动为我们预读更多的字节数据到它自己维护的一个内部字节数组缓冲区中，这样我们便可以减少系统调用次数，从而达到其缓冲区的目的。所以要明确的一点是 BufferedInputStream 的作用不是减少磁盘IO操作次数（这个OS已经帮我们做了），而是通过减少系统调用次数来提高性能的。同理 BufferedOuputStream , BufferedReader/Writer 也是一样的。在 C语言的函数库中也有类似的实现，如 fread()，这个函数就是 C语言中的缓冲IO，作用与BufferedInputStream()相同.\n\n​    这里简单的引用下JDK8 中 BufferedInputStream 的源码验证下：\n\n```java\npublic\nclass BufferedInputStream extends FilterInputStream {\n\t\n    /**\n    * 只列出了重要的部分\n    */\n\n    protected volatile byte buf[];\n\n    public synchronized int read() throws IOException {\n        if (pos >= count) {\n            fill();\n            if (pos >= count)\n                return -1;\n        }\n        return getBufIfOpen()[pos++] & 0xff;\n    }\n\n  \n\n```\n\n\n\n   我们可以看到，BufferedInputStream 内部维护着一个 字节数组 byte[] buf 来实现缓冲区的功能，我们调用的  buf_in.read() 方法在返回数据之前有做一个 if 判断，如果 buf 数组的当前索引不在有效的索引范围之内，即 if 条件成立， buf 字段维护的缓冲区已经不够了，这时候会调用 内部的 fill() 方法进行填充，而fill()会预读更多的数据到 buf 数组缓冲区中去，然后再返回当前字节数据，如果 if 条件不成立便直接从 buf缓冲区数组返回数据了。其中getBufIfOpen()返回的就是 buf字段的引用。顺便说下，源码中的 buf 字段声明为  protected volatile byte buf[];  主要是为了通过 volatile 关键字保证 buf数组在多线程并发环境中的内存可见性.\n\n### 2. 什么是内存映射\n\nLinux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。虚拟内存区域可以映射到俩种类型的对象一种：\n\n1. linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分。并且磁盘文件区被分成页大小的片，每一片包含一个虚拟页面的初始内容。此时并没有拷贝数据到内存中去，而是当进程代码第一次引用这段代码内的虚拟地址时，触发了缺页异常，这时候OS根据映射关系直接将文件的相关部分数据拷贝到进程的用户私有空间中去，当有操作第N页数据的时候重复这样的OS页面调度程序操作。**现在终于找出内存映射效率高的原因，原来内存映射文件的效率比标准IO高的重要原因就是因为少了把数据拷贝到OS内核缓冲区这一步（可能还少了native堆中转这一步）。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。**\n2. 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件时有内核穿件的，包含的去不是二进制零。CPU第一次引用这样的一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，经这个页面标记为是驻留在内存中的。注意在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制零的页。\n\n**注：如果你对虚拟内存不是很明白，推介你去看《深入理解操作系统》第九章**\n\n### 3.NIO中内存映射\n\n上面介绍了普通文件IO和内存映射，已经总结了为什么内存映射比普通的IO函数要快。现在来了解java中的内存映射，这也是NIO中的一个特性。其实java中的内存映射就是用c语言封装了一层，方便我们用java来调用，因此在了解概念的基础后，我们来看看如何使用。\n\n  java中提供了3种内存映射模式，即：只读(readonly)、读写(read_write)、专用(private) ，\n\n1. 对于只读模式来说，如果程序试图进行写操作，则会抛出ReadOnlyBufferException异常；\n2. 第二种的读写模式表明了通过内存映射文件的方式写或修改文件内容的话是会立刻反映到磁盘文件中去的，别的进程如果共享了同一个映射文件，那么也会立即看到变化！而不是像标准IO那样每个进程有各自的内核缓冲区，比如JAVA代码中，没有执行 IO输出流的 flush() 或者  close() 操作，那么对文件的修改不会更新到磁盘去，除非进程运行结束；\n3. 最后一种专用模式采用的是OS的“写时拷贝”原则，即在没有发生写操作的情况下，多个进程之间都是共享文件的同一块物理内存（进程各自的虚拟地址指向同一片物理地址），一旦某个进程进行写操作，那么将会把受影响的文件数据单独拷贝一份到进程的私有缓冲区中，不会反映到物理文件中去。\n\n   在JAVA NIO中可以很容易的创建一块内存映射区域，代码如下：\n\n```java\nFile file = new File(\"E:\\download\\office2007pro.chs.ISO\");\nFileInputStream in = new FileInputStream(file);\nFileChannel channel = in.getChannel();\n\nMappedByteBuffer buff = channel.map(FileChannel.MapMode.READ_ONLY, 0,channel.size());\n```\n\n  这里创建了一个只读模式的内存映射文件区域，接下来我就来测试下与普通NIO中的通道操作相比性能上的优势，先看如下代码：\n\n```java\npublic class MapperToBasic {\n\n    static final int BUFFER_SIZE = 1024;\n\n    String path =\"/Users/zhangke/code/java/tem/wechat.dmg\";\n\n    @Test\n    public void mapperTest() {\n        File file = new File(path);\n\n        FileInputStream in = null;\n        FileChannel channel = null;\n        try {\n            in = new FileInputStream(file);\n            channel = in.getChannel();\n            MappedByteBuffer buff = \n                channel.map(FileChannel.MapMode.READ_ONLY, \n                            0, channel.size());\n\n            byte[] b = new byte[1024];\n            int len = (int) file.length();\n\n            long begin = System.currentTimeMillis();\n\n            for (int offset = 0; offset < len; offset += \n                 1024) {\n\n                if (len - offset > BUFFER_SIZE) {\n                    buff.get(b);\n                } else {\n                    buff.get(new byte[len - offset]);\n                }\n            }\n\n            long end = System.currentTimeMillis();\n            System.out.println(\"time is:\" + (end - begin));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n\n            Optional.ofNullable(channel).ifPresent(c -> {\n                try {\n\n                    c.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void basiTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.flip();\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"time is:\" + (end - begin));\n        \n\n    }\n```\n\n上面第一个函数是测试NIO和普通IO读取文件大小为100M的文件内容的时间NIO读取完所有的内容大概花了30毫秒，普通IO大概花了160毫秒。文件越大，差距便越大。所以内存映射文件特别适合于对大文件的操作，JAVA中的限制是最大不得超过 Integer.MAX_VALUE，即2G左右，不过我们可以通过多次映射文件(channel.map)的不同部分来达到操作整个文件的目的。\n\n按照jdk文档的官方说法，内存映射文件属于JVM中的直接缓冲区，还可以通过 ByteBuffer.allocateDirect() ，即DirectMemory的方式来创建直接缓冲区。他们相比基础的 IO操作来说就是少了中间缓冲区的数据拷贝开销。同时他们属于JVM堆外内存，不受JVM堆内存大小的限制。\n\n### 4. 直接内存\n\nDirectMemory 默认的大小是等同于JVM最大堆，理论上说受限于进程的虚拟地址空间大小，比如 32位的windows上，每个进程有4G的虚拟空间除去 2G为OS内核保留外，再减去 JVM堆的最大值，剩余的才是DirectMemory大小。通过设置 JVM参数 -Xmx64M，即JVM最大堆为64M，然后执行以下程序可以证明DirectMemory不受JVM堆大小控制：\n\n```java\n public static void main(String[] args) {\t   \n   ByteBuffer.allocateDirect(1024*1024*100); // 100MB\n   }\n```\n我们设置了JVM堆 64M限制，然后在 直接内存上分配了 100MB空间，程序执行后直接报错：**Exception in thread \"main\" java.lang.OutOfMemoryError: Direct buffer memory**。接着我设置 -Xmx200M，程序正常结束。然后我修改配置： -Xmx64M  -XX:MaxDirectMemorySize=200M，程序正常结束。因此得出结论： 直接内存DirectMemory的大小默认为 -Xmx 的JVM堆的最大值，但是并不受其限制，而是由JVM参数 MaxDirectMemorySize单独控制。接下来我们来证明直接内存不是分配在JVM堆中。我们先执行以下程序，并设置 JVM参数       **-XX:+PrintGC** \n\n```\n public static void main(String[] args) {\t   \n\t for(int i=0;i<20000;i++) {\n            ByteBuffer.allocateDirect(1024*100);  //100K\n       }\n   }\n```\n\n  输出结果如下：\n\n     [GC 1371K->1328K(61312K), 0.0070033 secs]\n     [Full GC 1328K->1297K(61312K), 0.0329592 secs]\n     [GC 3029K->2481K(61312K), 0.0037401 secs]\n     [Full GC 2481K->2435K(61312K), 0.0102255 secs]\n\n   我们看到这里执行 GC的次数较少，但是触发了 两次 Full GC，原因在于直接内存不受 GC(新生代的Minor GC)影响，只有当执行老年代的 Full GC时候才会顺便回收直接内存！而直接内存是通过存储在JVM堆中的DirectByteBuffer对象来引用的，所以当众多的DirectByteBuffer对象从新生代被送入老年代后才触发了 full gc。\n\n  再看直接在JVM堆上分配内存区域的情况：\n\n ```java\n   public static void main(String[] args) {\t   \n\tfor(int i=0;i<10000;i++) {\n             ByteBuffer.allocate(1024*100);  //100K\n\t }\n   }\n ```\n\n  ByteBuffer.allocate 意味着直接在 JVM堆上分配内存，所以受 新生代的 Minor GC影响，输出如下：\n\n\n        [GC 16023K->224K(61312K), 0.0012432 secs]\n        [GC 16211K->192K(77376K), 0.0006917 secs]\n        [GC 32242K->176K(77376K), 0.0010613 secs]\n        [GC 32225K->224K(109504K), 0.0005539 secs]\n        [GC 64423K->192K(109504K), 0.0006151 secs]\n        [GC 64376K->192K(171392K), 0.0004968 secs]\n        [GC 128646K->204K(171392K), 0.0007423 secs]\n        [GC 128646K->204K(299968K), 0.0002067 secs]\n        [GC 257190K->204K(299968K), 0.0003862 secs]\n        [GC 257193K->204K(287680K), 0.0001718 secs]\n        [GC 245103K->204K(276480K), 0.0001994 secs]\n        [GC 233662K->204K(265344K), 0.0001828 secs]\n        [GC 222782K->172K(255232K), 0.0001998 secs]\n        [GC 212374K->172K(245120K), 0.0002217 secs]\n\n   可以看到，由于直接在 JVM堆上分配内存，所以触发了多次GC，且不会触及  Full GC，因为对象根本没机会进入老年代。\n\n在这里要来探讨一下内存映射和DirectMemory的内存回收问题。NIO中的DirectMemory和内存文件映射同属于直接缓冲区，但是前者和 -Xmx和-XX:MaxDirectMemorySize有关，而后者完全没有JVM参数可以影响和控制，这让我不禁怀疑两者的直接缓冲区是否相同，前者指的是 JAVA进程中的 native堆，即涉及底层平台如 win32的dll 部分，因为 C语言中的 malloc()分配的内存就属于 native堆，不属于 JVM堆，这也是DirectMemory能在一些场景中显著提高性能的原因，因为它避免了在 native堆和jvm堆之间数据的来回复制；而后者则是没有经过 native堆，是由 JAVA进程直接建立起 某一段虚拟地址空间和文件对象的关联映射关系，参见 Linux虚拟存储器图中的 “Memory mapped region for shared libraries”  区域，所以内存映射文件的区域并不在JVM GC的回收范围内，因为它本身就不属于堆区，卸载这部分区域只能通过系统调用 unmap()来实现 (Linux)中，而 JAVA API 只提供了 FileChannel.map 的形式创建内存映射区域，却没有提供对应的 unmap()。\n\n事实是由JVM帮助我们自动回收这部分内存，在定义这些类时，通过一个虚引用包裹这些创建的NIO对象，当JVM进行GC时检测指向这些内存映射或者直接内存的java对象是否被回收（java对象都是保存在堆上，只是对象中使用变量空间指向对外内存）。如果这些对象被回收，那么JVM就会自动的帮助我们回收这些堆外内存。具体参考：[堆外内存 之 DirectByteBuffer 详解](https://www.jianshu.com/p/007052ee3773)\n\n最后再试试通过 DirectMemory来操作前面 内存映射和基本通道操作的例子，来看看直接内存操作的话，程序的性能如何：\n\n```\n    @Test\n    public void directBufferTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n        \n        ByteBuffer buff = ByteBuffer.allocateDirect(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"time is:\" + (end - begin));\n        in.close();\n    }\n```\n\n\n\n程序输出为 130毫秒，看来比普通的NIO通道操作（160毫秒）来的快，但是比 mmap 内存映射的 30差距太多了，我想应该不至于吧，通过修改：\n\n```\nByteBuffer buff = ByteBuffer.allocateDirect(1024);  \n//将上面语句修改如下\nByteBuffer buff = ByteBuffer.allocateDirect((int)file.length())，\n```\n\n即一次性分配整个文件长度大小的堆外内存，最终输出为 78毫秒，由此可以得出两个结论：\n\n1. 堆外内存的分配耗时比较大.  \n\n2. 还是比mmap内存映射来得慢，都不要说通过mmap读取数据的时候还涉及缺页异常、页面调度的系统调用了。\n\n最后一点为 DirectMemory的内存只有在 JVM执行 full gc 的时候才会被回收，那么如果在其上分配过大的内存空间，那么也将出现 OutofMemoryError，即便 JVM 堆中的很多内存处于空闲状态。\n\n **补充下额外的一个知识点，关于 JVM堆大小的设置是不受限于物理内存，而是受限于虚拟内存空间大小，理论上来说是进程的虚拟地址空间大小，但是实际上我们的虚拟内存空间是有限制的，一般windows上默认在C盘，大小为物理内存的2倍左右。我做了个实验：我机子是 64位的win7，那么理论上说进程虚拟空间是几乎无限大，物理内存为4G，而我设置 -Xms5000M， 即在启动JAVA程序的时候一次性申请到超过物理内存大小的5000M内存，程序正常启动，而当我加到 -Xms8000M的时候就报OOM错误了，然后我修改增加 win7的虚拟内存，程序又正常启动了，说明 -Xms 受限于虚拟内存的大小。我设置-Xms5000M，即超过了4G物理内存，并在一个死循环中不断创建对象，并保证不会被GC回收。程序运行一会后整个电脑几乎死机状态，即卡住了，反映很慢很慢，推测是发生了系统颠簸，即频繁的页面调度置换导致，说明 -Xms -Xmx不是局限于物理内存的大小，而是综合虚拟内存了，JVM会根据电脑虚拟内存的设置来控制。**\n\n###  参考\n\n1. [JAVA NIO之浅谈内存映射文件原理与DirectMemory](https://blog.csdn.net/fcbayernmunchen/article/details/8635427)","slug":"nio/JAVA NIO之浅谈内存映射文件原理与DirectBuffer","published":1,"updated":"2019-01-14T08:40:08.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovt9002u9q1u67fqj6dv","content":"<h1 id=\"Java-NIO之浅谈内存映射文件原理与DirectMemory\"><a href=\"#Java-NIO之浅谈内存映射文件原理与DirectMemory\" class=\"headerlink\" title=\"Java NIO之浅谈内存映射文件原理与DirectMemory\"></a>Java NIO之浅谈内存映射文件原理与DirectMemory</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>传统文件IO操作原理</li>\n<li>什么是内存映射</li>\n<li>NIO中内存映射</li>\n<li>直接缓冲区（DirectMemory）</li>\n</ol>\n<p>学习了很久的NIO，但是一直对NIO中内存映射和DirectMemory有很多的不理解，恰好最近在读《深入理解操作系统》，对其中一些不理解的地点有了自己的一些感悟。此篇文章将结合操作系统谈谈自己对NIO中的内存映射和DirectMemory的理解。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-传统文件IO操作原理\"><a href=\"#1-传统文件IO操作原理\" class=\"headerlink\" title=\"1.传统文件IO操作原理\"></a>1.传统文件IO操作原理</h3><p>在传统的文件IO操作中，我们都是调用操作系统提供的底层标准IO系统调用函数  read()、write() ，此时调用此函数的进程（在JAVA中即java进程）会从用户态切换到内核态，然后OS的内核代码负责将相应的文件数据读取到内核的IO缓冲区，然后再把数据从内核IO缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。至于为什么要多此一举搞一个内核IO缓冲区把原本只需一次拷贝数据的事情搞成需要2次数据拷贝呢？ 我想学过操作系统或者计算机系统结构的人都知道，这么做是为了减少磁盘的IO操作，为了提高性能而考虑的，因为我们的程序访问一般都带有局部性，也就是所谓的局部性原理，在这里主要是指的空间局部性，即我们访问了文件的某一段数据，那么接下去很可能还会访问接下去的一段数据，由于磁盘IO操作的速度比直接访问内存慢了好几个数量级，所以OS根据局部性原理会在一次 read()系统调用过程中预读更多的文件数据缓存在内核IO缓冲区中，当继续访问的文件数据在缓冲区中时便直接拷贝数据到进程私有空间，避免了再次的低效率磁盘IO操作。在JAVA中当我们采用IO包下的文件操作流，如：  </p>\n<pre><code>   FileInputStream in = new FileInputStream(&quot;D:\\\\java.txt&quot;);\n   in.read();\n</code></pre><p>   JAVA虚拟机内部便会调用OS底层的 read()系统调用完成操作，如上所述，在第二次调用 in.read()的时候可能就是从内核缓冲区直接返回数据了（可能还有经过 native堆做一次中转，因为这些函数都被声明为 native，即本地平台相关，所以可能在C代码中有做一次中转，如 win32中是通过 C代码从OS读取数据，然后再传给JVM内存）。既然如此，JAVA的IO包中为啥还要提供一个 BufferedInputStream 类来作为缓冲区呢。关键在于四个字，”系统调用”！当读取OS内核缓冲区数据的时候，便发起了一次系统调用操作（通过native的C函数调用），而系统调用的代价相对来说是比较高的，涉及到进程用户态和内核态的上下文切换等一系列操作，所以我们经常采用如下的包装：</p>\n<pre><code class=\"java\">   FileInputStream in = new FileInputStream(&quot;D:\\\\java.txt&quot;); \n   BufferedInputStream buf_in = new BufferedInputStream(in);\n   buf_in.read();\n</code></pre>\n<p>  这样一来，我们每一次 buf_in.read() 时候，BufferedInputStream 会根据情况自动为我们预读更多的字节数据到它自己维护的一个内部字节数组缓冲区中，这样我们便可以减少系统调用次数，从而达到其缓冲区的目的。所以要明确的一点是 BufferedInputStream 的作用不是减少磁盘IO操作次数（这个OS已经帮我们做了），而是通过减少系统调用次数来提高性能的。同理 BufferedOuputStream , BufferedReader/Writer 也是一样的。在 C语言的函数库中也有类似的实现，如 fread()，这个函数就是 C语言中的缓冲IO，作用与BufferedInputStream()相同.</p>\n<p>​    这里简单的引用下JDK8 中 BufferedInputStream 的源码验证下：</p>\n<pre><code class=\"java\">public\nclass BufferedInputStream extends FilterInputStream {\n\n    /**\n    * 只列出了重要的部分\n    */\n\n    protected volatile byte buf[];\n\n    public synchronized int read() throws IOException {\n        if (pos &gt;= count) {\n            fill();\n            if (pos &gt;= count)\n                return -1;\n        }\n        return getBufIfOpen()[pos++] &amp; 0xff;\n    }\n\n\n\n</code></pre>\n<p>   我们可以看到，BufferedInputStream 内部维护着一个 字节数组 byte[] buf 来实现缓冲区的功能，我们调用的  buf_in.read() 方法在返回数据之前有做一个 if 判断，如果 buf 数组的当前索引不在有效的索引范围之内，即 if 条件成立， buf 字段维护的缓冲区已经不够了，这时候会调用 内部的 fill() 方法进行填充，而fill()会预读更多的数据到 buf 数组缓冲区中去，然后再返回当前字节数据，如果 if 条件不成立便直接从 buf缓冲区数组返回数据了。其中getBufIfOpen()返回的就是 buf字段的引用。顺便说下，源码中的 buf 字段声明为  protected volatile byte buf[];  主要是为了通过 volatile 关键字保证 buf数组在多线程并发环境中的内存可见性.</p>\n<h3 id=\"2-什么是内存映射\"><a href=\"#2-什么是内存映射\" class=\"headerlink\" title=\"2. 什么是内存映射\"></a>2. 什么是内存映射</h3><p>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。虚拟内存区域可以映射到俩种类型的对象一种：</p>\n<ol>\n<li>linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分。并且磁盘文件区被分成页大小的片，每一片包含一个虚拟页面的初始内容。此时并没有拷贝数据到内存中去，而是当进程代码第一次引用这段代码内的虚拟地址时，触发了缺页异常，这时候OS根据映射关系直接将文件的相关部分数据拷贝到进程的用户私有空间中去，当有操作第N页数据的时候重复这样的OS页面调度程序操作。<strong>现在终于找出内存映射效率高的原因，原来内存映射文件的效率比标准IO高的重要原因就是因为少了把数据拷贝到OS内核缓冲区这一步（可能还少了native堆中转这一步）。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。</strong></li>\n<li>匿名文件：一个区域也可以映射到一个匿名文件，匿名文件时有内核穿件的，包含的去不是二进制零。CPU第一次引用这样的一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，经这个页面标记为是驻留在内存中的。注意在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制零的页。</li>\n</ol>\n<p><strong>注：如果你对虚拟内存不是很明白，推介你去看《深入理解操作系统》第九章</strong></p>\n<h3 id=\"3-NIO中内存映射\"><a href=\"#3-NIO中内存映射\" class=\"headerlink\" title=\"3.NIO中内存映射\"></a>3.NIO中内存映射</h3><p>上面介绍了普通文件IO和内存映射，已经总结了为什么内存映射比普通的IO函数要快。现在来了解java中的内存映射，这也是NIO中的一个特性。其实java中的内存映射就是用c语言封装了一层，方便我们用java来调用，因此在了解概念的基础后，我们来看看如何使用。</p>\n<p>  java中提供了3种内存映射模式，即：只读(readonly)、读写(read_write)、专用(private) ，</p>\n<ol>\n<li>对于只读模式来说，如果程序试图进行写操作，则会抛出ReadOnlyBufferException异常；</li>\n<li>第二种的读写模式表明了通过内存映射文件的方式写或修改文件内容的话是会立刻反映到磁盘文件中去的，别的进程如果共享了同一个映射文件，那么也会立即看到变化！而不是像标准IO那样每个进程有各自的内核缓冲区，比如JAVA代码中，没有执行 IO输出流的 flush() 或者  close() 操作，那么对文件的修改不会更新到磁盘去，除非进程运行结束；</li>\n<li><p>最后一种专用模式采用的是OS的“写时拷贝”原则，即在没有发生写操作的情况下，多个进程之间都是共享文件的同一块物理内存（进程各自的虚拟地址指向同一片物理地址），一旦某个进程进行写操作，那么将会把受影响的文件数据单独拷贝一份到进程的私有缓冲区中，不会反映到物理文件中去。</p>\n<p>在JAVA NIO中可以很容易的创建一块内存映射区域，代码如下：</p>\n</li>\n</ol>\n<pre><code class=\"java\">File file = new File(&quot;E:\\download\\office2007pro.chs.ISO&quot;);\nFileInputStream in = new FileInputStream(file);\nFileChannel channel = in.getChannel();\n\nMappedByteBuffer buff = channel.map(FileChannel.MapMode.READ_ONLY, 0,channel.size());\n</code></pre>\n<p>  这里创建了一个只读模式的内存映射文件区域，接下来我就来测试下与普通NIO中的通道操作相比性能上的优势，先看如下代码：</p>\n<pre><code class=\"java\">public class MapperToBasic {\n\n    static final int BUFFER_SIZE = 1024;\n\n    String path =&quot;/Users/zhangke/code/java/tem/wechat.dmg&quot;;\n\n    @Test\n    public void mapperTest() {\n        File file = new File(path);\n\n        FileInputStream in = null;\n        FileChannel channel = null;\n        try {\n            in = new FileInputStream(file);\n            channel = in.getChannel();\n            MappedByteBuffer buff = \n                channel.map(FileChannel.MapMode.READ_ONLY, \n                            0, channel.size());\n\n            byte[] b = new byte[1024];\n            int len = (int) file.length();\n\n            long begin = System.currentTimeMillis();\n\n            for (int offset = 0; offset &lt; len; offset += \n                 1024) {\n\n                if (len - offset &gt; BUFFER_SIZE) {\n                    buff.get(b);\n                } else {\n                    buff.get(new byte[len - offset]);\n                }\n            }\n\n            long end = System.currentTimeMillis();\n            System.out.println(&quot;time is:&quot; + (end - begin));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n\n            Optional.ofNullable(channel).ifPresent(c -&gt; {\n                try {\n\n                    c.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void basiTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.flip();\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;time is:&quot; + (end - begin));\n\n\n    }\n</code></pre>\n<p>上面第一个函数是测试NIO和普通IO读取文件大小为100M的文件内容的时间NIO读取完所有的内容大概花了30毫秒，普通IO大概花了160毫秒。文件越大，差距便越大。所以内存映射文件特别适合于对大文件的操作，JAVA中的限制是最大不得超过 Integer.MAX_VALUE，即2G左右，不过我们可以通过多次映射文件(channel.map)的不同部分来达到操作整个文件的目的。</p>\n<p>按照jdk文档的官方说法，内存映射文件属于JVM中的直接缓冲区，还可以通过 ByteBuffer.allocateDirect() ，即DirectMemory的方式来创建直接缓冲区。他们相比基础的 IO操作来说就是少了中间缓冲区的数据拷贝开销。同时他们属于JVM堆外内存，不受JVM堆内存大小的限制。</p>\n<h3 id=\"4-直接内存\"><a href=\"#4-直接内存\" class=\"headerlink\" title=\"4. 直接内存\"></a>4. 直接内存</h3><p>DirectMemory 默认的大小是等同于JVM最大堆，理论上说受限于进程的虚拟地址空间大小，比如 32位的windows上，每个进程有4G的虚拟空间除去 2G为OS内核保留外，再减去 JVM堆的最大值，剩余的才是DirectMemory大小。通过设置 JVM参数 -Xmx64M，即JVM最大堆为64M，然后执行以下程序可以证明DirectMemory不受JVM堆大小控制：</p>\n<pre><code class=\"java\"> public static void main(String[] args) {       \n   ByteBuffer.allocateDirect(1024*1024*100); // 100MB\n   }\n</code></pre>\n<p>我们设置了JVM堆 64M限制，然后在 直接内存上分配了 100MB空间，程序执行后直接报错：<strong>Exception in thread “main” java.lang.OutOfMemoryError: Direct buffer memory</strong>。接着我设置 -Xmx200M，程序正常结束。然后我修改配置： -Xmx64M  -XX:MaxDirectMemorySize=200M，程序正常结束。因此得出结论： 直接内存DirectMemory的大小默认为 -Xmx 的JVM堆的最大值，但是并不受其限制，而是由JVM参数 MaxDirectMemorySize单独控制。接下来我们来证明直接内存不是分配在JVM堆中。我们先执行以下程序，并设置 JVM参数       <strong>-XX:+PrintGC</strong> </p>\n<pre><code> public static void main(String[] args) {       \n     for(int i=0;i&lt;20000;i++) {\n            ByteBuffer.allocateDirect(1024*100);  //100K\n       }\n   }\n</code></pre><p>  输出结果如下：</p>\n<pre><code> [GC 1371K-&gt;1328K(61312K), 0.0070033 secs]\n [Full GC 1328K-&gt;1297K(61312K), 0.0329592 secs]\n [GC 3029K-&gt;2481K(61312K), 0.0037401 secs]\n [Full GC 2481K-&gt;2435K(61312K), 0.0102255 secs]\n</code></pre><p>   我们看到这里执行 GC的次数较少，但是触发了 两次 Full GC，原因在于直接内存不受 GC(新生代的Minor GC)影响，只有当执行老年代的 Full GC时候才会顺便回收直接内存！而直接内存是通过存储在JVM堆中的DirectByteBuffer对象来引用的，所以当众多的DirectByteBuffer对象从新生代被送入老年代后才触发了 full gc。</p>\n<p>  再看直接在JVM堆上分配内存区域的情况：</p>\n<pre><code class=\"java\">   public static void main(String[] args) {       \n    for(int i=0;i&lt;10000;i++) {\n             ByteBuffer.allocate(1024*100);  //100K\n     }\n   }\n</code></pre>\n<p>  ByteBuffer.allocate 意味着直接在 JVM堆上分配内存，所以受 新生代的 Minor GC影响，输出如下：</p>\n<pre><code>    [GC 16023K-&gt;224K(61312K), 0.0012432 secs]\n    [GC 16211K-&gt;192K(77376K), 0.0006917 secs]\n    [GC 32242K-&gt;176K(77376K), 0.0010613 secs]\n    [GC 32225K-&gt;224K(109504K), 0.0005539 secs]\n    [GC 64423K-&gt;192K(109504K), 0.0006151 secs]\n    [GC 64376K-&gt;192K(171392K), 0.0004968 secs]\n    [GC 128646K-&gt;204K(171392K), 0.0007423 secs]\n    [GC 128646K-&gt;204K(299968K), 0.0002067 secs]\n    [GC 257190K-&gt;204K(299968K), 0.0003862 secs]\n    [GC 257193K-&gt;204K(287680K), 0.0001718 secs]\n    [GC 245103K-&gt;204K(276480K), 0.0001994 secs]\n    [GC 233662K-&gt;204K(265344K), 0.0001828 secs]\n    [GC 222782K-&gt;172K(255232K), 0.0001998 secs]\n    [GC 212374K-&gt;172K(245120K), 0.0002217 secs]\n</code></pre><p>   可以看到，由于直接在 JVM堆上分配内存，所以触发了多次GC，且不会触及  Full GC，因为对象根本没机会进入老年代。</p>\n<p>在这里要来探讨一下内存映射和DirectMemory的内存回收问题。NIO中的DirectMemory和内存文件映射同属于直接缓冲区，但是前者和 -Xmx和-XX:MaxDirectMemorySize有关，而后者完全没有JVM参数可以影响和控制，这让我不禁怀疑两者的直接缓冲区是否相同，前者指的是 JAVA进程中的 native堆，即涉及底层平台如 win32的dll 部分，因为 C语言中的 malloc()分配的内存就属于 native堆，不属于 JVM堆，这也是DirectMemory能在一些场景中显著提高性能的原因，因为它避免了在 native堆和jvm堆之间数据的来回复制；而后者则是没有经过 native堆，是由 JAVA进程直接建立起 某一段虚拟地址空间和文件对象的关联映射关系，参见 Linux虚拟存储器图中的 “Memory mapped region for shared libraries”  区域，所以内存映射文件的区域并不在JVM GC的回收范围内，因为它本身就不属于堆区，卸载这部分区域只能通过系统调用 unmap()来实现 (Linux)中，而 JAVA API 只提供了 FileChannel.map 的形式创建内存映射区域，却没有提供对应的 unmap()。</p>\n<p>事实是由JVM帮助我们自动回收这部分内存，在定义这些类时，通过一个虚引用包裹这些创建的NIO对象，当JVM进行GC时检测指向这些内存映射或者直接内存的java对象是否被回收（java对象都是保存在堆上，只是对象中使用变量空间指向对外内存）。如果这些对象被回收，那么JVM就会自动的帮助我们回收这些堆外内存。具体参考：<a href=\"https://www.jianshu.com/p/007052ee3773\" target=\"_blank\" rel=\"noopener\">堆外内存 之 DirectByteBuffer 详解</a></p>\n<p>最后再试试通过 DirectMemory来操作前面 内存映射和基本通道操作的例子，来看看直接内存操作的话，程序的性能如何：</p>\n<pre><code>    @Test\n    public void directBufferTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n\n        ByteBuffer buff = ByteBuffer.allocateDirect(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;time is:&quot; + (end - begin));\n        in.close();\n    }\n</code></pre><p>程序输出为 130毫秒，看来比普通的NIO通道操作（160毫秒）来的快，但是比 mmap 内存映射的 30差距太多了，我想应该不至于吧，通过修改：</p>\n<pre><code>ByteBuffer buff = ByteBuffer.allocateDirect(1024);  \n//将上面语句修改如下\nByteBuffer buff = ByteBuffer.allocateDirect((int)file.length())，\n</code></pre><p>即一次性分配整个文件长度大小的堆外内存，最终输出为 78毫秒，由此可以得出两个结论：</p>\n<ol>\n<li><p>堆外内存的分配耗时比较大.  </p>\n</li>\n<li><p>还是比mmap内存映射来得慢，都不要说通过mmap读取数据的时候还涉及缺页异常、页面调度的系统调用了。</p>\n</li>\n</ol>\n<p>最后一点为 DirectMemory的内存只有在 JVM执行 full gc 的时候才会被回收，那么如果在其上分配过大的内存空间，那么也将出现 OutofMemoryError，即便 JVM 堆中的很多内存处于空闲状态。</p>\n<p> <strong>补充下额外的一个知识点，关于 JVM堆大小的设置是不受限于物理内存，而是受限于虚拟内存空间大小，理论上来说是进程的虚拟地址空间大小，但是实际上我们的虚拟内存空间是有限制的，一般windows上默认在C盘，大小为物理内存的2倍左右。我做了个实验：我机子是 64位的win7，那么理论上说进程虚拟空间是几乎无限大，物理内存为4G，而我设置 -Xms5000M， 即在启动JAVA程序的时候一次性申请到超过物理内存大小的5000M内存，程序正常启动，而当我加到 -Xms8000M的时候就报OOM错误了，然后我修改增加 win7的虚拟内存，程序又正常启动了，说明 -Xms 受限于虚拟内存的大小。我设置-Xms5000M，即超过了4G物理内存，并在一个死循环中不断创建对象，并保证不会被GC回收。程序运行一会后整个电脑几乎死机状态，即卡住了，反映很慢很慢，推测是发生了系统颠簸，即频繁的页面调度置换导致，说明 -Xms -Xmx不是局限于物理内存的大小，而是综合虚拟内存了，JVM会根据电脑虚拟内存的设置来控制。</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://blog.csdn.net/fcbayernmunchen/article/details/8635427\" target=\"_blank\" rel=\"noopener\">JAVA NIO之浅谈内存映射文件原理与DirectMemory</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java-NIO之浅谈内存映射文件原理与DirectMemory\"><a href=\"#Java-NIO之浅谈内存映射文件原理与DirectMemory\" class=\"headerlink\" title=\"Java NIO之浅谈内存映射文件原理与DirectMemory\"></a>Java NIO之浅谈内存映射文件原理与DirectMemory</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>传统文件IO操作原理</li>\n<li>什么是内存映射</li>\n<li>NIO中内存映射</li>\n<li>直接缓冲区（DirectMemory）</li>\n</ol>\n<p>学习了很久的NIO，但是一直对NIO中内存映射和DirectMemory有很多的不理解，恰好最近在读《深入理解操作系统》，对其中一些不理解的地点有了自己的一些感悟。此篇文章将结合操作系统谈谈自己对NIO中的内存映射和DirectMemory的理解。</p>","more":"<h3 id=\"1-传统文件IO操作原理\"><a href=\"#1-传统文件IO操作原理\" class=\"headerlink\" title=\"1.传统文件IO操作原理\"></a>1.传统文件IO操作原理</h3><p>在传统的文件IO操作中，我们都是调用操作系统提供的底层标准IO系统调用函数  read()、write() ，此时调用此函数的进程（在JAVA中即java进程）会从用户态切换到内核态，然后OS的内核代码负责将相应的文件数据读取到内核的IO缓冲区，然后再把数据从内核IO缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。至于为什么要多此一举搞一个内核IO缓冲区把原本只需一次拷贝数据的事情搞成需要2次数据拷贝呢？ 我想学过操作系统或者计算机系统结构的人都知道，这么做是为了减少磁盘的IO操作，为了提高性能而考虑的，因为我们的程序访问一般都带有局部性，也就是所谓的局部性原理，在这里主要是指的空间局部性，即我们访问了文件的某一段数据，那么接下去很可能还会访问接下去的一段数据，由于磁盘IO操作的速度比直接访问内存慢了好几个数量级，所以OS根据局部性原理会在一次 read()系统调用过程中预读更多的文件数据缓存在内核IO缓冲区中，当继续访问的文件数据在缓冲区中时便直接拷贝数据到进程私有空间，避免了再次的低效率磁盘IO操作。在JAVA中当我们采用IO包下的文件操作流，如：  </p>\n<pre><code>   FileInputStream in = new FileInputStream(&quot;D:\\\\java.txt&quot;);\n   in.read();\n</code></pre><p>   JAVA虚拟机内部便会调用OS底层的 read()系统调用完成操作，如上所述，在第二次调用 in.read()的时候可能就是从内核缓冲区直接返回数据了（可能还有经过 native堆做一次中转，因为这些函数都被声明为 native，即本地平台相关，所以可能在C代码中有做一次中转，如 win32中是通过 C代码从OS读取数据，然后再传给JVM内存）。既然如此，JAVA的IO包中为啥还要提供一个 BufferedInputStream 类来作为缓冲区呢。关键在于四个字，”系统调用”！当读取OS内核缓冲区数据的时候，便发起了一次系统调用操作（通过native的C函数调用），而系统调用的代价相对来说是比较高的，涉及到进程用户态和内核态的上下文切换等一系列操作，所以我们经常采用如下的包装：</p>\n<pre><code class=\"java\">   FileInputStream in = new FileInputStream(&quot;D:\\\\java.txt&quot;); \n   BufferedInputStream buf_in = new BufferedInputStream(in);\n   buf_in.read();\n</code></pre>\n<p>  这样一来，我们每一次 buf_in.read() 时候，BufferedInputStream 会根据情况自动为我们预读更多的字节数据到它自己维护的一个内部字节数组缓冲区中，这样我们便可以减少系统调用次数，从而达到其缓冲区的目的。所以要明确的一点是 BufferedInputStream 的作用不是减少磁盘IO操作次数（这个OS已经帮我们做了），而是通过减少系统调用次数来提高性能的。同理 BufferedOuputStream , BufferedReader/Writer 也是一样的。在 C语言的函数库中也有类似的实现，如 fread()，这个函数就是 C语言中的缓冲IO，作用与BufferedInputStream()相同.</p>\n<p>​    这里简单的引用下JDK8 中 BufferedInputStream 的源码验证下：</p>\n<pre><code class=\"java\">public\nclass BufferedInputStream extends FilterInputStream {\n\n    /**\n    * 只列出了重要的部分\n    */\n\n    protected volatile byte buf[];\n\n    public synchronized int read() throws IOException {\n        if (pos &gt;= count) {\n            fill();\n            if (pos &gt;= count)\n                return -1;\n        }\n        return getBufIfOpen()[pos++] &amp; 0xff;\n    }\n\n\n\n</code></pre>\n<p>   我们可以看到，BufferedInputStream 内部维护着一个 字节数组 byte[] buf 来实现缓冲区的功能，我们调用的  buf_in.read() 方法在返回数据之前有做一个 if 判断，如果 buf 数组的当前索引不在有效的索引范围之内，即 if 条件成立， buf 字段维护的缓冲区已经不够了，这时候会调用 内部的 fill() 方法进行填充，而fill()会预读更多的数据到 buf 数组缓冲区中去，然后再返回当前字节数据，如果 if 条件不成立便直接从 buf缓冲区数组返回数据了。其中getBufIfOpen()返回的就是 buf字段的引用。顺便说下，源码中的 buf 字段声明为  protected volatile byte buf[];  主要是为了通过 volatile 关键字保证 buf数组在多线程并发环境中的内存可见性.</p>\n<h3 id=\"2-什么是内存映射\"><a href=\"#2-什么是内存映射\" class=\"headerlink\" title=\"2. 什么是内存映射\"></a>2. 什么是内存映射</h3><p>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。虚拟内存区域可以映射到俩种类型的对象一种：</p>\n<ol>\n<li>linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分。并且磁盘文件区被分成页大小的片，每一片包含一个虚拟页面的初始内容。此时并没有拷贝数据到内存中去，而是当进程代码第一次引用这段代码内的虚拟地址时，触发了缺页异常，这时候OS根据映射关系直接将文件的相关部分数据拷贝到进程的用户私有空间中去，当有操作第N页数据的时候重复这样的OS页面调度程序操作。<strong>现在终于找出内存映射效率高的原因，原来内存映射文件的效率比标准IO高的重要原因就是因为少了把数据拷贝到OS内核缓冲区这一步（可能还少了native堆中转这一步）。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。</strong></li>\n<li>匿名文件：一个区域也可以映射到一个匿名文件，匿名文件时有内核穿件的，包含的去不是二进制零。CPU第一次引用这样的一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，经这个页面标记为是驻留在内存中的。注意在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制零的页。</li>\n</ol>\n<p><strong>注：如果你对虚拟内存不是很明白，推介你去看《深入理解操作系统》第九章</strong></p>\n<h3 id=\"3-NIO中内存映射\"><a href=\"#3-NIO中内存映射\" class=\"headerlink\" title=\"3.NIO中内存映射\"></a>3.NIO中内存映射</h3><p>上面介绍了普通文件IO和内存映射，已经总结了为什么内存映射比普通的IO函数要快。现在来了解java中的内存映射，这也是NIO中的一个特性。其实java中的内存映射就是用c语言封装了一层，方便我们用java来调用，因此在了解概念的基础后，我们来看看如何使用。</p>\n<p>  java中提供了3种内存映射模式，即：只读(readonly)、读写(read_write)、专用(private) ，</p>\n<ol>\n<li>对于只读模式来说，如果程序试图进行写操作，则会抛出ReadOnlyBufferException异常；</li>\n<li>第二种的读写模式表明了通过内存映射文件的方式写或修改文件内容的话是会立刻反映到磁盘文件中去的，别的进程如果共享了同一个映射文件，那么也会立即看到变化！而不是像标准IO那样每个进程有各自的内核缓冲区，比如JAVA代码中，没有执行 IO输出流的 flush() 或者  close() 操作，那么对文件的修改不会更新到磁盘去，除非进程运行结束；</li>\n<li><p>最后一种专用模式采用的是OS的“写时拷贝”原则，即在没有发生写操作的情况下，多个进程之间都是共享文件的同一块物理内存（进程各自的虚拟地址指向同一片物理地址），一旦某个进程进行写操作，那么将会把受影响的文件数据单独拷贝一份到进程的私有缓冲区中，不会反映到物理文件中去。</p>\n<p>在JAVA NIO中可以很容易的创建一块内存映射区域，代码如下：</p>\n</li>\n</ol>\n<pre><code class=\"java\">File file = new File(&quot;E:\\download\\office2007pro.chs.ISO&quot;);\nFileInputStream in = new FileInputStream(file);\nFileChannel channel = in.getChannel();\n\nMappedByteBuffer buff = channel.map(FileChannel.MapMode.READ_ONLY, 0,channel.size());\n</code></pre>\n<p>  这里创建了一个只读模式的内存映射文件区域，接下来我就来测试下与普通NIO中的通道操作相比性能上的优势，先看如下代码：</p>\n<pre><code class=\"java\">public class MapperToBasic {\n\n    static final int BUFFER_SIZE = 1024;\n\n    String path =&quot;/Users/zhangke/code/java/tem/wechat.dmg&quot;;\n\n    @Test\n    public void mapperTest() {\n        File file = new File(path);\n\n        FileInputStream in = null;\n        FileChannel channel = null;\n        try {\n            in = new FileInputStream(file);\n            channel = in.getChannel();\n            MappedByteBuffer buff = \n                channel.map(FileChannel.MapMode.READ_ONLY, \n                            0, channel.size());\n\n            byte[] b = new byte[1024];\n            int len = (int) file.length();\n\n            long begin = System.currentTimeMillis();\n\n            for (int offset = 0; offset &lt; len; offset += \n                 1024) {\n\n                if (len - offset &gt; BUFFER_SIZE) {\n                    buff.get(b);\n                } else {\n                    buff.get(new byte[len - offset]);\n                }\n            }\n\n            long end = System.currentTimeMillis();\n            System.out.println(&quot;time is:&quot; + (end - begin));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n\n            Optional.ofNullable(channel).ifPresent(c -&gt; {\n                try {\n\n                    c.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void basiTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.flip();\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;time is:&quot; + (end - begin));\n\n\n    }\n</code></pre>\n<p>上面第一个函数是测试NIO和普通IO读取文件大小为100M的文件内容的时间NIO读取完所有的内容大概花了30毫秒，普通IO大概花了160毫秒。文件越大，差距便越大。所以内存映射文件特别适合于对大文件的操作，JAVA中的限制是最大不得超过 Integer.MAX_VALUE，即2G左右，不过我们可以通过多次映射文件(channel.map)的不同部分来达到操作整个文件的目的。</p>\n<p>按照jdk文档的官方说法，内存映射文件属于JVM中的直接缓冲区，还可以通过 ByteBuffer.allocateDirect() ，即DirectMemory的方式来创建直接缓冲区。他们相比基础的 IO操作来说就是少了中间缓冲区的数据拷贝开销。同时他们属于JVM堆外内存，不受JVM堆内存大小的限制。</p>\n<h3 id=\"4-直接内存\"><a href=\"#4-直接内存\" class=\"headerlink\" title=\"4. 直接内存\"></a>4. 直接内存</h3><p>DirectMemory 默认的大小是等同于JVM最大堆，理论上说受限于进程的虚拟地址空间大小，比如 32位的windows上，每个进程有4G的虚拟空间除去 2G为OS内核保留外，再减去 JVM堆的最大值，剩余的才是DirectMemory大小。通过设置 JVM参数 -Xmx64M，即JVM最大堆为64M，然后执行以下程序可以证明DirectMemory不受JVM堆大小控制：</p>\n<pre><code class=\"java\"> public static void main(String[] args) {       \n   ByteBuffer.allocateDirect(1024*1024*100); // 100MB\n   }\n</code></pre>\n<p>我们设置了JVM堆 64M限制，然后在 直接内存上分配了 100MB空间，程序执行后直接报错：<strong>Exception in thread “main” java.lang.OutOfMemoryError: Direct buffer memory</strong>。接着我设置 -Xmx200M，程序正常结束。然后我修改配置： -Xmx64M  -XX:MaxDirectMemorySize=200M，程序正常结束。因此得出结论： 直接内存DirectMemory的大小默认为 -Xmx 的JVM堆的最大值，但是并不受其限制，而是由JVM参数 MaxDirectMemorySize单独控制。接下来我们来证明直接内存不是分配在JVM堆中。我们先执行以下程序，并设置 JVM参数       <strong>-XX:+PrintGC</strong> </p>\n<pre><code> public static void main(String[] args) {       \n     for(int i=0;i&lt;20000;i++) {\n            ByteBuffer.allocateDirect(1024*100);  //100K\n       }\n   }\n</code></pre><p>  输出结果如下：</p>\n<pre><code> [GC 1371K-&gt;1328K(61312K), 0.0070033 secs]\n [Full GC 1328K-&gt;1297K(61312K), 0.0329592 secs]\n [GC 3029K-&gt;2481K(61312K), 0.0037401 secs]\n [Full GC 2481K-&gt;2435K(61312K), 0.0102255 secs]\n</code></pre><p>   我们看到这里执行 GC的次数较少，但是触发了 两次 Full GC，原因在于直接内存不受 GC(新生代的Minor GC)影响，只有当执行老年代的 Full GC时候才会顺便回收直接内存！而直接内存是通过存储在JVM堆中的DirectByteBuffer对象来引用的，所以当众多的DirectByteBuffer对象从新生代被送入老年代后才触发了 full gc。</p>\n<p>  再看直接在JVM堆上分配内存区域的情况：</p>\n<pre><code class=\"java\">   public static void main(String[] args) {       \n    for(int i=0;i&lt;10000;i++) {\n             ByteBuffer.allocate(1024*100);  //100K\n     }\n   }\n</code></pre>\n<p>  ByteBuffer.allocate 意味着直接在 JVM堆上分配内存，所以受 新生代的 Minor GC影响，输出如下：</p>\n<pre><code>    [GC 16023K-&gt;224K(61312K), 0.0012432 secs]\n    [GC 16211K-&gt;192K(77376K), 0.0006917 secs]\n    [GC 32242K-&gt;176K(77376K), 0.0010613 secs]\n    [GC 32225K-&gt;224K(109504K), 0.0005539 secs]\n    [GC 64423K-&gt;192K(109504K), 0.0006151 secs]\n    [GC 64376K-&gt;192K(171392K), 0.0004968 secs]\n    [GC 128646K-&gt;204K(171392K), 0.0007423 secs]\n    [GC 128646K-&gt;204K(299968K), 0.0002067 secs]\n    [GC 257190K-&gt;204K(299968K), 0.0003862 secs]\n    [GC 257193K-&gt;204K(287680K), 0.0001718 secs]\n    [GC 245103K-&gt;204K(276480K), 0.0001994 secs]\n    [GC 233662K-&gt;204K(265344K), 0.0001828 secs]\n    [GC 222782K-&gt;172K(255232K), 0.0001998 secs]\n    [GC 212374K-&gt;172K(245120K), 0.0002217 secs]\n</code></pre><p>   可以看到，由于直接在 JVM堆上分配内存，所以触发了多次GC，且不会触及  Full GC，因为对象根本没机会进入老年代。</p>\n<p>在这里要来探讨一下内存映射和DirectMemory的内存回收问题。NIO中的DirectMemory和内存文件映射同属于直接缓冲区，但是前者和 -Xmx和-XX:MaxDirectMemorySize有关，而后者完全没有JVM参数可以影响和控制，这让我不禁怀疑两者的直接缓冲区是否相同，前者指的是 JAVA进程中的 native堆，即涉及底层平台如 win32的dll 部分，因为 C语言中的 malloc()分配的内存就属于 native堆，不属于 JVM堆，这也是DirectMemory能在一些场景中显著提高性能的原因，因为它避免了在 native堆和jvm堆之间数据的来回复制；而后者则是没有经过 native堆，是由 JAVA进程直接建立起 某一段虚拟地址空间和文件对象的关联映射关系，参见 Linux虚拟存储器图中的 “Memory mapped region for shared libraries”  区域，所以内存映射文件的区域并不在JVM GC的回收范围内，因为它本身就不属于堆区，卸载这部分区域只能通过系统调用 unmap()来实现 (Linux)中，而 JAVA API 只提供了 FileChannel.map 的形式创建内存映射区域，却没有提供对应的 unmap()。</p>\n<p>事实是由JVM帮助我们自动回收这部分内存，在定义这些类时，通过一个虚引用包裹这些创建的NIO对象，当JVM进行GC时检测指向这些内存映射或者直接内存的java对象是否被回收（java对象都是保存在堆上，只是对象中使用变量空间指向对外内存）。如果这些对象被回收，那么JVM就会自动的帮助我们回收这些堆外内存。具体参考：<a href=\"https://www.jianshu.com/p/007052ee3773\" target=\"_blank\" rel=\"noopener\">堆外内存 之 DirectByteBuffer 详解</a></p>\n<p>最后再试试通过 DirectMemory来操作前面 内存映射和基本通道操作的例子，来看看直接内存操作的话，程序的性能如何：</p>\n<pre><code>    @Test\n    public void directBufferTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n\n        ByteBuffer buff = ByteBuffer.allocateDirect(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;time is:&quot; + (end - begin));\n        in.close();\n    }\n</code></pre><p>程序输出为 130毫秒，看来比普通的NIO通道操作（160毫秒）来的快，但是比 mmap 内存映射的 30差距太多了，我想应该不至于吧，通过修改：</p>\n<pre><code>ByteBuffer buff = ByteBuffer.allocateDirect(1024);  \n//将上面语句修改如下\nByteBuffer buff = ByteBuffer.allocateDirect((int)file.length())，\n</code></pre><p>即一次性分配整个文件长度大小的堆外内存，最终输出为 78毫秒，由此可以得出两个结论：</p>\n<ol>\n<li><p>堆外内存的分配耗时比较大.  </p>\n</li>\n<li><p>还是比mmap内存映射来得慢，都不要说通过mmap读取数据的时候还涉及缺页异常、页面调度的系统调用了。</p>\n</li>\n</ol>\n<p>最后一点为 DirectMemory的内存只有在 JVM执行 full gc 的时候才会被回收，那么如果在其上分配过大的内存空间，那么也将出现 OutofMemoryError，即便 JVM 堆中的很多内存处于空闲状态。</p>\n<p> <strong>补充下额外的一个知识点，关于 JVM堆大小的设置是不受限于物理内存，而是受限于虚拟内存空间大小，理论上来说是进程的虚拟地址空间大小，但是实际上我们的虚拟内存空间是有限制的，一般windows上默认在C盘，大小为物理内存的2倍左右。我做了个实验：我机子是 64位的win7，那么理论上说进程虚拟空间是几乎无限大，物理内存为4G，而我设置 -Xms5000M， 即在启动JAVA程序的时候一次性申请到超过物理内存大小的5000M内存，程序正常启动，而当我加到 -Xms8000M的时候就报OOM错误了，然后我修改增加 win7的虚拟内存，程序又正常启动了，说明 -Xms 受限于虚拟内存的大小。我设置-Xms5000M，即超过了4G物理内存，并在一个死循环中不断创建对象，并保证不会被GC回收。程序运行一会后整个电脑几乎死机状态，即卡住了，反映很慢很慢，推测是发生了系统颠簸，即频繁的页面调度置换导致，说明 -Xms -Xmx不是局限于物理内存的大小，而是综合虚拟内存了，JVM会根据电脑虚拟内存的设置来控制。</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://blog.csdn.net/fcbayernmunchen/article/details/8635427\" target=\"_blank\" rel=\"noopener\">JAVA NIO之浅谈内存映射文件原理与DirectMemory</a></li>\n</ol>"},{"abbrlink":5,"title":" java多线程系列 03 线程等待与唤醒，线程休眠","author":"zhangke","date":"2018-07-13T03:08:00.000Z","_content":"# java多线程系列 03 线程等待与唤醒，线程休眠\n\n### 概要\n\n>1. wait(), notify(), notifyAll()等方法介绍\n>2. wait()和notify()示例\n>3. wait(long timeout)和notify()示例\n>4. wait() 和 notifyAll()\n>5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中\n>6. sleep()介绍与使用\n>7. sleep() 与 wait()的比较\n\n### 1. wait(), notify(), notifyAll()等方法介绍\n\n>在Object类中，定义了wait(), notify()和notifyAll()等接口。\n>\n>wait()的作用是让当前线程进入等待状态，**同时，wait()也会让当前线程释放它所持有的锁。**而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。\n>\n>Object类中关于等待/唤醒的API详细信息如下：\n>**notify()**        -- 唤醒在此对象监视器上等待的单个线程。\n>**notifyAll()**   -- 唤醒在此对象监视器上等待的所有线程。\n>**wait()**           -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。\n>**wait(long timeout)**   -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。\n>**wait(long timeout, int nanos)**  -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。\n\n### 2. wait()和notify()示例\n\n>代码如下:\n>\n>```java\n>class ThreadA extends Thread {\n>\n>    public ThreadA(String name) {\n>        super(name);\n>    }\n>\n>    public void run() {\n>        synchronized (this) {\n>            System.out.println(Thread.currentThread().getName() \n>                               \t\t+ \" call notify()\");\n>            // 唤醒当前的wait线程\n>            notify();\n>        }\n>    }\n>}\n>\n>public class WaitTest {\n>\n>    public static void main(String[] args) {\n>\n>        ThreadA t1 = new ThreadA(\"t1\");\n>        synchronized (t1) {\n>            try {\n>                // 启动“线程t1”\n>                System.out.println(Thread.currentThread().getName() + \" start t1\");\n>                t1.start();\n>\n>                // 主线程等待t1通过notify()唤醒。\n>                System.out.println(Thread.currentThread().getName() + \" wait()\");\n>                t1.wait();\n>\n>                System.out.println(Thread.currentThread().getName() + \" continue\");\n>            } catch (InterruptedException e) {\n>                e.printStackTrace();\n>            }\n>        }\n>    }\n>}\n>```\n>\n>**运行结果**:\n>\n>```\n>main start t1\n>main wait()\n>t1 call notify()\n>main continue\n>```\n>\n>**结果说明**：\n>如下图，说明了“主线程”和“线程t1”的流程。\n>\n>(01) 注意，图中\"主线程\" 代表“主线程main”。\"线程t1\" 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。\n>(02) “主线程”通过 new ThreadA(\"t1\") 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。\n>(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。\n>(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。\n>(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。\n>\n>![img](https://images0.cnblogs.com/blog/497634/201312/18183712-f04899f92aaa43b6a33a85fecfa60a9d.png)\n>\n>对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？\n>在解答该问题前，我们先看看jdk文档中关于wait的一段介绍：\n>\n>```\n>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. \n>In other words, this method behaves exactly as if it simply performs the call wait(0).\n>The current thread must own this object's monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object's monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.\n>```\n>\n>中文意思大概是：\n>\n>```\n>引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。\n>```\n>\n>注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！\n>这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！\n\n### **3. wait(long timeout)和notify()**\n\n>wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 \n>\n>下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。\n>\n>```\n>// WaitTimeoutTest.java的源码\n>class ThreadA extends Thread{\n>\n>    public ThreadA(String name) {\n>        super(name);\n>    }\n>\n>    public void run() {\n>        System.out.println(Thread.currentThread().getName() + \" run \");\n>        // 死循环，不断运行。\n>        while(true)\n>            ;\n>    }\n>}\n>\n>public class WaitTimeoutTest {\n>\n>    public static void main(String[] args) {\n>\n>        ThreadA t1 = new ThreadA(\"t1\");\n>\n>        synchronized(t1) {\n>            try {\n>                // 启动“线程t1”\n>                System.out.println(Thread.currentThread().getName() + \" start t1\");\n>                t1.start();\n>\n>       // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。\n>         System.out.println(Thread.currentThread().getName() + \" call wait \");\n>                t1.wait(3000);\n>\n>                System.out.println(Thread.currentThread().getName() + \" continue\");\n>            } catch (InterruptedException e) {\n>                e.printStackTrace();\n>            }\n>        }\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>main start t1\n>main call wait \n>t1 run                  // 大约3秒之后...输出“main continue”\n>main continue\n>```\n>\n>**结果说明**：\n>如下图，说明了“主线程”和“线程t1”的流程。\n>(01) 注意，图中\"主线程\" 代表WaitTimeoutTest主线程(即，线程main)。\"线程t1\" 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。\n>(02) 主线程main执行t1.start()启动“线程t1”。\n>(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。\n>(04) “线程t1”运行之后，进入了死循环，一直不断的运行。\n>(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。\n>\n>![img](https://images0.cnblogs.com/blog/497634/201312/18183848-d4c16bf2760847afa4fede6a9d959083.png)\n\n### **4. wait() 和 notifyAll()**\n\n>通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。\n>\n>下面，我们通过示例演示notifyAll()的用法；它的作用是唤醒在此对象监视器上等待的所有线程。\n>\n>```\n>public class NotifyAllTest {\n>\n>    private static Object obj = new Object();\n>\n>    public static void main(String[] args) {\n>\n>        ThreadA t1 = new ThreadA(\"t1\");\n>        ThreadA t2 = new ThreadA(\"t2\");\n>        ThreadA t3 = new ThreadA(\"t3\");\n>        t1.start();\n>        t2.start();\n>        t3.start();\n>\n>        try {\n>            System.out.println(Thread.currentThread().getName() + \" sleep(3000)\");\n>            Thread.sleep(3000);\n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>\n>        synchronized (obj) {\n>            // 主线程等待唤醒。\n>            System.out.println(Thread.currentThread().getName() + \" notifyAll()\");\n>            obj.notifyAll();\n>        }\n>    }\n>\n>    static class ThreadA extends Thread {\n>\n>        public ThreadA(String name) {\n>            super(name);\n>        }\n>\n>        public void run() {\n>            synchronized (obj) {\n>                try {\n>                    // 打印输出结果\n>                    System.out.println(Thread.currentThread().getName() + \" wait\");\n>\n>                    // 唤醒当前的wait线程\n>                    obj.wait();\n>\n>                    // 打印输出结果\n>                    System.out.println(Thread.currentThread().getName() \n>                    \t\t+ \" continue\");\n>                } catch (InterruptedException e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        }\n>    }\n>}\n>```\n>\n>运行结果\n>\n>```\n>t1 wait\n>main sleep(3000)\n>t3 wait\n>t2 wait\n>main notifyAll()\n>t2 continue\n>t3 continue\n>t1 continue\n>```\n>\n>**结果说明**：\n>参考下面的流程图。 \n>(01) 主线程中新建并且启动了3个线程\"t1\", \"t2\"和\"t3\"。\n>(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设\"t1\", \"t2\"和\"t3\"这3个线程都运行了。以\"t1\"为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，\"t2\"和\"t3\"也会等待其它线程通过nofity()或nofityAll()来唤醒它们。\n>(03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒\"t1\", \"t2\"和\"t3\"这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，\"t1\", \"t2\"和\"t3\"就可以获取“obj锁”而继续运行了！\n>\n>![img](https://images0.cnblogs.com/blog/497634/201312/18183923-95275c066212410f96181704a681f453.png)\n>\n>**需要注意的一点是：notifyAll会唤醒所有等待获取此对象的线程，他们会彼此竞争，但是他们已经退出了等待，但是由于同步锁的原因，因此同一时刻只会有一个线程获取到锁，所以也只有一个线程会运行，但最终所有的线程都是依次获取到锁，接着运行**\n\n### **5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中**\n\n>Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。\n>\n>wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！\n>OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。\n>\n>负责唤醒等待线程的那个线程(我们称为“**唤醒线程**”)，它只有在获取“该对象的同步锁”(**这里的同步锁必须和等待线程的同步锁是同一个**)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。\n>\n>总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。\n\n### 6. sleep()介绍与使用\n\n>sleep() 定义在Thread.java中。 sleep() 的作用是让当前线程休眠，即当前线程会从**运行状态**进入到**休眠(阻塞)状态**。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由**阻塞状态**变成**就绪状态**，从而等待cpu的调度执行。\n>\n>下面是一个简单的demo\n>\n>```\n>// SleepTest.java的源码\n>class ThreadA extends Thread{\n>    public ThreadA(String name){ \n>        super(name); \n>    } \n>    public synchronized void run() { \n>        try {\n>            for(int i=0; i <10; i++){ \n>                System.out.printf(\"%s: %d\\n\", this.getName(), i); \n>                // i能被4整除时，休眠100毫秒\n>                if (i%4 == 0)\n>                    Thread.sleep(100);\n>            } \n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>    } \n>} \n>\n>public class SleepTest{ \n>    public static void main(String[] args){ \n>        ThreadA t1 = new ThreadA(\"t1\"); \n>        t1.start(); \n>    } \n>}\n>```\n>\n>运行结果:\n>\n>```\n>t1: 0\n>t1: 1\n>t1: 2\n>t1: 3\n>t1: 4\n>t1: 5\n>t1: 6\n>t1: 7\n>t1: 8\n>t1: 9\n>```\n>\n>**结果说明**： 程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(100)休眠100毫秒。\n>\n>\n\n### **7. sleep() 与 wait()的比较**\n\n>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。 但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。\n>\n>\u0010 下面通过示例演示sleep()是不会释放锁的。\n>\n>```\n>public class SleepLockTest {\n>\n>    private static Object obj = new Object();\n>\n>    public static void main(String[] args) {\n>        ThreadA t1 = new ThreadA(\"t1\");\n>        ThreadA t2 = new ThreadA(\"t2\");\n>        t1.start();\n>        t2.start();\n>    }\n>\n>    static class ThreadA extends Thread {\n>        public ThreadA(String name) {\n>            super(name);\n>        }\n>\n>        public void run() {\n>            // 获取obj对象的同步锁\n>            synchronized (obj) {\n>                try {\n>                    for (int i = 0; i < 10; i++) {\n>                        System.out.printf(\"%s: %d\\n\", this.getName(), i);\n>                        // i能被4整除时，休眠100毫秒\n>                        if (i % 4 == 0)\n>                            Thread.sleep(100);\n>                    }\n>                } catch (InterruptedException e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        }\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1: 0\n>t1: 1\n>t1: 2\n>t1: 3\n>t1: 4\n>t1: 5\n>t1: 6\n>t1: 7\n>t1: 8\n>t1: 9\n>t2: 0\n>t2: 1\n>t2: 2\n>t2: 3\n>t2: 4\n>t2: 5\n>t2: 6\n>t2: 7\n>t2: 8\n>t2: 9\n>```\n>\n>**结果说明**： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.sleep(100)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！ 注意，若我们注释掉synchronized (obj)后再次执行该程序，t1和t2是可以相互切换的。","source":"_posts/threads/java多线程系列 03 线程等待与唤醒，线程休眠.md","raw":"abbrlink: 5\ntitle: ' java多线程系列 03 线程等待与唤醒，线程休眠'\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-13 11:08:00\n---\n# java多线程系列 03 线程等待与唤醒，线程休眠\n\n### 概要\n\n>1. wait(), notify(), notifyAll()等方法介绍\n>2. wait()和notify()示例\n>3. wait(long timeout)和notify()示例\n>4. wait() 和 notifyAll()\n>5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中\n>6. sleep()介绍与使用\n>7. sleep() 与 wait()的比较\n\n### 1. wait(), notify(), notifyAll()等方法介绍\n\n>在Object类中，定义了wait(), notify()和notifyAll()等接口。\n>\n>wait()的作用是让当前线程进入等待状态，**同时，wait()也会让当前线程释放它所持有的锁。**而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。\n>\n>Object类中关于等待/唤醒的API详细信息如下：\n>**notify()**        -- 唤醒在此对象监视器上等待的单个线程。\n>**notifyAll()**   -- 唤醒在此对象监视器上等待的所有线程。\n>**wait()**           -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。\n>**wait(long timeout)**   -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。\n>**wait(long timeout, int nanos)**  -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。\n\n### 2. wait()和notify()示例\n\n>代码如下:\n>\n>```java\n>class ThreadA extends Thread {\n>\n>    public ThreadA(String name) {\n>        super(name);\n>    }\n>\n>    public void run() {\n>        synchronized (this) {\n>            System.out.println(Thread.currentThread().getName() \n>                               \t\t+ \" call notify()\");\n>            // 唤醒当前的wait线程\n>            notify();\n>        }\n>    }\n>}\n>\n>public class WaitTest {\n>\n>    public static void main(String[] args) {\n>\n>        ThreadA t1 = new ThreadA(\"t1\");\n>        synchronized (t1) {\n>            try {\n>                // 启动“线程t1”\n>                System.out.println(Thread.currentThread().getName() + \" start t1\");\n>                t1.start();\n>\n>                // 主线程等待t1通过notify()唤醒。\n>                System.out.println(Thread.currentThread().getName() + \" wait()\");\n>                t1.wait();\n>\n>                System.out.println(Thread.currentThread().getName() + \" continue\");\n>            } catch (InterruptedException e) {\n>                e.printStackTrace();\n>            }\n>        }\n>    }\n>}\n>```\n>\n>**运行结果**:\n>\n>```\n>main start t1\n>main wait()\n>t1 call notify()\n>main continue\n>```\n>\n>**结果说明**：\n>如下图，说明了“主线程”和“线程t1”的流程。\n>\n>(01) 注意，图中\"主线程\" 代表“主线程main”。\"线程t1\" 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。\n>(02) “主线程”通过 new ThreadA(\"t1\") 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。\n>(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。\n>(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。\n>(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。\n>\n>![img](https://images0.cnblogs.com/blog/497634/201312/18183712-f04899f92aaa43b6a33a85fecfa60a9d.png)\n>\n>对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？\n>在解答该问题前，我们先看看jdk文档中关于wait的一段介绍：\n>\n>```\n>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. \n>In other words, this method behaves exactly as if it simply performs the call wait(0).\n>The current thread must own this object's monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object's monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.\n>```\n>\n>中文意思大概是：\n>\n>```\n>引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。\n>```\n>\n>注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！\n>这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！\n\n### **3. wait(long timeout)和notify()**\n\n>wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 \n>\n>下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。\n>\n>```\n>// WaitTimeoutTest.java的源码\n>class ThreadA extends Thread{\n>\n>    public ThreadA(String name) {\n>        super(name);\n>    }\n>\n>    public void run() {\n>        System.out.println(Thread.currentThread().getName() + \" run \");\n>        // 死循环，不断运行。\n>        while(true)\n>            ;\n>    }\n>}\n>\n>public class WaitTimeoutTest {\n>\n>    public static void main(String[] args) {\n>\n>        ThreadA t1 = new ThreadA(\"t1\");\n>\n>        synchronized(t1) {\n>            try {\n>                // 启动“线程t1”\n>                System.out.println(Thread.currentThread().getName() + \" start t1\");\n>                t1.start();\n>\n>       // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。\n>         System.out.println(Thread.currentThread().getName() + \" call wait \");\n>                t1.wait(3000);\n>\n>                System.out.println(Thread.currentThread().getName() + \" continue\");\n>            } catch (InterruptedException e) {\n>                e.printStackTrace();\n>            }\n>        }\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>main start t1\n>main call wait \n>t1 run                  // 大约3秒之后...输出“main continue”\n>main continue\n>```\n>\n>**结果说明**：\n>如下图，说明了“主线程”和“线程t1”的流程。\n>(01) 注意，图中\"主线程\" 代表WaitTimeoutTest主线程(即，线程main)。\"线程t1\" 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。\n>(02) 主线程main执行t1.start()启动“线程t1”。\n>(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。\n>(04) “线程t1”运行之后，进入了死循环，一直不断的运行。\n>(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。\n>\n>![img](https://images0.cnblogs.com/blog/497634/201312/18183848-d4c16bf2760847afa4fede6a9d959083.png)\n\n### **4. wait() 和 notifyAll()**\n\n>通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。\n>\n>下面，我们通过示例演示notifyAll()的用法；它的作用是唤醒在此对象监视器上等待的所有线程。\n>\n>```\n>public class NotifyAllTest {\n>\n>    private static Object obj = new Object();\n>\n>    public static void main(String[] args) {\n>\n>        ThreadA t1 = new ThreadA(\"t1\");\n>        ThreadA t2 = new ThreadA(\"t2\");\n>        ThreadA t3 = new ThreadA(\"t3\");\n>        t1.start();\n>        t2.start();\n>        t3.start();\n>\n>        try {\n>            System.out.println(Thread.currentThread().getName() + \" sleep(3000)\");\n>            Thread.sleep(3000);\n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>\n>        synchronized (obj) {\n>            // 主线程等待唤醒。\n>            System.out.println(Thread.currentThread().getName() + \" notifyAll()\");\n>            obj.notifyAll();\n>        }\n>    }\n>\n>    static class ThreadA extends Thread {\n>\n>        public ThreadA(String name) {\n>            super(name);\n>        }\n>\n>        public void run() {\n>            synchronized (obj) {\n>                try {\n>                    // 打印输出结果\n>                    System.out.println(Thread.currentThread().getName() + \" wait\");\n>\n>                    // 唤醒当前的wait线程\n>                    obj.wait();\n>\n>                    // 打印输出结果\n>                    System.out.println(Thread.currentThread().getName() \n>                    \t\t+ \" continue\");\n>                } catch (InterruptedException e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        }\n>    }\n>}\n>```\n>\n>运行结果\n>\n>```\n>t1 wait\n>main sleep(3000)\n>t3 wait\n>t2 wait\n>main notifyAll()\n>t2 continue\n>t3 continue\n>t1 continue\n>```\n>\n>**结果说明**：\n>参考下面的流程图。 \n>(01) 主线程中新建并且启动了3个线程\"t1\", \"t2\"和\"t3\"。\n>(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设\"t1\", \"t2\"和\"t3\"这3个线程都运行了。以\"t1\"为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，\"t2\"和\"t3\"也会等待其它线程通过nofity()或nofityAll()来唤醒它们。\n>(03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒\"t1\", \"t2\"和\"t3\"这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，\"t1\", \"t2\"和\"t3\"就可以获取“obj锁”而继续运行了！\n>\n>![img](https://images0.cnblogs.com/blog/497634/201312/18183923-95275c066212410f96181704a681f453.png)\n>\n>**需要注意的一点是：notifyAll会唤醒所有等待获取此对象的线程，他们会彼此竞争，但是他们已经退出了等待，但是由于同步锁的原因，因此同一时刻只会有一个线程获取到锁，所以也只有一个线程会运行，但最终所有的线程都是依次获取到锁，接着运行**\n\n### **5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中**\n\n>Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。\n>\n>wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！\n>OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。\n>\n>负责唤醒等待线程的那个线程(我们称为“**唤醒线程**”)，它只有在获取“该对象的同步锁”(**这里的同步锁必须和等待线程的同步锁是同一个**)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。\n>\n>总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。\n\n### 6. sleep()介绍与使用\n\n>sleep() 定义在Thread.java中。 sleep() 的作用是让当前线程休眠，即当前线程会从**运行状态**进入到**休眠(阻塞)状态**。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由**阻塞状态**变成**就绪状态**，从而等待cpu的调度执行。\n>\n>下面是一个简单的demo\n>\n>```\n>// SleepTest.java的源码\n>class ThreadA extends Thread{\n>    public ThreadA(String name){ \n>        super(name); \n>    } \n>    public synchronized void run() { \n>        try {\n>            for(int i=0; i <10; i++){ \n>                System.out.printf(\"%s: %d\\n\", this.getName(), i); \n>                // i能被4整除时，休眠100毫秒\n>                if (i%4 == 0)\n>                    Thread.sleep(100);\n>            } \n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>    } \n>} \n>\n>public class SleepTest{ \n>    public static void main(String[] args){ \n>        ThreadA t1 = new ThreadA(\"t1\"); \n>        t1.start(); \n>    } \n>}\n>```\n>\n>运行结果:\n>\n>```\n>t1: 0\n>t1: 1\n>t1: 2\n>t1: 3\n>t1: 4\n>t1: 5\n>t1: 6\n>t1: 7\n>t1: 8\n>t1: 9\n>```\n>\n>**结果说明**： 程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(100)休眠100毫秒。\n>\n>\n\n### **7. sleep() 与 wait()的比较**\n\n>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。 但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。\n>\n>\u0010 下面通过示例演示sleep()是不会释放锁的。\n>\n>```\n>public class SleepLockTest {\n>\n>    private static Object obj = new Object();\n>\n>    public static void main(String[] args) {\n>        ThreadA t1 = new ThreadA(\"t1\");\n>        ThreadA t2 = new ThreadA(\"t2\");\n>        t1.start();\n>        t2.start();\n>    }\n>\n>    static class ThreadA extends Thread {\n>        public ThreadA(String name) {\n>            super(name);\n>        }\n>\n>        public void run() {\n>            // 获取obj对象的同步锁\n>            synchronized (obj) {\n>                try {\n>                    for (int i = 0; i < 10; i++) {\n>                        System.out.printf(\"%s: %d\\n\", this.getName(), i);\n>                        // i能被4整除时，休眠100毫秒\n>                        if (i % 4 == 0)\n>                            Thread.sleep(100);\n>                    }\n>                } catch (InterruptedException e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        }\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1: 0\n>t1: 1\n>t1: 2\n>t1: 3\n>t1: 4\n>t1: 5\n>t1: 6\n>t1: 7\n>t1: 8\n>t1: 9\n>t2: 0\n>t2: 1\n>t2: 2\n>t2: 3\n>t2: 4\n>t2: 5\n>t2: 6\n>t2: 7\n>t2: 8\n>t2: 9\n>```\n>\n>**结果说明**： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.sleep(100)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！ 注意，若我们注释掉synchronized (obj)后再次执行该程序，t1和t2是可以相互切换的。","slug":"threads/java多线程系列 03 线程等待与唤醒，线程休眠","published":1,"updated":"2019-01-04T01:48:59.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovt9002v9q1uc7dvaoga","content":"<h1 id=\"java多线程系列-03-线程等待与唤醒，线程休眠\"><a href=\"#java多线程系列-03-线程等待与唤醒，线程休眠\" class=\"headerlink\" title=\"java多线程系列 03 线程等待与唤醒，线程休眠\"></a>java多线程系列 03 线程等待与唤醒，线程休眠</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>wait(), notify(), notifyAll()等方法介绍</li>\n<li>wait()和notify()示例</li>\n<li>wait(long timeout)和notify()示例</li>\n<li>wait() 和 notifyAll()</li>\n<li>为什么notify(), wait()等函数定义在Object中，而不是Thread中</li>\n<li>sleep()介绍与使用</li>\n<li>sleep() 与 wait()的比较</li>\n</ol>\n</blockquote>\n<h3 id=\"1-wait-notify-notifyAll-等方法介绍\"><a href=\"#1-wait-notify-notifyAll-等方法介绍\" class=\"headerlink\" title=\"1. wait(), notify(), notifyAll()等方法介绍\"></a>1. wait(), notify(), notifyAll()等方法介绍</h3><blockquote>\n<p>在Object类中，定义了wait(), notify()和notifyAll()等接口。</p>\n<p>wait()的作用是让当前线程进入等待状态，<strong>同时，wait()也会让当前线程释放它所持有的锁。</strong>而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。</p>\n<p>Object类中关于等待/唤醒的API详细信息如下：<br><strong>notify()</strong>        – 唤醒在此对象监视器上等待的单个线程。<br><strong>notifyAll()</strong>   – 唤醒在此对象监视器上等待的所有线程。<br><strong>wait()</strong>           – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。<br><strong>wait(long timeout)</strong>   – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。<br><strong>wait(long timeout, int nanos)</strong>  – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</p>\n</blockquote>\n<h3 id=\"2-wait-和notify-示例\"><a href=\"#2-wait-和notify-示例\" class=\"headerlink\" title=\"2. wait()和notify()示例\"></a>2. wait()和notify()示例</h3><blockquote>\n<p>代码如下:</p>\n<pre><code class=\"java\">class ThreadA extends Thread {\n\n   public ThreadA(String name) {\n       super(name);\n   }\n\n   public void run() {\n       synchronized (this) {\n           System.out.println(Thread.currentThread().getName() \n                                      + &quot; call notify()&quot;);\n           // 唤醒当前的wait线程\n           notify();\n       }\n   }\n}\n\npublic class WaitTest {\n\n   public static void main(String[] args) {\n\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n       synchronized (t1) {\n           try {\n               // 启动“线程t1”\n               System.out.println(Thread.currentThread().getName() + &quot; start t1&quot;);\n               t1.start();\n\n               // 主线程等待t1通过notify()唤醒。\n               System.out.println(Thread.currentThread().getName() + &quot; wait()&quot;);\n               t1.wait();\n\n               System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n}\n</code></pre>\n<p><strong>运行结果</strong>:</p>\n<pre><code>main start t1\nmain wait()\nt1 call notify()\nmain continue\n</code></pre><p><strong>结果说明</strong>：<br>如下图，说明了“主线程”和“线程t1”的流程。</p>\n<p>(01) 注意，图中”主线程” 代表“主线程main”。”线程t1” 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。<br>(02) “主线程”通过 new ThreadA(“t1”) 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。<br>(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。<br>(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。<br>(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18183712-f04899f92aaa43b6a33a85fecfa60a9d.png\" alt=\"img\"></p>\n<p>对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？<br>在解答该问题前，我们先看看jdk文档中关于wait的一段介绍：</p>\n<pre><code>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. \nIn other words, this method behaves exactly as if it simply performs the call wait(0).\nThe current thread must own this object&#39;s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object&#39;s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.\n</code></pre><p>中文意思大概是：</p>\n<pre><code>引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。\n</code></pre><p>注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！<br>这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！</p>\n</blockquote>\n<h3 id=\"3-wait-long-timeout-和notify\"><a href=\"#3-wait-long-timeout-和notify\" class=\"headerlink\" title=\"3. wait(long timeout)和notify()\"></a><strong>3. wait(long timeout)和notify()</strong></h3><blockquote>\n<p>wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 </p>\n<p>下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。</p>\n<pre><code>// WaitTimeoutTest.java的源码\nclass ThreadA extends Thread{\n\n   public ThreadA(String name) {\n       super(name);\n   }\n\n   public void run() {\n       System.out.println(Thread.currentThread().getName() + &quot; run &quot;);\n       // 死循环，不断运行。\n       while(true)\n           ;\n   }\n}\n\npublic class WaitTimeoutTest {\n\n   public static void main(String[] args) {\n\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n\n       synchronized(t1) {\n           try {\n               // 启动“线程t1”\n               System.out.println(Thread.currentThread().getName() + &quot; start t1&quot;);\n               t1.start();\n\n      // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。\n        System.out.println(Thread.currentThread().getName() + &quot; call wait &quot;);\n               t1.wait(3000);\n\n               System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>main start t1\nmain call wait \nt1 run                  // 大约3秒之后...输出“main continue”\nmain continue\n</code></pre><p><strong>结果说明</strong>：<br>如下图，说明了“主线程”和“线程t1”的流程。<br>(01) 注意，图中”主线程” 代表WaitTimeoutTest主线程(即，线程main)。”线程t1” 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。<br>(02) 主线程main执行t1.start()启动“线程t1”。<br>(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。<br>(04) “线程t1”运行之后，进入了死循环，一直不断的运行。<br>(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18183848-d4c16bf2760847afa4fede6a9d959083.png\" alt=\"img\"></p>\n</blockquote>\n<h3 id=\"4-wait-和-notifyAll\"><a href=\"#4-wait-和-notifyAll\" class=\"headerlink\" title=\"4. wait() 和 notifyAll()\"></a><strong>4. wait() 和 notifyAll()</strong></h3><blockquote>\n<p>通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。</p>\n<p>下面，我们通过示例演示notifyAll()的用法；它的作用是唤醒在此对象监视器上等待的所有线程。</p>\n<pre><code>public class NotifyAllTest {\n\n   private static Object obj = new Object();\n\n   public static void main(String[] args) {\n\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n       ThreadA t2 = new ThreadA(&quot;t2&quot;);\n       ThreadA t3 = new ThreadA(&quot;t3&quot;);\n       t1.start();\n       t2.start();\n       t3.start();\n\n       try {\n           System.out.println(Thread.currentThread().getName() + &quot; sleep(3000)&quot;);\n           Thread.sleep(3000);\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n       synchronized (obj) {\n           // 主线程等待唤醒。\n           System.out.println(Thread.currentThread().getName() + &quot; notifyAll()&quot;);\n           obj.notifyAll();\n       }\n   }\n\n   static class ThreadA extends Thread {\n\n       public ThreadA(String name) {\n           super(name);\n       }\n\n       public void run() {\n           synchronized (obj) {\n               try {\n                   // 打印输出结果\n                   System.out.println(Thread.currentThread().getName() + &quot; wait&quot;);\n\n                   // 唤醒当前的wait线程\n                   obj.wait();\n\n                   // 打印输出结果\n                   System.out.println(Thread.currentThread().getName() \n                           + &quot; continue&quot;);\n               } catch (InterruptedException e) {\n                   e.printStackTrace();\n               }\n           }\n       }\n   }\n}\n</code></pre><p>运行结果</p>\n<pre><code>t1 wait\nmain sleep(3000)\nt3 wait\nt2 wait\nmain notifyAll()\nt2 continue\nt3 continue\nt1 continue\n</code></pre><p><strong>结果说明</strong>：<br>参考下面的流程图。<br>(01) 主线程中新建并且启动了3个线程”t1”, “t2”和”t3”。<br>(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设”t1”, “t2”和”t3”这3个线程都运行了。以”t1”为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，”t2”和”t3”也会等待其它线程通过nofity()或nofityAll()来唤醒它们。<br>(03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒”t1”, “t2”和”t3”这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，”t1”, “t2”和”t3”就可以获取“obj锁”而继续运行了！</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18183923-95275c066212410f96181704a681f453.png\" alt=\"img\"></p>\n<p><strong>需要注意的一点是：notifyAll会唤醒所有等待获取此对象的线程，他们会彼此竞争，但是他们已经退出了等待，但是由于同步锁的原因，因此同一时刻只会有一个线程获取到锁，所以也只有一个线程会运行，但最终所有的线程都是依次获取到锁，接着运行</strong></p>\n</blockquote>\n<h3 id=\"5-为什么notify-wait-等函数定义在Object中，而不是Thread中\"><a href=\"#5-为什么notify-wait-等函数定义在Object中，而不是Thread中\" class=\"headerlink\" title=\"5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中\"></a><strong>5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中</strong></h3><blockquote>\n<p>Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。</p>\n<p>wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！<br>OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。</p>\n<p>负责唤醒等待线程的那个线程(我们称为“<strong>唤醒线程</strong>”)，它只有在获取“该对象的同步锁”(<strong>这里的同步锁必须和等待线程的同步锁是同一个</strong>)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p>\n<p>总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。</p>\n</blockquote>\n<h3 id=\"6-sleep-介绍与使用\"><a href=\"#6-sleep-介绍与使用\" class=\"headerlink\" title=\"6. sleep()介绍与使用\"></a>6. sleep()介绍与使用</h3><blockquote>\n<p>sleep() 定义在Thread.java中。 sleep() 的作用是让当前线程休眠，即当前线程会从<strong>运行状态</strong>进入到<strong>休眠(阻塞)状态</strong>。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由<strong>阻塞状态</strong>变成<strong>就绪状态</strong>，从而等待cpu的调度执行。</p>\n<p>下面是一个简单的demo</p>\n<pre><code>// SleepTest.java的源码\nclass ThreadA extends Thread{\n   public ThreadA(String name){ \n       super(name); \n   } \n   public synchronized void run() { \n       try {\n           for(int i=0; i &lt;10; i++){ \n               System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i); \n               // i能被4整除时，休眠100毫秒\n               if (i%4 == 0)\n                   Thread.sleep(100);\n           } \n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n   } \n} \n\npublic class SleepTest{ \n   public static void main(String[] args){ \n       ThreadA t1 = new ThreadA(&quot;t1&quot;); \n       t1.start(); \n   } \n}\n</code></pre><p>运行结果:</p>\n<pre><code>t1: 0\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt1: 5\nt1: 6\nt1: 7\nt1: 8\nt1: 9\n</code></pre><p><strong>结果说明</strong>： 程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(100)休眠100毫秒。</p>\n</blockquote>\n<h3 id=\"7-sleep-与-wait-的比较\"><a href=\"#7-sleep-与-wait-的比较\" class=\"headerlink\" title=\"7. sleep() 与 wait()的比较\"></a><strong>7. sleep() 与 wait()的比较</strong></h3><blockquote>\n<p>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。 但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。</p>\n<p>\u0010 下面通过示例演示sleep()是不会释放锁的。</p>\n<pre><code>public class SleepLockTest {\n\n   private static Object obj = new Object();\n\n   public static void main(String[] args) {\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n       ThreadA t2 = new ThreadA(&quot;t2&quot;);\n       t1.start();\n       t2.start();\n   }\n\n   static class ThreadA extends Thread {\n       public ThreadA(String name) {\n           super(name);\n       }\n\n       public void run() {\n           // 获取obj对象的同步锁\n           synchronized (obj) {\n               try {\n                   for (int i = 0; i &lt; 10; i++) {\n                       System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i);\n                       // i能被4整除时，休眠100毫秒\n                       if (i % 4 == 0)\n                           Thread.sleep(100);\n                   }\n               } catch (InterruptedException e) {\n                   e.printStackTrace();\n               }\n           }\n       }\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1: 0\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt1: 5\nt1: 6\nt1: 7\nt1: 8\nt1: 9\nt2: 0\nt2: 1\nt2: 2\nt2: 3\nt2: 4\nt2: 5\nt2: 6\nt2: 7\nt2: 8\nt2: 9\n</code></pre><p><strong>结果说明</strong>： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.sleep(100)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！ 注意，若我们注释掉synchronized (obj)后再次执行该程序，t1和t2是可以相互切换的。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-03-线程等待与唤醒，线程休眠\"><a href=\"#java多线程系列-03-线程等待与唤醒，线程休眠\" class=\"headerlink\" title=\"java多线程系列 03 线程等待与唤醒，线程休眠\"></a>java多线程系列 03 线程等待与唤醒，线程休眠</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>wait(), notify(), notifyAll()等方法介绍</li>\n<li>wait()和notify()示例</li>\n<li>wait(long timeout)和notify()示例</li>\n<li>wait() 和 notifyAll()</li>\n<li>为什么notify(), wait()等函数定义在Object中，而不是Thread中</li>\n<li>sleep()介绍与使用</li>\n<li>sleep() 与 wait()的比较</li>\n</ol>\n</blockquote>\n<h3 id=\"1-wait-notify-notifyAll-等方法介绍\"><a href=\"#1-wait-notify-notifyAll-等方法介绍\" class=\"headerlink\" title=\"1. wait(), notify(), notifyAll()等方法介绍\"></a>1. wait(), notify(), notifyAll()等方法介绍</h3><blockquote>\n<p>在Object类中，定义了wait(), notify()和notifyAll()等接口。</p>\n<p>wait()的作用是让当前线程进入等待状态，<strong>同时，wait()也会让当前线程释放它所持有的锁。</strong>而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。</p>\n<p>Object类中关于等待/唤醒的API详细信息如下：<br><strong>notify()</strong>        – 唤醒在此对象监视器上等待的单个线程。<br><strong>notifyAll()</strong>   – 唤醒在此对象监视器上等待的所有线程。<br><strong>wait()</strong>           – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。<br><strong>wait(long timeout)</strong>   – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。<br><strong>wait(long timeout, int nanos)</strong>  – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</p>\n</blockquote>\n<h3 id=\"2-wait-和notify-示例\"><a href=\"#2-wait-和notify-示例\" class=\"headerlink\" title=\"2. wait()和notify()示例\"></a>2. wait()和notify()示例</h3><blockquote>\n<p>代码如下:</p>\n<pre><code class=\"java\">class ThreadA extends Thread {\n\n   public ThreadA(String name) {\n       super(name);\n   }\n\n   public void run() {\n       synchronized (this) {\n           System.out.println(Thread.currentThread().getName() \n                                      + &quot; call notify()&quot;);\n           // 唤醒当前的wait线程\n           notify();\n       }\n   }\n}\n\npublic class WaitTest {\n\n   public static void main(String[] args) {\n\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n       synchronized (t1) {\n           try {\n               // 启动“线程t1”\n               System.out.println(Thread.currentThread().getName() + &quot; start t1&quot;);\n               t1.start();\n\n               // 主线程等待t1通过notify()唤醒。\n               System.out.println(Thread.currentThread().getName() + &quot; wait()&quot;);\n               t1.wait();\n\n               System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n}\n</code></pre>\n<p><strong>运行结果</strong>:</p>\n<pre><code>main start t1\nmain wait()\nt1 call notify()\nmain continue\n</code></pre><p><strong>结果说明</strong>：<br>如下图，说明了“主线程”和“线程t1”的流程。</p>\n<p>(01) 注意，图中”主线程” 代表“主线程main”。”线程t1” 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。<br>(02) “主线程”通过 new ThreadA(“t1”) 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。<br>(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。<br>(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。<br>(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18183712-f04899f92aaa43b6a33a85fecfa60a9d.png\" alt=\"img\"></p>\n<p>对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？<br>在解答该问题前，我们先看看jdk文档中关于wait的一段介绍：</p>\n<pre><code>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. \nIn other words, this method behaves exactly as if it simply performs the call wait(0).\nThe current thread must own this object&#39;s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object&#39;s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.\n</code></pre><p>中文意思大概是：</p>\n<pre><code>引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。\n</code></pre><p>注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！<br>这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！</p>\n</blockquote>\n<h3 id=\"3-wait-long-timeout-和notify\"><a href=\"#3-wait-long-timeout-和notify\" class=\"headerlink\" title=\"3. wait(long timeout)和notify()\"></a><strong>3. wait(long timeout)和notify()</strong></h3><blockquote>\n<p>wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 </p>\n<p>下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。</p>\n<pre><code>// WaitTimeoutTest.java的源码\nclass ThreadA extends Thread{\n\n   public ThreadA(String name) {\n       super(name);\n   }\n\n   public void run() {\n       System.out.println(Thread.currentThread().getName() + &quot; run &quot;);\n       // 死循环，不断运行。\n       while(true)\n           ;\n   }\n}\n\npublic class WaitTimeoutTest {\n\n   public static void main(String[] args) {\n\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n\n       synchronized(t1) {\n           try {\n               // 启动“线程t1”\n               System.out.println(Thread.currentThread().getName() + &quot; start t1&quot;);\n               t1.start();\n\n      // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。\n        System.out.println(Thread.currentThread().getName() + &quot; call wait &quot;);\n               t1.wait(3000);\n\n               System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>main start t1\nmain call wait \nt1 run                  // 大约3秒之后...输出“main continue”\nmain continue\n</code></pre><p><strong>结果说明</strong>：<br>如下图，说明了“主线程”和“线程t1”的流程。<br>(01) 注意，图中”主线程” 代表WaitTimeoutTest主线程(即，线程main)。”线程t1” 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。<br>(02) 主线程main执行t1.start()启动“线程t1”。<br>(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。<br>(04) “线程t1”运行之后，进入了死循环，一直不断的运行。<br>(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18183848-d4c16bf2760847afa4fede6a9d959083.png\" alt=\"img\"></p>\n</blockquote>\n<h3 id=\"4-wait-和-notifyAll\"><a href=\"#4-wait-和-notifyAll\" class=\"headerlink\" title=\"4. wait() 和 notifyAll()\"></a><strong>4. wait() 和 notifyAll()</strong></h3><blockquote>\n<p>通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。</p>\n<p>下面，我们通过示例演示notifyAll()的用法；它的作用是唤醒在此对象监视器上等待的所有线程。</p>\n<pre><code>public class NotifyAllTest {\n\n   private static Object obj = new Object();\n\n   public static void main(String[] args) {\n\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n       ThreadA t2 = new ThreadA(&quot;t2&quot;);\n       ThreadA t3 = new ThreadA(&quot;t3&quot;);\n       t1.start();\n       t2.start();\n       t3.start();\n\n       try {\n           System.out.println(Thread.currentThread().getName() + &quot; sleep(3000)&quot;);\n           Thread.sleep(3000);\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n       synchronized (obj) {\n           // 主线程等待唤醒。\n           System.out.println(Thread.currentThread().getName() + &quot; notifyAll()&quot;);\n           obj.notifyAll();\n       }\n   }\n\n   static class ThreadA extends Thread {\n\n       public ThreadA(String name) {\n           super(name);\n       }\n\n       public void run() {\n           synchronized (obj) {\n               try {\n                   // 打印输出结果\n                   System.out.println(Thread.currentThread().getName() + &quot; wait&quot;);\n\n                   // 唤醒当前的wait线程\n                   obj.wait();\n\n                   // 打印输出结果\n                   System.out.println(Thread.currentThread().getName() \n                           + &quot; continue&quot;);\n               } catch (InterruptedException e) {\n                   e.printStackTrace();\n               }\n           }\n       }\n   }\n}\n</code></pre><p>运行结果</p>\n<pre><code>t1 wait\nmain sleep(3000)\nt3 wait\nt2 wait\nmain notifyAll()\nt2 continue\nt3 continue\nt1 continue\n</code></pre><p><strong>结果说明</strong>：<br>参考下面的流程图。<br>(01) 主线程中新建并且启动了3个线程”t1”, “t2”和”t3”。<br>(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设”t1”, “t2”和”t3”这3个线程都运行了。以”t1”为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，”t2”和”t3”也会等待其它线程通过nofity()或nofityAll()来唤醒它们。<br>(03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒”t1”, “t2”和”t3”这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，”t1”, “t2”和”t3”就可以获取“obj锁”而继续运行了！</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18183923-95275c066212410f96181704a681f453.png\" alt=\"img\"></p>\n<p><strong>需要注意的一点是：notifyAll会唤醒所有等待获取此对象的线程，他们会彼此竞争，但是他们已经退出了等待，但是由于同步锁的原因，因此同一时刻只会有一个线程获取到锁，所以也只有一个线程会运行，但最终所有的线程都是依次获取到锁，接着运行</strong></p>\n</blockquote>\n<h3 id=\"5-为什么notify-wait-等函数定义在Object中，而不是Thread中\"><a href=\"#5-为什么notify-wait-等函数定义在Object中，而不是Thread中\" class=\"headerlink\" title=\"5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中\"></a><strong>5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中</strong></h3><blockquote>\n<p>Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。</p>\n<p>wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！<br>OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。</p>\n<p>负责唤醒等待线程的那个线程(我们称为“<strong>唤醒线程</strong>”)，它只有在获取“该对象的同步锁”(<strong>这里的同步锁必须和等待线程的同步锁是同一个</strong>)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p>\n<p>总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。</p>\n</blockquote>\n<h3 id=\"6-sleep-介绍与使用\"><a href=\"#6-sleep-介绍与使用\" class=\"headerlink\" title=\"6. sleep()介绍与使用\"></a>6. sleep()介绍与使用</h3><blockquote>\n<p>sleep() 定义在Thread.java中。 sleep() 的作用是让当前线程休眠，即当前线程会从<strong>运行状态</strong>进入到<strong>休眠(阻塞)状态</strong>。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由<strong>阻塞状态</strong>变成<strong>就绪状态</strong>，从而等待cpu的调度执行。</p>\n<p>下面是一个简单的demo</p>\n<pre><code>// SleepTest.java的源码\nclass ThreadA extends Thread{\n   public ThreadA(String name){ \n       super(name); \n   } \n   public synchronized void run() { \n       try {\n           for(int i=0; i &lt;10; i++){ \n               System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i); \n               // i能被4整除时，休眠100毫秒\n               if (i%4 == 0)\n                   Thread.sleep(100);\n           } \n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n   } \n} \n\npublic class SleepTest{ \n   public static void main(String[] args){ \n       ThreadA t1 = new ThreadA(&quot;t1&quot;); \n       t1.start(); \n   } \n}\n</code></pre><p>运行结果:</p>\n<pre><code>t1: 0\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt1: 5\nt1: 6\nt1: 7\nt1: 8\nt1: 9\n</code></pre><p><strong>结果说明</strong>： 程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(100)休眠100毫秒。</p>\n</blockquote>\n<h3 id=\"7-sleep-与-wait-的比较\"><a href=\"#7-sleep-与-wait-的比较\" class=\"headerlink\" title=\"7. sleep() 与 wait()的比较\"></a><strong>7. sleep() 与 wait()的比较</strong></h3><blockquote>\n<p>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。 但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。</p>\n<p>\u0010 下面通过示例演示sleep()是不会释放锁的。</p>\n<pre><code>public class SleepLockTest {\n\n   private static Object obj = new Object();\n\n   public static void main(String[] args) {\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n       ThreadA t2 = new ThreadA(&quot;t2&quot;);\n       t1.start();\n       t2.start();\n   }\n\n   static class ThreadA extends Thread {\n       public ThreadA(String name) {\n           super(name);\n       }\n\n       public void run() {\n           // 获取obj对象的同步锁\n           synchronized (obj) {\n               try {\n                   for (int i = 0; i &lt; 10; i++) {\n                       System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i);\n                       // i能被4整除时，休眠100毫秒\n                       if (i % 4 == 0)\n                           Thread.sleep(100);\n                   }\n               } catch (InterruptedException e) {\n                   e.printStackTrace();\n               }\n           }\n       }\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1: 0\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt1: 5\nt1: 6\nt1: 7\nt1: 8\nt1: 9\nt2: 0\nt2: 1\nt2: 2\nt2: 3\nt2: 4\nt2: 5\nt2: 6\nt2: 7\nt2: 8\nt2: 9\n</code></pre><p><strong>结果说明</strong>： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.sleep(100)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！ 注意，若我们注释掉synchronized (obj)后再次执行该程序，t1和t2是可以相互切换的。</p>\n</blockquote>\n"},{"abbrlink":2,"title":"java多线程系列 02 sychronized关键字","author":"zhangke","date":"2018-07-12T07:55:00.000Z","_content":"# java多线程系列 02 sychronized关键字\n\n### 概要\n\n1. Sychronized 基本用法\n2. sychronized基本规则\n3. 对象锁和类索\n\n### 1. sychronized基本用法\n\nsychronized主要由俩种用法，一种是用来修饰方法，另外一种是用来修饰代码块。\n\n**synchronized方法示例**\n\n```java\npublic synchronized void foo1() {\n    System.out.println(\"synchronized methoed\");\n}\n```\n\n**synchronized代码块**\n\n```java\npublic void foo2() {\n    synchronized (this) {\n        System.out.println(\"synchronized methoed\");\n    }\n}\n```\n\nsynchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。\n\nsynchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率(并不是在所有情况下是最好的)。下面通过一个示例来演示：\n\n```Java\npublic class Demo4 {\n\n    public synchronized void synMethod() {\n        for (int i = 0; i < 1000000; i++)\n            ;\n    }\n\n    public void synBlock() {\n        synchronized (this) {\n            for (int i = 0; i < 1000000; i++)\n                ;\n        }\n    }\n\n    public static void main(String[] args) {\n        Demo4 demo = new Demo4();\n\n        long start, diff;\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synMethod();                                // 调用“synchronized方法”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(\"synMethod() : \" + diff);\n\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synBlock();                                // 调用“synchronized方法块”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(\"synBlock()  : \" + diff);\n    }\n}\n```\n>\n>下面是在我电脑上运行的结果：\n>\n>```\n>synMethod() : 2\n>synBlock()  : 3\n>```\n>\n>\n\n### 2. sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。 \n\n>\n>\n>>## 第一条\n>>\n>>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 \n>>\n>>下面是“synchronized代码块”对应的演示程序。\n>>\n>>```java\n>>class MyRunable implements Runnable {\n>>\n>>    @Override\n>>    public void run() {\n>>        //锁住当前线程\n>>        synchronized (this) {\n>>            try {\n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() \n>>                                       + \" loop \" + i);\n>>                }\n>>            } catch (InterruptedException ie) {\n>>            }\n>>        }\n>>    }\n>>}\n>>\n>>public class Demo1_1 {\n>>\n>>    public static void main(String[] args) {\n>>        // 新建“Runnable对象”\n>>        Runnable demo = new MyRunable();\n>>\n>>        // 新建“线程t1”, t1是基于demo这个Runnable对象\n>>        Thread t1 = new Thread(demo, \"t1\");\n>>\n>>        // 新建“线程t2”, t2是基于demo这个Runnable对象\n>>        Thread t2 = new Thread(demo, \"t2\");\n>>        t1.start();           // 启动“线程t1”\n>>        t2.start();           // 启动“线程t2”\n>>    }\n>>}\n>>```\n>>\n>>运行结果\n>>\n>>```\n>>t1 loop 0\n>>t1 loop 1\n>>t1 loop 2\n>>t1 loop 3\n>>t1 loop 4\n>>t2 loop 0\n>>t2 loop 1\n>>t2 loop 2\n>>t2 loop 3\n>>t2 loop 4\n>>```\n>>\n>>**结果说明**：\n>>run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于\"demo这个Runnable对象\"创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。\n>>\n>>如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下：\n>>\n>>```\n>>class MyThread extends Thread {\n>>    \n>>    public MyThread(String name) {\n>>        super(name);\n>>    }\n>>\n>>    @Override\n>>    public void run() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() \n>>                    + \" loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }  \n>>    }\n>>}\n>>\n>>public class Demo1_2 {\n>>\n>>    public static void main(String[] args) {  \n>>        Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>>        Thread t2 = new MyThread(\"t2\");  // 新建“线程t2”\n>>        t1.start();                          // 启动“线程t1”\n>>        t2.start();                          // 启动“线程t2” \n>>    } \n>>}\n>>```\n>>\n>>**代码说明**： 比较Demo1_2 和 Demo1_1，我们发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。 幸运的是，在“Demo1_2的run()方法”也调用了synchronized(this)，正如“Demo1_1的run()方法”也调用了synchronized(this)一样！ 那么，Demo1_2的执行流程是不是和Demo1_1一样呢？\n>>\n>>运行结果\n>>\n>>```\n>>t1 loop 0\n>>t2 loop 0\n>>t1 loop 1\n>>t2 loop 1\n>>t1 loop 2\n>>t2 loop 2\n>>t1 loop 3\n>>t2 loop 3\n>>t1 loop 4\n>>t2 loop 4\n>>```\n>>\n>>**结果说明**：\n>>如果这个结果一点也不令你感到惊讶，那么我相信你对synchronized和this的认识已经比较深刻了。否则的话，请继续阅读这里的分析。\n>>synchronized(this)中的this是指“当前的类对象”，即synchronized(this)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。\n>>对于Demo1_2中，synchronized(this)中的this代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行synchronized(this)时，获取的是不同对象的同步锁。对于Demo1_1对而言，synchronized(this)中的this代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。\n>>\n>>## 第二条\n>>\n>>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 下面是“synchronized代码块”对应的演示程序:\n>>\n>>```\n>>class Count {\n>>\n>>    // 含有synchronized同步块的方法\n>>    public void synMethod() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() + \" synMethod loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }  \n>>    }\n>>\n>>    // 非同步的方法\n>>    public void nonSynMethod() {\n>>        try {  \n>>            for (int i = 0; i < 5; i++) {\n>>                Thread.sleep(100);\n>>                System.out.println(Thread.currentThread().getName() + \" nonSynMethod loop \" + i);  \n>>            }\n>>        } catch (InterruptedException ie) {  \n>>        }\n>>    }\n>>}\n>>\n>>public class Demo2 {\n>>\n>>    public static void main(String[] args) {  \n>>        final Count count = new Count();\n>>        // 新建t1, t1会调用“count对象”的synMethod()方法\n>>        Thread t1 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.synMethod();\n>>                    }\n>>                }, \"t1\");\n>>\n>>        // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n>>        Thread t2 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.nonSynMethod();\n>>                    }\n>>                }, \"t2\");  \n>>\n>>\n>>        t1.start();  // 启动t1\n>>        t2.start();  // 启动t2\n>>    } \n>>}\n>>```\n>>\n>>运行结果：\n>>\n>>```\n>>t1 synMethod loop 0\n>>t2 nonSynMethod loop 0\n>>t1 synMethod loop 1\n>>t2 nonSynMethod loop 1\n>>t1 synMethod loop 2\n>>t2 nonSynMethod loop 2\n>>t1 synMethod loop 3\n>>t2 nonSynMethod loop 3\n>>t1 synMethod loop 4\n>>t2 nonSynMethod loop 4\n>>```\n>>\n>>**结果说明**： 主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。\n>>\n>># 第三条\n>>\n>>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 我们将上面的例子中的nonSynMethod()方法体的也用synchronized(this)修饰。修改后的源码如下：\n>>\n>>```\n>>class Count {\n>>\n>>    // 含有synchronized同步块的方法\n>>    public void synMethod() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() + \" synMethod loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }  \n>>    }\n>>\n>>    // 也包含synchronized同步块的方法\n>>    public void nonSynMethod() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100);\n>>                    System.out.println(Thread.currentThread().getName() + \" nonSynMethod loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }\n>>    }\n>>}\n>>\n>>public class Demo3 {\n>>\n>>    public static void main(String[] args) {  \n>>        final Count count = new Count();\n>>        // 新建t1, t1会调用“count对象”的synMethod()方法\n>>        Thread t1 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.synMethod();\n>>                    }\n>>                }, \"t1\");\n>>\n>>        // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n>>        Thread t2 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.nonSynMethod();\n>>                    }\n>>                }, \"t2\");  \n>>\n>>\n>>        t1.start();  // 启动t1\n>>        t2.start();  // 启动t2\n>>    } \n>>}\n>>```\n>>\n>>运行结果：\n>>\n>>```\n>>t1 synMethod loop 0\n>>t1 synMethod loop 1\n>>t1 synMethod loop 2\n>>t1 synMethod loop 3\n>>t1 synMethod loop 4\n>>t2 nonSynMethod loop 0\n>>t2 nonSynMethod loop 1\n>>t2 nonSynMethod loop 2\n>>t2 nonSynMethod loop 3\n>>t2 nonSynMethod loop 4\n>>```\n>>\n>>**结果说明**： 主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。\n>\n>\n\n### 3. 对象锁和类索\n\n>**对象锁** -- 锁在某一个实例对象上。如果该类是单例，那么该锁也和类锁具有相同的效果。          \n>\n> **类锁** -- 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 类锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。\n>\n>关于“实例锁”和“全局锁”有一个很形象的例子：\n>\n>```\n>pulbic class Something {\n>    public synchronized void isSyncA(){}\n>    public synchronized void isSyncB(){}\n>    public static synchronized void cSyncA(){}\n>    public static synchronized void cSyncB(){}\n>}\n>```\n>\n>假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。\n>(01) x.isSyncA()与x.isSyncB() \n>(02) x.isSyncA()与y.isSyncA()\n>(03) x.cSyncA()与y.cSyncB()\n>(04) x.isSyncA()与Something.cSyncA()\n>\n>**(01) 不能被同时访问。**因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！\n>\n>```\n> // LockTest1.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest1 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(01) x.isSyncA()与x.isSyncB() \n>    private void test1() {\n>        // 新建t11, t11会调用 x.isSyncA()\n>        Thread t11 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncA();\n>                    }\n>                }, \"t11\");\n>\n>        // 新建t12, t12会调用 x.isSyncB()\n>        Thread t12 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncB();\n>                    }\n>                }, \"t12\");  \n>\n>\n>        t11.start();  // 启动t11\n>        t12.start();  // 启动t12\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest1 demo = new LockTest1();\n>        demo.test1();\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t11 : isSyncA\n>t11 : isSyncA\n>t11 : isSyncA\n>t11 : isSyncA\n>t11 : isSyncA\n>t12 : isSyncB\n>t12 : isSyncB\n>t12 : isSyncB\n>t12 : isSyncB\n>t12 : isSyncB\n>```\n>\n>**(02) 可以同时被访问。**因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。\n>\n>```\n>// LockTest1.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest1 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(01) x.isSyncA()与x.isSyncB() \n>    private void test1() {\n>        // 新建t11, t11会调用 x.isSyncA()\n>        Thread t11 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncA();\n>                    }\n>                }, \"t11\");\n>\n>        // 新建t12, t12会调用 x.isSyncB()\n>        Thread t12 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncB();\n>                    }\n>                }, \"t12\");  \n>\n>\n>        t11.start();  // 启动t11\n>        t12.start();  // 启动t12\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest1 demo = new LockTest1();\n>        demo.test1();\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>```\n>\n>**(03) 不能被同时访问。**因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。\n>\n>```\n> // LockTest3.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncA\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncB\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest3 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(03) x.cSyncA()与y.cSyncB()\n>    private void test3() {\n>        // 新建t31, t31会调用 x.isSyncA()\n>        Thread t31 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.cSyncA();\n>                    }\n>                }, \"t31\");\n>\n>        // 新建t32, t32会调用 x.isSyncB()\n>        Thread t32 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        y.cSyncB();\n>                    }\n>                }, \"t32\");  \n>\n>\n>        t31.start();  // 启动t31\n>        t32.start();  // 启动t32\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest3 demo = new LockTest3();\n>\n>        demo.test3();\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t31 : cSyncA\n>t31 : cSyncA\n>t31 : cSyncA\n>t31 : cSyncA\n>t31 : cSyncA\n>t32 : cSyncB\n>t32 : cSyncB\n>t32 : cSyncB\n>t32 : cSyncB\n>t32 : cSyncB \n>```\n>\n>**(04) 可以被同时访问。**因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。\n>\n>```\n>// LockTest4.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncA\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncB\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest4 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(04) x.isSyncA()与Something.cSyncA()\n>    private void test4() {\n>        // 新建t41, t41会调用 x.isSyncA()\n>        Thread t41 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncA();\n>                    }\n>                }, \"t41\");\n>\n>        // 新建t42, t42会调用 x.isSyncB()\n>        Thread t42 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        Something.cSyncA();\n>                    }\n>                }, \"t42\");  \n>\n>\n>        t41.start();  // 启动t41\n>        t42.start();  // 启动t42\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest4 demo = new LockTest4();\n>\n>        demo.test4();\n>    }\n>}**运行结果**：\n>```\n>\n\n总结：其实你可以将类锁和对象锁相同看待，我这里的相同看待是指，将他们看成俩个不同的对象的形式，其实每个class都有一个监视对象。用来管理类的创建等任务。Synchronized关键字也是锁住了这个监视器对象。所以可以类比着看。","source":"_posts/threads/java多线程系列 02 synchronized 关键字.md","raw":"abbrlink: 2\ntitle: java多线程系列 02 sychronized关键字\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-12 15:55:00\n---\n# java多线程系列 02 sychronized关键字\n\n### 概要\n\n1. Sychronized 基本用法\n2. sychronized基本规则\n3. 对象锁和类索\n\n### 1. sychronized基本用法\n\nsychronized主要由俩种用法，一种是用来修饰方法，另外一种是用来修饰代码块。\n\n**synchronized方法示例**\n\n```java\npublic synchronized void foo1() {\n    System.out.println(\"synchronized methoed\");\n}\n```\n\n**synchronized代码块**\n\n```java\npublic void foo2() {\n    synchronized (this) {\n        System.out.println(\"synchronized methoed\");\n    }\n}\n```\n\nsynchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。\n\nsynchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率(并不是在所有情况下是最好的)。下面通过一个示例来演示：\n\n```Java\npublic class Demo4 {\n\n    public synchronized void synMethod() {\n        for (int i = 0; i < 1000000; i++)\n            ;\n    }\n\n    public void synBlock() {\n        synchronized (this) {\n            for (int i = 0; i < 1000000; i++)\n                ;\n        }\n    }\n\n    public static void main(String[] args) {\n        Demo4 demo = new Demo4();\n\n        long start, diff;\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synMethod();                                // 调用“synchronized方法”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(\"synMethod() : \" + diff);\n\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synBlock();                                // 调用“synchronized方法块”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(\"synBlock()  : \" + diff);\n    }\n}\n```\n>\n>下面是在我电脑上运行的结果：\n>\n>```\n>synMethod() : 2\n>synBlock()  : 3\n>```\n>\n>\n\n### 2. sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。 \n\n>\n>\n>>## 第一条\n>>\n>>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 \n>>\n>>下面是“synchronized代码块”对应的演示程序。\n>>\n>>```java\n>>class MyRunable implements Runnable {\n>>\n>>    @Override\n>>    public void run() {\n>>        //锁住当前线程\n>>        synchronized (this) {\n>>            try {\n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() \n>>                                       + \" loop \" + i);\n>>                }\n>>            } catch (InterruptedException ie) {\n>>            }\n>>        }\n>>    }\n>>}\n>>\n>>public class Demo1_1 {\n>>\n>>    public static void main(String[] args) {\n>>        // 新建“Runnable对象”\n>>        Runnable demo = new MyRunable();\n>>\n>>        // 新建“线程t1”, t1是基于demo这个Runnable对象\n>>        Thread t1 = new Thread(demo, \"t1\");\n>>\n>>        // 新建“线程t2”, t2是基于demo这个Runnable对象\n>>        Thread t2 = new Thread(demo, \"t2\");\n>>        t1.start();           // 启动“线程t1”\n>>        t2.start();           // 启动“线程t2”\n>>    }\n>>}\n>>```\n>>\n>>运行结果\n>>\n>>```\n>>t1 loop 0\n>>t1 loop 1\n>>t1 loop 2\n>>t1 loop 3\n>>t1 loop 4\n>>t2 loop 0\n>>t2 loop 1\n>>t2 loop 2\n>>t2 loop 3\n>>t2 loop 4\n>>```\n>>\n>>**结果说明**：\n>>run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于\"demo这个Runnable对象\"创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。\n>>\n>>如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下：\n>>\n>>```\n>>class MyThread extends Thread {\n>>    \n>>    public MyThread(String name) {\n>>        super(name);\n>>    }\n>>\n>>    @Override\n>>    public void run() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() \n>>                    + \" loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }  \n>>    }\n>>}\n>>\n>>public class Demo1_2 {\n>>\n>>    public static void main(String[] args) {  \n>>        Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>>        Thread t2 = new MyThread(\"t2\");  // 新建“线程t2”\n>>        t1.start();                          // 启动“线程t1”\n>>        t2.start();                          // 启动“线程t2” \n>>    } \n>>}\n>>```\n>>\n>>**代码说明**： 比较Demo1_2 和 Demo1_1，我们发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。 幸运的是，在“Demo1_2的run()方法”也调用了synchronized(this)，正如“Demo1_1的run()方法”也调用了synchronized(this)一样！ 那么，Demo1_2的执行流程是不是和Demo1_1一样呢？\n>>\n>>运行结果\n>>\n>>```\n>>t1 loop 0\n>>t2 loop 0\n>>t1 loop 1\n>>t2 loop 1\n>>t1 loop 2\n>>t2 loop 2\n>>t1 loop 3\n>>t2 loop 3\n>>t1 loop 4\n>>t2 loop 4\n>>```\n>>\n>>**结果说明**：\n>>如果这个结果一点也不令你感到惊讶，那么我相信你对synchronized和this的认识已经比较深刻了。否则的话，请继续阅读这里的分析。\n>>synchronized(this)中的this是指“当前的类对象”，即synchronized(this)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。\n>>对于Demo1_2中，synchronized(this)中的this代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行synchronized(this)时，获取的是不同对象的同步锁。对于Demo1_1对而言，synchronized(this)中的this代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。\n>>\n>>## 第二条\n>>\n>>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 下面是“synchronized代码块”对应的演示程序:\n>>\n>>```\n>>class Count {\n>>\n>>    // 含有synchronized同步块的方法\n>>    public void synMethod() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() + \" synMethod loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }  \n>>    }\n>>\n>>    // 非同步的方法\n>>    public void nonSynMethod() {\n>>        try {  \n>>            for (int i = 0; i < 5; i++) {\n>>                Thread.sleep(100);\n>>                System.out.println(Thread.currentThread().getName() + \" nonSynMethod loop \" + i);  \n>>            }\n>>        } catch (InterruptedException ie) {  \n>>        }\n>>    }\n>>}\n>>\n>>public class Demo2 {\n>>\n>>    public static void main(String[] args) {  \n>>        final Count count = new Count();\n>>        // 新建t1, t1会调用“count对象”的synMethod()方法\n>>        Thread t1 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.synMethod();\n>>                    }\n>>                }, \"t1\");\n>>\n>>        // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n>>        Thread t2 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.nonSynMethod();\n>>                    }\n>>                }, \"t2\");  \n>>\n>>\n>>        t1.start();  // 启动t1\n>>        t2.start();  // 启动t2\n>>    } \n>>}\n>>```\n>>\n>>运行结果：\n>>\n>>```\n>>t1 synMethod loop 0\n>>t2 nonSynMethod loop 0\n>>t1 synMethod loop 1\n>>t2 nonSynMethod loop 1\n>>t1 synMethod loop 2\n>>t2 nonSynMethod loop 2\n>>t1 synMethod loop 3\n>>t2 nonSynMethod loop 3\n>>t1 synMethod loop 4\n>>t2 nonSynMethod loop 4\n>>```\n>>\n>>**结果说明**： 主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。\n>>\n>># 第三条\n>>\n>>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 我们将上面的例子中的nonSynMethod()方法体的也用synchronized(this)修饰。修改后的源码如下：\n>>\n>>```\n>>class Count {\n>>\n>>    // 含有synchronized同步块的方法\n>>    public void synMethod() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() + \" synMethod loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }  \n>>    }\n>>\n>>    // 也包含synchronized同步块的方法\n>>    public void nonSynMethod() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100);\n>>                    System.out.println(Thread.currentThread().getName() + \" nonSynMethod loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }\n>>    }\n>>}\n>>\n>>public class Demo3 {\n>>\n>>    public static void main(String[] args) {  \n>>        final Count count = new Count();\n>>        // 新建t1, t1会调用“count对象”的synMethod()方法\n>>        Thread t1 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.synMethod();\n>>                    }\n>>                }, \"t1\");\n>>\n>>        // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n>>        Thread t2 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.nonSynMethod();\n>>                    }\n>>                }, \"t2\");  \n>>\n>>\n>>        t1.start();  // 启动t1\n>>        t2.start();  // 启动t2\n>>    } \n>>}\n>>```\n>>\n>>运行结果：\n>>\n>>```\n>>t1 synMethod loop 0\n>>t1 synMethod loop 1\n>>t1 synMethod loop 2\n>>t1 synMethod loop 3\n>>t1 synMethod loop 4\n>>t2 nonSynMethod loop 0\n>>t2 nonSynMethod loop 1\n>>t2 nonSynMethod loop 2\n>>t2 nonSynMethod loop 3\n>>t2 nonSynMethod loop 4\n>>```\n>>\n>>**结果说明**： 主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。\n>\n>\n\n### 3. 对象锁和类索\n\n>**对象锁** -- 锁在某一个实例对象上。如果该类是单例，那么该锁也和类锁具有相同的效果。          \n>\n> **类锁** -- 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 类锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。\n>\n>关于“实例锁”和“全局锁”有一个很形象的例子：\n>\n>```\n>pulbic class Something {\n>    public synchronized void isSyncA(){}\n>    public synchronized void isSyncB(){}\n>    public static synchronized void cSyncA(){}\n>    public static synchronized void cSyncB(){}\n>}\n>```\n>\n>假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。\n>(01) x.isSyncA()与x.isSyncB() \n>(02) x.isSyncA()与y.isSyncA()\n>(03) x.cSyncA()与y.cSyncB()\n>(04) x.isSyncA()与Something.cSyncA()\n>\n>**(01) 不能被同时访问。**因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！\n>\n>```\n> // LockTest1.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest1 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(01) x.isSyncA()与x.isSyncB() \n>    private void test1() {\n>        // 新建t11, t11会调用 x.isSyncA()\n>        Thread t11 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncA();\n>                    }\n>                }, \"t11\");\n>\n>        // 新建t12, t12会调用 x.isSyncB()\n>        Thread t12 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncB();\n>                    }\n>                }, \"t12\");  \n>\n>\n>        t11.start();  // 启动t11\n>        t12.start();  // 启动t12\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest1 demo = new LockTest1();\n>        demo.test1();\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t11 : isSyncA\n>t11 : isSyncA\n>t11 : isSyncA\n>t11 : isSyncA\n>t11 : isSyncA\n>t12 : isSyncB\n>t12 : isSyncB\n>t12 : isSyncB\n>t12 : isSyncB\n>t12 : isSyncB\n>```\n>\n>**(02) 可以同时被访问。**因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。\n>\n>```\n>// LockTest1.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest1 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(01) x.isSyncA()与x.isSyncB() \n>    private void test1() {\n>        // 新建t11, t11会调用 x.isSyncA()\n>        Thread t11 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncA();\n>                    }\n>                }, \"t11\");\n>\n>        // 新建t12, t12会调用 x.isSyncB()\n>        Thread t12 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncB();\n>                    }\n>                }, \"t12\");  \n>\n>\n>        t11.start();  // 启动t11\n>        t12.start();  // 启动t12\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest1 demo = new LockTest1();\n>        demo.test1();\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>```\n>\n>**(03) 不能被同时访问。**因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。\n>\n>```\n> // LockTest3.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncA\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncB\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest3 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(03) x.cSyncA()与y.cSyncB()\n>    private void test3() {\n>        // 新建t31, t31会调用 x.isSyncA()\n>        Thread t31 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.cSyncA();\n>                    }\n>                }, \"t31\");\n>\n>        // 新建t32, t32会调用 x.isSyncB()\n>        Thread t32 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        y.cSyncB();\n>                    }\n>                }, \"t32\");  \n>\n>\n>        t31.start();  // 启动t31\n>        t32.start();  // 启动t32\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest3 demo = new LockTest3();\n>\n>        demo.test3();\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t31 : cSyncA\n>t31 : cSyncA\n>t31 : cSyncA\n>t31 : cSyncA\n>t31 : cSyncA\n>t32 : cSyncB\n>t32 : cSyncB\n>t32 : cSyncB\n>t32 : cSyncB\n>t32 : cSyncB \n>```\n>\n>**(04) 可以被同时访问。**因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。\n>\n>```\n>// LockTest4.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncA\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncB\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest4 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(04) x.isSyncA()与Something.cSyncA()\n>    private void test4() {\n>        // 新建t41, t41会调用 x.isSyncA()\n>        Thread t41 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncA();\n>                    }\n>                }, \"t41\");\n>\n>        // 新建t42, t42会调用 x.isSyncB()\n>        Thread t42 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        Something.cSyncA();\n>                    }\n>                }, \"t42\");  \n>\n>\n>        t41.start();  // 启动t41\n>        t42.start();  // 启动t42\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest4 demo = new LockTest4();\n>\n>        demo.test4();\n>    }\n>}**运行结果**：\n>```\n>\n\n总结：其实你可以将类锁和对象锁相同看待，我这里的相同看待是指，将他们看成俩个不同的对象的形式，其实每个class都有一个监视对象。用来管理类的创建等任务。Synchronized关键字也是锁住了这个监视器对象。所以可以类比着看。","slug":"threads/java多线程系列 02 synchronized 关键字","published":1,"updated":"2019-01-04T01:48:59.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovta002w9q1uk0r6ke8v","content":"<h1 id=\"java多线程系列-02-sychronized关键字\"><a href=\"#java多线程系列-02-sychronized关键字\" class=\"headerlink\" title=\"java多线程系列 02 sychronized关键字\"></a>java多线程系列 02 sychronized关键字</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><ol>\n<li>Sychronized 基本用法</li>\n<li>sychronized基本规则</li>\n<li>对象锁和类索</li>\n</ol>\n<h3 id=\"1-sychronized基本用法\"><a href=\"#1-sychronized基本用法\" class=\"headerlink\" title=\"1. sychronized基本用法\"></a>1. sychronized基本用法</h3><p>sychronized主要由俩种用法，一种是用来修饰方法，另外一种是用来修饰代码块。</p>\n<p><strong>synchronized方法示例</strong></p>\n<pre><code class=\"java\">public synchronized void foo1() {\n    System.out.println(&quot;synchronized methoed&quot;);\n}\n</code></pre>\n<p><strong>synchronized代码块</strong></p>\n<pre><code class=\"java\">public void foo2() {\n    synchronized (this) {\n        System.out.println(&quot;synchronized methoed&quot;);\n    }\n}\n</code></pre>\n<p>synchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。</p>\n<p>synchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率(并不是在所有情况下是最好的)。下面通过一个示例来演示：</p>\n<pre><code class=\"Java\">public class Demo4 {\n\n    public synchronized void synMethod() {\n        for (int i = 0; i &lt; 1000000; i++)\n            ;\n    }\n\n    public void synBlock() {\n        synchronized (this) {\n            for (int i = 0; i &lt; 1000000; i++)\n                ;\n        }\n    }\n\n    public static void main(String[] args) {\n        Demo4 demo = new Demo4();\n\n        long start, diff;\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synMethod();                                // 调用“synchronized方法”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(&quot;synMethod() : &quot; + diff);\n\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synBlock();                                // 调用“synchronized方法块”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(&quot;synBlock()  : &quot; + diff);\n    }\n}\n</code></pre>\n<blockquote>\n<p>下面是在我电脑上运行的结果：</p>\n<pre><code>synMethod() : 2\nsynBlock()  : 3\n</code></pre></blockquote>\n<h3 id=\"2-sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。\"><a href=\"#2-sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。\" class=\"headerlink\" title=\"2. sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。\"></a>2. sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。</h3><blockquote>\n<blockquote>\n<h2 id=\"第一条\"><a href=\"#第一条\" class=\"headerlink\" title=\"第一条\"></a>第一条</h2><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 </p>\n<p>下面是“synchronized代码块”对应的演示程序。</p>\n<pre><code class=\"java\">class MyRunable implements Runnable {\n\n   @Override\n   public void run() {\n       //锁住当前线程\n       synchronized (this) {\n           try {\n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() \n                                      + &quot; loop &quot; + i);\n               }\n           } catch (InterruptedException ie) {\n           }\n       }\n   }\n}\n\npublic class Demo1_1 {\n\n   public static void main(String[] args) {\n       // 新建“Runnable对象”\n       Runnable demo = new MyRunable();\n\n       // 新建“线程t1”, t1是基于demo这个Runnable对象\n       Thread t1 = new Thread(demo, &quot;t1&quot;);\n\n       // 新建“线程t2”, t2是基于demo这个Runnable对象\n       Thread t2 = new Thread(demo, &quot;t2&quot;);\n       t1.start();           // 启动“线程t1”\n       t2.start();           // 启动“线程t2”\n   }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>t1 loop 0\nt1 loop 1\nt1 loop 2\nt1 loop 3\nt1 loop 4\nt2 loop 0\nt2 loop 1\nt2 loop 2\nt2 loop 3\nt2 loop 4\n</code></pre><p><strong>结果说明</strong>：<br>run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于”demo这个Runnable对象”创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。</p>\n<p>如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下：</p>\n<pre><code>class MyThread extends Thread {\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() \n                   + &quot; loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }  \n   }\n}\n\npublic class Demo1_2 {\n\n   public static void main(String[] args) {  \n       Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n       Thread t2 = new MyThread(&quot;t2&quot;);  // 新建“线程t2”\n       t1.start();                          // 启动“线程t1”\n       t2.start();                          // 启动“线程t2” \n   } \n}\n</code></pre><p><strong>代码说明</strong>： 比较Demo1_2 和 Demo1_1，我们发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。 幸运的是，在“Demo1_2的run()方法”也调用了synchronized(this)，正如“Demo1_1的run()方法”也调用了synchronized(this)一样！ 那么，Demo1_2的执行流程是不是和Demo1_1一样呢？</p>\n<p>运行结果</p>\n<pre><code>t1 loop 0\nt2 loop 0\nt1 loop 1\nt2 loop 1\nt1 loop 2\nt2 loop 2\nt1 loop 3\nt2 loop 3\nt1 loop 4\nt2 loop 4\n</code></pre><p><strong>结果说明</strong>：<br>如果这个结果一点也不令你感到惊讶，那么我相信你对synchronized和this的认识已经比较深刻了。否则的话，请继续阅读这里的分析。<br>synchronized(this)中的this是指“当前的类对象”，即synchronized(this)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。<br>对于Demo1_2中，synchronized(this)中的this代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行synchronized(this)时，获取的是不同对象的同步锁。对于Demo1_1对而言，synchronized(this)中的this代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。</p>\n<h2 id=\"第二条\"><a href=\"#第二条\" class=\"headerlink\" title=\"第二条\"></a>第二条</h2><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 下面是“synchronized代码块”对应的演示程序:</p>\n<pre><code>class Count {\n\n   // 含有synchronized同步块的方法\n   public void synMethod() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }  \n   }\n\n   // 非同步的方法\n   public void nonSynMethod() {\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100);\n               System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i);  \n           }\n       } catch (InterruptedException ie) {  \n       }\n   }\n}\n\npublic class Demo2 {\n\n   public static void main(String[] args) {  \n       final Count count = new Count();\n       // 新建t1, t1会调用“count对象”的synMethod()方法\n       Thread t1 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.synMethod();\n                   }\n               }, &quot;t1&quot;);\n\n       // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n       Thread t2 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.nonSynMethod();\n                   }\n               }, &quot;t2&quot;);  \n\n\n       t1.start();  // 启动t1\n       t2.start();  // 启动t2\n   } \n}\n</code></pre><p>运行结果：</p>\n<pre><code>t1 synMethod loop 0\nt2 nonSynMethod loop 0\nt1 synMethod loop 1\nt2 nonSynMethod loop 1\nt1 synMethod loop 2\nt2 nonSynMethod loop 2\nt1 synMethod loop 3\nt2 nonSynMethod loop 3\nt1 synMethod loop 4\nt2 nonSynMethod loop 4\n</code></pre><p><strong>结果说明</strong>： 主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。</p>\n<h1 id=\"第三条\"><a href=\"#第三条\" class=\"headerlink\" title=\"第三条\"></a>第三条</h1><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 我们将上面的例子中的nonSynMethod()方法体的也用synchronized(this)修饰。修改后的源码如下：</p>\n<pre><code>class Count {\n\n   // 含有synchronized同步块的方法\n   public void synMethod() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }  \n   }\n\n   // 也包含synchronized同步块的方法\n   public void nonSynMethod() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100);\n                   System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }\n   }\n}\n\npublic class Demo3 {\n\n   public static void main(String[] args) {  \n       final Count count = new Count();\n       // 新建t1, t1会调用“count对象”的synMethod()方法\n       Thread t1 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.synMethod();\n                   }\n               }, &quot;t1&quot;);\n\n       // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n       Thread t2 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.nonSynMethod();\n                   }\n               }, &quot;t2&quot;);  \n\n\n       t1.start();  // 启动t1\n       t2.start();  // 启动t2\n   } \n}\n</code></pre><p>运行结果：</p>\n<pre><code>t1 synMethod loop 0\nt1 synMethod loop 1\nt1 synMethod loop 2\nt1 synMethod loop 3\nt1 synMethod loop 4\nt2 nonSynMethod loop 0\nt2 nonSynMethod loop 1\nt2 nonSynMethod loop 2\nt2 nonSynMethod loop 3\nt2 nonSynMethod loop 4\n</code></pre><p><strong>结果说明</strong>： 主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"3-对象锁和类索\"><a href=\"#3-对象锁和类索\" class=\"headerlink\" title=\"3. 对象锁和类索\"></a>3. 对象锁和类索</h3><blockquote>\n<p><strong>对象锁</strong> – 锁在某一个实例对象上。如果该类是单例，那么该锁也和类锁具有相同的效果。          </p>\n<p><strong>类锁</strong> – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 类锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。</p>\n<p>关于“实例锁”和“全局锁”有一个很形象的例子：</p>\n<pre><code>pulbic class Something {\n   public synchronized void isSyncA(){}\n   public synchronized void isSyncB(){}\n   public static synchronized void cSyncA(){}\n   public static synchronized void cSyncB(){}\n}\n</code></pre><p>假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。<br>(01) x.isSyncA()与x.isSyncB()<br>(02) x.isSyncA()与y.isSyncA()<br>(03) x.cSyncA()与y.cSyncB()<br>(04) x.isSyncA()与Something.cSyncA()</p>\n<p><strong>(01) 不能被同时访问。</strong>因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！</p>\n<pre><code>// LockTest1.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest1 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(01) x.isSyncA()与x.isSyncB() \n   private void test1() {\n       // 新建t11, t11会调用 x.isSyncA()\n       Thread t11 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncA();\n                   }\n               }, &quot;t11&quot;);\n\n       // 新建t12, t12会调用 x.isSyncB()\n       Thread t12 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncB();\n                   }\n               }, &quot;t12&quot;);  \n\n\n       t11.start();  // 启动t11\n       t12.start();  // 启动t12\n   }\n\n   public static void main(String[] args) {\n       LockTest1 demo = new LockTest1();\n       demo.test1();\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\n</code></pre><p><strong>(02) 可以同时被访问。</strong>因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。</p>\n<pre><code>// LockTest1.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest1 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(01) x.isSyncA()与x.isSyncB() \n   private void test1() {\n       // 新建t11, t11会调用 x.isSyncA()\n       Thread t11 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncA();\n                   }\n               }, &quot;t11&quot;);\n\n       // 新建t12, t12会调用 x.isSyncB()\n       Thread t12 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncB();\n                   }\n               }, &quot;t12&quot;);  \n\n\n       t11.start();  // 启动t11\n       t12.start();  // 启动t12\n   }\n\n   public static void main(String[] args) {\n       LockTest1 demo = new LockTest1();\n       demo.test1();\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\n</code></pre><p><strong>(03) 不能被同时访问。</strong>因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。</p>\n<pre><code>// LockTest3.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest3 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(03) x.cSyncA()与y.cSyncB()\n   private void test3() {\n       // 新建t31, t31会调用 x.isSyncA()\n       Thread t31 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.cSyncA();\n                   }\n               }, &quot;t31&quot;);\n\n       // 新建t32, t32会调用 x.isSyncB()\n       Thread t32 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       y.cSyncB();\n                   }\n               }, &quot;t32&quot;);  \n\n\n       t31.start();  // 启动t31\n       t32.start();  // 启动t32\n   }\n\n   public static void main(String[] args) {\n       LockTest3 demo = new LockTest3();\n\n       demo.test3();\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB \n</code></pre><p><strong>(04) 可以被同时访问。</strong>因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。</p>\n<pre><code>// LockTest4.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest4 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(04) x.isSyncA()与Something.cSyncA()\n   private void test4() {\n       // 新建t41, t41会调用 x.isSyncA()\n       Thread t41 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncA();\n                   }\n               }, &quot;t41&quot;);\n\n       // 新建t42, t42会调用 x.isSyncB()\n       Thread t42 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       Something.cSyncA();\n                   }\n               }, &quot;t42&quot;);  \n\n\n       t41.start();  // 启动t41\n       t42.start();  // 启动t42\n   }\n\n   public static void main(String[] args) {\n       LockTest4 demo = new LockTest4();\n\n       demo.test4();\n   }\n}**运行结果**：\n</code></pre></blockquote>\n<p>总结：其实你可以将类锁和对象锁相同看待，我这里的相同看待是指，将他们看成俩个不同的对象的形式，其实每个class都有一个监视对象。用来管理类的创建等任务。Synchronized关键字也是锁住了这个监视器对象。所以可以类比着看。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-02-sychronized关键字\"><a href=\"#java多线程系列-02-sychronized关键字\" class=\"headerlink\" title=\"java多线程系列 02 sychronized关键字\"></a>java多线程系列 02 sychronized关键字</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><ol>\n<li>Sychronized 基本用法</li>\n<li>sychronized基本规则</li>\n<li>对象锁和类索</li>\n</ol>\n<h3 id=\"1-sychronized基本用法\"><a href=\"#1-sychronized基本用法\" class=\"headerlink\" title=\"1. sychronized基本用法\"></a>1. sychronized基本用法</h3><p>sychronized主要由俩种用法，一种是用来修饰方法，另外一种是用来修饰代码块。</p>\n<p><strong>synchronized方法示例</strong></p>\n<pre><code class=\"java\">public synchronized void foo1() {\n    System.out.println(&quot;synchronized methoed&quot;);\n}\n</code></pre>\n<p><strong>synchronized代码块</strong></p>\n<pre><code class=\"java\">public void foo2() {\n    synchronized (this) {\n        System.out.println(&quot;synchronized methoed&quot;);\n    }\n}\n</code></pre>\n<p>synchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。</p>\n<p>synchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率(并不是在所有情况下是最好的)。下面通过一个示例来演示：</p>\n<pre><code class=\"Java\">public class Demo4 {\n\n    public synchronized void synMethod() {\n        for (int i = 0; i &lt; 1000000; i++)\n            ;\n    }\n\n    public void synBlock() {\n        synchronized (this) {\n            for (int i = 0; i &lt; 1000000; i++)\n                ;\n        }\n    }\n\n    public static void main(String[] args) {\n        Demo4 demo = new Demo4();\n\n        long start, diff;\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synMethod();                                // 调用“synchronized方法”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(&quot;synMethod() : &quot; + diff);\n\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synBlock();                                // 调用“synchronized方法块”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(&quot;synBlock()  : &quot; + diff);\n    }\n}\n</code></pre>\n<blockquote>\n<p>下面是在我电脑上运行的结果：</p>\n<pre><code>synMethod() : 2\nsynBlock()  : 3\n</code></pre></blockquote>\n<h3 id=\"2-sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。\"><a href=\"#2-sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。\" class=\"headerlink\" title=\"2. sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。\"></a>2. sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。</h3><blockquote>\n<blockquote>\n<h2 id=\"第一条\"><a href=\"#第一条\" class=\"headerlink\" title=\"第一条\"></a>第一条</h2><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 </p>\n<p>下面是“synchronized代码块”对应的演示程序。</p>\n<pre><code class=\"java\">class MyRunable implements Runnable {\n\n   @Override\n   public void run() {\n       //锁住当前线程\n       synchronized (this) {\n           try {\n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() \n                                      + &quot; loop &quot; + i);\n               }\n           } catch (InterruptedException ie) {\n           }\n       }\n   }\n}\n\npublic class Demo1_1 {\n\n   public static void main(String[] args) {\n       // 新建“Runnable对象”\n       Runnable demo = new MyRunable();\n\n       // 新建“线程t1”, t1是基于demo这个Runnable对象\n       Thread t1 = new Thread(demo, &quot;t1&quot;);\n\n       // 新建“线程t2”, t2是基于demo这个Runnable对象\n       Thread t2 = new Thread(demo, &quot;t2&quot;);\n       t1.start();           // 启动“线程t1”\n       t2.start();           // 启动“线程t2”\n   }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>t1 loop 0\nt1 loop 1\nt1 loop 2\nt1 loop 3\nt1 loop 4\nt2 loop 0\nt2 loop 1\nt2 loop 2\nt2 loop 3\nt2 loop 4\n</code></pre><p><strong>结果说明</strong>：<br>run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于”demo这个Runnable对象”创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。</p>\n<p>如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下：</p>\n<pre><code>class MyThread extends Thread {\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() \n                   + &quot; loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }  \n   }\n}\n\npublic class Demo1_2 {\n\n   public static void main(String[] args) {  \n       Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n       Thread t2 = new MyThread(&quot;t2&quot;);  // 新建“线程t2”\n       t1.start();                          // 启动“线程t1”\n       t2.start();                          // 启动“线程t2” \n   } \n}\n</code></pre><p><strong>代码说明</strong>： 比较Demo1_2 和 Demo1_1，我们发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。 幸运的是，在“Demo1_2的run()方法”也调用了synchronized(this)，正如“Demo1_1的run()方法”也调用了synchronized(this)一样！ 那么，Demo1_2的执行流程是不是和Demo1_1一样呢？</p>\n<p>运行结果</p>\n<pre><code>t1 loop 0\nt2 loop 0\nt1 loop 1\nt2 loop 1\nt1 loop 2\nt2 loop 2\nt1 loop 3\nt2 loop 3\nt1 loop 4\nt2 loop 4\n</code></pre><p><strong>结果说明</strong>：<br>如果这个结果一点也不令你感到惊讶，那么我相信你对synchronized和this的认识已经比较深刻了。否则的话，请继续阅读这里的分析。<br>synchronized(this)中的this是指“当前的类对象”，即synchronized(this)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。<br>对于Demo1_2中，synchronized(this)中的this代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行synchronized(this)时，获取的是不同对象的同步锁。对于Demo1_1对而言，synchronized(this)中的this代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。</p>\n<h2 id=\"第二条\"><a href=\"#第二条\" class=\"headerlink\" title=\"第二条\"></a>第二条</h2><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 下面是“synchronized代码块”对应的演示程序:</p>\n<pre><code>class Count {\n\n   // 含有synchronized同步块的方法\n   public void synMethod() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }  \n   }\n\n   // 非同步的方法\n   public void nonSynMethod() {\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100);\n               System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i);  \n           }\n       } catch (InterruptedException ie) {  \n       }\n   }\n}\n\npublic class Demo2 {\n\n   public static void main(String[] args) {  \n       final Count count = new Count();\n       // 新建t1, t1会调用“count对象”的synMethod()方法\n       Thread t1 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.synMethod();\n                   }\n               }, &quot;t1&quot;);\n\n       // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n       Thread t2 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.nonSynMethod();\n                   }\n               }, &quot;t2&quot;);  \n\n\n       t1.start();  // 启动t1\n       t2.start();  // 启动t2\n   } \n}\n</code></pre><p>运行结果：</p>\n<pre><code>t1 synMethod loop 0\nt2 nonSynMethod loop 0\nt1 synMethod loop 1\nt2 nonSynMethod loop 1\nt1 synMethod loop 2\nt2 nonSynMethod loop 2\nt1 synMethod loop 3\nt2 nonSynMethod loop 3\nt1 synMethod loop 4\nt2 nonSynMethod loop 4\n</code></pre><p><strong>结果说明</strong>： 主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。</p>\n<h1 id=\"第三条\"><a href=\"#第三条\" class=\"headerlink\" title=\"第三条\"></a>第三条</h1><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 我们将上面的例子中的nonSynMethod()方法体的也用synchronized(this)修饰。修改后的源码如下：</p>\n<pre><code>class Count {\n\n   // 含有synchronized同步块的方法\n   public void synMethod() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }  \n   }\n\n   // 也包含synchronized同步块的方法\n   public void nonSynMethod() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100);\n                   System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }\n   }\n}\n\npublic class Demo3 {\n\n   public static void main(String[] args) {  \n       final Count count = new Count();\n       // 新建t1, t1会调用“count对象”的synMethod()方法\n       Thread t1 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.synMethod();\n                   }\n               }, &quot;t1&quot;);\n\n       // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n       Thread t2 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.nonSynMethod();\n                   }\n               }, &quot;t2&quot;);  \n\n\n       t1.start();  // 启动t1\n       t2.start();  // 启动t2\n   } \n}\n</code></pre><p>运行结果：</p>\n<pre><code>t1 synMethod loop 0\nt1 synMethod loop 1\nt1 synMethod loop 2\nt1 synMethod loop 3\nt1 synMethod loop 4\nt2 nonSynMethod loop 0\nt2 nonSynMethod loop 1\nt2 nonSynMethod loop 2\nt2 nonSynMethod loop 3\nt2 nonSynMethod loop 4\n</code></pre><p><strong>结果说明</strong>： 主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"3-对象锁和类索\"><a href=\"#3-对象锁和类索\" class=\"headerlink\" title=\"3. 对象锁和类索\"></a>3. 对象锁和类索</h3><blockquote>\n<p><strong>对象锁</strong> – 锁在某一个实例对象上。如果该类是单例，那么该锁也和类锁具有相同的效果。          </p>\n<p><strong>类锁</strong> – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 类锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。</p>\n<p>关于“实例锁”和“全局锁”有一个很形象的例子：</p>\n<pre><code>pulbic class Something {\n   public synchronized void isSyncA(){}\n   public synchronized void isSyncB(){}\n   public static synchronized void cSyncA(){}\n   public static synchronized void cSyncB(){}\n}\n</code></pre><p>假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。<br>(01) x.isSyncA()与x.isSyncB()<br>(02) x.isSyncA()与y.isSyncA()<br>(03) x.cSyncA()与y.cSyncB()<br>(04) x.isSyncA()与Something.cSyncA()</p>\n<p><strong>(01) 不能被同时访问。</strong>因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！</p>\n<pre><code>// LockTest1.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest1 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(01) x.isSyncA()与x.isSyncB() \n   private void test1() {\n       // 新建t11, t11会调用 x.isSyncA()\n       Thread t11 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncA();\n                   }\n               }, &quot;t11&quot;);\n\n       // 新建t12, t12会调用 x.isSyncB()\n       Thread t12 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncB();\n                   }\n               }, &quot;t12&quot;);  \n\n\n       t11.start();  // 启动t11\n       t12.start();  // 启动t12\n   }\n\n   public static void main(String[] args) {\n       LockTest1 demo = new LockTest1();\n       demo.test1();\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\n</code></pre><p><strong>(02) 可以同时被访问。</strong>因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。</p>\n<pre><code>// LockTest1.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest1 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(01) x.isSyncA()与x.isSyncB() \n   private void test1() {\n       // 新建t11, t11会调用 x.isSyncA()\n       Thread t11 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncA();\n                   }\n               }, &quot;t11&quot;);\n\n       // 新建t12, t12会调用 x.isSyncB()\n       Thread t12 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncB();\n                   }\n               }, &quot;t12&quot;);  \n\n\n       t11.start();  // 启动t11\n       t12.start();  // 启动t12\n   }\n\n   public static void main(String[] args) {\n       LockTest1 demo = new LockTest1();\n       demo.test1();\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\n</code></pre><p><strong>(03) 不能被同时访问。</strong>因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。</p>\n<pre><code>// LockTest3.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest3 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(03) x.cSyncA()与y.cSyncB()\n   private void test3() {\n       // 新建t31, t31会调用 x.isSyncA()\n       Thread t31 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.cSyncA();\n                   }\n               }, &quot;t31&quot;);\n\n       // 新建t32, t32会调用 x.isSyncB()\n       Thread t32 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       y.cSyncB();\n                   }\n               }, &quot;t32&quot;);  \n\n\n       t31.start();  // 启动t31\n       t32.start();  // 启动t32\n   }\n\n   public static void main(String[] args) {\n       LockTest3 demo = new LockTest3();\n\n       demo.test3();\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB \n</code></pre><p><strong>(04) 可以被同时访问。</strong>因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。</p>\n<pre><code>// LockTest4.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest4 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(04) x.isSyncA()与Something.cSyncA()\n   private void test4() {\n       // 新建t41, t41会调用 x.isSyncA()\n       Thread t41 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncA();\n                   }\n               }, &quot;t41&quot;);\n\n       // 新建t42, t42会调用 x.isSyncB()\n       Thread t42 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       Something.cSyncA();\n                   }\n               }, &quot;t42&quot;);  \n\n\n       t41.start();  // 启动t41\n       t42.start();  // 启动t42\n   }\n\n   public static void main(String[] args) {\n       LockTest4 demo = new LockTest4();\n\n       demo.test4();\n   }\n}**运行结果**：\n</code></pre></blockquote>\n<p>总结：其实你可以将类锁和对象锁相同看待，我这里的相同看待是指，将他们看成俩个不同的对象的形式，其实每个class都有一个监视对象。用来管理类的创建等任务。Synchronized关键字也是锁住了这个监视器对象。所以可以类比着看。</p>\n"},{"abbrlink":6,"title":" Java多线程系列 05 interrupt()和线程终止方式","author":"zhangke","date":"2018-07-13T03:11:00.000Z","_content":"# Java多线程系列 05 interrupt()和线程终止方式\n\n### 概要\n\n>1. interrupt()说明\n>2. 终止线程的方式\n>3. 终止线程的示例\n\n### 1. interrupt()说明\n\n>在介绍终止线程的方式之前，有必要先对interrupt()进行了解。\n>关于interrupt()，java的djk文档描述如下：<http://docs.oracle.com/javase/7/docs/api/>\n>\n>```\n>Interrupts this thread.Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.\n>\n>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.\n>\n>If this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a ClosedByInterruptException.\n>\n>If this thread is blocked in a Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked.\n>\n>If none of the previous conditions hold then this thread's interrupt status will be set.\n>\n>Interrupting a thread that is not alive need not have any effect.\n>```\n>\n>大致意思是：\n>\n>```\n>interrupt()的作用是中断本线程。\n>本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。\n>如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。\n>如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。\n>如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。\n>```\n>\n>\n\n### **2. 终止线程的方式**\n\n>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！ 下面，我先分别讨论线程在“阻塞状态”和“运行状态”的终止方式，然后再总结出一个通用的方式。\n>\n>### 2.1 终止处于“阻塞状态”的线程\n>\n>通常，我们通过“中断”方式终止处于“阻塞状态”的线程。\n>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的位置就能终止线程，形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    try {\n>        while (true) {\n>            // 执行任务...\n>        }\n>    } catch (InterruptedException ie) {  \n>        // 由于产生InterruptedException异常，退出while(true)循环，线程终止！\n>    }\n>}\n>```\n>\n>**说明**：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！\n>注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    while (true) {\n>        try {\n>            // 执行任务...\n>        } catch (InterruptedException ie) {  \n>            // InterruptedException在while(true)循环体内。\n>           // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出\n>            break;\n>        }\n>    }\n>}\n>```\n>\n>说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。\n>\n>### 2.2 终止处于“运行状态”的线程\n>\n>通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“**中断标记**”和“**额外添加标记**”。\n>**(01) 通过“中断标记”终止线程。**\n>形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    while (!isInterrupted()) {\n>        // 执行任务...\n>    }\n>}\n>```\n>\n>**说明**：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。\n>**注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。**\n>\n>上面上面说的可以通过一个小案例来测试:\n>\n>````\n>package concurrent;\n>\n>/**************************************\n> *      Author : zhangke\n> *      Date   : 2018/7/12 20:09\n> *      Desc   : \n> ***************************************/\n>public class InterruptedTest {\n>    public static void main(String[] args) {\n>        try {\n>            Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is new.\");\n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() + \n>            \t\t\" (\" + t1.getState() + \") is started.\");\n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(10);\n>            t1.interrupt();\n>            System.out.println(t1.getName() \n>            \t\t\t+ \" (\" + t1.getState() + \") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() \n>            \t\t\t+ \" (\" + t1.getState() + \") is interrupted now.\");\n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>\n>    }\n>\n>    static class MyThread extends Thread {\n>\n>        public MyThread(String name) {\n>            super(name);\n>        }\n>\n>        @Override\n>        public void run() {\n>\n>            int i = 0;\n>            while (!isInterrupted()) {\n>                i++;\n>                if (i % 100000 == 0)\n>                    System.out.println(Thread.currentThread().getName() \n>                    \t\t+ \" (\" + this.getState() + \") loop \" + i);\n>            }\n>            while (true) {\n>                System.out.println(\"test\");\n>            }\n>\n>        }\n>    }\n>}\n>\n>\n>````\n>\n>运行结果:\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 100000\n>t1 (RUNNABLE) loop 200000\n>test\n>test\n>test\n>test\n>test\n>test\n>test\n>..........\n>```\n>\n>通过上面的例子可以看出，interrupt方法只是产生了中断标记，但是并没有暂停当前线程。否则就不会出现test这个字符\n>\n>**(02) 通过“额外添加标记”。**\n>形式如下：\n>\n>```\n>private volatile boolean flag= true;\n>protected void stopTask() {\n>    flag = false;\n>}\n>\n>@Override\n>public void run() {\n>    while (flag) {\n>        // 执行任务...\n>    }\n>}\n>```\n>\n>**说明**：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。\n>注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。\n>\n>综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    try {\n>        // 1. isInterrupted()保证，只要中断标记为true就终止线程。\n>        while (!isInterrupted()) {\n>            // 执行任务...\n>        }\n>    } catch (InterruptedException ie) {  \n>        // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。\n>    }\n>}\n>```\n>\n>\n\n### **3. 终止线程的示例**\n\n>interrupt()常常被用来终止“阻塞状态”线程。参考下面示例：\n>\n>```\n>// Demo1.java的源码\n>class MyThread extends Thread {\n>    \n>    public MyThread(String name) {\n>        super(name);\n>    }\n>\n>    @Override\n>    public void run() {\n>        try {  \n>            int i=0;\n>            while (!isInterrupted()) {\n>                Thread.sleep(100); // 休眠100ms\n>                i++;\n>                System.out.println(Thread.currentThread().getName()+\" \n>                (\"+this.getState()+\") loop \" + i);  \n>            }\n>        } catch (InterruptedException e) {  \n>            System.out.println(Thread.currentThread().getName() +\n>            \" (\"+this.getState()+\") catch InterruptedException.\");  \n>        }\n>    }\n>}\n>\n>public class Demo1 {\n>\n>    public static void main(String[] args) {  \n>        try {  \n>            Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\");  \n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\");  \n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(300);\n>            t1.interrupt();\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() \n>            \t\t+\" (\"+t1.getState()+\") is interrupted now.\");\n>        } catch (InterruptedException e) {  \n>            e.printStackTrace();\n>        }\n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 1\n>t1 (RUNNABLE) loop 2\n>t1 (TIMED_WAITING) is interrupted.\n>t1 (RUNNABLE) catch InterruptedException.\n>t1 (TERMINATED) is interrupted now.\n>```\n>\n>**结果说明**：\n>(01) 主线程main中通过new MyThread(\"t1\")创建线程t1，之后通过t1.start()启动线程t1。\n>(02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。\n>(03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。\n>\n>我们对上面的结果进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。\n>\n>```\n>// Demo2.java的源码\n>class MyThread extends Thread {\n>    \n>    public MyThread(String name) {\n>        super(name);\n>    }\n>\n>    @Override\n>    public void run() {\n>        int i=0;\n>        while (!isInterrupted()) {\n>            try {\n>                Thread.sleep(100); // 休眠100ms\n>            } catch (InterruptedException ie) {  \n>                System.out.println(Thread.currentThread().getName() \n>                \t\t+\" (\"+this.getState()+\") catch InterruptedException.\");  \n>            }\n>            i++;\n>            System.out.println(Thread.currentThread().getName()+\n>            \t\" (\"+this.getState()+\") loop \" + i);  \n>        }\n>    }\n>}\n>\n>public class Demo2 {\n>\n>    public static void main(String[] args) {  \n>        try {  \n>            Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\");  \n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\");  \n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(300);\n>            t1.interrupt();\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() +\n>            \t\t\t\" (\"+t1.getState()+\") is interrupted now.\");\n>        } catch (InterruptedException e) {  \n>            e.printStackTrace();\n>        }\n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 1\n>t1 (RUNNABLE) loop 2\n>t1 (TIMED_WAITING) is interrupted.\n>t1 (RUNNABLE) catch InterruptedException.\n>t1 (RUNNABLE) loop 3\n>t1 (RUNNABLE) loop 4\n>t1 (RUNNABLE) loop 5\n>t1 (TIMED_WAITING) is interrupted now.\n>t1 (RUNNABLE) loop 6\n>t1 (RUNNABLE) loop 7\n>t1 (RUNNABLE) loop 8\n>t1 (RUNNABLE) loop 9\n>...\n>```\n>\n>**结果说明**：\n>程序进入了死循环！\n>为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。\n>解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。\n>\n>同时这个也说明interrupt只是产生了中断标记，并没有终止当前线程。\n>\n>下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例：\n>\n>```\n>// Demo3.java的源码\n>class MyThread extends Thread {\n>\n>    private volatile boolean flag= true;\n>    public void stopTask() {\n>        flag = false;\n>    }\n>    \n>    public MyThread(String name) {\n>        super(name);\n>    }\n>\n>    @Override\n>    public void run() {\n>        synchronized(this) {\n>            try {\n>                int i=0;\n>                while (flag) {\n>                    Thread.sleep(100); // 休眠100ms\n>                    i++;\n>                    System.out.println(Thread.currentThread().getName()+\n>                    \t\t\" (\"+this.getState()+\") loop \" + i);  \n>                }\n>            } catch (InterruptedException ie) {  \n>                System.out.println(Thread.currentThread().getName() +\n>                \t\t\" (\"+this.getState()+\") catch InterruptedException.\");  \n>            }\n>        }  \n>    }\n>}\n>\n>public class Demo3 {\n>\n>    public static void main(String[] args) {  \n>        try {  \n>            MyThread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\");  \n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\");  \n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(300);\n>            t1.stopTask();\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted now.\");\n>        } catch (InterruptedException e) {  \n>            e.printStackTrace();\n>        }\n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 1\n>t1 (RUNNABLE) loop 2\n>t1 (TIMED_WAITING) is interrupted.\n>t1 (RUNNABLE) loop 3\n>t1 (TERMINATED) is interrupted now.\n>```\n>\n>\n\n### **4. interrupted() 和 isInterrupted()的区别**\n\n>最后谈谈 interrupted() 和 isInterrupted()。\n>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。\n>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。\n\n\n\n\n\n","source":"_posts/threads/java多线程系列 05 interrupt()和线程终止方式.md","raw":"abbrlink: 6\ntitle: ' Java多线程系列 05 interrupt()和线程终止方式'\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-13 11:11:00\n---\n# Java多线程系列 05 interrupt()和线程终止方式\n\n### 概要\n\n>1. interrupt()说明\n>2. 终止线程的方式\n>3. 终止线程的示例\n\n### 1. interrupt()说明\n\n>在介绍终止线程的方式之前，有必要先对interrupt()进行了解。\n>关于interrupt()，java的djk文档描述如下：<http://docs.oracle.com/javase/7/docs/api/>\n>\n>```\n>Interrupts this thread.Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.\n>\n>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.\n>\n>If this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a ClosedByInterruptException.\n>\n>If this thread is blocked in a Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked.\n>\n>If none of the previous conditions hold then this thread's interrupt status will be set.\n>\n>Interrupting a thread that is not alive need not have any effect.\n>```\n>\n>大致意思是：\n>\n>```\n>interrupt()的作用是中断本线程。\n>本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。\n>如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。\n>如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。\n>如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。\n>```\n>\n>\n\n### **2. 终止线程的方式**\n\n>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！ 下面，我先分别讨论线程在“阻塞状态”和“运行状态”的终止方式，然后再总结出一个通用的方式。\n>\n>### 2.1 终止处于“阻塞状态”的线程\n>\n>通常，我们通过“中断”方式终止处于“阻塞状态”的线程。\n>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的位置就能终止线程，形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    try {\n>        while (true) {\n>            // 执行任务...\n>        }\n>    } catch (InterruptedException ie) {  \n>        // 由于产生InterruptedException异常，退出while(true)循环，线程终止！\n>    }\n>}\n>```\n>\n>**说明**：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！\n>注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    while (true) {\n>        try {\n>            // 执行任务...\n>        } catch (InterruptedException ie) {  \n>            // InterruptedException在while(true)循环体内。\n>           // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出\n>            break;\n>        }\n>    }\n>}\n>```\n>\n>说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。\n>\n>### 2.2 终止处于“运行状态”的线程\n>\n>通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“**中断标记**”和“**额外添加标记**”。\n>**(01) 通过“中断标记”终止线程。**\n>形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    while (!isInterrupted()) {\n>        // 执行任务...\n>    }\n>}\n>```\n>\n>**说明**：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。\n>**注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。**\n>\n>上面上面说的可以通过一个小案例来测试:\n>\n>````\n>package concurrent;\n>\n>/**************************************\n> *      Author : zhangke\n> *      Date   : 2018/7/12 20:09\n> *      Desc   : \n> ***************************************/\n>public class InterruptedTest {\n>    public static void main(String[] args) {\n>        try {\n>            Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is new.\");\n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() + \n>            \t\t\" (\" + t1.getState() + \") is started.\");\n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(10);\n>            t1.interrupt();\n>            System.out.println(t1.getName() \n>            \t\t\t+ \" (\" + t1.getState() + \") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() \n>            \t\t\t+ \" (\" + t1.getState() + \") is interrupted now.\");\n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>\n>    }\n>\n>    static class MyThread extends Thread {\n>\n>        public MyThread(String name) {\n>            super(name);\n>        }\n>\n>        @Override\n>        public void run() {\n>\n>            int i = 0;\n>            while (!isInterrupted()) {\n>                i++;\n>                if (i % 100000 == 0)\n>                    System.out.println(Thread.currentThread().getName() \n>                    \t\t+ \" (\" + this.getState() + \") loop \" + i);\n>            }\n>            while (true) {\n>                System.out.println(\"test\");\n>            }\n>\n>        }\n>    }\n>}\n>\n>\n>````\n>\n>运行结果:\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 100000\n>t1 (RUNNABLE) loop 200000\n>test\n>test\n>test\n>test\n>test\n>test\n>test\n>..........\n>```\n>\n>通过上面的例子可以看出，interrupt方法只是产生了中断标记，但是并没有暂停当前线程。否则就不会出现test这个字符\n>\n>**(02) 通过“额外添加标记”。**\n>形式如下：\n>\n>```\n>private volatile boolean flag= true;\n>protected void stopTask() {\n>    flag = false;\n>}\n>\n>@Override\n>public void run() {\n>    while (flag) {\n>        // 执行任务...\n>    }\n>}\n>```\n>\n>**说明**：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。\n>注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。\n>\n>综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    try {\n>        // 1. isInterrupted()保证，只要中断标记为true就终止线程。\n>        while (!isInterrupted()) {\n>            // 执行任务...\n>        }\n>    } catch (InterruptedException ie) {  \n>        // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。\n>    }\n>}\n>```\n>\n>\n\n### **3. 终止线程的示例**\n\n>interrupt()常常被用来终止“阻塞状态”线程。参考下面示例：\n>\n>```\n>// Demo1.java的源码\n>class MyThread extends Thread {\n>    \n>    public MyThread(String name) {\n>        super(name);\n>    }\n>\n>    @Override\n>    public void run() {\n>        try {  \n>            int i=0;\n>            while (!isInterrupted()) {\n>                Thread.sleep(100); // 休眠100ms\n>                i++;\n>                System.out.println(Thread.currentThread().getName()+\" \n>                (\"+this.getState()+\") loop \" + i);  \n>            }\n>        } catch (InterruptedException e) {  \n>            System.out.println(Thread.currentThread().getName() +\n>            \" (\"+this.getState()+\") catch InterruptedException.\");  \n>        }\n>    }\n>}\n>\n>public class Demo1 {\n>\n>    public static void main(String[] args) {  \n>        try {  \n>            Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\");  \n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\");  \n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(300);\n>            t1.interrupt();\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() \n>            \t\t+\" (\"+t1.getState()+\") is interrupted now.\");\n>        } catch (InterruptedException e) {  \n>            e.printStackTrace();\n>        }\n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 1\n>t1 (RUNNABLE) loop 2\n>t1 (TIMED_WAITING) is interrupted.\n>t1 (RUNNABLE) catch InterruptedException.\n>t1 (TERMINATED) is interrupted now.\n>```\n>\n>**结果说明**：\n>(01) 主线程main中通过new MyThread(\"t1\")创建线程t1，之后通过t1.start()启动线程t1。\n>(02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。\n>(03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。\n>\n>我们对上面的结果进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。\n>\n>```\n>// Demo2.java的源码\n>class MyThread extends Thread {\n>    \n>    public MyThread(String name) {\n>        super(name);\n>    }\n>\n>    @Override\n>    public void run() {\n>        int i=0;\n>        while (!isInterrupted()) {\n>            try {\n>                Thread.sleep(100); // 休眠100ms\n>            } catch (InterruptedException ie) {  \n>                System.out.println(Thread.currentThread().getName() \n>                \t\t+\" (\"+this.getState()+\") catch InterruptedException.\");  \n>            }\n>            i++;\n>            System.out.println(Thread.currentThread().getName()+\n>            \t\" (\"+this.getState()+\") loop \" + i);  \n>        }\n>    }\n>}\n>\n>public class Demo2 {\n>\n>    public static void main(String[] args) {  \n>        try {  \n>            Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\");  \n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\");  \n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(300);\n>            t1.interrupt();\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() +\n>            \t\t\t\" (\"+t1.getState()+\") is interrupted now.\");\n>        } catch (InterruptedException e) {  \n>            e.printStackTrace();\n>        }\n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 1\n>t1 (RUNNABLE) loop 2\n>t1 (TIMED_WAITING) is interrupted.\n>t1 (RUNNABLE) catch InterruptedException.\n>t1 (RUNNABLE) loop 3\n>t1 (RUNNABLE) loop 4\n>t1 (RUNNABLE) loop 5\n>t1 (TIMED_WAITING) is interrupted now.\n>t1 (RUNNABLE) loop 6\n>t1 (RUNNABLE) loop 7\n>t1 (RUNNABLE) loop 8\n>t1 (RUNNABLE) loop 9\n>...\n>```\n>\n>**结果说明**：\n>程序进入了死循环！\n>为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。\n>解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。\n>\n>同时这个也说明interrupt只是产生了中断标记，并没有终止当前线程。\n>\n>下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例：\n>\n>```\n>// Demo3.java的源码\n>class MyThread extends Thread {\n>\n>    private volatile boolean flag= true;\n>    public void stopTask() {\n>        flag = false;\n>    }\n>    \n>    public MyThread(String name) {\n>        super(name);\n>    }\n>\n>    @Override\n>    public void run() {\n>        synchronized(this) {\n>            try {\n>                int i=0;\n>                while (flag) {\n>                    Thread.sleep(100); // 休眠100ms\n>                    i++;\n>                    System.out.println(Thread.currentThread().getName()+\n>                    \t\t\" (\"+this.getState()+\") loop \" + i);  \n>                }\n>            } catch (InterruptedException ie) {  \n>                System.out.println(Thread.currentThread().getName() +\n>                \t\t\" (\"+this.getState()+\") catch InterruptedException.\");  \n>            }\n>        }  \n>    }\n>}\n>\n>public class Demo3 {\n>\n>    public static void main(String[] args) {  \n>        try {  \n>            MyThread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\");  \n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\");  \n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(300);\n>            t1.stopTask();\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted now.\");\n>        } catch (InterruptedException e) {  \n>            e.printStackTrace();\n>        }\n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 1\n>t1 (RUNNABLE) loop 2\n>t1 (TIMED_WAITING) is interrupted.\n>t1 (RUNNABLE) loop 3\n>t1 (TERMINATED) is interrupted now.\n>```\n>\n>\n\n### **4. interrupted() 和 isInterrupted()的区别**\n\n>最后谈谈 interrupted() 和 isInterrupted()。\n>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。\n>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。\n\n\n\n\n\n","slug":"threads/java多线程系列 05 interrupt()和线程终止方式","published":1,"updated":"2019-01-04T01:48:59.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovtb002y9q1uu17i2h5f","content":"<h1 id=\"Java多线程系列-05-interrupt-和线程终止方式\"><a href=\"#Java多线程系列-05-interrupt-和线程终止方式\" class=\"headerlink\" title=\"Java多线程系列 05 interrupt()和线程终止方式\"></a>Java多线程系列 05 interrupt()和线程终止方式</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>interrupt()说明</li>\n<li>终止线程的方式</li>\n<li>终止线程的示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-interrupt-说明\"><a href=\"#1-interrupt-说明\" class=\"headerlink\" title=\"1. interrupt()说明\"></a>1. interrupt()说明</h3><blockquote>\n<p>在介绍终止线程的方式之前，有必要先对interrupt()进行了解。<br>关于interrupt()，java的djk文档描述如下：<a href=\"http://docs.oracle.com/javase/7/docs/api/\" target=\"_blank\" rel=\"noopener\">http://docs.oracle.com/javase/7/docs/api/</a></p>\n<pre><code>Interrupts this thread.Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.\n\nIf this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.\n\nIf this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread&#39;s interrupt status will be set, and the thread will receive a ClosedByInterruptException.\n\nIf this thread is blocked in a Selector then the thread&#39;s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector&#39;s wakeup method were invoked.\n\nIf none of the previous conditions hold then this thread&#39;s interrupt status will be set.\n\nInterrupting a thread that is not alive need not have any effect.\n</code></pre><p>大致意思是：</p>\n<pre><code>interrupt()的作用是中断本线程。\n本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。\n如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。\n如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。\n如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。\n</code></pre></blockquote>\n<h3 id=\"2-终止线程的方式\"><a href=\"#2-终止线程的方式\" class=\"headerlink\" title=\"2. 终止线程的方式\"></a><strong>2. 终止线程的方式</strong></h3><blockquote>\n<p>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！ 下面，我先分别讨论线程在“阻塞状态”和“运行状态”的终止方式，然后再总结出一个通用的方式。</p>\n<h3 id=\"2-1-终止处于“阻塞状态”的线程\"><a href=\"#2-1-终止处于“阻塞状态”的线程\" class=\"headerlink\" title=\"2.1 终止处于“阻塞状态”的线程\"></a>2.1 终止处于“阻塞状态”的线程</h3><p>通常，我们通过“中断”方式终止处于“阻塞状态”的线程。<br>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的位置就能终止线程，形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   try {\n       while (true) {\n           // 执行任务...\n       }\n   } catch (InterruptedException ie) {  \n       // 由于产生InterruptedException异常，退出while(true)循环，线程终止！\n   }\n}\n</code></pre><p><strong>说明</strong>：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！<br>注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   while (true) {\n       try {\n           // 执行任务...\n       } catch (InterruptedException ie) {  \n           // InterruptedException在while(true)循环体内。\n          // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出\n           break;\n       }\n   }\n}\n</code></pre><p>说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。</p>\n<h3 id=\"2-2-终止处于“运行状态”的线程\"><a href=\"#2-2-终止处于“运行状态”的线程\" class=\"headerlink\" title=\"2.2 终止处于“运行状态”的线程\"></a>2.2 终止处于“运行状态”的线程</h3><p>通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“<strong>中断标记</strong>”和“<strong>额外添加标记</strong>”。<br><strong>(01) 通过“中断标记”终止线程。</strong><br>形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   while (!isInterrupted()) {\n       // 执行任务...\n   }\n}\n</code></pre><p><strong>说明</strong>：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。<br><strong>注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。</strong></p>\n<p>上面上面说的可以通过一个小案例来测试:</p>\n<pre><code>package concurrent;\n\n/**************************************\n*      Author : zhangke\n*      Date   : 2018/7/12 20:09\n*      Desc   : \n***************************************/\npublic class InterruptedTest {\n   public static void main(String[] args) {\n       try {\n           Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is new.&quot;);\n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() + \n                   &quot; (&quot; + t1.getState() + &quot;) is started.&quot;);\n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(10);\n           t1.interrupt();\n           System.out.println(t1.getName() \n                       + &quot; (&quot; + t1.getState() + &quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() \n                       + &quot; (&quot; + t1.getState() + &quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n   }\n\n   static class MyThread extends Thread {\n\n       public MyThread(String name) {\n           super(name);\n       }\n\n       @Override\n       public void run() {\n\n           int i = 0;\n           while (!isInterrupted()) {\n               i++;\n               if (i % 100000 == 0)\n                   System.out.println(Thread.currentThread().getName() \n                           + &quot; (&quot; + this.getState() + &quot;) loop &quot; + i);\n           }\n           while (true) {\n               System.out.println(&quot;test&quot;);\n           }\n\n       }\n   }\n}\n\n\n</code></pre><p>运行结果:</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 100000\nt1 (RUNNABLE) loop 200000\ntest\ntest\ntest\ntest\ntest\ntest\ntest\n..........\n</code></pre><p>通过上面的例子可以看出，interrupt方法只是产生了中断标记，但是并没有暂停当前线程。否则就不会出现test这个字符</p>\n<p><strong>(02) 通过“额外添加标记”。</strong><br>形式如下：</p>\n<pre><code>private volatile boolean flag= true;\nprotected void stopTask() {\n   flag = false;\n}\n\n@Override\npublic void run() {\n   while (flag) {\n       // 执行任务...\n   }\n}\n</code></pre><p><strong>说明</strong>：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。<br>注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。</p>\n<p>综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   try {\n       // 1. isInterrupted()保证，只要中断标记为true就终止线程。\n       while (!isInterrupted()) {\n           // 执行任务...\n       }\n   } catch (InterruptedException ie) {  \n       // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。\n   }\n}\n</code></pre></blockquote>\n<h3 id=\"3-终止线程的示例\"><a href=\"#3-终止线程的示例\" class=\"headerlink\" title=\"3. 终止线程的示例\"></a><strong>3. 终止线程的示例</strong></h3><blockquote>\n<p>interrupt()常常被用来终止“阻塞状态”线程。参考下面示例：</p>\n<pre><code>// Demo1.java的源码\nclass MyThread extends Thread {\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       try {  \n           int i=0;\n           while (!isInterrupted()) {\n               Thread.sleep(100); // 休眠100ms\n               i++;\n               System.out.println(Thread.currentThread().getName()+&quot; \n               (&quot;+this.getState()+&quot;) loop &quot; + i);  \n           }\n       } catch (InterruptedException e) {  \n           System.out.println(Thread.currentThread().getName() +\n           &quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  \n       }\n   }\n}\n\npublic class Demo1 {\n\n   public static void main(String[] args) {  \n       try {  \n           Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  \n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  \n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(300);\n           t1.interrupt();\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() \n                   +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {  \n           e.printStackTrace();\n       }\n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) catch InterruptedException.\nt1 (TERMINATED) is interrupted now.\n</code></pre><p><strong>结果说明</strong>：<br>(01) 主线程main中通过new MyThread(“t1”)创建线程t1，之后通过t1.start()启动线程t1。<br>(02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。<br>(03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。</p>\n<p>我们对上面的结果进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。</p>\n<pre><code>// Demo2.java的源码\nclass MyThread extends Thread {\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       int i=0;\n       while (!isInterrupted()) {\n           try {\n               Thread.sleep(100); // 休眠100ms\n           } catch (InterruptedException ie) {  \n               System.out.println(Thread.currentThread().getName() \n                       +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  \n           }\n           i++;\n           System.out.println(Thread.currentThread().getName()+\n               &quot; (&quot;+this.getState()+&quot;) loop &quot; + i);  \n       }\n   }\n}\n\npublic class Demo2 {\n\n   public static void main(String[] args) {  \n       try {  \n           Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  \n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  \n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(300);\n           t1.interrupt();\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() +\n                       &quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {  \n           e.printStackTrace();\n       }\n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) catch InterruptedException.\nt1 (RUNNABLE) loop 3\nt1 (RUNNABLE) loop 4\nt1 (RUNNABLE) loop 5\nt1 (TIMED_WAITING) is interrupted now.\nt1 (RUNNABLE) loop 6\nt1 (RUNNABLE) loop 7\nt1 (RUNNABLE) loop 8\nt1 (RUNNABLE) loop 9\n...\n</code></pre><p><strong>结果说明</strong>：<br>程序进入了死循环！<br>为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。<br>解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。</p>\n<p>同时这个也说明interrupt只是产生了中断标记，并没有终止当前线程。</p>\n<p>下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例：</p>\n<pre><code>// Demo3.java的源码\nclass MyThread extends Thread {\n\n   private volatile boolean flag= true;\n   public void stopTask() {\n       flag = false;\n   }\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       synchronized(this) {\n           try {\n               int i=0;\n               while (flag) {\n                   Thread.sleep(100); // 休眠100ms\n                   i++;\n                   System.out.println(Thread.currentThread().getName()+\n                           &quot; (&quot;+this.getState()+&quot;) loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n               System.out.println(Thread.currentThread().getName() +\n                       &quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  \n           }\n       }  \n   }\n}\n\npublic class Demo3 {\n\n   public static void main(String[] args) {  \n       try {  \n           MyThread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  \n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  \n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(300);\n           t1.stopTask();\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {  \n           e.printStackTrace();\n       }\n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) loop 3\nt1 (TERMINATED) is interrupted now.\n</code></pre></blockquote>\n<h3 id=\"4-interrupted-和-isInterrupted-的区别\"><a href=\"#4-interrupted-和-isInterrupted-的区别\" class=\"headerlink\" title=\"4. interrupted() 和 isInterrupted()的区别\"></a><strong>4. interrupted() 和 isInterrupted()的区别</strong></h3><blockquote>\n<p>最后谈谈 interrupted() 和 isInterrupted()。<br>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。<br>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java多线程系列-05-interrupt-和线程终止方式\"><a href=\"#Java多线程系列-05-interrupt-和线程终止方式\" class=\"headerlink\" title=\"Java多线程系列 05 interrupt()和线程终止方式\"></a>Java多线程系列 05 interrupt()和线程终止方式</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>interrupt()说明</li>\n<li>终止线程的方式</li>\n<li>终止线程的示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-interrupt-说明\"><a href=\"#1-interrupt-说明\" class=\"headerlink\" title=\"1. interrupt()说明\"></a>1. interrupt()说明</h3><blockquote>\n<p>在介绍终止线程的方式之前，有必要先对interrupt()进行了解。<br>关于interrupt()，java的djk文档描述如下：<a href=\"http://docs.oracle.com/javase/7/docs/api/\" target=\"_blank\" rel=\"noopener\">http://docs.oracle.com/javase/7/docs/api/</a></p>\n<pre><code>Interrupts this thread.Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.\n\nIf this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.\n\nIf this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread&#39;s interrupt status will be set, and the thread will receive a ClosedByInterruptException.\n\nIf this thread is blocked in a Selector then the thread&#39;s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector&#39;s wakeup method were invoked.\n\nIf none of the previous conditions hold then this thread&#39;s interrupt status will be set.\n\nInterrupting a thread that is not alive need not have any effect.\n</code></pre><p>大致意思是：</p>\n<pre><code>interrupt()的作用是中断本线程。\n本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。\n如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。\n如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。\n如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。\n</code></pre></blockquote>\n<h3 id=\"2-终止线程的方式\"><a href=\"#2-终止线程的方式\" class=\"headerlink\" title=\"2. 终止线程的方式\"></a><strong>2. 终止线程的方式</strong></h3><blockquote>\n<p>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！ 下面，我先分别讨论线程在“阻塞状态”和“运行状态”的终止方式，然后再总结出一个通用的方式。</p>\n<h3 id=\"2-1-终止处于“阻塞状态”的线程\"><a href=\"#2-1-终止处于“阻塞状态”的线程\" class=\"headerlink\" title=\"2.1 终止处于“阻塞状态”的线程\"></a>2.1 终止处于“阻塞状态”的线程</h3><p>通常，我们通过“中断”方式终止处于“阻塞状态”的线程。<br>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的位置就能终止线程，形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   try {\n       while (true) {\n           // 执行任务...\n       }\n   } catch (InterruptedException ie) {  \n       // 由于产生InterruptedException异常，退出while(true)循环，线程终止！\n   }\n}\n</code></pre><p><strong>说明</strong>：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！<br>注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   while (true) {\n       try {\n           // 执行任务...\n       } catch (InterruptedException ie) {  \n           // InterruptedException在while(true)循环体内。\n          // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出\n           break;\n       }\n   }\n}\n</code></pre><p>说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。</p>\n<h3 id=\"2-2-终止处于“运行状态”的线程\"><a href=\"#2-2-终止处于“运行状态”的线程\" class=\"headerlink\" title=\"2.2 终止处于“运行状态”的线程\"></a>2.2 终止处于“运行状态”的线程</h3><p>通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“<strong>中断标记</strong>”和“<strong>额外添加标记</strong>”。<br><strong>(01) 通过“中断标记”终止线程。</strong><br>形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   while (!isInterrupted()) {\n       // 执行任务...\n   }\n}\n</code></pre><p><strong>说明</strong>：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。<br><strong>注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。</strong></p>\n<p>上面上面说的可以通过一个小案例来测试:</p>\n<pre><code>package concurrent;\n\n/**************************************\n*      Author : zhangke\n*      Date   : 2018/7/12 20:09\n*      Desc   : \n***************************************/\npublic class InterruptedTest {\n   public static void main(String[] args) {\n       try {\n           Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is new.&quot;);\n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() + \n                   &quot; (&quot; + t1.getState() + &quot;) is started.&quot;);\n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(10);\n           t1.interrupt();\n           System.out.println(t1.getName() \n                       + &quot; (&quot; + t1.getState() + &quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() \n                       + &quot; (&quot; + t1.getState() + &quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n   }\n\n   static class MyThread extends Thread {\n\n       public MyThread(String name) {\n           super(name);\n       }\n\n       @Override\n       public void run() {\n\n           int i = 0;\n           while (!isInterrupted()) {\n               i++;\n               if (i % 100000 == 0)\n                   System.out.println(Thread.currentThread().getName() \n                           + &quot; (&quot; + this.getState() + &quot;) loop &quot; + i);\n           }\n           while (true) {\n               System.out.println(&quot;test&quot;);\n           }\n\n       }\n   }\n}\n\n\n</code></pre><p>运行结果:</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 100000\nt1 (RUNNABLE) loop 200000\ntest\ntest\ntest\ntest\ntest\ntest\ntest\n..........\n</code></pre><p>通过上面的例子可以看出，interrupt方法只是产生了中断标记，但是并没有暂停当前线程。否则就不会出现test这个字符</p>\n<p><strong>(02) 通过“额外添加标记”。</strong><br>形式如下：</p>\n<pre><code>private volatile boolean flag= true;\nprotected void stopTask() {\n   flag = false;\n}\n\n@Override\npublic void run() {\n   while (flag) {\n       // 执行任务...\n   }\n}\n</code></pre><p><strong>说明</strong>：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。<br>注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。</p>\n<p>综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   try {\n       // 1. isInterrupted()保证，只要中断标记为true就终止线程。\n       while (!isInterrupted()) {\n           // 执行任务...\n       }\n   } catch (InterruptedException ie) {  \n       // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。\n   }\n}\n</code></pre></blockquote>\n<h3 id=\"3-终止线程的示例\"><a href=\"#3-终止线程的示例\" class=\"headerlink\" title=\"3. 终止线程的示例\"></a><strong>3. 终止线程的示例</strong></h3><blockquote>\n<p>interrupt()常常被用来终止“阻塞状态”线程。参考下面示例：</p>\n<pre><code>// Demo1.java的源码\nclass MyThread extends Thread {\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       try {  \n           int i=0;\n           while (!isInterrupted()) {\n               Thread.sleep(100); // 休眠100ms\n               i++;\n               System.out.println(Thread.currentThread().getName()+&quot; \n               (&quot;+this.getState()+&quot;) loop &quot; + i);  \n           }\n       } catch (InterruptedException e) {  \n           System.out.println(Thread.currentThread().getName() +\n           &quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  \n       }\n   }\n}\n\npublic class Demo1 {\n\n   public static void main(String[] args) {  \n       try {  \n           Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  \n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  \n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(300);\n           t1.interrupt();\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() \n                   +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {  \n           e.printStackTrace();\n       }\n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) catch InterruptedException.\nt1 (TERMINATED) is interrupted now.\n</code></pre><p><strong>结果说明</strong>：<br>(01) 主线程main中通过new MyThread(“t1”)创建线程t1，之后通过t1.start()启动线程t1。<br>(02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。<br>(03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。</p>\n<p>我们对上面的结果进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。</p>\n<pre><code>// Demo2.java的源码\nclass MyThread extends Thread {\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       int i=0;\n       while (!isInterrupted()) {\n           try {\n               Thread.sleep(100); // 休眠100ms\n           } catch (InterruptedException ie) {  \n               System.out.println(Thread.currentThread().getName() \n                       +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  \n           }\n           i++;\n           System.out.println(Thread.currentThread().getName()+\n               &quot; (&quot;+this.getState()+&quot;) loop &quot; + i);  \n       }\n   }\n}\n\npublic class Demo2 {\n\n   public static void main(String[] args) {  \n       try {  \n           Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  \n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  \n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(300);\n           t1.interrupt();\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() +\n                       &quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {  \n           e.printStackTrace();\n       }\n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) catch InterruptedException.\nt1 (RUNNABLE) loop 3\nt1 (RUNNABLE) loop 4\nt1 (RUNNABLE) loop 5\nt1 (TIMED_WAITING) is interrupted now.\nt1 (RUNNABLE) loop 6\nt1 (RUNNABLE) loop 7\nt1 (RUNNABLE) loop 8\nt1 (RUNNABLE) loop 9\n...\n</code></pre><p><strong>结果说明</strong>：<br>程序进入了死循环！<br>为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。<br>解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。</p>\n<p>同时这个也说明interrupt只是产生了中断标记，并没有终止当前线程。</p>\n<p>下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例：</p>\n<pre><code>// Demo3.java的源码\nclass MyThread extends Thread {\n\n   private volatile boolean flag= true;\n   public void stopTask() {\n       flag = false;\n   }\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       synchronized(this) {\n           try {\n               int i=0;\n               while (flag) {\n                   Thread.sleep(100); // 休眠100ms\n                   i++;\n                   System.out.println(Thread.currentThread().getName()+\n                           &quot; (&quot;+this.getState()+&quot;) loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n               System.out.println(Thread.currentThread().getName() +\n                       &quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  \n           }\n       }  \n   }\n}\n\npublic class Demo3 {\n\n   public static void main(String[] args) {  \n       try {  \n           MyThread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  \n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  \n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(300);\n           t1.stopTask();\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {  \n           e.printStackTrace();\n       }\n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) loop 3\nt1 (TERMINATED) is interrupted now.\n</code></pre></blockquote>\n<h3 id=\"4-interrupted-和-isInterrupted-的区别\"><a href=\"#4-interrupted-和-isInterrupted-的区别\" class=\"headerlink\" title=\"4. interrupted() 和 isInterrupted()的区别\"></a><strong>4. interrupted() 和 isInterrupted()的区别</strong></h3><blockquote>\n<p>最后谈谈 interrupted() 和 isInterrupted()。<br>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。<br>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。</p>\n</blockquote>\n"},{"abbrlink":12,"title":"java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建","author":"zhangke","date":"2018-07-24T05:58:00.000Z","_content":"#  java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建\n\n### 概要\n\n>1. 线程池的创建\n>2. ThreadFactory：线程创建工厂\n>3. RejectedExecutionHandler：任务拒绝策略\n\n###  1. 线程池的创建\n\n>ThreadPoolExecutor提供了四个创建线程池的构造函数，源码如下\n>\n>```\n>//构造函数\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)\n>\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler)\n>\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory)\n>\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n>\n>```\n>\n>虽然其提供了四个构造函数，但是前三个都是在调用最后一个来创建。\n>\n>threadFactory：如果不指定的话。默认是Executors.DefaultThreadFactory\n>\n>RejectedExecutionHandler：如果不指定默认是AbortPolicy\n>\n>下面是一个小的demo，创建线程池\n>\n>```\n>ArrayBlockingQueue<Runnable> queue = new ArrayBlockingQueue(4);\n>\n>//使用默认的threadFatory，和ArrayBlockingQueue，DiscardOldestPolicy来创建线程池\n>ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4,\n>       60, TimeUnit.SECONDS, queue, new ThreadPoolExecutor.DiscardOldestPolicy());\n>```\n>\n>\n\n### 2. ThreadFactory:线程创建工厂\n\n>在JUC中定义了线程创建工厂接口，也就是ThreadFactory接口，源码如下\n>\n>```\n>public interface ThreadFactory {\n>    Thread newThread(Runnable r);\n>}\n>```\n>\n>接口定义很简单，传递一个实现了Runnable接口的类，然后返回一个Thread对象，这和我们平常使用的new Thread其实没设么区别，只是在这里换成了工厂模式。\n>\n>ThreadPoolExecutor默认使用的是Executors.DefaultThreadFactory这个类，源码如下\n>\n>```\n>    static class DefaultThreadFactory implements ThreadFactory {\n>        private static final AtomicInteger poolNumber = new AtomicInteger(1);\n>        private final ThreadGroup group;\n>        private final AtomicInteger threadNumber = new AtomicInteger(1);\n>        private final String namePrefix;\n>\n>        DefaultThreadFactory() {\n>            SecurityManager s = System.getSecurityManager();\n>            //\n>            group = (s != null) ? s.getThreadGroup() :\n>                                  Thread.currentThread().getThreadGroup();\n>            //所有后面创建的线程，都都以这个下面这个字符串为前缀\n>            namePrefix = \"pool-\" +\n>                          poolNumber.getAndIncrement() +\n>                         \"-thread-\";\n>        }\n>\n>        public Thread newThread(Runnable r) {\n>        \t//创建线程\n>            Thread t = new Thread(group, r,\n>                                  namePrefix + threadNumber.getAndIncrement(),\n>                                  0);\n>            //设置线程的优先级和线程不是daemon线程\n>            if (t.isDaemon())\n>                t.setDaemon(false);\n>            if (t.getPriority() != Thread.NORM_PRIORITY)\n>                t.setPriority(Thread.NORM_PRIORITY);\n>            return t;\n>        }\n>    }\n>```\n>\n>分析：\n>\n>是在Executors内部实现的一个内部静态类，这个类的定义很简单，就是创建一个ThreadGroup，将后面使用newThread创建的线程放到这个group中，然后设置所有的线程都不是daemon线程，并且设置线程优先级为\n>\n>NORM_PRIORITY。\n\n### 3. RejectedExecutionHandler：任务拒绝策略\n\n>线程池堵塞队列容量满之后，将会直接新建线程，数量等于 `maximumPoolSize` 后，将会执行任务拒绝策略不在接受任务，有以下四种拒绝策略：\n>\n>1. ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。\n>2. ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。\n>3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\n>4. ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务,也就是放在当前线程上运行，知道执行完成。\n\n","source":"_posts/juc/threads/java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建.md","raw":"abbrlink: 12\ntitle: java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建\ntags:\n  - JUC\n  - 线程池\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-24 13:58:00\n---\n#  java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建\n\n### 概要\n\n>1. 线程池的创建\n>2. ThreadFactory：线程创建工厂\n>3. RejectedExecutionHandler：任务拒绝策略\n\n###  1. 线程池的创建\n\n>ThreadPoolExecutor提供了四个创建线程池的构造函数，源码如下\n>\n>```\n>//构造函数\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)\n>\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler)\n>\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory)\n>\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n>\n>```\n>\n>虽然其提供了四个构造函数，但是前三个都是在调用最后一个来创建。\n>\n>threadFactory：如果不指定的话。默认是Executors.DefaultThreadFactory\n>\n>RejectedExecutionHandler：如果不指定默认是AbortPolicy\n>\n>下面是一个小的demo，创建线程池\n>\n>```\n>ArrayBlockingQueue<Runnable> queue = new ArrayBlockingQueue(4);\n>\n>//使用默认的threadFatory，和ArrayBlockingQueue，DiscardOldestPolicy来创建线程池\n>ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4,\n>       60, TimeUnit.SECONDS, queue, new ThreadPoolExecutor.DiscardOldestPolicy());\n>```\n>\n>\n\n### 2. ThreadFactory:线程创建工厂\n\n>在JUC中定义了线程创建工厂接口，也就是ThreadFactory接口，源码如下\n>\n>```\n>public interface ThreadFactory {\n>    Thread newThread(Runnable r);\n>}\n>```\n>\n>接口定义很简单，传递一个实现了Runnable接口的类，然后返回一个Thread对象，这和我们平常使用的new Thread其实没设么区别，只是在这里换成了工厂模式。\n>\n>ThreadPoolExecutor默认使用的是Executors.DefaultThreadFactory这个类，源码如下\n>\n>```\n>    static class DefaultThreadFactory implements ThreadFactory {\n>        private static final AtomicInteger poolNumber = new AtomicInteger(1);\n>        private final ThreadGroup group;\n>        private final AtomicInteger threadNumber = new AtomicInteger(1);\n>        private final String namePrefix;\n>\n>        DefaultThreadFactory() {\n>            SecurityManager s = System.getSecurityManager();\n>            //\n>            group = (s != null) ? s.getThreadGroup() :\n>                                  Thread.currentThread().getThreadGroup();\n>            //所有后面创建的线程，都都以这个下面这个字符串为前缀\n>            namePrefix = \"pool-\" +\n>                          poolNumber.getAndIncrement() +\n>                         \"-thread-\";\n>        }\n>\n>        public Thread newThread(Runnable r) {\n>        \t//创建线程\n>            Thread t = new Thread(group, r,\n>                                  namePrefix + threadNumber.getAndIncrement(),\n>                                  0);\n>            //设置线程的优先级和线程不是daemon线程\n>            if (t.isDaemon())\n>                t.setDaemon(false);\n>            if (t.getPriority() != Thread.NORM_PRIORITY)\n>                t.setPriority(Thread.NORM_PRIORITY);\n>            return t;\n>        }\n>    }\n>```\n>\n>分析：\n>\n>是在Executors内部实现的一个内部静态类，这个类的定义很简单，就是创建一个ThreadGroup，将后面使用newThread创建的线程放到这个group中，然后设置所有的线程都不是daemon线程，并且设置线程优先级为\n>\n>NORM_PRIORITY。\n\n### 3. RejectedExecutionHandler：任务拒绝策略\n\n>线程池堵塞队列容量满之后，将会直接新建线程，数量等于 `maximumPoolSize` 后，将会执行任务拒绝策略不在接受任务，有以下四种拒绝策略：\n>\n>1. ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。\n>2. ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。\n>3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\n>4. ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务,也就是放在当前线程上运行，知道执行完成。\n\n","slug":"juc/threads/java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建","published":1,"updated":"2019-01-04T01:48:59.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovtc00309q1uuqlj4dj7","content":"<h1 id=\"java多线程系列-JUC线程池之03-ThreadPoolExecutor-线程池的创建\"><a href=\"#java多线程系列-JUC线程池之03-ThreadPoolExecutor-线程池的创建\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建\"></a>java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>线程池的创建</li>\n<li>ThreadFactory：线程创建工厂</li>\n<li>RejectedExecutionHandler：任务拒绝策略</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程池的创建\"><a href=\"#1-线程池的创建\" class=\"headerlink\" title=\"1. 线程池的创建\"></a>1. 线程池的创建</h3><blockquote>\n<p>ThreadPoolExecutor提供了四个创建线程池的构造函数，源码如下</p>\n<pre><code>//构造函数\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)\n\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)\n\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)\n\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n\n</code></pre><p>虽然其提供了四个构造函数，但是前三个都是在调用最后一个来创建。</p>\n<p>threadFactory：如果不指定的话。默认是Executors.DefaultThreadFactory</p>\n<p>RejectedExecutionHandler：如果不指定默认是AbortPolicy</p>\n<p>下面是一个小的demo，创建线程池</p>\n<pre><code>ArrayBlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue(4);\n\n//使用默认的threadFatory，和ArrayBlockingQueue，DiscardOldestPolicy来创建线程池\nThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4,\n      60, TimeUnit.SECONDS, queue, new ThreadPoolExecutor.DiscardOldestPolicy());\n</code></pre></blockquote>\n<h3 id=\"2-ThreadFactory-线程创建工厂\"><a href=\"#2-ThreadFactory-线程创建工厂\" class=\"headerlink\" title=\"2. ThreadFactory:线程创建工厂\"></a>2. ThreadFactory:线程创建工厂</h3><blockquote>\n<p>在JUC中定义了线程创建工厂接口，也就是ThreadFactory接口，源码如下</p>\n<pre><code>public interface ThreadFactory {\n   Thread newThread(Runnable r);\n}\n</code></pre><p>接口定义很简单，传递一个实现了Runnable接口的类，然后返回一个Thread对象，这和我们平常使用的new Thread其实没设么区别，只是在这里换成了工厂模式。</p>\n<p>ThreadPoolExecutor默认使用的是Executors.DefaultThreadFactory这个类，源码如下</p>\n<pre><code>   static class DefaultThreadFactory implements ThreadFactory {\n       private static final AtomicInteger poolNumber = new AtomicInteger(1);\n       private final ThreadGroup group;\n       private final AtomicInteger threadNumber = new AtomicInteger(1);\n       private final String namePrefix;\n\n       DefaultThreadFactory() {\n           SecurityManager s = System.getSecurityManager();\n           //\n           group = (s != null) ? s.getThreadGroup() :\n                                 Thread.currentThread().getThreadGroup();\n           //所有后面创建的线程，都都以这个下面这个字符串为前缀\n           namePrefix = &quot;pool-&quot; +\n                         poolNumber.getAndIncrement() +\n                        &quot;-thread-&quot;;\n       }\n\n       public Thread newThread(Runnable r) {\n           //创建线程\n           Thread t = new Thread(group, r,\n                                 namePrefix + threadNumber.getAndIncrement(),\n                                 0);\n           //设置线程的优先级和线程不是daemon线程\n           if (t.isDaemon())\n               t.setDaemon(false);\n           if (t.getPriority() != Thread.NORM_PRIORITY)\n               t.setPriority(Thread.NORM_PRIORITY);\n           return t;\n       }\n   }\n</code></pre><p>分析：</p>\n<p>是在Executors内部实现的一个内部静态类，这个类的定义很简单，就是创建一个ThreadGroup，将后面使用newThread创建的线程放到这个group中，然后设置所有的线程都不是daemon线程，并且设置线程优先级为</p>\n<p>NORM_PRIORITY。</p>\n</blockquote>\n<h3 id=\"3-RejectedExecutionHandler：任务拒绝策略\"><a href=\"#3-RejectedExecutionHandler：任务拒绝策略\" class=\"headerlink\" title=\"3. RejectedExecutionHandler：任务拒绝策略\"></a>3. RejectedExecutionHandler：任务拒绝策略</h3><blockquote>\n<p>线程池堵塞队列容量满之后，将会直接新建线程，数量等于 <code>maximumPoolSize</code> 后，将会执行任务拒绝策略不在接受任务，有以下四种拒绝策略：</p>\n<ol>\n<li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</li>\n<li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务,也就是放在当前线程上运行，知道执行完成。</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-JUC线程池之03-ThreadPoolExecutor-线程池的创建\"><a href=\"#java多线程系列-JUC线程池之03-ThreadPoolExecutor-线程池的创建\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建\"></a>java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>线程池的创建</li>\n<li>ThreadFactory：线程创建工厂</li>\n<li>RejectedExecutionHandler：任务拒绝策略</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程池的创建\"><a href=\"#1-线程池的创建\" class=\"headerlink\" title=\"1. 线程池的创建\"></a>1. 线程池的创建</h3><blockquote>\n<p>ThreadPoolExecutor提供了四个创建线程池的构造函数，源码如下</p>\n<pre><code>//构造函数\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)\n\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)\n\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)\n\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n\n</code></pre><p>虽然其提供了四个构造函数，但是前三个都是在调用最后一个来创建。</p>\n<p>threadFactory：如果不指定的话。默认是Executors.DefaultThreadFactory</p>\n<p>RejectedExecutionHandler：如果不指定默认是AbortPolicy</p>\n<p>下面是一个小的demo，创建线程池</p>\n<pre><code>ArrayBlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue(4);\n\n//使用默认的threadFatory，和ArrayBlockingQueue，DiscardOldestPolicy来创建线程池\nThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4,\n      60, TimeUnit.SECONDS, queue, new ThreadPoolExecutor.DiscardOldestPolicy());\n</code></pre></blockquote>\n<h3 id=\"2-ThreadFactory-线程创建工厂\"><a href=\"#2-ThreadFactory-线程创建工厂\" class=\"headerlink\" title=\"2. ThreadFactory:线程创建工厂\"></a>2. ThreadFactory:线程创建工厂</h3><blockquote>\n<p>在JUC中定义了线程创建工厂接口，也就是ThreadFactory接口，源码如下</p>\n<pre><code>public interface ThreadFactory {\n   Thread newThread(Runnable r);\n}\n</code></pre><p>接口定义很简单，传递一个实现了Runnable接口的类，然后返回一个Thread对象，这和我们平常使用的new Thread其实没设么区别，只是在这里换成了工厂模式。</p>\n<p>ThreadPoolExecutor默认使用的是Executors.DefaultThreadFactory这个类，源码如下</p>\n<pre><code>   static class DefaultThreadFactory implements ThreadFactory {\n       private static final AtomicInteger poolNumber = new AtomicInteger(1);\n       private final ThreadGroup group;\n       private final AtomicInteger threadNumber = new AtomicInteger(1);\n       private final String namePrefix;\n\n       DefaultThreadFactory() {\n           SecurityManager s = System.getSecurityManager();\n           //\n           group = (s != null) ? s.getThreadGroup() :\n                                 Thread.currentThread().getThreadGroup();\n           //所有后面创建的线程，都都以这个下面这个字符串为前缀\n           namePrefix = &quot;pool-&quot; +\n                         poolNumber.getAndIncrement() +\n                        &quot;-thread-&quot;;\n       }\n\n       public Thread newThread(Runnable r) {\n           //创建线程\n           Thread t = new Thread(group, r,\n                                 namePrefix + threadNumber.getAndIncrement(),\n                                 0);\n           //设置线程的优先级和线程不是daemon线程\n           if (t.isDaemon())\n               t.setDaemon(false);\n           if (t.getPriority() != Thread.NORM_PRIORITY)\n               t.setPriority(Thread.NORM_PRIORITY);\n           return t;\n       }\n   }\n</code></pre><p>分析：</p>\n<p>是在Executors内部实现的一个内部静态类，这个类的定义很简单，就是创建一个ThreadGroup，将后面使用newThread创建的线程放到这个group中，然后设置所有的线程都不是daemon线程，并且设置线程优先级为</p>\n<p>NORM_PRIORITY。</p>\n</blockquote>\n<h3 id=\"3-RejectedExecutionHandler：任务拒绝策略\"><a href=\"#3-RejectedExecutionHandler：任务拒绝策略\" class=\"headerlink\" title=\"3. RejectedExecutionHandler：任务拒绝策略\"></a>3. RejectedExecutionHandler：任务拒绝策略</h3><blockquote>\n<p>线程池堵塞队列容量满之后，将会直接新建线程，数量等于 <code>maximumPoolSize</code> 后，将会执行任务拒绝策略不在接受任务，有以下四种拒绝策略：</p>\n<ol>\n<li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</li>\n<li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务,也就是放在当前线程上运行，知道执行完成。</li>\n</ol>\n</blockquote>\n"},{"abbrlink":20,"title":"Spring源码解析之 01环境搭建","author":"fengxiutianya","date":"2019-01-06T19:33:00.000Z","_content":"# spring源码解析之 01环境搭建\n\n### 概述\n\n1. 前提条件\n2. 环境搭建\n\n### 1. 前提条件\n\nSpring采用gradle来进行包管理，因此你需要安装gradle，这个网上面有很多的教程，就不在这里进行介绍。\n\n另外Spring的源码时放在github上，因此你需要安装git。\n\nspring 5 默认是jdk1.8以上的java版本 ，因此需要你本地的java环境是为1.8 以上。\n\n<!-- more -->\n\n### 2. 环境搭建\n\n1. 下载源代码\n\n   ```\n   git clone git@github.com:spring-projects/spring-framework.git\n   ```\n\n   下载好源码之后，因为git默认是在master分支上，本文使用的是**v5.1.3.RELEASE**，因此你需要切换到指定的版本下，使用下面命令\n\n   ```\n   git checkout v5.1.3.RELEASE\n   ```\n\n2. 导入IDE\n\n   在源码下面有俩个markdown文件，分别是**import-into-idea.md**和**import-into-eclipse.md**\n\n   这俩个文件分别针对俩大主流的IDE来介绍如何导入。我平常使用的IDE是idea，所以这篇文章也是介绍如何在idea搭建环境\n\n   导入分为俩步\n\n   1. 预先编译spring-oxm\n\n      切换到项目根目录，使用如下命令\n\n      ```\n      ./gradlew :spring-oxm:compileTestJava\n      ```\n\n   2. 导入项目\n\n      这里只有一点是需要注意的，选择导入环境时，选择gradle即可，其他的就是等待下载依赖和构建。这个过程时间挺长，不过这个和你的电脑配置以及网络有关。","source":"_posts/spring 源码分析/spring/spring源码解析之  01环境搭建.md","raw":"abbrlink: 20\ntitle: Spring源码解析之 01环境搭建\ntags:\n  - spring源码解析\n  - ''\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-07 03:33:00\n---\n# spring源码解析之 01环境搭建\n\n### 概述\n\n1. 前提条件\n2. 环境搭建\n\n### 1. 前提条件\n\nSpring采用gradle来进行包管理，因此你需要安装gradle，这个网上面有很多的教程，就不在这里进行介绍。\n\n另外Spring的源码时放在github上，因此你需要安装git。\n\nspring 5 默认是jdk1.8以上的java版本 ，因此需要你本地的java环境是为1.8 以上。\n\n<!-- more -->\n\n### 2. 环境搭建\n\n1. 下载源代码\n\n   ```\n   git clone git@github.com:spring-projects/spring-framework.git\n   ```\n\n   下载好源码之后，因为git默认是在master分支上，本文使用的是**v5.1.3.RELEASE**，因此你需要切换到指定的版本下，使用下面命令\n\n   ```\n   git checkout v5.1.3.RELEASE\n   ```\n\n2. 导入IDE\n\n   在源码下面有俩个markdown文件，分别是**import-into-idea.md**和**import-into-eclipse.md**\n\n   这俩个文件分别针对俩大主流的IDE来介绍如何导入。我平常使用的IDE是idea，所以这篇文章也是介绍如何在idea搭建环境\n\n   导入分为俩步\n\n   1. 预先编译spring-oxm\n\n      切换到项目根目录，使用如下命令\n\n      ```\n      ./gradlew :spring-oxm:compileTestJava\n      ```\n\n   2. 导入项目\n\n      这里只有一点是需要注意的，选择导入环境时，选择gradle即可，其他的就是等待下载依赖和构建。这个过程时间挺长，不过这个和你的电脑配置以及网络有关。","slug":"spring 源码分析/spring/spring源码解析之  01环境搭建","published":1,"updated":"2019-01-14T05:04:12.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovte00339q1u2r3zzccj","content":"<h1 id=\"spring源码解析之-01环境搭建\"><a href=\"#spring源码解析之-01环境搭建\" class=\"headerlink\" title=\"spring源码解析之 01环境搭建\"></a>spring源码解析之 01环境搭建</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>前提条件</li>\n<li>环境搭建</li>\n</ol>\n<h3 id=\"1-前提条件\"><a href=\"#1-前提条件\" class=\"headerlink\" title=\"1. 前提条件\"></a>1. 前提条件</h3><p>Spring采用gradle来进行包管理，因此你需要安装gradle，这个网上面有很多的教程，就不在这里进行介绍。</p>\n<p>另外Spring的源码时放在github上，因此你需要安装git。</p>\n<p>spring 5 默认是jdk1.8以上的java版本 ，因此需要你本地的java环境是为1.8 以上。</p>\n<a id=\"more\"></a>\n<h3 id=\"2-环境搭建\"><a href=\"#2-环境搭建\" class=\"headerlink\" title=\"2. 环境搭建\"></a>2. 环境搭建</h3><ol>\n<li><p>下载源代码</p>\n<pre><code>git clone git@github.com:spring-projects/spring-framework.git\n</code></pre><p>下载好源码之后，因为git默认是在master分支上，本文使用的是<strong>v5.1.3.RELEASE</strong>，因此你需要切换到指定的版本下，使用下面命令</p>\n<pre><code>git checkout v5.1.3.RELEASE\n</code></pre></li>\n<li><p>导入IDE</p>\n<p>在源码下面有俩个markdown文件，分别是<strong>import-into-idea.md</strong>和<strong>import-into-eclipse.md</strong></p>\n<p>这俩个文件分别针对俩大主流的IDE来介绍如何导入。我平常使用的IDE是idea，所以这篇文章也是介绍如何在idea搭建环境</p>\n<p>导入分为俩步</p>\n<ol>\n<li><p>预先编译spring-oxm</p>\n<p>切换到项目根目录，使用如下命令</p>\n<pre><code>./gradlew :spring-oxm:compileTestJava\n</code></pre></li>\n<li><p>导入项目</p>\n<p>这里只有一点是需要注意的，选择导入环境时，选择gradle即可，其他的就是等待下载依赖和构建。这个过程时间挺长，不过这个和你的电脑配置以及网络有关。</p>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-01环境搭建\"><a href=\"#spring源码解析之-01环境搭建\" class=\"headerlink\" title=\"spring源码解析之 01环境搭建\"></a>spring源码解析之 01环境搭建</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>前提条件</li>\n<li>环境搭建</li>\n</ol>\n<h3 id=\"1-前提条件\"><a href=\"#1-前提条件\" class=\"headerlink\" title=\"1. 前提条件\"></a>1. 前提条件</h3><p>Spring采用gradle来进行包管理，因此你需要安装gradle，这个网上面有很多的教程，就不在这里进行介绍。</p>\n<p>另外Spring的源码时放在github上，因此你需要安装git。</p>\n<p>spring 5 默认是jdk1.8以上的java版本 ，因此需要你本地的java环境是为1.8 以上。</p>","more":"<h3 id=\"2-环境搭建\"><a href=\"#2-环境搭建\" class=\"headerlink\" title=\"2. 环境搭建\"></a>2. 环境搭建</h3><ol>\n<li><p>下载源代码</p>\n<pre><code>git clone git@github.com:spring-projects/spring-framework.git\n</code></pre><p>下载好源码之后，因为git默认是在master分支上，本文使用的是<strong>v5.1.3.RELEASE</strong>，因此你需要切换到指定的版本下，使用下面命令</p>\n<pre><code>git checkout v5.1.3.RELEASE\n</code></pre></li>\n<li><p>导入IDE</p>\n<p>在源码下面有俩个markdown文件，分别是<strong>import-into-idea.md</strong>和<strong>import-into-eclipse.md</strong></p>\n<p>这俩个文件分别针对俩大主流的IDE来介绍如何导入。我平常使用的IDE是idea，所以这篇文章也是介绍如何在idea搭建环境</p>\n<p>导入分为俩步</p>\n<ol>\n<li><p>预先编译spring-oxm</p>\n<p>切换到项目根目录，使用如下命令</p>\n<pre><code>./gradlew :spring-oxm:compileTestJava\n</code></pre></li>\n<li><p>导入项目</p>\n<p>这里只有一点是需要注意的，选择导入环境时，选择gradle即可，其他的就是等待下载依赖和构建。这个过程时间挺长，不过这个和你的电脑配置以及网络有关。</p>\n</li>\n</ol>\n</li>\n</ol>"},{"abbrlink":27,"title":" Spring源码解析之 08bean标签：BeanDefinition","author":"fengxiutianya","date":"2019-01-13T21:12:00.000Z","_content":"# Spring源码解析之 08bean标签：BeanDefinition\n\n### 概述\n\n1. BeanDefinition 简介\n2. 解析Bean标签\n\n### BeanDefinition简介\n\nBeanDefinition 是一个接口，它描述了一个 Bean 实例，包括属性值、构造方法值和继承自它的类的更多信息。Spring通过BeanDefinition将配置文件中的\\< bean >配置文件转换为容器的内部表示，并将这些BeanDefinition注册到BeanDefinitionRegistry中。Spring容器的BeanDefinitionRegistry就像是spring配置信息的内存数据库，主要以map的形式保存，后续操作直接从BeanDefinitionRegistry中直接获取配置信息。\n<!-- more-->\n\n它继承 AttributeAccessor 和 BeanMetadataElement 接口。两个接口定义如下：\n\nAttributeAccessor ：定义了与其它对象的（元数据）进行连接和访问的约定，即对属性的修改，包括获取、设置、删除。\nBeanMetadataElement：Bean 元对象持有的配置元素可以通过getSource() 方法来获取。\n\nBeanDefinition继承关系图\n\n![BeanDefinition继承关系图](/images/pasted-10.png)\n\n我们常用的三个实现类有：ChildBeanDefinition、GenericBeanDefinition、RootBeanDefinition，三者都继承 AbstractBeanDefinition。如果配置文件中定义了父 `<bean>` 和 子 `<bean>` ，则父 `<bean>` 用 RootBeanDefinition表示，子 `<bean>` 用 ChildBeanDefinition 表示，而没有父 `<bean>` 的就使用RootBeanDefinition 表示。GenericBeanDefinition 为一站式服务类,通常在解析xml配置文件时，先将BeanDefinition解析为此类型。AbstractBeanDefinition对三个子类共同的类信息进行抽象。\n\n### 解析Bean标签\n\n在 `BeanDefinitionParserDelegate.parseBeanDefinitionElement()` 中完成 Bean 的解析，返回的是一个已经完成对 `<bean>` 标签解析的 BeanDefinition 实例。在该方法内部，首先调用 `createBeanDefinition()` 方法创建一个用于承载属性的 GenericBeanDefinition 实例，如下：\n\n```java\n    protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)\n            throws ClassNotFoundException {\n        return BeanDefinitionReaderUtils.createBeanDefinition(\n                parentName, className, this.readerContext.getBeanClassLoader());\n    }\n```\n\n委托 BeanDefinitionReaderUtils 创建，如下：\n\n```java\n    public static AbstractBeanDefinition createBeanDefinition(\n            @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {\n\n        GenericBeanDefinition bd = new GenericBeanDefinition();\n        bd.setParentName(parentName);\n        if (className != null) {\n            if (classLoader != null) {\n                bd.setBeanClass(ClassUtils.forName(className, classLoader));\n            }\n            else {\n                bd.setBeanClassName(className);\n            }\n        }\n        return bd;\n    }\n```\n\n该方法主要是设置 parentName 、className、classLoader。\n\n创建完 GenericBeanDefinition 实例后，再调用 `parseBeanDefinitionAttributes()` ，该方法将创建好的 GenericBeanDefinition 实例当做参数，对 Bean 标签的所有属性进行解析，如下：\n\n```java\npublic AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele,\n                      String beanName, @Nullable BeanDefinition containingBean, \n                                                            AbstractBeanDefinition bd) {\n        // 解析 scope 标签\n        if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n            error(\"Old 1.x 'singleton' attribute in use \n                  \t\t- upgrade to 'scope' declaration\", ele);\n        }\n        else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {\n            bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));\n        }\n        else if (containingBean != null) {\n            // Take default from containing bean in case of an inner bean definition.\n            bd.setScope(containingBean.getScope());\n        }\n\n        // 解析 abstract 标签\n        if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {\n            bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));\n        }\n\n        // 解析 lazy-init 标签\n        String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n        if (DEFAULT_VALUE.equals(lazyInit)) {\n            lazyInit = this.defaults.getLazyInit();\n        }\n        bd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n        // 解析 autowire 标签\n        String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n        bd.setAutowireMode(getAutowireMode(autowire));\n\n        // 解析 depends-on 标签\n        if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n            String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n            bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, \n                                MULTI_VALUE_ATTRIBUTE_DELIMITERS));\n        }\n\n        // 解析 autowire-candidate 标签\n        String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);\n        if (\"\".equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) {\n            String candidatePattern = this.defaults.getAutowireCandidates();\n            if (candidatePattern != null) {\n                String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);\n                bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));\n            }\n        }\n        else {\n            bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));\n        }\n\n        // 解析 primay 标签\n        if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {\n            bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));\n        }\n\n        // 解析 init-method 标签\n        if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {\n            String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n            bd.setInitMethodName(initMethodName);\n        }\n        else if (this.defaults.getInitMethod() != null) {\n            bd.setInitMethodName(this.defaults.getInitMethod());\n            bd.setEnforceInitMethod(false);\n        }\n\n        // 解析 destroy-mothod 标签\n        if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {\n            String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n            bd.setDestroyMethodName(destroyMethodName);\n        }\n        else if (this.defaults.getDestroyMethod() != null) {\n            bd.setDestroyMethodName(this.defaults.getDestroyMethod());\n            bd.setEnforceDestroyMethod(false);\n        }\n\n        // 解析 factory-method 标签\n        if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {\n            bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));\n        }\n        if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {\n            bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));\n        }\n\n        return bd;\n    }\n\n```\n\n从上面代码我们可以清晰地看到对 Bean 标签属性的解析，这些属性我们在工作中都或多或少用到过。\n\n完成 Bean 标签基本属性解析后，会依次调用 `parseMetaElements()`、`parseLookupOverrideSubElements()`、`parseReplacedMethodSubElements()` 对子元素 meta、lookup-method、replace-method 完成解析。下篇博文将会对这三个子元素进行详细说明。","source":"_posts/spring 源码分析/spring/Spring源码解析之  08bean标签：BeanDefinition .md","raw":"abbrlink: 27\ntitle: ' Spring源码解析之 08bean标签：BeanDefinition'\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-14 05:12:00\n---\n# Spring源码解析之 08bean标签：BeanDefinition\n\n### 概述\n\n1. BeanDefinition 简介\n2. 解析Bean标签\n\n### BeanDefinition简介\n\nBeanDefinition 是一个接口，它描述了一个 Bean 实例，包括属性值、构造方法值和继承自它的类的更多信息。Spring通过BeanDefinition将配置文件中的\\< bean >配置文件转换为容器的内部表示，并将这些BeanDefinition注册到BeanDefinitionRegistry中。Spring容器的BeanDefinitionRegistry就像是spring配置信息的内存数据库，主要以map的形式保存，后续操作直接从BeanDefinitionRegistry中直接获取配置信息。\n<!-- more-->\n\n它继承 AttributeAccessor 和 BeanMetadataElement 接口。两个接口定义如下：\n\nAttributeAccessor ：定义了与其它对象的（元数据）进行连接和访问的约定，即对属性的修改，包括获取、设置、删除。\nBeanMetadataElement：Bean 元对象持有的配置元素可以通过getSource() 方法来获取。\n\nBeanDefinition继承关系图\n\n![BeanDefinition继承关系图](/images/pasted-10.png)\n\n我们常用的三个实现类有：ChildBeanDefinition、GenericBeanDefinition、RootBeanDefinition，三者都继承 AbstractBeanDefinition。如果配置文件中定义了父 `<bean>` 和 子 `<bean>` ，则父 `<bean>` 用 RootBeanDefinition表示，子 `<bean>` 用 ChildBeanDefinition 表示，而没有父 `<bean>` 的就使用RootBeanDefinition 表示。GenericBeanDefinition 为一站式服务类,通常在解析xml配置文件时，先将BeanDefinition解析为此类型。AbstractBeanDefinition对三个子类共同的类信息进行抽象。\n\n### 解析Bean标签\n\n在 `BeanDefinitionParserDelegate.parseBeanDefinitionElement()` 中完成 Bean 的解析，返回的是一个已经完成对 `<bean>` 标签解析的 BeanDefinition 实例。在该方法内部，首先调用 `createBeanDefinition()` 方法创建一个用于承载属性的 GenericBeanDefinition 实例，如下：\n\n```java\n    protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)\n            throws ClassNotFoundException {\n        return BeanDefinitionReaderUtils.createBeanDefinition(\n                parentName, className, this.readerContext.getBeanClassLoader());\n    }\n```\n\n委托 BeanDefinitionReaderUtils 创建，如下：\n\n```java\n    public static AbstractBeanDefinition createBeanDefinition(\n            @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {\n\n        GenericBeanDefinition bd = new GenericBeanDefinition();\n        bd.setParentName(parentName);\n        if (className != null) {\n            if (classLoader != null) {\n                bd.setBeanClass(ClassUtils.forName(className, classLoader));\n            }\n            else {\n                bd.setBeanClassName(className);\n            }\n        }\n        return bd;\n    }\n```\n\n该方法主要是设置 parentName 、className、classLoader。\n\n创建完 GenericBeanDefinition 实例后，再调用 `parseBeanDefinitionAttributes()` ，该方法将创建好的 GenericBeanDefinition 实例当做参数，对 Bean 标签的所有属性进行解析，如下：\n\n```java\npublic AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele,\n                      String beanName, @Nullable BeanDefinition containingBean, \n                                                            AbstractBeanDefinition bd) {\n        // 解析 scope 标签\n        if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n            error(\"Old 1.x 'singleton' attribute in use \n                  \t\t- upgrade to 'scope' declaration\", ele);\n        }\n        else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {\n            bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));\n        }\n        else if (containingBean != null) {\n            // Take default from containing bean in case of an inner bean definition.\n            bd.setScope(containingBean.getScope());\n        }\n\n        // 解析 abstract 标签\n        if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {\n            bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));\n        }\n\n        // 解析 lazy-init 标签\n        String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n        if (DEFAULT_VALUE.equals(lazyInit)) {\n            lazyInit = this.defaults.getLazyInit();\n        }\n        bd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n        // 解析 autowire 标签\n        String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n        bd.setAutowireMode(getAutowireMode(autowire));\n\n        // 解析 depends-on 标签\n        if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n            String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n            bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, \n                                MULTI_VALUE_ATTRIBUTE_DELIMITERS));\n        }\n\n        // 解析 autowire-candidate 标签\n        String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);\n        if (\"\".equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) {\n            String candidatePattern = this.defaults.getAutowireCandidates();\n            if (candidatePattern != null) {\n                String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);\n                bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));\n            }\n        }\n        else {\n            bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));\n        }\n\n        // 解析 primay 标签\n        if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {\n            bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));\n        }\n\n        // 解析 init-method 标签\n        if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {\n            String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n            bd.setInitMethodName(initMethodName);\n        }\n        else if (this.defaults.getInitMethod() != null) {\n            bd.setInitMethodName(this.defaults.getInitMethod());\n            bd.setEnforceInitMethod(false);\n        }\n\n        // 解析 destroy-mothod 标签\n        if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {\n            String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n            bd.setDestroyMethodName(destroyMethodName);\n        }\n        else if (this.defaults.getDestroyMethod() != null) {\n            bd.setDestroyMethodName(this.defaults.getDestroyMethod());\n            bd.setEnforceDestroyMethod(false);\n        }\n\n        // 解析 factory-method 标签\n        if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {\n            bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));\n        }\n        if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {\n            bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));\n        }\n\n        return bd;\n    }\n\n```\n\n从上面代码我们可以清晰地看到对 Bean 标签属性的解析，这些属性我们在工作中都或多或少用到过。\n\n完成 Bean 标签基本属性解析后，会依次调用 `parseMetaElements()`、`parseLookupOverrideSubElements()`、`parseReplacedMethodSubElements()` 对子元素 meta、lookup-method、replace-method 完成解析。下篇博文将会对这三个子元素进行详细说明。","slug":"spring 源码分析/spring/Spring源码解析之  08bean标签：BeanDefinition ","published":1,"updated":"2019-01-15T03:37:49.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovtf00369q1ul5dxxcpn","content":"<h1 id=\"Spring源码解析之-08bean标签：BeanDefinition\"><a href=\"#Spring源码解析之-08bean标签：BeanDefinition\" class=\"headerlink\" title=\"Spring源码解析之 08bean标签：BeanDefinition\"></a>Spring源码解析之 08bean标签：BeanDefinition</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>BeanDefinition 简介</li>\n<li>解析Bean标签</li>\n</ol>\n<h3 id=\"BeanDefinition简介\"><a href=\"#BeanDefinition简介\" class=\"headerlink\" title=\"BeanDefinition简介\"></a>BeanDefinition简介</h3><p>BeanDefinition 是一个接口，它描述了一个 Bean 实例，包括属性值、构造方法值和继承自它的类的更多信息。Spring通过BeanDefinition将配置文件中的\\&lt; bean &gt;配置文件转换为容器的内部表示，并将这些BeanDefinition注册到BeanDefinitionRegistry中。Spring容器的BeanDefinitionRegistry就像是spring配置信息的内存数据库，主要以map的形式保存，后续操作直接从BeanDefinitionRegistry中直接获取配置信息。<br><a id=\"more\"></a></p>\n<p>它继承 AttributeAccessor 和 BeanMetadataElement 接口。两个接口定义如下：</p>\n<p>AttributeAccessor ：定义了与其它对象的（元数据）进行连接和访问的约定，即对属性的修改，包括获取、设置、删除。<br>BeanMetadataElement：Bean 元对象持有的配置元素可以通过getSource() 方法来获取。</p>\n<p>BeanDefinition继承关系图</p>\n<p><img src=\"/images/pasted-10.png\" alt=\"BeanDefinition继承关系图\"></p>\n<p>我们常用的三个实现类有：ChildBeanDefinition、GenericBeanDefinition、RootBeanDefinition，三者都继承 AbstractBeanDefinition。如果配置文件中定义了父 <code>&lt;bean&gt;</code> 和 子 <code>&lt;bean&gt;</code> ，则父 <code>&lt;bean&gt;</code> 用 RootBeanDefinition表示，子 <code>&lt;bean&gt;</code> 用 ChildBeanDefinition 表示，而没有父 <code>&lt;bean&gt;</code> 的就使用RootBeanDefinition 表示。GenericBeanDefinition 为一站式服务类,通常在解析xml配置文件时，先将BeanDefinition解析为此类型。AbstractBeanDefinition对三个子类共同的类信息进行抽象。</p>\n<h3 id=\"解析Bean标签\"><a href=\"#解析Bean标签\" class=\"headerlink\" title=\"解析Bean标签\"></a>解析Bean标签</h3><p>在 <code>BeanDefinitionParserDelegate.parseBeanDefinitionElement()</code> 中完成 Bean 的解析，返回的是一个已经完成对 <code>&lt;bean&gt;</code> 标签解析的 BeanDefinition 实例。在该方法内部，首先调用 <code>createBeanDefinition()</code> 方法创建一个用于承载属性的 GenericBeanDefinition 实例，如下：</p>\n<pre><code class=\"java\">    protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)\n            throws ClassNotFoundException {\n        return BeanDefinitionReaderUtils.createBeanDefinition(\n                parentName, className, this.readerContext.getBeanClassLoader());\n    }\n</code></pre>\n<p>委托 BeanDefinitionReaderUtils 创建，如下：</p>\n<pre><code class=\"java\">    public static AbstractBeanDefinition createBeanDefinition(\n            @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {\n\n        GenericBeanDefinition bd = new GenericBeanDefinition();\n        bd.setParentName(parentName);\n        if (className != null) {\n            if (classLoader != null) {\n                bd.setBeanClass(ClassUtils.forName(className, classLoader));\n            }\n            else {\n                bd.setBeanClassName(className);\n            }\n        }\n        return bd;\n    }\n</code></pre>\n<p>该方法主要是设置 parentName 、className、classLoader。</p>\n<p>创建完 GenericBeanDefinition 实例后，再调用 <code>parseBeanDefinitionAttributes()</code> ，该方法将创建好的 GenericBeanDefinition 实例当做参数，对 Bean 标签的所有属性进行解析，如下：</p>\n<pre><code class=\"java\">public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele,\n                      String beanName, @Nullable BeanDefinition containingBean, \n                                                            AbstractBeanDefinition bd) {\n        // 解析 scope 标签\n        if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n            error(&quot;Old 1.x &#39;singleton&#39; attribute in use \n                          - upgrade to &#39;scope&#39; declaration&quot;, ele);\n        }\n        else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {\n            bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));\n        }\n        else if (containingBean != null) {\n            // Take default from containing bean in case of an inner bean definition.\n            bd.setScope(containingBean.getScope());\n        }\n\n        // 解析 abstract 标签\n        if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {\n            bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));\n        }\n\n        // 解析 lazy-init 标签\n        String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n        if (DEFAULT_VALUE.equals(lazyInit)) {\n            lazyInit = this.defaults.getLazyInit();\n        }\n        bd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n        // 解析 autowire 标签\n        String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n        bd.setAutowireMode(getAutowireMode(autowire));\n\n        // 解析 depends-on 标签\n        if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n            String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n            bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, \n                                MULTI_VALUE_ATTRIBUTE_DELIMITERS));\n        }\n\n        // 解析 autowire-candidate 标签\n        String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);\n        if (&quot;&quot;.equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) {\n            String candidatePattern = this.defaults.getAutowireCandidates();\n            if (candidatePattern != null) {\n                String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);\n                bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));\n            }\n        }\n        else {\n            bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));\n        }\n\n        // 解析 primay 标签\n        if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {\n            bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));\n        }\n\n        // 解析 init-method 标签\n        if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {\n            String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n            bd.setInitMethodName(initMethodName);\n        }\n        else if (this.defaults.getInitMethod() != null) {\n            bd.setInitMethodName(this.defaults.getInitMethod());\n            bd.setEnforceInitMethod(false);\n        }\n\n        // 解析 destroy-mothod 标签\n        if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {\n            String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n            bd.setDestroyMethodName(destroyMethodName);\n        }\n        else if (this.defaults.getDestroyMethod() != null) {\n            bd.setDestroyMethodName(this.defaults.getDestroyMethod());\n            bd.setEnforceDestroyMethod(false);\n        }\n\n        // 解析 factory-method 标签\n        if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {\n            bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));\n        }\n        if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {\n            bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));\n        }\n\n        return bd;\n    }\n\n</code></pre>\n<p>从上面代码我们可以清晰地看到对 Bean 标签属性的解析，这些属性我们在工作中都或多或少用到过。</p>\n<p>完成 Bean 标签基本属性解析后，会依次调用 <code>parseMetaElements()</code>、<code>parseLookupOverrideSubElements()</code>、<code>parseReplacedMethodSubElements()</code> 对子元素 meta、lookup-method、replace-method 完成解析。下篇博文将会对这三个子元素进行详细说明。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Spring源码解析之-08bean标签：BeanDefinition\"><a href=\"#Spring源码解析之-08bean标签：BeanDefinition\" class=\"headerlink\" title=\"Spring源码解析之 08bean标签：BeanDefinition\"></a>Spring源码解析之 08bean标签：BeanDefinition</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>BeanDefinition 简介</li>\n<li>解析Bean标签</li>\n</ol>\n<h3 id=\"BeanDefinition简介\"><a href=\"#BeanDefinition简介\" class=\"headerlink\" title=\"BeanDefinition简介\"></a>BeanDefinition简介</h3><p>BeanDefinition 是一个接口，它描述了一个 Bean 实例，包括属性值、构造方法值和继承自它的类的更多信息。Spring通过BeanDefinition将配置文件中的\\&lt; bean &gt;配置文件转换为容器的内部表示，并将这些BeanDefinition注册到BeanDefinitionRegistry中。Spring容器的BeanDefinitionRegistry就像是spring配置信息的内存数据库，主要以map的形式保存，后续操作直接从BeanDefinitionRegistry中直接获取配置信息。<br>","more":"</p>\n<p>它继承 AttributeAccessor 和 BeanMetadataElement 接口。两个接口定义如下：</p>\n<p>AttributeAccessor ：定义了与其它对象的（元数据）进行连接和访问的约定，即对属性的修改，包括获取、设置、删除。<br>BeanMetadataElement：Bean 元对象持有的配置元素可以通过getSource() 方法来获取。</p>\n<p>BeanDefinition继承关系图</p>\n<p><img src=\"/images/pasted-10.png\" alt=\"BeanDefinition继承关系图\"></p>\n<p>我们常用的三个实现类有：ChildBeanDefinition、GenericBeanDefinition、RootBeanDefinition，三者都继承 AbstractBeanDefinition。如果配置文件中定义了父 <code>&lt;bean&gt;</code> 和 子 <code>&lt;bean&gt;</code> ，则父 <code>&lt;bean&gt;</code> 用 RootBeanDefinition表示，子 <code>&lt;bean&gt;</code> 用 ChildBeanDefinition 表示，而没有父 <code>&lt;bean&gt;</code> 的就使用RootBeanDefinition 表示。GenericBeanDefinition 为一站式服务类,通常在解析xml配置文件时，先将BeanDefinition解析为此类型。AbstractBeanDefinition对三个子类共同的类信息进行抽象。</p>\n<h3 id=\"解析Bean标签\"><a href=\"#解析Bean标签\" class=\"headerlink\" title=\"解析Bean标签\"></a>解析Bean标签</h3><p>在 <code>BeanDefinitionParserDelegate.parseBeanDefinitionElement()</code> 中完成 Bean 的解析，返回的是一个已经完成对 <code>&lt;bean&gt;</code> 标签解析的 BeanDefinition 实例。在该方法内部，首先调用 <code>createBeanDefinition()</code> 方法创建一个用于承载属性的 GenericBeanDefinition 实例，如下：</p>\n<pre><code class=\"java\">    protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)\n            throws ClassNotFoundException {\n        return BeanDefinitionReaderUtils.createBeanDefinition(\n                parentName, className, this.readerContext.getBeanClassLoader());\n    }\n</code></pre>\n<p>委托 BeanDefinitionReaderUtils 创建，如下：</p>\n<pre><code class=\"java\">    public static AbstractBeanDefinition createBeanDefinition(\n            @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {\n\n        GenericBeanDefinition bd = new GenericBeanDefinition();\n        bd.setParentName(parentName);\n        if (className != null) {\n            if (classLoader != null) {\n                bd.setBeanClass(ClassUtils.forName(className, classLoader));\n            }\n            else {\n                bd.setBeanClassName(className);\n            }\n        }\n        return bd;\n    }\n</code></pre>\n<p>该方法主要是设置 parentName 、className、classLoader。</p>\n<p>创建完 GenericBeanDefinition 实例后，再调用 <code>parseBeanDefinitionAttributes()</code> ，该方法将创建好的 GenericBeanDefinition 实例当做参数，对 Bean 标签的所有属性进行解析，如下：</p>\n<pre><code class=\"java\">public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele,\n                      String beanName, @Nullable BeanDefinition containingBean, \n                                                            AbstractBeanDefinition bd) {\n        // 解析 scope 标签\n        if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n            error(&quot;Old 1.x &#39;singleton&#39; attribute in use \n                          - upgrade to &#39;scope&#39; declaration&quot;, ele);\n        }\n        else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {\n            bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));\n        }\n        else if (containingBean != null) {\n            // Take default from containing bean in case of an inner bean definition.\n            bd.setScope(containingBean.getScope());\n        }\n\n        // 解析 abstract 标签\n        if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {\n            bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));\n        }\n\n        // 解析 lazy-init 标签\n        String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n        if (DEFAULT_VALUE.equals(lazyInit)) {\n            lazyInit = this.defaults.getLazyInit();\n        }\n        bd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n        // 解析 autowire 标签\n        String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n        bd.setAutowireMode(getAutowireMode(autowire));\n\n        // 解析 depends-on 标签\n        if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n            String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n            bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, \n                                MULTI_VALUE_ATTRIBUTE_DELIMITERS));\n        }\n\n        // 解析 autowire-candidate 标签\n        String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);\n        if (&quot;&quot;.equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) {\n            String candidatePattern = this.defaults.getAutowireCandidates();\n            if (candidatePattern != null) {\n                String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);\n                bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));\n            }\n        }\n        else {\n            bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));\n        }\n\n        // 解析 primay 标签\n        if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {\n            bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));\n        }\n\n        // 解析 init-method 标签\n        if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {\n            String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n            bd.setInitMethodName(initMethodName);\n        }\n        else if (this.defaults.getInitMethod() != null) {\n            bd.setInitMethodName(this.defaults.getInitMethod());\n            bd.setEnforceInitMethod(false);\n        }\n\n        // 解析 destroy-mothod 标签\n        if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {\n            String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n            bd.setDestroyMethodName(destroyMethodName);\n        }\n        else if (this.defaults.getDestroyMethod() != null) {\n            bd.setDestroyMethodName(this.defaults.getDestroyMethod());\n            bd.setEnforceDestroyMethod(false);\n        }\n\n        // 解析 factory-method 标签\n        if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {\n            bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));\n        }\n        if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {\n            bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));\n        }\n\n        return bd;\n    }\n\n</code></pre>\n<p>从上面代码我们可以清晰地看到对 Bean 标签属性的解析，这些属性我们在工作中都或多或少用到过。</p>\n<p>完成 Bean 标签基本属性解析后，会依次调用 <code>parseMetaElements()</code>、<code>parseLookupOverrideSubElements()</code>、<code>parseReplacedMethodSubElements()</code> 对子元素 meta、lookup-method、replace-method 完成解析。下篇博文将会对这三个子元素进行详细说明。</p>"},{"abbrlink":35,"title":"spring源码解析之 04（下）获取验证模型","author":"fengxiutianya","date":"2019-01-13T20:47:00.000Z","_content":"# spring源码解析之 04(下)获取验证模型\n\n### 概述\n\n1. DTD与XSD的区别\n2. getValidationModeForResource() 分析\n\n上一篇博客我们已经提到过，在核心逻辑方法 `doLoadBeanDefinitions()`中主要是做三件事情。\n\n1. 调用 `getValidationModeForResource()` 获取 xml 文件的验证模式\n2. 调用 `loadDocument()` 根据 xml 文件获取相应的 Document 实例。\n3. 调用 `registerBeanDefinitions()` 注册 Bean 实例。\n\n这篇博客主要来分析获取xml文件的验证模式\n\n<!-- more -->\n\n### DTD与XSD的区别\n\n了解XML文件的读者都应该知道XML文件的验证模式保证了XML文件的正确性，而比较常用的验证模式有俩种：DTD和XSD。\n\nDTD(Document Type Definition)，即文档类型定义，为 XML 文件的验证机制，属于 XML 文件中组成的一部分。DTD 是一种保证 XML 文档格式正确的有效验证方式，它定义了相关 XML 文档的元素、属性、排列方式、元素的内容类型以及元素的层次结构。其实 DTD 就相当于 XML 中的 “词汇”和“语法”，我们可以通过比较 XML 文件和 DTD 文件 来看文档是否符合规范，元素和标签使用是否正确。\n\n要在 Spring 中使用 DTD，需要在 Spring XML 文件头部声明：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE beans PUBLIC  \"-//SPRING//DTD BEAN//EN\"  \"http://www.springframework.org/dtd/spring-beans.dtd\">\n```\n\nDTD 在一定的阶段推动了 XML 的发展，但是它本身存在着一些缺陷：\n\n1. 它没有使用 XML 格式，而是自己定义了一套格式，相对解析器的重用性较差；而且 DTD 的构建和访问没有标准的编程接口，因而解析器很难简单的解析 DTD 文档。\n2. DTD 对元素的类型限制较少；同时其他的约束力也叫弱。\n3. DTD 扩展能力较差。\n4. 基于正则表达式的 DTD 文档的描述能力有限。\n\n针对 DTD 的缺陷，W3C 在 2001 年推出 XSD。XSD（XML Schemas Definition）即 XML Schema 语言。XML Schema描述了XML文档的结构。可以用一个指定的XML Schema来验证某个XML文档，以检查该XML文档是否符合其要求。文档设计者可以通过Xml Schema指定一个XML文档所允许的结构和内容，并可据此检查一个XML文档是否有效。XML Schema 本身就是一个 XML文档，使用的是 XML 语法，因此可以很方便的解析 XSD 文档。相对于 DTD，XSD 具有如下优势：\n\n- XML Schema基于XML,没有专门的语法\n- XML Schema可以象其他XML文件一样解析和处理\n- XML Schema比DTD提供了更丰富的数据类型.\n- XML Schema提供可扩充的数据模型。\n- XML Schema支持综合命名空间\n- XML Schema支持属性组。\n\n在使用XML Schema文档对XML示例文档进行校验，除了要声明名称空间外，还必须指定该名称空间所对应的XML Schema文档的存储位置。通过schmaLocation属性来制定名称空间所对应的XML Schema文档的存储位置，它包含俩个部分，一部分是名称空间URI，另一部分就是该名称空间所表示的XML Schema文件位置或URL地址。如果对这一块不是很懂，可以看下面这篇文章\n\n[关于XML文档的xmlns、xmlns:xsi和xsi:schemaLocation](https://my.oschina.net/itblog/blog/390001)\n\nspring配置文件中经常使用的例子\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n\n</beans>\n```\n\n###  getValidationModeForResource() 分析\n\n```java\nprotected int getValidationModeForResource(Resource resource) {\n\t\tint validationModeToUse = getValidationMode();\n\t\t// 如果用户已经设置，则使用用户设置的验证模式\n\t\tif (validationModeToUse != VALIDATION_AUTO) {\n\t\t\treturn validationModeToUse;\n\t\t}\n\t\t// 根据资源查找验证模式\n\t\tint detectedMode = detectValidationMode(resource);\n\t\tif (detectedMode != VALIDATION_AUTO) {\n\t\t\treturn detectedMode;\n\t\t}\n\t\t// 如果没有查找到具体的验证模式，也就是代表在查找到跟标记之前没有出现DTD，\n        // 就默认设置成XSD验证模式\n\t\treturn VALIDATION_XSD;\n\t}\n```\n\n如果指定了 XML 文件的的验证模式（调用`XmlBeanDefinitionReader.setValidating(boolean validating)`）则直接返回指定的验证模式，否则调用 `detectValidationMode()` 获取相应的验证模式，如下：\n\n```java\n    protected int detectValidationMode(Resource resource) {\n        if (resource.isOpen()) {\n            throw new BeanDefinitionStoreException(\n                    \"Passed-in Resource [\" + resource + \"] contains an open stream: \" +\n         \"cannot determine validation mode automatically. Either pass in a Resource \" +\n     \"that is able to create fresh streams, or explicitly specify the validationMode \"+\n                    \"on your XmlBeanDefinitionReader instance.\");\n        }\n\n        InputStream inputStream;\n        try {\n            inputStream = resource.getInputStream();\n        }\n        catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\n   \"Unable to determine validation mode for [\" + resource + \"]: cannot open InputStream. \" +\"Did you attempt to load directly from a SAX InputSource without specifying the \" + \"validationMode on your XmlBeanDefinitionReader instance?\", ex);\n        }\n\n        try {\n          // 核心方法\n            return this.validationModeDetector.detectValidationMode(inputStream);\n        }\n        catch (IOException ex) {\n   throw new BeanDefinitionStoreException(\"Unable to determine validation mode for [\" + resource + \"]: an error occurred whilst reading from the InputStream.\", ex);\n        }\n    }\n```\n\n前面一大堆的代码，核心在于 `this.validationModeDetector.detectValidationMode(inputStream)`，validationModeDetector 定义为 `XmlValidationModeDetector`,所以验证模式的获取委托给 `XmlValidationModeDetector` 的 `detectValidationMode()` 方法。\n\n```java\n    public int detectValidationMode(InputStream inputStream) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        try {\n            boolean isDtdValidated = false;\n            String content;\n            // 一行一行读取 xml 文件的内容\n            while ((content = reader.readLine()) != null) {\n                content = consumeCommentTokens(content);\n                // 如果为注释，则跳过\n                if (this.inComment || !StringUtils.hasText(content)) {\n                    continue;\n                }\n                // 包含 DOCTYPE 为 DTD 模式\n                if (hasDoctype(content)) {\n                    isDtdValidated = true;\n                    break;\n                }\n                // 读取 < 开始符号，验证模式一定会在 < 符号之前\n                if (hasOpeningTag(content)) {\n                    // End of meaningful data...\n                    break;\n                }\n            }\n        // 为 true 返回 DTD，否则返回 XSD\n            return (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);\n        }\n        catch (CharConversionException ex) {\n            // 出现异常，为 XSD\n            return VALIDATION_AUTO;\n        }\n        finally {\n            reader.close();\n        }\n    }\n```\n\n从代码中看，主要是通过读取 XML 文件的内容，判断内容中是否包含有 DOCTYPE ，如果是 则为 DTD，否则为 XSD，当然只会读取到 第一个 “<” 处，因为 验证模式一定会在第一个 “<” 之前。如果当中出现了 CharConversionException 异常，则为 XSD模式。\n\n好了，XML 文件的验证模式分析完毕，下篇分析 `doLoadBeanDefinitions()` 的第二个步骤：获取 Document 实例。","source":"_posts/spring 源码分析/spring/spring源码解析之  04（下）获取验证模型.md","raw":"abbrlink: 35\ntitle: spring源码解析之 04（下）获取验证模型\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-14 04:47:00\n---\n# spring源码解析之 04(下)获取验证模型\n\n### 概述\n\n1. DTD与XSD的区别\n2. getValidationModeForResource() 分析\n\n上一篇博客我们已经提到过，在核心逻辑方法 `doLoadBeanDefinitions()`中主要是做三件事情。\n\n1. 调用 `getValidationModeForResource()` 获取 xml 文件的验证模式\n2. 调用 `loadDocument()` 根据 xml 文件获取相应的 Document 实例。\n3. 调用 `registerBeanDefinitions()` 注册 Bean 实例。\n\n这篇博客主要来分析获取xml文件的验证模式\n\n<!-- more -->\n\n### DTD与XSD的区别\n\n了解XML文件的读者都应该知道XML文件的验证模式保证了XML文件的正确性，而比较常用的验证模式有俩种：DTD和XSD。\n\nDTD(Document Type Definition)，即文档类型定义，为 XML 文件的验证机制，属于 XML 文件中组成的一部分。DTD 是一种保证 XML 文档格式正确的有效验证方式，它定义了相关 XML 文档的元素、属性、排列方式、元素的内容类型以及元素的层次结构。其实 DTD 就相当于 XML 中的 “词汇”和“语法”，我们可以通过比较 XML 文件和 DTD 文件 来看文档是否符合规范，元素和标签使用是否正确。\n\n要在 Spring 中使用 DTD，需要在 Spring XML 文件头部声明：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE beans PUBLIC  \"-//SPRING//DTD BEAN//EN\"  \"http://www.springframework.org/dtd/spring-beans.dtd\">\n```\n\nDTD 在一定的阶段推动了 XML 的发展，但是它本身存在着一些缺陷：\n\n1. 它没有使用 XML 格式，而是自己定义了一套格式，相对解析器的重用性较差；而且 DTD 的构建和访问没有标准的编程接口，因而解析器很难简单的解析 DTD 文档。\n2. DTD 对元素的类型限制较少；同时其他的约束力也叫弱。\n3. DTD 扩展能力较差。\n4. 基于正则表达式的 DTD 文档的描述能力有限。\n\n针对 DTD 的缺陷，W3C 在 2001 年推出 XSD。XSD（XML Schemas Definition）即 XML Schema 语言。XML Schema描述了XML文档的结构。可以用一个指定的XML Schema来验证某个XML文档，以检查该XML文档是否符合其要求。文档设计者可以通过Xml Schema指定一个XML文档所允许的结构和内容，并可据此检查一个XML文档是否有效。XML Schema 本身就是一个 XML文档，使用的是 XML 语法，因此可以很方便的解析 XSD 文档。相对于 DTD，XSD 具有如下优势：\n\n- XML Schema基于XML,没有专门的语法\n- XML Schema可以象其他XML文件一样解析和处理\n- XML Schema比DTD提供了更丰富的数据类型.\n- XML Schema提供可扩充的数据模型。\n- XML Schema支持综合命名空间\n- XML Schema支持属性组。\n\n在使用XML Schema文档对XML示例文档进行校验，除了要声明名称空间外，还必须指定该名称空间所对应的XML Schema文档的存储位置。通过schmaLocation属性来制定名称空间所对应的XML Schema文档的存储位置，它包含俩个部分，一部分是名称空间URI，另一部分就是该名称空间所表示的XML Schema文件位置或URL地址。如果对这一块不是很懂，可以看下面这篇文章\n\n[关于XML文档的xmlns、xmlns:xsi和xsi:schemaLocation](https://my.oschina.net/itblog/blog/390001)\n\nspring配置文件中经常使用的例子\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n\n</beans>\n```\n\n###  getValidationModeForResource() 分析\n\n```java\nprotected int getValidationModeForResource(Resource resource) {\n\t\tint validationModeToUse = getValidationMode();\n\t\t// 如果用户已经设置，则使用用户设置的验证模式\n\t\tif (validationModeToUse != VALIDATION_AUTO) {\n\t\t\treturn validationModeToUse;\n\t\t}\n\t\t// 根据资源查找验证模式\n\t\tint detectedMode = detectValidationMode(resource);\n\t\tif (detectedMode != VALIDATION_AUTO) {\n\t\t\treturn detectedMode;\n\t\t}\n\t\t// 如果没有查找到具体的验证模式，也就是代表在查找到跟标记之前没有出现DTD，\n        // 就默认设置成XSD验证模式\n\t\treturn VALIDATION_XSD;\n\t}\n```\n\n如果指定了 XML 文件的的验证模式（调用`XmlBeanDefinitionReader.setValidating(boolean validating)`）则直接返回指定的验证模式，否则调用 `detectValidationMode()` 获取相应的验证模式，如下：\n\n```java\n    protected int detectValidationMode(Resource resource) {\n        if (resource.isOpen()) {\n            throw new BeanDefinitionStoreException(\n                    \"Passed-in Resource [\" + resource + \"] contains an open stream: \" +\n         \"cannot determine validation mode automatically. Either pass in a Resource \" +\n     \"that is able to create fresh streams, or explicitly specify the validationMode \"+\n                    \"on your XmlBeanDefinitionReader instance.\");\n        }\n\n        InputStream inputStream;\n        try {\n            inputStream = resource.getInputStream();\n        }\n        catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\n   \"Unable to determine validation mode for [\" + resource + \"]: cannot open InputStream. \" +\"Did you attempt to load directly from a SAX InputSource without specifying the \" + \"validationMode on your XmlBeanDefinitionReader instance?\", ex);\n        }\n\n        try {\n          // 核心方法\n            return this.validationModeDetector.detectValidationMode(inputStream);\n        }\n        catch (IOException ex) {\n   throw new BeanDefinitionStoreException(\"Unable to determine validation mode for [\" + resource + \"]: an error occurred whilst reading from the InputStream.\", ex);\n        }\n    }\n```\n\n前面一大堆的代码，核心在于 `this.validationModeDetector.detectValidationMode(inputStream)`，validationModeDetector 定义为 `XmlValidationModeDetector`,所以验证模式的获取委托给 `XmlValidationModeDetector` 的 `detectValidationMode()` 方法。\n\n```java\n    public int detectValidationMode(InputStream inputStream) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        try {\n            boolean isDtdValidated = false;\n            String content;\n            // 一行一行读取 xml 文件的内容\n            while ((content = reader.readLine()) != null) {\n                content = consumeCommentTokens(content);\n                // 如果为注释，则跳过\n                if (this.inComment || !StringUtils.hasText(content)) {\n                    continue;\n                }\n                // 包含 DOCTYPE 为 DTD 模式\n                if (hasDoctype(content)) {\n                    isDtdValidated = true;\n                    break;\n                }\n                // 读取 < 开始符号，验证模式一定会在 < 符号之前\n                if (hasOpeningTag(content)) {\n                    // End of meaningful data...\n                    break;\n                }\n            }\n        // 为 true 返回 DTD，否则返回 XSD\n            return (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);\n        }\n        catch (CharConversionException ex) {\n            // 出现异常，为 XSD\n            return VALIDATION_AUTO;\n        }\n        finally {\n            reader.close();\n        }\n    }\n```\n\n从代码中看，主要是通过读取 XML 文件的内容，判断内容中是否包含有 DOCTYPE ，如果是 则为 DTD，否则为 XSD，当然只会读取到 第一个 “<” 处，因为 验证模式一定会在第一个 “<” 之前。如果当中出现了 CharConversionException 异常，则为 XSD模式。\n\n好了，XML 文件的验证模式分析完毕，下篇分析 `doLoadBeanDefinitions()` 的第二个步骤：获取 Document 实例。","slug":"spring 源码分析/spring/spring源码解析之  04（下）获取验证模型","published":1,"updated":"2019-01-14T06:13:32.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovtg00399q1u2p1kncf8","content":"<h1 id=\"spring源码解析之-04-下-获取验证模型\"><a href=\"#spring源码解析之-04-下-获取验证模型\" class=\"headerlink\" title=\"spring源码解析之 04(下)获取验证模型\"></a>spring源码解析之 04(下)获取验证模型</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>DTD与XSD的区别</li>\n<li>getValidationModeForResource() 分析</li>\n</ol>\n<p>上一篇博客我们已经提到过，在核心逻辑方法 <code>doLoadBeanDefinitions()</code>中主要是做三件事情。</p>\n<ol>\n<li>调用 <code>getValidationModeForResource()</code> 获取 xml 文件的验证模式</li>\n<li>调用 <code>loadDocument()</code> 根据 xml 文件获取相应的 Document 实例。</li>\n<li>调用 <code>registerBeanDefinitions()</code> 注册 Bean 实例。</li>\n</ol>\n<p>这篇博客主要来分析获取xml文件的验证模式</p>\n<a id=\"more\"></a>\n<h3 id=\"DTD与XSD的区别\"><a href=\"#DTD与XSD的区别\" class=\"headerlink\" title=\"DTD与XSD的区别\"></a>DTD与XSD的区别</h3><p>了解XML文件的读者都应该知道XML文件的验证模式保证了XML文件的正确性，而比较常用的验证模式有俩种：DTD和XSD。</p>\n<p>DTD(Document Type Definition)，即文档类型定义，为 XML 文件的验证机制，属于 XML 文件中组成的一部分。DTD 是一种保证 XML 文档格式正确的有效验证方式，它定义了相关 XML 文档的元素、属性、排列方式、元素的内容类型以及元素的层次结构。其实 DTD 就相当于 XML 中的 “词汇”和“语法”，我们可以通过比较 XML 文件和 DTD 文件 来看文档是否符合规范，元素和标签使用是否正确。</p>\n<p>要在 Spring 中使用 DTD，需要在 Spring XML 文件头部声明：</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE beans PUBLIC  &quot;-//SPRING//DTD BEAN//EN&quot;  &quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;&gt;\n</code></pre>\n<p>DTD 在一定的阶段推动了 XML 的发展，但是它本身存在着一些缺陷：</p>\n<ol>\n<li>它没有使用 XML 格式，而是自己定义了一套格式，相对解析器的重用性较差；而且 DTD 的构建和访问没有标准的编程接口，因而解析器很难简单的解析 DTD 文档。</li>\n<li>DTD 对元素的类型限制较少；同时其他的约束力也叫弱。</li>\n<li>DTD 扩展能力较差。</li>\n<li>基于正则表达式的 DTD 文档的描述能力有限。</li>\n</ol>\n<p>针对 DTD 的缺陷，W3C 在 2001 年推出 XSD。XSD（XML Schemas Definition）即 XML Schema 语言。XML Schema描述了XML文档的结构。可以用一个指定的XML Schema来验证某个XML文档，以检查该XML文档是否符合其要求。文档设计者可以通过Xml Schema指定一个XML文档所允许的结构和内容，并可据此检查一个XML文档是否有效。XML Schema 本身就是一个 XML文档，使用的是 XML 语法，因此可以很方便的解析 XSD 文档。相对于 DTD，XSD 具有如下优势：</p>\n<ul>\n<li>XML Schema基于XML,没有专门的语法</li>\n<li>XML Schema可以象其他XML文件一样解析和处理</li>\n<li>XML Schema比DTD提供了更丰富的数据类型.</li>\n<li>XML Schema提供可扩充的数据模型。</li>\n<li>XML Schema支持综合命名空间</li>\n<li>XML Schema支持属性组。</li>\n</ul>\n<p>在使用XML Schema文档对XML示例文档进行校验，除了要声明名称空间外，还必须指定该名称空间所对应的XML Schema文档的存储位置。通过schmaLocation属性来制定名称空间所对应的XML Schema文档的存储位置，它包含俩个部分，一部分是名称空间URI，另一部分就是该名称空间所表示的XML Schema文件位置或URL地址。如果对这一块不是很懂，可以看下面这篇文章</p>\n<p><a href=\"https://my.oschina.net/itblog/blog/390001\" target=\"_blank\" rel=\"noopener\">关于XML文档的xmlns、xmlns:xsi和xsi:schemaLocation</a></p>\n<p>spring配置文件中经常使用的例子</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n\n&lt;/beans&gt;\n</code></pre>\n<h3 id=\"getValidationModeForResource-分析\"><a href=\"#getValidationModeForResource-分析\" class=\"headerlink\" title=\"getValidationModeForResource() 分析\"></a>getValidationModeForResource() 分析</h3><pre><code class=\"java\">protected int getValidationModeForResource(Resource resource) {\n        int validationModeToUse = getValidationMode();\n        // 如果用户已经设置，则使用用户设置的验证模式\n        if (validationModeToUse != VALIDATION_AUTO) {\n            return validationModeToUse;\n        }\n        // 根据资源查找验证模式\n        int detectedMode = detectValidationMode(resource);\n        if (detectedMode != VALIDATION_AUTO) {\n            return detectedMode;\n        }\n        // 如果没有查找到具体的验证模式，也就是代表在查找到跟标记之前没有出现DTD，\n        // 就默认设置成XSD验证模式\n        return VALIDATION_XSD;\n    }\n</code></pre>\n<p>如果指定了 XML 文件的的验证模式（调用<code>XmlBeanDefinitionReader.setValidating(boolean validating)</code>）则直接返回指定的验证模式，否则调用 <code>detectValidationMode()</code> 获取相应的验证模式，如下：</p>\n<pre><code class=\"java\">    protected int detectValidationMode(Resource resource) {\n        if (resource.isOpen()) {\n            throw new BeanDefinitionStoreException(\n                    &quot;Passed-in Resource [&quot; + resource + &quot;] contains an open stream: &quot; +\n         &quot;cannot determine validation mode automatically. Either pass in a Resource &quot; +\n     &quot;that is able to create fresh streams, or explicitly specify the validationMode &quot;+\n                    &quot;on your XmlBeanDefinitionReader instance.&quot;);\n        }\n\n        InputStream inputStream;\n        try {\n            inputStream = resource.getInputStream();\n        }\n        catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\n   &quot;Unable to determine validation mode for [&quot; + resource + &quot;]: cannot open InputStream. &quot; +&quot;Did you attempt to load directly from a SAX InputSource without specifying the &quot; + &quot;validationMode on your XmlBeanDefinitionReader instance?&quot;, ex);\n        }\n\n        try {\n          // 核心方法\n            return this.validationModeDetector.detectValidationMode(inputStream);\n        }\n        catch (IOException ex) {\n   throw new BeanDefinitionStoreException(&quot;Unable to determine validation mode for [&quot; + resource + &quot;]: an error occurred whilst reading from the InputStream.&quot;, ex);\n        }\n    }\n</code></pre>\n<p>前面一大堆的代码，核心在于 <code>this.validationModeDetector.detectValidationMode(inputStream)</code>，validationModeDetector 定义为 <code>XmlValidationModeDetector</code>,所以验证模式的获取委托给 <code>XmlValidationModeDetector</code> 的 <code>detectValidationMode()</code> 方法。</p>\n<pre><code class=\"java\">    public int detectValidationMode(InputStream inputStream) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        try {\n            boolean isDtdValidated = false;\n            String content;\n            // 一行一行读取 xml 文件的内容\n            while ((content = reader.readLine()) != null) {\n                content = consumeCommentTokens(content);\n                // 如果为注释，则跳过\n                if (this.inComment || !StringUtils.hasText(content)) {\n                    continue;\n                }\n                // 包含 DOCTYPE 为 DTD 模式\n                if (hasDoctype(content)) {\n                    isDtdValidated = true;\n                    break;\n                }\n                // 读取 &lt; 开始符号，验证模式一定会在 &lt; 符号之前\n                if (hasOpeningTag(content)) {\n                    // End of meaningful data...\n                    break;\n                }\n            }\n        // 为 true 返回 DTD，否则返回 XSD\n            return (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);\n        }\n        catch (CharConversionException ex) {\n            // 出现异常，为 XSD\n            return VALIDATION_AUTO;\n        }\n        finally {\n            reader.close();\n        }\n    }\n</code></pre>\n<p>从代码中看，主要是通过读取 XML 文件的内容，判断内容中是否包含有 DOCTYPE ，如果是 则为 DTD，否则为 XSD，当然只会读取到 第一个 “&lt;” 处，因为 验证模式一定会在第一个 “&lt;” 之前。如果当中出现了 CharConversionException 异常，则为 XSD模式。</p>\n<p>好了，XML 文件的验证模式分析完毕，下篇分析 <code>doLoadBeanDefinitions()</code> 的第二个步骤：获取 Document 实例。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-04-下-获取验证模型\"><a href=\"#spring源码解析之-04-下-获取验证模型\" class=\"headerlink\" title=\"spring源码解析之 04(下)获取验证模型\"></a>spring源码解析之 04(下)获取验证模型</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>DTD与XSD的区别</li>\n<li>getValidationModeForResource() 分析</li>\n</ol>\n<p>上一篇博客我们已经提到过，在核心逻辑方法 <code>doLoadBeanDefinitions()</code>中主要是做三件事情。</p>\n<ol>\n<li>调用 <code>getValidationModeForResource()</code> 获取 xml 文件的验证模式</li>\n<li>调用 <code>loadDocument()</code> 根据 xml 文件获取相应的 Document 实例。</li>\n<li>调用 <code>registerBeanDefinitions()</code> 注册 Bean 实例。</li>\n</ol>\n<p>这篇博客主要来分析获取xml文件的验证模式</p>","more":"<h3 id=\"DTD与XSD的区别\"><a href=\"#DTD与XSD的区别\" class=\"headerlink\" title=\"DTD与XSD的区别\"></a>DTD与XSD的区别</h3><p>了解XML文件的读者都应该知道XML文件的验证模式保证了XML文件的正确性，而比较常用的验证模式有俩种：DTD和XSD。</p>\n<p>DTD(Document Type Definition)，即文档类型定义，为 XML 文件的验证机制，属于 XML 文件中组成的一部分。DTD 是一种保证 XML 文档格式正确的有效验证方式，它定义了相关 XML 文档的元素、属性、排列方式、元素的内容类型以及元素的层次结构。其实 DTD 就相当于 XML 中的 “词汇”和“语法”，我们可以通过比较 XML 文件和 DTD 文件 来看文档是否符合规范，元素和标签使用是否正确。</p>\n<p>要在 Spring 中使用 DTD，需要在 Spring XML 文件头部声明：</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE beans PUBLIC  &quot;-//SPRING//DTD BEAN//EN&quot;  &quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;&gt;\n</code></pre>\n<p>DTD 在一定的阶段推动了 XML 的发展，但是它本身存在着一些缺陷：</p>\n<ol>\n<li>它没有使用 XML 格式，而是自己定义了一套格式，相对解析器的重用性较差；而且 DTD 的构建和访问没有标准的编程接口，因而解析器很难简单的解析 DTD 文档。</li>\n<li>DTD 对元素的类型限制较少；同时其他的约束力也叫弱。</li>\n<li>DTD 扩展能力较差。</li>\n<li>基于正则表达式的 DTD 文档的描述能力有限。</li>\n</ol>\n<p>针对 DTD 的缺陷，W3C 在 2001 年推出 XSD。XSD（XML Schemas Definition）即 XML Schema 语言。XML Schema描述了XML文档的结构。可以用一个指定的XML Schema来验证某个XML文档，以检查该XML文档是否符合其要求。文档设计者可以通过Xml Schema指定一个XML文档所允许的结构和内容，并可据此检查一个XML文档是否有效。XML Schema 本身就是一个 XML文档，使用的是 XML 语法，因此可以很方便的解析 XSD 文档。相对于 DTD，XSD 具有如下优势：</p>\n<ul>\n<li>XML Schema基于XML,没有专门的语法</li>\n<li>XML Schema可以象其他XML文件一样解析和处理</li>\n<li>XML Schema比DTD提供了更丰富的数据类型.</li>\n<li>XML Schema提供可扩充的数据模型。</li>\n<li>XML Schema支持综合命名空间</li>\n<li>XML Schema支持属性组。</li>\n</ul>\n<p>在使用XML Schema文档对XML示例文档进行校验，除了要声明名称空间外，还必须指定该名称空间所对应的XML Schema文档的存储位置。通过schmaLocation属性来制定名称空间所对应的XML Schema文档的存储位置，它包含俩个部分，一部分是名称空间URI，另一部分就是该名称空间所表示的XML Schema文件位置或URL地址。如果对这一块不是很懂，可以看下面这篇文章</p>\n<p><a href=\"https://my.oschina.net/itblog/blog/390001\" target=\"_blank\" rel=\"noopener\">关于XML文档的xmlns、xmlns:xsi和xsi:schemaLocation</a></p>\n<p>spring配置文件中经常使用的例子</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n\n&lt;/beans&gt;\n</code></pre>\n<h3 id=\"getValidationModeForResource-分析\"><a href=\"#getValidationModeForResource-分析\" class=\"headerlink\" title=\"getValidationModeForResource() 分析\"></a>getValidationModeForResource() 分析</h3><pre><code class=\"java\">protected int getValidationModeForResource(Resource resource) {\n        int validationModeToUse = getValidationMode();\n        // 如果用户已经设置，则使用用户设置的验证模式\n        if (validationModeToUse != VALIDATION_AUTO) {\n            return validationModeToUse;\n        }\n        // 根据资源查找验证模式\n        int detectedMode = detectValidationMode(resource);\n        if (detectedMode != VALIDATION_AUTO) {\n            return detectedMode;\n        }\n        // 如果没有查找到具体的验证模式，也就是代表在查找到跟标记之前没有出现DTD，\n        // 就默认设置成XSD验证模式\n        return VALIDATION_XSD;\n    }\n</code></pre>\n<p>如果指定了 XML 文件的的验证模式（调用<code>XmlBeanDefinitionReader.setValidating(boolean validating)</code>）则直接返回指定的验证模式，否则调用 <code>detectValidationMode()</code> 获取相应的验证模式，如下：</p>\n<pre><code class=\"java\">    protected int detectValidationMode(Resource resource) {\n        if (resource.isOpen()) {\n            throw new BeanDefinitionStoreException(\n                    &quot;Passed-in Resource [&quot; + resource + &quot;] contains an open stream: &quot; +\n         &quot;cannot determine validation mode automatically. Either pass in a Resource &quot; +\n     &quot;that is able to create fresh streams, or explicitly specify the validationMode &quot;+\n                    &quot;on your XmlBeanDefinitionReader instance.&quot;);\n        }\n\n        InputStream inputStream;\n        try {\n            inputStream = resource.getInputStream();\n        }\n        catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\n   &quot;Unable to determine validation mode for [&quot; + resource + &quot;]: cannot open InputStream. &quot; +&quot;Did you attempt to load directly from a SAX InputSource without specifying the &quot; + &quot;validationMode on your XmlBeanDefinitionReader instance?&quot;, ex);\n        }\n\n        try {\n          // 核心方法\n            return this.validationModeDetector.detectValidationMode(inputStream);\n        }\n        catch (IOException ex) {\n   throw new BeanDefinitionStoreException(&quot;Unable to determine validation mode for [&quot; + resource + &quot;]: an error occurred whilst reading from the InputStream.&quot;, ex);\n        }\n    }\n</code></pre>\n<p>前面一大堆的代码，核心在于 <code>this.validationModeDetector.detectValidationMode(inputStream)</code>，validationModeDetector 定义为 <code>XmlValidationModeDetector</code>,所以验证模式的获取委托给 <code>XmlValidationModeDetector</code> 的 <code>detectValidationMode()</code> 方法。</p>\n<pre><code class=\"java\">    public int detectValidationMode(InputStream inputStream) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        try {\n            boolean isDtdValidated = false;\n            String content;\n            // 一行一行读取 xml 文件的内容\n            while ((content = reader.readLine()) != null) {\n                content = consumeCommentTokens(content);\n                // 如果为注释，则跳过\n                if (this.inComment || !StringUtils.hasText(content)) {\n                    continue;\n                }\n                // 包含 DOCTYPE 为 DTD 模式\n                if (hasDoctype(content)) {\n                    isDtdValidated = true;\n                    break;\n                }\n                // 读取 &lt; 开始符号，验证模式一定会在 &lt; 符号之前\n                if (hasOpeningTag(content)) {\n                    // End of meaningful data...\n                    break;\n                }\n            }\n        // 为 true 返回 DTD，否则返回 XSD\n            return (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);\n        }\n        catch (CharConversionException ex) {\n            // 出现异常，为 XSD\n            return VALIDATION_AUTO;\n        }\n        finally {\n            reader.close();\n        }\n    }\n</code></pre>\n<p>从代码中看，主要是通过读取 XML 文件的内容，判断内容中是否包含有 DOCTYPE ，如果是 则为 DTD，否则为 XSD，当然只会读取到 第一个 “&lt;” 处，因为 验证模式一定会在第一个 “&lt;” 之前。如果当中出现了 CharConversionException 异常，则为 XSD模式。</p>\n<p>好了，XML 文件的验证模式分析完毕，下篇分析 <code>doLoadBeanDefinitions()</code> 的第二个步骤：获取 Document 实例。</p>"},{"abbrlink":30,"title":"spring源码解析之 11bean标签：解析自定义标签","author":"fengxiutianya","date":"2019-01-13T21:25:00.000Z","_content":"# spring源码解析之 11bean标签：解析自定义标签\n\nbean标签解析设计太多的知识点，这里我们先看看最开始解析bean的那段代码，回顾一下\n<!-- more-->\n\n```java\n    protected void processBeanDefinition(Element ele,\n                                         BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,                 \n      \t\t\t\t\t\t\t\t getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\n                    \"Failed to register bean definition with name '\" +\n                        bdHolder.getBeanName() + \"'\", ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(\n                new BeanComponentDefinition(bdHolder));                                \n        }\n    }\n```\n\n`processBeanDefinition()` 负责 Bean 标签的解析，在解析过程中首先调用`BeanDefinitionParserDelegate.parseBeanDefinitionElement()` 完成默认标签的解析，如果解析成功（返回的 bdHolder != null ），则首先调用 `BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired()` 完成自定义标签元素解析，前面文章已经分析了默认标签的解析，所以这篇文章分析自定义标签的解析。首先大致了解下这句话的作用，其实我们可以从语义上分析：如果需要的话就对beanDefinition进行装饰，那这句话代码到底是什么功能呢？在bean属性解析过程中，有俩种类型：一种是默认类型的解析，另一种是自定义类型的解析，这里就是自定义类型的解析。前面我们也说过自定义标签的解析，为什么会在默认类型解析中单独添加一个方法处理呢？这个是因为，我们之前见过的那种类型是bean标签一级的自定义标签解析，这里我们看到的自定义类型其实是属性。就像下面这样：\n\n```xml\n<bean id=\"\" name=\"\">\n\t<myBean:user username=\"aaa\"/>\n</bean>\n```\n\n当spring中的bean使用的是默认的标签配置，但是其中的子元素却是用了自定义的配置，这句代码便会起作用。\n\n```java\n    public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, \n                                        BeanDefinitionHolder definitionHolder) {\n        return decorateBeanDefinitionIfRequired(ele, definitionHolder, null);\n    }\n```\n\n调用 `decorateBeanDefinitionIfRequired()` ：\n\n```java\n    public BeanDefinitionHolder decorateBeanDefinitionIfRequired(\n            Element ele, BeanDefinitionHolder definitionHolder, \n        \t@Nullable BeanDefinition containingBd) {\n\n        BeanDefinitionHolder finalDefinition = definitionHolder;\n\n        // 遍历所有的属性，查看是否有适用于装饰的属性\n        NamedNodeMap attributes = ele.getAttributes();\n        for (int i = 0; i < attributes.getLength(); i++) {\n            Node node = attributes.item(i);\n            finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);\n        }\n\n        // 遍历子节点，查看是否有适用于修饰的子元素\n        NodeList children = ele.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            Node node = children.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                finalDefinition = \n                    decorateIfRequired(node, finalDefinition, containingBd);\n            }\n        }\n        return finalDefinition;\n    }\n```\n\n上面代码，看到函数分别对元素和所有属性以及子节点进行了decorateIfRequired函数的调用，\n\n遍历节点（子节点），调用 `decorateIfRequired()` 装饰节点（子节点）。\n\n```java\n    public BeanDefinitionHolder decorateIfRequired(\n            Node node, BeanDefinitionHolder originalDef,\n        \t@Nullable BeanDefinition containingBd) {\n        // 获取自定义标签的命名空间\n        String namespaceUri = getNamespaceURI(node);\n        // 过滤掉默认命名标签\n        if (namespaceUri != null && !isDefaultNamespace(namespaceUri)) {\n            // 获取相应的处理器\n            NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n            if (handler != null) {\n                // 进行装饰处理\n                BeanDefinitionHolder decorated =\n                        handler.decorate(node, originalDef,\n                          new ParserContext(this.readerContext, this, containingBd));\n                if (decorated != null) {\n                    return decorated;\n                }\n            }\n            else if (namespaceUri.startsWith(\"http://www.springframework.org/\")) {\n                error(\"Unable to locate Spring NamespaceHandler \n                      \tfor XML schema namespace [\" + \n                     namespaceUri + \"]\", node);\n            }\n            else {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"No Spring NamespaceHandler \n                   \t  found for XML schema namespace [\" + namespaceUri + \"]\");\n                }\n            }\n        }\n        return originalDef;\n    }\n```\n\n首先获取自定义标签的命名空间，如果不是默认的命名空间则根据该命名空间获取相应的处理器，最后调用处理器的 `decorate()` 进行装饰处理。具体的装饰过程这里不进行讲述，在后面分析自定义标签时会做详细说明。\n\n至此，Bean 的解析过程已经全部完成了，下面做一个简要的总结。\n\n解析 BeanDefinition 的入口在 `DefaultBeanDefinitionDocumentReader.parseBeanDefinitions()` 。该方法会根据命令空间来判断标签是默认标签还是自定义标签，其中默认标签由 `parseDefaultElement()` 实现，自定义标签由 `parseCustomElement()` 实现。在默认标签解析中，会根据标签名称的不同进行 import 、alias 、bean 、beans 四大标签进行处理，其中 bean 标签的解析为核心，它由 `processBeanDefinition()` 方法实现。`processBeanDefinition()` 开始进入解析核心工作，分为三步：\n\n1. 解析默认标签：`BeanDefinitionParserDelegate.parseBeanDefinitionElement()`\n2. 解析默认标签下的自定义标签：`BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired()`\n3. 注册解析的 BeanDefinition：`BeanDefinitionReaderUtils.registerBeanDefinition`\n\n在默认标签解析过程中，核心工作由 `parseBeanDefinitionElement()` 方法实现，该方法会依次解析 Bean 标签的属性、各个子元素，解析完成后返回一个 GenericBeanDefinition 实例对象。","source":"_posts/spring 源码分析/spring/spring源码解析之 11bean标签：解析自定义标签.md","raw":"abbrlink: 30\ntitle: spring源码解析之 11bean标签：解析自定义标签\ntags:\n  - spring源码解析\n  - ''\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-14 05:25:00\n---\n# spring源码解析之 11bean标签：解析自定义标签\n\nbean标签解析设计太多的知识点，这里我们先看看最开始解析bean的那段代码，回顾一下\n<!-- more-->\n\n```java\n    protected void processBeanDefinition(Element ele,\n                                         BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,                 \n      \t\t\t\t\t\t\t\t getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\n                    \"Failed to register bean definition with name '\" +\n                        bdHolder.getBeanName() + \"'\", ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(\n                new BeanComponentDefinition(bdHolder));                                \n        }\n    }\n```\n\n`processBeanDefinition()` 负责 Bean 标签的解析，在解析过程中首先调用`BeanDefinitionParserDelegate.parseBeanDefinitionElement()` 完成默认标签的解析，如果解析成功（返回的 bdHolder != null ），则首先调用 `BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired()` 完成自定义标签元素解析，前面文章已经分析了默认标签的解析，所以这篇文章分析自定义标签的解析。首先大致了解下这句话的作用，其实我们可以从语义上分析：如果需要的话就对beanDefinition进行装饰，那这句话代码到底是什么功能呢？在bean属性解析过程中，有俩种类型：一种是默认类型的解析，另一种是自定义类型的解析，这里就是自定义类型的解析。前面我们也说过自定义标签的解析，为什么会在默认类型解析中单独添加一个方法处理呢？这个是因为，我们之前见过的那种类型是bean标签一级的自定义标签解析，这里我们看到的自定义类型其实是属性。就像下面这样：\n\n```xml\n<bean id=\"\" name=\"\">\n\t<myBean:user username=\"aaa\"/>\n</bean>\n```\n\n当spring中的bean使用的是默认的标签配置，但是其中的子元素却是用了自定义的配置，这句代码便会起作用。\n\n```java\n    public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, \n                                        BeanDefinitionHolder definitionHolder) {\n        return decorateBeanDefinitionIfRequired(ele, definitionHolder, null);\n    }\n```\n\n调用 `decorateBeanDefinitionIfRequired()` ：\n\n```java\n    public BeanDefinitionHolder decorateBeanDefinitionIfRequired(\n            Element ele, BeanDefinitionHolder definitionHolder, \n        \t@Nullable BeanDefinition containingBd) {\n\n        BeanDefinitionHolder finalDefinition = definitionHolder;\n\n        // 遍历所有的属性，查看是否有适用于装饰的属性\n        NamedNodeMap attributes = ele.getAttributes();\n        for (int i = 0; i < attributes.getLength(); i++) {\n            Node node = attributes.item(i);\n            finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);\n        }\n\n        // 遍历子节点，查看是否有适用于修饰的子元素\n        NodeList children = ele.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            Node node = children.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                finalDefinition = \n                    decorateIfRequired(node, finalDefinition, containingBd);\n            }\n        }\n        return finalDefinition;\n    }\n```\n\n上面代码，看到函数分别对元素和所有属性以及子节点进行了decorateIfRequired函数的调用，\n\n遍历节点（子节点），调用 `decorateIfRequired()` 装饰节点（子节点）。\n\n```java\n    public BeanDefinitionHolder decorateIfRequired(\n            Node node, BeanDefinitionHolder originalDef,\n        \t@Nullable BeanDefinition containingBd) {\n        // 获取自定义标签的命名空间\n        String namespaceUri = getNamespaceURI(node);\n        // 过滤掉默认命名标签\n        if (namespaceUri != null && !isDefaultNamespace(namespaceUri)) {\n            // 获取相应的处理器\n            NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n            if (handler != null) {\n                // 进行装饰处理\n                BeanDefinitionHolder decorated =\n                        handler.decorate(node, originalDef,\n                          new ParserContext(this.readerContext, this, containingBd));\n                if (decorated != null) {\n                    return decorated;\n                }\n            }\n            else if (namespaceUri.startsWith(\"http://www.springframework.org/\")) {\n                error(\"Unable to locate Spring NamespaceHandler \n                      \tfor XML schema namespace [\" + \n                     namespaceUri + \"]\", node);\n            }\n            else {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"No Spring NamespaceHandler \n                   \t  found for XML schema namespace [\" + namespaceUri + \"]\");\n                }\n            }\n        }\n        return originalDef;\n    }\n```\n\n首先获取自定义标签的命名空间，如果不是默认的命名空间则根据该命名空间获取相应的处理器，最后调用处理器的 `decorate()` 进行装饰处理。具体的装饰过程这里不进行讲述，在后面分析自定义标签时会做详细说明。\n\n至此，Bean 的解析过程已经全部完成了，下面做一个简要的总结。\n\n解析 BeanDefinition 的入口在 `DefaultBeanDefinitionDocumentReader.parseBeanDefinitions()` 。该方法会根据命令空间来判断标签是默认标签还是自定义标签，其中默认标签由 `parseDefaultElement()` 实现，自定义标签由 `parseCustomElement()` 实现。在默认标签解析中，会根据标签名称的不同进行 import 、alias 、bean 、beans 四大标签进行处理，其中 bean 标签的解析为核心，它由 `processBeanDefinition()` 方法实现。`processBeanDefinition()` 开始进入解析核心工作，分为三步：\n\n1. 解析默认标签：`BeanDefinitionParserDelegate.parseBeanDefinitionElement()`\n2. 解析默认标签下的自定义标签：`BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired()`\n3. 注册解析的 BeanDefinition：`BeanDefinitionReaderUtils.registerBeanDefinition`\n\n在默认标签解析过程中，核心工作由 `parseBeanDefinitionElement()` 方法实现，该方法会依次解析 Bean 标签的属性、各个子元素，解析完成后返回一个 GenericBeanDefinition 实例对象。","slug":"spring 源码分析/spring/spring源码解析之 11bean标签：解析自定义标签","published":1,"updated":"2019-01-15T03:37:23.781Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovti003b9q1ubqy0rfte","content":"<h1 id=\"spring源码解析之-11bean标签：解析自定义标签\"><a href=\"#spring源码解析之-11bean标签：解析自定义标签\" class=\"headerlink\" title=\"spring源码解析之 11bean标签：解析自定义标签\"></a>spring源码解析之 11bean标签：解析自定义标签</h1><p>bean标签解析设计太多的知识点，这里我们先看看最开始解析bean的那段代码，回顾一下<br><a id=\"more\"></a></p>\n<pre><code class=\"java\">    protected void processBeanDefinition(Element ele,\n                                         BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,                 \n                                       getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\n                    &quot;Failed to register bean definition with name &#39;&quot; +\n                        bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(\n                new BeanComponentDefinition(bdHolder));                                \n        }\n    }\n</code></pre>\n<p><code>processBeanDefinition()</code> 负责 Bean 标签的解析，在解析过程中首先调用<code>BeanDefinitionParserDelegate.parseBeanDefinitionElement()</code> 完成默认标签的解析，如果解析成功（返回的 bdHolder != null ），则首先调用 <code>BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired()</code> 完成自定义标签元素解析，前面文章已经分析了默认标签的解析，所以这篇文章分析自定义标签的解析。首先大致了解下这句话的作用，其实我们可以从语义上分析：如果需要的话就对beanDefinition进行装饰，那这句话代码到底是什么功能呢？在bean属性解析过程中，有俩种类型：一种是默认类型的解析，另一种是自定义类型的解析，这里就是自定义类型的解析。前面我们也说过自定义标签的解析，为什么会在默认类型解析中单独添加一个方法处理呢？这个是因为，我们之前见过的那种类型是bean标签一级的自定义标签解析，这里我们看到的自定义类型其实是属性。就像下面这样：</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;&quot; name=&quot;&quot;&gt;\n    &lt;myBean:user username=&quot;aaa&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>当spring中的bean使用的是默认的标签配置，但是其中的子元素却是用了自定义的配置，这句代码便会起作用。</p>\n<pre><code class=\"java\">    public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, \n                                        BeanDefinitionHolder definitionHolder) {\n        return decorateBeanDefinitionIfRequired(ele, definitionHolder, null);\n    }\n</code></pre>\n<p>调用 <code>decorateBeanDefinitionIfRequired()</code> ：</p>\n<pre><code class=\"java\">    public BeanDefinitionHolder decorateBeanDefinitionIfRequired(\n            Element ele, BeanDefinitionHolder definitionHolder, \n            @Nullable BeanDefinition containingBd) {\n\n        BeanDefinitionHolder finalDefinition = definitionHolder;\n\n        // 遍历所有的属性，查看是否有适用于装饰的属性\n        NamedNodeMap attributes = ele.getAttributes();\n        for (int i = 0; i &lt; attributes.getLength(); i++) {\n            Node node = attributes.item(i);\n            finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);\n        }\n\n        // 遍历子节点，查看是否有适用于修饰的子元素\n        NodeList children = ele.getChildNodes();\n        for (int i = 0; i &lt; children.getLength(); i++) {\n            Node node = children.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                finalDefinition = \n                    decorateIfRequired(node, finalDefinition, containingBd);\n            }\n        }\n        return finalDefinition;\n    }\n</code></pre>\n<p>上面代码，看到函数分别对元素和所有属性以及子节点进行了decorateIfRequired函数的调用，</p>\n<p>遍历节点（子节点），调用 <code>decorateIfRequired()</code> 装饰节点（子节点）。</p>\n<pre><code class=\"java\">    public BeanDefinitionHolder decorateIfRequired(\n            Node node, BeanDefinitionHolder originalDef,\n            @Nullable BeanDefinition containingBd) {\n        // 获取自定义标签的命名空间\n        String namespaceUri = getNamespaceURI(node);\n        // 过滤掉默认命名标签\n        if (namespaceUri != null &amp;&amp; !isDefaultNamespace(namespaceUri)) {\n            // 获取相应的处理器\n            NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n            if (handler != null) {\n                // 进行装饰处理\n                BeanDefinitionHolder decorated =\n                        handler.decorate(node, originalDef,\n                          new ParserContext(this.readerContext, this, containingBd));\n                if (decorated != null) {\n                    return decorated;\n                }\n            }\n            else if (namespaceUri.startsWith(&quot;http://www.springframework.org/&quot;)) {\n                error(&quot;Unable to locate Spring NamespaceHandler \n                          for XML schema namespace [&quot; + \n                     namespaceUri + &quot;]&quot;, node);\n            }\n            else {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(&quot;No Spring NamespaceHandler \n                         found for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;);\n                }\n            }\n        }\n        return originalDef;\n    }\n</code></pre>\n<p>首先获取自定义标签的命名空间，如果不是默认的命名空间则根据该命名空间获取相应的处理器，最后调用处理器的 <code>decorate()</code> 进行装饰处理。具体的装饰过程这里不进行讲述，在后面分析自定义标签时会做详细说明。</p>\n<p>至此，Bean 的解析过程已经全部完成了，下面做一个简要的总结。</p>\n<p>解析 BeanDefinition 的入口在 <code>DefaultBeanDefinitionDocumentReader.parseBeanDefinitions()</code> 。该方法会根据命令空间来判断标签是默认标签还是自定义标签，其中默认标签由 <code>parseDefaultElement()</code> 实现，自定义标签由 <code>parseCustomElement()</code> 实现。在默认标签解析中，会根据标签名称的不同进行 import 、alias 、bean 、beans 四大标签进行处理，其中 bean 标签的解析为核心，它由 <code>processBeanDefinition()</code> 方法实现。<code>processBeanDefinition()</code> 开始进入解析核心工作，分为三步：</p>\n<ol>\n<li>解析默认标签：<code>BeanDefinitionParserDelegate.parseBeanDefinitionElement()</code></li>\n<li>解析默认标签下的自定义标签：<code>BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired()</code></li>\n<li>注册解析的 BeanDefinition：<code>BeanDefinitionReaderUtils.registerBeanDefinition</code></li>\n</ol>\n<p>在默认标签解析过程中，核心工作由 <code>parseBeanDefinitionElement()</code> 方法实现，该方法会依次解析 Bean 标签的属性、各个子元素，解析完成后返回一个 GenericBeanDefinition 实例对象。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-11bean标签：解析自定义标签\"><a href=\"#spring源码解析之-11bean标签：解析自定义标签\" class=\"headerlink\" title=\"spring源码解析之 11bean标签：解析自定义标签\"></a>spring源码解析之 11bean标签：解析自定义标签</h1><p>bean标签解析设计太多的知识点，这里我们先看看最开始解析bean的那段代码，回顾一下<br>","more":"</p>\n<pre><code class=\"java\">    protected void processBeanDefinition(Element ele,\n                                         BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,                 \n                                       getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\n                    &quot;Failed to register bean definition with name &#39;&quot; +\n                        bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(\n                new BeanComponentDefinition(bdHolder));                                \n        }\n    }\n</code></pre>\n<p><code>processBeanDefinition()</code> 负责 Bean 标签的解析，在解析过程中首先调用<code>BeanDefinitionParserDelegate.parseBeanDefinitionElement()</code> 完成默认标签的解析，如果解析成功（返回的 bdHolder != null ），则首先调用 <code>BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired()</code> 完成自定义标签元素解析，前面文章已经分析了默认标签的解析，所以这篇文章分析自定义标签的解析。首先大致了解下这句话的作用，其实我们可以从语义上分析：如果需要的话就对beanDefinition进行装饰，那这句话代码到底是什么功能呢？在bean属性解析过程中，有俩种类型：一种是默认类型的解析，另一种是自定义类型的解析，这里就是自定义类型的解析。前面我们也说过自定义标签的解析，为什么会在默认类型解析中单独添加一个方法处理呢？这个是因为，我们之前见过的那种类型是bean标签一级的自定义标签解析，这里我们看到的自定义类型其实是属性。就像下面这样：</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;&quot; name=&quot;&quot;&gt;\n    &lt;myBean:user username=&quot;aaa&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>当spring中的bean使用的是默认的标签配置，但是其中的子元素却是用了自定义的配置，这句代码便会起作用。</p>\n<pre><code class=\"java\">    public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, \n                                        BeanDefinitionHolder definitionHolder) {\n        return decorateBeanDefinitionIfRequired(ele, definitionHolder, null);\n    }\n</code></pre>\n<p>调用 <code>decorateBeanDefinitionIfRequired()</code> ：</p>\n<pre><code class=\"java\">    public BeanDefinitionHolder decorateBeanDefinitionIfRequired(\n            Element ele, BeanDefinitionHolder definitionHolder, \n            @Nullable BeanDefinition containingBd) {\n\n        BeanDefinitionHolder finalDefinition = definitionHolder;\n\n        // 遍历所有的属性，查看是否有适用于装饰的属性\n        NamedNodeMap attributes = ele.getAttributes();\n        for (int i = 0; i &lt; attributes.getLength(); i++) {\n            Node node = attributes.item(i);\n            finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);\n        }\n\n        // 遍历子节点，查看是否有适用于修饰的子元素\n        NodeList children = ele.getChildNodes();\n        for (int i = 0; i &lt; children.getLength(); i++) {\n            Node node = children.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                finalDefinition = \n                    decorateIfRequired(node, finalDefinition, containingBd);\n            }\n        }\n        return finalDefinition;\n    }\n</code></pre>\n<p>上面代码，看到函数分别对元素和所有属性以及子节点进行了decorateIfRequired函数的调用，</p>\n<p>遍历节点（子节点），调用 <code>decorateIfRequired()</code> 装饰节点（子节点）。</p>\n<pre><code class=\"java\">    public BeanDefinitionHolder decorateIfRequired(\n            Node node, BeanDefinitionHolder originalDef,\n            @Nullable BeanDefinition containingBd) {\n        // 获取自定义标签的命名空间\n        String namespaceUri = getNamespaceURI(node);\n        // 过滤掉默认命名标签\n        if (namespaceUri != null &amp;&amp; !isDefaultNamespace(namespaceUri)) {\n            // 获取相应的处理器\n            NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n            if (handler != null) {\n                // 进行装饰处理\n                BeanDefinitionHolder decorated =\n                        handler.decorate(node, originalDef,\n                          new ParserContext(this.readerContext, this, containingBd));\n                if (decorated != null) {\n                    return decorated;\n                }\n            }\n            else if (namespaceUri.startsWith(&quot;http://www.springframework.org/&quot;)) {\n                error(&quot;Unable to locate Spring NamespaceHandler \n                          for XML schema namespace [&quot; + \n                     namespaceUri + &quot;]&quot;, node);\n            }\n            else {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(&quot;No Spring NamespaceHandler \n                         found for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;);\n                }\n            }\n        }\n        return originalDef;\n    }\n</code></pre>\n<p>首先获取自定义标签的命名空间，如果不是默认的命名空间则根据该命名空间获取相应的处理器，最后调用处理器的 <code>decorate()</code> 进行装饰处理。具体的装饰过程这里不进行讲述，在后面分析自定义标签时会做详细说明。</p>\n<p>至此，Bean 的解析过程已经全部完成了，下面做一个简要的总结。</p>\n<p>解析 BeanDefinition 的入口在 <code>DefaultBeanDefinitionDocumentReader.parseBeanDefinitions()</code> 。该方法会根据命令空间来判断标签是默认标签还是自定义标签，其中默认标签由 <code>parseDefaultElement()</code> 实现，自定义标签由 <code>parseCustomElement()</code> 实现。在默认标签解析中，会根据标签名称的不同进行 import 、alias 、bean 、beans 四大标签进行处理，其中 bean 标签的解析为核心，它由 <code>processBeanDefinition()</code> 方法实现。<code>processBeanDefinition()</code> 开始进入解析核心工作，分为三步：</p>\n<ol>\n<li>解析默认标签：<code>BeanDefinitionParserDelegate.parseBeanDefinitionElement()</code></li>\n<li>解析默认标签下的自定义标签：<code>BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired()</code></li>\n<li>注册解析的 BeanDefinition：<code>BeanDefinitionReaderUtils.registerBeanDefinition</code></li>\n</ol>\n<p>在默认标签解析过程中，核心工作由 <code>parseBeanDefinitionElement()</code> 方法实现，该方法会依次解析 Bean 标签的属性、各个子元素，解析完成后返回一个 GenericBeanDefinition 实例对象。</p>"},{"abbrlink":38,"title":"spring源码解析之 19 各Scope的创建","author":"fengxiutianya","date":"2019-01-14T19:33:00.000Z","_content":"# spring源码解析之 19 各Scope的创建\n\n在 Spring 中存在着不同的 scope，默认是 singleton ，还有 prototype、request 等等其他的 scope，他们的初始化步骤是怎样的呢？这个答案在这篇博客中给出。\n<!-- more-->\n\n**singleton**\n\nSpring 的 scope 默认为 singleton，其初始化的代码如下：\n\n```java\nif (mbd.isSingleton()) {\n    sharedInstance = getSingleton(beanName, () -> {\n        try {\n            return createBean(beanName, mbd, args);\n        }\n        catch (BeansException ex) {\n            destroySingleton(beanName);\n            throw ex;\n        }\n    });\n    bean = getObjectForBeanInstance(sharedInstance, name, \n                                    beanName, mbd);\n}\n```\n\n第一部分分析了从缓存中获取单例模式的 bean，但是如果缓存中不存在呢？则需要从头开始加载 bean，这个过程由 `getSingleton()` 实现。\n\n```java\n public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {\n\t\tAssert.notNull(beanName, \"Bean name must not be null\");\n\t\t// 全局变量需要同步\n\t\tsynchronized (this.singletonObjects) {\n\t\t\t// 首先检查对一个的bean是否已经加载过，因为singleton模式其实就是复用已创建的bean\n\t\t\t// 所以这一步是必须的\n\t\t\tObject singletonObject = this.singletonObjects.get(beanName);\n\t\t\t// 如果为空才可以进行singleton的bean的初始化\n\t\t\tif (singletonObject == null) {\n\t\t\t\t// 检查bean是否在销毁，如果销毁则抛出异常\n\t\t\t\tif (this.singletonsCurrentlyInDestruction) {\n\t\t\t\t\t// 省略抛出异常代码\n\t\t\t\t}\n                \n\t\t\t\t// 创建之前的处理工作，将当前正在创建的bean加入的创建bean的缓存中，\n\t\t\t\tbeforeSingletonCreation(beanName);\n\t\t\t\tboolean newSingleton = false;\n\t\t\t\tboolean recordSuppressedExceptions = \n                    \t\t\t(this.suppressedExceptions == null);\n\t\t\t\tif (recordSuppressedExceptions) {\n\t\t\t\t\tthis.suppressedExceptions = new LinkedHashSet<>();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// 初始化bean，主要的就是调用Lambda表达式中的createBean()方法\n\t\t\t\t\tsingletonObject = singletonFactory.getObject();\n\t\t\t\t\tnewSingleton = true;\n\t\t\t\t} catch (IllegalStateException ex) {\n                    singletonObject = this.singletonObjects.get(beanName);\n\t\t\t\t\tif (singletonObject == null) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t} catch (BeanCreationException ex) {\n\t\t\t\t\tif (recordSuppressedExceptions) {\n\t\t\t\t\t\tfor (Exception suppressedException : this.suppressedExceptions)\n                        {\n\t\t\t\t\t\t\tex.addRelatedCause(suppressedException);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t} finally {\n\t\t\t\t\tif (recordSuppressedExceptions) {\n\t\t\t\t\t\tthis.suppressedExceptions = null;\n\t\t\t\t\t}\n\t\t\t\t\t// 创建之后的处理工作：从正在创建的bean中删除当前的beanname，\n\t\t\t\t\tafterSingletonCreation(beanName);\n\t\t\t\t}\n\t\t\t\t// 创建成功加入缓存\n\t\t\t\tif (newSingleton) {\n\t\t\t\t\t// 将结果记录至缓存并删除加载bean过程中所记录的各种辅助状态\n\t\t\t\t\taddSingleton(beanName, singletonObject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singletonObject;\n\t\t}\n\t}\n\n```\n\n其实这个过程并没有真正创建 bean，仅仅只是做了一部分准备和预处理步骤，真正获取单例 bean 的方法其实是由 `singletonFactory.getObject()` 这部分实现，而 singletonFactory 由回调方法产生。那么这个方法做了哪些准备呢？\n\n1. 再次检查缓存是否已经加载过，如果已经加载了则直接返回，否则开始加载过程。\n2. 调用 `beforeSingletonCreation()` 记录加载单例 bean 之前的加载状态，即前置处理。\n3. 调用参数传递的 ObjectFactory 的 `getObject()` 实例化 bean。\n4. 调用 `afterSingletonCreation()` 进行加载单例后的后置处理。\n5. 将结果记录并加入值缓存中，同时删除加载 bean 过程中所记录的一些辅助状态。\n\n流程中涉及的三个方法 `beforeSingletonCreation()` 与 `afterSingletonCreation()` 在前面博客中分析过了，所以这里不再阐述了，我们看另外一个方法 `addSingleton()`。\n\n```java\n    protected void addSingleton(String beanName, Object singletonObject) {\n        synchronized (this.singletonObjects) {\n            this.singletonObjects.put(beanName, singletonObject);\n            this.singletonFactories.remove(beanName);\n            this.earlySingletonObjects.remove(beanName);\n            this.registeredSingletons.add(beanName);\n        }\n    }\n```\n\n一个 put、一个 add、两个 remove。singletonObjects 单例 bean 的缓存，singletonFactories 单例 bean Factory 的缓存，earlySingletonObjects “早期”创建的单例 bean 的缓存，registeredSingletons 已经注册的单例缓存。\n\n加载了单例 bean 后，调用 `getObjectForBeanInstance()` 从 bean 实例中获取对象。该方法已经在前面博客详细分析了。\n\n**原型模式**\n\n```java\nelse if (mbd.isPrototype()) {\n    Object prototypeInstance = null;\n    try {\n        beforePrototypeCreation(beanName);\n        prototypeInstance = createBean(beanName, mbd, args);\n    }\n    finally {\n        afterPrototypeCreation(beanName);\n    }\n    bean = getObjectForBeanInstance(prototypeInstance, name,\n                                    beanName, mbd);\n}\n```\n\n原型模式的初始化过程很简单：直接创建一个新的实例就可以了。过程如下：\n\n1. 调用` beforePrototypeCreation()` 记录加载原型模式 bean 之前的加载状态，即前置处理。\n2. 调用 `createBean()` 创建一个 bean 实例对象。\n3. 调用 `afterPrototypeCreation()` 进行加载原型模式 bean 后的后置处理。\n4. 调用 `getObjectForBeanInstance()` 从 bean 实例中获取对象。\n\n**其他作用域**\n\n```java\nString scopeName = mbd.getScope();\nfinal Scope scope = this.scopes.get(scopeName);\nif (scope == null) {\n    throw new IllegalStateException(\"No Scope registered for scope name '\" \n                                    + scopeName + \"'\");\n }\ntry {\n    Object scopedInstance = scope.get(beanName, () -> {\n        beforePrototypeCreation(beanName);\n        try {\n            return createBean(beanName, mbd, args);\n        }\n        finally {\n            afterPrototypeCreation(beanName);\n        }\n    });\n\tbean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n    \n}catch (IllegalStateException ex) {\n  \t//抛出异常代码省略\n}\n```\n\n核心流程和原型模式一样，只不过获取 bean 实例是由 `scope.get()` 实现，如下：\n\n```java\n    public Object get(String name, ObjectFactory<?> objectFactory) {\n       // 获取 scope 缓存\n        Map<String, Object> scope = this.threadScope.get();\n        Object scopedObject = scope.get(name);\n        if (scopedObject == null) {\n            scopedObject = objectFactory.getObject();\n            // 加入缓存\n            scope.put(name, scopedObject);\n        }\n        return scopedObject;\n    }\n```\n\n对于上面三个模块，其中最重要的有两个方法，一个是 `createBean()`、一个是 `getObjectForBeanInstance()`。这两个方法在上面三个模块都有调用，`createBean()` 后续详细说明，`getObjectForBeanInstance()` 在前面博客 中有详细讲解，这里再次阐述下（此段内容来自《Spring 源码深度解析》）：这个方法主要是验证以下我们得到的 bean 的正确性，其实就是检测当前 bean 是否是 FactoryBean 类型的 bean，如果是，那么需要调用该 bean 对应的 FactoryBean 实例的 `getObject()` 作为返回值。无论是从缓存中获得到的 bean 还是通过不同的 scope 策略加载的 bean 都只是最原始的 bean 状态，并不一定就是我们最终想要的 bean。举个例子，加入我们需要对工厂 bean 进行处理，那么这里得到的其实是工厂 bean 的初始状态，但是我们真正需要的是工厂 bean 中定义 factory-method 方法中返回的 bean，而 `getObjectForBeanInstance()` 就是完成这个工作的。","source":"_posts/spring 源码分析/spring/spring源码解析之 19各Scope的创建.md","raw":"abbrlink: 38\ntitle: spring源码解析之 19 各Scope的创建\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-15 03:33:00\n---\n# spring源码解析之 19 各Scope的创建\n\n在 Spring 中存在着不同的 scope，默认是 singleton ，还有 prototype、request 等等其他的 scope，他们的初始化步骤是怎样的呢？这个答案在这篇博客中给出。\n<!-- more-->\n\n**singleton**\n\nSpring 的 scope 默认为 singleton，其初始化的代码如下：\n\n```java\nif (mbd.isSingleton()) {\n    sharedInstance = getSingleton(beanName, () -> {\n        try {\n            return createBean(beanName, mbd, args);\n        }\n        catch (BeansException ex) {\n            destroySingleton(beanName);\n            throw ex;\n        }\n    });\n    bean = getObjectForBeanInstance(sharedInstance, name, \n                                    beanName, mbd);\n}\n```\n\n第一部分分析了从缓存中获取单例模式的 bean，但是如果缓存中不存在呢？则需要从头开始加载 bean，这个过程由 `getSingleton()` 实现。\n\n```java\n public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {\n\t\tAssert.notNull(beanName, \"Bean name must not be null\");\n\t\t// 全局变量需要同步\n\t\tsynchronized (this.singletonObjects) {\n\t\t\t// 首先检查对一个的bean是否已经加载过，因为singleton模式其实就是复用已创建的bean\n\t\t\t// 所以这一步是必须的\n\t\t\tObject singletonObject = this.singletonObjects.get(beanName);\n\t\t\t// 如果为空才可以进行singleton的bean的初始化\n\t\t\tif (singletonObject == null) {\n\t\t\t\t// 检查bean是否在销毁，如果销毁则抛出异常\n\t\t\t\tif (this.singletonsCurrentlyInDestruction) {\n\t\t\t\t\t// 省略抛出异常代码\n\t\t\t\t}\n                \n\t\t\t\t// 创建之前的处理工作，将当前正在创建的bean加入的创建bean的缓存中，\n\t\t\t\tbeforeSingletonCreation(beanName);\n\t\t\t\tboolean newSingleton = false;\n\t\t\t\tboolean recordSuppressedExceptions = \n                    \t\t\t(this.suppressedExceptions == null);\n\t\t\t\tif (recordSuppressedExceptions) {\n\t\t\t\t\tthis.suppressedExceptions = new LinkedHashSet<>();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// 初始化bean，主要的就是调用Lambda表达式中的createBean()方法\n\t\t\t\t\tsingletonObject = singletonFactory.getObject();\n\t\t\t\t\tnewSingleton = true;\n\t\t\t\t} catch (IllegalStateException ex) {\n                    singletonObject = this.singletonObjects.get(beanName);\n\t\t\t\t\tif (singletonObject == null) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t} catch (BeanCreationException ex) {\n\t\t\t\t\tif (recordSuppressedExceptions) {\n\t\t\t\t\t\tfor (Exception suppressedException : this.suppressedExceptions)\n                        {\n\t\t\t\t\t\t\tex.addRelatedCause(suppressedException);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t} finally {\n\t\t\t\t\tif (recordSuppressedExceptions) {\n\t\t\t\t\t\tthis.suppressedExceptions = null;\n\t\t\t\t\t}\n\t\t\t\t\t// 创建之后的处理工作：从正在创建的bean中删除当前的beanname，\n\t\t\t\t\tafterSingletonCreation(beanName);\n\t\t\t\t}\n\t\t\t\t// 创建成功加入缓存\n\t\t\t\tif (newSingleton) {\n\t\t\t\t\t// 将结果记录至缓存并删除加载bean过程中所记录的各种辅助状态\n\t\t\t\t\taddSingleton(beanName, singletonObject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singletonObject;\n\t\t}\n\t}\n\n```\n\n其实这个过程并没有真正创建 bean，仅仅只是做了一部分准备和预处理步骤，真正获取单例 bean 的方法其实是由 `singletonFactory.getObject()` 这部分实现，而 singletonFactory 由回调方法产生。那么这个方法做了哪些准备呢？\n\n1. 再次检查缓存是否已经加载过，如果已经加载了则直接返回，否则开始加载过程。\n2. 调用 `beforeSingletonCreation()` 记录加载单例 bean 之前的加载状态，即前置处理。\n3. 调用参数传递的 ObjectFactory 的 `getObject()` 实例化 bean。\n4. 调用 `afterSingletonCreation()` 进行加载单例后的后置处理。\n5. 将结果记录并加入值缓存中，同时删除加载 bean 过程中所记录的一些辅助状态。\n\n流程中涉及的三个方法 `beforeSingletonCreation()` 与 `afterSingletonCreation()` 在前面博客中分析过了，所以这里不再阐述了，我们看另外一个方法 `addSingleton()`。\n\n```java\n    protected void addSingleton(String beanName, Object singletonObject) {\n        synchronized (this.singletonObjects) {\n            this.singletonObjects.put(beanName, singletonObject);\n            this.singletonFactories.remove(beanName);\n            this.earlySingletonObjects.remove(beanName);\n            this.registeredSingletons.add(beanName);\n        }\n    }\n```\n\n一个 put、一个 add、两个 remove。singletonObjects 单例 bean 的缓存，singletonFactories 单例 bean Factory 的缓存，earlySingletonObjects “早期”创建的单例 bean 的缓存，registeredSingletons 已经注册的单例缓存。\n\n加载了单例 bean 后，调用 `getObjectForBeanInstance()` 从 bean 实例中获取对象。该方法已经在前面博客详细分析了。\n\n**原型模式**\n\n```java\nelse if (mbd.isPrototype()) {\n    Object prototypeInstance = null;\n    try {\n        beforePrototypeCreation(beanName);\n        prototypeInstance = createBean(beanName, mbd, args);\n    }\n    finally {\n        afterPrototypeCreation(beanName);\n    }\n    bean = getObjectForBeanInstance(prototypeInstance, name,\n                                    beanName, mbd);\n}\n```\n\n原型模式的初始化过程很简单：直接创建一个新的实例就可以了。过程如下：\n\n1. 调用` beforePrototypeCreation()` 记录加载原型模式 bean 之前的加载状态，即前置处理。\n2. 调用 `createBean()` 创建一个 bean 实例对象。\n3. 调用 `afterPrototypeCreation()` 进行加载原型模式 bean 后的后置处理。\n4. 调用 `getObjectForBeanInstance()` 从 bean 实例中获取对象。\n\n**其他作用域**\n\n```java\nString scopeName = mbd.getScope();\nfinal Scope scope = this.scopes.get(scopeName);\nif (scope == null) {\n    throw new IllegalStateException(\"No Scope registered for scope name '\" \n                                    + scopeName + \"'\");\n }\ntry {\n    Object scopedInstance = scope.get(beanName, () -> {\n        beforePrototypeCreation(beanName);\n        try {\n            return createBean(beanName, mbd, args);\n        }\n        finally {\n            afterPrototypeCreation(beanName);\n        }\n    });\n\tbean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n    \n}catch (IllegalStateException ex) {\n  \t//抛出异常代码省略\n}\n```\n\n核心流程和原型模式一样，只不过获取 bean 实例是由 `scope.get()` 实现，如下：\n\n```java\n    public Object get(String name, ObjectFactory<?> objectFactory) {\n       // 获取 scope 缓存\n        Map<String, Object> scope = this.threadScope.get();\n        Object scopedObject = scope.get(name);\n        if (scopedObject == null) {\n            scopedObject = objectFactory.getObject();\n            // 加入缓存\n            scope.put(name, scopedObject);\n        }\n        return scopedObject;\n    }\n```\n\n对于上面三个模块，其中最重要的有两个方法，一个是 `createBean()`、一个是 `getObjectForBeanInstance()`。这两个方法在上面三个模块都有调用，`createBean()` 后续详细说明，`getObjectForBeanInstance()` 在前面博客 中有详细讲解，这里再次阐述下（此段内容来自《Spring 源码深度解析》）：这个方法主要是验证以下我们得到的 bean 的正确性，其实就是检测当前 bean 是否是 FactoryBean 类型的 bean，如果是，那么需要调用该 bean 对应的 FactoryBean 实例的 `getObject()` 作为返回值。无论是从缓存中获得到的 bean 还是通过不同的 scope 策略加载的 bean 都只是最原始的 bean 状态，并不一定就是我们最终想要的 bean。举个例子，加入我们需要对工厂 bean 进行处理，那么这里得到的其实是工厂 bean 的初始状态，但是我们真正需要的是工厂 bean 中定义 factory-method 方法中返回的 bean，而 `getObjectForBeanInstance()` 就是完成这个工作的。","slug":"spring 源码分析/spring/spring源码解析之 19各Scope的创建","published":1,"updated":"2019-01-15T07:08:25.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovtj003e9q1uy2aoawld","content":"<h1 id=\"spring源码解析之-19-各Scope的创建\"><a href=\"#spring源码解析之-19-各Scope的创建\" class=\"headerlink\" title=\"spring源码解析之 19 各Scope的创建\"></a>spring源码解析之 19 各Scope的创建</h1><p>在 Spring 中存在着不同的 scope，默认是 singleton ，还有 prototype、request 等等其他的 scope，他们的初始化步骤是怎样的呢？这个答案在这篇博客中给出。<br><a id=\"more\"></a></p>\n<p><strong>singleton</strong></p>\n<p>Spring 的 scope 默认为 singleton，其初始化的代码如下：</p>\n<pre><code class=\"java\">if (mbd.isSingleton()) {\n    sharedInstance = getSingleton(beanName, () -&gt; {\n        try {\n            return createBean(beanName, mbd, args);\n        }\n        catch (BeansException ex) {\n            destroySingleton(beanName);\n            throw ex;\n        }\n    });\n    bean = getObjectForBeanInstance(sharedInstance, name, \n                                    beanName, mbd);\n}\n</code></pre>\n<p>第一部分分析了从缓存中获取单例模式的 bean，但是如果缓存中不存在呢？则需要从头开始加载 bean，这个过程由 <code>getSingleton()</code> 实现。</p>\n<pre><code class=\"java\"> public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {\n        Assert.notNull(beanName, &quot;Bean name must not be null&quot;);\n        // 全局变量需要同步\n        synchronized (this.singletonObjects) {\n            // 首先检查对一个的bean是否已经加载过，因为singleton模式其实就是复用已创建的bean\n            // 所以这一步是必须的\n            Object singletonObject = this.singletonObjects.get(beanName);\n            // 如果为空才可以进行singleton的bean的初始化\n            if (singletonObject == null) {\n                // 检查bean是否在销毁，如果销毁则抛出异常\n                if (this.singletonsCurrentlyInDestruction) {\n                    // 省略抛出异常代码\n                }\n\n                // 创建之前的处理工作，将当前正在创建的bean加入的创建bean的缓存中，\n                beforeSingletonCreation(beanName);\n                boolean newSingleton = false;\n                boolean recordSuppressedExceptions = \n                                (this.suppressedExceptions == null);\n                if (recordSuppressedExceptions) {\n                    this.suppressedExceptions = new LinkedHashSet&lt;&gt;();\n                }\n                try {\n                    // 初始化bean，主要的就是调用Lambda表达式中的createBean()方法\n                    singletonObject = singletonFactory.getObject();\n                    newSingleton = true;\n                } catch (IllegalStateException ex) {\n                    singletonObject = this.singletonObjects.get(beanName);\n                    if (singletonObject == null) {\n                        throw ex;\n                    }\n                } catch (BeanCreationException ex) {\n                    if (recordSuppressedExceptions) {\n                        for (Exception suppressedException : this.suppressedExceptions)\n                        {\n                            ex.addRelatedCause(suppressedException);\n                        }\n                    }\n                    throw ex;\n                } finally {\n                    if (recordSuppressedExceptions) {\n                        this.suppressedExceptions = null;\n                    }\n                    // 创建之后的处理工作：从正在创建的bean中删除当前的beanname，\n                    afterSingletonCreation(beanName);\n                }\n                // 创建成功加入缓存\n                if (newSingleton) {\n                    // 将结果记录至缓存并删除加载bean过程中所记录的各种辅助状态\n                    addSingleton(beanName, singletonObject);\n                }\n            }\n            return singletonObject;\n        }\n    }\n\n</code></pre>\n<p>其实这个过程并没有真正创建 bean，仅仅只是做了一部分准备和预处理步骤，真正获取单例 bean 的方法其实是由 <code>singletonFactory.getObject()</code> 这部分实现，而 singletonFactory 由回调方法产生。那么这个方法做了哪些准备呢？</p>\n<ol>\n<li>再次检查缓存是否已经加载过，如果已经加载了则直接返回，否则开始加载过程。</li>\n<li>调用 <code>beforeSingletonCreation()</code> 记录加载单例 bean 之前的加载状态，即前置处理。</li>\n<li>调用参数传递的 ObjectFactory 的 <code>getObject()</code> 实例化 bean。</li>\n<li>调用 <code>afterSingletonCreation()</code> 进行加载单例后的后置处理。</li>\n<li>将结果记录并加入值缓存中，同时删除加载 bean 过程中所记录的一些辅助状态。</li>\n</ol>\n<p>流程中涉及的三个方法 <code>beforeSingletonCreation()</code> 与 <code>afterSingletonCreation()</code> 在前面博客中分析过了，所以这里不再阐述了，我们看另外一个方法 <code>addSingleton()</code>。</p>\n<pre><code class=\"java\">    protected void addSingleton(String beanName, Object singletonObject) {\n        synchronized (this.singletonObjects) {\n            this.singletonObjects.put(beanName, singletonObject);\n            this.singletonFactories.remove(beanName);\n            this.earlySingletonObjects.remove(beanName);\n            this.registeredSingletons.add(beanName);\n        }\n    }\n</code></pre>\n<p>一个 put、一个 add、两个 remove。singletonObjects 单例 bean 的缓存，singletonFactories 单例 bean Factory 的缓存，earlySingletonObjects “早期”创建的单例 bean 的缓存，registeredSingletons 已经注册的单例缓存。</p>\n<p>加载了单例 bean 后，调用 <code>getObjectForBeanInstance()</code> 从 bean 实例中获取对象。该方法已经在前面博客详细分析了。</p>\n<p><strong>原型模式</strong></p>\n<pre><code class=\"java\">else if (mbd.isPrototype()) {\n    Object prototypeInstance = null;\n    try {\n        beforePrototypeCreation(beanName);\n        prototypeInstance = createBean(beanName, mbd, args);\n    }\n    finally {\n        afterPrototypeCreation(beanName);\n    }\n    bean = getObjectForBeanInstance(prototypeInstance, name,\n                                    beanName, mbd);\n}\n</code></pre>\n<p>原型模式的初始化过程很简单：直接创建一个新的实例就可以了。过程如下：</p>\n<ol>\n<li>调用<code>beforePrototypeCreation()</code> 记录加载原型模式 bean 之前的加载状态，即前置处理。</li>\n<li>调用 <code>createBean()</code> 创建一个 bean 实例对象。</li>\n<li>调用 <code>afterPrototypeCreation()</code> 进行加载原型模式 bean 后的后置处理。</li>\n<li>调用 <code>getObjectForBeanInstance()</code> 从 bean 实例中获取对象。</li>\n</ol>\n<p><strong>其他作用域</strong></p>\n<pre><code class=\"java\">String scopeName = mbd.getScope();\nfinal Scope scope = this.scopes.get(scopeName);\nif (scope == null) {\n    throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; \n                                    + scopeName + &quot;&#39;&quot;);\n }\ntry {\n    Object scopedInstance = scope.get(beanName, () -&gt; {\n        beforePrototypeCreation(beanName);\n        try {\n            return createBean(beanName, mbd, args);\n        }\n        finally {\n            afterPrototypeCreation(beanName);\n        }\n    });\n    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n\n}catch (IllegalStateException ex) {\n      //抛出异常代码省略\n}\n</code></pre>\n<p>核心流程和原型模式一样，只不过获取 bean 实例是由 <code>scope.get()</code> 实现，如下：</p>\n<pre><code class=\"java\">    public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) {\n       // 获取 scope 缓存\n        Map&lt;String, Object&gt; scope = this.threadScope.get();\n        Object scopedObject = scope.get(name);\n        if (scopedObject == null) {\n            scopedObject = objectFactory.getObject();\n            // 加入缓存\n            scope.put(name, scopedObject);\n        }\n        return scopedObject;\n    }\n</code></pre>\n<p>对于上面三个模块，其中最重要的有两个方法，一个是 <code>createBean()</code>、一个是 <code>getObjectForBeanInstance()</code>。这两个方法在上面三个模块都有调用，<code>createBean()</code> 后续详细说明，<code>getObjectForBeanInstance()</code> 在前面博客 中有详细讲解，这里再次阐述下（此段内容来自《Spring 源码深度解析》）：这个方法主要是验证以下我们得到的 bean 的正确性，其实就是检测当前 bean 是否是 FactoryBean 类型的 bean，如果是，那么需要调用该 bean 对应的 FactoryBean 实例的 <code>getObject()</code> 作为返回值。无论是从缓存中获得到的 bean 还是通过不同的 scope 策略加载的 bean 都只是最原始的 bean 状态，并不一定就是我们最终想要的 bean。举个例子，加入我们需要对工厂 bean 进行处理，那么这里得到的其实是工厂 bean 的初始状态，但是我们真正需要的是工厂 bean 中定义 factory-method 方法中返回的 bean，而 <code>getObjectForBeanInstance()</code> 就是完成这个工作的。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-19-各Scope的创建\"><a href=\"#spring源码解析之-19-各Scope的创建\" class=\"headerlink\" title=\"spring源码解析之 19 各Scope的创建\"></a>spring源码解析之 19 各Scope的创建</h1><p>在 Spring 中存在着不同的 scope，默认是 singleton ，还有 prototype、request 等等其他的 scope，他们的初始化步骤是怎样的呢？这个答案在这篇博客中给出。<br>","more":"</p>\n<p><strong>singleton</strong></p>\n<p>Spring 的 scope 默认为 singleton，其初始化的代码如下：</p>\n<pre><code class=\"java\">if (mbd.isSingleton()) {\n    sharedInstance = getSingleton(beanName, () -&gt; {\n        try {\n            return createBean(beanName, mbd, args);\n        }\n        catch (BeansException ex) {\n            destroySingleton(beanName);\n            throw ex;\n        }\n    });\n    bean = getObjectForBeanInstance(sharedInstance, name, \n                                    beanName, mbd);\n}\n</code></pre>\n<p>第一部分分析了从缓存中获取单例模式的 bean，但是如果缓存中不存在呢？则需要从头开始加载 bean，这个过程由 <code>getSingleton()</code> 实现。</p>\n<pre><code class=\"java\"> public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {\n        Assert.notNull(beanName, &quot;Bean name must not be null&quot;);\n        // 全局变量需要同步\n        synchronized (this.singletonObjects) {\n            // 首先检查对一个的bean是否已经加载过，因为singleton模式其实就是复用已创建的bean\n            // 所以这一步是必须的\n            Object singletonObject = this.singletonObjects.get(beanName);\n            // 如果为空才可以进行singleton的bean的初始化\n            if (singletonObject == null) {\n                // 检查bean是否在销毁，如果销毁则抛出异常\n                if (this.singletonsCurrentlyInDestruction) {\n                    // 省略抛出异常代码\n                }\n\n                // 创建之前的处理工作，将当前正在创建的bean加入的创建bean的缓存中，\n                beforeSingletonCreation(beanName);\n                boolean newSingleton = false;\n                boolean recordSuppressedExceptions = \n                                (this.suppressedExceptions == null);\n                if (recordSuppressedExceptions) {\n                    this.suppressedExceptions = new LinkedHashSet&lt;&gt;();\n                }\n                try {\n                    // 初始化bean，主要的就是调用Lambda表达式中的createBean()方法\n                    singletonObject = singletonFactory.getObject();\n                    newSingleton = true;\n                } catch (IllegalStateException ex) {\n                    singletonObject = this.singletonObjects.get(beanName);\n                    if (singletonObject == null) {\n                        throw ex;\n                    }\n                } catch (BeanCreationException ex) {\n                    if (recordSuppressedExceptions) {\n                        for (Exception suppressedException : this.suppressedExceptions)\n                        {\n                            ex.addRelatedCause(suppressedException);\n                        }\n                    }\n                    throw ex;\n                } finally {\n                    if (recordSuppressedExceptions) {\n                        this.suppressedExceptions = null;\n                    }\n                    // 创建之后的处理工作：从正在创建的bean中删除当前的beanname，\n                    afterSingletonCreation(beanName);\n                }\n                // 创建成功加入缓存\n                if (newSingleton) {\n                    // 将结果记录至缓存并删除加载bean过程中所记录的各种辅助状态\n                    addSingleton(beanName, singletonObject);\n                }\n            }\n            return singletonObject;\n        }\n    }\n\n</code></pre>\n<p>其实这个过程并没有真正创建 bean，仅仅只是做了一部分准备和预处理步骤，真正获取单例 bean 的方法其实是由 <code>singletonFactory.getObject()</code> 这部分实现，而 singletonFactory 由回调方法产生。那么这个方法做了哪些准备呢？</p>\n<ol>\n<li>再次检查缓存是否已经加载过，如果已经加载了则直接返回，否则开始加载过程。</li>\n<li>调用 <code>beforeSingletonCreation()</code> 记录加载单例 bean 之前的加载状态，即前置处理。</li>\n<li>调用参数传递的 ObjectFactory 的 <code>getObject()</code> 实例化 bean。</li>\n<li>调用 <code>afterSingletonCreation()</code> 进行加载单例后的后置处理。</li>\n<li>将结果记录并加入值缓存中，同时删除加载 bean 过程中所记录的一些辅助状态。</li>\n</ol>\n<p>流程中涉及的三个方法 <code>beforeSingletonCreation()</code> 与 <code>afterSingletonCreation()</code> 在前面博客中分析过了，所以这里不再阐述了，我们看另外一个方法 <code>addSingleton()</code>。</p>\n<pre><code class=\"java\">    protected void addSingleton(String beanName, Object singletonObject) {\n        synchronized (this.singletonObjects) {\n            this.singletonObjects.put(beanName, singletonObject);\n            this.singletonFactories.remove(beanName);\n            this.earlySingletonObjects.remove(beanName);\n            this.registeredSingletons.add(beanName);\n        }\n    }\n</code></pre>\n<p>一个 put、一个 add、两个 remove。singletonObjects 单例 bean 的缓存，singletonFactories 单例 bean Factory 的缓存，earlySingletonObjects “早期”创建的单例 bean 的缓存，registeredSingletons 已经注册的单例缓存。</p>\n<p>加载了单例 bean 后，调用 <code>getObjectForBeanInstance()</code> 从 bean 实例中获取对象。该方法已经在前面博客详细分析了。</p>\n<p><strong>原型模式</strong></p>\n<pre><code class=\"java\">else if (mbd.isPrototype()) {\n    Object prototypeInstance = null;\n    try {\n        beforePrototypeCreation(beanName);\n        prototypeInstance = createBean(beanName, mbd, args);\n    }\n    finally {\n        afterPrototypeCreation(beanName);\n    }\n    bean = getObjectForBeanInstance(prototypeInstance, name,\n                                    beanName, mbd);\n}\n</code></pre>\n<p>原型模式的初始化过程很简单：直接创建一个新的实例就可以了。过程如下：</p>\n<ol>\n<li>调用<code>beforePrototypeCreation()</code> 记录加载原型模式 bean 之前的加载状态，即前置处理。</li>\n<li>调用 <code>createBean()</code> 创建一个 bean 实例对象。</li>\n<li>调用 <code>afterPrototypeCreation()</code> 进行加载原型模式 bean 后的后置处理。</li>\n<li>调用 <code>getObjectForBeanInstance()</code> 从 bean 实例中获取对象。</li>\n</ol>\n<p><strong>其他作用域</strong></p>\n<pre><code class=\"java\">String scopeName = mbd.getScope();\nfinal Scope scope = this.scopes.get(scopeName);\nif (scope == null) {\n    throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; \n                                    + scopeName + &quot;&#39;&quot;);\n }\ntry {\n    Object scopedInstance = scope.get(beanName, () -&gt; {\n        beforePrototypeCreation(beanName);\n        try {\n            return createBean(beanName, mbd, args);\n        }\n        finally {\n            afterPrototypeCreation(beanName);\n        }\n    });\n    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n\n}catch (IllegalStateException ex) {\n      //抛出异常代码省略\n}\n</code></pre>\n<p>核心流程和原型模式一样，只不过获取 bean 实例是由 <code>scope.get()</code> 实现，如下：</p>\n<pre><code class=\"java\">    public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) {\n       // 获取 scope 缓存\n        Map&lt;String, Object&gt; scope = this.threadScope.get();\n        Object scopedObject = scope.get(name);\n        if (scopedObject == null) {\n            scopedObject = objectFactory.getObject();\n            // 加入缓存\n            scope.put(name, scopedObject);\n        }\n        return scopedObject;\n    }\n</code></pre>\n<p>对于上面三个模块，其中最重要的有两个方法，一个是 <code>createBean()</code>、一个是 <code>getObjectForBeanInstance()</code>。这两个方法在上面三个模块都有调用，<code>createBean()</code> 后续详细说明，<code>getObjectForBeanInstance()</code> 在前面博客 中有详细讲解，这里再次阐述下（此段内容来自《Spring 源码深度解析》）：这个方法主要是验证以下我们得到的 bean 的正确性，其实就是检测当前 bean 是否是 FactoryBean 类型的 bean，如果是，那么需要调用该 bean 对应的 FactoryBean 实例的 <code>getObject()</code> 作为返回值。无论是从缓存中获得到的 bean 还是通过不同的 scope 策略加载的 bean 都只是最原始的 bean 状态，并不一定就是我们最终想要的 bean。举个例子，加入我们需要对工厂 bean 进行处理，那么这里得到的其实是工厂 bean 的初始状态，但是我们真正需要的是工厂 bean 中定义 factory-method 方法中返回的 bean，而 <code>getObjectForBeanInstance()</code> 就是完成这个工作的。</p>"},{"abbrlink":49,"title":"spring源码解析之 26深入分析Aware接口","author":"fengxiutianya","date":"2019-01-14T22:38:00.000Z","_content":"# spring源码解析之 26深入分析Aware接口\n\n我们经过前面的解析，已经知道了如何创建一个bean。但是在在上一篇博客bean的初始化中，说道bean的初始化initializeBean会做以下三件事，分别是：\n\n1. 激活 Aware 方法\n2. 后置处理器的应用\n3. 激活自定义的 init 方法\n\n虽然我们分析了这部分的源码，但是没有仔细分析，所以接下来三篇文章，会分别对这三个进行仔细分析。单独拿出来说的原因，是他们都是spring提供给我们可以使用的扩展机制。这里先来分析Aware接口\n<!-- more -->\n\nAware接口定义如下：\n\n```java\n/**\n * A marker superinterface indicating that a bean is eligible to be notified by the\n * Spring container of a particular framework object through a callback-style method.\n * The actual method signature is determined by individual subinterfaces but should\n * typically consist of just one void-returning method that accepts a single argument.\n *\n * <p>Note that merely implementing {@link Aware} provides no default functionality.\n * Rather, processing must be done explicitly, for example in a\n * {@link org.springframework.beans.factory.config.BeanPostProcessor}.\n * Refer to {@linkorg.springframework.context.support.ApplicationContextAwareProcessor}\n * for an example of processing specific {@code *Aware} interface callbacks.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n */\npublic interface Aware {\n\n}\n```\n\nAware 接口为 Spring 容器的核心接口，是一个具有标识作用的超级接口，实现了该接口的 bean 是具有被 Spring 容器通知的能力，通知的方式是采用回调的方式。\n\nAware 接口是一个空接口，实际的方法签名由各个子接口来确定，且该接口通常只会有一个接收单参数的 set 方法，该 set 方法的命名方式为 set + 去掉接口名中的 Aware 后缀，即 XxxAware 接口，则方法定义为 setXxx()，例如 BeanNameAware（setBeanName），ApplicationContextAware（setApplicationContext）。\n\n在上面的描述中也特别说明了如果仅仅是实现了Aware接口，是没有任何作用。而我们自己如果想实现一个类似于BeanNameAware的接口，就需要以下几个步骤\n\n1. 自定义一个接口实现Aware，\n2. 提供针对这个接口处理的类，类如定义一个bean实现BeanPostProcessor（这个会在下一篇中具体分析），然后在其中实现针对自己实现接口的处理。\n\nspring已经定义的Aware类型的接口，都已经实现了针对这些接口的处理，类如我们前面说到的三个接口，是在`invokeAwareMethods`中进行的处理，代码如下：\n\n```java\n private void invokeAwareMethods(final String beanName, final Object bean) {\n  if (bean instanceof Aware) {\n   if (bean instanceof BeanNameAware) {\n    ((BeanNameAware) bean).setBeanName(beanName);\n   }\n   if (bean instanceof BeanClassLoaderAware) {\n    ClassLoader bcl = getBeanClassLoader();\n    if (bcl != null) {\n     ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);\n    }\n   }\n   if (bean instanceof BeanFactoryAware) {\n    ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n   }\n  }\n }\n```\n\n下面就这三个接口来做一个简单的演示，先看各自的定义：\n\n```java\npublic interface BeanClassLoaderAware extends Aware {\n\n /**\n  * 将 BeanClassLoader 提供给 bean 实例回调\n  * 在 bean 属性填充之后、初始化回调之前回调，\n  * 例如InitializingBean的InitializingBean.afterPropertiesSet（）方法或自定义init方法\n  */\n void setBeanClassLoader(ClassLoader classLoader);\n}\n\npublic interface BeanFactoryAware extends Aware {\n    /**\n  * 将 BeanFactory 提供给 bean 实例回调\n  * 调用时机和 setBeanClassLoader 一样\n  */\n void setBeanFactory(BeanFactory beanFactory) throws BeansException;\n}\n\npublic interface BeanNameAware extends Aware {\n /**\n  * 在创建此 bean 的 bean工厂中设置 beanName\n  */\n void setBeanName(String name);\n}\n\npublic interface ApplicationContextAware extends Aware {\n /**\n  * 设置此 bean 对象的 ApplicationContext，通常，该方法用于初始化对象\n  */\n void setApplicationContext(ApplicationContext applicationContext) throws BeansException;\n\n}\n```\n\n下面简单演示下上面四个接口的使用方法：\n\n```java\npublic class MyApplicationAware implements BeanNameAware,BeanFactoryAware,BeanClassLoaderAware{\n\n    private String beanName;\n\n    private BeanFactory beanFactory;\n\n    private ClassLoader classLoader;\n\n    private ApplicationContext applicationContext;\n\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        System.out.println(\"调用了 BeanClassLoaderAware 的 setBeanClassLoader 方法\");\n\n        this.classLoader = classLoader;\n    }\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n        System.out.println(\"调用了 BeanFactoryAware 的 setBeanFactory 方法\");\n\n        this.beanFactory = beanFactory;\n    }\n\n    @Override\n    public void setBeanName(String name) {\n        System.out.println(\"调用了 BeanNameAware 的 setBeanName 方法\");\n\n        this.beanName = name;\n    }\n\n\n    public void display(){\n        System.out.println(\"beanName:\" + beanName);\n\n        System.out.println(\"是否为单例：\" + beanFactory.isSingleton(beanName));\n        \n    }\n}\n```\n\n测试方法如下:\n\n```java\npublic static void main(String[] args) {\n    ClassPathResource resource = new ClassPathResource(\"spring.xml\");\n    DefaultListableBeanFactory factory = new DefaultListableBeanFactory();\n    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\n    reader.loadBeanDefinitions(resource);\n\n    MyApplicationAware applicationAware = (MyApplicationAware) \n        factory.getBean(\"myApplicationAware\");\n    applicationAware.display();\n}\n```\n\n运行结果如下：\n\n```\n调用了 BeanNameAware 的 setBeanName 方法\n调用了 BeanClassLoaderAware 的 setBeanClassLoader 方法\n调用了 BeanFactoryAware 的 setBeanFactory 方法\nbeanName:myApplicationAware\n是否为单例:true\n```\n\n从这了我们基本上就可以 Aware 真正的含义是什么了？感知，其实是 Spring 容器在初始化主动检测当前 bean 是否实现了 Aware 接口，如果实现了则回调其 set 方法将相应的参数设置给该 bean ，这个时候该 bean 就从 Spring 容器中取得相应的资源。最后文章末尾列出部分常用的 Aware 子接口，便于日后查询：\n\n- LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ\n- BeanClassLoaderAware：加载Spring Bean的类加载器\n- BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI\n- ResourceLoaderAware：底层访问资源的加载器\n- BeanFactoryAware：声明BeanFactory\n- PortletConfigAware：PortletConfig\n- PortletContextAware：PortletContext\n- ServletConfigAware：ServletConfig\n- ServletContextAware：ServletContext\n- MessageSourceAware：国际化\n- ApplicationEventPublisherAware：应用事件\n- NotificationPublisherAware：JMX通知\n- BeanNameAware：声明Spring Bean的名字\n\n这里我们已经仔细分析了Aware接口，但是如果我们自己想实现一个自定义的Aware接口，则需要结合下一篇文章将要介绍的BeanPostProcessor，接下来我们一起来仔细分析这个接口。","source":"_posts/spring 源码分析/spring/spring源码解析之 26深入分析Aware接口.md","raw":"abbrlink: 49\ntitle: spring源码解析之 26深入分析Aware接口\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-15 06:38:00\n---\n# spring源码解析之 26深入分析Aware接口\n\n我们经过前面的解析，已经知道了如何创建一个bean。但是在在上一篇博客bean的初始化中，说道bean的初始化initializeBean会做以下三件事，分别是：\n\n1. 激活 Aware 方法\n2. 后置处理器的应用\n3. 激活自定义的 init 方法\n\n虽然我们分析了这部分的源码，但是没有仔细分析，所以接下来三篇文章，会分别对这三个进行仔细分析。单独拿出来说的原因，是他们都是spring提供给我们可以使用的扩展机制。这里先来分析Aware接口\n<!-- more -->\n\nAware接口定义如下：\n\n```java\n/**\n * A marker superinterface indicating that a bean is eligible to be notified by the\n * Spring container of a particular framework object through a callback-style method.\n * The actual method signature is determined by individual subinterfaces but should\n * typically consist of just one void-returning method that accepts a single argument.\n *\n * <p>Note that merely implementing {@link Aware} provides no default functionality.\n * Rather, processing must be done explicitly, for example in a\n * {@link org.springframework.beans.factory.config.BeanPostProcessor}.\n * Refer to {@linkorg.springframework.context.support.ApplicationContextAwareProcessor}\n * for an example of processing specific {@code *Aware} interface callbacks.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n */\npublic interface Aware {\n\n}\n```\n\nAware 接口为 Spring 容器的核心接口，是一个具有标识作用的超级接口，实现了该接口的 bean 是具有被 Spring 容器通知的能力，通知的方式是采用回调的方式。\n\nAware 接口是一个空接口，实际的方法签名由各个子接口来确定，且该接口通常只会有一个接收单参数的 set 方法，该 set 方法的命名方式为 set + 去掉接口名中的 Aware 后缀，即 XxxAware 接口，则方法定义为 setXxx()，例如 BeanNameAware（setBeanName），ApplicationContextAware（setApplicationContext）。\n\n在上面的描述中也特别说明了如果仅仅是实现了Aware接口，是没有任何作用。而我们自己如果想实现一个类似于BeanNameAware的接口，就需要以下几个步骤\n\n1. 自定义一个接口实现Aware，\n2. 提供针对这个接口处理的类，类如定义一个bean实现BeanPostProcessor（这个会在下一篇中具体分析），然后在其中实现针对自己实现接口的处理。\n\nspring已经定义的Aware类型的接口，都已经实现了针对这些接口的处理，类如我们前面说到的三个接口，是在`invokeAwareMethods`中进行的处理，代码如下：\n\n```java\n private void invokeAwareMethods(final String beanName, final Object bean) {\n  if (bean instanceof Aware) {\n   if (bean instanceof BeanNameAware) {\n    ((BeanNameAware) bean).setBeanName(beanName);\n   }\n   if (bean instanceof BeanClassLoaderAware) {\n    ClassLoader bcl = getBeanClassLoader();\n    if (bcl != null) {\n     ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);\n    }\n   }\n   if (bean instanceof BeanFactoryAware) {\n    ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n   }\n  }\n }\n```\n\n下面就这三个接口来做一个简单的演示，先看各自的定义：\n\n```java\npublic interface BeanClassLoaderAware extends Aware {\n\n /**\n  * 将 BeanClassLoader 提供给 bean 实例回调\n  * 在 bean 属性填充之后、初始化回调之前回调，\n  * 例如InitializingBean的InitializingBean.afterPropertiesSet（）方法或自定义init方法\n  */\n void setBeanClassLoader(ClassLoader classLoader);\n}\n\npublic interface BeanFactoryAware extends Aware {\n    /**\n  * 将 BeanFactory 提供给 bean 实例回调\n  * 调用时机和 setBeanClassLoader 一样\n  */\n void setBeanFactory(BeanFactory beanFactory) throws BeansException;\n}\n\npublic interface BeanNameAware extends Aware {\n /**\n  * 在创建此 bean 的 bean工厂中设置 beanName\n  */\n void setBeanName(String name);\n}\n\npublic interface ApplicationContextAware extends Aware {\n /**\n  * 设置此 bean 对象的 ApplicationContext，通常，该方法用于初始化对象\n  */\n void setApplicationContext(ApplicationContext applicationContext) throws BeansException;\n\n}\n```\n\n下面简单演示下上面四个接口的使用方法：\n\n```java\npublic class MyApplicationAware implements BeanNameAware,BeanFactoryAware,BeanClassLoaderAware{\n\n    private String beanName;\n\n    private BeanFactory beanFactory;\n\n    private ClassLoader classLoader;\n\n    private ApplicationContext applicationContext;\n\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        System.out.println(\"调用了 BeanClassLoaderAware 的 setBeanClassLoader 方法\");\n\n        this.classLoader = classLoader;\n    }\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n        System.out.println(\"调用了 BeanFactoryAware 的 setBeanFactory 方法\");\n\n        this.beanFactory = beanFactory;\n    }\n\n    @Override\n    public void setBeanName(String name) {\n        System.out.println(\"调用了 BeanNameAware 的 setBeanName 方法\");\n\n        this.beanName = name;\n    }\n\n\n    public void display(){\n        System.out.println(\"beanName:\" + beanName);\n\n        System.out.println(\"是否为单例：\" + beanFactory.isSingleton(beanName));\n        \n    }\n}\n```\n\n测试方法如下:\n\n```java\npublic static void main(String[] args) {\n    ClassPathResource resource = new ClassPathResource(\"spring.xml\");\n    DefaultListableBeanFactory factory = new DefaultListableBeanFactory();\n    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\n    reader.loadBeanDefinitions(resource);\n\n    MyApplicationAware applicationAware = (MyApplicationAware) \n        factory.getBean(\"myApplicationAware\");\n    applicationAware.display();\n}\n```\n\n运行结果如下：\n\n```\n调用了 BeanNameAware 的 setBeanName 方法\n调用了 BeanClassLoaderAware 的 setBeanClassLoader 方法\n调用了 BeanFactoryAware 的 setBeanFactory 方法\nbeanName:myApplicationAware\n是否为单例:true\n```\n\n从这了我们基本上就可以 Aware 真正的含义是什么了？感知，其实是 Spring 容器在初始化主动检测当前 bean 是否实现了 Aware 接口，如果实现了则回调其 set 方法将相应的参数设置给该 bean ，这个时候该 bean 就从 Spring 容器中取得相应的资源。最后文章末尾列出部分常用的 Aware 子接口，便于日后查询：\n\n- LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ\n- BeanClassLoaderAware：加载Spring Bean的类加载器\n- BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI\n- ResourceLoaderAware：底层访问资源的加载器\n- BeanFactoryAware：声明BeanFactory\n- PortletConfigAware：PortletConfig\n- PortletContextAware：PortletContext\n- ServletConfigAware：ServletConfig\n- ServletContextAware：ServletContext\n- MessageSourceAware：国际化\n- ApplicationEventPublisherAware：应用事件\n- NotificationPublisherAware：JMX通知\n- BeanNameAware：声明Spring Bean的名字\n\n这里我们已经仔细分析了Aware接口，但是如果我们自己想实现一个自定义的Aware接口，则需要结合下一篇文章将要介绍的BeanPostProcessor，接下来我们一起来仔细分析这个接口。","slug":"spring 源码分析/spring/spring源码解析之 26深入分析Aware接口","published":1,"updated":"2019-01-16T08:34:26.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovtk003h9q1uhdojyvrn","content":"<h1 id=\"spring源码解析之-26深入分析Aware接口\"><a href=\"#spring源码解析之-26深入分析Aware接口\" class=\"headerlink\" title=\"spring源码解析之 26深入分析Aware接口\"></a>spring源码解析之 26深入分析Aware接口</h1><p>我们经过前面的解析，已经知道了如何创建一个bean。但是在在上一篇博客bean的初始化中，说道bean的初始化initializeBean会做以下三件事，分别是：</p>\n<ol>\n<li>激活 Aware 方法</li>\n<li>后置处理器的应用</li>\n<li>激活自定义的 init 方法</li>\n</ol>\n<p>虽然我们分析了这部分的源码，但是没有仔细分析，所以接下来三篇文章，会分别对这三个进行仔细分析。单独拿出来说的原因，是他们都是spring提供给我们可以使用的扩展机制。这里先来分析Aware接口<br><a id=\"more\"></a></p>\n<p>Aware接口定义如下：</p>\n<pre><code class=\"java\">/**\n * A marker superinterface indicating that a bean is eligible to be notified by the\n * Spring container of a particular framework object through a callback-style method.\n * The actual method signature is determined by individual subinterfaces but should\n * typically consist of just one void-returning method that accepts a single argument.\n *\n * &lt;p&gt;Note that merely implementing {@link Aware} provides no default functionality.\n * Rather, processing must be done explicitly, for example in a\n * {@link org.springframework.beans.factory.config.BeanPostProcessor}.\n * Refer to {@linkorg.springframework.context.support.ApplicationContextAwareProcessor}\n * for an example of processing specific {@code *Aware} interface callbacks.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n */\npublic interface Aware {\n\n}\n</code></pre>\n<p>Aware 接口为 Spring 容器的核心接口，是一个具有标识作用的超级接口，实现了该接口的 bean 是具有被 Spring 容器通知的能力，通知的方式是采用回调的方式。</p>\n<p>Aware 接口是一个空接口，实际的方法签名由各个子接口来确定，且该接口通常只会有一个接收单参数的 set 方法，该 set 方法的命名方式为 set + 去掉接口名中的 Aware 后缀，即 XxxAware 接口，则方法定义为 setXxx()，例如 BeanNameAware（setBeanName），ApplicationContextAware（setApplicationContext）。</p>\n<p>在上面的描述中也特别说明了如果仅仅是实现了Aware接口，是没有任何作用。而我们自己如果想实现一个类似于BeanNameAware的接口，就需要以下几个步骤</p>\n<ol>\n<li>自定义一个接口实现Aware，</li>\n<li>提供针对这个接口处理的类，类如定义一个bean实现BeanPostProcessor（这个会在下一篇中具体分析），然后在其中实现针对自己实现接口的处理。</li>\n</ol>\n<p>spring已经定义的Aware类型的接口，都已经实现了针对这些接口的处理，类如我们前面说到的三个接口，是在<code>invokeAwareMethods</code>中进行的处理，代码如下：</p>\n<pre><code class=\"java\"> private void invokeAwareMethods(final String beanName, final Object bean) {\n  if (bean instanceof Aware) {\n   if (bean instanceof BeanNameAware) {\n    ((BeanNameAware) bean).setBeanName(beanName);\n   }\n   if (bean instanceof BeanClassLoaderAware) {\n    ClassLoader bcl = getBeanClassLoader();\n    if (bcl != null) {\n     ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);\n    }\n   }\n   if (bean instanceof BeanFactoryAware) {\n    ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n   }\n  }\n }\n</code></pre>\n<p>下面就这三个接口来做一个简单的演示，先看各自的定义：</p>\n<pre><code class=\"java\">public interface BeanClassLoaderAware extends Aware {\n\n /**\n  * 将 BeanClassLoader 提供给 bean 实例回调\n  * 在 bean 属性填充之后、初始化回调之前回调，\n  * 例如InitializingBean的InitializingBean.afterPropertiesSet（）方法或自定义init方法\n  */\n void setBeanClassLoader(ClassLoader classLoader);\n}\n\npublic interface BeanFactoryAware extends Aware {\n    /**\n  * 将 BeanFactory 提供给 bean 实例回调\n  * 调用时机和 setBeanClassLoader 一样\n  */\n void setBeanFactory(BeanFactory beanFactory) throws BeansException;\n}\n\npublic interface BeanNameAware extends Aware {\n /**\n  * 在创建此 bean 的 bean工厂中设置 beanName\n  */\n void setBeanName(String name);\n}\n\npublic interface ApplicationContextAware extends Aware {\n /**\n  * 设置此 bean 对象的 ApplicationContext，通常，该方法用于初始化对象\n  */\n void setApplicationContext(ApplicationContext applicationContext) throws BeansException;\n\n}\n</code></pre>\n<p>下面简单演示下上面四个接口的使用方法：</p>\n<pre><code class=\"java\">public class MyApplicationAware implements BeanNameAware,BeanFactoryAware,BeanClassLoaderAware{\n\n    private String beanName;\n\n    private BeanFactory beanFactory;\n\n    private ClassLoader classLoader;\n\n    private ApplicationContext applicationContext;\n\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        System.out.println(&quot;调用了 BeanClassLoaderAware 的 setBeanClassLoader 方法&quot;);\n\n        this.classLoader = classLoader;\n    }\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n        System.out.println(&quot;调用了 BeanFactoryAware 的 setBeanFactory 方法&quot;);\n\n        this.beanFactory = beanFactory;\n    }\n\n    @Override\n    public void setBeanName(String name) {\n        System.out.println(&quot;调用了 BeanNameAware 的 setBeanName 方法&quot;);\n\n        this.beanName = name;\n    }\n\n\n    public void display(){\n        System.out.println(&quot;beanName:&quot; + beanName);\n\n        System.out.println(&quot;是否为单例：&quot; + beanFactory.isSingleton(beanName));\n\n    }\n}\n</code></pre>\n<p>测试方法如下:</p>\n<pre><code class=\"java\">public static void main(String[] args) {\n    ClassPathResource resource = new ClassPathResource(&quot;spring.xml&quot;);\n    DefaultListableBeanFactory factory = new DefaultListableBeanFactory();\n    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\n    reader.loadBeanDefinitions(resource);\n\n    MyApplicationAware applicationAware = (MyApplicationAware) \n        factory.getBean(&quot;myApplicationAware&quot;);\n    applicationAware.display();\n}\n</code></pre>\n<p>运行结果如下：</p>\n<pre><code>调用了 BeanNameAware 的 setBeanName 方法\n调用了 BeanClassLoaderAware 的 setBeanClassLoader 方法\n调用了 BeanFactoryAware 的 setBeanFactory 方法\nbeanName:myApplicationAware\n是否为单例:true\n</code></pre><p>从这了我们基本上就可以 Aware 真正的含义是什么了？感知，其实是 Spring 容器在初始化主动检测当前 bean 是否实现了 Aware 接口，如果实现了则回调其 set 方法将相应的参数设置给该 bean ，这个时候该 bean 就从 Spring 容器中取得相应的资源。最后文章末尾列出部分常用的 Aware 子接口，便于日后查询：</p>\n<ul>\n<li>LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ</li>\n<li>BeanClassLoaderAware：加载Spring Bean的类加载器</li>\n<li>BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI</li>\n<li>ResourceLoaderAware：底层访问资源的加载器</li>\n<li>BeanFactoryAware：声明BeanFactory</li>\n<li>PortletConfigAware：PortletConfig</li>\n<li>PortletContextAware：PortletContext</li>\n<li>ServletConfigAware：ServletConfig</li>\n<li>ServletContextAware：ServletContext</li>\n<li>MessageSourceAware：国际化</li>\n<li>ApplicationEventPublisherAware：应用事件</li>\n<li>NotificationPublisherAware：JMX通知</li>\n<li>BeanNameAware：声明Spring Bean的名字</li>\n</ul>\n<p>这里我们已经仔细分析了Aware接口，但是如果我们自己想实现一个自定义的Aware接口，则需要结合下一篇文章将要介绍的BeanPostProcessor，接下来我们一起来仔细分析这个接口。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-26深入分析Aware接口\"><a href=\"#spring源码解析之-26深入分析Aware接口\" class=\"headerlink\" title=\"spring源码解析之 26深入分析Aware接口\"></a>spring源码解析之 26深入分析Aware接口</h1><p>我们经过前面的解析，已经知道了如何创建一个bean。但是在在上一篇博客bean的初始化中，说道bean的初始化initializeBean会做以下三件事，分别是：</p>\n<ol>\n<li>激活 Aware 方法</li>\n<li>后置处理器的应用</li>\n<li>激活自定义的 init 方法</li>\n</ol>\n<p>虽然我们分析了这部分的源码，但是没有仔细分析，所以接下来三篇文章，会分别对这三个进行仔细分析。单独拿出来说的原因，是他们都是spring提供给我们可以使用的扩展机制。这里先来分析Aware接口<br>","more":"</p>\n<p>Aware接口定义如下：</p>\n<pre><code class=\"java\">/**\n * A marker superinterface indicating that a bean is eligible to be notified by the\n * Spring container of a particular framework object through a callback-style method.\n * The actual method signature is determined by individual subinterfaces but should\n * typically consist of just one void-returning method that accepts a single argument.\n *\n * &lt;p&gt;Note that merely implementing {@link Aware} provides no default functionality.\n * Rather, processing must be done explicitly, for example in a\n * {@link org.springframework.beans.factory.config.BeanPostProcessor}.\n * Refer to {@linkorg.springframework.context.support.ApplicationContextAwareProcessor}\n * for an example of processing specific {@code *Aware} interface callbacks.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n */\npublic interface Aware {\n\n}\n</code></pre>\n<p>Aware 接口为 Spring 容器的核心接口，是一个具有标识作用的超级接口，实现了该接口的 bean 是具有被 Spring 容器通知的能力，通知的方式是采用回调的方式。</p>\n<p>Aware 接口是一个空接口，实际的方法签名由各个子接口来确定，且该接口通常只会有一个接收单参数的 set 方法，该 set 方法的命名方式为 set + 去掉接口名中的 Aware 后缀，即 XxxAware 接口，则方法定义为 setXxx()，例如 BeanNameAware（setBeanName），ApplicationContextAware（setApplicationContext）。</p>\n<p>在上面的描述中也特别说明了如果仅仅是实现了Aware接口，是没有任何作用。而我们自己如果想实现一个类似于BeanNameAware的接口，就需要以下几个步骤</p>\n<ol>\n<li>自定义一个接口实现Aware，</li>\n<li>提供针对这个接口处理的类，类如定义一个bean实现BeanPostProcessor（这个会在下一篇中具体分析），然后在其中实现针对自己实现接口的处理。</li>\n</ol>\n<p>spring已经定义的Aware类型的接口，都已经实现了针对这些接口的处理，类如我们前面说到的三个接口，是在<code>invokeAwareMethods</code>中进行的处理，代码如下：</p>\n<pre><code class=\"java\"> private void invokeAwareMethods(final String beanName, final Object bean) {\n  if (bean instanceof Aware) {\n   if (bean instanceof BeanNameAware) {\n    ((BeanNameAware) bean).setBeanName(beanName);\n   }\n   if (bean instanceof BeanClassLoaderAware) {\n    ClassLoader bcl = getBeanClassLoader();\n    if (bcl != null) {\n     ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);\n    }\n   }\n   if (bean instanceof BeanFactoryAware) {\n    ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n   }\n  }\n }\n</code></pre>\n<p>下面就这三个接口来做一个简单的演示，先看各自的定义：</p>\n<pre><code class=\"java\">public interface BeanClassLoaderAware extends Aware {\n\n /**\n  * 将 BeanClassLoader 提供给 bean 实例回调\n  * 在 bean 属性填充之后、初始化回调之前回调，\n  * 例如InitializingBean的InitializingBean.afterPropertiesSet（）方法或自定义init方法\n  */\n void setBeanClassLoader(ClassLoader classLoader);\n}\n\npublic interface BeanFactoryAware extends Aware {\n    /**\n  * 将 BeanFactory 提供给 bean 实例回调\n  * 调用时机和 setBeanClassLoader 一样\n  */\n void setBeanFactory(BeanFactory beanFactory) throws BeansException;\n}\n\npublic interface BeanNameAware extends Aware {\n /**\n  * 在创建此 bean 的 bean工厂中设置 beanName\n  */\n void setBeanName(String name);\n}\n\npublic interface ApplicationContextAware extends Aware {\n /**\n  * 设置此 bean 对象的 ApplicationContext，通常，该方法用于初始化对象\n  */\n void setApplicationContext(ApplicationContext applicationContext) throws BeansException;\n\n}\n</code></pre>\n<p>下面简单演示下上面四个接口的使用方法：</p>\n<pre><code class=\"java\">public class MyApplicationAware implements BeanNameAware,BeanFactoryAware,BeanClassLoaderAware{\n\n    private String beanName;\n\n    private BeanFactory beanFactory;\n\n    private ClassLoader classLoader;\n\n    private ApplicationContext applicationContext;\n\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        System.out.println(&quot;调用了 BeanClassLoaderAware 的 setBeanClassLoader 方法&quot;);\n\n        this.classLoader = classLoader;\n    }\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n        System.out.println(&quot;调用了 BeanFactoryAware 的 setBeanFactory 方法&quot;);\n\n        this.beanFactory = beanFactory;\n    }\n\n    @Override\n    public void setBeanName(String name) {\n        System.out.println(&quot;调用了 BeanNameAware 的 setBeanName 方法&quot;);\n\n        this.beanName = name;\n    }\n\n\n    public void display(){\n        System.out.println(&quot;beanName:&quot; + beanName);\n\n        System.out.println(&quot;是否为单例：&quot; + beanFactory.isSingleton(beanName));\n\n    }\n}\n</code></pre>\n<p>测试方法如下:</p>\n<pre><code class=\"java\">public static void main(String[] args) {\n    ClassPathResource resource = new ClassPathResource(&quot;spring.xml&quot;);\n    DefaultListableBeanFactory factory = new DefaultListableBeanFactory();\n    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\n    reader.loadBeanDefinitions(resource);\n\n    MyApplicationAware applicationAware = (MyApplicationAware) \n        factory.getBean(&quot;myApplicationAware&quot;);\n    applicationAware.display();\n}\n</code></pre>\n<p>运行结果如下：</p>\n<pre><code>调用了 BeanNameAware 的 setBeanName 方法\n调用了 BeanClassLoaderAware 的 setBeanClassLoader 方法\n调用了 BeanFactoryAware 的 setBeanFactory 方法\nbeanName:myApplicationAware\n是否为单例:true\n</code></pre><p>从这了我们基本上就可以 Aware 真正的含义是什么了？感知，其实是 Spring 容器在初始化主动检测当前 bean 是否实现了 Aware 接口，如果实现了则回调其 set 方法将相应的参数设置给该 bean ，这个时候该 bean 就从 Spring 容器中取得相应的资源。最后文章末尾列出部分常用的 Aware 子接口，便于日后查询：</p>\n<ul>\n<li>LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ</li>\n<li>BeanClassLoaderAware：加载Spring Bean的类加载器</li>\n<li>BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI</li>\n<li>ResourceLoaderAware：底层访问资源的加载器</li>\n<li>BeanFactoryAware：声明BeanFactory</li>\n<li>PortletConfigAware：PortletConfig</li>\n<li>PortletContextAware：PortletContext</li>\n<li>ServletConfigAware：ServletConfig</li>\n<li>ServletContextAware：ServletContext</li>\n<li>MessageSourceAware：国际化</li>\n<li>ApplicationEventPublisherAware：应用事件</li>\n<li>NotificationPublisherAware：JMX通知</li>\n<li>BeanNameAware：声明Spring Bean的名字</li>\n</ul>\n<p>这里我们已经仔细分析了Aware接口，但是如果我们自己想实现一个自定义的Aware接口，则需要结合下一篇文章将要介绍的BeanPostProcessor，接下来我们一起来仔细分析这个接口。</p>"},{"abbrlink":47,"title":"spring源码解析之 28深入分析InitializingBean 接口和 init-method","author":"fengxiutianya","date":"2019-01-14T22:40:00.000Z","_content":"# spring源码解析之 28深入分析InitializingBean 接口和 init-method\n\n 已经分析了 Aware 接口族 和 BeanPostProcessor 接口，这篇分析 InitializingBean 接口和 init-method 方法。\n\n## InitializingBean\n\nSpring 的 InitializingBean 接口为 bean 提供了定义初始化方法的方式，它仅包含了一个方法：`afterPropertiesSet()`。\n<!-- more -->\n\n```JAVA\npublic interface InitializingBean {\n\n \t/**\n    * 该方法在 BeanFactory 设置完了所有属性之后被调用\n    * 该方法允许 bean 实例设置了所有 bean 属性时执行初始化工作，如果该过程出现了错误则需要抛出异常\n   */\n   void afterPropertiesSet() throws Exception;\n}\n```\n\nSpring 在完成实例化后，设置完所有属性，进行 “Aware 接口” 和 “BeanPostProcessor 前置处理”之后，会接着检测当前 bean 对象是否实现了 InitializingBean 接口，如果是，则会调用其 `afterPropertiesSet()` 进一步调整 bean 实例对象的状态。\n\n```JAVA\npublic class InitializingBeanTest implements InitializingBean {\n\n    private String name;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        System.out.println(\"InitializingBeanTest initializing...\");\n\n        this.name = \"chenssy 2 号\";\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n// 配置项\n<bean id=\"initializingBeanTest\" class=\"org.springframework.core.test.InitializingBeanTest\">\n    <property name=\"name\" value=\"chenssy 1 号\"/>\n</bean>\n\n// 测试代码\nInitializingBeanTest test = (InitializingBeanTest) factory.getBean(\"initializingBeanTest\");\nSystem.out.println(\"name ：\" + test.getName());\n```\n\n执行结果：\n\n![upload successful](/images/pasted-22.png)\n\n在这个示例中改变了 InitializingBeanTest 示例的 name 属性，也就是说 在 `afterPropertiesSet()` 中我们是可以改变 bean 的属性的，这相当于 Spring 容器又给我们提供了一种可以改变 bean 实例对象的方法。\n\n上面提到 bean 初始化阶段（`initializeBean()` ） Spring 容器会主动检查当前 bean 是否已经实现了 InitializingBean 接口，如果实现了则会掉用其 `afterPropertiesSet()` ,这个主动检查、调用的动作是由 `invokeInitMethods()` 来完成的。\n\n```JAVA\n    protected void invokeInitMethods(String beanName, final Object bean,\n    \t\t@Nullable RootBeanDefinition mbd)\n            throws Throwable {\n\n        // 是否实现 InitializingBean\n        // 如果实现了 InitializingBean 接口，则只掉调用bean的 afterPropertiesSet()\n        boolean isInitializingBean = (bean instanceof InitializingBean);\n        if (isInitializingBean && (mbd == null || \n                          !mbd.isExternallyManagedInitMethod(\"afterPropertiesSet\"))) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Invoking afterPropertiesSet() on bean with name '\"\n                             + beanName + \"'\");\n            }\n            if (System.getSecurityManager() != null) {\n                try {\n                    AccessController.doPrivileged((PrivilegedExceptionAction<Object>) \n                                                  () -> {\n                        ((InitializingBean) bean).afterPropertiesSet();\n                        return null;\n                    }, getAccessControlContext());\n                }\n                catch (PrivilegedActionException pae) {\n                    throw pae.getException();\n                }\n            }\n            else {\n                // 直接调用 afterPropertiesSet()\n                ((InitializingBean) bean).afterPropertiesSet();\n            }\n        }\n\n        if (mbd != null && bean.getClass() != NullBean.class) {\n            // 判断是否指定了 init-method()，\n            // 如果指定了 init-method()，则再调用制定的init-method\n            String initMethodName = mbd.getInitMethodName();\n            if (StringUtils.hasLength(initMethodName) &&\n                    !(isInitializingBean && \n                      \t\"afterPropertiesSet\".equals(initMethodName)) &&\n                    !mbd.isExternallyManagedInitMethod(initMethodName)) {\n                // 利用反射机制执行\n                invokeCustomInitMethod(beanName, bean, mbd);\n            }\n        }\n    }\n```\n\n首先检测当前 bean 是否实现了 InitializingBean 接口，如果实现了则调用其 `afterPropertiesSet()`，然后再检查是否也指定了 `init-method()`，如果指定了则通过反射机制调用指定的 `init-method()`。\n\n虽然该接口为 Spring 容器的扩展性立下了汗马功劳，但是如果真的让我们的业务对象来实现这个接口就显得不是那么的友好了，Spring 的一个核心理念就是无侵入性，但是如果我们业务类实现这个接口就显得 Spring 容器具有侵入性了。所以 Spring 还提供了另外一种实现的方式：init-method 方法\n\n## init-method()\n\n在分析分析 `<bean>` 标签解析过程中我们提到了有关于 `init-method` 属性，该属性用于在 bean 初始化时指定执行方法，可以用来替代实现 InitializingBean 接口。\n\n```JAVA\npublic class InitializingBeanTest {\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setOtherName(){\n        System.out.println(\"InitializingBeanTest setOtherName...\");\n\n        this.name = \"chenssy 3 号\";\n    }\n}\n\n// 配置文件\n<bean id=\"initializingBeanTest\" class=\"org.springframework.core.test.InitializingBeanTest\"\n        init-method=\"setOtherName\">\n    <property name=\"name\" value=\"chenssy 1 号\"/>\n</bean>\n```\n\n执行结果:\n\n![upload successful](/images/pasted-20.png)\n\n完全可以达到和 InitializingBean 一样的效果，而且在代码中我们没有看到丝毫 Spring 侵入的现象。所以通过 init-method 我们可以使用业务对象中定义的任何方法来实现 bean 实例对象的初始化定制化，而不再受制于 InitializingBean的 `afterPropertiesSet()`。同时我们可以使用 `<beans>` 标签的 `default-init-method` 属性来统一指定初始化方法，这样就省了需要在每个 `<bean>` 标签中都设置 `init-method` 这样的繁琐工作了。比如在 `default-init-method` 规定所有初始化操作全部以 `initBean()` 命名。如下：\n\n![upload successful](/images/pasted-21.png)\n\n从 `invokeInitMethods()` 中，我们知道 `init-method` 指定的方法会在 `afterPropertiesSet()` 之后执行，如果 `afterPropertiesSet()` 中出现了异常，则 `init-method` 是不会执行的，而且由于 `init-method` 采用的是反射执行的方式，所以 `afterPropertiesSet()` 的执行效率一般会高些，但是并不能排除我们要优先使用 `init-method`，主要是因为它消除了 bean 对 Spring 的依赖，Spring 没有侵入到我们业务代码，这样会更加符合 Spring 的理念。诚然，`init-method` 是基于 xml 配置文件的，就目前而言，我们的工程几乎都摒弃了配置，而采用注释的方式，那么 `@PreDestory` 可能适合你，当然这个注解我们后面分析。\n\n至此，InitializingBean 和 init-method 已经分析完毕了，对于DisposableBean 和 destory-method，他们和 init 相似，这里就不做阐述了。","source":"_posts/spring 源码分析/spring/spring源码解析之 28深入分析InitializingBean 接口和 init-method.md","raw":"abbrlink: 47\ntitle: spring源码解析之 28深入分析InitializingBean 接口和 init-method\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-15 06:40:00\n---\n# spring源码解析之 28深入分析InitializingBean 接口和 init-method\n\n 已经分析了 Aware 接口族 和 BeanPostProcessor 接口，这篇分析 InitializingBean 接口和 init-method 方法。\n\n## InitializingBean\n\nSpring 的 InitializingBean 接口为 bean 提供了定义初始化方法的方式，它仅包含了一个方法：`afterPropertiesSet()`。\n<!-- more -->\n\n```JAVA\npublic interface InitializingBean {\n\n \t/**\n    * 该方法在 BeanFactory 设置完了所有属性之后被调用\n    * 该方法允许 bean 实例设置了所有 bean 属性时执行初始化工作，如果该过程出现了错误则需要抛出异常\n   */\n   void afterPropertiesSet() throws Exception;\n}\n```\n\nSpring 在完成实例化后，设置完所有属性，进行 “Aware 接口” 和 “BeanPostProcessor 前置处理”之后，会接着检测当前 bean 对象是否实现了 InitializingBean 接口，如果是，则会调用其 `afterPropertiesSet()` 进一步调整 bean 实例对象的状态。\n\n```JAVA\npublic class InitializingBeanTest implements InitializingBean {\n\n    private String name;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        System.out.println(\"InitializingBeanTest initializing...\");\n\n        this.name = \"chenssy 2 号\";\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n// 配置项\n<bean id=\"initializingBeanTest\" class=\"org.springframework.core.test.InitializingBeanTest\">\n    <property name=\"name\" value=\"chenssy 1 号\"/>\n</bean>\n\n// 测试代码\nInitializingBeanTest test = (InitializingBeanTest) factory.getBean(\"initializingBeanTest\");\nSystem.out.println(\"name ：\" + test.getName());\n```\n\n执行结果：\n\n![upload successful](/images/pasted-22.png)\n\n在这个示例中改变了 InitializingBeanTest 示例的 name 属性，也就是说 在 `afterPropertiesSet()` 中我们是可以改变 bean 的属性的，这相当于 Spring 容器又给我们提供了一种可以改变 bean 实例对象的方法。\n\n上面提到 bean 初始化阶段（`initializeBean()` ） Spring 容器会主动检查当前 bean 是否已经实现了 InitializingBean 接口，如果实现了则会掉用其 `afterPropertiesSet()` ,这个主动检查、调用的动作是由 `invokeInitMethods()` 来完成的。\n\n```JAVA\n    protected void invokeInitMethods(String beanName, final Object bean,\n    \t\t@Nullable RootBeanDefinition mbd)\n            throws Throwable {\n\n        // 是否实现 InitializingBean\n        // 如果实现了 InitializingBean 接口，则只掉调用bean的 afterPropertiesSet()\n        boolean isInitializingBean = (bean instanceof InitializingBean);\n        if (isInitializingBean && (mbd == null || \n                          !mbd.isExternallyManagedInitMethod(\"afterPropertiesSet\"))) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Invoking afterPropertiesSet() on bean with name '\"\n                             + beanName + \"'\");\n            }\n            if (System.getSecurityManager() != null) {\n                try {\n                    AccessController.doPrivileged((PrivilegedExceptionAction<Object>) \n                                                  () -> {\n                        ((InitializingBean) bean).afterPropertiesSet();\n                        return null;\n                    }, getAccessControlContext());\n                }\n                catch (PrivilegedActionException pae) {\n                    throw pae.getException();\n                }\n            }\n            else {\n                // 直接调用 afterPropertiesSet()\n                ((InitializingBean) bean).afterPropertiesSet();\n            }\n        }\n\n        if (mbd != null && bean.getClass() != NullBean.class) {\n            // 判断是否指定了 init-method()，\n            // 如果指定了 init-method()，则再调用制定的init-method\n            String initMethodName = mbd.getInitMethodName();\n            if (StringUtils.hasLength(initMethodName) &&\n                    !(isInitializingBean && \n                      \t\"afterPropertiesSet\".equals(initMethodName)) &&\n                    !mbd.isExternallyManagedInitMethod(initMethodName)) {\n                // 利用反射机制执行\n                invokeCustomInitMethod(beanName, bean, mbd);\n            }\n        }\n    }\n```\n\n首先检测当前 bean 是否实现了 InitializingBean 接口，如果实现了则调用其 `afterPropertiesSet()`，然后再检查是否也指定了 `init-method()`，如果指定了则通过反射机制调用指定的 `init-method()`。\n\n虽然该接口为 Spring 容器的扩展性立下了汗马功劳，但是如果真的让我们的业务对象来实现这个接口就显得不是那么的友好了，Spring 的一个核心理念就是无侵入性，但是如果我们业务类实现这个接口就显得 Spring 容器具有侵入性了。所以 Spring 还提供了另外一种实现的方式：init-method 方法\n\n## init-method()\n\n在分析分析 `<bean>` 标签解析过程中我们提到了有关于 `init-method` 属性，该属性用于在 bean 初始化时指定执行方法，可以用来替代实现 InitializingBean 接口。\n\n```JAVA\npublic class InitializingBeanTest {\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setOtherName(){\n        System.out.println(\"InitializingBeanTest setOtherName...\");\n\n        this.name = \"chenssy 3 号\";\n    }\n}\n\n// 配置文件\n<bean id=\"initializingBeanTest\" class=\"org.springframework.core.test.InitializingBeanTest\"\n        init-method=\"setOtherName\">\n    <property name=\"name\" value=\"chenssy 1 号\"/>\n</bean>\n```\n\n执行结果:\n\n![upload successful](/images/pasted-20.png)\n\n完全可以达到和 InitializingBean 一样的效果，而且在代码中我们没有看到丝毫 Spring 侵入的现象。所以通过 init-method 我们可以使用业务对象中定义的任何方法来实现 bean 实例对象的初始化定制化，而不再受制于 InitializingBean的 `afterPropertiesSet()`。同时我们可以使用 `<beans>` 标签的 `default-init-method` 属性来统一指定初始化方法，这样就省了需要在每个 `<bean>` 标签中都设置 `init-method` 这样的繁琐工作了。比如在 `default-init-method` 规定所有初始化操作全部以 `initBean()` 命名。如下：\n\n![upload successful](/images/pasted-21.png)\n\n从 `invokeInitMethods()` 中，我们知道 `init-method` 指定的方法会在 `afterPropertiesSet()` 之后执行，如果 `afterPropertiesSet()` 中出现了异常，则 `init-method` 是不会执行的，而且由于 `init-method` 采用的是反射执行的方式，所以 `afterPropertiesSet()` 的执行效率一般会高些，但是并不能排除我们要优先使用 `init-method`，主要是因为它消除了 bean 对 Spring 的依赖，Spring 没有侵入到我们业务代码，这样会更加符合 Spring 的理念。诚然，`init-method` 是基于 xml 配置文件的，就目前而言，我们的工程几乎都摒弃了配置，而采用注释的方式，那么 `@PreDestory` 可能适合你，当然这个注解我们后面分析。\n\n至此，InitializingBean 和 init-method 已经分析完毕了，对于DisposableBean 和 destory-method，他们和 init 相似，这里就不做阐述了。","slug":"spring 源码分析/spring/spring源码解析之 28深入分析InitializingBean 接口和 init-method","published":1,"updated":"2019-01-16T08:34:00.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovtl003k9q1uok7akxoo","content":"<h1 id=\"spring源码解析之-28深入分析InitializingBean-接口和-init-method\"><a href=\"#spring源码解析之-28深入分析InitializingBean-接口和-init-method\" class=\"headerlink\" title=\"spring源码解析之 28深入分析InitializingBean 接口和 init-method\"></a>spring源码解析之 28深入分析InitializingBean 接口和 init-method</h1><p> 已经分析了 Aware 接口族 和 BeanPostProcessor 接口，这篇分析 InitializingBean 接口和 init-method 方法。</p>\n<h2 id=\"InitializingBean\"><a href=\"#InitializingBean\" class=\"headerlink\" title=\"InitializingBean\"></a>InitializingBean</h2><p>Spring 的 InitializingBean 接口为 bean 提供了定义初始化方法的方式，它仅包含了一个方法：<code>afterPropertiesSet()</code>。<br><a id=\"more\"></a></p>\n<pre><code class=\"JAVA\">public interface InitializingBean {\n\n     /**\n    * 该方法在 BeanFactory 设置完了所有属性之后被调用\n    * 该方法允许 bean 实例设置了所有 bean 属性时执行初始化工作，如果该过程出现了错误则需要抛出异常\n   */\n   void afterPropertiesSet() throws Exception;\n}\n</code></pre>\n<p>Spring 在完成实例化后，设置完所有属性，进行 “Aware 接口” 和 “BeanPostProcessor 前置处理”之后，会接着检测当前 bean 对象是否实现了 InitializingBean 接口，如果是，则会调用其 <code>afterPropertiesSet()</code> 进一步调整 bean 实例对象的状态。</p>\n<pre><code class=\"JAVA\">public class InitializingBeanTest implements InitializingBean {\n\n    private String name;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        System.out.println(&quot;InitializingBeanTest initializing...&quot;);\n\n        this.name = &quot;chenssy 2 号&quot;;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n// 配置项\n&lt;bean id=&quot;initializingBeanTest&quot; class=&quot;org.springframework.core.test.InitializingBeanTest&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;chenssy 1 号&quot;/&gt;\n&lt;/bean&gt;\n\n// 测试代码\nInitializingBeanTest test = (InitializingBeanTest) factory.getBean(&quot;initializingBeanTest&quot;);\nSystem.out.println(&quot;name ：&quot; + test.getName());\n</code></pre>\n<p>执行结果：</p>\n<p><img src=\"/images/pasted-22.png\" alt=\"upload successful\"></p>\n<p>在这个示例中改变了 InitializingBeanTest 示例的 name 属性，也就是说 在 <code>afterPropertiesSet()</code> 中我们是可以改变 bean 的属性的，这相当于 Spring 容器又给我们提供了一种可以改变 bean 实例对象的方法。</p>\n<p>上面提到 bean 初始化阶段（<code>initializeBean()</code> ） Spring 容器会主动检查当前 bean 是否已经实现了 InitializingBean 接口，如果实现了则会掉用其 <code>afterPropertiesSet()</code> ,这个主动检查、调用的动作是由 <code>invokeInitMethods()</code> 来完成的。</p>\n<pre><code class=\"JAVA\">    protected void invokeInitMethods(String beanName, final Object bean,\n            @Nullable RootBeanDefinition mbd)\n            throws Throwable {\n\n        // 是否实现 InitializingBean\n        // 如果实现了 InitializingBean 接口，则只掉调用bean的 afterPropertiesSet()\n        boolean isInitializingBean = (bean instanceof InitializingBean);\n        if (isInitializingBean &amp;&amp; (mbd == null || \n                          !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &#39;&quot;\n                             + beanName + &quot;&#39;&quot;);\n            }\n            if (System.getSecurityManager() != null) {\n                try {\n                    AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) \n                                                  () -&gt; {\n                        ((InitializingBean) bean).afterPropertiesSet();\n                        return null;\n                    }, getAccessControlContext());\n                }\n                catch (PrivilegedActionException pae) {\n                    throw pae.getException();\n                }\n            }\n            else {\n                // 直接调用 afterPropertiesSet()\n                ((InitializingBean) bean).afterPropertiesSet();\n            }\n        }\n\n        if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) {\n            // 判断是否指定了 init-method()，\n            // 如果指定了 init-method()，则再调用制定的init-method\n            String initMethodName = mbd.getInitMethodName();\n            if (StringUtils.hasLength(initMethodName) &amp;&amp;\n                    !(isInitializingBean &amp;&amp; \n                          &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;\n                    !mbd.isExternallyManagedInitMethod(initMethodName)) {\n                // 利用反射机制执行\n                invokeCustomInitMethod(beanName, bean, mbd);\n            }\n        }\n    }\n</code></pre>\n<p>首先检测当前 bean 是否实现了 InitializingBean 接口，如果实现了则调用其 <code>afterPropertiesSet()</code>，然后再检查是否也指定了 <code>init-method()</code>，如果指定了则通过反射机制调用指定的 <code>init-method()</code>。</p>\n<p>虽然该接口为 Spring 容器的扩展性立下了汗马功劳，但是如果真的让我们的业务对象来实现这个接口就显得不是那么的友好了，Spring 的一个核心理念就是无侵入性，但是如果我们业务类实现这个接口就显得 Spring 容器具有侵入性了。所以 Spring 还提供了另外一种实现的方式：init-method 方法</p>\n<h2 id=\"init-method\"><a href=\"#init-method\" class=\"headerlink\" title=\"init-method()\"></a>init-method()</h2><p>在分析分析 <code>&lt;bean&gt;</code> 标签解析过程中我们提到了有关于 <code>init-method</code> 属性，该属性用于在 bean 初始化时指定执行方法，可以用来替代实现 InitializingBean 接口。</p>\n<pre><code class=\"JAVA\">public class InitializingBeanTest {\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setOtherName(){\n        System.out.println(&quot;InitializingBeanTest setOtherName...&quot;);\n\n        this.name = &quot;chenssy 3 号&quot;;\n    }\n}\n\n// 配置文件\n&lt;bean id=&quot;initializingBeanTest&quot; class=&quot;org.springframework.core.test.InitializingBeanTest&quot;\n        init-method=&quot;setOtherName&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;chenssy 1 号&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>执行结果:</p>\n<p><img src=\"/images/pasted-20.png\" alt=\"upload successful\"></p>\n<p>完全可以达到和 InitializingBean 一样的效果，而且在代码中我们没有看到丝毫 Spring 侵入的现象。所以通过 init-method 我们可以使用业务对象中定义的任何方法来实现 bean 实例对象的初始化定制化，而不再受制于 InitializingBean的 <code>afterPropertiesSet()</code>。同时我们可以使用 <code>&lt;beans&gt;</code> 标签的 <code>default-init-method</code> 属性来统一指定初始化方法，这样就省了需要在每个 <code>&lt;bean&gt;</code> 标签中都设置 <code>init-method</code> 这样的繁琐工作了。比如在 <code>default-init-method</code> 规定所有初始化操作全部以 <code>initBean()</code> 命名。如下：</p>\n<p><img src=\"/images/pasted-21.png\" alt=\"upload successful\"></p>\n<p>从 <code>invokeInitMethods()</code> 中，我们知道 <code>init-method</code> 指定的方法会在 <code>afterPropertiesSet()</code> 之后执行，如果 <code>afterPropertiesSet()</code> 中出现了异常，则 <code>init-method</code> 是不会执行的，而且由于 <code>init-method</code> 采用的是反射执行的方式，所以 <code>afterPropertiesSet()</code> 的执行效率一般会高些，但是并不能排除我们要优先使用 <code>init-method</code>，主要是因为它消除了 bean 对 Spring 的依赖，Spring 没有侵入到我们业务代码，这样会更加符合 Spring 的理念。诚然，<code>init-method</code> 是基于 xml 配置文件的，就目前而言，我们的工程几乎都摒弃了配置，而采用注释的方式，那么 <code>@PreDestory</code> 可能适合你，当然这个注解我们后面分析。</p>\n<p>至此，InitializingBean 和 init-method 已经分析完毕了，对于DisposableBean 和 destory-method，他们和 init 相似，这里就不做阐述了。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-28深入分析InitializingBean-接口和-init-method\"><a href=\"#spring源码解析之-28深入分析InitializingBean-接口和-init-method\" class=\"headerlink\" title=\"spring源码解析之 28深入分析InitializingBean 接口和 init-method\"></a>spring源码解析之 28深入分析InitializingBean 接口和 init-method</h1><p> 已经分析了 Aware 接口族 和 BeanPostProcessor 接口，这篇分析 InitializingBean 接口和 init-method 方法。</p>\n<h2 id=\"InitializingBean\"><a href=\"#InitializingBean\" class=\"headerlink\" title=\"InitializingBean\"></a>InitializingBean</h2><p>Spring 的 InitializingBean 接口为 bean 提供了定义初始化方法的方式，它仅包含了一个方法：<code>afterPropertiesSet()</code>。<br>","more":"</p>\n<pre><code class=\"JAVA\">public interface InitializingBean {\n\n     /**\n    * 该方法在 BeanFactory 设置完了所有属性之后被调用\n    * 该方法允许 bean 实例设置了所有 bean 属性时执行初始化工作，如果该过程出现了错误则需要抛出异常\n   */\n   void afterPropertiesSet() throws Exception;\n}\n</code></pre>\n<p>Spring 在完成实例化后，设置完所有属性，进行 “Aware 接口” 和 “BeanPostProcessor 前置处理”之后，会接着检测当前 bean 对象是否实现了 InitializingBean 接口，如果是，则会调用其 <code>afterPropertiesSet()</code> 进一步调整 bean 实例对象的状态。</p>\n<pre><code class=\"JAVA\">public class InitializingBeanTest implements InitializingBean {\n\n    private String name;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        System.out.println(&quot;InitializingBeanTest initializing...&quot;);\n\n        this.name = &quot;chenssy 2 号&quot;;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n// 配置项\n&lt;bean id=&quot;initializingBeanTest&quot; class=&quot;org.springframework.core.test.InitializingBeanTest&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;chenssy 1 号&quot;/&gt;\n&lt;/bean&gt;\n\n// 测试代码\nInitializingBeanTest test = (InitializingBeanTest) factory.getBean(&quot;initializingBeanTest&quot;);\nSystem.out.println(&quot;name ：&quot; + test.getName());\n</code></pre>\n<p>执行结果：</p>\n<p><img src=\"/images/pasted-22.png\" alt=\"upload successful\"></p>\n<p>在这个示例中改变了 InitializingBeanTest 示例的 name 属性，也就是说 在 <code>afterPropertiesSet()</code> 中我们是可以改变 bean 的属性的，这相当于 Spring 容器又给我们提供了一种可以改变 bean 实例对象的方法。</p>\n<p>上面提到 bean 初始化阶段（<code>initializeBean()</code> ） Spring 容器会主动检查当前 bean 是否已经实现了 InitializingBean 接口，如果实现了则会掉用其 <code>afterPropertiesSet()</code> ,这个主动检查、调用的动作是由 <code>invokeInitMethods()</code> 来完成的。</p>\n<pre><code class=\"JAVA\">    protected void invokeInitMethods(String beanName, final Object bean,\n            @Nullable RootBeanDefinition mbd)\n            throws Throwable {\n\n        // 是否实现 InitializingBean\n        // 如果实现了 InitializingBean 接口，则只掉调用bean的 afterPropertiesSet()\n        boolean isInitializingBean = (bean instanceof InitializingBean);\n        if (isInitializingBean &amp;&amp; (mbd == null || \n                          !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &#39;&quot;\n                             + beanName + &quot;&#39;&quot;);\n            }\n            if (System.getSecurityManager() != null) {\n                try {\n                    AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) \n                                                  () -&gt; {\n                        ((InitializingBean) bean).afterPropertiesSet();\n                        return null;\n                    }, getAccessControlContext());\n                }\n                catch (PrivilegedActionException pae) {\n                    throw pae.getException();\n                }\n            }\n            else {\n                // 直接调用 afterPropertiesSet()\n                ((InitializingBean) bean).afterPropertiesSet();\n            }\n        }\n\n        if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) {\n            // 判断是否指定了 init-method()，\n            // 如果指定了 init-method()，则再调用制定的init-method\n            String initMethodName = mbd.getInitMethodName();\n            if (StringUtils.hasLength(initMethodName) &amp;&amp;\n                    !(isInitializingBean &amp;&amp; \n                          &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;\n                    !mbd.isExternallyManagedInitMethod(initMethodName)) {\n                // 利用反射机制执行\n                invokeCustomInitMethod(beanName, bean, mbd);\n            }\n        }\n    }\n</code></pre>\n<p>首先检测当前 bean 是否实现了 InitializingBean 接口，如果实现了则调用其 <code>afterPropertiesSet()</code>，然后再检查是否也指定了 <code>init-method()</code>，如果指定了则通过反射机制调用指定的 <code>init-method()</code>。</p>\n<p>虽然该接口为 Spring 容器的扩展性立下了汗马功劳，但是如果真的让我们的业务对象来实现这个接口就显得不是那么的友好了，Spring 的一个核心理念就是无侵入性，但是如果我们业务类实现这个接口就显得 Spring 容器具有侵入性了。所以 Spring 还提供了另外一种实现的方式：init-method 方法</p>\n<h2 id=\"init-method\"><a href=\"#init-method\" class=\"headerlink\" title=\"init-method()\"></a>init-method()</h2><p>在分析分析 <code>&lt;bean&gt;</code> 标签解析过程中我们提到了有关于 <code>init-method</code> 属性，该属性用于在 bean 初始化时指定执行方法，可以用来替代实现 InitializingBean 接口。</p>\n<pre><code class=\"JAVA\">public class InitializingBeanTest {\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setOtherName(){\n        System.out.println(&quot;InitializingBeanTest setOtherName...&quot;);\n\n        this.name = &quot;chenssy 3 号&quot;;\n    }\n}\n\n// 配置文件\n&lt;bean id=&quot;initializingBeanTest&quot; class=&quot;org.springframework.core.test.InitializingBeanTest&quot;\n        init-method=&quot;setOtherName&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;chenssy 1 号&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>执行结果:</p>\n<p><img src=\"/images/pasted-20.png\" alt=\"upload successful\"></p>\n<p>完全可以达到和 InitializingBean 一样的效果，而且在代码中我们没有看到丝毫 Spring 侵入的现象。所以通过 init-method 我们可以使用业务对象中定义的任何方法来实现 bean 实例对象的初始化定制化，而不再受制于 InitializingBean的 <code>afterPropertiesSet()</code>。同时我们可以使用 <code>&lt;beans&gt;</code> 标签的 <code>default-init-method</code> 属性来统一指定初始化方法，这样就省了需要在每个 <code>&lt;bean&gt;</code> 标签中都设置 <code>init-method</code> 这样的繁琐工作了。比如在 <code>default-init-method</code> 规定所有初始化操作全部以 <code>initBean()</code> 命名。如下：</p>\n<p><img src=\"/images/pasted-21.png\" alt=\"upload successful\"></p>\n<p>从 <code>invokeInitMethods()</code> 中，我们知道 <code>init-method</code> 指定的方法会在 <code>afterPropertiesSet()</code> 之后执行，如果 <code>afterPropertiesSet()</code> 中出现了异常，则 <code>init-method</code> 是不会执行的，而且由于 <code>init-method</code> 采用的是反射执行的方式，所以 <code>afterPropertiesSet()</code> 的执行效率一般会高些，但是并不能排除我们要优先使用 <code>init-method</code>，主要是因为它消除了 bean 对 Spring 的依赖，Spring 没有侵入到我们业务代码，这样会更加符合 Spring 的理念。诚然，<code>init-method</code> 是基于 xml 配置文件的，就目前而言，我们的工程几乎都摒弃了配置，而采用注释的方式，那么 <code>@PreDestory</code> 可能适合你，当然这个注解我们后面分析。</p>\n<p>至此，InitializingBean 和 init-method 已经分析完毕了，对于DisposableBean 和 destory-method，他们和 init 相似，这里就不做阐述了。</p>"},{"abbrlink":9,"title":"java多线程系列-JUC线程池之 01 线程池架构","author":"zhangke","date":"2018-07-23T06:07:00.000Z","_content":"# java多线程系列-JUC线程池之 01 线程池架构\n\n### 概要\n\n>1. 线程池整体架构介绍\n>2. 简单示例\n\n### 1. 线程池整体架构介绍\n\n>### 1. Executor\n>\n>> Executor将任务的执行和任务的创建分离开来。他提供了执行的接口，是来执行任务的。只要提交的任务实现了Runnable接口，就可以将此任务交给Executor来执行，这个接口只包含一个函数，代码如下:\n>>\n>> ```\n>> public interface Executor{\n>>     //在未来执行给定的任务\n>>     void\texecute(Runnable command)\n>> }\n>> ```\n>>\n>> \n>\n>### 2. ExecutorService\n>\n>>现在可以通过Executor来实现任务的运行。通常Executor的实现通常会创建线程来执行任务。但JVM只有在所有非守护线程全部终止后才会退出，因此如果无法正确的关闭Executor，那么JVM将无法结束。\n>>\n>>关闭任务的方式：\n>>\n>>1. 直接关闭，相当于断开电源\n>>2. 执行完所有当前线程上执行的任务，不在接收新的任务。然后关闭\n>>\n>>此时Executor接口定义的方法不足以满足这些要求的实现，所以有了ExecutorService接口。添加了一些用于生命周期管理的方法（同时还有一些用于任务提交的便利方法）：\n>>\n>>```java\n>>// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。\n>>boolean awaitTermination(long timeout, TimeUnit unit)\n>>    \n>>// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。\n>><T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n>>// 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。\n>><T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n>>// 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。\n>><T> T invokeAny(Collection<? extends Callable<T>> tasks)\n>>// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。\n>><T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n>>    \n>>    \n>>// 如果此执行程序已关闭，则返回 true。\n>>boolean isShutdown()\n>>// 如果关闭后所有任务都已完成，则返回 true。\n>>boolean isTerminated()\n>>    \n>>    \n>>// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。\n>>void shutdown()\n>>// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。\n>>List<Runnable> shutdownNow()\n>>    \n>>    \n>>// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n>><T> Future<T> submit(Callable<T> task)\n>>// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>>Future<?> submit(Runnable task)\n>>// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>><T> Future<T> submit(Runnable task, T result)\n>>```\n>>\n>>ExecutorService的生命周期有三种状态：运行、关闭和已终止。\n>>\n>>1. 在初始创建时处于运行状态，\n>>\n>>2. shutdown方法将执行平缓的关闭状态：不在接收新的任务，同时等待已经提交的任务执行完成，包括那些还未开始执行的任务\n>>\n>>3. shutdownNow方法将执行粗暴的关闭过程，将尝试取消所有运行中的任务。\n>>\n>>   通过isTerminated来确定线程池是否终止，终止后不同拒绝策略有不同的返回结果的方式。\n>\n>### **3. AbstractExecutorService**\n>\n>> AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。方便我们定制线程池。这个类的方法和ExecutorService一样，所有就不列出来，后面再分析线程池源码时我会在来说这个类。\n>\n>### 4.**ThreadPoolExecutor**\n>\n>> ThreadPoolExecutor就是大名鼎鼎的\"线程池\"，它继承于AbstractExecutorService抽象类。是线程池的主要实现类，也是我们后面关注的重点，因此就现在这里提一下，后面会仔细讲。\n>>\n>> \n>\n>### 5. **ScheduledExecutorService**\n>\n>>ScheduledExecutorService是一个接口，它继承于于ExecutorService。它相当于提供了\"延时\"和\"周期执行\"功能的ExecutorService。 ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。\n>>\n>>**ScheduledExecutorService函数列表**\n>>\n>>````Java\n>>// 创建并执行在给定延迟后启用的 ScheduledFuture。\n>><V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit)\n>>// 创建并执行在给定延迟后启用的一次性操作。\n>>ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)\n>>// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\n>>ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n>>// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\n>>ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n>>````\n>>\n>>\n>\n>### 6. **ScheduledThreadPoolExecutor**\n>\n>> ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了\"延时\"和\"周期执行\"功能的ExecutorService。 ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。\n>>\n>> 在没有此接口之前，我们使用Timer来做定时任务，Timer定时任务的缺陷：\n>>\n>> 1. 执行定时任务时，只创建一个线程，因此如果某个任务执行时间过长，会导致其他定时任务的执行周期加长\n>> 2. 由于只创建了一个线程，当这个线程因为异常关闭之后，其他定时任务就无法启动。（这个问题称之为线程泄漏）\n>>\n>> 因此在5.0 之后很少使用这个类来做定时任务，换成了ScheduledThreadPoolExecutor来做定时任务。\n>>\n>> 同时要构建自己的调度任务还需要队列的支持，这时可以使用DelayQueue，他实现了BlockingQueue，并为ScheduledThreadPoolExecutor提供调度功能，DelayQUeue管理者一组Delayed对象，每个Delayed对象都有一个相应的延迟时间。在DelayQueue中，只有某个元素逾期后，才能从这个队列中take操作。\n>>\n>> 参数列表\n>>\n>> ```Java\n>> // 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize)\n>> // 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler)\n>> // 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory)\n>> // 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n>> \n>> // 修改或替换用于执行 callable 的任务。\n>> protected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task)\n>> // 修改或替换用于执行 runnable 的任务。\n>> protected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task)\n>> // 使用所要求的零延迟执行命令。\n>> void execute(Runnable command)\n>> // 获取有关在此执行程序已 shutdown 的情况下、是否继续执行现有定期任务的策略。\n>> boolean getContinueExistingPeriodicTasksAfterShutdownPolicy()\n>> // 获取有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\n>> boolean getExecuteExistingDelayedTasksAfterShutdownPolicy()\n>> // 返回此执行程序使用的任务队列。\n>> BlockingQueue<Runnable> getQueue()\n>> // 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。\n>> boolean remove(Runnable task)\n>> // 创建并执行在给定延迟后启用的 ScheduledFuture。\n>> <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit)\n>> // 创建并执行在给定延迟后启用的一次性操作。\n>> ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)\n>> // 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\n>> ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n>> // 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\n>> ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n>> // 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有定期任务的策略。\n>> void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)\n>> // 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\n>> void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)\n>> // 在以前已提交任务的执行中发起一个有序的关闭，但是不接受新任务。\n>> void shutdown()\n>> // 尝试停止所有正在执行的任务、暂停等待任务的处理，并返回等待执行的任务列表。\n>> List<Runnable> shutdownNow()\n>> // 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n>> <T> Future<T> submit(Callable<T> task)\n>> // 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>> Future<?> submit(Runnable task)\n>> // 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>> <T> Future<T> submit(Runnable task, T result)\n>> ```\n>>\n>> \n>\n>### 7. Executors\n>\n>>Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。\n>>\n>>```java\n>>// 返回 Callable 对象，调用它时可运行给定特权的操作并返回其结果。\n>>static Callable<Object> callable(PrivilegedAction<?> action)\n>>// 返回 Callable 对象，调用它时可运行给定特权的异常操作并返回其结果。\n>>static Callable<Object> callable(PrivilegedExceptionAction<?> action)\n>>// 返回 Callable 对象，调用它时可运行给定的任务并返回 null。\n>>static Callable<Object> callable(Runnable task)\n>>// 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果。\n>>static <T> Callable<T> callable(Runnable task, T result)\n>>// 返回用于创建新线程的默认线程工厂。\n>>static ThreadFactory defaultThreadFactory()\n>>// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。\n>>static ExecutorService newCachedThreadPool()\n>>// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。\n>>static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)\n>>// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。\n>>static ExecutorService newFixedThreadPool(int nThreads)\n>>// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。\n>>static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)\n>>// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n>>// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)\n>>// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。\n>>static ExecutorService newSingleThreadExecutor()\n>>// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，并在需要时使用提供的 ThreadFactory 创建新线程。\n>>static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)\n>>// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newSingleThreadScheduledExecutor()\n>>// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)\n>>// 返回 Callable 对象，调用它时可在当前的访问控制上下文中执行给定的 callable 对象。\n>>static <T> Callable<T> privilegedCallable(Callable<T> callable)\n>>// 返回 Callable 对象，调用它时可在当前的访问控制上下文中，使用当前上下文类加载器作为上下文类加载器来执行给定的 callable 对象。\n>>static <T> Callable<T> privilegedCallableUsingCurrentClassLoader(Callable<T> callable)\n>>// 返回用于创建新线程的线程工厂，这些新线程与当前线程具有相同的权限。\n>>static ThreadFactory privilegedThreadFactory()\n>>// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\n>>static ExecutorService unconfigurableExecutorService(ExecutorService executor)\n>>// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\n>>static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)\n>>```\n>>\n>>\n>\n>\n\n### 2. 简单示例\n\n>```java\n>import java.util.concurrent.Executors;\n>import java.util.concurrent.ExecutorService;\n>\n>public class ThreadPoolDemo1 {\n>\n>    public static void main(String[] args) {\n>        // 创建一个可重用固定线程数的线程池\n>        ExecutorService pool = Executors.newFixedThreadPool(2);\n>        // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n>        Thread ta = new MyThread();\n>        Thread tb = new MyThread();\n>        Thread tc = new MyThread();\n>        Thread td = new MyThread();\n>        Thread te = new MyThread();\n>        // 将线程放入池中进行执行\n>        pool.execute(ta);\n>        pool.execute(tb);\n>        pool.execute(tc);\n>        pool.execute(td);\n>        pool.execute(te);\n>        // 关闭线程池\n>        pool.shutdown();\n>    }\n>}\n>\n>class MyThread extends Thread {\n>\n>    @Override\n>    public void run() {\n>        System.out.println(Thread.currentThread().getName()+ \" is running.\");\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>```\n>\n>**结果说明**：\n>主线程中创建了线程池pool，线程池的容量是2。即，线程池中最多能同时运行2个线程。\n>紧接着，将ta,tb,tc,td,te这3个线程添加到线程池中运行。\n>最后，通过shutdown()关闭线程池。","source":"_posts/juc/threads/java多线程系列-JUC线程池之01 线程池架构.md","raw":"abbrlink: 9\ntitle: java多线程系列-JUC线程池之 01 线程池架构\ntags:\n  - JUC\n  - 线程池\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-23 14:07:00\n---\n# java多线程系列-JUC线程池之 01 线程池架构\n\n### 概要\n\n>1. 线程池整体架构介绍\n>2. 简单示例\n\n### 1. 线程池整体架构介绍\n\n>### 1. Executor\n>\n>> Executor将任务的执行和任务的创建分离开来。他提供了执行的接口，是来执行任务的。只要提交的任务实现了Runnable接口，就可以将此任务交给Executor来执行，这个接口只包含一个函数，代码如下:\n>>\n>> ```\n>> public interface Executor{\n>>     //在未来执行给定的任务\n>>     void\texecute(Runnable command)\n>> }\n>> ```\n>>\n>> \n>\n>### 2. ExecutorService\n>\n>>现在可以通过Executor来实现任务的运行。通常Executor的实现通常会创建线程来执行任务。但JVM只有在所有非守护线程全部终止后才会退出，因此如果无法正确的关闭Executor，那么JVM将无法结束。\n>>\n>>关闭任务的方式：\n>>\n>>1. 直接关闭，相当于断开电源\n>>2. 执行完所有当前线程上执行的任务，不在接收新的任务。然后关闭\n>>\n>>此时Executor接口定义的方法不足以满足这些要求的实现，所以有了ExecutorService接口。添加了一些用于生命周期管理的方法（同时还有一些用于任务提交的便利方法）：\n>>\n>>```java\n>>// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。\n>>boolean awaitTermination(long timeout, TimeUnit unit)\n>>    \n>>// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。\n>><T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n>>// 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。\n>><T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n>>// 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。\n>><T> T invokeAny(Collection<? extends Callable<T>> tasks)\n>>// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。\n>><T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n>>    \n>>    \n>>// 如果此执行程序已关闭，则返回 true。\n>>boolean isShutdown()\n>>// 如果关闭后所有任务都已完成，则返回 true。\n>>boolean isTerminated()\n>>    \n>>    \n>>// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。\n>>void shutdown()\n>>// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。\n>>List<Runnable> shutdownNow()\n>>    \n>>    \n>>// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n>><T> Future<T> submit(Callable<T> task)\n>>// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>>Future<?> submit(Runnable task)\n>>// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>><T> Future<T> submit(Runnable task, T result)\n>>```\n>>\n>>ExecutorService的生命周期有三种状态：运行、关闭和已终止。\n>>\n>>1. 在初始创建时处于运行状态，\n>>\n>>2. shutdown方法将执行平缓的关闭状态：不在接收新的任务，同时等待已经提交的任务执行完成，包括那些还未开始执行的任务\n>>\n>>3. shutdownNow方法将执行粗暴的关闭过程，将尝试取消所有运行中的任务。\n>>\n>>   通过isTerminated来确定线程池是否终止，终止后不同拒绝策略有不同的返回结果的方式。\n>\n>### **3. AbstractExecutorService**\n>\n>> AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。方便我们定制线程池。这个类的方法和ExecutorService一样，所有就不列出来，后面再分析线程池源码时我会在来说这个类。\n>\n>### 4.**ThreadPoolExecutor**\n>\n>> ThreadPoolExecutor就是大名鼎鼎的\"线程池\"，它继承于AbstractExecutorService抽象类。是线程池的主要实现类，也是我们后面关注的重点，因此就现在这里提一下，后面会仔细讲。\n>>\n>> \n>\n>### 5. **ScheduledExecutorService**\n>\n>>ScheduledExecutorService是一个接口，它继承于于ExecutorService。它相当于提供了\"延时\"和\"周期执行\"功能的ExecutorService。 ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。\n>>\n>>**ScheduledExecutorService函数列表**\n>>\n>>````Java\n>>// 创建并执行在给定延迟后启用的 ScheduledFuture。\n>><V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit)\n>>// 创建并执行在给定延迟后启用的一次性操作。\n>>ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)\n>>// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\n>>ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n>>// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\n>>ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n>>````\n>>\n>>\n>\n>### 6. **ScheduledThreadPoolExecutor**\n>\n>> ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了\"延时\"和\"周期执行\"功能的ExecutorService。 ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。\n>>\n>> 在没有此接口之前，我们使用Timer来做定时任务，Timer定时任务的缺陷：\n>>\n>> 1. 执行定时任务时，只创建一个线程，因此如果某个任务执行时间过长，会导致其他定时任务的执行周期加长\n>> 2. 由于只创建了一个线程，当这个线程因为异常关闭之后，其他定时任务就无法启动。（这个问题称之为线程泄漏）\n>>\n>> 因此在5.0 之后很少使用这个类来做定时任务，换成了ScheduledThreadPoolExecutor来做定时任务。\n>>\n>> 同时要构建自己的调度任务还需要队列的支持，这时可以使用DelayQueue，他实现了BlockingQueue，并为ScheduledThreadPoolExecutor提供调度功能，DelayQUeue管理者一组Delayed对象，每个Delayed对象都有一个相应的延迟时间。在DelayQueue中，只有某个元素逾期后，才能从这个队列中take操作。\n>>\n>> 参数列表\n>>\n>> ```Java\n>> // 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize)\n>> // 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler)\n>> // 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory)\n>> // 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n>> \n>> // 修改或替换用于执行 callable 的任务。\n>> protected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task)\n>> // 修改或替换用于执行 runnable 的任务。\n>> protected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task)\n>> // 使用所要求的零延迟执行命令。\n>> void execute(Runnable command)\n>> // 获取有关在此执行程序已 shutdown 的情况下、是否继续执行现有定期任务的策略。\n>> boolean getContinueExistingPeriodicTasksAfterShutdownPolicy()\n>> // 获取有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\n>> boolean getExecuteExistingDelayedTasksAfterShutdownPolicy()\n>> // 返回此执行程序使用的任务队列。\n>> BlockingQueue<Runnable> getQueue()\n>> // 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。\n>> boolean remove(Runnable task)\n>> // 创建并执行在给定延迟后启用的 ScheduledFuture。\n>> <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit)\n>> // 创建并执行在给定延迟后启用的一次性操作。\n>> ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)\n>> // 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\n>> ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n>> // 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\n>> ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n>> // 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有定期任务的策略。\n>> void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)\n>> // 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\n>> void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)\n>> // 在以前已提交任务的执行中发起一个有序的关闭，但是不接受新任务。\n>> void shutdown()\n>> // 尝试停止所有正在执行的任务、暂停等待任务的处理，并返回等待执行的任务列表。\n>> List<Runnable> shutdownNow()\n>> // 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n>> <T> Future<T> submit(Callable<T> task)\n>> // 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>> Future<?> submit(Runnable task)\n>> // 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>> <T> Future<T> submit(Runnable task, T result)\n>> ```\n>>\n>> \n>\n>### 7. Executors\n>\n>>Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。\n>>\n>>```java\n>>// 返回 Callable 对象，调用它时可运行给定特权的操作并返回其结果。\n>>static Callable<Object> callable(PrivilegedAction<?> action)\n>>// 返回 Callable 对象，调用它时可运行给定特权的异常操作并返回其结果。\n>>static Callable<Object> callable(PrivilegedExceptionAction<?> action)\n>>// 返回 Callable 对象，调用它时可运行给定的任务并返回 null。\n>>static Callable<Object> callable(Runnable task)\n>>// 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果。\n>>static <T> Callable<T> callable(Runnable task, T result)\n>>// 返回用于创建新线程的默认线程工厂。\n>>static ThreadFactory defaultThreadFactory()\n>>// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。\n>>static ExecutorService newCachedThreadPool()\n>>// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。\n>>static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)\n>>// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。\n>>static ExecutorService newFixedThreadPool(int nThreads)\n>>// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。\n>>static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)\n>>// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n>>// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)\n>>// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。\n>>static ExecutorService newSingleThreadExecutor()\n>>// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，并在需要时使用提供的 ThreadFactory 创建新线程。\n>>static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)\n>>// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newSingleThreadScheduledExecutor()\n>>// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)\n>>// 返回 Callable 对象，调用它时可在当前的访问控制上下文中执行给定的 callable 对象。\n>>static <T> Callable<T> privilegedCallable(Callable<T> callable)\n>>// 返回 Callable 对象，调用它时可在当前的访问控制上下文中，使用当前上下文类加载器作为上下文类加载器来执行给定的 callable 对象。\n>>static <T> Callable<T> privilegedCallableUsingCurrentClassLoader(Callable<T> callable)\n>>// 返回用于创建新线程的线程工厂，这些新线程与当前线程具有相同的权限。\n>>static ThreadFactory privilegedThreadFactory()\n>>// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\n>>static ExecutorService unconfigurableExecutorService(ExecutorService executor)\n>>// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\n>>static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)\n>>```\n>>\n>>\n>\n>\n\n### 2. 简单示例\n\n>```java\n>import java.util.concurrent.Executors;\n>import java.util.concurrent.ExecutorService;\n>\n>public class ThreadPoolDemo1 {\n>\n>    public static void main(String[] args) {\n>        // 创建一个可重用固定线程数的线程池\n>        ExecutorService pool = Executors.newFixedThreadPool(2);\n>        // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n>        Thread ta = new MyThread();\n>        Thread tb = new MyThread();\n>        Thread tc = new MyThread();\n>        Thread td = new MyThread();\n>        Thread te = new MyThread();\n>        // 将线程放入池中进行执行\n>        pool.execute(ta);\n>        pool.execute(tb);\n>        pool.execute(tc);\n>        pool.execute(td);\n>        pool.execute(te);\n>        // 关闭线程池\n>        pool.shutdown();\n>    }\n>}\n>\n>class MyThread extends Thread {\n>\n>    @Override\n>    public void run() {\n>        System.out.println(Thread.currentThread().getName()+ \" is running.\");\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>```\n>\n>**结果说明**：\n>主线程中创建了线程池pool，线程池的容量是2。即，线程池中最多能同时运行2个线程。\n>紧接着，将ta,tb,tc,td,te这3个线程添加到线程池中运行。\n>最后，通过shutdown()关闭线程池。","slug":"juc/threads/java多线程系列-JUC线程池之01 线程池架构","published":1,"updated":"2019-01-04T02:18:27.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovvx00419q1uh19q5o3b","content":"<h1 id=\"java多线程系列-JUC线程池之-01-线程池架构\"><a href=\"#java多线程系列-JUC线程池之-01-线程池架构\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之 01 线程池架构\"></a>java多线程系列-JUC线程池之 01 线程池架构</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>线程池整体架构介绍</li>\n<li>简单示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程池整体架构介绍\"><a href=\"#1-线程池整体架构介绍\" class=\"headerlink\" title=\"1. 线程池整体架构介绍\"></a>1. 线程池整体架构介绍</h3><blockquote>\n<h3 id=\"1-Executor\"><a href=\"#1-Executor\" class=\"headerlink\" title=\"1. Executor\"></a>1. Executor</h3><blockquote>\n<p>Executor将任务的执行和任务的创建分离开来。他提供了执行的接口，是来执行任务的。只要提交的任务实现了Runnable接口，就可以将此任务交给Executor来执行，这个接口只包含一个函数，代码如下:</p>\n<pre><code>public interface Executor{\n    //在未来执行给定的任务\n    void    execute(Runnable command)\n}\n</code></pre></blockquote>\n<h3 id=\"2-ExecutorService\"><a href=\"#2-ExecutorService\" class=\"headerlink\" title=\"2. ExecutorService\"></a>2. ExecutorService</h3><blockquote>\n<p>现在可以通过Executor来实现任务的运行。通常Executor的实现通常会创建线程来执行任务。但JVM只有在所有非守护线程全部终止后才会退出，因此如果无法正确的关闭Executor，那么JVM将无法结束。</p>\n<p>关闭任务的方式：</p>\n<ol>\n<li>直接关闭，相当于断开电源</li>\n<li>执行完所有当前线程上执行的任务，不在接收新的任务。然后关闭</li>\n</ol>\n<p>此时Executor接口定义的方法不足以满足这些要求的实现，所以有了ExecutorService接口。添加了一些用于生命周期管理的方法（同时还有一些用于任务提交的便利方法）：</p>\n<pre><code class=\"java\">// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。\nboolean awaitTermination(long timeout, TimeUnit unit)\n\n// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。\n&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)\n// 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。\n&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)\n// 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。\n&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)\n// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。\n&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)\n\n\n// 如果此执行程序已关闭，则返回 true。\nboolean isShutdown()\n// 如果关闭后所有任务都已完成，则返回 true。\nboolean isTerminated()\n\n\n// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。\nvoid shutdown()\n// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。\nList&lt;Runnable&gt; shutdownNow()\n\n\n// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\nFuture&lt;?&gt; submit(Runnable task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)\n</code></pre>\n<p>ExecutorService的生命周期有三种状态：运行、关闭和已终止。</p>\n<ol>\n<li><p>在初始创建时处于运行状态，</p>\n</li>\n<li><p>shutdown方法将执行平缓的关闭状态：不在接收新的任务，同时等待已经提交的任务执行完成，包括那些还未开始执行的任务</p>\n</li>\n<li><p>shutdownNow方法将执行粗暴的关闭过程，将尝试取消所有运行中的任务。</p>\n<p>通过isTerminated来确定线程池是否终止，终止后不同拒绝策略有不同的返回结果的方式。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"3-AbstractExecutorService\"><a href=\"#3-AbstractExecutorService\" class=\"headerlink\" title=\"3. AbstractExecutorService\"></a><strong>3. AbstractExecutorService</strong></h3><blockquote>\n<p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。方便我们定制线程池。这个类的方法和ExecutorService一样，所有就不列出来，后面再分析线程池源码时我会在来说这个类。</p>\n</blockquote>\n<h3 id=\"4-ThreadPoolExecutor\"><a href=\"#4-ThreadPoolExecutor\" class=\"headerlink\" title=\"4.ThreadPoolExecutor\"></a>4.<strong>ThreadPoolExecutor</strong></h3><blockquote>\n<p>ThreadPoolExecutor就是大名鼎鼎的”线程池”，它继承于AbstractExecutorService抽象类。是线程池的主要实现类，也是我们后面关注的重点，因此就现在这里提一下，后面会仔细讲。</p>\n</blockquote>\n<h3 id=\"5-ScheduledExecutorService\"><a href=\"#5-ScheduledExecutorService\" class=\"headerlink\" title=\"5. ScheduledExecutorService\"></a>5. <strong>ScheduledExecutorService</strong></h3><blockquote>\n<p>ScheduledExecutorService是一个接口，它继承于于ExecutorService。它相当于提供了”延时”和”周期执行”功能的ExecutorService。 ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。</p>\n<p><strong>ScheduledExecutorService函数列表</strong></p>\n<pre><code class=\"Java\">// 创建并执行在给定延迟后启用的 ScheduledFuture。\n&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)\n// 创建并执行在给定延迟后启用的一次性操作。\nScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\nScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\nScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n</code></pre>\n</blockquote>\n<h3 id=\"6-ScheduledThreadPoolExecutor\"><a href=\"#6-ScheduledThreadPoolExecutor\" class=\"headerlink\" title=\"6. ScheduledThreadPoolExecutor\"></a>6. <strong>ScheduledThreadPoolExecutor</strong></h3><blockquote>\n<p>ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了”延时”和”周期执行”功能的ExecutorService。 ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。</p>\n<p>在没有此接口之前，我们使用Timer来做定时任务，Timer定时任务的缺陷：</p>\n<ol>\n<li>执行定时任务时，只创建一个线程，因此如果某个任务执行时间过长，会导致其他定时任务的执行周期加长</li>\n<li>由于只创建了一个线程，当这个线程因为异常关闭之后，其他定时任务就无法启动。（这个问题称之为线程泄漏）</li>\n</ol>\n<p>因此在5.0 之后很少使用这个类来做定时任务，换成了ScheduledThreadPoolExecutor来做定时任务。</p>\n<p>同时要构建自己的调度任务还需要队列的支持，这时可以使用DelayQueue，他实现了BlockingQueue，并为ScheduledThreadPoolExecutor提供调度功能，DelayQUeue管理者一组Delayed对象，每个Delayed对象都有一个相应的延迟时间。在DelayQueue中，只有某个元素逾期后，才能从这个队列中take操作。</p>\n<p>参数列表</p>\n<pre><code class=\"Java\">// 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize)\n// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler)\n// 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory)\n// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n\n// 修改或替换用于执行 callable 的任务。\nprotected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task)\n// 修改或替换用于执行 runnable 的任务。\nprotected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)\n// 使用所要求的零延迟执行命令。\nvoid execute(Runnable command)\n// 获取有关在此执行程序已 shutdown 的情况下、是否继续执行现有定期任务的策略。\nboolean getContinueExistingPeriodicTasksAfterShutdownPolicy()\n// 获取有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\nboolean getExecuteExistingDelayedTasksAfterShutdownPolicy()\n// 返回此执行程序使用的任务队列。\nBlockingQueue&lt;Runnable&gt; getQueue()\n// 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。\nboolean remove(Runnable task)\n// 创建并执行在给定延迟后启用的 ScheduledFuture。\n&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)\n// 创建并执行在给定延迟后启用的一次性操作。\nScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\nScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\nScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有定期任务的策略。\nvoid setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)\n// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\nvoid setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)\n// 在以前已提交任务的执行中发起一个有序的关闭，但是不接受新任务。\nvoid shutdown()\n// 尝试停止所有正在执行的任务、暂停等待任务的处理，并返回等待执行的任务列表。\nList&lt;Runnable&gt; shutdownNow()\n// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\nFuture&lt;?&gt; submit(Runnable task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)\n</code></pre>\n</blockquote>\n<h3 id=\"7-Executors\"><a href=\"#7-Executors\" class=\"headerlink\" title=\"7. Executors\"></a>7. Executors</h3><blockquote>\n<p>Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。</p>\n<pre><code class=\"java\">// 返回 Callable 对象，调用它时可运行给定特权的操作并返回其结果。\nstatic Callable&lt;Object&gt; callable(PrivilegedAction&lt;?&gt; action)\n// 返回 Callable 对象，调用它时可运行给定特权的异常操作并返回其结果。\nstatic Callable&lt;Object&gt; callable(PrivilegedExceptionAction&lt;?&gt; action)\n// 返回 Callable 对象，调用它时可运行给定的任务并返回 null。\nstatic Callable&lt;Object&gt; callable(Runnable task)\n// 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果。\nstatic &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)\n// 返回用于创建新线程的默认线程工厂。\nstatic ThreadFactory defaultThreadFactory()\n// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。\nstatic ExecutorService newCachedThreadPool()\n// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。\nstatic ExecutorService newCachedThreadPool(ThreadFactory threadFactory)\n// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。\nstatic ExecutorService newFixedThreadPool(int nThreads)\n// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。\nstatic ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)\n// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)\n// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。\nstatic ExecutorService newSingleThreadExecutor()\n// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，并在需要时使用提供的 ThreadFactory 创建新线程。\nstatic ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)\n// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newSingleThreadScheduledExecutor()\n// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)\n// 返回 Callable 对象，调用它时可在当前的访问控制上下文中执行给定的 callable 对象。\nstatic &lt;T&gt; Callable&lt;T&gt; privilegedCallable(Callable&lt;T&gt; callable)\n// 返回 Callable 对象，调用它时可在当前的访问控制上下文中，使用当前上下文类加载器作为上下文类加载器来执行给定的 callable 对象。\nstatic &lt;T&gt; Callable&lt;T&gt; privilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; callable)\n// 返回用于创建新线程的线程工厂，这些新线程与当前线程具有相同的权限。\nstatic ThreadFactory privilegedThreadFactory()\n// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\nstatic ExecutorService unconfigurableExecutorService(ExecutorService executor)\n// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\nstatic ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)\n</code></pre>\n</blockquote>\n</blockquote>\n<h3 id=\"2-简单示例\"><a href=\"#2-简单示例\" class=\"headerlink\" title=\"2. 简单示例\"></a>2. 简单示例</h3><blockquote>\n<pre><code class=\"java\">import java.util.concurrent.Executors;\nimport java.util.concurrent.ExecutorService;\n\npublic class ThreadPoolDemo1 {\n\n   public static void main(String[] args) {\n       // 创建一个可重用固定线程数的线程池\n       ExecutorService pool = Executors.newFixedThreadPool(2);\n       // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n       Thread ta = new MyThread();\n       Thread tb = new MyThread();\n       Thread tc = new MyThread();\n       Thread td = new MyThread();\n       Thread te = new MyThread();\n       // 将线程放入池中进行执行\n       pool.execute(ta);\n       pool.execute(tb);\n       pool.execute(tc);\n       pool.execute(td);\n       pool.execute(te);\n       // 关闭线程池\n       pool.shutdown();\n   }\n}\n\nclass MyThread extends Thread {\n\n   @Override\n   public void run() {\n       System.out.println(Thread.currentThread().getName()+ &quot; is running.&quot;);\n   }\n}\n</code></pre>\n<p><strong>运行结果</strong>：</p>\n<pre><code>pool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\n</code></pre><p><strong>结果说明</strong>：<br>主线程中创建了线程池pool，线程池的容量是2。即，线程池中最多能同时运行2个线程。<br>紧接着，将ta,tb,tc,td,te这3个线程添加到线程池中运行。<br>最后，通过shutdown()关闭线程池。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-JUC线程池之-01-线程池架构\"><a href=\"#java多线程系列-JUC线程池之-01-线程池架构\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之 01 线程池架构\"></a>java多线程系列-JUC线程池之 01 线程池架构</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>线程池整体架构介绍</li>\n<li>简单示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程池整体架构介绍\"><a href=\"#1-线程池整体架构介绍\" class=\"headerlink\" title=\"1. 线程池整体架构介绍\"></a>1. 线程池整体架构介绍</h3><blockquote>\n<h3 id=\"1-Executor\"><a href=\"#1-Executor\" class=\"headerlink\" title=\"1. Executor\"></a>1. Executor</h3><blockquote>\n<p>Executor将任务的执行和任务的创建分离开来。他提供了执行的接口，是来执行任务的。只要提交的任务实现了Runnable接口，就可以将此任务交给Executor来执行，这个接口只包含一个函数，代码如下:</p>\n<pre><code>public interface Executor{\n    //在未来执行给定的任务\n    void    execute(Runnable command)\n}\n</code></pre></blockquote>\n<h3 id=\"2-ExecutorService\"><a href=\"#2-ExecutorService\" class=\"headerlink\" title=\"2. ExecutorService\"></a>2. ExecutorService</h3><blockquote>\n<p>现在可以通过Executor来实现任务的运行。通常Executor的实现通常会创建线程来执行任务。但JVM只有在所有非守护线程全部终止后才会退出，因此如果无法正确的关闭Executor，那么JVM将无法结束。</p>\n<p>关闭任务的方式：</p>\n<ol>\n<li>直接关闭，相当于断开电源</li>\n<li>执行完所有当前线程上执行的任务，不在接收新的任务。然后关闭</li>\n</ol>\n<p>此时Executor接口定义的方法不足以满足这些要求的实现，所以有了ExecutorService接口。添加了一些用于生命周期管理的方法（同时还有一些用于任务提交的便利方法）：</p>\n<pre><code class=\"java\">// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。\nboolean awaitTermination(long timeout, TimeUnit unit)\n\n// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。\n&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)\n// 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。\n&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)\n// 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。\n&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)\n// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。\n&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)\n\n\n// 如果此执行程序已关闭，则返回 true。\nboolean isShutdown()\n// 如果关闭后所有任务都已完成，则返回 true。\nboolean isTerminated()\n\n\n// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。\nvoid shutdown()\n// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。\nList&lt;Runnable&gt; shutdownNow()\n\n\n// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\nFuture&lt;?&gt; submit(Runnable task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)\n</code></pre>\n<p>ExecutorService的生命周期有三种状态：运行、关闭和已终止。</p>\n<ol>\n<li><p>在初始创建时处于运行状态，</p>\n</li>\n<li><p>shutdown方法将执行平缓的关闭状态：不在接收新的任务，同时等待已经提交的任务执行完成，包括那些还未开始执行的任务</p>\n</li>\n<li><p>shutdownNow方法将执行粗暴的关闭过程，将尝试取消所有运行中的任务。</p>\n<p>通过isTerminated来确定线程池是否终止，终止后不同拒绝策略有不同的返回结果的方式。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"3-AbstractExecutorService\"><a href=\"#3-AbstractExecutorService\" class=\"headerlink\" title=\"3. AbstractExecutorService\"></a><strong>3. AbstractExecutorService</strong></h3><blockquote>\n<p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。方便我们定制线程池。这个类的方法和ExecutorService一样，所有就不列出来，后面再分析线程池源码时我会在来说这个类。</p>\n</blockquote>\n<h3 id=\"4-ThreadPoolExecutor\"><a href=\"#4-ThreadPoolExecutor\" class=\"headerlink\" title=\"4.ThreadPoolExecutor\"></a>4.<strong>ThreadPoolExecutor</strong></h3><blockquote>\n<p>ThreadPoolExecutor就是大名鼎鼎的”线程池”，它继承于AbstractExecutorService抽象类。是线程池的主要实现类，也是我们后面关注的重点，因此就现在这里提一下，后面会仔细讲。</p>\n</blockquote>\n<h3 id=\"5-ScheduledExecutorService\"><a href=\"#5-ScheduledExecutorService\" class=\"headerlink\" title=\"5. ScheduledExecutorService\"></a>5. <strong>ScheduledExecutorService</strong></h3><blockquote>\n<p>ScheduledExecutorService是一个接口，它继承于于ExecutorService。它相当于提供了”延时”和”周期执行”功能的ExecutorService。 ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。</p>\n<p><strong>ScheduledExecutorService函数列表</strong></p>\n<pre><code class=\"Java\">// 创建并执行在给定延迟后启用的 ScheduledFuture。\n&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)\n// 创建并执行在给定延迟后启用的一次性操作。\nScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\nScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\nScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n</code></pre>\n</blockquote>\n<h3 id=\"6-ScheduledThreadPoolExecutor\"><a href=\"#6-ScheduledThreadPoolExecutor\" class=\"headerlink\" title=\"6. ScheduledThreadPoolExecutor\"></a>6. <strong>ScheduledThreadPoolExecutor</strong></h3><blockquote>\n<p>ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了”延时”和”周期执行”功能的ExecutorService。 ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。</p>\n<p>在没有此接口之前，我们使用Timer来做定时任务，Timer定时任务的缺陷：</p>\n<ol>\n<li>执行定时任务时，只创建一个线程，因此如果某个任务执行时间过长，会导致其他定时任务的执行周期加长</li>\n<li>由于只创建了一个线程，当这个线程因为异常关闭之后，其他定时任务就无法启动。（这个问题称之为线程泄漏）</li>\n</ol>\n<p>因此在5.0 之后很少使用这个类来做定时任务，换成了ScheduledThreadPoolExecutor来做定时任务。</p>\n<p>同时要构建自己的调度任务还需要队列的支持，这时可以使用DelayQueue，他实现了BlockingQueue，并为ScheduledThreadPoolExecutor提供调度功能，DelayQUeue管理者一组Delayed对象，每个Delayed对象都有一个相应的延迟时间。在DelayQueue中，只有某个元素逾期后，才能从这个队列中take操作。</p>\n<p>参数列表</p>\n<pre><code class=\"Java\">// 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize)\n// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler)\n// 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory)\n// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n\n// 修改或替换用于执行 callable 的任务。\nprotected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task)\n// 修改或替换用于执行 runnable 的任务。\nprotected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)\n// 使用所要求的零延迟执行命令。\nvoid execute(Runnable command)\n// 获取有关在此执行程序已 shutdown 的情况下、是否继续执行现有定期任务的策略。\nboolean getContinueExistingPeriodicTasksAfterShutdownPolicy()\n// 获取有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\nboolean getExecuteExistingDelayedTasksAfterShutdownPolicy()\n// 返回此执行程序使用的任务队列。\nBlockingQueue&lt;Runnable&gt; getQueue()\n// 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。\nboolean remove(Runnable task)\n// 创建并执行在给定延迟后启用的 ScheduledFuture。\n&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)\n// 创建并执行在给定延迟后启用的一次性操作。\nScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\nScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\nScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有定期任务的策略。\nvoid setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)\n// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\nvoid setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)\n// 在以前已提交任务的执行中发起一个有序的关闭，但是不接受新任务。\nvoid shutdown()\n// 尝试停止所有正在执行的任务、暂停等待任务的处理，并返回等待执行的任务列表。\nList&lt;Runnable&gt; shutdownNow()\n// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\nFuture&lt;?&gt; submit(Runnable task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)\n</code></pre>\n</blockquote>\n<h3 id=\"7-Executors\"><a href=\"#7-Executors\" class=\"headerlink\" title=\"7. Executors\"></a>7. Executors</h3><blockquote>\n<p>Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。</p>\n<pre><code class=\"java\">// 返回 Callable 对象，调用它时可运行给定特权的操作并返回其结果。\nstatic Callable&lt;Object&gt; callable(PrivilegedAction&lt;?&gt; action)\n// 返回 Callable 对象，调用它时可运行给定特权的异常操作并返回其结果。\nstatic Callable&lt;Object&gt; callable(PrivilegedExceptionAction&lt;?&gt; action)\n// 返回 Callable 对象，调用它时可运行给定的任务并返回 null。\nstatic Callable&lt;Object&gt; callable(Runnable task)\n// 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果。\nstatic &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)\n// 返回用于创建新线程的默认线程工厂。\nstatic ThreadFactory defaultThreadFactory()\n// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。\nstatic ExecutorService newCachedThreadPool()\n// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。\nstatic ExecutorService newCachedThreadPool(ThreadFactory threadFactory)\n// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。\nstatic ExecutorService newFixedThreadPool(int nThreads)\n// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。\nstatic ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)\n// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)\n// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。\nstatic ExecutorService newSingleThreadExecutor()\n// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，并在需要时使用提供的 ThreadFactory 创建新线程。\nstatic ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)\n// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newSingleThreadScheduledExecutor()\n// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)\n// 返回 Callable 对象，调用它时可在当前的访问控制上下文中执行给定的 callable 对象。\nstatic &lt;T&gt; Callable&lt;T&gt; privilegedCallable(Callable&lt;T&gt; callable)\n// 返回 Callable 对象，调用它时可在当前的访问控制上下文中，使用当前上下文类加载器作为上下文类加载器来执行给定的 callable 对象。\nstatic &lt;T&gt; Callable&lt;T&gt; privilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; callable)\n// 返回用于创建新线程的线程工厂，这些新线程与当前线程具有相同的权限。\nstatic ThreadFactory privilegedThreadFactory()\n// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\nstatic ExecutorService unconfigurableExecutorService(ExecutorService executor)\n// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\nstatic ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)\n</code></pre>\n</blockquote>\n</blockquote>\n<h3 id=\"2-简单示例\"><a href=\"#2-简单示例\" class=\"headerlink\" title=\"2. 简单示例\"></a>2. 简单示例</h3><blockquote>\n<pre><code class=\"java\">import java.util.concurrent.Executors;\nimport java.util.concurrent.ExecutorService;\n\npublic class ThreadPoolDemo1 {\n\n   public static void main(String[] args) {\n       // 创建一个可重用固定线程数的线程池\n       ExecutorService pool = Executors.newFixedThreadPool(2);\n       // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n       Thread ta = new MyThread();\n       Thread tb = new MyThread();\n       Thread tc = new MyThread();\n       Thread td = new MyThread();\n       Thread te = new MyThread();\n       // 将线程放入池中进行执行\n       pool.execute(ta);\n       pool.execute(tb);\n       pool.execute(tc);\n       pool.execute(td);\n       pool.execute(te);\n       // 关闭线程池\n       pool.shutdown();\n   }\n}\n\nclass MyThread extends Thread {\n\n   @Override\n   public void run() {\n       System.out.println(Thread.currentThread().getName()+ &quot; is running.&quot;);\n   }\n}\n</code></pre>\n<p><strong>运行结果</strong>：</p>\n<pre><code>pool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\n</code></pre><p><strong>结果说明</strong>：<br>主线程中创建了线程池pool，线程池的容量是2。即，线程池中最多能同时运行2个线程。<br>紧接着，将ta,tb,tc,td,te这3个线程添加到线程池中运行。<br>最后，通过shutdown()关闭线程池。</p>\n</blockquote>\n"},{"abbrlink":10,"title":"java多线程系列-JUC线程池之04 Future 和Callable","author":"zhangke","date":"2018-07-24T07:12:00.000Z","_content":"# java多线程系列-JUC线程池之04 Future 和Callable\n\n### 概要\n\n>1. Callable和Future简介\n>2. ThreadPoolExecutor中submit分析\n>3. FutureTask源码分析\n\n### 1. Callable 和 Future 简介\n\n>Executor框架使用Runnable作为其基本的任务表示形式。Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。\n>\n>许多任务实际上都是存在延迟的计算—执行数据库插叙，从网络上获取资源，或者计算某个复杂的功能，对于这些任务，Callable是一种更好的抽象：他认为主入口点（即call）将返回一个值，并可能抛出一个异常。\n>\n>在Executor中包含了一些辅助的方法能将其他类型的任务封装为一个Callabe。\n>\n>Runnable和Callable描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确的起始点，并且最终会结束。Executor执行的任务有4个声明周期阶段：创建、提交、开始和完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于哪些已经开始执行的任务，只能当他们响应中断时，才能取消。\n>\n>Future表示一个任务额声明周期，并定义相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。并且在Future规范中的隐含意义是，任务声明周期只能前进，不能后退，就像ExecutorService的生命周期一样。当某个任务完成后，他就永远停留在完成状态上。\n>\n>**1. Callable**\n>\n>Callable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。\n>\n>为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。\n>\n>Callable的源码如下：\n>\n>```\n>public interface Callable<V> {\n>    V call() throws Exception;\n>}\n>```\n>\n>**说明**：从中我们可以看出Callable支持泛型。 \n>\n>**2. Future**\n>\n>Future 是一个接口。它用于表示异步计算的结果。提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。\n>\n>Future的源码如下：\n>\n>```java\n>public interface Future<V> {\n>    // 试图取消对此任务的执行。\n>    boolean     cancel(boolean mayInterruptIfRunning)\n>\n>    // 如果在任务正常完成前将其取消，则返回 true。\n>    boolean     isCancelled()\n>\n>    // 如果任务已完成，则返回 true。\n>    boolean     isDone()\n>\n>    // 如有必要，等待计算完成，然后获取其结果。\n>    V           get() throws InterruptedException, ExecutionException;\n>\n>    // 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。\n>    V       get(long timeout, TimeUnit unit)\n>          throws InterruptedException, ExecutionException, TimeoutException;\n>}\n>```\n\n### 2. ThreadPoolExecutor中submit分析\n\n>前面我们已经对ThreadPoolExecutor中execute进行了分析，在execute中执行的任务是没有返回结果。这在很大程度上限制了这个方法的使用，因此在ExecutorService中提供了submit方法，可以在任务执行完成后返回结果，这个方法有三个重载方法，源码如下：\n>\n>```java\n>\t//执行Runnable接口，返回一个没有任何结果的Future\n>    public Future<?> submit(Runnable task) {\n>        if (task == null) throw new NullPointerException();\n>        RunnableFuture<Void> ftask = newTaskFor(task, null);\n>        execute(ftask);\n>        return ftask;\n>    }\n>\t//执行Runnable接口，并返回一个带有result结果的Future\n>    public <T> Future<T> submit(Runnable task, T result) {\n>        if (task == null) throw new NullPointerException();\n>        RunnableFuture<T> ftask = newTaskFor(task, result);\n>        execute(ftask);\n>        return ftask;\n>    }\n>\t\n>   \t//执行Callable接口，并返回Future对象\n>    public <T> Future<T> submit(Callable<T> task) {\n>        if (task == null) throw new NullPointerException();\n>        RunnableFuture<T> ftask = newTaskFor(task);\n>        execute(ftask);\n>        return ftask;\n>    }\n>```\n>\n>通过看上面的代码，大体上代码的结构都是相同的，首先通过newTaskFor方法创建一个RunnableFuture对象，然后使用execute执行这个任务。\n>\n>下面我们看一下newTaskFor这个方法，这个方法也包括俩个重载的方法，源码如下\n>\n>```java\n>protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {\n>     return new FutureTask<T>(runnable, value);\n>}\n>\n> protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n>      return new FutureTask<T>(callable);\n>}\n>```\n>\n>这个方法是将提供的Runnable和Callable接口封装在FutureTask内，然后返回一个RunnableFuture对象，事实上，FutureTask实现了RunnablFuture这个接口。\n\n###3.  FutureTask源码分析\n\n>Future继承体系如下\n>\n>![]()\n>\n>Future表示一个任务的状态有以下几种，\n>\n>```\n>NEW      ：任务新创建状态   \n>COMPLETING  ：任务完成状态\n>NORMAL \t\t：正常完成状态\n>EXCEPTIONAL ：异常完成状态\n>CANCELLED    ：取消状态\n>INTERRUPTING ：正在中断状态\n>INTERRUPTED  ：已经被中断状态\n>```\n>\n>状态只能从一个状态转变到另外一个状态，不能后退，状态的转换大致上有以下几种：\n>\n>```\n>NEW -> COMPLETING -> NORMAL\n>NEW -> COMPLETING -> EXCEPTIONAL\n>NEW -> CANCELLED\n>NEW -> INTERRUPTING -> INTERRUPTED\n>```\n>\n>### FutureTask构造函数\n>\n>```java\n>public FutureTask(Callable<V> callable) {\n>    if (callable == null)\n>        throw new NullPointerException();\n>    // callable是一个Callable对象\n>    this.callable = callable;\n>    // state记录FutureTask的状态\n>    this.state = NEW;       // ensure visibility of callable\n>}\n>\n>public FutureTask(Runnable runnable, V result) {\n>    \t//将给定的runnable接口封装成Callable类，\n>        this.callable = Executors.callable(runnable, result);\n>        this.state = NEW;       // ensure visibility of callable\n>}\n>\n>```\n>\n>### FutureTask中run函数\n>\n>在newTaskFor()新建一个ftask对象之后，会通过execute(ftask)执行该任务。此时ftask被当作一个Runnable对象进行执行，最终会调用到它的run()方法:源码如下：\n>\n>```java\n>public void run() {\n>    //判断当前任务的状态\n>    if (state != NEW ||\n>        !UNSAFE.compareAndSwapObject(this, runnerOffset,\n>                                     null, Thread.currentThread()))\n>        return;\n>    try {\n>        // 将callable对象赋值给c。\n>        Callable<V> c = callable;\n>        if (c != null && state == NEW) {\n>            V result;\n>            boolean ran;\n>            try {\n>                // 执行Callable的call()方法，并保存结果到result中。\n>                result = c.call();\n>                ran = true;\n>            } catch (Throwable ex) {\n>                result = null;\n>                ran = false;\n>                setException(ex);\n>            }\n>            // 如果运行成功，则将result保存\n>            if (ran)\n>                set(result);\n>        }\n>    } finally {\n>        runner = null;\n>        // 设置“state状态标记”\n>        int s = state;\n>        if (s >= INTERRUPTING)\n>            handlePossibleCancellationInterrupt(s);\n>    }\n>}\n>```\n>\n>**说明**：run()中会执行Callable对象的call()方法，并且最终将结果保存到result中，并通过set(result)将result保存。 之后调用FutureTask的get()方法，返回的就是通过set(result)保存的值。\n>\n>### FutureTask中get函数\n>\n>get是用来得到任务执行的结果，如果任务没有执行完成，就会暂停当前任务的执行\n>\n>```java\n> public V get() throws InterruptedException, ExecutionException {\n>        int s = state;\n>        if (s <= COMPLETING)\n>            s = awaitDone(false, 0L);\n>        return report(s);\n>    }\n>\n>```\n>\n>从上面代码可以看出，get是调用awaitDone来阻塞当前线程。源码如下\n>\n>```java\n>    private int awaitDone(boolean timed, long nanos)\n>        throws InterruptedException {\n>        //得到截止时间\n>        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n>        WaitNode q = null;\n>        boolean queued = false;\n>        //循环判断，知道任务执行完成\n>        for (;;) {\n>            //删除中断的等待结果返回线程\n>            if (Thread.interrupted()) {\n>                removeWaiter(q);\n>                throw new InterruptedException();\n>            }\n>\n>            //得到任务状态\n>            int s = state;\n>            //如果是以完成状态，则返回结果\n>            if (s > COMPLETING) {\n>                if (q != null)\n>                    q.thread = null;\n>                return s;\n>            }\n>            //如果是正在执行状态，当前线程让出cpu\n>            else if (s == COMPLETING) // cannot time out yet\n>                Thread.yield();\n>            //创建新的等待节点\n>            else if (q == null)\n>                q = new WaitNode();\n>            //将等待节点插入等待队列\n>            else if (!queued)\n>                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n>                                                     q.next = waiters, q);\n>            //如果是有等待时间限制的\n>            else if (timed) {\n>                nanos = deadline - System.nanoTime();\n>                //过了等待时间，则删除等待对应的等待节点\n>                if (nanos <= 0L) {\n>                    removeWaiter(q);\n>                    return state;\n>                }\n>                //阻塞当前线程\n>                LockSupport.parkNanos(this, nanos);\n>            }\n>            else\n>                LockSupport.park(this);\n>        }\n>    }\n>```\n>\n>分析：\n>\n>上面代码可以阻塞调用线程的执行，但是线程的唤醒是不在这里面的。其实这样设计是对的，任务是否执行完成，Future是无法决定的，只要执行这个任务的线程才知道，所以就把唤醒线程的代码放在run方法里面，但是为什么刚刚没有在run里面看到呢，是因为封装在finishCompletion这个方法里面，而这个方法的调用是由set和setExecption俩个方法调用，源码如下：\n>\n>```java\n>\t//任务执行完成，设置执行结果，并设置当前任务状态   \n>protected void set(V v) {\n>        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n>            outcome = v;\n>            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n>            //唤醒所有等待的此任务完成的线程\n>            finishCompletion();\n>        }\n>    }\n>\t//此方法和上面的set方法执行流程一样，只是改变当前任务的状态时异常状态\n>    protected void setException(Throwable t) {\n>        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n>            outcome = t;\n>            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n>            finishCompletion();\n>        }\n>    }\n>\t//唤醒锁等带此任务执行完成的线程\n>    private void finishCompletion() {\n>        // assert state > COMPLETING;\n>        for (WaitNode q; (q = waiters) != null;) {\n>            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n>                for (;;) {\n>                    Thread t = q.thread;\n>                    if (t != null) {\n>                        q.thread = null;\n>                        LockSupport.unpark(t);\n>                    }\n>                    WaitNode next = q.next;\n>                    if (next == null)\n>                        break;\n>                    q.next = null; // unlink to help gc\n>                    q = next;\n>                }\n>                break;\n>            }\n>        }\n>\t\t//这个方法是一个空方法，如果希望任务执行完成后调用一个类似于callback回调，继承此类，\n>        //然后封装此方法\n>        done();\n>\n>        callable = null;        // to reduce footprint\n>    }\n>```\n>\n>\n>\n>\n\n","source":"_posts/juc/threads/java多线程系列-JUC线程池之04 Future 和Callable.md","raw":"abbrlink: 10\ntitle: java多线程系列-JUC线程池之04 Future 和Callable\ntags:\n  - 线程池\n  - JUC\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-24 15:12:00\n---\n# java多线程系列-JUC线程池之04 Future 和Callable\n\n### 概要\n\n>1. Callable和Future简介\n>2. ThreadPoolExecutor中submit分析\n>3. FutureTask源码分析\n\n### 1. Callable 和 Future 简介\n\n>Executor框架使用Runnable作为其基本的任务表示形式。Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。\n>\n>许多任务实际上都是存在延迟的计算—执行数据库插叙，从网络上获取资源，或者计算某个复杂的功能，对于这些任务，Callable是一种更好的抽象：他认为主入口点（即call）将返回一个值，并可能抛出一个异常。\n>\n>在Executor中包含了一些辅助的方法能将其他类型的任务封装为一个Callabe。\n>\n>Runnable和Callable描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确的起始点，并且最终会结束。Executor执行的任务有4个声明周期阶段：创建、提交、开始和完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于哪些已经开始执行的任务，只能当他们响应中断时，才能取消。\n>\n>Future表示一个任务额声明周期，并定义相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。并且在Future规范中的隐含意义是，任务声明周期只能前进，不能后退，就像ExecutorService的生命周期一样。当某个任务完成后，他就永远停留在完成状态上。\n>\n>**1. Callable**\n>\n>Callable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。\n>\n>为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。\n>\n>Callable的源码如下：\n>\n>```\n>public interface Callable<V> {\n>    V call() throws Exception;\n>}\n>```\n>\n>**说明**：从中我们可以看出Callable支持泛型。 \n>\n>**2. Future**\n>\n>Future 是一个接口。它用于表示异步计算的结果。提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。\n>\n>Future的源码如下：\n>\n>```java\n>public interface Future<V> {\n>    // 试图取消对此任务的执行。\n>    boolean     cancel(boolean mayInterruptIfRunning)\n>\n>    // 如果在任务正常完成前将其取消，则返回 true。\n>    boolean     isCancelled()\n>\n>    // 如果任务已完成，则返回 true。\n>    boolean     isDone()\n>\n>    // 如有必要，等待计算完成，然后获取其结果。\n>    V           get() throws InterruptedException, ExecutionException;\n>\n>    // 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。\n>    V       get(long timeout, TimeUnit unit)\n>          throws InterruptedException, ExecutionException, TimeoutException;\n>}\n>```\n\n### 2. ThreadPoolExecutor中submit分析\n\n>前面我们已经对ThreadPoolExecutor中execute进行了分析，在execute中执行的任务是没有返回结果。这在很大程度上限制了这个方法的使用，因此在ExecutorService中提供了submit方法，可以在任务执行完成后返回结果，这个方法有三个重载方法，源码如下：\n>\n>```java\n>\t//执行Runnable接口，返回一个没有任何结果的Future\n>    public Future<?> submit(Runnable task) {\n>        if (task == null) throw new NullPointerException();\n>        RunnableFuture<Void> ftask = newTaskFor(task, null);\n>        execute(ftask);\n>        return ftask;\n>    }\n>\t//执行Runnable接口，并返回一个带有result结果的Future\n>    public <T> Future<T> submit(Runnable task, T result) {\n>        if (task == null) throw new NullPointerException();\n>        RunnableFuture<T> ftask = newTaskFor(task, result);\n>        execute(ftask);\n>        return ftask;\n>    }\n>\t\n>   \t//执行Callable接口，并返回Future对象\n>    public <T> Future<T> submit(Callable<T> task) {\n>        if (task == null) throw new NullPointerException();\n>        RunnableFuture<T> ftask = newTaskFor(task);\n>        execute(ftask);\n>        return ftask;\n>    }\n>```\n>\n>通过看上面的代码，大体上代码的结构都是相同的，首先通过newTaskFor方法创建一个RunnableFuture对象，然后使用execute执行这个任务。\n>\n>下面我们看一下newTaskFor这个方法，这个方法也包括俩个重载的方法，源码如下\n>\n>```java\n>protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {\n>     return new FutureTask<T>(runnable, value);\n>}\n>\n> protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n>      return new FutureTask<T>(callable);\n>}\n>```\n>\n>这个方法是将提供的Runnable和Callable接口封装在FutureTask内，然后返回一个RunnableFuture对象，事实上，FutureTask实现了RunnablFuture这个接口。\n\n###3.  FutureTask源码分析\n\n>Future继承体系如下\n>\n>![]()\n>\n>Future表示一个任务的状态有以下几种，\n>\n>```\n>NEW      ：任务新创建状态   \n>COMPLETING  ：任务完成状态\n>NORMAL \t\t：正常完成状态\n>EXCEPTIONAL ：异常完成状态\n>CANCELLED    ：取消状态\n>INTERRUPTING ：正在中断状态\n>INTERRUPTED  ：已经被中断状态\n>```\n>\n>状态只能从一个状态转变到另外一个状态，不能后退，状态的转换大致上有以下几种：\n>\n>```\n>NEW -> COMPLETING -> NORMAL\n>NEW -> COMPLETING -> EXCEPTIONAL\n>NEW -> CANCELLED\n>NEW -> INTERRUPTING -> INTERRUPTED\n>```\n>\n>### FutureTask构造函数\n>\n>```java\n>public FutureTask(Callable<V> callable) {\n>    if (callable == null)\n>        throw new NullPointerException();\n>    // callable是一个Callable对象\n>    this.callable = callable;\n>    // state记录FutureTask的状态\n>    this.state = NEW;       // ensure visibility of callable\n>}\n>\n>public FutureTask(Runnable runnable, V result) {\n>    \t//将给定的runnable接口封装成Callable类，\n>        this.callable = Executors.callable(runnable, result);\n>        this.state = NEW;       // ensure visibility of callable\n>}\n>\n>```\n>\n>### FutureTask中run函数\n>\n>在newTaskFor()新建一个ftask对象之后，会通过execute(ftask)执行该任务。此时ftask被当作一个Runnable对象进行执行，最终会调用到它的run()方法:源码如下：\n>\n>```java\n>public void run() {\n>    //判断当前任务的状态\n>    if (state != NEW ||\n>        !UNSAFE.compareAndSwapObject(this, runnerOffset,\n>                                     null, Thread.currentThread()))\n>        return;\n>    try {\n>        // 将callable对象赋值给c。\n>        Callable<V> c = callable;\n>        if (c != null && state == NEW) {\n>            V result;\n>            boolean ran;\n>            try {\n>                // 执行Callable的call()方法，并保存结果到result中。\n>                result = c.call();\n>                ran = true;\n>            } catch (Throwable ex) {\n>                result = null;\n>                ran = false;\n>                setException(ex);\n>            }\n>            // 如果运行成功，则将result保存\n>            if (ran)\n>                set(result);\n>        }\n>    } finally {\n>        runner = null;\n>        // 设置“state状态标记”\n>        int s = state;\n>        if (s >= INTERRUPTING)\n>            handlePossibleCancellationInterrupt(s);\n>    }\n>}\n>```\n>\n>**说明**：run()中会执行Callable对象的call()方法，并且最终将结果保存到result中，并通过set(result)将result保存。 之后调用FutureTask的get()方法，返回的就是通过set(result)保存的值。\n>\n>### FutureTask中get函数\n>\n>get是用来得到任务执行的结果，如果任务没有执行完成，就会暂停当前任务的执行\n>\n>```java\n> public V get() throws InterruptedException, ExecutionException {\n>        int s = state;\n>        if (s <= COMPLETING)\n>            s = awaitDone(false, 0L);\n>        return report(s);\n>    }\n>\n>```\n>\n>从上面代码可以看出，get是调用awaitDone来阻塞当前线程。源码如下\n>\n>```java\n>    private int awaitDone(boolean timed, long nanos)\n>        throws InterruptedException {\n>        //得到截止时间\n>        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n>        WaitNode q = null;\n>        boolean queued = false;\n>        //循环判断，知道任务执行完成\n>        for (;;) {\n>            //删除中断的等待结果返回线程\n>            if (Thread.interrupted()) {\n>                removeWaiter(q);\n>                throw new InterruptedException();\n>            }\n>\n>            //得到任务状态\n>            int s = state;\n>            //如果是以完成状态，则返回结果\n>            if (s > COMPLETING) {\n>                if (q != null)\n>                    q.thread = null;\n>                return s;\n>            }\n>            //如果是正在执行状态，当前线程让出cpu\n>            else if (s == COMPLETING) // cannot time out yet\n>                Thread.yield();\n>            //创建新的等待节点\n>            else if (q == null)\n>                q = new WaitNode();\n>            //将等待节点插入等待队列\n>            else if (!queued)\n>                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n>                                                     q.next = waiters, q);\n>            //如果是有等待时间限制的\n>            else if (timed) {\n>                nanos = deadline - System.nanoTime();\n>                //过了等待时间，则删除等待对应的等待节点\n>                if (nanos <= 0L) {\n>                    removeWaiter(q);\n>                    return state;\n>                }\n>                //阻塞当前线程\n>                LockSupport.parkNanos(this, nanos);\n>            }\n>            else\n>                LockSupport.park(this);\n>        }\n>    }\n>```\n>\n>分析：\n>\n>上面代码可以阻塞调用线程的执行，但是线程的唤醒是不在这里面的。其实这样设计是对的，任务是否执行完成，Future是无法决定的，只要执行这个任务的线程才知道，所以就把唤醒线程的代码放在run方法里面，但是为什么刚刚没有在run里面看到呢，是因为封装在finishCompletion这个方法里面，而这个方法的调用是由set和setExecption俩个方法调用，源码如下：\n>\n>```java\n>\t//任务执行完成，设置执行结果，并设置当前任务状态   \n>protected void set(V v) {\n>        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n>            outcome = v;\n>            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n>            //唤醒所有等待的此任务完成的线程\n>            finishCompletion();\n>        }\n>    }\n>\t//此方法和上面的set方法执行流程一样，只是改变当前任务的状态时异常状态\n>    protected void setException(Throwable t) {\n>        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n>            outcome = t;\n>            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n>            finishCompletion();\n>        }\n>    }\n>\t//唤醒锁等带此任务执行完成的线程\n>    private void finishCompletion() {\n>        // assert state > COMPLETING;\n>        for (WaitNode q; (q = waiters) != null;) {\n>            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n>                for (;;) {\n>                    Thread t = q.thread;\n>                    if (t != null) {\n>                        q.thread = null;\n>                        LockSupport.unpark(t);\n>                    }\n>                    WaitNode next = q.next;\n>                    if (next == null)\n>                        break;\n>                    q.next = null; // unlink to help gc\n>                    q = next;\n>                }\n>                break;\n>            }\n>        }\n>\t\t//这个方法是一个空方法，如果希望任务执行完成后调用一个类似于callback回调，继承此类，\n>        //然后封装此方法\n>        done();\n>\n>        callable = null;        // to reduce footprint\n>    }\n>```\n>\n>\n>\n>\n\n","slug":"juc/threads/java多线程系列-JUC线程池之04 Future 和Callable","published":1,"updated":"2019-01-04T01:48:59.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovvz00429q1uddpjad3l","content":"<h1 id=\"java多线程系列-JUC线程池之04-Future-和Callable\"><a href=\"#java多线程系列-JUC线程池之04-Future-和Callable\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之04 Future 和Callable\"></a>java多线程系列-JUC线程池之04 Future 和Callable</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>Callable和Future简介</li>\n<li>ThreadPoolExecutor中submit分析</li>\n<li>FutureTask源码分析</li>\n</ol>\n</blockquote>\n<h3 id=\"1-Callable-和-Future-简介\"><a href=\"#1-Callable-和-Future-简介\" class=\"headerlink\" title=\"1. Callable 和 Future 简介\"></a>1. Callable 和 Future 简介</h3><blockquote>\n<p>Executor框架使用Runnable作为其基本的任务表示形式。Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。</p>\n<p>许多任务实际上都是存在延迟的计算—执行数据库插叙，从网络上获取资源，或者计算某个复杂的功能，对于这些任务，Callable是一种更好的抽象：他认为主入口点（即call）将返回一个值，并可能抛出一个异常。</p>\n<p>在Executor中包含了一些辅助的方法能将其他类型的任务封装为一个Callabe。</p>\n<p>Runnable和Callable描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确的起始点，并且最终会结束。Executor执行的任务有4个声明周期阶段：创建、提交、开始和完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于哪些已经开始执行的任务，只能当他们响应中断时，才能取消。</p>\n<p>Future表示一个任务额声明周期，并定义相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。并且在Future规范中的隐含意义是，任务声明周期只能前进，不能后退，就像ExecutorService的生命周期一样。当某个任务完成后，他就永远停留在完成状态上。</p>\n<p><strong>1. Callable</strong></p>\n<p>Callable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。</p>\n<p>为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。</p>\n<p>Callable的源码如下：</p>\n<pre><code>public interface Callable&lt;V&gt; {\n   V call() throws Exception;\n}\n</code></pre><p><strong>说明</strong>：从中我们可以看出Callable支持泛型。 </p>\n<p><strong>2. Future</strong></p>\n<p>Future 是一个接口。它用于表示异步计算的结果。提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。</p>\n<p>Future的源码如下：</p>\n<pre><code class=\"java\">public interface Future&lt;V&gt; {\n   // 试图取消对此任务的执行。\n   boolean     cancel(boolean mayInterruptIfRunning)\n\n   // 如果在任务正常完成前将其取消，则返回 true。\n   boolean     isCancelled()\n\n   // 如果任务已完成，则返回 true。\n   boolean     isDone()\n\n   // 如有必要，等待计算完成，然后获取其结果。\n   V           get() throws InterruptedException, ExecutionException;\n\n   // 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。\n   V       get(long timeout, TimeUnit unit)\n         throws InterruptedException, ExecutionException, TimeoutException;\n}\n</code></pre>\n</blockquote>\n<h3 id=\"2-ThreadPoolExecutor中submit分析\"><a href=\"#2-ThreadPoolExecutor中submit分析\" class=\"headerlink\" title=\"2. ThreadPoolExecutor中submit分析\"></a>2. ThreadPoolExecutor中submit分析</h3><blockquote>\n<p>前面我们已经对ThreadPoolExecutor中execute进行了分析，在execute中执行的任务是没有返回结果。这在很大程度上限制了这个方法的使用，因此在ExecutorService中提供了submit方法，可以在任务执行完成后返回结果，这个方法有三个重载方法，源码如下：</p>\n<pre><code class=\"java\">   //执行Runnable接口，返回一个没有任何结果的Future\n   public Future&lt;?&gt; submit(Runnable task) {\n       if (task == null) throw new NullPointerException();\n       RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);\n       execute(ftask);\n       return ftask;\n   }\n   //执行Runnable接口，并返回一个带有result结果的Future\n   public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {\n       if (task == null) throw new NullPointerException();\n       RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);\n       execute(ftask);\n       return ftask;\n   }\n\n      //执行Callable接口，并返回Future对象\n   public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {\n       if (task == null) throw new NullPointerException();\n       RunnableFuture&lt;T&gt; ftask = newTaskFor(task);\n       execute(ftask);\n       return ftask;\n   }\n</code></pre>\n<p>通过看上面的代码，大体上代码的结构都是相同的，首先通过newTaskFor方法创建一个RunnableFuture对象，然后使用execute执行这个任务。</p>\n<p>下面我们看一下newTaskFor这个方法，这个方法也包括俩个重载的方法，源码如下</p>\n<pre><code class=\"java\">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {\n    return new FutureTask&lt;T&gt;(runnable, value);\n}\n\nprotected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {\n     return new FutureTask&lt;T&gt;(callable);\n}\n</code></pre>\n<p>这个方法是将提供的Runnable和Callable接口封装在FutureTask内，然后返回一个RunnableFuture对象，事实上，FutureTask实现了RunnablFuture这个接口。</p>\n</blockquote>\n<p>###3.  FutureTask源码分析</p>\n<blockquote>\n<p>Future继承体系如下</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>Future表示一个任务的状态有以下几种，</p>\n<pre><code>NEW      ：任务新创建状态   \nCOMPLETING  ：任务完成状态\nNORMAL         ：正常完成状态\nEXCEPTIONAL ：异常完成状态\nCANCELLED    ：取消状态\nINTERRUPTING ：正在中断状态\nINTERRUPTED  ：已经被中断状态\n</code></pre><p>状态只能从一个状态转变到另外一个状态，不能后退，状态的转换大致上有以下几种：</p>\n<pre><code>NEW -&gt; COMPLETING -&gt; NORMAL\nNEW -&gt; COMPLETING -&gt; EXCEPTIONAL\nNEW -&gt; CANCELLED\nNEW -&gt; INTERRUPTING -&gt; INTERRUPTED\n</code></pre><h3 id=\"FutureTask构造函数\"><a href=\"#FutureTask构造函数\" class=\"headerlink\" title=\"FutureTask构造函数\"></a>FutureTask构造函数</h3><pre><code class=\"java\">public FutureTask(Callable&lt;V&gt; callable) {\n   if (callable == null)\n       throw new NullPointerException();\n   // callable是一个Callable对象\n   this.callable = callable;\n   // state记录FutureTask的状态\n   this.state = NEW;       // ensure visibility of callable\n}\n\npublic FutureTask(Runnable runnable, V result) {\n       //将给定的runnable接口封装成Callable类，\n       this.callable = Executors.callable(runnable, result);\n       this.state = NEW;       // ensure visibility of callable\n}\n\n</code></pre>\n<h3 id=\"FutureTask中run函数\"><a href=\"#FutureTask中run函数\" class=\"headerlink\" title=\"FutureTask中run函数\"></a>FutureTask中run函数</h3><p>在newTaskFor()新建一个ftask对象之后，会通过execute(ftask)执行该任务。此时ftask被当作一个Runnable对象进行执行，最终会调用到它的run()方法:源码如下：</p>\n<pre><code class=\"java\">public void run() {\n   //判断当前任务的状态\n   if (state != NEW ||\n       !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                    null, Thread.currentThread()))\n       return;\n   try {\n       // 将callable对象赋值给c。\n       Callable&lt;V&gt; c = callable;\n       if (c != null &amp;&amp; state == NEW) {\n           V result;\n           boolean ran;\n           try {\n               // 执行Callable的call()方法，并保存结果到result中。\n               result = c.call();\n               ran = true;\n           } catch (Throwable ex) {\n               result = null;\n               ran = false;\n               setException(ex);\n           }\n           // 如果运行成功，则将result保存\n           if (ran)\n               set(result);\n       }\n   } finally {\n       runner = null;\n       // 设置“state状态标记”\n       int s = state;\n       if (s &gt;= INTERRUPTING)\n           handlePossibleCancellationInterrupt(s);\n   }\n}\n</code></pre>\n<p><strong>说明</strong>：run()中会执行Callable对象的call()方法，并且最终将结果保存到result中，并通过set(result)将result保存。 之后调用FutureTask的get()方法，返回的就是通过set(result)保存的值。</p>\n<h3 id=\"FutureTask中get函数\"><a href=\"#FutureTask中get函数\" class=\"headerlink\" title=\"FutureTask中get函数\"></a>FutureTask中get函数</h3><p>get是用来得到任务执行的结果，如果任务没有执行完成，就会暂停当前任务的执行</p>\n<pre><code class=\"java\">public V get() throws InterruptedException, ExecutionException {\n       int s = state;\n       if (s &lt;= COMPLETING)\n           s = awaitDone(false, 0L);\n       return report(s);\n   }\n\n</code></pre>\n<p>从上面代码可以看出，get是调用awaitDone来阻塞当前线程。源码如下</p>\n<pre><code class=\"java\">   private int awaitDone(boolean timed, long nanos)\n       throws InterruptedException {\n       //得到截止时间\n       final long deadline = timed ? System.nanoTime() + nanos : 0L;\n       WaitNode q = null;\n       boolean queued = false;\n       //循环判断，知道任务执行完成\n       for (;;) {\n           //删除中断的等待结果返回线程\n           if (Thread.interrupted()) {\n               removeWaiter(q);\n               throw new InterruptedException();\n           }\n\n           //得到任务状态\n           int s = state;\n           //如果是以完成状态，则返回结果\n           if (s &gt; COMPLETING) {\n               if (q != null)\n                   q.thread = null;\n               return s;\n           }\n           //如果是正在执行状态，当前线程让出cpu\n           else if (s == COMPLETING) // cannot time out yet\n               Thread.yield();\n           //创建新的等待节点\n           else if (q == null)\n               q = new WaitNode();\n           //将等待节点插入等待队列\n           else if (!queued)\n               queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                    q.next = waiters, q);\n           //如果是有等待时间限制的\n           else if (timed) {\n               nanos = deadline - System.nanoTime();\n               //过了等待时间，则删除等待对应的等待节点\n               if (nanos &lt;= 0L) {\n                   removeWaiter(q);\n                   return state;\n               }\n               //阻塞当前线程\n               LockSupport.parkNanos(this, nanos);\n           }\n           else\n               LockSupport.park(this);\n       }\n   }\n</code></pre>\n<p>分析：</p>\n<p>上面代码可以阻塞调用线程的执行，但是线程的唤醒是不在这里面的。其实这样设计是对的，任务是否执行完成，Future是无法决定的，只要执行这个任务的线程才知道，所以就把唤醒线程的代码放在run方法里面，但是为什么刚刚没有在run里面看到呢，是因为封装在finishCompletion这个方法里面，而这个方法的调用是由set和setExecption俩个方法调用，源码如下：</p>\n<pre><code class=\"java\">   //任务执行完成，设置执行结果，并设置当前任务状态   \nprotected void set(V v) {\n       if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n           outcome = v;\n           UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n           //唤醒所有等待的此任务完成的线程\n           finishCompletion();\n       }\n   }\n   //此方法和上面的set方法执行流程一样，只是改变当前任务的状态时异常状态\n   protected void setException(Throwable t) {\n       if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n           outcome = t;\n           UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n           finishCompletion();\n       }\n   }\n   //唤醒锁等带此任务执行完成的线程\n   private void finishCompletion() {\n       // assert state &gt; COMPLETING;\n       for (WaitNode q; (q = waiters) != null;) {\n           if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n               for (;;) {\n                   Thread t = q.thread;\n                   if (t != null) {\n                       q.thread = null;\n                       LockSupport.unpark(t);\n                   }\n                   WaitNode next = q.next;\n                   if (next == null)\n                       break;\n                   q.next = null; // unlink to help gc\n                   q = next;\n               }\n               break;\n           }\n       }\n       //这个方法是一个空方法，如果希望任务执行完成后调用一个类似于callback回调，继承此类，\n       //然后封装此方法\n       done();\n\n       callable = null;        // to reduce footprint\n   }\n</code></pre>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-JUC线程池之04-Future-和Callable\"><a href=\"#java多线程系列-JUC线程池之04-Future-和Callable\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之04 Future 和Callable\"></a>java多线程系列-JUC线程池之04 Future 和Callable</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>Callable和Future简介</li>\n<li>ThreadPoolExecutor中submit分析</li>\n<li>FutureTask源码分析</li>\n</ol>\n</blockquote>\n<h3 id=\"1-Callable-和-Future-简介\"><a href=\"#1-Callable-和-Future-简介\" class=\"headerlink\" title=\"1. Callable 和 Future 简介\"></a>1. Callable 和 Future 简介</h3><blockquote>\n<p>Executor框架使用Runnable作为其基本的任务表示形式。Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。</p>\n<p>许多任务实际上都是存在延迟的计算—执行数据库插叙，从网络上获取资源，或者计算某个复杂的功能，对于这些任务，Callable是一种更好的抽象：他认为主入口点（即call）将返回一个值，并可能抛出一个异常。</p>\n<p>在Executor中包含了一些辅助的方法能将其他类型的任务封装为一个Callabe。</p>\n<p>Runnable和Callable描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确的起始点，并且最终会结束。Executor执行的任务有4个声明周期阶段：创建、提交、开始和完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于哪些已经开始执行的任务，只能当他们响应中断时，才能取消。</p>\n<p>Future表示一个任务额声明周期，并定义相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。并且在Future规范中的隐含意义是，任务声明周期只能前进，不能后退，就像ExecutorService的生命周期一样。当某个任务完成后，他就永远停留在完成状态上。</p>\n<p><strong>1. Callable</strong></p>\n<p>Callable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。</p>\n<p>为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。</p>\n<p>Callable的源码如下：</p>\n<pre><code>public interface Callable&lt;V&gt; {\n   V call() throws Exception;\n}\n</code></pre><p><strong>说明</strong>：从中我们可以看出Callable支持泛型。 </p>\n<p><strong>2. Future</strong></p>\n<p>Future 是一个接口。它用于表示异步计算的结果。提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。</p>\n<p>Future的源码如下：</p>\n<pre><code class=\"java\">public interface Future&lt;V&gt; {\n   // 试图取消对此任务的执行。\n   boolean     cancel(boolean mayInterruptIfRunning)\n\n   // 如果在任务正常完成前将其取消，则返回 true。\n   boolean     isCancelled()\n\n   // 如果任务已完成，则返回 true。\n   boolean     isDone()\n\n   // 如有必要，等待计算完成，然后获取其结果。\n   V           get() throws InterruptedException, ExecutionException;\n\n   // 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。\n   V       get(long timeout, TimeUnit unit)\n         throws InterruptedException, ExecutionException, TimeoutException;\n}\n</code></pre>\n</blockquote>\n<h3 id=\"2-ThreadPoolExecutor中submit分析\"><a href=\"#2-ThreadPoolExecutor中submit分析\" class=\"headerlink\" title=\"2. ThreadPoolExecutor中submit分析\"></a>2. ThreadPoolExecutor中submit分析</h3><blockquote>\n<p>前面我们已经对ThreadPoolExecutor中execute进行了分析，在execute中执行的任务是没有返回结果。这在很大程度上限制了这个方法的使用，因此在ExecutorService中提供了submit方法，可以在任务执行完成后返回结果，这个方法有三个重载方法，源码如下：</p>\n<pre><code class=\"java\">   //执行Runnable接口，返回一个没有任何结果的Future\n   public Future&lt;?&gt; submit(Runnable task) {\n       if (task == null) throw new NullPointerException();\n       RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);\n       execute(ftask);\n       return ftask;\n   }\n   //执行Runnable接口，并返回一个带有result结果的Future\n   public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {\n       if (task == null) throw new NullPointerException();\n       RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);\n       execute(ftask);\n       return ftask;\n   }\n\n      //执行Callable接口，并返回Future对象\n   public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {\n       if (task == null) throw new NullPointerException();\n       RunnableFuture&lt;T&gt; ftask = newTaskFor(task);\n       execute(ftask);\n       return ftask;\n   }\n</code></pre>\n<p>通过看上面的代码，大体上代码的结构都是相同的，首先通过newTaskFor方法创建一个RunnableFuture对象，然后使用execute执行这个任务。</p>\n<p>下面我们看一下newTaskFor这个方法，这个方法也包括俩个重载的方法，源码如下</p>\n<pre><code class=\"java\">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {\n    return new FutureTask&lt;T&gt;(runnable, value);\n}\n\nprotected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {\n     return new FutureTask&lt;T&gt;(callable);\n}\n</code></pre>\n<p>这个方法是将提供的Runnable和Callable接口封装在FutureTask内，然后返回一个RunnableFuture对象，事实上，FutureTask实现了RunnablFuture这个接口。</p>\n</blockquote>\n<p>###3.  FutureTask源码分析</p>\n<blockquote>\n<p>Future继承体系如下</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>Future表示一个任务的状态有以下几种，</p>\n<pre><code>NEW      ：任务新创建状态   \nCOMPLETING  ：任务完成状态\nNORMAL         ：正常完成状态\nEXCEPTIONAL ：异常完成状态\nCANCELLED    ：取消状态\nINTERRUPTING ：正在中断状态\nINTERRUPTED  ：已经被中断状态\n</code></pre><p>状态只能从一个状态转变到另外一个状态，不能后退，状态的转换大致上有以下几种：</p>\n<pre><code>NEW -&gt; COMPLETING -&gt; NORMAL\nNEW -&gt; COMPLETING -&gt; EXCEPTIONAL\nNEW -&gt; CANCELLED\nNEW -&gt; INTERRUPTING -&gt; INTERRUPTED\n</code></pre><h3 id=\"FutureTask构造函数\"><a href=\"#FutureTask构造函数\" class=\"headerlink\" title=\"FutureTask构造函数\"></a>FutureTask构造函数</h3><pre><code class=\"java\">public FutureTask(Callable&lt;V&gt; callable) {\n   if (callable == null)\n       throw new NullPointerException();\n   // callable是一个Callable对象\n   this.callable = callable;\n   // state记录FutureTask的状态\n   this.state = NEW;       // ensure visibility of callable\n}\n\npublic FutureTask(Runnable runnable, V result) {\n       //将给定的runnable接口封装成Callable类，\n       this.callable = Executors.callable(runnable, result);\n       this.state = NEW;       // ensure visibility of callable\n}\n\n</code></pre>\n<h3 id=\"FutureTask中run函数\"><a href=\"#FutureTask中run函数\" class=\"headerlink\" title=\"FutureTask中run函数\"></a>FutureTask中run函数</h3><p>在newTaskFor()新建一个ftask对象之后，会通过execute(ftask)执行该任务。此时ftask被当作一个Runnable对象进行执行，最终会调用到它的run()方法:源码如下：</p>\n<pre><code class=\"java\">public void run() {\n   //判断当前任务的状态\n   if (state != NEW ||\n       !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                    null, Thread.currentThread()))\n       return;\n   try {\n       // 将callable对象赋值给c。\n       Callable&lt;V&gt; c = callable;\n       if (c != null &amp;&amp; state == NEW) {\n           V result;\n           boolean ran;\n           try {\n               // 执行Callable的call()方法，并保存结果到result中。\n               result = c.call();\n               ran = true;\n           } catch (Throwable ex) {\n               result = null;\n               ran = false;\n               setException(ex);\n           }\n           // 如果运行成功，则将result保存\n           if (ran)\n               set(result);\n       }\n   } finally {\n       runner = null;\n       // 设置“state状态标记”\n       int s = state;\n       if (s &gt;= INTERRUPTING)\n           handlePossibleCancellationInterrupt(s);\n   }\n}\n</code></pre>\n<p><strong>说明</strong>：run()中会执行Callable对象的call()方法，并且最终将结果保存到result中，并通过set(result)将result保存。 之后调用FutureTask的get()方法，返回的就是通过set(result)保存的值。</p>\n<h3 id=\"FutureTask中get函数\"><a href=\"#FutureTask中get函数\" class=\"headerlink\" title=\"FutureTask中get函数\"></a>FutureTask中get函数</h3><p>get是用来得到任务执行的结果，如果任务没有执行完成，就会暂停当前任务的执行</p>\n<pre><code class=\"java\">public V get() throws InterruptedException, ExecutionException {\n       int s = state;\n       if (s &lt;= COMPLETING)\n           s = awaitDone(false, 0L);\n       return report(s);\n   }\n\n</code></pre>\n<p>从上面代码可以看出，get是调用awaitDone来阻塞当前线程。源码如下</p>\n<pre><code class=\"java\">   private int awaitDone(boolean timed, long nanos)\n       throws InterruptedException {\n       //得到截止时间\n       final long deadline = timed ? System.nanoTime() + nanos : 0L;\n       WaitNode q = null;\n       boolean queued = false;\n       //循环判断，知道任务执行完成\n       for (;;) {\n           //删除中断的等待结果返回线程\n           if (Thread.interrupted()) {\n               removeWaiter(q);\n               throw new InterruptedException();\n           }\n\n           //得到任务状态\n           int s = state;\n           //如果是以完成状态，则返回结果\n           if (s &gt; COMPLETING) {\n               if (q != null)\n                   q.thread = null;\n               return s;\n           }\n           //如果是正在执行状态，当前线程让出cpu\n           else if (s == COMPLETING) // cannot time out yet\n               Thread.yield();\n           //创建新的等待节点\n           else if (q == null)\n               q = new WaitNode();\n           //将等待节点插入等待队列\n           else if (!queued)\n               queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                    q.next = waiters, q);\n           //如果是有等待时间限制的\n           else if (timed) {\n               nanos = deadline - System.nanoTime();\n               //过了等待时间，则删除等待对应的等待节点\n               if (nanos &lt;= 0L) {\n                   removeWaiter(q);\n                   return state;\n               }\n               //阻塞当前线程\n               LockSupport.parkNanos(this, nanos);\n           }\n           else\n               LockSupport.park(this);\n       }\n   }\n</code></pre>\n<p>分析：</p>\n<p>上面代码可以阻塞调用线程的执行，但是线程的唤醒是不在这里面的。其实这样设计是对的，任务是否执行完成，Future是无法决定的，只要执行这个任务的线程才知道，所以就把唤醒线程的代码放在run方法里面，但是为什么刚刚没有在run里面看到呢，是因为封装在finishCompletion这个方法里面，而这个方法的调用是由set和setExecption俩个方法调用，源码如下：</p>\n<pre><code class=\"java\">   //任务执行完成，设置执行结果，并设置当前任务状态   \nprotected void set(V v) {\n       if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n           outcome = v;\n           UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n           //唤醒所有等待的此任务完成的线程\n           finishCompletion();\n       }\n   }\n   //此方法和上面的set方法执行流程一样，只是改变当前任务的状态时异常状态\n   protected void setException(Throwable t) {\n       if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n           outcome = t;\n           UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n           finishCompletion();\n       }\n   }\n   //唤醒锁等带此任务执行完成的线程\n   private void finishCompletion() {\n       // assert state &gt; COMPLETING;\n       for (WaitNode q; (q = waiters) != null;) {\n           if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n               for (;;) {\n                   Thread t = q.thread;\n                   if (t != null) {\n                       q.thread = null;\n                       LockSupport.unpark(t);\n                   }\n                   WaitNode next = q.next;\n                   if (next == null)\n                       break;\n                   q.next = null; // unlink to help gc\n                   q = next;\n               }\n               break;\n           }\n       }\n       //这个方法是一个空方法，如果希望任务执行完成后调用一个类似于callback回调，继承此类，\n       //然后封装此方法\n       done();\n\n       callable = null;        // to reduce footprint\n   }\n</code></pre>\n</blockquote>\n"},{"abbrlink":21,"title":"Spring源码分析之 02IOC原理","author":"枫秀天涯","date":"2019-01-06T19:35:00.000Z","_content":"# Spring源码解析之 02 IOC原理\n\n### 概述\n\n1. Ioc理论背景\n2. 什么是控制反转 (IoC)\n3.  Ioc能做什么\n4. Ioc和DI的关系\n\n在研究spring源码之前我们首先需要搞明白一个概念，也就是Ioc，中文意思控制反转，从字面是看不出来这是什么，可以用来干嘛。但是spring的基础就是Ioc，如果理解不了Ioc，也就谈不上对spring的源码分析。所以首先我们要搞明白Ioc。\n\n<!-- more -->\n\n### Ioc理论背景\n\n我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由 N 个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。\n\n![软件系统中耦合的对象](/images/pasted-1.png)\n\n图 1：软件系统中耦合的对象\n\n如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。\n\n图 1 中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。\n\n齿轮组中齿轮之间的啮合关系, 与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。\n\n\n\n![对象之间复杂的依赖关系](/images/pasted-2.png)\n\n\n\n图 2：对象之间复杂的依赖关系\n\n耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。**为了解决对象之间的耦合度过高的问题**，软件专家 Michael Mattson 提出了 IOC 理论，用来实现对象之间的 “解耦”，目前这个理论已经被成功地应用到实践当中，很多的 J2EE 项目均采用了 IOC 框架产品 Spring。\n\n### 什么是控制反转 (IoC)\n\nIoc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：\n\n1. 谁控制谁\n2. 控制什么\n3. 为何是反转\n4. 哪些方面反转了\n\n先以一个例子来阐述这个概念：\n\n已找女朋友为例（对于程序猿来说这个值得探究的问题）。一般情况下我们是如何来找女朋友的呢？首先我们需要根据自己的需求（漂亮、身材好、性格好）找一个妹子，然后到处打听她的兴趣爱好、微信、电话号码，然后各种投其所好送其所要，最后追到手。如下：\n\n```java\n/**\n * 年轻小伙子\n */\npublic class YoungMan {\n    private BeautifulGirl beautifulGirl;\n\n    YoungMan(){\n        // 可能你比较牛逼，指腹为婚\n        // beautifulGirl = new BeautifulGirl();\n    }\n\n    public void setBeautifulGirl(BeautifulGirl beautifulGirl) {\n        this.beautifulGirl = beautifulGirl;\n    }\n\n    public static void main(String[] args){\n        YoungMan you = new YoungMan();\n        BeautifulGirl beautifulGirl = new BeautifulGirl(\"你的各种条件\");\n        beautifulGirl.setxxx(\"各种投其所好\");\n\n        // 然后你有女票了\n        you.setBeautifulGirl(beautifulGirl);\n    }\n}\n```\n\n这就是我们通常做事的方式，如果我们需要某个对象，一般都是采用这种直接创建的方式(`new BeautifulGirl()`)，这个过程复杂而又繁琐，而且我们必须要面对每个环节，同时使用完成之后我们还要负责销毁它，在这种情况下我们的对象与它所依赖的对象耦合在一起。\n\n其实我们需要思考一个问题？我们每次用到自己依赖的对象真的需要自己去创建吗？我们知道，我们依赖对象其实并不是依赖该对象本身，而是依赖它所提供的服务，只要在我们需要它的时候，它能够及时提供服务即可，至于它是我们主动去创建的还是别人送给我们的，其实并不是那么重要。再说了，相比于自己千辛万苦去创建它还要管理、善后而言，直接有人送过来是不是显得更加好呢？\n\n这个给我们送东西的**人 **就是 IoC，在上面的例子中，它就相当于一个婚介公司，作为一个婚介公司它管理着很多男男女女的资料，当我们需要一个女朋友的时候，直接跟婚介公司提出我们的需求，婚介公司则会根据我们的需求提供一个妹子给我们，我们只需要负责谈恋爱，生猴子就行了。你看，这样是不是很简单明了。\n\n诚然，作为婚介公司的 IoC 帮我们省略了找女朋友的繁杂过程，将原来的主动寻找变成了现在的被动接受（符合我们的要求），更加简洁轻便。你想啊，原来你还得鞍马前后，各种巴结，什么东西都需要自己去亲力亲为，现在好了，直接有人把现成的送过来，多么美妙的事情啊。所以，简单点说，IoC 的理念就是**让别人为你服务**，如下图（摘自Spring揭秘）：\n\n![IOC service ](/images/pasted-5.png)\n\n在没有引入 IoC 的时候，被注入的对象直接依赖于被依赖的对象，有了 IoC 后，两者及其他们的关系都是通过 Ioc Service Provider 来统一管理维护的。被注入的对象需要什么，直接跟 IoC Service Provider 打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到 IOC Service Provider 为被注入对象服务的目的。**所以 IoC 就是这么简单！原来是需要什么东西自己去拿，现在是需要什么东西让别人（IOC Service Provider）送过来**\n\n现在在看上面那四个问题，答案就显得非常明显了:\n\n1. **谁控制谁**：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。\n2. **控制什么**：那就是主要控制了外部资源获取（不只是对象包括比如文件等）。\n3. **为何是反转**：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。\n4. **哪些方面反转了**：所依赖对象的获取被反转了。\n\n妹子有了，但是如何拥有妹子呢？这也是一门学问。\n\n1. 可能你比较牛逼，刚刚出生的时候就指腹为婚了。\n2. 大多数情况我们还是会考虑自己想要什么样的妹子，所以还是需要向婚介公司打招呼的。\n3. 还有一种情况就是，你根本就不知道自己想要什么样的妹子，直接跟婚介公司说，我就要一个这样的妹子。\n\n所以，IOC Service Provider 为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、stter方法注入、接口注入。\n\n**构造器注入**\n\n构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。\n\n```java\nYoungMan(BeautifulGirl beautifulGirl){\n        this.beautifulGirl = beautifulGirl;\n}\n```\n\n构造器注入方式比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你指定了你媳妇。\n\n**setter 方法注入**\n\n对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下：\n\n```java\npublic class YoungMan {\n    private BeautifulGirl beautifulGirl;\n\n    public void setBeautifulGirl(BeautifulGirl beautifulGirl) {\n        this.beautifulGirl = beautifulGirl;\n    }\n}\n```\n\n相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼，你可以要林志玲款式的，赵丽颖款式的，甚至凤姐哪款的，随意性较强。\n\n**接口方式注入**\n\n接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。\n\n### Ioc 能做什么\n\nIoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。\n\n其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。\n\nIoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。\n\n### Ioc和DI的关系\n\nDI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。\n\n理解DI的关键是：**“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”**，那我们来深入分析一下：\n\n●**谁依赖于谁：**当然是应用程序依赖于IoC容器；\n\n●**为什么需要依赖：**应用程序需要IoC容器来提供对象需要的外部资源；\n\n●**谁注入谁：**很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；\n\n**●注入了什么：**就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。\n\nIoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，**“依赖注入” 明确描述了“被注入对象依赖IoC容器配置依赖对象”**。\n\n注：如果想要更加深入的了解IoC和DI，请参考大师级人物Martin Fowler的一篇经典文章《Inversion of Control Containers and the Dependency Injection pattern》，[原文地址](http://www.martinfowler.com/articles/injection.html)。\n\n### 参考\n\n1. [ Java 中高级面试题中的 Spring 的 IOC 原理](https://www.toutiao.com/a6532225433423839757/?tt_from=weixin&utm_campaign=client_share&timestamp=1532168308&app=news_article&utm_source=weixin&iid=38522641144&utm_medium=toutiao_android&wxshare_count=1)\n2.  [【死磕 Spring】—– IOC 之深入理解 Spring IoC](http://cmsblogs.com/?p=2652)\n3.  [ IoC 之 2.1 IoC基础 ——跟我学Spring3](https://jinnianshilongnian.iteye.com/blog/1413846)","source":"_posts/spring 源码分析/spring/spring源码解析之  02IOC原理.md","raw":"abbrlink: 21\ntitle: Spring源码分析之 02IOC原理\ntags:\n  - spring源码解析\n  - ''\ncategories:\n  - spring\nauthor: 枫秀天涯\ndate: 2019-01-07 03:35:00\n---\n# Spring源码解析之 02 IOC原理\n\n### 概述\n\n1. Ioc理论背景\n2. 什么是控制反转 (IoC)\n3.  Ioc能做什么\n4. Ioc和DI的关系\n\n在研究spring源码之前我们首先需要搞明白一个概念，也就是Ioc，中文意思控制反转，从字面是看不出来这是什么，可以用来干嘛。但是spring的基础就是Ioc，如果理解不了Ioc，也就谈不上对spring的源码分析。所以首先我们要搞明白Ioc。\n\n<!-- more -->\n\n### Ioc理论背景\n\n我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由 N 个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。\n\n![软件系统中耦合的对象](/images/pasted-1.png)\n\n图 1：软件系统中耦合的对象\n\n如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。\n\n图 1 中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。\n\n齿轮组中齿轮之间的啮合关系, 与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。\n\n\n\n![对象之间复杂的依赖关系](/images/pasted-2.png)\n\n\n\n图 2：对象之间复杂的依赖关系\n\n耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。**为了解决对象之间的耦合度过高的问题**，软件专家 Michael Mattson 提出了 IOC 理论，用来实现对象之间的 “解耦”，目前这个理论已经被成功地应用到实践当中，很多的 J2EE 项目均采用了 IOC 框架产品 Spring。\n\n### 什么是控制反转 (IoC)\n\nIoc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：\n\n1. 谁控制谁\n2. 控制什么\n3. 为何是反转\n4. 哪些方面反转了\n\n先以一个例子来阐述这个概念：\n\n已找女朋友为例（对于程序猿来说这个值得探究的问题）。一般情况下我们是如何来找女朋友的呢？首先我们需要根据自己的需求（漂亮、身材好、性格好）找一个妹子，然后到处打听她的兴趣爱好、微信、电话号码，然后各种投其所好送其所要，最后追到手。如下：\n\n```java\n/**\n * 年轻小伙子\n */\npublic class YoungMan {\n    private BeautifulGirl beautifulGirl;\n\n    YoungMan(){\n        // 可能你比较牛逼，指腹为婚\n        // beautifulGirl = new BeautifulGirl();\n    }\n\n    public void setBeautifulGirl(BeautifulGirl beautifulGirl) {\n        this.beautifulGirl = beautifulGirl;\n    }\n\n    public static void main(String[] args){\n        YoungMan you = new YoungMan();\n        BeautifulGirl beautifulGirl = new BeautifulGirl(\"你的各种条件\");\n        beautifulGirl.setxxx(\"各种投其所好\");\n\n        // 然后你有女票了\n        you.setBeautifulGirl(beautifulGirl);\n    }\n}\n```\n\n这就是我们通常做事的方式，如果我们需要某个对象，一般都是采用这种直接创建的方式(`new BeautifulGirl()`)，这个过程复杂而又繁琐，而且我们必须要面对每个环节，同时使用完成之后我们还要负责销毁它，在这种情况下我们的对象与它所依赖的对象耦合在一起。\n\n其实我们需要思考一个问题？我们每次用到自己依赖的对象真的需要自己去创建吗？我们知道，我们依赖对象其实并不是依赖该对象本身，而是依赖它所提供的服务，只要在我们需要它的时候，它能够及时提供服务即可，至于它是我们主动去创建的还是别人送给我们的，其实并不是那么重要。再说了，相比于自己千辛万苦去创建它还要管理、善后而言，直接有人送过来是不是显得更加好呢？\n\n这个给我们送东西的**人 **就是 IoC，在上面的例子中，它就相当于一个婚介公司，作为一个婚介公司它管理着很多男男女女的资料，当我们需要一个女朋友的时候，直接跟婚介公司提出我们的需求，婚介公司则会根据我们的需求提供一个妹子给我们，我们只需要负责谈恋爱，生猴子就行了。你看，这样是不是很简单明了。\n\n诚然，作为婚介公司的 IoC 帮我们省略了找女朋友的繁杂过程，将原来的主动寻找变成了现在的被动接受（符合我们的要求），更加简洁轻便。你想啊，原来你还得鞍马前后，各种巴结，什么东西都需要自己去亲力亲为，现在好了，直接有人把现成的送过来，多么美妙的事情啊。所以，简单点说，IoC 的理念就是**让别人为你服务**，如下图（摘自Spring揭秘）：\n\n![IOC service ](/images/pasted-5.png)\n\n在没有引入 IoC 的时候，被注入的对象直接依赖于被依赖的对象，有了 IoC 后，两者及其他们的关系都是通过 Ioc Service Provider 来统一管理维护的。被注入的对象需要什么，直接跟 IoC Service Provider 打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到 IOC Service Provider 为被注入对象服务的目的。**所以 IoC 就是这么简单！原来是需要什么东西自己去拿，现在是需要什么东西让别人（IOC Service Provider）送过来**\n\n现在在看上面那四个问题，答案就显得非常明显了:\n\n1. **谁控制谁**：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。\n2. **控制什么**：那就是主要控制了外部资源获取（不只是对象包括比如文件等）。\n3. **为何是反转**：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。\n4. **哪些方面反转了**：所依赖对象的获取被反转了。\n\n妹子有了，但是如何拥有妹子呢？这也是一门学问。\n\n1. 可能你比较牛逼，刚刚出生的时候就指腹为婚了。\n2. 大多数情况我们还是会考虑自己想要什么样的妹子，所以还是需要向婚介公司打招呼的。\n3. 还有一种情况就是，你根本就不知道自己想要什么样的妹子，直接跟婚介公司说，我就要一个这样的妹子。\n\n所以，IOC Service Provider 为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、stter方法注入、接口注入。\n\n**构造器注入**\n\n构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。\n\n```java\nYoungMan(BeautifulGirl beautifulGirl){\n        this.beautifulGirl = beautifulGirl;\n}\n```\n\n构造器注入方式比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你指定了你媳妇。\n\n**setter 方法注入**\n\n对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下：\n\n```java\npublic class YoungMan {\n    private BeautifulGirl beautifulGirl;\n\n    public void setBeautifulGirl(BeautifulGirl beautifulGirl) {\n        this.beautifulGirl = beautifulGirl;\n    }\n}\n```\n\n相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼，你可以要林志玲款式的，赵丽颖款式的，甚至凤姐哪款的，随意性较强。\n\n**接口方式注入**\n\n接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。\n\n### Ioc 能做什么\n\nIoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。\n\n其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。\n\nIoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。\n\n### Ioc和DI的关系\n\nDI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。\n\n理解DI的关键是：**“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”**，那我们来深入分析一下：\n\n●**谁依赖于谁：**当然是应用程序依赖于IoC容器；\n\n●**为什么需要依赖：**应用程序需要IoC容器来提供对象需要的外部资源；\n\n●**谁注入谁：**很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；\n\n**●注入了什么：**就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。\n\nIoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，**“依赖注入” 明确描述了“被注入对象依赖IoC容器配置依赖对象”**。\n\n注：如果想要更加深入的了解IoC和DI，请参考大师级人物Martin Fowler的一篇经典文章《Inversion of Control Containers and the Dependency Injection pattern》，[原文地址](http://www.martinfowler.com/articles/injection.html)。\n\n### 参考\n\n1. [ Java 中高级面试题中的 Spring 的 IOC 原理](https://www.toutiao.com/a6532225433423839757/?tt_from=weixin&utm_campaign=client_share&timestamp=1532168308&app=news_article&utm_source=weixin&iid=38522641144&utm_medium=toutiao_android&wxshare_count=1)\n2.  [【死磕 Spring】—– IOC 之深入理解 Spring IoC](http://cmsblogs.com/?p=2652)\n3.  [ IoC 之 2.1 IoC基础 ——跟我学Spring3](https://jinnianshilongnian.iteye.com/blog/1413846)","slug":"spring 源码分析/spring/spring源码解析之  02IOC原理","published":1,"updated":"2019-01-14T05:03:34.074Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovw100449q1u66tro3gy","content":"<h1 id=\"Spring源码解析之-02-IOC原理\"><a href=\"#Spring源码解析之-02-IOC原理\" class=\"headerlink\" title=\"Spring源码解析之 02 IOC原理\"></a>Spring源码解析之 02 IOC原理</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>Ioc理论背景</li>\n<li>什么是控制反转 (IoC)</li>\n<li>Ioc能做什么</li>\n<li>Ioc和DI的关系</li>\n</ol>\n<p>在研究spring源码之前我们首先需要搞明白一个概念，也就是Ioc，中文意思控制反转，从字面是看不出来这是什么，可以用来干嘛。但是spring的基础就是Ioc，如果理解不了Ioc，也就谈不上对spring的源码分析。所以首先我们要搞明白Ioc。</p>\n<a id=\"more\"></a>\n<h3 id=\"Ioc理论背景\"><a href=\"#Ioc理论背景\" class=\"headerlink\" title=\"Ioc理论背景\"></a>Ioc理论背景</h3><p>我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由 N 个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。</p>\n<p><img src=\"/images/pasted-1.png\" alt=\"软件系统中耦合的对象\"></p>\n<p>图 1：软件系统中耦合的对象</p>\n<p>如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。</p>\n<p>图 1 中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。</p>\n<p>齿轮组中齿轮之间的啮合关系, 与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。</p>\n<p><img src=\"/images/pasted-2.png\" alt=\"对象之间复杂的依赖关系\"></p>\n<p>图 2：对象之间复杂的依赖关系</p>\n<p>耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。<strong>为了解决对象之间的耦合度过高的问题</strong>，软件专家 Michael Mattson 提出了 IOC 理论，用来实现对象之间的 “解耦”，目前这个理论已经被成功地应用到实践当中，很多的 J2EE 项目均采用了 IOC 框架产品 Spring。</p>\n<h3 id=\"什么是控制反转-IoC\"><a href=\"#什么是控制反转-IoC\" class=\"headerlink\" title=\"什么是控制反转 (IoC)\"></a>什么是控制反转 (IoC)</h3><p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：</p>\n<ol>\n<li>谁控制谁</li>\n<li>控制什么</li>\n<li>为何是反转</li>\n<li>哪些方面反转了</li>\n</ol>\n<p>先以一个例子来阐述这个概念：</p>\n<p>已找女朋友为例（对于程序猿来说这个值得探究的问题）。一般情况下我们是如何来找女朋友的呢？首先我们需要根据自己的需求（漂亮、身材好、性格好）找一个妹子，然后到处打听她的兴趣爱好、微信、电话号码，然后各种投其所好送其所要，最后追到手。如下：</p>\n<pre><code class=\"java\">/**\n * 年轻小伙子\n */\npublic class YoungMan {\n    private BeautifulGirl beautifulGirl;\n\n    YoungMan(){\n        // 可能你比较牛逼，指腹为婚\n        // beautifulGirl = new BeautifulGirl();\n    }\n\n    public void setBeautifulGirl(BeautifulGirl beautifulGirl) {\n        this.beautifulGirl = beautifulGirl;\n    }\n\n    public static void main(String[] args){\n        YoungMan you = new YoungMan();\n        BeautifulGirl beautifulGirl = new BeautifulGirl(&quot;你的各种条件&quot;);\n        beautifulGirl.setxxx(&quot;各种投其所好&quot;);\n\n        // 然后你有女票了\n        you.setBeautifulGirl(beautifulGirl);\n    }\n}\n</code></pre>\n<p>这就是我们通常做事的方式，如果我们需要某个对象，一般都是采用这种直接创建的方式(<code>new BeautifulGirl()</code>)，这个过程复杂而又繁琐，而且我们必须要面对每个环节，同时使用完成之后我们还要负责销毁它，在这种情况下我们的对象与它所依赖的对象耦合在一起。</p>\n<p>其实我们需要思考一个问题？我们每次用到自己依赖的对象真的需要自己去创建吗？我们知道，我们依赖对象其实并不是依赖该对象本身，而是依赖它所提供的服务，只要在我们需要它的时候，它能够及时提供服务即可，至于它是我们主动去创建的还是别人送给我们的，其实并不是那么重要。再说了，相比于自己千辛万苦去创建它还要管理、善后而言，直接有人送过来是不是显得更加好呢？</p>\n<p>这个给我们送东西的<strong>人 </strong>就是 IoC，在上面的例子中，它就相当于一个婚介公司，作为一个婚介公司它管理着很多男男女女的资料，当我们需要一个女朋友的时候，直接跟婚介公司提出我们的需求，婚介公司则会根据我们的需求提供一个妹子给我们，我们只需要负责谈恋爱，生猴子就行了。你看，这样是不是很简单明了。</p>\n<p>诚然，作为婚介公司的 IoC 帮我们省略了找女朋友的繁杂过程，将原来的主动寻找变成了现在的被动接受（符合我们的要求），更加简洁轻便。你想啊，原来你还得鞍马前后，各种巴结，什么东西都需要自己去亲力亲为，现在好了，直接有人把现成的送过来，多么美妙的事情啊。所以，简单点说，IoC 的理念就是<strong>让别人为你服务</strong>，如下图（摘自Spring揭秘）：</p>\n<p><img src=\"/images/pasted-5.png\" alt=\"IOC service \"></p>\n<p>在没有引入 IoC 的时候，被注入的对象直接依赖于被依赖的对象，有了 IoC 后，两者及其他们的关系都是通过 Ioc Service Provider 来统一管理维护的。被注入的对象需要什么，直接跟 IoC Service Provider 打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到 IOC Service Provider 为被注入对象服务的目的。<strong>所以 IoC 就是这么简单！原来是需要什么东西自己去拿，现在是需要什么东西让别人（IOC Service Provider）送过来</strong></p>\n<p>现在在看上面那四个问题，答案就显得非常明显了:</p>\n<ol>\n<li><strong>谁控制谁</strong>：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。</li>\n<li><strong>控制什么</strong>：那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</li>\n<li><strong>为何是反转</strong>：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li>\n<li><strong>哪些方面反转了</strong>：所依赖对象的获取被反转了。</li>\n</ol>\n<p>妹子有了，但是如何拥有妹子呢？这也是一门学问。</p>\n<ol>\n<li>可能你比较牛逼，刚刚出生的时候就指腹为婚了。</li>\n<li>大多数情况我们还是会考虑自己想要什么样的妹子，所以还是需要向婚介公司打招呼的。</li>\n<li>还有一种情况就是，你根本就不知道自己想要什么样的妹子，直接跟婚介公司说，我就要一个这样的妹子。</li>\n</ol>\n<p>所以，IOC Service Provider 为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、stter方法注入、接口注入。</p>\n<p><strong>构造器注入</strong></p>\n<p>构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。</p>\n<pre><code class=\"java\">YoungMan(BeautifulGirl beautifulGirl){\n        this.beautifulGirl = beautifulGirl;\n}\n</code></pre>\n<p>构造器注入方式比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你指定了你媳妇。</p>\n<p><strong>setter 方法注入</strong></p>\n<p>对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下：</p>\n<pre><code class=\"java\">public class YoungMan {\n    private BeautifulGirl beautifulGirl;\n\n    public void setBeautifulGirl(BeautifulGirl beautifulGirl) {\n        this.beautifulGirl = beautifulGirl;\n    }\n}\n</code></pre>\n<p>相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼，你可以要林志玲款式的，赵丽颖款式的，甚至凤姐哪款的，随意性较强。</p>\n<p><strong>接口方式注入</strong></p>\n<p>接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。</p>\n<h3 id=\"Ioc-能做什么\"><a href=\"#Ioc-能做什么\" class=\"headerlink\" title=\"Ioc 能做什么\"></a>Ioc 能做什么</h3><p>IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>\n<p>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p>\n<p>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p>\n<h3 id=\"Ioc和DI的关系\"><a href=\"#Ioc和DI的关系\" class=\"headerlink\" title=\"Ioc和DI的关系\"></a>Ioc和DI的关系</h3><p>DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>\n<p>理解DI的关键是：<strong>“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”</strong>，那我们来深入分析一下：</p>\n<p>●<strong>谁依赖于谁：</strong>当然是应用程序依赖于IoC容器；</p>\n<p>●<strong>为什么需要依赖：</strong>应用程序需要IoC容器来提供对象需要的外部资源；</p>\n<p>●<strong>谁注入谁：</strong>很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</p>\n<p><strong>●注入了什么：</strong>就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>\n<p>IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，<strong>“依赖注入” 明确描述了“被注入对象依赖IoC容器配置依赖对象”</strong>。</p>\n<p>注：如果想要更加深入的了解IoC和DI，请参考大师级人物Martin Fowler的一篇经典文章《Inversion of Control Containers and the Dependency Injection pattern》，<a href=\"http://www.martinfowler.com/articles/injection.html\" target=\"_blank\" rel=\"noopener\">原文地址</a>。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://www.toutiao.com/a6532225433423839757/?tt_from=weixin&amp;utm_campaign=client_share&amp;timestamp=1532168308&amp;app=news_article&amp;utm_source=weixin&amp;iid=38522641144&amp;utm_medium=toutiao_android&amp;wxshare_count=1\" target=\"_blank\" rel=\"noopener\"> Java 中高级面试题中的 Spring 的 IOC 原理</a></li>\n<li><a href=\"http://cmsblogs.com/?p=2652\" target=\"_blank\" rel=\"noopener\">【死磕 Spring】—– IOC 之深入理解 Spring IoC</a></li>\n<li><a href=\"https://jinnianshilongnian.iteye.com/blog/1413846\" target=\"_blank\" rel=\"noopener\"> IoC 之 2.1 IoC基础 ——跟我学Spring3</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"Spring源码解析之-02-IOC原理\"><a href=\"#Spring源码解析之-02-IOC原理\" class=\"headerlink\" title=\"Spring源码解析之 02 IOC原理\"></a>Spring源码解析之 02 IOC原理</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>Ioc理论背景</li>\n<li>什么是控制反转 (IoC)</li>\n<li>Ioc能做什么</li>\n<li>Ioc和DI的关系</li>\n</ol>\n<p>在研究spring源码之前我们首先需要搞明白一个概念，也就是Ioc，中文意思控制反转，从字面是看不出来这是什么，可以用来干嘛。但是spring的基础就是Ioc，如果理解不了Ioc，也就谈不上对spring的源码分析。所以首先我们要搞明白Ioc。</p>","more":"<h3 id=\"Ioc理论背景\"><a href=\"#Ioc理论背景\" class=\"headerlink\" title=\"Ioc理论背景\"></a>Ioc理论背景</h3><p>我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由 N 个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。</p>\n<p><img src=\"/images/pasted-1.png\" alt=\"软件系统中耦合的对象\"></p>\n<p>图 1：软件系统中耦合的对象</p>\n<p>如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。</p>\n<p>图 1 中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。</p>\n<p>齿轮组中齿轮之间的啮合关系, 与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。</p>\n<p><img src=\"/images/pasted-2.png\" alt=\"对象之间复杂的依赖关系\"></p>\n<p>图 2：对象之间复杂的依赖关系</p>\n<p>耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。<strong>为了解决对象之间的耦合度过高的问题</strong>，软件专家 Michael Mattson 提出了 IOC 理论，用来实现对象之间的 “解耦”，目前这个理论已经被成功地应用到实践当中，很多的 J2EE 项目均采用了 IOC 框架产品 Spring。</p>\n<h3 id=\"什么是控制反转-IoC\"><a href=\"#什么是控制反转-IoC\" class=\"headerlink\" title=\"什么是控制反转 (IoC)\"></a>什么是控制反转 (IoC)</h3><p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：</p>\n<ol>\n<li>谁控制谁</li>\n<li>控制什么</li>\n<li>为何是反转</li>\n<li>哪些方面反转了</li>\n</ol>\n<p>先以一个例子来阐述这个概念：</p>\n<p>已找女朋友为例（对于程序猿来说这个值得探究的问题）。一般情况下我们是如何来找女朋友的呢？首先我们需要根据自己的需求（漂亮、身材好、性格好）找一个妹子，然后到处打听她的兴趣爱好、微信、电话号码，然后各种投其所好送其所要，最后追到手。如下：</p>\n<pre><code class=\"java\">/**\n * 年轻小伙子\n */\npublic class YoungMan {\n    private BeautifulGirl beautifulGirl;\n\n    YoungMan(){\n        // 可能你比较牛逼，指腹为婚\n        // beautifulGirl = new BeautifulGirl();\n    }\n\n    public void setBeautifulGirl(BeautifulGirl beautifulGirl) {\n        this.beautifulGirl = beautifulGirl;\n    }\n\n    public static void main(String[] args){\n        YoungMan you = new YoungMan();\n        BeautifulGirl beautifulGirl = new BeautifulGirl(&quot;你的各种条件&quot;);\n        beautifulGirl.setxxx(&quot;各种投其所好&quot;);\n\n        // 然后你有女票了\n        you.setBeautifulGirl(beautifulGirl);\n    }\n}\n</code></pre>\n<p>这就是我们通常做事的方式，如果我们需要某个对象，一般都是采用这种直接创建的方式(<code>new BeautifulGirl()</code>)，这个过程复杂而又繁琐，而且我们必须要面对每个环节，同时使用完成之后我们还要负责销毁它，在这种情况下我们的对象与它所依赖的对象耦合在一起。</p>\n<p>其实我们需要思考一个问题？我们每次用到自己依赖的对象真的需要自己去创建吗？我们知道，我们依赖对象其实并不是依赖该对象本身，而是依赖它所提供的服务，只要在我们需要它的时候，它能够及时提供服务即可，至于它是我们主动去创建的还是别人送给我们的，其实并不是那么重要。再说了，相比于自己千辛万苦去创建它还要管理、善后而言，直接有人送过来是不是显得更加好呢？</p>\n<p>这个给我们送东西的<strong>人 </strong>就是 IoC，在上面的例子中，它就相当于一个婚介公司，作为一个婚介公司它管理着很多男男女女的资料，当我们需要一个女朋友的时候，直接跟婚介公司提出我们的需求，婚介公司则会根据我们的需求提供一个妹子给我们，我们只需要负责谈恋爱，生猴子就行了。你看，这样是不是很简单明了。</p>\n<p>诚然，作为婚介公司的 IoC 帮我们省略了找女朋友的繁杂过程，将原来的主动寻找变成了现在的被动接受（符合我们的要求），更加简洁轻便。你想啊，原来你还得鞍马前后，各种巴结，什么东西都需要自己去亲力亲为，现在好了，直接有人把现成的送过来，多么美妙的事情啊。所以，简单点说，IoC 的理念就是<strong>让别人为你服务</strong>，如下图（摘自Spring揭秘）：</p>\n<p><img src=\"/images/pasted-5.png\" alt=\"IOC service \"></p>\n<p>在没有引入 IoC 的时候，被注入的对象直接依赖于被依赖的对象，有了 IoC 后，两者及其他们的关系都是通过 Ioc Service Provider 来统一管理维护的。被注入的对象需要什么，直接跟 IoC Service Provider 打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到 IOC Service Provider 为被注入对象服务的目的。<strong>所以 IoC 就是这么简单！原来是需要什么东西自己去拿，现在是需要什么东西让别人（IOC Service Provider）送过来</strong></p>\n<p>现在在看上面那四个问题，答案就显得非常明显了:</p>\n<ol>\n<li><strong>谁控制谁</strong>：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。</li>\n<li><strong>控制什么</strong>：那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</li>\n<li><strong>为何是反转</strong>：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li>\n<li><strong>哪些方面反转了</strong>：所依赖对象的获取被反转了。</li>\n</ol>\n<p>妹子有了，但是如何拥有妹子呢？这也是一门学问。</p>\n<ol>\n<li>可能你比较牛逼，刚刚出生的时候就指腹为婚了。</li>\n<li>大多数情况我们还是会考虑自己想要什么样的妹子，所以还是需要向婚介公司打招呼的。</li>\n<li>还有一种情况就是，你根本就不知道自己想要什么样的妹子，直接跟婚介公司说，我就要一个这样的妹子。</li>\n</ol>\n<p>所以，IOC Service Provider 为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、stter方法注入、接口注入。</p>\n<p><strong>构造器注入</strong></p>\n<p>构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。</p>\n<pre><code class=\"java\">YoungMan(BeautifulGirl beautifulGirl){\n        this.beautifulGirl = beautifulGirl;\n}\n</code></pre>\n<p>构造器注入方式比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你指定了你媳妇。</p>\n<p><strong>setter 方法注入</strong></p>\n<p>对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下：</p>\n<pre><code class=\"java\">public class YoungMan {\n    private BeautifulGirl beautifulGirl;\n\n    public void setBeautifulGirl(BeautifulGirl beautifulGirl) {\n        this.beautifulGirl = beautifulGirl;\n    }\n}\n</code></pre>\n<p>相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼，你可以要林志玲款式的，赵丽颖款式的，甚至凤姐哪款的，随意性较强。</p>\n<p><strong>接口方式注入</strong></p>\n<p>接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。</p>\n<h3 id=\"Ioc-能做什么\"><a href=\"#Ioc-能做什么\" class=\"headerlink\" title=\"Ioc 能做什么\"></a>Ioc 能做什么</h3><p>IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>\n<p>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p>\n<p>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p>\n<h3 id=\"Ioc和DI的关系\"><a href=\"#Ioc和DI的关系\" class=\"headerlink\" title=\"Ioc和DI的关系\"></a>Ioc和DI的关系</h3><p>DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>\n<p>理解DI的关键是：<strong>“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”</strong>，那我们来深入分析一下：</p>\n<p>●<strong>谁依赖于谁：</strong>当然是应用程序依赖于IoC容器；</p>\n<p>●<strong>为什么需要依赖：</strong>应用程序需要IoC容器来提供对象需要的外部资源；</p>\n<p>●<strong>谁注入谁：</strong>很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</p>\n<p><strong>●注入了什么：</strong>就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>\n<p>IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，<strong>“依赖注入” 明确描述了“被注入对象依赖IoC容器配置依赖对象”</strong>。</p>\n<p>注：如果想要更加深入的了解IoC和DI，请参考大师级人物Martin Fowler的一篇经典文章《Inversion of Control Containers and the Dependency Injection pattern》，<a href=\"http://www.martinfowler.com/articles/injection.html\" target=\"_blank\" rel=\"noopener\">原文地址</a>。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://www.toutiao.com/a6532225433423839757/?tt_from=weixin&amp;utm_campaign=client_share&amp;timestamp=1532168308&amp;app=news_article&amp;utm_source=weixin&amp;iid=38522641144&amp;utm_medium=toutiao_android&amp;wxshare_count=1\" target=\"_blank\" rel=\"noopener\"> Java 中高级面试题中的 Spring 的 IOC 原理</a></li>\n<li><a href=\"http://cmsblogs.com/?p=2652\" target=\"_blank\" rel=\"noopener\">【死磕 Spring】—– IOC 之深入理解 Spring IoC</a></li>\n<li><a href=\"https://jinnianshilongnian.iteye.com/blog/1413846\" target=\"_blank\" rel=\"noopener\"> IoC 之 2.1 IoC基础 ——跟我学Spring3</a></li>\n</ol>"},{"abbrlink":23,"title":"spring 源码解析之 04（上）加载bean","author":"fengxiutianya","date":"2019-01-13T20:46:00.000Z","_content":"# spring 源码解析之 04（上）加载bean\n\n### 概述\n\n1. spring 容器整体介绍\n2. 源码分析：loadBeanDefinitions具体实现\n<!-- more-->\n\n### spring容器整体介绍\n\n先看一段熟悉的代码\n\n```java\nBeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"sample02.xml\"));\n```\n\n这段代码时用来获取IOC容器，只不过现在spring已经不推介这样使用，这种使用方式和下面这段代码其实是一样的效果，而且实现其实也是一样的，只是上面的封装的更加简洁。\n\n```java\nClassPathResource resource = new ClassPathResource(\"bean.xml\");\nDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\nXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\nreader.loadBeanDefinitions(resource);\n```\n\n至于为什么说上下俩段代码实现是一样的，在后面分析源码时你就会明白。\n\n现在我们首先看看上面代码具体干了些什么\n\n- 创建资源对象（这里还不能确定资源是否存在，在前面spring统一资源加载中有说过为什么）\n- 创建 BeanFactory容器\n- 根据新建的 BeanFactory 创建一个BeanDefinitionReader对象，该Reader 对象为资源的解析器\n- 解析资源 整个过程就分为三个步骤：资源定位、装载、注册，如下：\n  - **资源定位**。我们一般用外部资源来描述 Bean 对象，所以在初始化 IOC 容器的第一步就是需要定位这个外部资源。在上一篇博客已经详细说明了资源加载的过程。\n  - **装载**。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IOC 容器的内部数据结构：BeanDefinition。在 IOC 容器内部维护着一个 BeanDefinition Map 的数据结构，在配置文件中每一个 `<bean>` 都对应着一个BeanDefinition对象。\n  - **注册**。向IOC容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistry 接口来实现的。在 IOC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IOC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。在这里需要注意的一点是这个过程并没有完成依赖注入，依赖注册是发生在应用第一次调用 `getBean()` 向容器索要 Bean 时。当然我们可以通过设置预处理，即对某个 Bean 设置 lazyinit 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。 资源定位在前面已经分析了，下面我们会直接分析加载。\n\n在分析具体代码之前，我们这俩先来一个整体介绍，有助于后面的理解\n\n1. DefaultListableBeanFactory\n\n   DefaultListableBeanFactory是整个bean加载核心部分，是spring注册及加载bean的默认实现，DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory并实现了ConfigurableListableBeanFactory以及BeanDefinitionRegistry接口。下面是DefaultListableBeanFactory继承关系图。\n\n   ![DefaultListableBeanFactory](/images/pasted-9.png)\n\n   这里先简单介绍一下上面类图中各个类的作用\n\n   * AliasRegistry: 定义对alias的简单增删改操作，也就是定义对别名的操作。\n   * SimpleAliasRegistry:主要使用map最为alias的缓存，并实现接口AliasRegistry。\n   * SingletonBeanRegistry：定义对单例的注册及获取。\n   * BeanFactory：定义获取bean及bean的各种属性。\n   * DefaultSingletonBeanRegistry：实现接口SingletonBeanRegistry\n   * HierarchicalBeanFactory:继承BeanFactory，在此基础上增加了BeanFactory继承体系，增加了对parentFactory的支持\n   * BeanDefinitionRegistry：定义对BeanDefinition的各种增删改操作。\n   * FactoryBeanRegistrySupport：继承DefaultSingletonBeanRegistry，并在此基础上增加了对FactoryBean的特殊处理功能。\n   * ConfigurableBeanFactory：提供配置BeanFactory的各种方法。\n   * ListableBeanFactory：根据各种条件获取bean的配置清单\n   * AbstractBeanFactory：综合FactoryBeanRegistrySupport和ConfigurableBeanFactory的功能，提供默认实现，方便后面实现\n   * AutowireCapableBeanFactory:提供创建bean、自动注入、初始化以及应用bean的后处理器(也就是扩展bean，在spring官方文档中提到过，容器的扩展点，也就是在创建bean前后对bean的处理）。\n   * AbstractAutowireCapableBeanFactory:继承AbstractBeanFactory并实现AutowireCapableBeanFactory\n   * ConfigurableListableBeanFactory：BeanFactory配置清单，指定忽略类型及接口等。\n   * DefaultListableBeanFactory：综合上面所有功能，主要是对bean注册后的处理。\n\n   在进行源码分析之前，先来解决上面遗留的一个问题，也就是上面俩段代码为什么说实现是一样的？\n\n   XmlBeanFactory 是继承字自DefaultListableBeanFactory，而继承中只添加了一个属性XmlBeanDefinitionReader类型reader属性，然后利用此reader加载bean。具体代码如下\n\n   ```java\n   public class XmlBeanFactory extends DefaultListableBeanFactory {\n   \tprivate final XmlBeanDefinitionReader reader = new \n           \t\t\t\tXmlBeanDefinitionReader(this);\n   \tpublic XmlBeanFactory(Resource resource) throws BeansException {\n   \t\tthis(resource, null);\n   \t}\n   \n   \tpublic XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) \n     \t\t\tthrows BeansException {\n           \n   \t\tsuper(parentBeanFactory);\n   \t\t// 解析资源\n   \t\tthis.reader.loadBeanDefinitions(resource);\n   \t}\n   }\n   ```\n\n   通过上面的分析可以看出，XmlBeanFactory就是帮我们写的四步合并成一步直接实现。\n\n   ### 源码分析：loadBeanDefinitions具体实现\n\n   `reader.loadBeanDefinitions(resource)` 才是加载资源的真正实现，所以我们直接从该方法入手。\n\n   ```java\n       public int loadBeanDefinitions(Resource resource)\n       \t\tthrows BeanDefinitionStoreException {\n           return loadBeanDefinitions(new EncodedResource(resource));\n       }\n   ```\n\n   从指定的 xml 文件加载 Bean Definition，这里会先对 Resource 资源封装成 EncodedResource。这里为什么需要将 Resource 封装成 EncodedResource呢？主要是为了对 Resource 进行编码，保证内容读取的正确性。封装成 EncodedResource 后，调用`loadBeanDefinitions()`，这个方法才是真正的逻辑实现。如下：\n\n   ```java\n       public int loadBeanDefinitions(EncodedResource encodedResource) \n       \t\t\tthrows BeanDefinitionStoreException {\n           Assert.notNull(encodedResource, \"EncodedResource must not be null\");\n           if (logger.isInfoEnabled()) {\n               logger.info(\"Loading XML bean definitions from \" \n                           \t+ encodedResource.getResource());\n           }\n   \n           // 获取已经加载过的资源\n           Set<EncodedResource> currentResources = \n               \t\tthis.resourcesCurrentlyBeingLoaded.get();\n           if (currentResources == null) {\n               currentResources = new HashSet<>(4);\n               this.resourcesCurrentlyBeingLoaded.set(currentResources);\n           }\n   \n           // 将当前资源加入记录中\n           if (!currentResources.add(encodedResource)) {\n               throw new BeanDefinitionStoreException(\n                       \"Detected cyclic loading of \" + encodedResource \n                   \t\t\t+ \" - check your import definitions!\");\n           }\n           try {\n        // 从 EncodedResource 获取封装的 Resource 并从 Resource 中获取其中的 InputStream\n               InputStream inputStream = \n                   \t\tencodedResource.getResource().getInputStream();\n               try {\n                   InputSource inputSource = new InputSource(inputStream);\n                   // 设置编码\n                   if (encodedResource.getEncoding() != null) {\n                       inputSource.setEncoding(encodedResource.getEncoding());\n                   }\n                   // 核心逻辑部分\n                   return doLoadBeanDefinitions(inputSource, \n                                                encodedResource.getResource());\n               }\n               finally {\n                   inputStream.close();\n               }\n           }\n           catch (IOException ex) {\n               throw new BeanDefinitionStoreException(\n                       \"IOException parsing XML document from \" + \n                   \t\tencodedResource.getResource(), ex);\n           }\n           finally {\n               // 从缓存中剔除该资源\n               currentResources.remove(encodedResource);\n               if (currentResources.isEmpty()) {\n                   this.resourcesCurrentlyBeingLoaded.remove();\n               }\n           }\n       }\n   ```\n\n   首先通过`resourcesCurrentlyBeingLoaded.get()` 来获取已经加载过的资源，然后将 encodedResource 加入其中，如果 resourcesCurrentlyBeingLoaded 中已经存在该资源，则抛出 BeanDefinitionStoreException 异常。完成后从 encodedResource 获取封装的 Resource 资源并从 Resource 中获取相应的 InputStream ，最后将 InputStream 封装为 InputSource 调用 `doLoadBeanDefinitions()`。方法 `doLoadBeanDefinitions()` 为从 xml 文件中加载 Bean Definition 的真正逻辑，如下:\n\n   ```java\n   protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n               throws BeanDefinitionStoreException {\n           try {\n               // 获取 Document 实例\n               Document doc = doLoadDocument(inputSource, resource);\n               // 根据 Document 实例注册 Bean信息\n               return registerBeanDefinitions(doc, resource);\n           }\n           catch (BeanDefinitionStoreException ex) {\n               throw ex;\n           }\n           catch (SAXParseException ex) {\n               throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                       \"Line \" + ex.getLineNumber() + \" in XML document from \" + resource + \" is invalid\", ex);\n           }\n           catch (SAXException ex) {\n               throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                       \"XML document from \" + resource + \" is invalid\", ex);\n           }\n           catch (ParserConfigurationException ex) {\n               throw new BeanDefinitionStoreException(resource.getDescription(),\n                       \"Parser configuration exception parsing XML from \" + resource, ex);\n           }\n           catch (IOException ex) {\n               throw new BeanDefinitionStoreException(resource.getDescription(),\n                       \"IOException parsing XML document from \" + resource, ex);\n           }\n           catch (Throwable ex) {\n               throw new BeanDefinitionStoreException(resource.getDescription(),\n                       \"Unexpected exception parsing XML document from \" + resource, ex);\n           }\n       }\n   ```\n\n   核心部分就是 try 块的两行代码。\n\n   1. 调用 `doLoadDocument()` 方法，根据 xml 文件获取 Document 实例。\n   2. 根据获取的 Document 实例注册 Bean 信息。\n\n   其实在`doLoadDocument()`方法内部还获取了 xml 文件的验证模式。如下:\n\n   ```\n       protected Document doLoadDocument(InputSource inputSource, Resource resource) \n       \tthrows Exception {\n           return this.documentLoader.loadDocument(inputSource, getEntityResolver(), \n           this.errorHandler,getValidationModeForResource(resource),isNamespaceAware());\n       }\n   ```\n\n   调用`getValidationModeForResource()` 获取指定资源（xml）的验证模式。所以 `doLoadBeanDefinitions()`主要就是做了三件事情。\n\n   1. 调用 `getValidationModeForResource()` 获取 xml 文件的验证模式\n   2. 调用 `loadDocument()` 根据 xml 文件获取相应的 Document 实例。\n   3. 调用 `registerBeanDefinitions()` 注册 Bean 实例。","source":"_posts/spring 源码分析/spring/spring源码解析之  04（上）加载bean.md","raw":"abbrlink: 23\ntitle: spring 源码解析之 04（上）加载bean\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-14 04:46:00\n---\n# spring 源码解析之 04（上）加载bean\n\n### 概述\n\n1. spring 容器整体介绍\n2. 源码分析：loadBeanDefinitions具体实现\n<!-- more-->\n\n### spring容器整体介绍\n\n先看一段熟悉的代码\n\n```java\nBeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"sample02.xml\"));\n```\n\n这段代码时用来获取IOC容器，只不过现在spring已经不推介这样使用，这种使用方式和下面这段代码其实是一样的效果，而且实现其实也是一样的，只是上面的封装的更加简洁。\n\n```java\nClassPathResource resource = new ClassPathResource(\"bean.xml\");\nDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\nXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\nreader.loadBeanDefinitions(resource);\n```\n\n至于为什么说上下俩段代码实现是一样的，在后面分析源码时你就会明白。\n\n现在我们首先看看上面代码具体干了些什么\n\n- 创建资源对象（这里还不能确定资源是否存在，在前面spring统一资源加载中有说过为什么）\n- 创建 BeanFactory容器\n- 根据新建的 BeanFactory 创建一个BeanDefinitionReader对象，该Reader 对象为资源的解析器\n- 解析资源 整个过程就分为三个步骤：资源定位、装载、注册，如下：\n  - **资源定位**。我们一般用外部资源来描述 Bean 对象，所以在初始化 IOC 容器的第一步就是需要定位这个外部资源。在上一篇博客已经详细说明了资源加载的过程。\n  - **装载**。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IOC 容器的内部数据结构：BeanDefinition。在 IOC 容器内部维护着一个 BeanDefinition Map 的数据结构，在配置文件中每一个 `<bean>` 都对应着一个BeanDefinition对象。\n  - **注册**。向IOC容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistry 接口来实现的。在 IOC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IOC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。在这里需要注意的一点是这个过程并没有完成依赖注入，依赖注册是发生在应用第一次调用 `getBean()` 向容器索要 Bean 时。当然我们可以通过设置预处理，即对某个 Bean 设置 lazyinit 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。 资源定位在前面已经分析了，下面我们会直接分析加载。\n\n在分析具体代码之前，我们这俩先来一个整体介绍，有助于后面的理解\n\n1. DefaultListableBeanFactory\n\n   DefaultListableBeanFactory是整个bean加载核心部分，是spring注册及加载bean的默认实现，DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory并实现了ConfigurableListableBeanFactory以及BeanDefinitionRegistry接口。下面是DefaultListableBeanFactory继承关系图。\n\n   ![DefaultListableBeanFactory](/images/pasted-9.png)\n\n   这里先简单介绍一下上面类图中各个类的作用\n\n   * AliasRegistry: 定义对alias的简单增删改操作，也就是定义对别名的操作。\n   * SimpleAliasRegistry:主要使用map最为alias的缓存，并实现接口AliasRegistry。\n   * SingletonBeanRegistry：定义对单例的注册及获取。\n   * BeanFactory：定义获取bean及bean的各种属性。\n   * DefaultSingletonBeanRegistry：实现接口SingletonBeanRegistry\n   * HierarchicalBeanFactory:继承BeanFactory，在此基础上增加了BeanFactory继承体系，增加了对parentFactory的支持\n   * BeanDefinitionRegistry：定义对BeanDefinition的各种增删改操作。\n   * FactoryBeanRegistrySupport：继承DefaultSingletonBeanRegistry，并在此基础上增加了对FactoryBean的特殊处理功能。\n   * ConfigurableBeanFactory：提供配置BeanFactory的各种方法。\n   * ListableBeanFactory：根据各种条件获取bean的配置清单\n   * AbstractBeanFactory：综合FactoryBeanRegistrySupport和ConfigurableBeanFactory的功能，提供默认实现，方便后面实现\n   * AutowireCapableBeanFactory:提供创建bean、自动注入、初始化以及应用bean的后处理器(也就是扩展bean，在spring官方文档中提到过，容器的扩展点，也就是在创建bean前后对bean的处理）。\n   * AbstractAutowireCapableBeanFactory:继承AbstractBeanFactory并实现AutowireCapableBeanFactory\n   * ConfigurableListableBeanFactory：BeanFactory配置清单，指定忽略类型及接口等。\n   * DefaultListableBeanFactory：综合上面所有功能，主要是对bean注册后的处理。\n\n   在进行源码分析之前，先来解决上面遗留的一个问题，也就是上面俩段代码为什么说实现是一样的？\n\n   XmlBeanFactory 是继承字自DefaultListableBeanFactory，而继承中只添加了一个属性XmlBeanDefinitionReader类型reader属性，然后利用此reader加载bean。具体代码如下\n\n   ```java\n   public class XmlBeanFactory extends DefaultListableBeanFactory {\n   \tprivate final XmlBeanDefinitionReader reader = new \n           \t\t\t\tXmlBeanDefinitionReader(this);\n   \tpublic XmlBeanFactory(Resource resource) throws BeansException {\n   \t\tthis(resource, null);\n   \t}\n   \n   \tpublic XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) \n     \t\t\tthrows BeansException {\n           \n   \t\tsuper(parentBeanFactory);\n   \t\t// 解析资源\n   \t\tthis.reader.loadBeanDefinitions(resource);\n   \t}\n   }\n   ```\n\n   通过上面的分析可以看出，XmlBeanFactory就是帮我们写的四步合并成一步直接实现。\n\n   ### 源码分析：loadBeanDefinitions具体实现\n\n   `reader.loadBeanDefinitions(resource)` 才是加载资源的真正实现，所以我们直接从该方法入手。\n\n   ```java\n       public int loadBeanDefinitions(Resource resource)\n       \t\tthrows BeanDefinitionStoreException {\n           return loadBeanDefinitions(new EncodedResource(resource));\n       }\n   ```\n\n   从指定的 xml 文件加载 Bean Definition，这里会先对 Resource 资源封装成 EncodedResource。这里为什么需要将 Resource 封装成 EncodedResource呢？主要是为了对 Resource 进行编码，保证内容读取的正确性。封装成 EncodedResource 后，调用`loadBeanDefinitions()`，这个方法才是真正的逻辑实现。如下：\n\n   ```java\n       public int loadBeanDefinitions(EncodedResource encodedResource) \n       \t\t\tthrows BeanDefinitionStoreException {\n           Assert.notNull(encodedResource, \"EncodedResource must not be null\");\n           if (logger.isInfoEnabled()) {\n               logger.info(\"Loading XML bean definitions from \" \n                           \t+ encodedResource.getResource());\n           }\n   \n           // 获取已经加载过的资源\n           Set<EncodedResource> currentResources = \n               \t\tthis.resourcesCurrentlyBeingLoaded.get();\n           if (currentResources == null) {\n               currentResources = new HashSet<>(4);\n               this.resourcesCurrentlyBeingLoaded.set(currentResources);\n           }\n   \n           // 将当前资源加入记录中\n           if (!currentResources.add(encodedResource)) {\n               throw new BeanDefinitionStoreException(\n                       \"Detected cyclic loading of \" + encodedResource \n                   \t\t\t+ \" - check your import definitions!\");\n           }\n           try {\n        // 从 EncodedResource 获取封装的 Resource 并从 Resource 中获取其中的 InputStream\n               InputStream inputStream = \n                   \t\tencodedResource.getResource().getInputStream();\n               try {\n                   InputSource inputSource = new InputSource(inputStream);\n                   // 设置编码\n                   if (encodedResource.getEncoding() != null) {\n                       inputSource.setEncoding(encodedResource.getEncoding());\n                   }\n                   // 核心逻辑部分\n                   return doLoadBeanDefinitions(inputSource, \n                                                encodedResource.getResource());\n               }\n               finally {\n                   inputStream.close();\n               }\n           }\n           catch (IOException ex) {\n               throw new BeanDefinitionStoreException(\n                       \"IOException parsing XML document from \" + \n                   \t\tencodedResource.getResource(), ex);\n           }\n           finally {\n               // 从缓存中剔除该资源\n               currentResources.remove(encodedResource);\n               if (currentResources.isEmpty()) {\n                   this.resourcesCurrentlyBeingLoaded.remove();\n               }\n           }\n       }\n   ```\n\n   首先通过`resourcesCurrentlyBeingLoaded.get()` 来获取已经加载过的资源，然后将 encodedResource 加入其中，如果 resourcesCurrentlyBeingLoaded 中已经存在该资源，则抛出 BeanDefinitionStoreException 异常。完成后从 encodedResource 获取封装的 Resource 资源并从 Resource 中获取相应的 InputStream ，最后将 InputStream 封装为 InputSource 调用 `doLoadBeanDefinitions()`。方法 `doLoadBeanDefinitions()` 为从 xml 文件中加载 Bean Definition 的真正逻辑，如下:\n\n   ```java\n   protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n               throws BeanDefinitionStoreException {\n           try {\n               // 获取 Document 实例\n               Document doc = doLoadDocument(inputSource, resource);\n               // 根据 Document 实例注册 Bean信息\n               return registerBeanDefinitions(doc, resource);\n           }\n           catch (BeanDefinitionStoreException ex) {\n               throw ex;\n           }\n           catch (SAXParseException ex) {\n               throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                       \"Line \" + ex.getLineNumber() + \" in XML document from \" + resource + \" is invalid\", ex);\n           }\n           catch (SAXException ex) {\n               throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                       \"XML document from \" + resource + \" is invalid\", ex);\n           }\n           catch (ParserConfigurationException ex) {\n               throw new BeanDefinitionStoreException(resource.getDescription(),\n                       \"Parser configuration exception parsing XML from \" + resource, ex);\n           }\n           catch (IOException ex) {\n               throw new BeanDefinitionStoreException(resource.getDescription(),\n                       \"IOException parsing XML document from \" + resource, ex);\n           }\n           catch (Throwable ex) {\n               throw new BeanDefinitionStoreException(resource.getDescription(),\n                       \"Unexpected exception parsing XML document from \" + resource, ex);\n           }\n       }\n   ```\n\n   核心部分就是 try 块的两行代码。\n\n   1. 调用 `doLoadDocument()` 方法，根据 xml 文件获取 Document 实例。\n   2. 根据获取的 Document 实例注册 Bean 信息。\n\n   其实在`doLoadDocument()`方法内部还获取了 xml 文件的验证模式。如下:\n\n   ```\n       protected Document doLoadDocument(InputSource inputSource, Resource resource) \n       \tthrows Exception {\n           return this.documentLoader.loadDocument(inputSource, getEntityResolver(), \n           this.errorHandler,getValidationModeForResource(resource),isNamespaceAware());\n       }\n   ```\n\n   调用`getValidationModeForResource()` 获取指定资源（xml）的验证模式。所以 `doLoadBeanDefinitions()`主要就是做了三件事情。\n\n   1. 调用 `getValidationModeForResource()` 获取 xml 文件的验证模式\n   2. 调用 `loadDocument()` 根据 xml 文件获取相应的 Document 实例。\n   3. 调用 `registerBeanDefinitions()` 注册 Bean 实例。","slug":"spring 源码分析/spring/spring源码解析之  04（上）加载bean","published":1,"updated":"2019-01-15T03:38:27.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovw300469q1u1jxniz5i","content":"<h1 id=\"spring-源码解析之-04（上）加载bean\"><a href=\"#spring-源码解析之-04（上）加载bean\" class=\"headerlink\" title=\"spring 源码解析之 04（上）加载bean\"></a>spring 源码解析之 04（上）加载bean</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>spring 容器整体介绍</li>\n<li>源码分析：loadBeanDefinitions具体实现<a id=\"more\"></a>\n</li>\n</ol>\n<h3 id=\"spring容器整体介绍\"><a href=\"#spring容器整体介绍\" class=\"headerlink\" title=\"spring容器整体介绍\"></a>spring容器整体介绍</h3><p>先看一段熟悉的代码</p>\n<pre><code class=\"java\">BeanFactory bf = new XmlBeanFactory(new ClassPathResource(&quot;sample02.xml&quot;));\n</code></pre>\n<p>这段代码时用来获取IOC容器，只不过现在spring已经不推介这样使用，这种使用方式和下面这段代码其实是一样的效果，而且实现其实也是一样的，只是上面的封装的更加简洁。</p>\n<pre><code class=\"java\">ClassPathResource resource = new ClassPathResource(&quot;bean.xml&quot;);\nDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\nXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\nreader.loadBeanDefinitions(resource);\n</code></pre>\n<p>至于为什么说上下俩段代码实现是一样的，在后面分析源码时你就会明白。</p>\n<p>现在我们首先看看上面代码具体干了些什么</p>\n<ul>\n<li>创建资源对象（这里还不能确定资源是否存在，在前面spring统一资源加载中有说过为什么）</li>\n<li>创建 BeanFactory容器</li>\n<li>根据新建的 BeanFactory 创建一个BeanDefinitionReader对象，该Reader 对象为资源的解析器</li>\n<li>解析资源 整个过程就分为三个步骤：资源定位、装载、注册，如下：<ul>\n<li><strong>资源定位</strong>。我们一般用外部资源来描述 Bean 对象，所以在初始化 IOC 容器的第一步就是需要定位这个外部资源。在上一篇博客已经详细说明了资源加载的过程。</li>\n<li><strong>装载</strong>。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IOC 容器的内部数据结构：BeanDefinition。在 IOC 容器内部维护着一个 BeanDefinition Map 的数据结构，在配置文件中每一个 <code>&lt;bean&gt;</code> 都对应着一个BeanDefinition对象。</li>\n<li><strong>注册</strong>。向IOC容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistry 接口来实现的。在 IOC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IOC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。在这里需要注意的一点是这个过程并没有完成依赖注入，依赖注册是发生在应用第一次调用 <code>getBean()</code> 向容器索要 Bean 时。当然我们可以通过设置预处理，即对某个 Bean 设置 lazyinit 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。 资源定位在前面已经分析了，下面我们会直接分析加载。</li>\n</ul>\n</li>\n</ul>\n<p>在分析具体代码之前，我们这俩先来一个整体介绍，有助于后面的理解</p>\n<ol>\n<li><p>DefaultListableBeanFactory</p>\n<p>DefaultListableBeanFactory是整个bean加载核心部分，是spring注册及加载bean的默认实现，DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory并实现了ConfigurableListableBeanFactory以及BeanDefinitionRegistry接口。下面是DefaultListableBeanFactory继承关系图。</p>\n<p><img src=\"/images/pasted-9.png\" alt=\"DefaultListableBeanFactory\"></p>\n<p>这里先简单介绍一下上面类图中各个类的作用</p>\n<ul>\n<li>AliasRegistry: 定义对alias的简单增删改操作，也就是定义对别名的操作。</li>\n<li>SimpleAliasRegistry:主要使用map最为alias的缓存，并实现接口AliasRegistry。</li>\n<li>SingletonBeanRegistry：定义对单例的注册及获取。</li>\n<li>BeanFactory：定义获取bean及bean的各种属性。</li>\n<li>DefaultSingletonBeanRegistry：实现接口SingletonBeanRegistry</li>\n<li>HierarchicalBeanFactory:继承BeanFactory，在此基础上增加了BeanFactory继承体系，增加了对parentFactory的支持</li>\n<li>BeanDefinitionRegistry：定义对BeanDefinition的各种增删改操作。</li>\n<li>FactoryBeanRegistrySupport：继承DefaultSingletonBeanRegistry，并在此基础上增加了对FactoryBean的特殊处理功能。</li>\n<li>ConfigurableBeanFactory：提供配置BeanFactory的各种方法。</li>\n<li>ListableBeanFactory：根据各种条件获取bean的配置清单</li>\n<li>AbstractBeanFactory：综合FactoryBeanRegistrySupport和ConfigurableBeanFactory的功能，提供默认实现，方便后面实现</li>\n<li>AutowireCapableBeanFactory:提供创建bean、自动注入、初始化以及应用bean的后处理器(也就是扩展bean，在spring官方文档中提到过，容器的扩展点，也就是在创建bean前后对bean的处理）。</li>\n<li>AbstractAutowireCapableBeanFactory:继承AbstractBeanFactory并实现AutowireCapableBeanFactory</li>\n<li>ConfigurableListableBeanFactory：BeanFactory配置清单，指定忽略类型及接口等。</li>\n<li>DefaultListableBeanFactory：综合上面所有功能，主要是对bean注册后的处理。</li>\n</ul>\n<p>在进行源码分析之前，先来解决上面遗留的一个问题，也就是上面俩段代码为什么说实现是一样的？</p>\n<p>XmlBeanFactory 是继承字自DefaultListableBeanFactory，而继承中只添加了一个属性XmlBeanDefinitionReader类型reader属性，然后利用此reader加载bean。具体代码如下</p>\n<pre><code class=\"java\">public class XmlBeanFactory extends DefaultListableBeanFactory {\n    private final XmlBeanDefinitionReader reader = new \n                        XmlBeanDefinitionReader(this);\n    public XmlBeanFactory(Resource resource) throws BeansException {\n        this(resource, null);\n    }\n\n    public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) \n              throws BeansException {\n\n        super(parentBeanFactory);\n        // 解析资源\n        this.reader.loadBeanDefinitions(resource);\n    }\n}\n</code></pre>\n<p>通过上面的分析可以看出，XmlBeanFactory就是帮我们写的四步合并成一步直接实现。</p>\n<h3 id=\"源码分析：loadBeanDefinitions具体实现\"><a href=\"#源码分析：loadBeanDefinitions具体实现\" class=\"headerlink\" title=\"源码分析：loadBeanDefinitions具体实现\"></a>源码分析：loadBeanDefinitions具体实现</h3><p><code>reader.loadBeanDefinitions(resource)</code> 才是加载资源的真正实现，所以我们直接从该方法入手。</p>\n<pre><code class=\"java\">    public int loadBeanDefinitions(Resource resource)\n            throws BeanDefinitionStoreException {\n        return loadBeanDefinitions(new EncodedResource(resource));\n    }\n</code></pre>\n<p>从指定的 xml 文件加载 Bean Definition，这里会先对 Resource 资源封装成 EncodedResource。这里为什么需要将 Resource 封装成 EncodedResource呢？主要是为了对 Resource 进行编码，保证内容读取的正确性。封装成 EncodedResource 后，调用<code>loadBeanDefinitions()</code>，这个方法才是真正的逻辑实现。如下：</p>\n<pre><code class=\"java\">    public int loadBeanDefinitions(EncodedResource encodedResource) \n                throws BeanDefinitionStoreException {\n        Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);\n        if (logger.isInfoEnabled()) {\n            logger.info(&quot;Loading XML bean definitions from &quot; \n                            + encodedResource.getResource());\n        }\n\n        // 获取已经加载过的资源\n        Set&lt;EncodedResource&gt; currentResources = \n                    this.resourcesCurrentlyBeingLoaded.get();\n        if (currentResources == null) {\n            currentResources = new HashSet&lt;&gt;(4);\n            this.resourcesCurrentlyBeingLoaded.set(currentResources);\n        }\n\n        // 将当前资源加入记录中\n        if (!currentResources.add(encodedResource)) {\n            throw new BeanDefinitionStoreException(\n                    &quot;Detected cyclic loading of &quot; + encodedResource \n                            + &quot; - check your import definitions!&quot;);\n        }\n        try {\n     // 从 EncodedResource 获取封装的 Resource 并从 Resource 中获取其中的 InputStream\n            InputStream inputStream = \n                        encodedResource.getResource().getInputStream();\n            try {\n                InputSource inputSource = new InputSource(inputStream);\n                // 设置编码\n                if (encodedResource.getEncoding() != null) {\n                    inputSource.setEncoding(encodedResource.getEncoding());\n                }\n                // 核心逻辑部分\n                return doLoadBeanDefinitions(inputSource, \n                                             encodedResource.getResource());\n            }\n            finally {\n                inputStream.close();\n            }\n        }\n        catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\n                    &quot;IOException parsing XML document from &quot; + \n                        encodedResource.getResource(), ex);\n        }\n        finally {\n            // 从缓存中剔除该资源\n            currentResources.remove(encodedResource);\n            if (currentResources.isEmpty()) {\n                this.resourcesCurrentlyBeingLoaded.remove();\n            }\n        }\n    }\n</code></pre>\n<p>首先通过<code>resourcesCurrentlyBeingLoaded.get()</code> 来获取已经加载过的资源，然后将 encodedResource 加入其中，如果 resourcesCurrentlyBeingLoaded 中已经存在该资源，则抛出 BeanDefinitionStoreException 异常。完成后从 encodedResource 获取封装的 Resource 资源并从 Resource 中获取相应的 InputStream ，最后将 InputStream 封装为 InputSource 调用 <code>doLoadBeanDefinitions()</code>。方法 <code>doLoadBeanDefinitions()</code> 为从 xml 文件中加载 Bean Definition 的真正逻辑，如下:</p>\n<pre><code class=\"java\">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n            throws BeanDefinitionStoreException {\n        try {\n            // 获取 Document 实例\n            Document doc = doLoadDocument(inputSource, resource);\n            // 根据 Document 实例注册 Bean信息\n            return registerBeanDefinitions(doc, resource);\n        }\n        catch (BeanDefinitionStoreException ex) {\n            throw ex;\n        }\n        catch (SAXParseException ex) {\n            throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                    &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);\n        }\n        catch (SAXException ex) {\n            throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                    &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);\n        }\n        catch (ParserConfigurationException ex) {\n            throw new BeanDefinitionStoreException(resource.getDescription(),\n                    &quot;Parser configuration exception parsing XML from &quot; + resource, ex);\n        }\n        catch (IOException ex) {\n            throw new BeanDefinitionStoreException(resource.getDescription(),\n                    &quot;IOException parsing XML document from &quot; + resource, ex);\n        }\n        catch (Throwable ex) {\n            throw new BeanDefinitionStoreException(resource.getDescription(),\n                    &quot;Unexpected exception parsing XML document from &quot; + resource, ex);\n        }\n    }\n</code></pre>\n<p>核心部分就是 try 块的两行代码。</p>\n<ol>\n<li>调用 <code>doLoadDocument()</code> 方法，根据 xml 文件获取 Document 实例。</li>\n<li>根据获取的 Document 实例注册 Bean 信息。</li>\n</ol>\n<p>其实在<code>doLoadDocument()</code>方法内部还获取了 xml 文件的验证模式。如下:</p>\n<pre><code>    protected Document doLoadDocument(InputSource inputSource, Resource resource) \n        throws Exception {\n        return this.documentLoader.loadDocument(inputSource, getEntityResolver(), \n        this.errorHandler,getValidationModeForResource(resource),isNamespaceAware());\n    }\n</code></pre><p>调用<code>getValidationModeForResource()</code> 获取指定资源（xml）的验证模式。所以 <code>doLoadBeanDefinitions()</code>主要就是做了三件事情。</p>\n<ol>\n<li>调用 <code>getValidationModeForResource()</code> 获取 xml 文件的验证模式</li>\n<li>调用 <code>loadDocument()</code> 根据 xml 文件获取相应的 Document 实例。</li>\n<li>调用 <code>registerBeanDefinitions()</code> 注册 Bean 实例。</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring-源码解析之-04（上）加载bean\"><a href=\"#spring-源码解析之-04（上）加载bean\" class=\"headerlink\" title=\"spring 源码解析之 04（上）加载bean\"></a>spring 源码解析之 04（上）加载bean</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>spring 容器整体介绍</li>\n<li>源码分析：loadBeanDefinitions具体实现","more":"</li>\n</ol>\n<h3 id=\"spring容器整体介绍\"><a href=\"#spring容器整体介绍\" class=\"headerlink\" title=\"spring容器整体介绍\"></a>spring容器整体介绍</h3><p>先看一段熟悉的代码</p>\n<pre><code class=\"java\">BeanFactory bf = new XmlBeanFactory(new ClassPathResource(&quot;sample02.xml&quot;));\n</code></pre>\n<p>这段代码时用来获取IOC容器，只不过现在spring已经不推介这样使用，这种使用方式和下面这段代码其实是一样的效果，而且实现其实也是一样的，只是上面的封装的更加简洁。</p>\n<pre><code class=\"java\">ClassPathResource resource = new ClassPathResource(&quot;bean.xml&quot;);\nDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\nXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\nreader.loadBeanDefinitions(resource);\n</code></pre>\n<p>至于为什么说上下俩段代码实现是一样的，在后面分析源码时你就会明白。</p>\n<p>现在我们首先看看上面代码具体干了些什么</p>\n<ul>\n<li>创建资源对象（这里还不能确定资源是否存在，在前面spring统一资源加载中有说过为什么）</li>\n<li>创建 BeanFactory容器</li>\n<li>根据新建的 BeanFactory 创建一个BeanDefinitionReader对象，该Reader 对象为资源的解析器</li>\n<li>解析资源 整个过程就分为三个步骤：资源定位、装载、注册，如下：<ul>\n<li><strong>资源定位</strong>。我们一般用外部资源来描述 Bean 对象，所以在初始化 IOC 容器的第一步就是需要定位这个外部资源。在上一篇博客已经详细说明了资源加载的过程。</li>\n<li><strong>装载</strong>。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IOC 容器的内部数据结构：BeanDefinition。在 IOC 容器内部维护着一个 BeanDefinition Map 的数据结构，在配置文件中每一个 <code>&lt;bean&gt;</code> 都对应着一个BeanDefinition对象。</li>\n<li><strong>注册</strong>。向IOC容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistry 接口来实现的。在 IOC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IOC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。在这里需要注意的一点是这个过程并没有完成依赖注入，依赖注册是发生在应用第一次调用 <code>getBean()</code> 向容器索要 Bean 时。当然我们可以通过设置预处理，即对某个 Bean 设置 lazyinit 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。 资源定位在前面已经分析了，下面我们会直接分析加载。</li>\n</ul>\n</li>\n</ul>\n<p>在分析具体代码之前，我们这俩先来一个整体介绍，有助于后面的理解</p>\n<ol>\n<li><p>DefaultListableBeanFactory</p>\n<p>DefaultListableBeanFactory是整个bean加载核心部分，是spring注册及加载bean的默认实现，DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory并实现了ConfigurableListableBeanFactory以及BeanDefinitionRegistry接口。下面是DefaultListableBeanFactory继承关系图。</p>\n<p><img src=\"/images/pasted-9.png\" alt=\"DefaultListableBeanFactory\"></p>\n<p>这里先简单介绍一下上面类图中各个类的作用</p>\n<ul>\n<li>AliasRegistry: 定义对alias的简单增删改操作，也就是定义对别名的操作。</li>\n<li>SimpleAliasRegistry:主要使用map最为alias的缓存，并实现接口AliasRegistry。</li>\n<li>SingletonBeanRegistry：定义对单例的注册及获取。</li>\n<li>BeanFactory：定义获取bean及bean的各种属性。</li>\n<li>DefaultSingletonBeanRegistry：实现接口SingletonBeanRegistry</li>\n<li>HierarchicalBeanFactory:继承BeanFactory，在此基础上增加了BeanFactory继承体系，增加了对parentFactory的支持</li>\n<li>BeanDefinitionRegistry：定义对BeanDefinition的各种增删改操作。</li>\n<li>FactoryBeanRegistrySupport：继承DefaultSingletonBeanRegistry，并在此基础上增加了对FactoryBean的特殊处理功能。</li>\n<li>ConfigurableBeanFactory：提供配置BeanFactory的各种方法。</li>\n<li>ListableBeanFactory：根据各种条件获取bean的配置清单</li>\n<li>AbstractBeanFactory：综合FactoryBeanRegistrySupport和ConfigurableBeanFactory的功能，提供默认实现，方便后面实现</li>\n<li>AutowireCapableBeanFactory:提供创建bean、自动注入、初始化以及应用bean的后处理器(也就是扩展bean，在spring官方文档中提到过，容器的扩展点，也就是在创建bean前后对bean的处理）。</li>\n<li>AbstractAutowireCapableBeanFactory:继承AbstractBeanFactory并实现AutowireCapableBeanFactory</li>\n<li>ConfigurableListableBeanFactory：BeanFactory配置清单，指定忽略类型及接口等。</li>\n<li>DefaultListableBeanFactory：综合上面所有功能，主要是对bean注册后的处理。</li>\n</ul>\n<p>在进行源码分析之前，先来解决上面遗留的一个问题，也就是上面俩段代码为什么说实现是一样的？</p>\n<p>XmlBeanFactory 是继承字自DefaultListableBeanFactory，而继承中只添加了一个属性XmlBeanDefinitionReader类型reader属性，然后利用此reader加载bean。具体代码如下</p>\n<pre><code class=\"java\">public class XmlBeanFactory extends DefaultListableBeanFactory {\n    private final XmlBeanDefinitionReader reader = new \n                        XmlBeanDefinitionReader(this);\n    public XmlBeanFactory(Resource resource) throws BeansException {\n        this(resource, null);\n    }\n\n    public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) \n              throws BeansException {\n\n        super(parentBeanFactory);\n        // 解析资源\n        this.reader.loadBeanDefinitions(resource);\n    }\n}\n</code></pre>\n<p>通过上面的分析可以看出，XmlBeanFactory就是帮我们写的四步合并成一步直接实现。</p>\n<h3 id=\"源码分析：loadBeanDefinitions具体实现\"><a href=\"#源码分析：loadBeanDefinitions具体实现\" class=\"headerlink\" title=\"源码分析：loadBeanDefinitions具体实现\"></a>源码分析：loadBeanDefinitions具体实现</h3><p><code>reader.loadBeanDefinitions(resource)</code> 才是加载资源的真正实现，所以我们直接从该方法入手。</p>\n<pre><code class=\"java\">    public int loadBeanDefinitions(Resource resource)\n            throws BeanDefinitionStoreException {\n        return loadBeanDefinitions(new EncodedResource(resource));\n    }\n</code></pre>\n<p>从指定的 xml 文件加载 Bean Definition，这里会先对 Resource 资源封装成 EncodedResource。这里为什么需要将 Resource 封装成 EncodedResource呢？主要是为了对 Resource 进行编码，保证内容读取的正确性。封装成 EncodedResource 后，调用<code>loadBeanDefinitions()</code>，这个方法才是真正的逻辑实现。如下：</p>\n<pre><code class=\"java\">    public int loadBeanDefinitions(EncodedResource encodedResource) \n                throws BeanDefinitionStoreException {\n        Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);\n        if (logger.isInfoEnabled()) {\n            logger.info(&quot;Loading XML bean definitions from &quot; \n                            + encodedResource.getResource());\n        }\n\n        // 获取已经加载过的资源\n        Set&lt;EncodedResource&gt; currentResources = \n                    this.resourcesCurrentlyBeingLoaded.get();\n        if (currentResources == null) {\n            currentResources = new HashSet&lt;&gt;(4);\n            this.resourcesCurrentlyBeingLoaded.set(currentResources);\n        }\n\n        // 将当前资源加入记录中\n        if (!currentResources.add(encodedResource)) {\n            throw new BeanDefinitionStoreException(\n                    &quot;Detected cyclic loading of &quot; + encodedResource \n                            + &quot; - check your import definitions!&quot;);\n        }\n        try {\n     // 从 EncodedResource 获取封装的 Resource 并从 Resource 中获取其中的 InputStream\n            InputStream inputStream = \n                        encodedResource.getResource().getInputStream();\n            try {\n                InputSource inputSource = new InputSource(inputStream);\n                // 设置编码\n                if (encodedResource.getEncoding() != null) {\n                    inputSource.setEncoding(encodedResource.getEncoding());\n                }\n                // 核心逻辑部分\n                return doLoadBeanDefinitions(inputSource, \n                                             encodedResource.getResource());\n            }\n            finally {\n                inputStream.close();\n            }\n        }\n        catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\n                    &quot;IOException parsing XML document from &quot; + \n                        encodedResource.getResource(), ex);\n        }\n        finally {\n            // 从缓存中剔除该资源\n            currentResources.remove(encodedResource);\n            if (currentResources.isEmpty()) {\n                this.resourcesCurrentlyBeingLoaded.remove();\n            }\n        }\n    }\n</code></pre>\n<p>首先通过<code>resourcesCurrentlyBeingLoaded.get()</code> 来获取已经加载过的资源，然后将 encodedResource 加入其中，如果 resourcesCurrentlyBeingLoaded 中已经存在该资源，则抛出 BeanDefinitionStoreException 异常。完成后从 encodedResource 获取封装的 Resource 资源并从 Resource 中获取相应的 InputStream ，最后将 InputStream 封装为 InputSource 调用 <code>doLoadBeanDefinitions()</code>。方法 <code>doLoadBeanDefinitions()</code> 为从 xml 文件中加载 Bean Definition 的真正逻辑，如下:</p>\n<pre><code class=\"java\">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n            throws BeanDefinitionStoreException {\n        try {\n            // 获取 Document 实例\n            Document doc = doLoadDocument(inputSource, resource);\n            // 根据 Document 实例注册 Bean信息\n            return registerBeanDefinitions(doc, resource);\n        }\n        catch (BeanDefinitionStoreException ex) {\n            throw ex;\n        }\n        catch (SAXParseException ex) {\n            throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                    &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);\n        }\n        catch (SAXException ex) {\n            throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                    &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);\n        }\n        catch (ParserConfigurationException ex) {\n            throw new BeanDefinitionStoreException(resource.getDescription(),\n                    &quot;Parser configuration exception parsing XML from &quot; + resource, ex);\n        }\n        catch (IOException ex) {\n            throw new BeanDefinitionStoreException(resource.getDescription(),\n                    &quot;IOException parsing XML document from &quot; + resource, ex);\n        }\n        catch (Throwable ex) {\n            throw new BeanDefinitionStoreException(resource.getDescription(),\n                    &quot;Unexpected exception parsing XML document from &quot; + resource, ex);\n        }\n    }\n</code></pre>\n<p>核心部分就是 try 块的两行代码。</p>\n<ol>\n<li>调用 <code>doLoadDocument()</code> 方法，根据 xml 文件获取 Document 实例。</li>\n<li>根据获取的 Document 实例注册 Bean 信息。</li>\n</ol>\n<p>其实在<code>doLoadDocument()</code>方法内部还获取了 xml 文件的验证模式。如下:</p>\n<pre><code>    protected Document doLoadDocument(InputSource inputSource, Resource resource) \n        throws Exception {\n        return this.documentLoader.loadDocument(inputSource, getEntityResolver(), \n        this.errorHandler,getValidationModeForResource(resource),isNamespaceAware());\n    }\n</code></pre><p>调用<code>getValidationModeForResource()</code> 获取指定资源（xml）的验证模式。所以 <code>doLoadBeanDefinitions()</code>主要就是做了三件事情。</p>\n<ol>\n<li>调用 <code>getValidationModeForResource()</code> 获取 xml 文件的验证模式</li>\n<li>调用 <code>loadDocument()</code> 根据 xml 文件获取相应的 Document 实例。</li>\n<li>调用 <code>registerBeanDefinitions()</code> 注册 Bean 实例。</li>\n</ol>\n</li>\n</ol>"},{"abbrlink":25,"title":"spring 源码分析之 06注册BeanDefinition","author":"fengxiutianya","date":"2019-01-13T20:58:00.000Z","_content":"# spring 源码解析之 06注册BeanDefinition\n\n#### registerBeanDefinitions\n\n获取 Document 对象后，会根据该对象和 Resource 资源对象调用 `registerBeanDefinitions()` 方法，开始注册 BeanDefinitions 之旅。如下：\n<!-- more-->\n\n```java\n    public int registerBeanDefinitions(Document doc, Resource resource) \n        throws BeanDefinitionStoreException {\n        //用DefaultBeanDefinitionDocumentReader实例化BeanDefinitionDocumentReader\n        BeanDefinitionDocumentReader documentReader = \n            createBeanDefinitionDocumentReader();\n        // 记录注册BeanDefinition之前的个数\n        int countBefore = getRegistry().getBeanDefinitionCount();\n        // 注册BeanDefinition\n        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n        //记录本次加载BeanDefinition的个数\n        return getRegistry().getBeanDefinitionCount() - countBefore;\n    }\n```\n\n首先调用 `createBeanDefinitionDocumentReader()` 方法实例化 BeanDefinitionDocumentReader 对象，然后获取统计前 BeanDefinition 的个数，最后调用 `registerBeanDefinitions()` 注册 BeanDefinition。\n\n实例化 BeanDefinitionDocumentReader 对象方法如下：\n\n```java\n    protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {\n        return BeanDefinitionDocumentReader.class.cast(\n            BeanUtils.instantiateClass(this.documentReaderClass));\n    }\n```\n\n注册 BeanDefinition 的方法 `registerBeanDefinitions()` 是在接口 BeanDefinitionDocumentReader 中定义，如下：\n\n```java\n    void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)\n            throws BeanDefinitionStoreException;\n```\n\n**从给定的 Document 对象中解析定义的 BeanDefinition 并将他们注册到注册表中**。方法接收两个参数，待解析的 Document 对象，以及解析器的当前上下文，包括目标注册表和被解析的资源。其中 readerContext 是根据 Resource 来创建的，如下：\n\n```java\n    public XmlReaderContext createReaderContext(Resource resource) {\n        return new XmlReaderContext(resource, this.problemReporter, this.eventListener,\n                this.sourceExtractor, this, getNamespaceHandlerResolver());\n    }\n```\n\nDefaultBeanDefinitionDocumentReader 对BeanDefinitionDocumentReader默认实现，具体的注册BeanDefinition代码如下：\n\n```java\n    public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n        this.readerContext = readerContext;\n        logger.debug(\"Loading bean definitions\");\n        Element root = doc.getDocumentElement();\n        doRegisterBeanDefinitions(root);\n    }\n```\n\n这个方法的主要目的就是提取root，以便于再次将root作为参数继续BeanDefinition的注册，接着就是注册的核型逻辑，调用 `doRegisterBeanDefinitions()` 开启注册 BeanDefinition 之旅\n\n```java\n    protected void doRegisterBeanDefinitions(Element root) {\n        BeanDefinitionParserDelegate parent = this.delegate;\n        this.delegate = createDelegate(getReaderContext(), root, parent);\n\n        if (this.delegate.isDefaultNamespace(root)) {\n             // 处理 profile\n            String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n            if (StringUtils.hasText(profileSpec)) {\n                String[] specifiedProfiles = \n                    StringUtils.tokenizeToStringArray(\n                        profileSpec, \n                   BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n                if (!getReaderContext().getEnvironment()\n                    \t.acceptsProfiles(specifiedProfiles)) {\n                    if (logger.isInfoEnabled()) {\n                        logger.info(\"Skipped XML bean definition file \n                                    \tdue to specified profiles [\" + \n                                    profileSpec +\n                                \"] not matching: \" + getReaderContext().getResource());\n                    }\n                    return;\n                }\n            }\n        }\n\n        // 解析前处理\n        preProcessXml(root);\n        // 解析\n        parseBeanDefinitions(root, this.delegate);\n        // 解析后处理\n        postProcessXml(root);\n\n        this.delegate = parent;\n    }\n```\n\n程序首先处理 profile属性，profile主要用于我们切换环境，比如切换开发、测试、生产环境，非常方便。然后调用 `parseBeanDefinitions()` 进行解析动作，不过在该方法之前之后分别调用 `preProcessXml()` 和 `postProcessXml()`方法来进行前、后处理，目前这两个方法都是空实现，既然是空的写着还有什么用呢？就像面向对象设计方法学中常说的一句话，一个类要么是面向继承设计的，要么就用final修饰。在DefaultBeanDefinitionDocumentReader中并没有用final修饰，所以它是面向继承而设计的。这俩个方法正是为子类而设计的，如果读者有了解过设计模式，可以很快速地反映出这是模板方法修饰，如果继承自DefaultBeanDefinitionDocumentReader的子类需要在bean解析前后做一些处理的话，那么只需要重写这俩个方法。\n\n```java\n    protected void preProcessXml(Element root) {\n    }\n\n    protected void postProcessXml(Element root) {\n    }\n```\n\n#### profile属性的作用\n\n从上面的代码可以注意到。在注册Bean的最开始是对PROFILE_ATTRIBUTE属性的解析，可能对于我们来说，profile并不是很常用，所以首先了解一下这个属性。\n\n分析profile💰我们先了解下profile的用法，示例如下：\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\t<bean id=\"dateFoo\" class=\"com.zhangke.common.DateFoo\">\n\t\t<property name=\"date\">\n\t\t\t<value>2007/10/1</value>\n\t\t</property>\n\t</bean>\n\n\t<beans profile=\"dev\">\n\t\t<!-- dev开发环境下定义-->\n\t</beans>\n\t<beans profile=\"production\">\n\t\t<!-- production测试环境下定义-->\n\t</beans>\n</beans>\n```\n\n集成到web环境时，在webx.xml中加入以下代码：\n\n```xml\n<context-param>\n\t<param-name>Spring.profiles.active</param-name>\n    <param-value>dev</param-value>\n</context-param>\n```\n\n从上可以看出，有了这个特性，可以同时在配置文件中部署俩套配置来使用与生产环境和开发环境，这样可以方便的进行切换开发、部署环境，这在开发过程中经常使用到，最常用的莫过于更换不同的数据库。\n\n从上面你应该大体上了解profile的使用，下面我们着重分析一下上面在解析BeanDefinition前的profile的处理。首先程序会获取当前节点的命名空间是否是默认命名空间，也就是spring官方提供的节点定义，（这里不包括context，util这些节点，默认命名空间可以去看我前面的博客[spring源码分析之获取xml的验证模型]()）,然后就检测beans节点是否定义了profile属性，如果定义了则会需要到开发环境变量中去寻找，所以这里县断言profile属性值不可能为空，如果为空，则代表着所有的环境都需要包含此配置。因为profile是可以同时制定多个的，需要程序对其拆分，并解析多个profile中是否有符合环境变量中定义的，不定义则不会去解析。\n\n#### 解析并注册BeanDefinition\n\n处理了profile后就可以进行XML的读取，`parseBeanDefinitions()` 定义如下：\n\n```java\n    protected void parseBeanDefinitions(Element root, \n                                        \tBeanDefinitionParserDelegate delegate) {\n        // 对beans的处理\n        if (delegate.isDefaultNamespace(root)) {\n            NodeList nl = root.getChildNodes();\n            for (int i = 0; i < nl.getLength(); i++) {\n                Node node = nl.item(i);\n                if (node instanceof Element) {\n                    Element ele = (Element) node;\n                    // 默认环境节点的处理\n                    if (delegate.isDefaultNamespace(ele)) {\n                        parseDefaultElement(ele, delegate);\n                    }\n                    else {\n                        // 自定义节点的处理\n                        delegate.parseCustomElement(ele);\n                    }\n                }\n            }\n        }\n        else {\n            // 自定义节点处理\n            delegate.parseCustomElement(root);\n        }\n    }\n```\n\n最终解析动作落地在两个方法处：`parseDefaultElement(ele, delegate)` 和 `delegate.parseCustomElement(root)`。我们知道在 Spring 有两种 Bean 声明方式：\n\n- 配置文件式声明：`<bean id=\"studentService\" class=\"org.springframework.core.StudentService\"/>`\n- 自定义注解方式：`<tx:annotation-driven>`\n\n两种方式的读取和解析都存在较大的差异，所以采用不同的解析方法，如果采用Spring默认的配置，Spring当然知道该怎么做，但是如果是自定义的，那么就需要用户实现一些借口即配置了。如果根节点或者子节点采用默认命名空间的话，则调用 `parseDefaultElement()` 进行解析，否则调用 `delegate.parseCustomElement()` 方法对自定义命名空间进行解析。而判断是否默认空间还是自定义四命名空间的办法其实使用node.getNAmespaceURI获取命名空间，并与Spring中固定的命名空间`http://www.Springframework.org/schema/beans`进行比对。如果一直则认为是默认，否则就认为是自定义。其实你可以这样简单里面，如果是默认空间写法如下\n\n```xml\n<属性名> 属性值 </属性名>\n```\n\n自定义写法如下:\n\n```xml\n<命名空间：属性名> 属性值 </命名空间：属性名>\n```\n\n因为默认命名空间，xml规定可以在属性名前面不用写命名空间。所以你现在可以很容易的分辨你写的xm中哪些是自定义哪些是默认。\n\n再多说一点，在springframework官方文档中，[Appendix](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#appendix)中定义了几个方便开发的xml Schema，原理就是在这。不过后面会讲如何自定义属性，这里只是简单提一下。\n\n至此，`doLoadBeanDefinitions()` 中做的三件事情已经全部分析完毕，下面将对 Bean 的解析过程做详细分析说明。","source":"_posts/spring 源码分析/spring/spring源码解析之  06注册BeanDefinition.md","raw":"abbrlink: 25\ntitle: spring 源码分析之 06注册BeanDefinition\ntags:\n  - spring源码解析\n  - ''\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-14 04:58:00\n---\n# spring 源码解析之 06注册BeanDefinition\n\n#### registerBeanDefinitions\n\n获取 Document 对象后，会根据该对象和 Resource 资源对象调用 `registerBeanDefinitions()` 方法，开始注册 BeanDefinitions 之旅。如下：\n<!-- more-->\n\n```java\n    public int registerBeanDefinitions(Document doc, Resource resource) \n        throws BeanDefinitionStoreException {\n        //用DefaultBeanDefinitionDocumentReader实例化BeanDefinitionDocumentReader\n        BeanDefinitionDocumentReader documentReader = \n            createBeanDefinitionDocumentReader();\n        // 记录注册BeanDefinition之前的个数\n        int countBefore = getRegistry().getBeanDefinitionCount();\n        // 注册BeanDefinition\n        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n        //记录本次加载BeanDefinition的个数\n        return getRegistry().getBeanDefinitionCount() - countBefore;\n    }\n```\n\n首先调用 `createBeanDefinitionDocumentReader()` 方法实例化 BeanDefinitionDocumentReader 对象，然后获取统计前 BeanDefinition 的个数，最后调用 `registerBeanDefinitions()` 注册 BeanDefinition。\n\n实例化 BeanDefinitionDocumentReader 对象方法如下：\n\n```java\n    protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {\n        return BeanDefinitionDocumentReader.class.cast(\n            BeanUtils.instantiateClass(this.documentReaderClass));\n    }\n```\n\n注册 BeanDefinition 的方法 `registerBeanDefinitions()` 是在接口 BeanDefinitionDocumentReader 中定义，如下：\n\n```java\n    void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)\n            throws BeanDefinitionStoreException;\n```\n\n**从给定的 Document 对象中解析定义的 BeanDefinition 并将他们注册到注册表中**。方法接收两个参数，待解析的 Document 对象，以及解析器的当前上下文，包括目标注册表和被解析的资源。其中 readerContext 是根据 Resource 来创建的，如下：\n\n```java\n    public XmlReaderContext createReaderContext(Resource resource) {\n        return new XmlReaderContext(resource, this.problemReporter, this.eventListener,\n                this.sourceExtractor, this, getNamespaceHandlerResolver());\n    }\n```\n\nDefaultBeanDefinitionDocumentReader 对BeanDefinitionDocumentReader默认实现，具体的注册BeanDefinition代码如下：\n\n```java\n    public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n        this.readerContext = readerContext;\n        logger.debug(\"Loading bean definitions\");\n        Element root = doc.getDocumentElement();\n        doRegisterBeanDefinitions(root);\n    }\n```\n\n这个方法的主要目的就是提取root，以便于再次将root作为参数继续BeanDefinition的注册，接着就是注册的核型逻辑，调用 `doRegisterBeanDefinitions()` 开启注册 BeanDefinition 之旅\n\n```java\n    protected void doRegisterBeanDefinitions(Element root) {\n        BeanDefinitionParserDelegate parent = this.delegate;\n        this.delegate = createDelegate(getReaderContext(), root, parent);\n\n        if (this.delegate.isDefaultNamespace(root)) {\n             // 处理 profile\n            String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n            if (StringUtils.hasText(profileSpec)) {\n                String[] specifiedProfiles = \n                    StringUtils.tokenizeToStringArray(\n                        profileSpec, \n                   BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n                if (!getReaderContext().getEnvironment()\n                    \t.acceptsProfiles(specifiedProfiles)) {\n                    if (logger.isInfoEnabled()) {\n                        logger.info(\"Skipped XML bean definition file \n                                    \tdue to specified profiles [\" + \n                                    profileSpec +\n                                \"] not matching: \" + getReaderContext().getResource());\n                    }\n                    return;\n                }\n            }\n        }\n\n        // 解析前处理\n        preProcessXml(root);\n        // 解析\n        parseBeanDefinitions(root, this.delegate);\n        // 解析后处理\n        postProcessXml(root);\n\n        this.delegate = parent;\n    }\n```\n\n程序首先处理 profile属性，profile主要用于我们切换环境，比如切换开发、测试、生产环境，非常方便。然后调用 `parseBeanDefinitions()` 进行解析动作，不过在该方法之前之后分别调用 `preProcessXml()` 和 `postProcessXml()`方法来进行前、后处理，目前这两个方法都是空实现，既然是空的写着还有什么用呢？就像面向对象设计方法学中常说的一句话，一个类要么是面向继承设计的，要么就用final修饰。在DefaultBeanDefinitionDocumentReader中并没有用final修饰，所以它是面向继承而设计的。这俩个方法正是为子类而设计的，如果读者有了解过设计模式，可以很快速地反映出这是模板方法修饰，如果继承自DefaultBeanDefinitionDocumentReader的子类需要在bean解析前后做一些处理的话，那么只需要重写这俩个方法。\n\n```java\n    protected void preProcessXml(Element root) {\n    }\n\n    protected void postProcessXml(Element root) {\n    }\n```\n\n#### profile属性的作用\n\n从上面的代码可以注意到。在注册Bean的最开始是对PROFILE_ATTRIBUTE属性的解析，可能对于我们来说，profile并不是很常用，所以首先了解一下这个属性。\n\n分析profile💰我们先了解下profile的用法，示例如下：\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\t<bean id=\"dateFoo\" class=\"com.zhangke.common.DateFoo\">\n\t\t<property name=\"date\">\n\t\t\t<value>2007/10/1</value>\n\t\t</property>\n\t</bean>\n\n\t<beans profile=\"dev\">\n\t\t<!-- dev开发环境下定义-->\n\t</beans>\n\t<beans profile=\"production\">\n\t\t<!-- production测试环境下定义-->\n\t</beans>\n</beans>\n```\n\n集成到web环境时，在webx.xml中加入以下代码：\n\n```xml\n<context-param>\n\t<param-name>Spring.profiles.active</param-name>\n    <param-value>dev</param-value>\n</context-param>\n```\n\n从上可以看出，有了这个特性，可以同时在配置文件中部署俩套配置来使用与生产环境和开发环境，这样可以方便的进行切换开发、部署环境，这在开发过程中经常使用到，最常用的莫过于更换不同的数据库。\n\n从上面你应该大体上了解profile的使用，下面我们着重分析一下上面在解析BeanDefinition前的profile的处理。首先程序会获取当前节点的命名空间是否是默认命名空间，也就是spring官方提供的节点定义，（这里不包括context，util这些节点，默认命名空间可以去看我前面的博客[spring源码分析之获取xml的验证模型]()）,然后就检测beans节点是否定义了profile属性，如果定义了则会需要到开发环境变量中去寻找，所以这里县断言profile属性值不可能为空，如果为空，则代表着所有的环境都需要包含此配置。因为profile是可以同时制定多个的，需要程序对其拆分，并解析多个profile中是否有符合环境变量中定义的，不定义则不会去解析。\n\n#### 解析并注册BeanDefinition\n\n处理了profile后就可以进行XML的读取，`parseBeanDefinitions()` 定义如下：\n\n```java\n    protected void parseBeanDefinitions(Element root, \n                                        \tBeanDefinitionParserDelegate delegate) {\n        // 对beans的处理\n        if (delegate.isDefaultNamespace(root)) {\n            NodeList nl = root.getChildNodes();\n            for (int i = 0; i < nl.getLength(); i++) {\n                Node node = nl.item(i);\n                if (node instanceof Element) {\n                    Element ele = (Element) node;\n                    // 默认环境节点的处理\n                    if (delegate.isDefaultNamespace(ele)) {\n                        parseDefaultElement(ele, delegate);\n                    }\n                    else {\n                        // 自定义节点的处理\n                        delegate.parseCustomElement(ele);\n                    }\n                }\n            }\n        }\n        else {\n            // 自定义节点处理\n            delegate.parseCustomElement(root);\n        }\n    }\n```\n\n最终解析动作落地在两个方法处：`parseDefaultElement(ele, delegate)` 和 `delegate.parseCustomElement(root)`。我们知道在 Spring 有两种 Bean 声明方式：\n\n- 配置文件式声明：`<bean id=\"studentService\" class=\"org.springframework.core.StudentService\"/>`\n- 自定义注解方式：`<tx:annotation-driven>`\n\n两种方式的读取和解析都存在较大的差异，所以采用不同的解析方法，如果采用Spring默认的配置，Spring当然知道该怎么做，但是如果是自定义的，那么就需要用户实现一些借口即配置了。如果根节点或者子节点采用默认命名空间的话，则调用 `parseDefaultElement()` 进行解析，否则调用 `delegate.parseCustomElement()` 方法对自定义命名空间进行解析。而判断是否默认空间还是自定义四命名空间的办法其实使用node.getNAmespaceURI获取命名空间，并与Spring中固定的命名空间`http://www.Springframework.org/schema/beans`进行比对。如果一直则认为是默认，否则就认为是自定义。其实你可以这样简单里面，如果是默认空间写法如下\n\n```xml\n<属性名> 属性值 </属性名>\n```\n\n自定义写法如下:\n\n```xml\n<命名空间：属性名> 属性值 </命名空间：属性名>\n```\n\n因为默认命名空间，xml规定可以在属性名前面不用写命名空间。所以你现在可以很容易的分辨你写的xm中哪些是自定义哪些是默认。\n\n再多说一点，在springframework官方文档中，[Appendix](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#appendix)中定义了几个方便开发的xml Schema，原理就是在这。不过后面会讲如何自定义属性，这里只是简单提一下。\n\n至此，`doLoadBeanDefinitions()` 中做的三件事情已经全部分析完毕，下面将对 Bean 的解析过程做详细分析说明。","slug":"spring 源码分析/spring/spring源码解析之  06注册BeanDefinition","published":1,"updated":"2019-01-15T03:38:06.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovw500499q1u2dveea58","content":"<h1 id=\"spring-源码解析之-06注册BeanDefinition\"><a href=\"#spring-源码解析之-06注册BeanDefinition\" class=\"headerlink\" title=\"spring 源码解析之 06注册BeanDefinition\"></a>spring 源码解析之 06注册BeanDefinition</h1><h4 id=\"registerBeanDefinitions\"><a href=\"#registerBeanDefinitions\" class=\"headerlink\" title=\"registerBeanDefinitions\"></a>registerBeanDefinitions</h4><p>获取 Document 对象后，会根据该对象和 Resource 资源对象调用 <code>registerBeanDefinitions()</code> 方法，开始注册 BeanDefinitions 之旅。如下：<br><a id=\"more\"></a></p>\n<pre><code class=\"java\">    public int registerBeanDefinitions(Document doc, Resource resource) \n        throws BeanDefinitionStoreException {\n        //用DefaultBeanDefinitionDocumentReader实例化BeanDefinitionDocumentReader\n        BeanDefinitionDocumentReader documentReader = \n            createBeanDefinitionDocumentReader();\n        // 记录注册BeanDefinition之前的个数\n        int countBefore = getRegistry().getBeanDefinitionCount();\n        // 注册BeanDefinition\n        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n        //记录本次加载BeanDefinition的个数\n        return getRegistry().getBeanDefinitionCount() - countBefore;\n    }\n</code></pre>\n<p>首先调用 <code>createBeanDefinitionDocumentReader()</code> 方法实例化 BeanDefinitionDocumentReader 对象，然后获取统计前 BeanDefinition 的个数，最后调用 <code>registerBeanDefinitions()</code> 注册 BeanDefinition。</p>\n<p>实例化 BeanDefinitionDocumentReader 对象方法如下：</p>\n<pre><code class=\"java\">    protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {\n        return BeanDefinitionDocumentReader.class.cast(\n            BeanUtils.instantiateClass(this.documentReaderClass));\n    }\n</code></pre>\n<p>注册 BeanDefinition 的方法 <code>registerBeanDefinitions()</code> 是在接口 BeanDefinitionDocumentReader 中定义，如下：</p>\n<pre><code class=\"java\">    void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)\n            throws BeanDefinitionStoreException;\n</code></pre>\n<p><strong>从给定的 Document 对象中解析定义的 BeanDefinition 并将他们注册到注册表中</strong>。方法接收两个参数，待解析的 Document 对象，以及解析器的当前上下文，包括目标注册表和被解析的资源。其中 readerContext 是根据 Resource 来创建的，如下：</p>\n<pre><code class=\"java\">    public XmlReaderContext createReaderContext(Resource resource) {\n        return new XmlReaderContext(resource, this.problemReporter, this.eventListener,\n                this.sourceExtractor, this, getNamespaceHandlerResolver());\n    }\n</code></pre>\n<p>DefaultBeanDefinitionDocumentReader 对BeanDefinitionDocumentReader默认实现，具体的注册BeanDefinition代码如下：</p>\n<pre><code class=\"java\">    public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n        this.readerContext = readerContext;\n        logger.debug(&quot;Loading bean definitions&quot;);\n        Element root = doc.getDocumentElement();\n        doRegisterBeanDefinitions(root);\n    }\n</code></pre>\n<p>这个方法的主要目的就是提取root，以便于再次将root作为参数继续BeanDefinition的注册，接着就是注册的核型逻辑，调用 <code>doRegisterBeanDefinitions()</code> 开启注册 BeanDefinition 之旅</p>\n<pre><code class=\"java\">    protected void doRegisterBeanDefinitions(Element root) {\n        BeanDefinitionParserDelegate parent = this.delegate;\n        this.delegate = createDelegate(getReaderContext(), root, parent);\n\n        if (this.delegate.isDefaultNamespace(root)) {\n             // 处理 profile\n            String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n            if (StringUtils.hasText(profileSpec)) {\n                String[] specifiedProfiles = \n                    StringUtils.tokenizeToStringArray(\n                        profileSpec, \n                   BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n                if (!getReaderContext().getEnvironment()\n                        .acceptsProfiles(specifiedProfiles)) {\n                    if (logger.isInfoEnabled()) {\n                        logger.info(&quot;Skipped XML bean definition file \n                                        due to specified profiles [&quot; + \n                                    profileSpec +\n                                &quot;] not matching: &quot; + getReaderContext().getResource());\n                    }\n                    return;\n                }\n            }\n        }\n\n        // 解析前处理\n        preProcessXml(root);\n        // 解析\n        parseBeanDefinitions(root, this.delegate);\n        // 解析后处理\n        postProcessXml(root);\n\n        this.delegate = parent;\n    }\n</code></pre>\n<p>程序首先处理 profile属性，profile主要用于我们切换环境，比如切换开发、测试、生产环境，非常方便。然后调用 <code>parseBeanDefinitions()</code> 进行解析动作，不过在该方法之前之后分别调用 <code>preProcessXml()</code> 和 <code>postProcessXml()</code>方法来进行前、后处理，目前这两个方法都是空实现，既然是空的写着还有什么用呢？就像面向对象设计方法学中常说的一句话，一个类要么是面向继承设计的，要么就用final修饰。在DefaultBeanDefinitionDocumentReader中并没有用final修饰，所以它是面向继承而设计的。这俩个方法正是为子类而设计的，如果读者有了解过设计模式，可以很快速地反映出这是模板方法修饰，如果继承自DefaultBeanDefinitionDocumentReader的子类需要在bean解析前后做一些处理的话，那么只需要重写这俩个方法。</p>\n<pre><code class=\"java\">    protected void preProcessXml(Element root) {\n    }\n\n    protected void postProcessXml(Element root) {\n    }\n</code></pre>\n<h4 id=\"profile属性的作用\"><a href=\"#profile属性的作用\" class=\"headerlink\" title=\"profile属性的作用\"></a>profile属性的作用</h4><p>从上面的代码可以注意到。在注册Bean的最开始是对PROFILE_ATTRIBUTE属性的解析，可能对于我们来说，profile并不是很常用，所以首先了解一下这个属性。</p>\n<p>分析profile💰我们先了解下profile的用法，示例如下：</p>\n<pre><code class=\"java\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n    &lt;bean id=&quot;dateFoo&quot; class=&quot;com.zhangke.common.DateFoo&quot;&gt;\n        &lt;property name=&quot;date&quot;&gt;\n            &lt;value&gt;2007/10/1&lt;/value&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;beans profile=&quot;dev&quot;&gt;\n        &lt;!-- dev开发环境下定义--&gt;\n    &lt;/beans&gt;\n    &lt;beans profile=&quot;production&quot;&gt;\n        &lt;!-- production测试环境下定义--&gt;\n    &lt;/beans&gt;\n&lt;/beans&gt;\n</code></pre>\n<p>集成到web环境时，在webx.xml中加入以下代码：</p>\n<pre><code class=\"xml\">&lt;context-param&gt;\n    &lt;param-name&gt;Spring.profiles.active&lt;/param-name&gt;\n    &lt;param-value&gt;dev&lt;/param-value&gt;\n&lt;/context-param&gt;\n</code></pre>\n<p>从上可以看出，有了这个特性，可以同时在配置文件中部署俩套配置来使用与生产环境和开发环境，这样可以方便的进行切换开发、部署环境，这在开发过程中经常使用到，最常用的莫过于更换不同的数据库。</p>\n<p>从上面你应该大体上了解profile的使用，下面我们着重分析一下上面在解析BeanDefinition前的profile的处理。首先程序会获取当前节点的命名空间是否是默认命名空间，也就是spring官方提供的节点定义，（这里不包括context，util这些节点，默认命名空间可以去看我前面的博客<a href=\"\">spring源码分析之获取xml的验证模型</a>）,然后就检测beans节点是否定义了profile属性，如果定义了则会需要到开发环境变量中去寻找，所以这里县断言profile属性值不可能为空，如果为空，则代表着所有的环境都需要包含此配置。因为profile是可以同时制定多个的，需要程序对其拆分，并解析多个profile中是否有符合环境变量中定义的，不定义则不会去解析。</p>\n<h4 id=\"解析并注册BeanDefinition\"><a href=\"#解析并注册BeanDefinition\" class=\"headerlink\" title=\"解析并注册BeanDefinition\"></a>解析并注册BeanDefinition</h4><p>处理了profile后就可以进行XML的读取，<code>parseBeanDefinitions()</code> 定义如下：</p>\n<pre><code class=\"java\">    protected void parseBeanDefinitions(Element root, \n                                            BeanDefinitionParserDelegate delegate) {\n        // 对beans的处理\n        if (delegate.isDefaultNamespace(root)) {\n            NodeList nl = root.getChildNodes();\n            for (int i = 0; i &lt; nl.getLength(); i++) {\n                Node node = nl.item(i);\n                if (node instanceof Element) {\n                    Element ele = (Element) node;\n                    // 默认环境节点的处理\n                    if (delegate.isDefaultNamespace(ele)) {\n                        parseDefaultElement(ele, delegate);\n                    }\n                    else {\n                        // 自定义节点的处理\n                        delegate.parseCustomElement(ele);\n                    }\n                }\n            }\n        }\n        else {\n            // 自定义节点处理\n            delegate.parseCustomElement(root);\n        }\n    }\n</code></pre>\n<p>最终解析动作落地在两个方法处：<code>parseDefaultElement(ele, delegate)</code> 和 <code>delegate.parseCustomElement(root)</code>。我们知道在 Spring 有两种 Bean 声明方式：</p>\n<ul>\n<li>配置文件式声明：<code>&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.StudentService&quot;/&gt;</code></li>\n<li>自定义注解方式：<code>&lt;tx:annotation-driven&gt;</code></li>\n</ul>\n<p>两种方式的读取和解析都存在较大的差异，所以采用不同的解析方法，如果采用Spring默认的配置，Spring当然知道该怎么做，但是如果是自定义的，那么就需要用户实现一些借口即配置了。如果根节点或者子节点采用默认命名空间的话，则调用 <code>parseDefaultElement()</code> 进行解析，否则调用 <code>delegate.parseCustomElement()</code> 方法对自定义命名空间进行解析。而判断是否默认空间还是自定义四命名空间的办法其实使用node.getNAmespaceURI获取命名空间，并与Spring中固定的命名空间<code>http://www.Springframework.org/schema/beans</code>进行比对。如果一直则认为是默认，否则就认为是自定义。其实你可以这样简单里面，如果是默认空间写法如下</p>\n<pre><code class=\"xml\">&lt;属性名&gt; 属性值 &lt;/属性名&gt;\n</code></pre>\n<p>自定义写法如下:</p>\n<pre><code class=\"xml\">&lt;命名空间：属性名&gt; 属性值 &lt;/命名空间：属性名&gt;\n</code></pre>\n<p>因为默认命名空间，xml规定可以在属性名前面不用写命名空间。所以你现在可以很容易的分辨你写的xm中哪些是自定义哪些是默认。</p>\n<p>再多说一点，在springframework官方文档中，<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#appendix\" target=\"_blank\" rel=\"noopener\">Appendix</a>中定义了几个方便开发的xml Schema，原理就是在这。不过后面会讲如何自定义属性，这里只是简单提一下。</p>\n<p>至此，<code>doLoadBeanDefinitions()</code> 中做的三件事情已经全部分析完毕，下面将对 Bean 的解析过程做详细分析说明。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring-源码解析之-06注册BeanDefinition\"><a href=\"#spring-源码解析之-06注册BeanDefinition\" class=\"headerlink\" title=\"spring 源码解析之 06注册BeanDefinition\"></a>spring 源码解析之 06注册BeanDefinition</h1><h4 id=\"registerBeanDefinitions\"><a href=\"#registerBeanDefinitions\" class=\"headerlink\" title=\"registerBeanDefinitions\"></a>registerBeanDefinitions</h4><p>获取 Document 对象后，会根据该对象和 Resource 资源对象调用 <code>registerBeanDefinitions()</code> 方法，开始注册 BeanDefinitions 之旅。如下：<br>","more":"</p>\n<pre><code class=\"java\">    public int registerBeanDefinitions(Document doc, Resource resource) \n        throws BeanDefinitionStoreException {\n        //用DefaultBeanDefinitionDocumentReader实例化BeanDefinitionDocumentReader\n        BeanDefinitionDocumentReader documentReader = \n            createBeanDefinitionDocumentReader();\n        // 记录注册BeanDefinition之前的个数\n        int countBefore = getRegistry().getBeanDefinitionCount();\n        // 注册BeanDefinition\n        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n        //记录本次加载BeanDefinition的个数\n        return getRegistry().getBeanDefinitionCount() - countBefore;\n    }\n</code></pre>\n<p>首先调用 <code>createBeanDefinitionDocumentReader()</code> 方法实例化 BeanDefinitionDocumentReader 对象，然后获取统计前 BeanDefinition 的个数，最后调用 <code>registerBeanDefinitions()</code> 注册 BeanDefinition。</p>\n<p>实例化 BeanDefinitionDocumentReader 对象方法如下：</p>\n<pre><code class=\"java\">    protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {\n        return BeanDefinitionDocumentReader.class.cast(\n            BeanUtils.instantiateClass(this.documentReaderClass));\n    }\n</code></pre>\n<p>注册 BeanDefinition 的方法 <code>registerBeanDefinitions()</code> 是在接口 BeanDefinitionDocumentReader 中定义，如下：</p>\n<pre><code class=\"java\">    void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)\n            throws BeanDefinitionStoreException;\n</code></pre>\n<p><strong>从给定的 Document 对象中解析定义的 BeanDefinition 并将他们注册到注册表中</strong>。方法接收两个参数，待解析的 Document 对象，以及解析器的当前上下文，包括目标注册表和被解析的资源。其中 readerContext 是根据 Resource 来创建的，如下：</p>\n<pre><code class=\"java\">    public XmlReaderContext createReaderContext(Resource resource) {\n        return new XmlReaderContext(resource, this.problemReporter, this.eventListener,\n                this.sourceExtractor, this, getNamespaceHandlerResolver());\n    }\n</code></pre>\n<p>DefaultBeanDefinitionDocumentReader 对BeanDefinitionDocumentReader默认实现，具体的注册BeanDefinition代码如下：</p>\n<pre><code class=\"java\">    public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n        this.readerContext = readerContext;\n        logger.debug(&quot;Loading bean definitions&quot;);\n        Element root = doc.getDocumentElement();\n        doRegisterBeanDefinitions(root);\n    }\n</code></pre>\n<p>这个方法的主要目的就是提取root，以便于再次将root作为参数继续BeanDefinition的注册，接着就是注册的核型逻辑，调用 <code>doRegisterBeanDefinitions()</code> 开启注册 BeanDefinition 之旅</p>\n<pre><code class=\"java\">    protected void doRegisterBeanDefinitions(Element root) {\n        BeanDefinitionParserDelegate parent = this.delegate;\n        this.delegate = createDelegate(getReaderContext(), root, parent);\n\n        if (this.delegate.isDefaultNamespace(root)) {\n             // 处理 profile\n            String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n            if (StringUtils.hasText(profileSpec)) {\n                String[] specifiedProfiles = \n                    StringUtils.tokenizeToStringArray(\n                        profileSpec, \n                   BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n                if (!getReaderContext().getEnvironment()\n                        .acceptsProfiles(specifiedProfiles)) {\n                    if (logger.isInfoEnabled()) {\n                        logger.info(&quot;Skipped XML bean definition file \n                                        due to specified profiles [&quot; + \n                                    profileSpec +\n                                &quot;] not matching: &quot; + getReaderContext().getResource());\n                    }\n                    return;\n                }\n            }\n        }\n\n        // 解析前处理\n        preProcessXml(root);\n        // 解析\n        parseBeanDefinitions(root, this.delegate);\n        // 解析后处理\n        postProcessXml(root);\n\n        this.delegate = parent;\n    }\n</code></pre>\n<p>程序首先处理 profile属性，profile主要用于我们切换环境，比如切换开发、测试、生产环境，非常方便。然后调用 <code>parseBeanDefinitions()</code> 进行解析动作，不过在该方法之前之后分别调用 <code>preProcessXml()</code> 和 <code>postProcessXml()</code>方法来进行前、后处理，目前这两个方法都是空实现，既然是空的写着还有什么用呢？就像面向对象设计方法学中常说的一句话，一个类要么是面向继承设计的，要么就用final修饰。在DefaultBeanDefinitionDocumentReader中并没有用final修饰，所以它是面向继承而设计的。这俩个方法正是为子类而设计的，如果读者有了解过设计模式，可以很快速地反映出这是模板方法修饰，如果继承自DefaultBeanDefinitionDocumentReader的子类需要在bean解析前后做一些处理的话，那么只需要重写这俩个方法。</p>\n<pre><code class=\"java\">    protected void preProcessXml(Element root) {\n    }\n\n    protected void postProcessXml(Element root) {\n    }\n</code></pre>\n<h4 id=\"profile属性的作用\"><a href=\"#profile属性的作用\" class=\"headerlink\" title=\"profile属性的作用\"></a>profile属性的作用</h4><p>从上面的代码可以注意到。在注册Bean的最开始是对PROFILE_ATTRIBUTE属性的解析，可能对于我们来说，profile并不是很常用，所以首先了解一下这个属性。</p>\n<p>分析profile💰我们先了解下profile的用法，示例如下：</p>\n<pre><code class=\"java\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n    &lt;bean id=&quot;dateFoo&quot; class=&quot;com.zhangke.common.DateFoo&quot;&gt;\n        &lt;property name=&quot;date&quot;&gt;\n            &lt;value&gt;2007/10/1&lt;/value&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;beans profile=&quot;dev&quot;&gt;\n        &lt;!-- dev开发环境下定义--&gt;\n    &lt;/beans&gt;\n    &lt;beans profile=&quot;production&quot;&gt;\n        &lt;!-- production测试环境下定义--&gt;\n    &lt;/beans&gt;\n&lt;/beans&gt;\n</code></pre>\n<p>集成到web环境时，在webx.xml中加入以下代码：</p>\n<pre><code class=\"xml\">&lt;context-param&gt;\n    &lt;param-name&gt;Spring.profiles.active&lt;/param-name&gt;\n    &lt;param-value&gt;dev&lt;/param-value&gt;\n&lt;/context-param&gt;\n</code></pre>\n<p>从上可以看出，有了这个特性，可以同时在配置文件中部署俩套配置来使用与生产环境和开发环境，这样可以方便的进行切换开发、部署环境，这在开发过程中经常使用到，最常用的莫过于更换不同的数据库。</p>\n<p>从上面你应该大体上了解profile的使用，下面我们着重分析一下上面在解析BeanDefinition前的profile的处理。首先程序会获取当前节点的命名空间是否是默认命名空间，也就是spring官方提供的节点定义，（这里不包括context，util这些节点，默认命名空间可以去看我前面的博客<a href=\"\">spring源码分析之获取xml的验证模型</a>）,然后就检测beans节点是否定义了profile属性，如果定义了则会需要到开发环境变量中去寻找，所以这里县断言profile属性值不可能为空，如果为空，则代表着所有的环境都需要包含此配置。因为profile是可以同时制定多个的，需要程序对其拆分，并解析多个profile中是否有符合环境变量中定义的，不定义则不会去解析。</p>\n<h4 id=\"解析并注册BeanDefinition\"><a href=\"#解析并注册BeanDefinition\" class=\"headerlink\" title=\"解析并注册BeanDefinition\"></a>解析并注册BeanDefinition</h4><p>处理了profile后就可以进行XML的读取，<code>parseBeanDefinitions()</code> 定义如下：</p>\n<pre><code class=\"java\">    protected void parseBeanDefinitions(Element root, \n                                            BeanDefinitionParserDelegate delegate) {\n        // 对beans的处理\n        if (delegate.isDefaultNamespace(root)) {\n            NodeList nl = root.getChildNodes();\n            for (int i = 0; i &lt; nl.getLength(); i++) {\n                Node node = nl.item(i);\n                if (node instanceof Element) {\n                    Element ele = (Element) node;\n                    // 默认环境节点的处理\n                    if (delegate.isDefaultNamespace(ele)) {\n                        parseDefaultElement(ele, delegate);\n                    }\n                    else {\n                        // 自定义节点的处理\n                        delegate.parseCustomElement(ele);\n                    }\n                }\n            }\n        }\n        else {\n            // 自定义节点处理\n            delegate.parseCustomElement(root);\n        }\n    }\n</code></pre>\n<p>最终解析动作落地在两个方法处：<code>parseDefaultElement(ele, delegate)</code> 和 <code>delegate.parseCustomElement(root)</code>。我们知道在 Spring 有两种 Bean 声明方式：</p>\n<ul>\n<li>配置文件式声明：<code>&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.StudentService&quot;/&gt;</code></li>\n<li>自定义注解方式：<code>&lt;tx:annotation-driven&gt;</code></li>\n</ul>\n<p>两种方式的读取和解析都存在较大的差异，所以采用不同的解析方法，如果采用Spring默认的配置，Spring当然知道该怎么做，但是如果是自定义的，那么就需要用户实现一些借口即配置了。如果根节点或者子节点采用默认命名空间的话，则调用 <code>parseDefaultElement()</code> 进行解析，否则调用 <code>delegate.parseCustomElement()</code> 方法对自定义命名空间进行解析。而判断是否默认空间还是自定义四命名空间的办法其实使用node.getNAmespaceURI获取命名空间，并与Spring中固定的命名空间<code>http://www.Springframework.org/schema/beans</code>进行比对。如果一直则认为是默认，否则就认为是自定义。其实你可以这样简单里面，如果是默认空间写法如下</p>\n<pre><code class=\"xml\">&lt;属性名&gt; 属性值 &lt;/属性名&gt;\n</code></pre>\n<p>自定义写法如下:</p>\n<pre><code class=\"xml\">&lt;命名空间：属性名&gt; 属性值 &lt;/命名空间：属性名&gt;\n</code></pre>\n<p>因为默认命名空间，xml规定可以在属性名前面不用写命名空间。所以你现在可以很容易的分辨你写的xm中哪些是自定义哪些是默认。</p>\n<p>再多说一点，在springframework官方文档中，<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#appendix\" target=\"_blank\" rel=\"noopener\">Appendix</a>中定义了几个方便开发的xml Schema，原理就是在这。不过后面会讲如何自定义属性，这里只是简单提一下。</p>\n<p>至此，<code>doLoadBeanDefinitions()</code> 中做的三件事情已经全部分析完毕，下面将对 Bean 的解析过程做详细分析说明。</p>"},{"abbrlink":24,"title":"spring源码分析之 05获取Document对象","author":"fengxiutianya","date":"2019-01-13T20:52:00.000Z","_content":"# spring源码解析之 05获取Document对象\n\n### 概述\n\n1. 获取LoadDocument源码分析\n2. EntityResolver分析\n\n### 获取LoadDocument源码分析\n\n在 `XmlBeanDefinitionReader.doLoadDocument()` 方法中做了两件事情，一是调用 `getValidationModeForResource()` 获取 XML 的验证模式，二是调用 `DocumentLoader.loadDocument()` 获取 Document 对象。上篇博客已经分析了获取 XML 验证模式，这篇我们分析获取 Document 对象。\n<!-- more-->\n获取 Document 的策略由接口 DocumentLoader 定义，如下：\n\n```java\npublic interface DocumentLoader {\n    Document loadDocument(\n            InputSource inputSource, EntityResolver entityResolver,\n            ErrorHandler errorHandler, int validationMode, boolean namespaceAware)\n            throws Exception;\n\n}\n```\n\nDocumentLoader 中只有一个方法 `loadDocument()` ，该方法接收五个参数：\n\n- inputSource：加载 Document 的 Resource 源\n- entityResolver：解析文件的解析器\n- errorHandler：处理加载 Document 对象的过程的错误\n- validationMode：验证模式\n- namespaceAware：命名空间支持。如果要提供对 XML 名称空间的支持，则为true\n\n该方法由 DocumentLoader 的默认实现类 DefaultDocumentLoader 实现，如下：\n\n```java\n    public Document loadDocument(InputSource inputSource, \n                                 EntityResolver entityResolver,\n         \t\t\t\t\t\t ErrorHandler errorHandler, int validationMode,\n                                 boolean namespaceAware) throws Exception {\n\n        DocumentBuilderFactory factory = \n            \tcreateDocumentBuilderFactory(validationMode, namespaceAware);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Using JAXP provider [\" + factory.getClass().getName() + \"]\");\n        }\n        DocumentBuilder builder =\n            createDocumentBuilder(factory, entityResolver, errorHandler);\n        return builder.parse(inputSource);\n    }\n```\n\n对于这部分代码并没有太多可以描述的，因为通过SAX解析XML文档的套路大致都差不多，Spring在这里并没有什么特殊的地方。首先调用 `createDocumentBuilderFactory()` 创建 DocumentBuilderFactory ，再通过该 factory 创建 DocumentBuilder，最后解析 InputSource 返回 Document 对象。不过你如果感兴趣可以自己了解一下。\n\n### EntityResolver分析\n\n通过 `loadDocument()` 获取 Document 对象时，有一个参数 entityResolver ，该参数是通过 `getEntityResolver()` 获取的。何为EntityResolver？官网这样解释，如果SAX应用程序需要实现自定义处理外部实体，则必须实现此接口并使用setEntityReslover方法想SAX驱动器注册一个实例。也就是说，对于解析一个XML，SAX首先读取该XML文档上的声明，根据声明去寻找相应的DTD定义，以便对该文档进行一个验证。默认的寻找规则及通过网络（实现上就是声明的DTD的URI地址）来下载相应的DTD声明，并进行验证。下载的过程是一个漫长的过程，而且当网络中断或不可用时，这里会报错，就是因为相应的DTD声明没有被找到的原因。\n\nEntityResolver的作用是项目本省就可以提供一个如何寻找DTD声明的方法，即有程序来实现寻找DTD声明的过程，比如我们将DTD文件放到项目中某处，在实现时直接将此文档读取并返回给SAX即可。这样就避免了通过网络来寻找相应的声明。\n\n首先看entityResolver的接口的方法声明：\n\nInputSource resolveEntity(String publiId,String systemId)\n\n这里，他接受俩个参数publicId和systemId，返回一个InputSource，这个对象不是我们之前介绍的统一资源那个对象，是org.xml.sax.InputSource这个对象。下面我们以特定的例子来讲解\n\n1. 如果我们在解析验证模式为XSD的配置文件，代码如下\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n   \t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   \t   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n          http://www.springframework.org/schema/beans/spring-beans.xsd\">\n   \n   </beans>\n   ```\n\n   读到以下俩个参数\n\n   * **publicId**:null\n\n   * **systemId**: http://www.springframework.org/schema/beans/spring-beans.xsd\n\n2. 如果我们在解析验证模式为DTD的配置文件，代码如下\n\n   ```xml\n   <!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\"\n   \"http://www.springframework.org/dtd/spring-beans.dtd\">\n   ```\n\n   读取到以下来个参数：\n\n   * **publicId**:\"-//SPRING//DTD BEAN//EN\"\n   * **systemId**：http://www.springframework.org/dtd/spring-beans.dtd\n\n   之前已经提到过，验证文件默认的加载方式是通过URL进行网络下载获取，这样会造成延迟，用户体验也不好，一般的做法都是将验证文件防止在自己的工程里，那么怎么做才能将这个URL转换为自己工程里对应的地址文件呢？我们已加载DTD文件为例来看看Spring中是如何实现的。下面先分析`getEntityResolver`，然后具体讲解一下EntityResolver的实现方式\n\n> `getEntityResolver()` 返回指定的解析器，如果没有指定，则构造一个未指定的默认解析器。\n\n```java\n    protected EntityResolver getEntityResolver() {\n        if (this.entityResolver == null) {\n            ResourceLoader resourceLoader = getResourceLoader();\n            if (resourceLoader != null) {\n                this.entityResolver = new ResourceEntityResolver(resourceLoader);\n            }\n            else {\n                this.entityResolver =\n                    \tnew DelegatingEntityResolver(getBeanClassLoader());\n            }\n        }\n        return this.entityResolver;\n    }\n```\n\n如果 ResourceLoader 不为 null，则根据指定的 ResourceLoader 创建一个 ResourceEntityResolver。如果 ResourceLoader 为null，则创建 一个 DelegatingEntityResolver，该 Resolver 委托给默认的 BeansDtdResolver 和 PluggableSchemaResolver 。\n\n我们就拿DelegatingEntityResolver来具体分析\n\n```java\n\n\tpublic InputSource resolveEntity(String publicId, @Nullable String systemId) throws SAXException, IOException {\n\t\tif (systemId != null) {\n            // 如果是DTD从这里解析\n\t\t\tif (systemId.endsWith(DTD_SUFFIX)) {\n\t\t\t\treturn this.dtdResolver.resolveEntity(publicId, systemId);\n\t\t\t}\n            // 如果是XSD，这里进行解析\n\t\t\telse if (systemId.endsWith(XSD_SUFFIX)) {\n\t\t\t\treturn this.schemaResolver.resolveEntity(publicId, systemId);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n```\n\n可以看到，对不同的验证模式，spring使用了不同的解析器解析。这里简单描述一下原理，比如加载DTD类型的BeansDtdResolver的resolveEntity是直接截取systemId最后的xx.dtd然后去当前路径下寻找，而加载XSD类型的PluggableSchemaResolver类的resolveEntity是默认到META-INF/spring.schemas文件中找到systemId所对应的XSD文件并加载。\n\nBeansDtdResolver 的解析过程如下:\n\n```java\n    public InputSource resolveEntity(String publicId, @Nullable String systemId) \n        \tthrows IOException {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Trying to resolve XML entity with public ID [\" + publicId +\n                    \"] and system ID [\" + systemId + \"]\");\n        }\n        if (systemId != null && systemId.endsWith(DTD_EXTENSION)) {\n            int lastPathSeparator = systemId.lastIndexOf('/');\n            int dtdNameStart = systemId.indexOf(DTD_NAME, lastPathSeparator);\n            if (dtdNameStart != -1) {\n                String dtdFile = DTD_NAME + DTD_EXTENSION;\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Trying to locate [\" + dtdFile + \"] in Spring jar on classpath\");\n                }\n                try {\n                    Resource resource = new ClassPathResource(dtdFile, getClass());\n                    InputSource source = new InputSource(resource.getInputStream());\n                    source.setPublicId(publicId);\n                    source.setSystemId(systemId);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Found beans DTD [\" + systemId + \"] in classpath: \" + dtdFile);\n                    }\n                    return source;\n                }\n                catch (IOException ex) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Could not resolve beans DTD [\" + systemId + \"]: not found in classpath\", ex);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n```\n\n从上面的代码中我们可以看到加载 DTD 类型的 `BeansDtdResolver.resolveEntity()` 只是对 systemId 进行了简单的校验（从最后一个 / 开始，内容中是否包含 `spring-beans`），然后构造一个 InputSource 并设置 publicId、systemId，然后返回。\n\nPluggableSchemaResolver 的解析过程如下:\n\n```java\n    public InputSource resolveEntity(String publicId, @Nullable String systemId) throws IOException {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Trying to resolve XML entity with public id [\" + publicId +\n                    \"] and system id [\" + systemId + \"]\");\n        }\n\n        if (systemId != null) {\n            String resourceLocation = getSchemaMappings().get(systemId);\n            if (resourceLocation != null) {\n                Resource resource = new ClassPathResource(resourceLocation, this.classLoader);\n                try {\n                    InputSource source = new InputSource(resource.getInputStream());\n                    source.setPublicId(publicId);\n                    source.setSystemId(systemId);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Found XML schema [\" + systemId + \"] in classpath: \" + resourceLocation);\n                    }\n                    return source;\n                }\n                catch (FileNotFoundException ex) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Couldn't find XML schema [\" + systemId + \"]: \" + resource, ex);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n```\n\n首先调用 getSchemaMappings() 获取一个映射表(systemId 与其在本地的对照关系)，然后根据传入的 systemId 获取该 systemId 在本地的路径 resourceLocation，最后根据 resourceLocation 构造 InputSource 对象。\n\n下面是getSchemaMappings源码\n\n```java\nprivate Map<String, String> getSchemaMappings() {\n   Map<String, String> schemaMappings = this.schemaMappings;\n   if (schemaMappings == null) {\n      synchronized (this) {\n         schemaMappings = this.schemaMappings;\n         if (schemaMappings == null) {\n            if (logger.isTraceEnabled()) {\n               logger.trace(\"Loading schema mappings from [\" + \n                            this.schemaMappingsLocation + \"]\");\n            }\n            try {\n                //加载XSD的配置，默认存储在META-INF/spring.schemas，\n                // 你也可以更改这个默认存储，不过一般用不到\n               Properties mappings =\n             \t PropertiesLoaderUtils.loadAllProperties\n                \t\t   (this.schemaMappingsLocation, this.classLoader);\n               if (logger.isTraceEnabled()) {\n                  logger.trace(\"Loaded schema mappings: \" + mappings);\n               }\n               schemaMappings = new ConcurrentHashMap<>(mappings.size());\n               CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings);\n               this.schemaMappings = schemaMappings;\n            }\n            catch (IOException ex) {\n               throw new IllegalStateException(\n                     \"Unable to load schema mappings from location [\" + \n                   this.schemaMappingsLocation + \"]\", ex);\n            }\n         }\n      }\n   }\n   return schemaMappings;\n}\n```\n\n从上面可以看到，先去加载指定目录下的所有XSD键值对，然后和当前已经存在XSD键值对合并，然后返回一个Map来方便查找。\n\n下面简单整理一下上面用到的类：\n\n- ResourceEntityResolver：继承自 EntityResolver ，通过 ResourceLoader 来解析实体的引用。\n- DelegatingEntityResolver：EntityResolver 的实现，分别代理了 dtd 的 BeansDtdResolver 和 xml schemas 的 PluggableSchemaResolver。\n- BeansDtdResolver ： spring bean dtd 解析器。EntityResolver 的实现，用来从 classpath 或者 jar 文件加载 dtd。\n- PluggableSchemaResolver：使用 Map存储 schema url和本地文件的位置，并将 schema url 解析到本地 classpath 资源，也就是我们自定义标签存放XSD文件的位置，后面我们说解析自定义标签会在说道这里。","source":"_posts/spring 源码分析/spring/spring源码解析之  05获取Document对象.md","raw":"abbrlink: 24\ntitle: spring源码分析之 05获取Document对象\ntags:\n  - spring源码解析\n  - ''\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-14 04:52:00\n---\n# spring源码解析之 05获取Document对象\n\n### 概述\n\n1. 获取LoadDocument源码分析\n2. EntityResolver分析\n\n### 获取LoadDocument源码分析\n\n在 `XmlBeanDefinitionReader.doLoadDocument()` 方法中做了两件事情，一是调用 `getValidationModeForResource()` 获取 XML 的验证模式，二是调用 `DocumentLoader.loadDocument()` 获取 Document 对象。上篇博客已经分析了获取 XML 验证模式，这篇我们分析获取 Document 对象。\n<!-- more-->\n获取 Document 的策略由接口 DocumentLoader 定义，如下：\n\n```java\npublic interface DocumentLoader {\n    Document loadDocument(\n            InputSource inputSource, EntityResolver entityResolver,\n            ErrorHandler errorHandler, int validationMode, boolean namespaceAware)\n            throws Exception;\n\n}\n```\n\nDocumentLoader 中只有一个方法 `loadDocument()` ，该方法接收五个参数：\n\n- inputSource：加载 Document 的 Resource 源\n- entityResolver：解析文件的解析器\n- errorHandler：处理加载 Document 对象的过程的错误\n- validationMode：验证模式\n- namespaceAware：命名空间支持。如果要提供对 XML 名称空间的支持，则为true\n\n该方法由 DocumentLoader 的默认实现类 DefaultDocumentLoader 实现，如下：\n\n```java\n    public Document loadDocument(InputSource inputSource, \n                                 EntityResolver entityResolver,\n         \t\t\t\t\t\t ErrorHandler errorHandler, int validationMode,\n                                 boolean namespaceAware) throws Exception {\n\n        DocumentBuilderFactory factory = \n            \tcreateDocumentBuilderFactory(validationMode, namespaceAware);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Using JAXP provider [\" + factory.getClass().getName() + \"]\");\n        }\n        DocumentBuilder builder =\n            createDocumentBuilder(factory, entityResolver, errorHandler);\n        return builder.parse(inputSource);\n    }\n```\n\n对于这部分代码并没有太多可以描述的，因为通过SAX解析XML文档的套路大致都差不多，Spring在这里并没有什么特殊的地方。首先调用 `createDocumentBuilderFactory()` 创建 DocumentBuilderFactory ，再通过该 factory 创建 DocumentBuilder，最后解析 InputSource 返回 Document 对象。不过你如果感兴趣可以自己了解一下。\n\n### EntityResolver分析\n\n通过 `loadDocument()` 获取 Document 对象时，有一个参数 entityResolver ，该参数是通过 `getEntityResolver()` 获取的。何为EntityResolver？官网这样解释，如果SAX应用程序需要实现自定义处理外部实体，则必须实现此接口并使用setEntityReslover方法想SAX驱动器注册一个实例。也就是说，对于解析一个XML，SAX首先读取该XML文档上的声明，根据声明去寻找相应的DTD定义，以便对该文档进行一个验证。默认的寻找规则及通过网络（实现上就是声明的DTD的URI地址）来下载相应的DTD声明，并进行验证。下载的过程是一个漫长的过程，而且当网络中断或不可用时，这里会报错，就是因为相应的DTD声明没有被找到的原因。\n\nEntityResolver的作用是项目本省就可以提供一个如何寻找DTD声明的方法，即有程序来实现寻找DTD声明的过程，比如我们将DTD文件放到项目中某处，在实现时直接将此文档读取并返回给SAX即可。这样就避免了通过网络来寻找相应的声明。\n\n首先看entityResolver的接口的方法声明：\n\nInputSource resolveEntity(String publiId,String systemId)\n\n这里，他接受俩个参数publicId和systemId，返回一个InputSource，这个对象不是我们之前介绍的统一资源那个对象，是org.xml.sax.InputSource这个对象。下面我们以特定的例子来讲解\n\n1. 如果我们在解析验证模式为XSD的配置文件，代码如下\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n   \t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   \t   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n          http://www.springframework.org/schema/beans/spring-beans.xsd\">\n   \n   </beans>\n   ```\n\n   读到以下俩个参数\n\n   * **publicId**:null\n\n   * **systemId**: http://www.springframework.org/schema/beans/spring-beans.xsd\n\n2. 如果我们在解析验证模式为DTD的配置文件，代码如下\n\n   ```xml\n   <!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\"\n   \"http://www.springframework.org/dtd/spring-beans.dtd\">\n   ```\n\n   读取到以下来个参数：\n\n   * **publicId**:\"-//SPRING//DTD BEAN//EN\"\n   * **systemId**：http://www.springframework.org/dtd/spring-beans.dtd\n\n   之前已经提到过，验证文件默认的加载方式是通过URL进行网络下载获取，这样会造成延迟，用户体验也不好，一般的做法都是将验证文件防止在自己的工程里，那么怎么做才能将这个URL转换为自己工程里对应的地址文件呢？我们已加载DTD文件为例来看看Spring中是如何实现的。下面先分析`getEntityResolver`，然后具体讲解一下EntityResolver的实现方式\n\n> `getEntityResolver()` 返回指定的解析器，如果没有指定，则构造一个未指定的默认解析器。\n\n```java\n    protected EntityResolver getEntityResolver() {\n        if (this.entityResolver == null) {\n            ResourceLoader resourceLoader = getResourceLoader();\n            if (resourceLoader != null) {\n                this.entityResolver = new ResourceEntityResolver(resourceLoader);\n            }\n            else {\n                this.entityResolver =\n                    \tnew DelegatingEntityResolver(getBeanClassLoader());\n            }\n        }\n        return this.entityResolver;\n    }\n```\n\n如果 ResourceLoader 不为 null，则根据指定的 ResourceLoader 创建一个 ResourceEntityResolver。如果 ResourceLoader 为null，则创建 一个 DelegatingEntityResolver，该 Resolver 委托给默认的 BeansDtdResolver 和 PluggableSchemaResolver 。\n\n我们就拿DelegatingEntityResolver来具体分析\n\n```java\n\n\tpublic InputSource resolveEntity(String publicId, @Nullable String systemId) throws SAXException, IOException {\n\t\tif (systemId != null) {\n            // 如果是DTD从这里解析\n\t\t\tif (systemId.endsWith(DTD_SUFFIX)) {\n\t\t\t\treturn this.dtdResolver.resolveEntity(publicId, systemId);\n\t\t\t}\n            // 如果是XSD，这里进行解析\n\t\t\telse if (systemId.endsWith(XSD_SUFFIX)) {\n\t\t\t\treturn this.schemaResolver.resolveEntity(publicId, systemId);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n```\n\n可以看到，对不同的验证模式，spring使用了不同的解析器解析。这里简单描述一下原理，比如加载DTD类型的BeansDtdResolver的resolveEntity是直接截取systemId最后的xx.dtd然后去当前路径下寻找，而加载XSD类型的PluggableSchemaResolver类的resolveEntity是默认到META-INF/spring.schemas文件中找到systemId所对应的XSD文件并加载。\n\nBeansDtdResolver 的解析过程如下:\n\n```java\n    public InputSource resolveEntity(String publicId, @Nullable String systemId) \n        \tthrows IOException {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Trying to resolve XML entity with public ID [\" + publicId +\n                    \"] and system ID [\" + systemId + \"]\");\n        }\n        if (systemId != null && systemId.endsWith(DTD_EXTENSION)) {\n            int lastPathSeparator = systemId.lastIndexOf('/');\n            int dtdNameStart = systemId.indexOf(DTD_NAME, lastPathSeparator);\n            if (dtdNameStart != -1) {\n                String dtdFile = DTD_NAME + DTD_EXTENSION;\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Trying to locate [\" + dtdFile + \"] in Spring jar on classpath\");\n                }\n                try {\n                    Resource resource = new ClassPathResource(dtdFile, getClass());\n                    InputSource source = new InputSource(resource.getInputStream());\n                    source.setPublicId(publicId);\n                    source.setSystemId(systemId);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Found beans DTD [\" + systemId + \"] in classpath: \" + dtdFile);\n                    }\n                    return source;\n                }\n                catch (IOException ex) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Could not resolve beans DTD [\" + systemId + \"]: not found in classpath\", ex);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n```\n\n从上面的代码中我们可以看到加载 DTD 类型的 `BeansDtdResolver.resolveEntity()` 只是对 systemId 进行了简单的校验（从最后一个 / 开始，内容中是否包含 `spring-beans`），然后构造一个 InputSource 并设置 publicId、systemId，然后返回。\n\nPluggableSchemaResolver 的解析过程如下:\n\n```java\n    public InputSource resolveEntity(String publicId, @Nullable String systemId) throws IOException {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Trying to resolve XML entity with public id [\" + publicId +\n                    \"] and system id [\" + systemId + \"]\");\n        }\n\n        if (systemId != null) {\n            String resourceLocation = getSchemaMappings().get(systemId);\n            if (resourceLocation != null) {\n                Resource resource = new ClassPathResource(resourceLocation, this.classLoader);\n                try {\n                    InputSource source = new InputSource(resource.getInputStream());\n                    source.setPublicId(publicId);\n                    source.setSystemId(systemId);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Found XML schema [\" + systemId + \"] in classpath: \" + resourceLocation);\n                    }\n                    return source;\n                }\n                catch (FileNotFoundException ex) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Couldn't find XML schema [\" + systemId + \"]: \" + resource, ex);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n```\n\n首先调用 getSchemaMappings() 获取一个映射表(systemId 与其在本地的对照关系)，然后根据传入的 systemId 获取该 systemId 在本地的路径 resourceLocation，最后根据 resourceLocation 构造 InputSource 对象。\n\n下面是getSchemaMappings源码\n\n```java\nprivate Map<String, String> getSchemaMappings() {\n   Map<String, String> schemaMappings = this.schemaMappings;\n   if (schemaMappings == null) {\n      synchronized (this) {\n         schemaMappings = this.schemaMappings;\n         if (schemaMappings == null) {\n            if (logger.isTraceEnabled()) {\n               logger.trace(\"Loading schema mappings from [\" + \n                            this.schemaMappingsLocation + \"]\");\n            }\n            try {\n                //加载XSD的配置，默认存储在META-INF/spring.schemas，\n                // 你也可以更改这个默认存储，不过一般用不到\n               Properties mappings =\n             \t PropertiesLoaderUtils.loadAllProperties\n                \t\t   (this.schemaMappingsLocation, this.classLoader);\n               if (logger.isTraceEnabled()) {\n                  logger.trace(\"Loaded schema mappings: \" + mappings);\n               }\n               schemaMappings = new ConcurrentHashMap<>(mappings.size());\n               CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings);\n               this.schemaMappings = schemaMappings;\n            }\n            catch (IOException ex) {\n               throw new IllegalStateException(\n                     \"Unable to load schema mappings from location [\" + \n                   this.schemaMappingsLocation + \"]\", ex);\n            }\n         }\n      }\n   }\n   return schemaMappings;\n}\n```\n\n从上面可以看到，先去加载指定目录下的所有XSD键值对，然后和当前已经存在XSD键值对合并，然后返回一个Map来方便查找。\n\n下面简单整理一下上面用到的类：\n\n- ResourceEntityResolver：继承自 EntityResolver ，通过 ResourceLoader 来解析实体的引用。\n- DelegatingEntityResolver：EntityResolver 的实现，分别代理了 dtd 的 BeansDtdResolver 和 xml schemas 的 PluggableSchemaResolver。\n- BeansDtdResolver ： spring bean dtd 解析器。EntityResolver 的实现，用来从 classpath 或者 jar 文件加载 dtd。\n- PluggableSchemaResolver：使用 Map存储 schema url和本地文件的位置，并将 schema url 解析到本地 classpath 资源，也就是我们自定义标签存放XSD文件的位置，后面我们说解析自定义标签会在说道这里。","slug":"spring 源码分析/spring/spring源码解析之  05获取Document对象","published":1,"updated":"2019-01-15T03:38:14.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovw6004c9q1uib6n08f4","content":"<h1 id=\"spring源码解析之-05获取Document对象\"><a href=\"#spring源码解析之-05获取Document对象\" class=\"headerlink\" title=\"spring源码解析之 05获取Document对象\"></a>spring源码解析之 05获取Document对象</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>获取LoadDocument源码分析</li>\n<li>EntityResolver分析</li>\n</ol>\n<h3 id=\"获取LoadDocument源码分析\"><a href=\"#获取LoadDocument源码分析\" class=\"headerlink\" title=\"获取LoadDocument源码分析\"></a>获取LoadDocument源码分析</h3><p>在 <code>XmlBeanDefinitionReader.doLoadDocument()</code> 方法中做了两件事情，一是调用 <code>getValidationModeForResource()</code> 获取 XML 的验证模式，二是调用 <code>DocumentLoader.loadDocument()</code> 获取 Document 对象。上篇博客已经分析了获取 XML 验证模式，这篇我们分析获取 Document 对象。<br><a id=\"more\"></a><br>获取 Document 的策略由接口 DocumentLoader 定义，如下：</p>\n<pre><code class=\"java\">public interface DocumentLoader {\n    Document loadDocument(\n            InputSource inputSource, EntityResolver entityResolver,\n            ErrorHandler errorHandler, int validationMode, boolean namespaceAware)\n            throws Exception;\n\n}\n</code></pre>\n<p>DocumentLoader 中只有一个方法 <code>loadDocument()</code> ，该方法接收五个参数：</p>\n<ul>\n<li>inputSource：加载 Document 的 Resource 源</li>\n<li>entityResolver：解析文件的解析器</li>\n<li>errorHandler：处理加载 Document 对象的过程的错误</li>\n<li>validationMode：验证模式</li>\n<li>namespaceAware：命名空间支持。如果要提供对 XML 名称空间的支持，则为true</li>\n</ul>\n<p>该方法由 DocumentLoader 的默认实现类 DefaultDocumentLoader 实现，如下：</p>\n<pre><code class=\"java\">    public Document loadDocument(InputSource inputSource, \n                                 EntityResolver entityResolver,\n                                  ErrorHandler errorHandler, int validationMode,\n                                 boolean namespaceAware) throws Exception {\n\n        DocumentBuilderFactory factory = \n                createDocumentBuilderFactory(validationMode, namespaceAware);\n        if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);\n        }\n        DocumentBuilder builder =\n            createDocumentBuilder(factory, entityResolver, errorHandler);\n        return builder.parse(inputSource);\n    }\n</code></pre>\n<p>对于这部分代码并没有太多可以描述的，因为通过SAX解析XML文档的套路大致都差不多，Spring在这里并没有什么特殊的地方。首先调用 <code>createDocumentBuilderFactory()</code> 创建 DocumentBuilderFactory ，再通过该 factory 创建 DocumentBuilder，最后解析 InputSource 返回 Document 对象。不过你如果感兴趣可以自己了解一下。</p>\n<h3 id=\"EntityResolver分析\"><a href=\"#EntityResolver分析\" class=\"headerlink\" title=\"EntityResolver分析\"></a>EntityResolver分析</h3><p>通过 <code>loadDocument()</code> 获取 Document 对象时，有一个参数 entityResolver ，该参数是通过 <code>getEntityResolver()</code> 获取的。何为EntityResolver？官网这样解释，如果SAX应用程序需要实现自定义处理外部实体，则必须实现此接口并使用setEntityReslover方法想SAX驱动器注册一个实例。也就是说，对于解析一个XML，SAX首先读取该XML文档上的声明，根据声明去寻找相应的DTD定义，以便对该文档进行一个验证。默认的寻找规则及通过网络（实现上就是声明的DTD的URI地址）来下载相应的DTD声明，并进行验证。下载的过程是一个漫长的过程，而且当网络中断或不可用时，这里会报错，就是因为相应的DTD声明没有被找到的原因。</p>\n<p>EntityResolver的作用是项目本省就可以提供一个如何寻找DTD声明的方法，即有程序来实现寻找DTD声明的过程，比如我们将DTD文件放到项目中某处，在实现时直接将此文档读取并返回给SAX即可。这样就避免了通过网络来寻找相应的声明。</p>\n<p>首先看entityResolver的接口的方法声明：</p>\n<p>InputSource resolveEntity(String publiId,String systemId)</p>\n<p>这里，他接受俩个参数publicId和systemId，返回一个InputSource，这个对象不是我们之前介绍的统一资源那个对象，是org.xml.sax.InputSource这个对象。下面我们以特定的例子来讲解</p>\n<ol>\n<li><p>如果我们在解析验证模式为XSD的配置文件，代码如下</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<p>读到以下俩个参数</p>\n<ul>\n<li><p><strong>publicId</strong>:null</p>\n</li>\n<li><p><strong>systemId</strong>: <a href=\"http://www.springframework.org/schema/beans/spring-beans.xsd\" target=\"_blank\" rel=\"noopener\">http://www.springframework.org/schema/beans/spring-beans.xsd</a></p>\n</li>\n</ul>\n</li>\n<li><p>如果我们在解析验证模式为DTD的配置文件，代码如下</p>\n<pre><code class=\"xml\">&lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN//EN&quot;\n&quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;&gt;\n</code></pre>\n<p>读取到以下来个参数：</p>\n<ul>\n<li><strong>publicId</strong>:”-//SPRING//DTD BEAN//EN”</li>\n<li><strong>systemId</strong>：<a href=\"http://www.springframework.org/dtd/spring-beans.dtd\" target=\"_blank\" rel=\"noopener\">http://www.springframework.org/dtd/spring-beans.dtd</a></li>\n</ul>\n<p>之前已经提到过，验证文件默认的加载方式是通过URL进行网络下载获取，这样会造成延迟，用户体验也不好，一般的做法都是将验证文件防止在自己的工程里，那么怎么做才能将这个URL转换为自己工程里对应的地址文件呢？我们已加载DTD文件为例来看看Spring中是如何实现的。下面先分析<code>getEntityResolver</code>，然后具体讲解一下EntityResolver的实现方式</p>\n</li>\n</ol>\n<blockquote>\n<p><code>getEntityResolver()</code> 返回指定的解析器，如果没有指定，则构造一个未指定的默认解析器。</p>\n</blockquote>\n<pre><code class=\"java\">    protected EntityResolver getEntityResolver() {\n        if (this.entityResolver == null) {\n            ResourceLoader resourceLoader = getResourceLoader();\n            if (resourceLoader != null) {\n                this.entityResolver = new ResourceEntityResolver(resourceLoader);\n            }\n            else {\n                this.entityResolver =\n                        new DelegatingEntityResolver(getBeanClassLoader());\n            }\n        }\n        return this.entityResolver;\n    }\n</code></pre>\n<p>如果 ResourceLoader 不为 null，则根据指定的 ResourceLoader 创建一个 ResourceEntityResolver。如果 ResourceLoader 为null，则创建 一个 DelegatingEntityResolver，该 Resolver 委托给默认的 BeansDtdResolver 和 PluggableSchemaResolver 。</p>\n<p>我们就拿DelegatingEntityResolver来具体分析</p>\n<pre><code class=\"java\">\n    public InputSource resolveEntity(String publicId, @Nullable String systemId) throws SAXException, IOException {\n        if (systemId != null) {\n            // 如果是DTD从这里解析\n            if (systemId.endsWith(DTD_SUFFIX)) {\n                return this.dtdResolver.resolveEntity(publicId, systemId);\n            }\n            // 如果是XSD，这里进行解析\n            else if (systemId.endsWith(XSD_SUFFIX)) {\n                return this.schemaResolver.resolveEntity(publicId, systemId);\n            }\n        }\n        return null;\n    }\n\n</code></pre>\n<p>可以看到，对不同的验证模式，spring使用了不同的解析器解析。这里简单描述一下原理，比如加载DTD类型的BeansDtdResolver的resolveEntity是直接截取systemId最后的xx.dtd然后去当前路径下寻找，而加载XSD类型的PluggableSchemaResolver类的resolveEntity是默认到META-INF/spring.schemas文件中找到systemId所对应的XSD文件并加载。</p>\n<p>BeansDtdResolver 的解析过程如下:</p>\n<pre><code class=\"java\">    public InputSource resolveEntity(String publicId, @Nullable String systemId) \n            throws IOException {\n        if (logger.isTraceEnabled()) {\n            logger.trace(&quot;Trying to resolve XML entity with public ID [&quot; + publicId +\n                    &quot;] and system ID [&quot; + systemId + &quot;]&quot;);\n        }\n        if (systemId != null &amp;&amp; systemId.endsWith(DTD_EXTENSION)) {\n            int lastPathSeparator = systemId.lastIndexOf(&#39;/&#39;);\n            int dtdNameStart = systemId.indexOf(DTD_NAME, lastPathSeparator);\n            if (dtdNameStart != -1) {\n                String dtdFile = DTD_NAME + DTD_EXTENSION;\n                if (logger.isTraceEnabled()) {\n                    logger.trace(&quot;Trying to locate [&quot; + dtdFile + &quot;] in Spring jar on classpath&quot;);\n                }\n                try {\n                    Resource resource = new ClassPathResource(dtdFile, getClass());\n                    InputSource source = new InputSource(resource.getInputStream());\n                    source.setPublicId(publicId);\n                    source.setSystemId(systemId);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(&quot;Found beans DTD [&quot; + systemId + &quot;] in classpath: &quot; + dtdFile);\n                    }\n                    return source;\n                }\n                catch (IOException ex) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(&quot;Could not resolve beans DTD [&quot; + systemId + &quot;]: not found in classpath&quot;, ex);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n</code></pre>\n<p>从上面的代码中我们可以看到加载 DTD 类型的 <code>BeansDtdResolver.resolveEntity()</code> 只是对 systemId 进行了简单的校验（从最后一个 / 开始，内容中是否包含 <code>spring-beans</code>），然后构造一个 InputSource 并设置 publicId、systemId，然后返回。</p>\n<p>PluggableSchemaResolver 的解析过程如下:</p>\n<pre><code class=\"java\">    public InputSource resolveEntity(String publicId, @Nullable String systemId) throws IOException {\n        if (logger.isTraceEnabled()) {\n            logger.trace(&quot;Trying to resolve XML entity with public id [&quot; + publicId +\n                    &quot;] and system id [&quot; + systemId + &quot;]&quot;);\n        }\n\n        if (systemId != null) {\n            String resourceLocation = getSchemaMappings().get(systemId);\n            if (resourceLocation != null) {\n                Resource resource = new ClassPathResource(resourceLocation, this.classLoader);\n                try {\n                    InputSource source = new InputSource(resource.getInputStream());\n                    source.setPublicId(publicId);\n                    source.setSystemId(systemId);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(&quot;Found XML schema [&quot; + systemId + &quot;] in classpath: &quot; + resourceLocation);\n                    }\n                    return source;\n                }\n                catch (FileNotFoundException ex) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(&quot;Couldn&#39;t find XML schema [&quot; + systemId + &quot;]: &quot; + resource, ex);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n</code></pre>\n<p>首先调用 getSchemaMappings() 获取一个映射表(systemId 与其在本地的对照关系)，然后根据传入的 systemId 获取该 systemId 在本地的路径 resourceLocation，最后根据 resourceLocation 构造 InputSource 对象。</p>\n<p>下面是getSchemaMappings源码</p>\n<pre><code class=\"java\">private Map&lt;String, String&gt; getSchemaMappings() {\n   Map&lt;String, String&gt; schemaMappings = this.schemaMappings;\n   if (schemaMappings == null) {\n      synchronized (this) {\n         schemaMappings = this.schemaMappings;\n         if (schemaMappings == null) {\n            if (logger.isTraceEnabled()) {\n               logger.trace(&quot;Loading schema mappings from [&quot; + \n                            this.schemaMappingsLocation + &quot;]&quot;);\n            }\n            try {\n                //加载XSD的配置，默认存储在META-INF/spring.schemas，\n                // 你也可以更改这个默认存储，不过一般用不到\n               Properties mappings =\n                  PropertiesLoaderUtils.loadAllProperties\n                           (this.schemaMappingsLocation, this.classLoader);\n               if (logger.isTraceEnabled()) {\n                  logger.trace(&quot;Loaded schema mappings: &quot; + mappings);\n               }\n               schemaMappings = new ConcurrentHashMap&lt;&gt;(mappings.size());\n               CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings);\n               this.schemaMappings = schemaMappings;\n            }\n            catch (IOException ex) {\n               throw new IllegalStateException(\n                     &quot;Unable to load schema mappings from location [&quot; + \n                   this.schemaMappingsLocation + &quot;]&quot;, ex);\n            }\n         }\n      }\n   }\n   return schemaMappings;\n}\n</code></pre>\n<p>从上面可以看到，先去加载指定目录下的所有XSD键值对，然后和当前已经存在XSD键值对合并，然后返回一个Map来方便查找。</p>\n<p>下面简单整理一下上面用到的类：</p>\n<ul>\n<li>ResourceEntityResolver：继承自 EntityResolver ，通过 ResourceLoader 来解析实体的引用。</li>\n<li>DelegatingEntityResolver：EntityResolver 的实现，分别代理了 dtd 的 BeansDtdResolver 和 xml schemas 的 PluggableSchemaResolver。</li>\n<li>BeansDtdResolver ： spring bean dtd 解析器。EntityResolver 的实现，用来从 classpath 或者 jar 文件加载 dtd。</li>\n<li>PluggableSchemaResolver：使用 Map存储 schema url和本地文件的位置，并将 schema url 解析到本地 classpath 资源，也就是我们自定义标签存放XSD文件的位置，后面我们说解析自定义标签会在说道这里。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-05获取Document对象\"><a href=\"#spring源码解析之-05获取Document对象\" class=\"headerlink\" title=\"spring源码解析之 05获取Document对象\"></a>spring源码解析之 05获取Document对象</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>获取LoadDocument源码分析</li>\n<li>EntityResolver分析</li>\n</ol>\n<h3 id=\"获取LoadDocument源码分析\"><a href=\"#获取LoadDocument源码分析\" class=\"headerlink\" title=\"获取LoadDocument源码分析\"></a>获取LoadDocument源码分析</h3><p>在 <code>XmlBeanDefinitionReader.doLoadDocument()</code> 方法中做了两件事情，一是调用 <code>getValidationModeForResource()</code> 获取 XML 的验证模式，二是调用 <code>DocumentLoader.loadDocument()</code> 获取 Document 对象。上篇博客已经分析了获取 XML 验证模式，这篇我们分析获取 Document 对象。<br>","more":"<br>获取 Document 的策略由接口 DocumentLoader 定义，如下：</p>\n<pre><code class=\"java\">public interface DocumentLoader {\n    Document loadDocument(\n            InputSource inputSource, EntityResolver entityResolver,\n            ErrorHandler errorHandler, int validationMode, boolean namespaceAware)\n            throws Exception;\n\n}\n</code></pre>\n<p>DocumentLoader 中只有一个方法 <code>loadDocument()</code> ，该方法接收五个参数：</p>\n<ul>\n<li>inputSource：加载 Document 的 Resource 源</li>\n<li>entityResolver：解析文件的解析器</li>\n<li>errorHandler：处理加载 Document 对象的过程的错误</li>\n<li>validationMode：验证模式</li>\n<li>namespaceAware：命名空间支持。如果要提供对 XML 名称空间的支持，则为true</li>\n</ul>\n<p>该方法由 DocumentLoader 的默认实现类 DefaultDocumentLoader 实现，如下：</p>\n<pre><code class=\"java\">    public Document loadDocument(InputSource inputSource, \n                                 EntityResolver entityResolver,\n                                  ErrorHandler errorHandler, int validationMode,\n                                 boolean namespaceAware) throws Exception {\n\n        DocumentBuilderFactory factory = \n                createDocumentBuilderFactory(validationMode, namespaceAware);\n        if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);\n        }\n        DocumentBuilder builder =\n            createDocumentBuilder(factory, entityResolver, errorHandler);\n        return builder.parse(inputSource);\n    }\n</code></pre>\n<p>对于这部分代码并没有太多可以描述的，因为通过SAX解析XML文档的套路大致都差不多，Spring在这里并没有什么特殊的地方。首先调用 <code>createDocumentBuilderFactory()</code> 创建 DocumentBuilderFactory ，再通过该 factory 创建 DocumentBuilder，最后解析 InputSource 返回 Document 对象。不过你如果感兴趣可以自己了解一下。</p>\n<h3 id=\"EntityResolver分析\"><a href=\"#EntityResolver分析\" class=\"headerlink\" title=\"EntityResolver分析\"></a>EntityResolver分析</h3><p>通过 <code>loadDocument()</code> 获取 Document 对象时，有一个参数 entityResolver ，该参数是通过 <code>getEntityResolver()</code> 获取的。何为EntityResolver？官网这样解释，如果SAX应用程序需要实现自定义处理外部实体，则必须实现此接口并使用setEntityReslover方法想SAX驱动器注册一个实例。也就是说，对于解析一个XML，SAX首先读取该XML文档上的声明，根据声明去寻找相应的DTD定义，以便对该文档进行一个验证。默认的寻找规则及通过网络（实现上就是声明的DTD的URI地址）来下载相应的DTD声明，并进行验证。下载的过程是一个漫长的过程，而且当网络中断或不可用时，这里会报错，就是因为相应的DTD声明没有被找到的原因。</p>\n<p>EntityResolver的作用是项目本省就可以提供一个如何寻找DTD声明的方法，即有程序来实现寻找DTD声明的过程，比如我们将DTD文件放到项目中某处，在实现时直接将此文档读取并返回给SAX即可。这样就避免了通过网络来寻找相应的声明。</p>\n<p>首先看entityResolver的接口的方法声明：</p>\n<p>InputSource resolveEntity(String publiId,String systemId)</p>\n<p>这里，他接受俩个参数publicId和systemId，返回一个InputSource，这个对象不是我们之前介绍的统一资源那个对象，是org.xml.sax.InputSource这个对象。下面我们以特定的例子来讲解</p>\n<ol>\n<li><p>如果我们在解析验证模式为XSD的配置文件，代码如下</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<p>读到以下俩个参数</p>\n<ul>\n<li><p><strong>publicId</strong>:null</p>\n</li>\n<li><p><strong>systemId</strong>: <a href=\"http://www.springframework.org/schema/beans/spring-beans.xsd\" target=\"_blank\" rel=\"noopener\">http://www.springframework.org/schema/beans/spring-beans.xsd</a></p>\n</li>\n</ul>\n</li>\n<li><p>如果我们在解析验证模式为DTD的配置文件，代码如下</p>\n<pre><code class=\"xml\">&lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN//EN&quot;\n&quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;&gt;\n</code></pre>\n<p>读取到以下来个参数：</p>\n<ul>\n<li><strong>publicId</strong>:”-//SPRING//DTD BEAN//EN”</li>\n<li><strong>systemId</strong>：<a href=\"http://www.springframework.org/dtd/spring-beans.dtd\" target=\"_blank\" rel=\"noopener\">http://www.springframework.org/dtd/spring-beans.dtd</a></li>\n</ul>\n<p>之前已经提到过，验证文件默认的加载方式是通过URL进行网络下载获取，这样会造成延迟，用户体验也不好，一般的做法都是将验证文件防止在自己的工程里，那么怎么做才能将这个URL转换为自己工程里对应的地址文件呢？我们已加载DTD文件为例来看看Spring中是如何实现的。下面先分析<code>getEntityResolver</code>，然后具体讲解一下EntityResolver的实现方式</p>\n</li>\n</ol>\n<blockquote>\n<p><code>getEntityResolver()</code> 返回指定的解析器，如果没有指定，则构造一个未指定的默认解析器。</p>\n</blockquote>\n<pre><code class=\"java\">    protected EntityResolver getEntityResolver() {\n        if (this.entityResolver == null) {\n            ResourceLoader resourceLoader = getResourceLoader();\n            if (resourceLoader != null) {\n                this.entityResolver = new ResourceEntityResolver(resourceLoader);\n            }\n            else {\n                this.entityResolver =\n                        new DelegatingEntityResolver(getBeanClassLoader());\n            }\n        }\n        return this.entityResolver;\n    }\n</code></pre>\n<p>如果 ResourceLoader 不为 null，则根据指定的 ResourceLoader 创建一个 ResourceEntityResolver。如果 ResourceLoader 为null，则创建 一个 DelegatingEntityResolver，该 Resolver 委托给默认的 BeansDtdResolver 和 PluggableSchemaResolver 。</p>\n<p>我们就拿DelegatingEntityResolver来具体分析</p>\n<pre><code class=\"java\">\n    public InputSource resolveEntity(String publicId, @Nullable String systemId) throws SAXException, IOException {\n        if (systemId != null) {\n            // 如果是DTD从这里解析\n            if (systemId.endsWith(DTD_SUFFIX)) {\n                return this.dtdResolver.resolveEntity(publicId, systemId);\n            }\n            // 如果是XSD，这里进行解析\n            else if (systemId.endsWith(XSD_SUFFIX)) {\n                return this.schemaResolver.resolveEntity(publicId, systemId);\n            }\n        }\n        return null;\n    }\n\n</code></pre>\n<p>可以看到，对不同的验证模式，spring使用了不同的解析器解析。这里简单描述一下原理，比如加载DTD类型的BeansDtdResolver的resolveEntity是直接截取systemId最后的xx.dtd然后去当前路径下寻找，而加载XSD类型的PluggableSchemaResolver类的resolveEntity是默认到META-INF/spring.schemas文件中找到systemId所对应的XSD文件并加载。</p>\n<p>BeansDtdResolver 的解析过程如下:</p>\n<pre><code class=\"java\">    public InputSource resolveEntity(String publicId, @Nullable String systemId) \n            throws IOException {\n        if (logger.isTraceEnabled()) {\n            logger.trace(&quot;Trying to resolve XML entity with public ID [&quot; + publicId +\n                    &quot;] and system ID [&quot; + systemId + &quot;]&quot;);\n        }\n        if (systemId != null &amp;&amp; systemId.endsWith(DTD_EXTENSION)) {\n            int lastPathSeparator = systemId.lastIndexOf(&#39;/&#39;);\n            int dtdNameStart = systemId.indexOf(DTD_NAME, lastPathSeparator);\n            if (dtdNameStart != -1) {\n                String dtdFile = DTD_NAME + DTD_EXTENSION;\n                if (logger.isTraceEnabled()) {\n                    logger.trace(&quot;Trying to locate [&quot; + dtdFile + &quot;] in Spring jar on classpath&quot;);\n                }\n                try {\n                    Resource resource = new ClassPathResource(dtdFile, getClass());\n                    InputSource source = new InputSource(resource.getInputStream());\n                    source.setPublicId(publicId);\n                    source.setSystemId(systemId);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(&quot;Found beans DTD [&quot; + systemId + &quot;] in classpath: &quot; + dtdFile);\n                    }\n                    return source;\n                }\n                catch (IOException ex) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(&quot;Could not resolve beans DTD [&quot; + systemId + &quot;]: not found in classpath&quot;, ex);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n</code></pre>\n<p>从上面的代码中我们可以看到加载 DTD 类型的 <code>BeansDtdResolver.resolveEntity()</code> 只是对 systemId 进行了简单的校验（从最后一个 / 开始，内容中是否包含 <code>spring-beans</code>），然后构造一个 InputSource 并设置 publicId、systemId，然后返回。</p>\n<p>PluggableSchemaResolver 的解析过程如下:</p>\n<pre><code class=\"java\">    public InputSource resolveEntity(String publicId, @Nullable String systemId) throws IOException {\n        if (logger.isTraceEnabled()) {\n            logger.trace(&quot;Trying to resolve XML entity with public id [&quot; + publicId +\n                    &quot;] and system id [&quot; + systemId + &quot;]&quot;);\n        }\n\n        if (systemId != null) {\n            String resourceLocation = getSchemaMappings().get(systemId);\n            if (resourceLocation != null) {\n                Resource resource = new ClassPathResource(resourceLocation, this.classLoader);\n                try {\n                    InputSource source = new InputSource(resource.getInputStream());\n                    source.setPublicId(publicId);\n                    source.setSystemId(systemId);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(&quot;Found XML schema [&quot; + systemId + &quot;] in classpath: &quot; + resourceLocation);\n                    }\n                    return source;\n                }\n                catch (FileNotFoundException ex) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(&quot;Couldn&#39;t find XML schema [&quot; + systemId + &quot;]: &quot; + resource, ex);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n</code></pre>\n<p>首先调用 getSchemaMappings() 获取一个映射表(systemId 与其在本地的对照关系)，然后根据传入的 systemId 获取该 systemId 在本地的路径 resourceLocation，最后根据 resourceLocation 构造 InputSource 对象。</p>\n<p>下面是getSchemaMappings源码</p>\n<pre><code class=\"java\">private Map&lt;String, String&gt; getSchemaMappings() {\n   Map&lt;String, String&gt; schemaMappings = this.schemaMappings;\n   if (schemaMappings == null) {\n      synchronized (this) {\n         schemaMappings = this.schemaMappings;\n         if (schemaMappings == null) {\n            if (logger.isTraceEnabled()) {\n               logger.trace(&quot;Loading schema mappings from [&quot; + \n                            this.schemaMappingsLocation + &quot;]&quot;);\n            }\n            try {\n                //加载XSD的配置，默认存储在META-INF/spring.schemas，\n                // 你也可以更改这个默认存储，不过一般用不到\n               Properties mappings =\n                  PropertiesLoaderUtils.loadAllProperties\n                           (this.schemaMappingsLocation, this.classLoader);\n               if (logger.isTraceEnabled()) {\n                  logger.trace(&quot;Loaded schema mappings: &quot; + mappings);\n               }\n               schemaMappings = new ConcurrentHashMap&lt;&gt;(mappings.size());\n               CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings);\n               this.schemaMappings = schemaMappings;\n            }\n            catch (IOException ex) {\n               throw new IllegalStateException(\n                     &quot;Unable to load schema mappings from location [&quot; + \n                   this.schemaMappingsLocation + &quot;]&quot;, ex);\n            }\n         }\n      }\n   }\n   return schemaMappings;\n}\n</code></pre>\n<p>从上面可以看到，先去加载指定目录下的所有XSD键值对，然后和当前已经存在XSD键值对合并，然后返回一个Map来方便查找。</p>\n<p>下面简单整理一下上面用到的类：</p>\n<ul>\n<li>ResourceEntityResolver：继承自 EntityResolver ，通过 ResourceLoader 来解析实体的引用。</li>\n<li>DelegatingEntityResolver：EntityResolver 的实现，分别代理了 dtd 的 BeansDtdResolver 和 xml schemas 的 PluggableSchemaResolver。</li>\n<li>BeansDtdResolver ： spring bean dtd 解析器。EntityResolver 的实现，用来从 classpath 或者 jar 文件加载 dtd。</li>\n<li>PluggableSchemaResolver：使用 Map存储 schema url和本地文件的位置，并将 schema url 解析到本地 classpath 资源，也就是我们自定义标签存放XSD文件的位置，后面我们说解析自定义标签会在说道这里。</li>\n</ul>"},{"abbrlink":26,"title":"spring源码解析之 07bean标签:开启解析进程","author":"fengxiutianya","date":"2019-01-13T21:11:00.000Z","_content":"# spring 源码解析之bean标签:开启解析进程\n\n### 概述\n\n1. parseDefaultElement\n2. processBeanDefinition (bean标签的解析即注册)\n3. 解析BeanDefinition\n<!-- more-->\n### parseDefaultElement\n\nSpring 中有两种解析 Bean 的方式。如果根节点或者子节点采用默认命名空间的话，则调用 `parseDefaultElement()` 进行默认标签解析，否则调用 `delegate.parseCustomElement()` 方法进行自定义解析。所以以下博客就这两个方法进行详细分析说明，先从默认标签解析过程开始，源码如下：\n\n```java\n    private void parseDefaultElement(Element ele, \n                                     BeanDefinitionParserDelegate delegate) {\n       // 对 import 标签的解析\n        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n            importBeanDefinitionResource(ele);\n        }\n        // 对 alias 标签的解析\n        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n            processAliasRegistration(ele);\n        }\n        // 对 bean 标签的解析\n        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n            processBeanDefinition(ele, delegate);\n        }\n        // 对 beans 标签的解析\n        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n            // recurse\n            doRegisterBeanDefinitions(ele);\n        }\n    }\n```\n\n方法的功能一目了然，分别是对四种不同的标签进行解析，分别是 import、alias、bean、beans。咱门从最富在的标签bean 开始，如果能理解此标签的解析过程，其他的标签的解析自然会迎刃而解。\n\n### processBeanDefinition (bean标签的解析即注册)\n\n如果遇到标签为 bean 则调用 `processBeanDefinition()` 方法进行 bean 标签解析，如下：\n\n```java\n    protected void processBeanDefinition(Element ele,\n                                         BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,                 \n      \t\t\t\t\t\t\t\t getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\n                    \"Failed to register bean definition with name '\" +\n                        bdHolder.getBeanName() + \"'\", ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(\n                new BeanComponentDefinition(bdHolder));                                \n        }\n    }\n```\n\n整个过程分为四个步骤\n\n1. 调用 `BeanDefinitionParserDelegate.parseBeanDefinitionElement()` 进行元素解析，解析过程中如果失败，返回 null，错误由 `ProblemReporter` 处理。如果解析成功则返回 BeanDefinitionHolder 实例 bdHolder。BeanDefinitionHolder 为持有 name 和 alias 的 BeanDefinition。\n2. 若实例 bdHolder 不为空，则调用 `BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired()`进行自定义标签处理\n3. 解析完成后，则调用 `BeanDefinitionReaderUtils.registerBeanDefinition()` 对 bdHolder 进行注册\n4. 发出响应事件，通知相关的监听器，完成 Bean 标签解析\n\n### 解析BeanDefinition\n\n下面我们就针对各个操作做具体分析。首先我们从元素解析即信息提取开始，也就是`BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);` 进入BeanDefinitionDelegate类的parseBeanDefinitionElement方法。\n\n```java\n    @Nullable\n\tpublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, \n                                      @Nullable BeanDefinition containingBean) {\n        // 解析id属性\n\t\tString id = ele.getAttribute(ID_ATTRIBUTE);\n        // 解析name属性\n\t\tString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\t\t// 分割name属性\n\t\tList<String> aliases = new ArrayList<>();\n\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\tString[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, \n                              MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n\t\t\taliases.addAll(Arrays.asList(nameArr));\n\t\t}\n\n        // 设置beanName 如果有id，则设置id值，如果不存在，则使用name属性值的第一个元素\n\t\tString beanName = id;\n\t\tif (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {\n\t\t\tbeanName = aliases.remove(0);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No XML 'id' specified - using '\" + beanName +\n\t\t\t\t\t\t\"' as bean name and \" + aliases + \" as aliases\");\n\t\t\t}\n\t\t}\n\n        // 检查name的唯一性,也包括对别名的检查\n\t\tif (containingBean == null) {\n\t\t\tcheckNameUniqueness(beanName, aliases, ele);\n\t\t}\n\t\t// 解析 属性，构造 AbstractBeanDefinition\n\t\tAbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele,\n                                  beanName, containingBean);\n\t\tif (beanDefinition != null) {\n             // 如果 beanName 不存在，则根据条件构造一个 beanName\n\t\t\tif (!StringUtils.hasText(beanName)) {\n\t\t\t\ttry {\n\t\t\t\t\tif (containingBean != null) {\n\t\t\t\t\t\tbeanName = BeanDefinitionReaderUtils.generateBeanName(\n\t\t\t\t\t\t\t\tbeanDefinition, this.readerContext.getRegistry(), \n                            \t\t\ttrue);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbeanName = this.readerContext.generateBeanName(beanDefinition);\n\t\t\t\t\t\t// 如果此bean的className没有在别名只能怪使用，则注册此bean的className\n                        // 为此bean的别名\n\t\t\t\t\t\tString beanClassName = beanDefinition.getBeanClassName();\n\t\t\t\t\t\tif (beanClassName != null &&\n\t\t\t\t\t\t\t\tbeanName.startsWith(beanClassName) &&\n                            beanName.length() > beanClassName.length() &&\n\t\t\t\t\t!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\taliases.add(beanClassName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Neither XML 'id' nor 'name' specified - \" +\n\t\t\t\t\t\t\t\t\"using generated bean name [\" + beanName + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\terror(ex.getMessage(), ele);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString[] aliasesArray = StringUtils.toStringArray(aliases);\n            // 封装BeanDefinitionHolder\n\t\t\treturn new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n\t\t}\n\t\treturn null;\n\t}\n```\n\n这个方法还没有对 Bean 标签进行解析，只是在解析动作之前做了一些功能架构，主要的工作有：\n\n- 解析 id、name 属性，确定 alias 集合，检测 beanName 是否唯一\n- 调用方法 `parseBeanDefinitionElement()` 对属性进行解析并封装成 GenericBeanDefinition 实例 beanDefinition\n- 如果检测到bean没有指定beanName，那么使用默认规则为此BEan生成beanName\n- 根据所获取的信息（beanName、aliases、beanDefinition）构造 BeanDefinitionHolder 实例对象并返回。\n\n这里有必要说下 beanName 的命名规则：如果 id 不为空，则 beanName = id；如果 id 为空，但是 alias 不空，则 beanName 为 alias 的第一个元素，如果两者都为空，则根据默认规则来设置 beanName。\n\n上面三个步骤第二个步骤为核心方法，它主要承担解析 Bean 标签中所有的属性值。如下：\n\n```java\n   public AbstractBeanDefinition parseBeanDefinitionElement(\n            Element ele, String beanName, @Nullable BeanDefinition containingBean) {\n\n        this.parseState.push(new BeanEntry(beanName));\n\n        String className = null;\n        // 解析 class 属性\n        if (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n            className = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n        }\n        String parent = null;\n\n        // 解析 parent 属性\n        if (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n            parent = ele.getAttribute(PARENT_ATTRIBUTE);\n        }\n\n        try {\n\n            // 创建用于承载属性的 GenericBeanDefinition 实例\n            AbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n            // 解析默认 bean 的各种属性\n            parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n\n            // 提取 description\n            bd.setDescription(DomUtils.getChildElementValueByTagName(ele, \n                                                    DESCRIPTION_ELEMENT));\n\n            // 解析元数据\n            parseMetaElements(ele, bd);\n\n            // 解析 lookup-method 属性\n            parseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n\n            // 解析 replaced-method 属性\n            parseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n\n            // 解析构造函数参数\n            parseConstructorArgElements(ele, bd);\n\n            // 解析 property 子元素\n            parsePropertyElements(ele, bd);\n\n            // 解析 qualifier 子元素\n            parseQualifierElements(ele, bd);\n\n            bd.setResource(this.readerContext.getResource());\n            bd.setSource(extractSource(ele));\n\n            return bd;\n        }\n        catch (ClassNotFoundException ex) {\n            error(\"Bean class [\" + className + \"] not found\", ele, ex);\n        }\n        catch (NoClassDefFoundError err) {\n            error(\"Class that bean class [\" + className\n                  + \"] depends on not found\", ele, err);\n        }\n        catch (Throwable ex) {\n            error(\"Unexpected failure during bean definition parsing\", ele, ex);\n        }\n        finally {\n            this.parseState.pop();\n        }\n        return null;\n    }\n```\n\n到这里，Bean 标签的所有属性我们都可以看到其解析的过程，也就说到这里我们已经解析一个基本可用的 BeanDefinition。\n\n由于篇幅有点长，在下面文章中将对此进行仔细分析。","source":"_posts/spring 源码分析/spring/spring源码解析之  07bean标签：开始解析进程.md","raw":"abbrlink: 26\ntitle: 'spring源码解析之 07bean标签:开启解析进程'\ntags:\n  - spring源码解析\n  - ''\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-14 05:11:00\n---\n# spring 源码解析之bean标签:开启解析进程\n\n### 概述\n\n1. parseDefaultElement\n2. processBeanDefinition (bean标签的解析即注册)\n3. 解析BeanDefinition\n<!-- more-->\n### parseDefaultElement\n\nSpring 中有两种解析 Bean 的方式。如果根节点或者子节点采用默认命名空间的话，则调用 `parseDefaultElement()` 进行默认标签解析，否则调用 `delegate.parseCustomElement()` 方法进行自定义解析。所以以下博客就这两个方法进行详细分析说明，先从默认标签解析过程开始，源码如下：\n\n```java\n    private void parseDefaultElement(Element ele, \n                                     BeanDefinitionParserDelegate delegate) {\n       // 对 import 标签的解析\n        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n            importBeanDefinitionResource(ele);\n        }\n        // 对 alias 标签的解析\n        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n            processAliasRegistration(ele);\n        }\n        // 对 bean 标签的解析\n        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n            processBeanDefinition(ele, delegate);\n        }\n        // 对 beans 标签的解析\n        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n            // recurse\n            doRegisterBeanDefinitions(ele);\n        }\n    }\n```\n\n方法的功能一目了然，分别是对四种不同的标签进行解析，分别是 import、alias、bean、beans。咱门从最富在的标签bean 开始，如果能理解此标签的解析过程，其他的标签的解析自然会迎刃而解。\n\n### processBeanDefinition (bean标签的解析即注册)\n\n如果遇到标签为 bean 则调用 `processBeanDefinition()` 方法进行 bean 标签解析，如下：\n\n```java\n    protected void processBeanDefinition(Element ele,\n                                         BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,                 \n      \t\t\t\t\t\t\t\t getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\n                    \"Failed to register bean definition with name '\" +\n                        bdHolder.getBeanName() + \"'\", ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(\n                new BeanComponentDefinition(bdHolder));                                \n        }\n    }\n```\n\n整个过程分为四个步骤\n\n1. 调用 `BeanDefinitionParserDelegate.parseBeanDefinitionElement()` 进行元素解析，解析过程中如果失败，返回 null，错误由 `ProblemReporter` 处理。如果解析成功则返回 BeanDefinitionHolder 实例 bdHolder。BeanDefinitionHolder 为持有 name 和 alias 的 BeanDefinition。\n2. 若实例 bdHolder 不为空，则调用 `BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired()`进行自定义标签处理\n3. 解析完成后，则调用 `BeanDefinitionReaderUtils.registerBeanDefinition()` 对 bdHolder 进行注册\n4. 发出响应事件，通知相关的监听器，完成 Bean 标签解析\n\n### 解析BeanDefinition\n\n下面我们就针对各个操作做具体分析。首先我们从元素解析即信息提取开始，也就是`BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);` 进入BeanDefinitionDelegate类的parseBeanDefinitionElement方法。\n\n```java\n    @Nullable\n\tpublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, \n                                      @Nullable BeanDefinition containingBean) {\n        // 解析id属性\n\t\tString id = ele.getAttribute(ID_ATTRIBUTE);\n        // 解析name属性\n\t\tString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\t\t// 分割name属性\n\t\tList<String> aliases = new ArrayList<>();\n\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\tString[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, \n                              MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n\t\t\taliases.addAll(Arrays.asList(nameArr));\n\t\t}\n\n        // 设置beanName 如果有id，则设置id值，如果不存在，则使用name属性值的第一个元素\n\t\tString beanName = id;\n\t\tif (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {\n\t\t\tbeanName = aliases.remove(0);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No XML 'id' specified - using '\" + beanName +\n\t\t\t\t\t\t\"' as bean name and \" + aliases + \" as aliases\");\n\t\t\t}\n\t\t}\n\n        // 检查name的唯一性,也包括对别名的检查\n\t\tif (containingBean == null) {\n\t\t\tcheckNameUniqueness(beanName, aliases, ele);\n\t\t}\n\t\t// 解析 属性，构造 AbstractBeanDefinition\n\t\tAbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele,\n                                  beanName, containingBean);\n\t\tif (beanDefinition != null) {\n             // 如果 beanName 不存在，则根据条件构造一个 beanName\n\t\t\tif (!StringUtils.hasText(beanName)) {\n\t\t\t\ttry {\n\t\t\t\t\tif (containingBean != null) {\n\t\t\t\t\t\tbeanName = BeanDefinitionReaderUtils.generateBeanName(\n\t\t\t\t\t\t\t\tbeanDefinition, this.readerContext.getRegistry(), \n                            \t\t\ttrue);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbeanName = this.readerContext.generateBeanName(beanDefinition);\n\t\t\t\t\t\t// 如果此bean的className没有在别名只能怪使用，则注册此bean的className\n                        // 为此bean的别名\n\t\t\t\t\t\tString beanClassName = beanDefinition.getBeanClassName();\n\t\t\t\t\t\tif (beanClassName != null &&\n\t\t\t\t\t\t\t\tbeanName.startsWith(beanClassName) &&\n                            beanName.length() > beanClassName.length() &&\n\t\t\t\t\t!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\taliases.add(beanClassName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Neither XML 'id' nor 'name' specified - \" +\n\t\t\t\t\t\t\t\t\"using generated bean name [\" + beanName + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\terror(ex.getMessage(), ele);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString[] aliasesArray = StringUtils.toStringArray(aliases);\n            // 封装BeanDefinitionHolder\n\t\t\treturn new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n\t\t}\n\t\treturn null;\n\t}\n```\n\n这个方法还没有对 Bean 标签进行解析，只是在解析动作之前做了一些功能架构，主要的工作有：\n\n- 解析 id、name 属性，确定 alias 集合，检测 beanName 是否唯一\n- 调用方法 `parseBeanDefinitionElement()` 对属性进行解析并封装成 GenericBeanDefinition 实例 beanDefinition\n- 如果检测到bean没有指定beanName，那么使用默认规则为此BEan生成beanName\n- 根据所获取的信息（beanName、aliases、beanDefinition）构造 BeanDefinitionHolder 实例对象并返回。\n\n这里有必要说下 beanName 的命名规则：如果 id 不为空，则 beanName = id；如果 id 为空，但是 alias 不空，则 beanName 为 alias 的第一个元素，如果两者都为空，则根据默认规则来设置 beanName。\n\n上面三个步骤第二个步骤为核心方法，它主要承担解析 Bean 标签中所有的属性值。如下：\n\n```java\n   public AbstractBeanDefinition parseBeanDefinitionElement(\n            Element ele, String beanName, @Nullable BeanDefinition containingBean) {\n\n        this.parseState.push(new BeanEntry(beanName));\n\n        String className = null;\n        // 解析 class 属性\n        if (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n            className = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n        }\n        String parent = null;\n\n        // 解析 parent 属性\n        if (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n            parent = ele.getAttribute(PARENT_ATTRIBUTE);\n        }\n\n        try {\n\n            // 创建用于承载属性的 GenericBeanDefinition 实例\n            AbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n            // 解析默认 bean 的各种属性\n            parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n\n            // 提取 description\n            bd.setDescription(DomUtils.getChildElementValueByTagName(ele, \n                                                    DESCRIPTION_ELEMENT));\n\n            // 解析元数据\n            parseMetaElements(ele, bd);\n\n            // 解析 lookup-method 属性\n            parseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n\n            // 解析 replaced-method 属性\n            parseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n\n            // 解析构造函数参数\n            parseConstructorArgElements(ele, bd);\n\n            // 解析 property 子元素\n            parsePropertyElements(ele, bd);\n\n            // 解析 qualifier 子元素\n            parseQualifierElements(ele, bd);\n\n            bd.setResource(this.readerContext.getResource());\n            bd.setSource(extractSource(ele));\n\n            return bd;\n        }\n        catch (ClassNotFoundException ex) {\n            error(\"Bean class [\" + className + \"] not found\", ele, ex);\n        }\n        catch (NoClassDefFoundError err) {\n            error(\"Class that bean class [\" + className\n                  + \"] depends on not found\", ele, err);\n        }\n        catch (Throwable ex) {\n            error(\"Unexpected failure during bean definition parsing\", ele, ex);\n        }\n        finally {\n            this.parseState.pop();\n        }\n        return null;\n    }\n```\n\n到这里，Bean 标签的所有属性我们都可以看到其解析的过程，也就说到这里我们已经解析一个基本可用的 BeanDefinition。\n\n由于篇幅有点长，在下面文章中将对此进行仔细分析。","slug":"spring 源码分析/spring/spring源码解析之  07bean标签：开始解析进程","published":1,"updated":"2019-01-15T03:37:57.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovw7004f9q1uxlh3qtap","content":"<h1 id=\"spring-源码解析之bean标签-开启解析进程\"><a href=\"#spring-源码解析之bean标签-开启解析进程\" class=\"headerlink\" title=\"spring 源码解析之bean标签:开启解析进程\"></a>spring 源码解析之bean标签:开启解析进程</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>parseDefaultElement</li>\n<li>processBeanDefinition (bean标签的解析即注册)</li>\n<li>解析BeanDefinition<a id=\"more\"></a>\n<h3 id=\"parseDefaultElement\"><a href=\"#parseDefaultElement\" class=\"headerlink\" title=\"parseDefaultElement\"></a>parseDefaultElement</h3></li>\n</ol>\n<p>Spring 中有两种解析 Bean 的方式。如果根节点或者子节点采用默认命名空间的话，则调用 <code>parseDefaultElement()</code> 进行默认标签解析，否则调用 <code>delegate.parseCustomElement()</code> 方法进行自定义解析。所以以下博客就这两个方法进行详细分析说明，先从默认标签解析过程开始，源码如下：</p>\n<pre><code class=\"java\">    private void parseDefaultElement(Element ele, \n                                     BeanDefinitionParserDelegate delegate) {\n       // 对 import 标签的解析\n        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n            importBeanDefinitionResource(ele);\n        }\n        // 对 alias 标签的解析\n        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n            processAliasRegistration(ele);\n        }\n        // 对 bean 标签的解析\n        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n            processBeanDefinition(ele, delegate);\n        }\n        // 对 beans 标签的解析\n        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n            // recurse\n            doRegisterBeanDefinitions(ele);\n        }\n    }\n</code></pre>\n<p>方法的功能一目了然，分别是对四种不同的标签进行解析，分别是 import、alias、bean、beans。咱门从最富在的标签bean 开始，如果能理解此标签的解析过程，其他的标签的解析自然会迎刃而解。</p>\n<h3 id=\"processBeanDefinition-bean标签的解析即注册\"><a href=\"#processBeanDefinition-bean标签的解析即注册\" class=\"headerlink\" title=\"processBeanDefinition (bean标签的解析即注册)\"></a>processBeanDefinition (bean标签的解析即注册)</h3><p>如果遇到标签为 bean 则调用 <code>processBeanDefinition()</code> 方法进行 bean 标签解析，如下：</p>\n<pre><code class=\"java\">    protected void processBeanDefinition(Element ele,\n                                         BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,                 \n                                       getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\n                    &quot;Failed to register bean definition with name &#39;&quot; +\n                        bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(\n                new BeanComponentDefinition(bdHolder));                                \n        }\n    }\n</code></pre>\n<p>整个过程分为四个步骤</p>\n<ol>\n<li>调用 <code>BeanDefinitionParserDelegate.parseBeanDefinitionElement()</code> 进行元素解析，解析过程中如果失败，返回 null，错误由 <code>ProblemReporter</code> 处理。如果解析成功则返回 BeanDefinitionHolder 实例 bdHolder。BeanDefinitionHolder 为持有 name 和 alias 的 BeanDefinition。</li>\n<li>若实例 bdHolder 不为空，则调用 <code>BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired()</code>进行自定义标签处理</li>\n<li>解析完成后，则调用 <code>BeanDefinitionReaderUtils.registerBeanDefinition()</code> 对 bdHolder 进行注册</li>\n<li>发出响应事件，通知相关的监听器，完成 Bean 标签解析</li>\n</ol>\n<h3 id=\"解析BeanDefinition\"><a href=\"#解析BeanDefinition\" class=\"headerlink\" title=\"解析BeanDefinition\"></a>解析BeanDefinition</h3><p>下面我们就针对各个操作做具体分析。首先我们从元素解析即信息提取开始，也就是<code>BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</code> 进入BeanDefinitionDelegate类的parseBeanDefinitionElement方法。</p>\n<pre><code class=\"java\">    @Nullable\n    public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, \n                                      @Nullable BeanDefinition containingBean) {\n        // 解析id属性\n        String id = ele.getAttribute(ID_ATTRIBUTE);\n        // 解析name属性\n        String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n        // 分割name属性\n        List&lt;String&gt; aliases = new ArrayList&lt;&gt;();\n        if (StringUtils.hasLength(nameAttr)) {\n            String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, \n                              MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n            aliases.addAll(Arrays.asList(nameArr));\n        }\n\n        // 设置beanName 如果有id，则设置id值，如果不存在，则使用name属性值的第一个元素\n        String beanName = id;\n        if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {\n            beanName = aliases.remove(0);\n            if (logger.isTraceEnabled()) {\n                logger.trace(&quot;No XML &#39;id&#39; specified - using &#39;&quot; + beanName +\n                        &quot;&#39; as bean name and &quot; + aliases + &quot; as aliases&quot;);\n            }\n        }\n\n        // 检查name的唯一性,也包括对别名的检查\n        if (containingBean == null) {\n            checkNameUniqueness(beanName, aliases, ele);\n        }\n        // 解析 属性，构造 AbstractBeanDefinition\n        AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele,\n                                  beanName, containingBean);\n        if (beanDefinition != null) {\n             // 如果 beanName 不存在，则根据条件构造一个 beanName\n            if (!StringUtils.hasText(beanName)) {\n                try {\n                    if (containingBean != null) {\n                        beanName = BeanDefinitionReaderUtils.generateBeanName(\n                                beanDefinition, this.readerContext.getRegistry(), \n                                        true);\n                    }\n                    else {\n                        beanName = this.readerContext.generateBeanName(beanDefinition);\n                        // 如果此bean的className没有在别名只能怪使用，则注册此bean的className\n                        // 为此bean的别名\n                        String beanClassName = beanDefinition.getBeanClassName();\n                        if (beanClassName != null &amp;&amp;\n                                beanName.startsWith(beanClassName) &amp;&amp;\n                            beanName.length() &gt; beanClassName.length() &amp;&amp;\n                    !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)\n                            ) {\n                            aliases.add(beanClassName);\n                        }\n                    }\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(&quot;Neither XML &#39;id&#39; nor &#39;name&#39; specified - &quot; +\n                                &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);\n                    }\n                }\n                catch (Exception ex) {\n                    error(ex.getMessage(), ele);\n                    return null;\n                }\n            }\n            String[] aliasesArray = StringUtils.toStringArray(aliases);\n            // 封装BeanDefinitionHolder\n            return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n        }\n        return null;\n    }\n</code></pre>\n<p>这个方法还没有对 Bean 标签进行解析，只是在解析动作之前做了一些功能架构，主要的工作有：</p>\n<ul>\n<li>解析 id、name 属性，确定 alias 集合，检测 beanName 是否唯一</li>\n<li>调用方法 <code>parseBeanDefinitionElement()</code> 对属性进行解析并封装成 GenericBeanDefinition 实例 beanDefinition</li>\n<li>如果检测到bean没有指定beanName，那么使用默认规则为此BEan生成beanName</li>\n<li>根据所获取的信息（beanName、aliases、beanDefinition）构造 BeanDefinitionHolder 实例对象并返回。</li>\n</ul>\n<p>这里有必要说下 beanName 的命名规则：如果 id 不为空，则 beanName = id；如果 id 为空，但是 alias 不空，则 beanName 为 alias 的第一个元素，如果两者都为空，则根据默认规则来设置 beanName。</p>\n<p>上面三个步骤第二个步骤为核心方法，它主要承担解析 Bean 标签中所有的属性值。如下：</p>\n<pre><code class=\"java\">   public AbstractBeanDefinition parseBeanDefinitionElement(\n            Element ele, String beanName, @Nullable BeanDefinition containingBean) {\n\n        this.parseState.push(new BeanEntry(beanName));\n\n        String className = null;\n        // 解析 class 属性\n        if (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n            className = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n        }\n        String parent = null;\n\n        // 解析 parent 属性\n        if (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n            parent = ele.getAttribute(PARENT_ATTRIBUTE);\n        }\n\n        try {\n\n            // 创建用于承载属性的 GenericBeanDefinition 实例\n            AbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n            // 解析默认 bean 的各种属性\n            parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n\n            // 提取 description\n            bd.setDescription(DomUtils.getChildElementValueByTagName(ele, \n                                                    DESCRIPTION_ELEMENT));\n\n            // 解析元数据\n            parseMetaElements(ele, bd);\n\n            // 解析 lookup-method 属性\n            parseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n\n            // 解析 replaced-method 属性\n            parseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n\n            // 解析构造函数参数\n            parseConstructorArgElements(ele, bd);\n\n            // 解析 property 子元素\n            parsePropertyElements(ele, bd);\n\n            // 解析 qualifier 子元素\n            parseQualifierElements(ele, bd);\n\n            bd.setResource(this.readerContext.getResource());\n            bd.setSource(extractSource(ele));\n\n            return bd;\n        }\n        catch (ClassNotFoundException ex) {\n            error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);\n        }\n        catch (NoClassDefFoundError err) {\n            error(&quot;Class that bean class [&quot; + className\n                  + &quot;] depends on not found&quot;, ele, err);\n        }\n        catch (Throwable ex) {\n            error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);\n        }\n        finally {\n            this.parseState.pop();\n        }\n        return null;\n    }\n</code></pre>\n<p>到这里，Bean 标签的所有属性我们都可以看到其解析的过程，也就说到这里我们已经解析一个基本可用的 BeanDefinition。</p>\n<p>由于篇幅有点长，在下面文章中将对此进行仔细分析。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring-源码解析之bean标签-开启解析进程\"><a href=\"#spring-源码解析之bean标签-开启解析进程\" class=\"headerlink\" title=\"spring 源码解析之bean标签:开启解析进程\"></a>spring 源码解析之bean标签:开启解析进程</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>parseDefaultElement</li>\n<li>processBeanDefinition (bean标签的解析即注册)</li>\n<li>解析BeanDefinition","more":"<h3 id=\"parseDefaultElement\"><a href=\"#parseDefaultElement\" class=\"headerlink\" title=\"parseDefaultElement\"></a>parseDefaultElement</h3></li>\n</ol>\n<p>Spring 中有两种解析 Bean 的方式。如果根节点或者子节点采用默认命名空间的话，则调用 <code>parseDefaultElement()</code> 进行默认标签解析，否则调用 <code>delegate.parseCustomElement()</code> 方法进行自定义解析。所以以下博客就这两个方法进行详细分析说明，先从默认标签解析过程开始，源码如下：</p>\n<pre><code class=\"java\">    private void parseDefaultElement(Element ele, \n                                     BeanDefinitionParserDelegate delegate) {\n       // 对 import 标签的解析\n        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n            importBeanDefinitionResource(ele);\n        }\n        // 对 alias 标签的解析\n        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n            processAliasRegistration(ele);\n        }\n        // 对 bean 标签的解析\n        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n            processBeanDefinition(ele, delegate);\n        }\n        // 对 beans 标签的解析\n        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n            // recurse\n            doRegisterBeanDefinitions(ele);\n        }\n    }\n</code></pre>\n<p>方法的功能一目了然，分别是对四种不同的标签进行解析，分别是 import、alias、bean、beans。咱门从最富在的标签bean 开始，如果能理解此标签的解析过程，其他的标签的解析自然会迎刃而解。</p>\n<h3 id=\"processBeanDefinition-bean标签的解析即注册\"><a href=\"#processBeanDefinition-bean标签的解析即注册\" class=\"headerlink\" title=\"processBeanDefinition (bean标签的解析即注册)\"></a>processBeanDefinition (bean标签的解析即注册)</h3><p>如果遇到标签为 bean 则调用 <code>processBeanDefinition()</code> 方法进行 bean 标签解析，如下：</p>\n<pre><code class=\"java\">    protected void processBeanDefinition(Element ele,\n                                         BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,                 \n                                       getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\n                    &quot;Failed to register bean definition with name &#39;&quot; +\n                        bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(\n                new BeanComponentDefinition(bdHolder));                                \n        }\n    }\n</code></pre>\n<p>整个过程分为四个步骤</p>\n<ol>\n<li>调用 <code>BeanDefinitionParserDelegate.parseBeanDefinitionElement()</code> 进行元素解析，解析过程中如果失败，返回 null，错误由 <code>ProblemReporter</code> 处理。如果解析成功则返回 BeanDefinitionHolder 实例 bdHolder。BeanDefinitionHolder 为持有 name 和 alias 的 BeanDefinition。</li>\n<li>若实例 bdHolder 不为空，则调用 <code>BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired()</code>进行自定义标签处理</li>\n<li>解析完成后，则调用 <code>BeanDefinitionReaderUtils.registerBeanDefinition()</code> 对 bdHolder 进行注册</li>\n<li>发出响应事件，通知相关的监听器，完成 Bean 标签解析</li>\n</ol>\n<h3 id=\"解析BeanDefinition\"><a href=\"#解析BeanDefinition\" class=\"headerlink\" title=\"解析BeanDefinition\"></a>解析BeanDefinition</h3><p>下面我们就针对各个操作做具体分析。首先我们从元素解析即信息提取开始，也就是<code>BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</code> 进入BeanDefinitionDelegate类的parseBeanDefinitionElement方法。</p>\n<pre><code class=\"java\">    @Nullable\n    public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, \n                                      @Nullable BeanDefinition containingBean) {\n        // 解析id属性\n        String id = ele.getAttribute(ID_ATTRIBUTE);\n        // 解析name属性\n        String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n        // 分割name属性\n        List&lt;String&gt; aliases = new ArrayList&lt;&gt;();\n        if (StringUtils.hasLength(nameAttr)) {\n            String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, \n                              MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n            aliases.addAll(Arrays.asList(nameArr));\n        }\n\n        // 设置beanName 如果有id，则设置id值，如果不存在，则使用name属性值的第一个元素\n        String beanName = id;\n        if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {\n            beanName = aliases.remove(0);\n            if (logger.isTraceEnabled()) {\n                logger.trace(&quot;No XML &#39;id&#39; specified - using &#39;&quot; + beanName +\n                        &quot;&#39; as bean name and &quot; + aliases + &quot; as aliases&quot;);\n            }\n        }\n\n        // 检查name的唯一性,也包括对别名的检查\n        if (containingBean == null) {\n            checkNameUniqueness(beanName, aliases, ele);\n        }\n        // 解析 属性，构造 AbstractBeanDefinition\n        AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele,\n                                  beanName, containingBean);\n        if (beanDefinition != null) {\n             // 如果 beanName 不存在，则根据条件构造一个 beanName\n            if (!StringUtils.hasText(beanName)) {\n                try {\n                    if (containingBean != null) {\n                        beanName = BeanDefinitionReaderUtils.generateBeanName(\n                                beanDefinition, this.readerContext.getRegistry(), \n                                        true);\n                    }\n                    else {\n                        beanName = this.readerContext.generateBeanName(beanDefinition);\n                        // 如果此bean的className没有在别名只能怪使用，则注册此bean的className\n                        // 为此bean的别名\n                        String beanClassName = beanDefinition.getBeanClassName();\n                        if (beanClassName != null &amp;&amp;\n                                beanName.startsWith(beanClassName) &amp;&amp;\n                            beanName.length() &gt; beanClassName.length() &amp;&amp;\n                    !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)\n                            ) {\n                            aliases.add(beanClassName);\n                        }\n                    }\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(&quot;Neither XML &#39;id&#39; nor &#39;name&#39; specified - &quot; +\n                                &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);\n                    }\n                }\n                catch (Exception ex) {\n                    error(ex.getMessage(), ele);\n                    return null;\n                }\n            }\n            String[] aliasesArray = StringUtils.toStringArray(aliases);\n            // 封装BeanDefinitionHolder\n            return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n        }\n        return null;\n    }\n</code></pre>\n<p>这个方法还没有对 Bean 标签进行解析，只是在解析动作之前做了一些功能架构，主要的工作有：</p>\n<ul>\n<li>解析 id、name 属性，确定 alias 集合，检测 beanName 是否唯一</li>\n<li>调用方法 <code>parseBeanDefinitionElement()</code> 对属性进行解析并封装成 GenericBeanDefinition 实例 beanDefinition</li>\n<li>如果检测到bean没有指定beanName，那么使用默认规则为此BEan生成beanName</li>\n<li>根据所获取的信息（beanName、aliases、beanDefinition）构造 BeanDefinitionHolder 实例对象并返回。</li>\n</ul>\n<p>这里有必要说下 beanName 的命名规则：如果 id 不为空，则 beanName = id；如果 id 为空，但是 alias 不空，则 beanName 为 alias 的第一个元素，如果两者都为空，则根据默认规则来设置 beanName。</p>\n<p>上面三个步骤第二个步骤为核心方法，它主要承担解析 Bean 标签中所有的属性值。如下：</p>\n<pre><code class=\"java\">   public AbstractBeanDefinition parseBeanDefinitionElement(\n            Element ele, String beanName, @Nullable BeanDefinition containingBean) {\n\n        this.parseState.push(new BeanEntry(beanName));\n\n        String className = null;\n        // 解析 class 属性\n        if (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n            className = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n        }\n        String parent = null;\n\n        // 解析 parent 属性\n        if (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n            parent = ele.getAttribute(PARENT_ATTRIBUTE);\n        }\n\n        try {\n\n            // 创建用于承载属性的 GenericBeanDefinition 实例\n            AbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n            // 解析默认 bean 的各种属性\n            parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n\n            // 提取 description\n            bd.setDescription(DomUtils.getChildElementValueByTagName(ele, \n                                                    DESCRIPTION_ELEMENT));\n\n            // 解析元数据\n            parseMetaElements(ele, bd);\n\n            // 解析 lookup-method 属性\n            parseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n\n            // 解析 replaced-method 属性\n            parseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n\n            // 解析构造函数参数\n            parseConstructorArgElements(ele, bd);\n\n            // 解析 property 子元素\n            parsePropertyElements(ele, bd);\n\n            // 解析 qualifier 子元素\n            parseQualifierElements(ele, bd);\n\n            bd.setResource(this.readerContext.getResource());\n            bd.setSource(extractSource(ele));\n\n            return bd;\n        }\n        catch (ClassNotFoundException ex) {\n            error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);\n        }\n        catch (NoClassDefFoundError err) {\n            error(&quot;Class that bean class [&quot; + className\n                  + &quot;] depends on not found&quot;, ele, err);\n        }\n        catch (Throwable ex) {\n            error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);\n        }\n        finally {\n            this.parseState.pop();\n        }\n        return null;\n    }\n</code></pre>\n<p>到这里，Bean 标签的所有属性我们都可以看到其解析的过程，也就说到这里我们已经解析一个基本可用的 BeanDefinition。</p>\n<p>由于篇幅有点长，在下面文章中将对此进行仔细分析。</p>"},{"abbrlink":28,"title":"spring源码解析之 09bean 标签：meta、lookup-method、replace-method","author":"fengxiutianya","date":"2019-01-13T21:19:00.000Z","_content":"# spring源码解析之 09bean 标签：meta、lookup-method、replace-method\n\n### 概述\n\n1. 简介meta、lookup-method、replace-method\n2. meta 子元素解析\n3. lookup-method 子元素解析\n4. replace-method子元素解析\n<!-- more-->\n\n### 简介meta、lookup-method、replace-method\n\nmeta、lookup-method、replace-method 三个子元素的作用如下：\n\n- meta：元数据。\n- lookup-method：Spring 动态改变 bean 里方法的实现。方法执行返回的对象，使用 Spring 内原有的这类对象替换，通过改变方法返回值来动态改变方法。内部实现为使用 cglib 方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果。\n- replace-method：Spring 动态改变 bean 里方法的实现。需要改变的方法，使用 Spring 内原有其他类（需要继承接口`org.springframework.beans.factory.support.MethodReplacer`）的逻辑，替换这个方法。通过改变方法执行逻辑来动态改变方法。\n\n### meta 子元素解析\n\n在开始解析元素数据的分析前，我们先回顾下元数据meta属性的使用\n\n```xml\n<bean id=\"\" class=\"\">\n\t<meta key=\"key1\" value=\"aaaaa\"/>\n</bean>\n```\n\n**meta** ：元数据。当需要使用里面的信息时可以通过key获取\n\nmeta 所声明的 key 并不会在 Bean 中体现，只是一个额外的声明，当我们需要使用里面的信息时，通过 BeanDefinition 的 `getAttribute()` 获取。该子元素的解析过程如下：\n\n```java\n    public void parseMetaElements(Element ele, \n                                  BeanMetadataAttributeAccessor attributeAccessor) {\n       // 获取当前节点的所有子元素\n        NodeList nl = ele.getChildNodes();\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            // 提出meta\n            if (isCandidateElement(node) && nodeNameEquals(node, META_ELEMENT)) {\n                Element metaElement = (Element) node;\n                String key = metaElement.getAttribute(KEY_ATTRIBUTE);\n                String value = metaElement.getAttribute(VALUE_ATTRIBUTE);\n                // 使用key、value构造BeanMetadataAttribute\n                BeanMetadataAttribute attribute = \n                    new BeanMetadataAttribute(key, value);\n                attribute.setSource(extractSource(metaElement));\n                // 记录信息\n                attributeAccessor.addMetadataAttribute(attribute);\n            }\n        }\n    }\n```\n\n解析过程较为简单，获取相应的 key – value 构建 BeanMetadataAttribute 对象，然后通过 `addMetadataAttribute()`加入到 AbstractBeanDefinition 中。 “ 如下：\n\n```java\n    public void addMetadataAttribute(BeanMetadataAttribute attribute) {\n        super.setAttribute(attribute.getName(), attribute);\n    }\n```\n\n委托 AttributeAccessorSupport 实现，如下：\n\n```java\n    public void setAttribute(String name, @Nullable Object value) {\n        Assert.notNull(name, \"Name must not be null\");\n        if (value != null) {\n            this.attributes.put(name, value);\n        }\n        else {\n            removeAttribute(name);\n        }\n    }\n```\n\nAttributeAccessorSupport 是接口 AttributeAccessor 的实现者。 AttributeAccessor 接口定义了与其他对象的元数据进行连接和访问的约定，可以通过该接口对属性进行获取、设置、删除操作。\n\n设置元数据后，则可以通过 `getAttribute()` 获取,如下：\n\n```java\n    public Object getAttribute(String name) {\n        BeanMetadataAttribute attribute = (BeanMetadataAttribute) super.getAttribute(name);\n        return (attribute != null ? attribute.getValue() : null);\n    }\n```\n\n### lookup-method 子元素解析\n\n**lookup-method** ：获取器注入，是把一个方法声明为返回某种类型的 bean 但实际要返回的 bean 是在配置文件里面配置的。该方法可以用于设计一些可插拔的功能上，解除程序依赖。\n\n直接上例子：\n\n```java\npublic interface Car {\n\n    void display();\n}\n\npublic class Bmw implements Car{\n    @Override\n    public void display() {\n        System.out.println(\"我是 BMW\");\n    }\n}\n\npublic class Hongqi implements Car{\n    @Override\n    public void display() {\n        System.out.println(\"我是 hongqi\");\n    }\n}\n\npublic abstract class Display {\n\n\n    public void display(){\n        getCar().display();\n    }\n\n    public abstract Car getCar();\n}\n\n   public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:spring.xml\");\n\n        Display display = (Display) context.getBean(\"display\");\n        display.display();\n    }\n}\n```\n\n配置内容如下：\n\n```xml\n    <bean id=\"display\" class=\"org.springframework.core.test1.Display\">\n        <lookup-method name=\"getCar\" bean=\"hongqi\"/>\n    </bean>\n```\n\n运行结果为：\n\n```null\n我是 hongqi\n```\n\n如果将 `bean=\"hognqi\"` 替换为 `bean=\"bmw\"`，则运行结果变成：\n\n```null\n我是 BMW\n```\n\n看了这个示例，我们初步了解了 looku-method 子元素提供的功能了，其解析过程如下：\n\n```java\n    public void parseLookupOverrideSubElements(Element beanEle, \n                                               MethodOverrides overrides) {\n        NodeList nl = beanEle.getChildNodes();\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            // 当且仅当spring默认bean的子元素下切位lookup-method时有效\n            if (isCandidateElement(node) && nodeNameEquals(node, \n                                                           LOOKUP_METHOD_ELEMENT)) {\n                Element ele = (Element) node;\n                // 获取要修饰的方法\n                String methodName = ele.getAttribute(NAME_ATTRIBUTE);\n                // 获取配置返回的bean\n                String beanRef = ele.getAttribute(BEAN_ELEMENT);\n                LookupOverride override = new LookupOverride(methodName, beanRef);\n                override.setSource(extractSource(ele));\n                overrides.addOverride(override);\n            }\n        }\n    }\n```\n\n解析过程和 meta 子元素没有多大区别，同样是解析 methodName、beanRef 构造一个 LookupOverride 对象，然后覆盖即可。在实例化 Bean 的时候，再详细阐述具体的实现过程，这里仅仅只是一个标记作用。\n\n### replaced-method子元素解析\n\n**replaced-method** ：可以在运行时调用新的方法替换现有的方法，还能动态的更新原有方法的逻辑\n\n该标签使用方法和 lookup-method 标签差不多，只不过替代方法的类需要实现 MethodReplacer 接口。如下:\n\n```java\npublic class Method {\n    public void display(){\n        System.out.println(\"我是原始方法\");\n    }\n}\n\npublic class MethodReplace implements MethodReplacer {\n\n    @Override\n    public Object reimplement(Object obj, Method method, Object[] args) \n        throws Throwable {\n        System.out.println(\"我是替换方法\");\n\n        return null;\n    }\n}\n\n    public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:spring.xml\");\n\n        Method method = (Method) context.getBean(\"method\");\n        method.display();\n    }\n```\n\n如果 spring.xml 文件如下：\n\n```xml\n    <bean id=\"methodReplace\" class=\"org.springframework.core.test1.MethodReplace\"/>\n\n    <bean id=\"method\" class=\"org.springframework.core.test1.Method\"/>\n```\n\n则运行结果为：\n\n```null\n我是原始方法\n```\n\n增加 replaced-method 子元素：\n\n```xml\n    <bean id=\"methodReplace\" class=\"org.springframework.core.test1.MethodReplace\"/>\n\n    <bean id=\"method\" class=\"org.springframework.core.test1.Method\">\n        <replaced-method name=\"display\" replacer=\"methodReplace\"/>\n    </bean>\n```\n\n运行结果为：\n\n```null\n我是替换方法\n```\n\n另外需要补充的一点是\n\n如果我们的`MethodReplacer`将要替换的方法在对应的`bean`中属于重载类型的方法，即存在多个方法名相同的方法时，我们还需要通过在`replaced-method`元素下通过`arg-type`元素来定义对应方法参数的类型，这样就可以区分需要替换的是哪一个方法。所以，针对上述示例，我们也可以如下定义：\n\n```xml\n\t<bean id=\"beanAReplacer\" class=\"com.app.BeanAReplacer\"/>\n\t<bean id=\"beanA\" class=\"com.app.BeanA\">\n\t\t<replaced-method name=\"add\" replacer=\"beanAReplacer\">\n\t\t\t<arg-type match=\"int\"/>\n\t\t\t<arg-type match=\"int\"/>\n\t\t</replaced-method>\n\t</bean>\n```\n\n对应方法名的方法只存在一个时，`arg-type`将不起作用，即`Spring`此时不会根据`arg-type`去取对应的方法进行替换，或者换句话说就是当`replaced-method`指定名称的方法只存在一个时，无论`arg-type`如何定义都是可以的。\n\n上面代码演示了 replaced-method 子元素的用法，下面再看看该子元素的解析过程。\n\n```java\n    public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {\n        NodeList nl = beanEle.getChildNodes();\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            if (isCandidateElement(node) && nodeNameEquals(node, \n                                                           REPLACED_METHOD_ELEMENT)) {\n                Element replacedMethodEle = (Element) node;\n                // 获取要替换的就得方法\n                String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);\n                // 获取对一个的新的替换方法\n                String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);\n                ReplaceOverride replaceOverride = new ReplaceOverride(name, callback);\n                // 获取参数类型列表\n                List<Element> argTypeEles = DomUtils\n                    .getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);\n                // 记录参数类型\n                for (Element argTypeEle : argTypeEles) {\n                    String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);\n                    match = (StringUtils.hasText(match)\n                             \t? match : DomUtils.getTextValue(argTypeEle));\n                    if (StringUtils.hasText(match)) {\n                        replaceOverride.addTypeIdentifier(match);\n                    }\n                }\n                replaceOverride.setSource(extractSource(replacedMethodEle));\n                overrides.addOverride(replaceOverride);\n            }\n        }\n    }\n```\n\n该子元素和 lookup-method 资源的解析过程差不多，同样是提取 name 和 replacer 属性构建 ReplaceOverride 对象，然后记录到 AbstractBeanDefinition 中的 methodOverrides 属性中。\n\n对于 lookup-method 和 replaced-method 两个子元素是如何使用以完成他们所提供的功能，在后续实例化 Bean 的时候会做详细说明。","source":"_posts/spring 源码分析/spring/spring源码解析之  09bean 标签：meta、lookup-method、replace-method.md","raw":"abbrlink: 28\ntitle: spring源码解析之 09bean 标签：meta、lookup-method、replace-method\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-14 05:19:00\n---\n# spring源码解析之 09bean 标签：meta、lookup-method、replace-method\n\n### 概述\n\n1. 简介meta、lookup-method、replace-method\n2. meta 子元素解析\n3. lookup-method 子元素解析\n4. replace-method子元素解析\n<!-- more-->\n\n### 简介meta、lookup-method、replace-method\n\nmeta、lookup-method、replace-method 三个子元素的作用如下：\n\n- meta：元数据。\n- lookup-method：Spring 动态改变 bean 里方法的实现。方法执行返回的对象，使用 Spring 内原有的这类对象替换，通过改变方法返回值来动态改变方法。内部实现为使用 cglib 方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果。\n- replace-method：Spring 动态改变 bean 里方法的实现。需要改变的方法，使用 Spring 内原有其他类（需要继承接口`org.springframework.beans.factory.support.MethodReplacer`）的逻辑，替换这个方法。通过改变方法执行逻辑来动态改变方法。\n\n### meta 子元素解析\n\n在开始解析元素数据的分析前，我们先回顾下元数据meta属性的使用\n\n```xml\n<bean id=\"\" class=\"\">\n\t<meta key=\"key1\" value=\"aaaaa\"/>\n</bean>\n```\n\n**meta** ：元数据。当需要使用里面的信息时可以通过key获取\n\nmeta 所声明的 key 并不会在 Bean 中体现，只是一个额外的声明，当我们需要使用里面的信息时，通过 BeanDefinition 的 `getAttribute()` 获取。该子元素的解析过程如下：\n\n```java\n    public void parseMetaElements(Element ele, \n                                  BeanMetadataAttributeAccessor attributeAccessor) {\n       // 获取当前节点的所有子元素\n        NodeList nl = ele.getChildNodes();\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            // 提出meta\n            if (isCandidateElement(node) && nodeNameEquals(node, META_ELEMENT)) {\n                Element metaElement = (Element) node;\n                String key = metaElement.getAttribute(KEY_ATTRIBUTE);\n                String value = metaElement.getAttribute(VALUE_ATTRIBUTE);\n                // 使用key、value构造BeanMetadataAttribute\n                BeanMetadataAttribute attribute = \n                    new BeanMetadataAttribute(key, value);\n                attribute.setSource(extractSource(metaElement));\n                // 记录信息\n                attributeAccessor.addMetadataAttribute(attribute);\n            }\n        }\n    }\n```\n\n解析过程较为简单，获取相应的 key – value 构建 BeanMetadataAttribute 对象，然后通过 `addMetadataAttribute()`加入到 AbstractBeanDefinition 中。 “ 如下：\n\n```java\n    public void addMetadataAttribute(BeanMetadataAttribute attribute) {\n        super.setAttribute(attribute.getName(), attribute);\n    }\n```\n\n委托 AttributeAccessorSupport 实现，如下：\n\n```java\n    public void setAttribute(String name, @Nullable Object value) {\n        Assert.notNull(name, \"Name must not be null\");\n        if (value != null) {\n            this.attributes.put(name, value);\n        }\n        else {\n            removeAttribute(name);\n        }\n    }\n```\n\nAttributeAccessorSupport 是接口 AttributeAccessor 的实现者。 AttributeAccessor 接口定义了与其他对象的元数据进行连接和访问的约定，可以通过该接口对属性进行获取、设置、删除操作。\n\n设置元数据后，则可以通过 `getAttribute()` 获取,如下：\n\n```java\n    public Object getAttribute(String name) {\n        BeanMetadataAttribute attribute = (BeanMetadataAttribute) super.getAttribute(name);\n        return (attribute != null ? attribute.getValue() : null);\n    }\n```\n\n### lookup-method 子元素解析\n\n**lookup-method** ：获取器注入，是把一个方法声明为返回某种类型的 bean 但实际要返回的 bean 是在配置文件里面配置的。该方法可以用于设计一些可插拔的功能上，解除程序依赖。\n\n直接上例子：\n\n```java\npublic interface Car {\n\n    void display();\n}\n\npublic class Bmw implements Car{\n    @Override\n    public void display() {\n        System.out.println(\"我是 BMW\");\n    }\n}\n\npublic class Hongqi implements Car{\n    @Override\n    public void display() {\n        System.out.println(\"我是 hongqi\");\n    }\n}\n\npublic abstract class Display {\n\n\n    public void display(){\n        getCar().display();\n    }\n\n    public abstract Car getCar();\n}\n\n   public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:spring.xml\");\n\n        Display display = (Display) context.getBean(\"display\");\n        display.display();\n    }\n}\n```\n\n配置内容如下：\n\n```xml\n    <bean id=\"display\" class=\"org.springframework.core.test1.Display\">\n        <lookup-method name=\"getCar\" bean=\"hongqi\"/>\n    </bean>\n```\n\n运行结果为：\n\n```null\n我是 hongqi\n```\n\n如果将 `bean=\"hognqi\"` 替换为 `bean=\"bmw\"`，则运行结果变成：\n\n```null\n我是 BMW\n```\n\n看了这个示例，我们初步了解了 looku-method 子元素提供的功能了，其解析过程如下：\n\n```java\n    public void parseLookupOverrideSubElements(Element beanEle, \n                                               MethodOverrides overrides) {\n        NodeList nl = beanEle.getChildNodes();\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            // 当且仅当spring默认bean的子元素下切位lookup-method时有效\n            if (isCandidateElement(node) && nodeNameEquals(node, \n                                                           LOOKUP_METHOD_ELEMENT)) {\n                Element ele = (Element) node;\n                // 获取要修饰的方法\n                String methodName = ele.getAttribute(NAME_ATTRIBUTE);\n                // 获取配置返回的bean\n                String beanRef = ele.getAttribute(BEAN_ELEMENT);\n                LookupOverride override = new LookupOverride(methodName, beanRef);\n                override.setSource(extractSource(ele));\n                overrides.addOverride(override);\n            }\n        }\n    }\n```\n\n解析过程和 meta 子元素没有多大区别，同样是解析 methodName、beanRef 构造一个 LookupOverride 对象，然后覆盖即可。在实例化 Bean 的时候，再详细阐述具体的实现过程，这里仅仅只是一个标记作用。\n\n### replaced-method子元素解析\n\n**replaced-method** ：可以在运行时调用新的方法替换现有的方法，还能动态的更新原有方法的逻辑\n\n该标签使用方法和 lookup-method 标签差不多，只不过替代方法的类需要实现 MethodReplacer 接口。如下:\n\n```java\npublic class Method {\n    public void display(){\n        System.out.println(\"我是原始方法\");\n    }\n}\n\npublic class MethodReplace implements MethodReplacer {\n\n    @Override\n    public Object reimplement(Object obj, Method method, Object[] args) \n        throws Throwable {\n        System.out.println(\"我是替换方法\");\n\n        return null;\n    }\n}\n\n    public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:spring.xml\");\n\n        Method method = (Method) context.getBean(\"method\");\n        method.display();\n    }\n```\n\n如果 spring.xml 文件如下：\n\n```xml\n    <bean id=\"methodReplace\" class=\"org.springframework.core.test1.MethodReplace\"/>\n\n    <bean id=\"method\" class=\"org.springframework.core.test1.Method\"/>\n```\n\n则运行结果为：\n\n```null\n我是原始方法\n```\n\n增加 replaced-method 子元素：\n\n```xml\n    <bean id=\"methodReplace\" class=\"org.springframework.core.test1.MethodReplace\"/>\n\n    <bean id=\"method\" class=\"org.springframework.core.test1.Method\">\n        <replaced-method name=\"display\" replacer=\"methodReplace\"/>\n    </bean>\n```\n\n运行结果为：\n\n```null\n我是替换方法\n```\n\n另外需要补充的一点是\n\n如果我们的`MethodReplacer`将要替换的方法在对应的`bean`中属于重载类型的方法，即存在多个方法名相同的方法时，我们还需要通过在`replaced-method`元素下通过`arg-type`元素来定义对应方法参数的类型，这样就可以区分需要替换的是哪一个方法。所以，针对上述示例，我们也可以如下定义：\n\n```xml\n\t<bean id=\"beanAReplacer\" class=\"com.app.BeanAReplacer\"/>\n\t<bean id=\"beanA\" class=\"com.app.BeanA\">\n\t\t<replaced-method name=\"add\" replacer=\"beanAReplacer\">\n\t\t\t<arg-type match=\"int\"/>\n\t\t\t<arg-type match=\"int\"/>\n\t\t</replaced-method>\n\t</bean>\n```\n\n对应方法名的方法只存在一个时，`arg-type`将不起作用，即`Spring`此时不会根据`arg-type`去取对应的方法进行替换，或者换句话说就是当`replaced-method`指定名称的方法只存在一个时，无论`arg-type`如何定义都是可以的。\n\n上面代码演示了 replaced-method 子元素的用法，下面再看看该子元素的解析过程。\n\n```java\n    public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {\n        NodeList nl = beanEle.getChildNodes();\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            if (isCandidateElement(node) && nodeNameEquals(node, \n                                                           REPLACED_METHOD_ELEMENT)) {\n                Element replacedMethodEle = (Element) node;\n                // 获取要替换的就得方法\n                String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);\n                // 获取对一个的新的替换方法\n                String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);\n                ReplaceOverride replaceOverride = new ReplaceOverride(name, callback);\n                // 获取参数类型列表\n                List<Element> argTypeEles = DomUtils\n                    .getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);\n                // 记录参数类型\n                for (Element argTypeEle : argTypeEles) {\n                    String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);\n                    match = (StringUtils.hasText(match)\n                             \t? match : DomUtils.getTextValue(argTypeEle));\n                    if (StringUtils.hasText(match)) {\n                        replaceOverride.addTypeIdentifier(match);\n                    }\n                }\n                replaceOverride.setSource(extractSource(replacedMethodEle));\n                overrides.addOverride(replaceOverride);\n            }\n        }\n    }\n```\n\n该子元素和 lookup-method 资源的解析过程差不多，同样是提取 name 和 replacer 属性构建 ReplaceOverride 对象，然后记录到 AbstractBeanDefinition 中的 methodOverrides 属性中。\n\n对于 lookup-method 和 replaced-method 两个子元素是如何使用以完成他们所提供的功能，在后续实例化 Bean 的时候会做详细说明。","slug":"spring 源码分析/spring/spring源码解析之  09bean 标签：meta、lookup-method、replace-method","published":1,"updated":"2019-01-15T03:37:40.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovw8004i9q1uj27dtyhr","content":"<h1 id=\"spring源码解析之-09bean-标签：meta、lookup-method、replace-method\"><a href=\"#spring源码解析之-09bean-标签：meta、lookup-method、replace-method\" class=\"headerlink\" title=\"spring源码解析之 09bean 标签：meta、lookup-method、replace-method\"></a>spring源码解析之 09bean 标签：meta、lookup-method、replace-method</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>简介meta、lookup-method、replace-method</li>\n<li>meta 子元素解析</li>\n<li>lookup-method 子元素解析</li>\n<li>replace-method子元素解析<a id=\"more\"></a>\n</li>\n</ol>\n<h3 id=\"简介meta、lookup-method、replace-method\"><a href=\"#简介meta、lookup-method、replace-method\" class=\"headerlink\" title=\"简介meta、lookup-method、replace-method\"></a>简介meta、lookup-method、replace-method</h3><p>meta、lookup-method、replace-method 三个子元素的作用如下：</p>\n<ul>\n<li>meta：元数据。</li>\n<li>lookup-method：Spring 动态改变 bean 里方法的实现。方法执行返回的对象，使用 Spring 内原有的这类对象替换，通过改变方法返回值来动态改变方法。内部实现为使用 cglib 方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果。</li>\n<li>replace-method：Spring 动态改变 bean 里方法的实现。需要改变的方法，使用 Spring 内原有其他类（需要继承接口<code>org.springframework.beans.factory.support.MethodReplacer</code>）的逻辑，替换这个方法。通过改变方法执行逻辑来动态改变方法。</li>\n</ul>\n<h3 id=\"meta-子元素解析\"><a href=\"#meta-子元素解析\" class=\"headerlink\" title=\"meta 子元素解析\"></a>meta 子元素解析</h3><p>在开始解析元素数据的分析前，我们先回顾下元数据meta属性的使用</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;\n    &lt;meta key=&quot;key1&quot; value=&quot;aaaaa&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p><strong>meta</strong> ：元数据。当需要使用里面的信息时可以通过key获取</p>\n<p>meta 所声明的 key 并不会在 Bean 中体现，只是一个额外的声明，当我们需要使用里面的信息时，通过 BeanDefinition 的 <code>getAttribute()</code> 获取。该子元素的解析过程如下：</p>\n<pre><code class=\"java\">    public void parseMetaElements(Element ele, \n                                  BeanMetadataAttributeAccessor attributeAccessor) {\n       // 获取当前节点的所有子元素\n        NodeList nl = ele.getChildNodes();\n        for (int i = 0; i &lt; nl.getLength(); i++) {\n            Node node = nl.item(i);\n            // 提出meta\n            if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) {\n                Element metaElement = (Element) node;\n                String key = metaElement.getAttribute(KEY_ATTRIBUTE);\n                String value = metaElement.getAttribute(VALUE_ATTRIBUTE);\n                // 使用key、value构造BeanMetadataAttribute\n                BeanMetadataAttribute attribute = \n                    new BeanMetadataAttribute(key, value);\n                attribute.setSource(extractSource(metaElement));\n                // 记录信息\n                attributeAccessor.addMetadataAttribute(attribute);\n            }\n        }\n    }\n</code></pre>\n<p>解析过程较为简单，获取相应的 key – value 构建 BeanMetadataAttribute 对象，然后通过 <code>addMetadataAttribute()</code>加入到 AbstractBeanDefinition 中。 “ 如下：</p>\n<pre><code class=\"java\">    public void addMetadataAttribute(BeanMetadataAttribute attribute) {\n        super.setAttribute(attribute.getName(), attribute);\n    }\n</code></pre>\n<p>委托 AttributeAccessorSupport 实现，如下：</p>\n<pre><code class=\"java\">    public void setAttribute(String name, @Nullable Object value) {\n        Assert.notNull(name, &quot;Name must not be null&quot;);\n        if (value != null) {\n            this.attributes.put(name, value);\n        }\n        else {\n            removeAttribute(name);\n        }\n    }\n</code></pre>\n<p>AttributeAccessorSupport 是接口 AttributeAccessor 的实现者。 AttributeAccessor 接口定义了与其他对象的元数据进行连接和访问的约定，可以通过该接口对属性进行获取、设置、删除操作。</p>\n<p>设置元数据后，则可以通过 <code>getAttribute()</code> 获取,如下：</p>\n<pre><code class=\"java\">    public Object getAttribute(String name) {\n        BeanMetadataAttribute attribute = (BeanMetadataAttribute) super.getAttribute(name);\n        return (attribute != null ? attribute.getValue() : null);\n    }\n</code></pre>\n<h3 id=\"lookup-method-子元素解析\"><a href=\"#lookup-method-子元素解析\" class=\"headerlink\" title=\"lookup-method 子元素解析\"></a>lookup-method 子元素解析</h3><p><strong>lookup-method</strong> ：获取器注入，是把一个方法声明为返回某种类型的 bean 但实际要返回的 bean 是在配置文件里面配置的。该方法可以用于设计一些可插拔的功能上，解除程序依赖。</p>\n<p>直接上例子：</p>\n<pre><code class=\"java\">public interface Car {\n\n    void display();\n}\n\npublic class Bmw implements Car{\n    @Override\n    public void display() {\n        System.out.println(&quot;我是 BMW&quot;);\n    }\n}\n\npublic class Hongqi implements Car{\n    @Override\n    public void display() {\n        System.out.println(&quot;我是 hongqi&quot;);\n    }\n}\n\npublic abstract class Display {\n\n\n    public void display(){\n        getCar().display();\n    }\n\n    public abstract Car getCar();\n}\n\n   public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);\n\n        Display display = (Display) context.getBean(&quot;display&quot;);\n        display.display();\n    }\n}\n</code></pre>\n<p>配置内容如下：</p>\n<pre><code class=\"xml\">    &lt;bean id=&quot;display&quot; class=&quot;org.springframework.core.test1.Display&quot;&gt;\n        &lt;lookup-method name=&quot;getCar&quot; bean=&quot;hongqi&quot;/&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p>运行结果为：</p>\n<pre><code class=\"null\">我是 hongqi\n</code></pre>\n<p>如果将 <code>bean=&quot;hognqi&quot;</code> 替换为 <code>bean=&quot;bmw&quot;</code>，则运行结果变成：</p>\n<pre><code class=\"null\">我是 BMW\n</code></pre>\n<p>看了这个示例，我们初步了解了 looku-method 子元素提供的功能了，其解析过程如下：</p>\n<pre><code class=\"java\">    public void parseLookupOverrideSubElements(Element beanEle, \n                                               MethodOverrides overrides) {\n        NodeList nl = beanEle.getChildNodes();\n        for (int i = 0; i &lt; nl.getLength(); i++) {\n            Node node = nl.item(i);\n            // 当且仅当spring默认bean的子元素下切位lookup-method时有效\n            if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, \n                                                           LOOKUP_METHOD_ELEMENT)) {\n                Element ele = (Element) node;\n                // 获取要修饰的方法\n                String methodName = ele.getAttribute(NAME_ATTRIBUTE);\n                // 获取配置返回的bean\n                String beanRef = ele.getAttribute(BEAN_ELEMENT);\n                LookupOverride override = new LookupOverride(methodName, beanRef);\n                override.setSource(extractSource(ele));\n                overrides.addOverride(override);\n            }\n        }\n    }\n</code></pre>\n<p>解析过程和 meta 子元素没有多大区别，同样是解析 methodName、beanRef 构造一个 LookupOverride 对象，然后覆盖即可。在实例化 Bean 的时候，再详细阐述具体的实现过程，这里仅仅只是一个标记作用。</p>\n<h3 id=\"replaced-method子元素解析\"><a href=\"#replaced-method子元素解析\" class=\"headerlink\" title=\"replaced-method子元素解析\"></a>replaced-method子元素解析</h3><p><strong>replaced-method</strong> ：可以在运行时调用新的方法替换现有的方法，还能动态的更新原有方法的逻辑</p>\n<p>该标签使用方法和 lookup-method 标签差不多，只不过替代方法的类需要实现 MethodReplacer 接口。如下:</p>\n<pre><code class=\"java\">public class Method {\n    public void display(){\n        System.out.println(&quot;我是原始方法&quot;);\n    }\n}\n\npublic class MethodReplace implements MethodReplacer {\n\n    @Override\n    public Object reimplement(Object obj, Method method, Object[] args) \n        throws Throwable {\n        System.out.println(&quot;我是替换方法&quot;);\n\n        return null;\n    }\n}\n\n    public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);\n\n        Method method = (Method) context.getBean(&quot;method&quot;);\n        method.display();\n    }\n</code></pre>\n<p>如果 spring.xml 文件如下：</p>\n<pre><code class=\"xml\">    &lt;bean id=&quot;methodReplace&quot; class=&quot;org.springframework.core.test1.MethodReplace&quot;/&gt;\n\n    &lt;bean id=&quot;method&quot; class=&quot;org.springframework.core.test1.Method&quot;/&gt;\n</code></pre>\n<p>则运行结果为：</p>\n<pre><code class=\"null\">我是原始方法\n</code></pre>\n<p>增加 replaced-method 子元素：</p>\n<pre><code class=\"xml\">    &lt;bean id=&quot;methodReplace&quot; class=&quot;org.springframework.core.test1.MethodReplace&quot;/&gt;\n\n    &lt;bean id=&quot;method&quot; class=&quot;org.springframework.core.test1.Method&quot;&gt;\n        &lt;replaced-method name=&quot;display&quot; replacer=&quot;methodReplace&quot;/&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p>运行结果为：</p>\n<pre><code class=\"null\">我是替换方法\n</code></pre>\n<p>另外需要补充的一点是</p>\n<p>如果我们的<code>MethodReplacer</code>将要替换的方法在对应的<code>bean</code>中属于重载类型的方法，即存在多个方法名相同的方法时，我们还需要通过在<code>replaced-method</code>元素下通过<code>arg-type</code>元素来定义对应方法参数的类型，这样就可以区分需要替换的是哪一个方法。所以，针对上述示例，我们也可以如下定义：</p>\n<pre><code class=\"xml\">    &lt;bean id=&quot;beanAReplacer&quot; class=&quot;com.app.BeanAReplacer&quot;/&gt;\n    &lt;bean id=&quot;beanA&quot; class=&quot;com.app.BeanA&quot;&gt;\n        &lt;replaced-method name=&quot;add&quot; replacer=&quot;beanAReplacer&quot;&gt;\n            &lt;arg-type match=&quot;int&quot;/&gt;\n            &lt;arg-type match=&quot;int&quot;/&gt;\n        &lt;/replaced-method&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p>对应方法名的方法只存在一个时，<code>arg-type</code>将不起作用，即<code>Spring</code>此时不会根据<code>arg-type</code>去取对应的方法进行替换，或者换句话说就是当<code>replaced-method</code>指定名称的方法只存在一个时，无论<code>arg-type</code>如何定义都是可以的。</p>\n<p>上面代码演示了 replaced-method 子元素的用法，下面再看看该子元素的解析过程。</p>\n<pre><code class=\"java\">    public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {\n        NodeList nl = beanEle.getChildNodes();\n        for (int i = 0; i &lt; nl.getLength(); i++) {\n            Node node = nl.item(i);\n            if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, \n                                                           REPLACED_METHOD_ELEMENT)) {\n                Element replacedMethodEle = (Element) node;\n                // 获取要替换的就得方法\n                String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);\n                // 获取对一个的新的替换方法\n                String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);\n                ReplaceOverride replaceOverride = new ReplaceOverride(name, callback);\n                // 获取参数类型列表\n                List&lt;Element&gt; argTypeEles = DomUtils\n                    .getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);\n                // 记录参数类型\n                for (Element argTypeEle : argTypeEles) {\n                    String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);\n                    match = (StringUtils.hasText(match)\n                                 ? match : DomUtils.getTextValue(argTypeEle));\n                    if (StringUtils.hasText(match)) {\n                        replaceOverride.addTypeIdentifier(match);\n                    }\n                }\n                replaceOverride.setSource(extractSource(replacedMethodEle));\n                overrides.addOverride(replaceOverride);\n            }\n        }\n    }\n</code></pre>\n<p>该子元素和 lookup-method 资源的解析过程差不多，同样是提取 name 和 replacer 属性构建 ReplaceOverride 对象，然后记录到 AbstractBeanDefinition 中的 methodOverrides 属性中。</p>\n<p>对于 lookup-method 和 replaced-method 两个子元素是如何使用以完成他们所提供的功能，在后续实例化 Bean 的时候会做详细说明。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-09bean-标签：meta、lookup-method、replace-method\"><a href=\"#spring源码解析之-09bean-标签：meta、lookup-method、replace-method\" class=\"headerlink\" title=\"spring源码解析之 09bean 标签：meta、lookup-method、replace-method\"></a>spring源码解析之 09bean 标签：meta、lookup-method、replace-method</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>简介meta、lookup-method、replace-method</li>\n<li>meta 子元素解析</li>\n<li>lookup-method 子元素解析</li>\n<li>replace-method子元素解析","more":"</li>\n</ol>\n<h3 id=\"简介meta、lookup-method、replace-method\"><a href=\"#简介meta、lookup-method、replace-method\" class=\"headerlink\" title=\"简介meta、lookup-method、replace-method\"></a>简介meta、lookup-method、replace-method</h3><p>meta、lookup-method、replace-method 三个子元素的作用如下：</p>\n<ul>\n<li>meta：元数据。</li>\n<li>lookup-method：Spring 动态改变 bean 里方法的实现。方法执行返回的对象，使用 Spring 内原有的这类对象替换，通过改变方法返回值来动态改变方法。内部实现为使用 cglib 方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果。</li>\n<li>replace-method：Spring 动态改变 bean 里方法的实现。需要改变的方法，使用 Spring 内原有其他类（需要继承接口<code>org.springframework.beans.factory.support.MethodReplacer</code>）的逻辑，替换这个方法。通过改变方法执行逻辑来动态改变方法。</li>\n</ul>\n<h3 id=\"meta-子元素解析\"><a href=\"#meta-子元素解析\" class=\"headerlink\" title=\"meta 子元素解析\"></a>meta 子元素解析</h3><p>在开始解析元素数据的分析前，我们先回顾下元数据meta属性的使用</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;\n    &lt;meta key=&quot;key1&quot; value=&quot;aaaaa&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p><strong>meta</strong> ：元数据。当需要使用里面的信息时可以通过key获取</p>\n<p>meta 所声明的 key 并不会在 Bean 中体现，只是一个额外的声明，当我们需要使用里面的信息时，通过 BeanDefinition 的 <code>getAttribute()</code> 获取。该子元素的解析过程如下：</p>\n<pre><code class=\"java\">    public void parseMetaElements(Element ele, \n                                  BeanMetadataAttributeAccessor attributeAccessor) {\n       // 获取当前节点的所有子元素\n        NodeList nl = ele.getChildNodes();\n        for (int i = 0; i &lt; nl.getLength(); i++) {\n            Node node = nl.item(i);\n            // 提出meta\n            if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) {\n                Element metaElement = (Element) node;\n                String key = metaElement.getAttribute(KEY_ATTRIBUTE);\n                String value = metaElement.getAttribute(VALUE_ATTRIBUTE);\n                // 使用key、value构造BeanMetadataAttribute\n                BeanMetadataAttribute attribute = \n                    new BeanMetadataAttribute(key, value);\n                attribute.setSource(extractSource(metaElement));\n                // 记录信息\n                attributeAccessor.addMetadataAttribute(attribute);\n            }\n        }\n    }\n</code></pre>\n<p>解析过程较为简单，获取相应的 key – value 构建 BeanMetadataAttribute 对象，然后通过 <code>addMetadataAttribute()</code>加入到 AbstractBeanDefinition 中。 “ 如下：</p>\n<pre><code class=\"java\">    public void addMetadataAttribute(BeanMetadataAttribute attribute) {\n        super.setAttribute(attribute.getName(), attribute);\n    }\n</code></pre>\n<p>委托 AttributeAccessorSupport 实现，如下：</p>\n<pre><code class=\"java\">    public void setAttribute(String name, @Nullable Object value) {\n        Assert.notNull(name, &quot;Name must not be null&quot;);\n        if (value != null) {\n            this.attributes.put(name, value);\n        }\n        else {\n            removeAttribute(name);\n        }\n    }\n</code></pre>\n<p>AttributeAccessorSupport 是接口 AttributeAccessor 的实现者。 AttributeAccessor 接口定义了与其他对象的元数据进行连接和访问的约定，可以通过该接口对属性进行获取、设置、删除操作。</p>\n<p>设置元数据后，则可以通过 <code>getAttribute()</code> 获取,如下：</p>\n<pre><code class=\"java\">    public Object getAttribute(String name) {\n        BeanMetadataAttribute attribute = (BeanMetadataAttribute) super.getAttribute(name);\n        return (attribute != null ? attribute.getValue() : null);\n    }\n</code></pre>\n<h3 id=\"lookup-method-子元素解析\"><a href=\"#lookup-method-子元素解析\" class=\"headerlink\" title=\"lookup-method 子元素解析\"></a>lookup-method 子元素解析</h3><p><strong>lookup-method</strong> ：获取器注入，是把一个方法声明为返回某种类型的 bean 但实际要返回的 bean 是在配置文件里面配置的。该方法可以用于设计一些可插拔的功能上，解除程序依赖。</p>\n<p>直接上例子：</p>\n<pre><code class=\"java\">public interface Car {\n\n    void display();\n}\n\npublic class Bmw implements Car{\n    @Override\n    public void display() {\n        System.out.println(&quot;我是 BMW&quot;);\n    }\n}\n\npublic class Hongqi implements Car{\n    @Override\n    public void display() {\n        System.out.println(&quot;我是 hongqi&quot;);\n    }\n}\n\npublic abstract class Display {\n\n\n    public void display(){\n        getCar().display();\n    }\n\n    public abstract Car getCar();\n}\n\n   public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);\n\n        Display display = (Display) context.getBean(&quot;display&quot;);\n        display.display();\n    }\n}\n</code></pre>\n<p>配置内容如下：</p>\n<pre><code class=\"xml\">    &lt;bean id=&quot;display&quot; class=&quot;org.springframework.core.test1.Display&quot;&gt;\n        &lt;lookup-method name=&quot;getCar&quot; bean=&quot;hongqi&quot;/&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p>运行结果为：</p>\n<pre><code class=\"null\">我是 hongqi\n</code></pre>\n<p>如果将 <code>bean=&quot;hognqi&quot;</code> 替换为 <code>bean=&quot;bmw&quot;</code>，则运行结果变成：</p>\n<pre><code class=\"null\">我是 BMW\n</code></pre>\n<p>看了这个示例，我们初步了解了 looku-method 子元素提供的功能了，其解析过程如下：</p>\n<pre><code class=\"java\">    public void parseLookupOverrideSubElements(Element beanEle, \n                                               MethodOverrides overrides) {\n        NodeList nl = beanEle.getChildNodes();\n        for (int i = 0; i &lt; nl.getLength(); i++) {\n            Node node = nl.item(i);\n            // 当且仅当spring默认bean的子元素下切位lookup-method时有效\n            if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, \n                                                           LOOKUP_METHOD_ELEMENT)) {\n                Element ele = (Element) node;\n                // 获取要修饰的方法\n                String methodName = ele.getAttribute(NAME_ATTRIBUTE);\n                // 获取配置返回的bean\n                String beanRef = ele.getAttribute(BEAN_ELEMENT);\n                LookupOverride override = new LookupOverride(methodName, beanRef);\n                override.setSource(extractSource(ele));\n                overrides.addOverride(override);\n            }\n        }\n    }\n</code></pre>\n<p>解析过程和 meta 子元素没有多大区别，同样是解析 methodName、beanRef 构造一个 LookupOverride 对象，然后覆盖即可。在实例化 Bean 的时候，再详细阐述具体的实现过程，这里仅仅只是一个标记作用。</p>\n<h3 id=\"replaced-method子元素解析\"><a href=\"#replaced-method子元素解析\" class=\"headerlink\" title=\"replaced-method子元素解析\"></a>replaced-method子元素解析</h3><p><strong>replaced-method</strong> ：可以在运行时调用新的方法替换现有的方法，还能动态的更新原有方法的逻辑</p>\n<p>该标签使用方法和 lookup-method 标签差不多，只不过替代方法的类需要实现 MethodReplacer 接口。如下:</p>\n<pre><code class=\"java\">public class Method {\n    public void display(){\n        System.out.println(&quot;我是原始方法&quot;);\n    }\n}\n\npublic class MethodReplace implements MethodReplacer {\n\n    @Override\n    public Object reimplement(Object obj, Method method, Object[] args) \n        throws Throwable {\n        System.out.println(&quot;我是替换方法&quot;);\n\n        return null;\n    }\n}\n\n    public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);\n\n        Method method = (Method) context.getBean(&quot;method&quot;);\n        method.display();\n    }\n</code></pre>\n<p>如果 spring.xml 文件如下：</p>\n<pre><code class=\"xml\">    &lt;bean id=&quot;methodReplace&quot; class=&quot;org.springframework.core.test1.MethodReplace&quot;/&gt;\n\n    &lt;bean id=&quot;method&quot; class=&quot;org.springframework.core.test1.Method&quot;/&gt;\n</code></pre>\n<p>则运行结果为：</p>\n<pre><code class=\"null\">我是原始方法\n</code></pre>\n<p>增加 replaced-method 子元素：</p>\n<pre><code class=\"xml\">    &lt;bean id=&quot;methodReplace&quot; class=&quot;org.springframework.core.test1.MethodReplace&quot;/&gt;\n\n    &lt;bean id=&quot;method&quot; class=&quot;org.springframework.core.test1.Method&quot;&gt;\n        &lt;replaced-method name=&quot;display&quot; replacer=&quot;methodReplace&quot;/&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p>运行结果为：</p>\n<pre><code class=\"null\">我是替换方法\n</code></pre>\n<p>另外需要补充的一点是</p>\n<p>如果我们的<code>MethodReplacer</code>将要替换的方法在对应的<code>bean</code>中属于重载类型的方法，即存在多个方法名相同的方法时，我们还需要通过在<code>replaced-method</code>元素下通过<code>arg-type</code>元素来定义对应方法参数的类型，这样就可以区分需要替换的是哪一个方法。所以，针对上述示例，我们也可以如下定义：</p>\n<pre><code class=\"xml\">    &lt;bean id=&quot;beanAReplacer&quot; class=&quot;com.app.BeanAReplacer&quot;/&gt;\n    &lt;bean id=&quot;beanA&quot; class=&quot;com.app.BeanA&quot;&gt;\n        &lt;replaced-method name=&quot;add&quot; replacer=&quot;beanAReplacer&quot;&gt;\n            &lt;arg-type match=&quot;int&quot;/&gt;\n            &lt;arg-type match=&quot;int&quot;/&gt;\n        &lt;/replaced-method&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p>对应方法名的方法只存在一个时，<code>arg-type</code>将不起作用，即<code>Spring</code>此时不会根据<code>arg-type</code>去取对应的方法进行替换，或者换句话说就是当<code>replaced-method</code>指定名称的方法只存在一个时，无论<code>arg-type</code>如何定义都是可以的。</p>\n<p>上面代码演示了 replaced-method 子元素的用法，下面再看看该子元素的解析过程。</p>\n<pre><code class=\"java\">    public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {\n        NodeList nl = beanEle.getChildNodes();\n        for (int i = 0; i &lt; nl.getLength(); i++) {\n            Node node = nl.item(i);\n            if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, \n                                                           REPLACED_METHOD_ELEMENT)) {\n                Element replacedMethodEle = (Element) node;\n                // 获取要替换的就得方法\n                String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);\n                // 获取对一个的新的替换方法\n                String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);\n                ReplaceOverride replaceOverride = new ReplaceOverride(name, callback);\n                // 获取参数类型列表\n                List&lt;Element&gt; argTypeEles = DomUtils\n                    .getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);\n                // 记录参数类型\n                for (Element argTypeEle : argTypeEles) {\n                    String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);\n                    match = (StringUtils.hasText(match)\n                                 ? match : DomUtils.getTextValue(argTypeEle));\n                    if (StringUtils.hasText(match)) {\n                        replaceOverride.addTypeIdentifier(match);\n                    }\n                }\n                replaceOverride.setSource(extractSource(replacedMethodEle));\n                overrides.addOverride(replaceOverride);\n            }\n        }\n    }\n</code></pre>\n<p>该子元素和 lookup-method 资源的解析过程差不多，同样是提取 name 和 replacer 属性构建 ReplaceOverride 对象，然后记录到 AbstractBeanDefinition 中的 methodOverrides 属性中。</p>\n<p>对于 lookup-method 和 replaced-method 两个子元素是如何使用以完成他们所提供的功能，在后续实例化 Bean 的时候会做详细说明。</p>"},{"abbrlink":31,"title":"spring源码解析之 12alias、import、beans标签的解析","author":"fengxiutianya","date":"2019-01-13T21:32:00.000Z","_content":"# spring源码解析之 12alias，import标签的解析\n\n### 概述\n\n1. alias标签解析\n2. import标签解析\n3. 嵌入式beans标签解析\n\n通过前面较长的篇幅我们终于完成了默认标签中对bean标签的处理，那么我们之前提到过，对配置文件的解析包括对import标签，alias标签、bean标签的处理，而这三个的解析也是围绕着bean标签。下面我们先来看alias标签的解析。\n\n在bean进行定义时，除了使用id属性来制定名称之外，为了提供多个名称，可以使用alias标签来指定，而所有的这些名称都指向统一bean，在某些情况下提供别名非常有用，比如为了让应用的 每一个组件都能更容易地对公共组件进行引用。\n<!-- more-->\n在xml中可以使用如下格式来指定bean的别名\n\n```xml\n<bean  id=\"testbean\" class=\"\"></bean>\n<alias name=\"testbean\" alias=\"test1,test2\"></alias>\n```\n\n下面我们来深入分析下对于alias标签的解析过程\n\n```java\nprotected void processAliasRegistration(Element ele) {\n    \t//获取beannanme\n\t\tString name = ele.getAttribute(NAME_ATTRIBUTE);\n\t\t// 获取alias\n    \tString alias = ele.getAttribute(ALIAS_ATTRIBUTE);\n\t\tboolean valid = true;\n\t\tif (!StringUtils.hasText(name)) {\n\t\t\tgetReaderContext().error(\"Name must not be empty\", ele);\n\t\t\tvalid = false;\n\t\t}\n\t\tif (!StringUtils.hasText(alias)) {\n\t\t\tgetReaderContext().error(\"Alias must not be empty\", ele);\n\t\t\tvalid = false;\n\t\t}\n\t\tif (valid) {\n\t\t\ttry {\n                //注册alias\n\t\t\t\tgetReaderContext().getRegistry().registerAlias(name, alias);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tgetReaderContext().error(\"Failed to register alias '\" + alias +\n\t\t\t\t\t\t\"' for bean with name '\" + name + \"'\", ele, ex);\n\t\t\t}\n            //别名注册后通知监听器做响应的处理\n\t\t\tgetReaderContext().fireAliasRegistered(name, alias, extractSource(ele));\n\t\t}\n\t}\n```\n\n可以发现，跟之前讲过的bean中的alias注册大同小异，都是将别名与beanName组成一对注册到registry中。\n\n### import标签解析\n\n经历过 Spring 配置文件的小伙伴都知道，如果工程比较大，配置文件的维护会让人觉得恐怖，文件太多了，想象将所有的配置都放在一个 spring.xml 配置文件中，哪种后怕感是不是很明显？所有针对这种情况 Spring 提供了一个分模块的思路，利用 import 标签，例如我们可以构造一个这样的 spring.xml。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <import resource=\"spring-student.xml\"/>\n    <import resource=\"spring-student-dtd.xml\"/>\n</beans>\n```\n\nspring.xml 配置文件中使用 import 标签的方式导入其他模块的配置文件，如果有配置需要修改直接修改相应配置文件即可，若有新的模块需要引入直接增加 import 即可，这样大大简化了配置后期维护的复杂度，同时也易于管理。\n\nSpring 利用 `importBeanDefinitionResource()` 方法完成对 import 标签的解析。\n\n```java\n    protected void importBeanDefinitionResource(Element ele) {\n        // 获取 resource 的属性值 \n        String location = ele.getAttribute(RESOURCE_ATTRIBUTE);\n        // 为空，直接退出\n        if (!StringUtils.hasText(location)) {\n            getReaderContext().error(\"Resource location must not be empty\", ele);\n            return;\n        }\n\n        // 解析系统属性，格式如 ：\"${user.dir}\"\n        location = getReaderContext().\n            \tgetEnvironment().resolveRequiredPlaceholders(location);\n\n        Set<Resource> actualResources = new LinkedHashSet<>(4);\n\n        // 判断 location 是相对路径还是绝对路径\n        boolean absoluteLocation = false;\n        try {\n            absoluteLocation = ResourcePatternUtils.isUrl(location) || \n                ResourceUtils.toURI(location).isAbsolute();\n        }\n        catch (URISyntaxException ex) {\n            // cannot convert to an URI, considering the location relative\n            // unless it is the well-known Spring prefix \"classpath*:\"\n        }\n\n        // 绝对路径\n        if (absoluteLocation) {\n            try {\n                // 直接根据地质加载相应的配置文件\n                int importCount = getReaderContext().getReader()\n                    \t.loadBeanDefinitions(location, actualResources);\n                if (logger.isDebugEnabled()) {\n                logger.debug(\"Imported \" +  importCount \n                     + \" bean definitions from URL location [\" + location + \"]\");\n                }\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\n                        \"Failed to import bean definitions from URL location [\"\n                    \t+ location + \"]\", ele, ex);\n            }\n        }\n        else {\n            // 相对路径则根据相应的地质计算出绝对路径地址\n            try {\n                int importCount;\n                Resource relativeResource = getReaderContext().getResource()\n                    \t\t\t\t\t\t\t.createRelative(location);\n                if (relativeResource.exists()) {\n                    importCount = getReaderContext().getReader()\n                        \t\t\t\t.loadBeanDefinitions(relativeResource);\n                    actualResources.add(relativeResource);\n                }\n                else {\n                    String baseLocation = getReaderContext().getResource()\n                        \t\t\t\t\t.getURL().toString();\n                    importCount = getReaderContext().getReader()\n                        \t.loadBeanDefinitions(  \n                            \tStringUtil.applyRelativePath(baseLocation, location),\n                        \t\t\tactualResources);\n                }\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Imported \" +  importCount + \n                                 \" bean definitions from relative location [\" \n                                 \t+ location + \"]\");\n                }\n            }\n            catch (IOException ex) {\n                getReaderContext().error(\"Failed to resolve current resource location\", \n                                         \tele, ex);\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\"Failed to import bean definitions from \n                                         relative location [\" + location + \"]\",\n                                         \t\t\t  ele, ex);\n            }\n        }\n        // 解析成功后，进行监听器激活处理\n        Resource[] actResArray = actualResources.toArray(new Resource[0]);\n        getReaderContext().fireImportProcessed(location, actResArray, \n                                               extractSource(ele));\n    }\n```\n\n解析 import 过程较为清晰，整个过程如下：\n\n1. 获取 source 属性的值，该值表示资源的路径\n2. 解析路径中的系统属性，如”${user.dir}”\n3. 判断资源路径 location 是绝对路径还是相对路径\n4. 如果是绝对路径，则调递归调用 Bean 的解析过程，进行另一次的解析\n5. 如果是相对路径，则先计算出绝对路径得到 Resource，然后进行解析\n6. 通知监听器，完成解析\n\n**判断路径**\n\n方法通过以下方法来判断 location 是为相对路径还是绝对路径：\n\n```null\nabsoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();\n```\n\n判断绝对路径的规则如下：\n\n- 以 classpath*: 或者 classpath: 开头为绝对路径\n- 能够通过该 location 构建出 `java.net.URL`为绝对路径\n- 根据 location 构造 `java.net.URI` 判断调用 `isAbsolute()` 判断是否为绝对路径\n\n**绝对路径**\n\n如果 location 为绝对路径则调用 `loadBeanDefinitions()`，该方法在 AbstractBeanDefinitionReader 中定义。\n\n```java\n    public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {\n        ResourceLoader resourceLoader = getResourceLoader();\n        if (resourceLoader == null) {\n            throw new BeanDefinitionStoreException(\n                    \"Cannot import bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n        }\n\n        if (resourceLoader instanceof ResourcePatternResolver) {\n            // Resource pattern matching available.\n            try {\n                Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n                int loadCount = loadBeanDefinitions(resources);\n                if (actualResources != null) {\n                    for (Resource resource : resources) {\n                        actualResources.add(resource);\n                    }\n                }\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Loaded \" + loadCount + \" bean definitions from location pattern [\" + location + \"]\");\n                }\n                return loadCount;\n            }\n            catch (IOException ex) {\n                throw new BeanDefinitionStoreException(\n                        \"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n            }\n        }\n        else {\n            // Can only load single resources by absolute URL.\n            Resource resource = resourceLoader.getResource(location);\n            int loadCount = loadBeanDefinitions(resource);\n            if (actualResources != null) {\n                actualResources.add(resource);\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Loaded \" + loadCount + \" bean definitions from location [\" + location + \"]\");\n            }\n            return loadCount;\n        }\n    }\n```\n\n整个逻辑比较简单，首先获取 ResourceLoader，然后根据不同的 ResourceLoader 执行不同的逻辑，主要是可能存在多个 Resource，但是最终都会回归到 `XmlBeanDefinitionReader.loadBeanDefinitions()` ，所以这是一个递归的过程。\n\n**相对路径**\n\n如果是相对路径则会根据相应的 Resource 计算出相应的绝对路径，然后根据该路径构造一个 Resource，若该 Resource 存在，则调用 `XmlBeanDefinitionReader.loadBeanDefinitions()` 进行 BeanDefinition 加载，否则构造一个绝对 location ，调用 `AbstractBeanDefinitionReader.loadBeanDefinitions()` 方法，与绝对路径过程一样。\n\n至此，import 标签解析完毕，整个过程比较清晰明了：**获取 source 属性值，得到正确的资源路径，然后调用loadBeanDefinitions() 方法进行递归的 BeanDefinition 加载**\n\n### 嵌入式beans标签解析\n\n对于嵌入式的beans标签，有点类似于import标签所提供的解析。无非是递归调用beans的解析过程。因此在这里就不具体分析。","source":"_posts/spring 源码分析/spring/spring源码解析之 12alias标签的解析.md","raw":"abbrlink: 31\ntitle: spring源码解析之 12alias、import、beans标签的解析\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-14 05:32:00\n---\n# spring源码解析之 12alias，import标签的解析\n\n### 概述\n\n1. alias标签解析\n2. import标签解析\n3. 嵌入式beans标签解析\n\n通过前面较长的篇幅我们终于完成了默认标签中对bean标签的处理，那么我们之前提到过，对配置文件的解析包括对import标签，alias标签、bean标签的处理，而这三个的解析也是围绕着bean标签。下面我们先来看alias标签的解析。\n\n在bean进行定义时，除了使用id属性来制定名称之外，为了提供多个名称，可以使用alias标签来指定，而所有的这些名称都指向统一bean，在某些情况下提供别名非常有用，比如为了让应用的 每一个组件都能更容易地对公共组件进行引用。\n<!-- more-->\n在xml中可以使用如下格式来指定bean的别名\n\n```xml\n<bean  id=\"testbean\" class=\"\"></bean>\n<alias name=\"testbean\" alias=\"test1,test2\"></alias>\n```\n\n下面我们来深入分析下对于alias标签的解析过程\n\n```java\nprotected void processAliasRegistration(Element ele) {\n    \t//获取beannanme\n\t\tString name = ele.getAttribute(NAME_ATTRIBUTE);\n\t\t// 获取alias\n    \tString alias = ele.getAttribute(ALIAS_ATTRIBUTE);\n\t\tboolean valid = true;\n\t\tif (!StringUtils.hasText(name)) {\n\t\t\tgetReaderContext().error(\"Name must not be empty\", ele);\n\t\t\tvalid = false;\n\t\t}\n\t\tif (!StringUtils.hasText(alias)) {\n\t\t\tgetReaderContext().error(\"Alias must not be empty\", ele);\n\t\t\tvalid = false;\n\t\t}\n\t\tif (valid) {\n\t\t\ttry {\n                //注册alias\n\t\t\t\tgetReaderContext().getRegistry().registerAlias(name, alias);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tgetReaderContext().error(\"Failed to register alias '\" + alias +\n\t\t\t\t\t\t\"' for bean with name '\" + name + \"'\", ele, ex);\n\t\t\t}\n            //别名注册后通知监听器做响应的处理\n\t\t\tgetReaderContext().fireAliasRegistered(name, alias, extractSource(ele));\n\t\t}\n\t}\n```\n\n可以发现，跟之前讲过的bean中的alias注册大同小异，都是将别名与beanName组成一对注册到registry中。\n\n### import标签解析\n\n经历过 Spring 配置文件的小伙伴都知道，如果工程比较大，配置文件的维护会让人觉得恐怖，文件太多了，想象将所有的配置都放在一个 spring.xml 配置文件中，哪种后怕感是不是很明显？所有针对这种情况 Spring 提供了一个分模块的思路，利用 import 标签，例如我们可以构造一个这样的 spring.xml。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <import resource=\"spring-student.xml\"/>\n    <import resource=\"spring-student-dtd.xml\"/>\n</beans>\n```\n\nspring.xml 配置文件中使用 import 标签的方式导入其他模块的配置文件，如果有配置需要修改直接修改相应配置文件即可，若有新的模块需要引入直接增加 import 即可，这样大大简化了配置后期维护的复杂度，同时也易于管理。\n\nSpring 利用 `importBeanDefinitionResource()` 方法完成对 import 标签的解析。\n\n```java\n    protected void importBeanDefinitionResource(Element ele) {\n        // 获取 resource 的属性值 \n        String location = ele.getAttribute(RESOURCE_ATTRIBUTE);\n        // 为空，直接退出\n        if (!StringUtils.hasText(location)) {\n            getReaderContext().error(\"Resource location must not be empty\", ele);\n            return;\n        }\n\n        // 解析系统属性，格式如 ：\"${user.dir}\"\n        location = getReaderContext().\n            \tgetEnvironment().resolveRequiredPlaceholders(location);\n\n        Set<Resource> actualResources = new LinkedHashSet<>(4);\n\n        // 判断 location 是相对路径还是绝对路径\n        boolean absoluteLocation = false;\n        try {\n            absoluteLocation = ResourcePatternUtils.isUrl(location) || \n                ResourceUtils.toURI(location).isAbsolute();\n        }\n        catch (URISyntaxException ex) {\n            // cannot convert to an URI, considering the location relative\n            // unless it is the well-known Spring prefix \"classpath*:\"\n        }\n\n        // 绝对路径\n        if (absoluteLocation) {\n            try {\n                // 直接根据地质加载相应的配置文件\n                int importCount = getReaderContext().getReader()\n                    \t.loadBeanDefinitions(location, actualResources);\n                if (logger.isDebugEnabled()) {\n                logger.debug(\"Imported \" +  importCount \n                     + \" bean definitions from URL location [\" + location + \"]\");\n                }\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\n                        \"Failed to import bean definitions from URL location [\"\n                    \t+ location + \"]\", ele, ex);\n            }\n        }\n        else {\n            // 相对路径则根据相应的地质计算出绝对路径地址\n            try {\n                int importCount;\n                Resource relativeResource = getReaderContext().getResource()\n                    \t\t\t\t\t\t\t.createRelative(location);\n                if (relativeResource.exists()) {\n                    importCount = getReaderContext().getReader()\n                        \t\t\t\t.loadBeanDefinitions(relativeResource);\n                    actualResources.add(relativeResource);\n                }\n                else {\n                    String baseLocation = getReaderContext().getResource()\n                        \t\t\t\t\t.getURL().toString();\n                    importCount = getReaderContext().getReader()\n                        \t.loadBeanDefinitions(  \n                            \tStringUtil.applyRelativePath(baseLocation, location),\n                        \t\t\tactualResources);\n                }\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Imported \" +  importCount + \n                                 \" bean definitions from relative location [\" \n                                 \t+ location + \"]\");\n                }\n            }\n            catch (IOException ex) {\n                getReaderContext().error(\"Failed to resolve current resource location\", \n                                         \tele, ex);\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\"Failed to import bean definitions from \n                                         relative location [\" + location + \"]\",\n                                         \t\t\t  ele, ex);\n            }\n        }\n        // 解析成功后，进行监听器激活处理\n        Resource[] actResArray = actualResources.toArray(new Resource[0]);\n        getReaderContext().fireImportProcessed(location, actResArray, \n                                               extractSource(ele));\n    }\n```\n\n解析 import 过程较为清晰，整个过程如下：\n\n1. 获取 source 属性的值，该值表示资源的路径\n2. 解析路径中的系统属性，如”${user.dir}”\n3. 判断资源路径 location 是绝对路径还是相对路径\n4. 如果是绝对路径，则调递归调用 Bean 的解析过程，进行另一次的解析\n5. 如果是相对路径，则先计算出绝对路径得到 Resource，然后进行解析\n6. 通知监听器，完成解析\n\n**判断路径**\n\n方法通过以下方法来判断 location 是为相对路径还是绝对路径：\n\n```null\nabsoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();\n```\n\n判断绝对路径的规则如下：\n\n- 以 classpath*: 或者 classpath: 开头为绝对路径\n- 能够通过该 location 构建出 `java.net.URL`为绝对路径\n- 根据 location 构造 `java.net.URI` 判断调用 `isAbsolute()` 判断是否为绝对路径\n\n**绝对路径**\n\n如果 location 为绝对路径则调用 `loadBeanDefinitions()`，该方法在 AbstractBeanDefinitionReader 中定义。\n\n```java\n    public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {\n        ResourceLoader resourceLoader = getResourceLoader();\n        if (resourceLoader == null) {\n            throw new BeanDefinitionStoreException(\n                    \"Cannot import bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n        }\n\n        if (resourceLoader instanceof ResourcePatternResolver) {\n            // Resource pattern matching available.\n            try {\n                Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n                int loadCount = loadBeanDefinitions(resources);\n                if (actualResources != null) {\n                    for (Resource resource : resources) {\n                        actualResources.add(resource);\n                    }\n                }\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Loaded \" + loadCount + \" bean definitions from location pattern [\" + location + \"]\");\n                }\n                return loadCount;\n            }\n            catch (IOException ex) {\n                throw new BeanDefinitionStoreException(\n                        \"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n            }\n        }\n        else {\n            // Can only load single resources by absolute URL.\n            Resource resource = resourceLoader.getResource(location);\n            int loadCount = loadBeanDefinitions(resource);\n            if (actualResources != null) {\n                actualResources.add(resource);\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Loaded \" + loadCount + \" bean definitions from location [\" + location + \"]\");\n            }\n            return loadCount;\n        }\n    }\n```\n\n整个逻辑比较简单，首先获取 ResourceLoader，然后根据不同的 ResourceLoader 执行不同的逻辑，主要是可能存在多个 Resource，但是最终都会回归到 `XmlBeanDefinitionReader.loadBeanDefinitions()` ，所以这是一个递归的过程。\n\n**相对路径**\n\n如果是相对路径则会根据相应的 Resource 计算出相应的绝对路径，然后根据该路径构造一个 Resource，若该 Resource 存在，则调用 `XmlBeanDefinitionReader.loadBeanDefinitions()` 进行 BeanDefinition 加载，否则构造一个绝对 location ，调用 `AbstractBeanDefinitionReader.loadBeanDefinitions()` 方法，与绝对路径过程一样。\n\n至此，import 标签解析完毕，整个过程比较清晰明了：**获取 source 属性值，得到正确的资源路径，然后调用loadBeanDefinitions() 方法进行递归的 BeanDefinition 加载**\n\n### 嵌入式beans标签解析\n\n对于嵌入式的beans标签，有点类似于import标签所提供的解析。无非是递归调用beans的解析过程。因此在这里就不具体分析。","slug":"spring 源码分析/spring/spring源码解析之 12alias标签的解析","published":1,"updated":"2019-01-15T03:37:13.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovw9004l9q1uy52mps1j","content":"<h1 id=\"spring源码解析之-12alias，import标签的解析\"><a href=\"#spring源码解析之-12alias，import标签的解析\" class=\"headerlink\" title=\"spring源码解析之 12alias，import标签的解析\"></a>spring源码解析之 12alias，import标签的解析</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>alias标签解析</li>\n<li>import标签解析</li>\n<li>嵌入式beans标签解析</li>\n</ol>\n<p>通过前面较长的篇幅我们终于完成了默认标签中对bean标签的处理，那么我们之前提到过，对配置文件的解析包括对import标签，alias标签、bean标签的处理，而这三个的解析也是围绕着bean标签。下面我们先来看alias标签的解析。</p>\n<p>在bean进行定义时，除了使用id属性来制定名称之外，为了提供多个名称，可以使用alias标签来指定，而所有的这些名称都指向统一bean，在某些情况下提供别名非常有用，比如为了让应用的 每一个组件都能更容易地对公共组件进行引用。<br><a id=\"more\"></a><br>在xml中可以使用如下格式来指定bean的别名</p>\n<pre><code class=\"xml\">&lt;bean  id=&quot;testbean&quot; class=&quot;&quot;&gt;&lt;/bean&gt;\n&lt;alias name=&quot;testbean&quot; alias=&quot;test1,test2&quot;&gt;&lt;/alias&gt;\n</code></pre>\n<p>下面我们来深入分析下对于alias标签的解析过程</p>\n<pre><code class=\"java\">protected void processAliasRegistration(Element ele) {\n        //获取beannanme\n        String name = ele.getAttribute(NAME_ATTRIBUTE);\n        // 获取alias\n        String alias = ele.getAttribute(ALIAS_ATTRIBUTE);\n        boolean valid = true;\n        if (!StringUtils.hasText(name)) {\n            getReaderContext().error(&quot;Name must not be empty&quot;, ele);\n            valid = false;\n        }\n        if (!StringUtils.hasText(alias)) {\n            getReaderContext().error(&quot;Alias must not be empty&quot;, ele);\n            valid = false;\n        }\n        if (valid) {\n            try {\n                //注册alias\n                getReaderContext().getRegistry().registerAlias(name, alias);\n            }\n            catch (Exception ex) {\n                getReaderContext().error(&quot;Failed to register alias &#39;&quot; + alias +\n                        &quot;&#39; for bean with name &#39;&quot; + name + &quot;&#39;&quot;, ele, ex);\n            }\n            //别名注册后通知监听器做响应的处理\n            getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));\n        }\n    }\n</code></pre>\n<p>可以发现，跟之前讲过的bean中的alias注册大同小异，都是将别名与beanName组成一对注册到registry中。</p>\n<h3 id=\"import标签解析\"><a href=\"#import标签解析\" class=\"headerlink\" title=\"import标签解析\"></a>import标签解析</h3><p>经历过 Spring 配置文件的小伙伴都知道，如果工程比较大，配置文件的维护会让人觉得恐怖，文件太多了，想象将所有的配置都放在一个 spring.xml 配置文件中，哪种后怕感是不是很明显？所有针对这种情况 Spring 提供了一个分模块的思路，利用 import 标签，例如我们可以构造一个这样的 spring.xml。</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;import resource=&quot;spring-student.xml&quot;/&gt;\n    &lt;import resource=&quot;spring-student-dtd.xml&quot;/&gt;\n&lt;/beans&gt;\n</code></pre>\n<p>spring.xml 配置文件中使用 import 标签的方式导入其他模块的配置文件，如果有配置需要修改直接修改相应配置文件即可，若有新的模块需要引入直接增加 import 即可，这样大大简化了配置后期维护的复杂度，同时也易于管理。</p>\n<p>Spring 利用 <code>importBeanDefinitionResource()</code> 方法完成对 import 标签的解析。</p>\n<pre><code class=\"java\">    protected void importBeanDefinitionResource(Element ele) {\n        // 获取 resource 的属性值 \n        String location = ele.getAttribute(RESOURCE_ATTRIBUTE);\n        // 为空，直接退出\n        if (!StringUtils.hasText(location)) {\n            getReaderContext().error(&quot;Resource location must not be empty&quot;, ele);\n            return;\n        }\n\n        // 解析系统属性，格式如 ：&quot;${user.dir}&quot;\n        location = getReaderContext().\n                getEnvironment().resolveRequiredPlaceholders(location);\n\n        Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;&gt;(4);\n\n        // 判断 location 是相对路径还是绝对路径\n        boolean absoluteLocation = false;\n        try {\n            absoluteLocation = ResourcePatternUtils.isUrl(location) || \n                ResourceUtils.toURI(location).isAbsolute();\n        }\n        catch (URISyntaxException ex) {\n            // cannot convert to an URI, considering the location relative\n            // unless it is the well-known Spring prefix &quot;classpath*:&quot;\n        }\n\n        // 绝对路径\n        if (absoluteLocation) {\n            try {\n                // 直接根据地质加载相应的配置文件\n                int importCount = getReaderContext().getReader()\n                        .loadBeanDefinitions(location, actualResources);\n                if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Imported &quot; +  importCount \n                     + &quot; bean definitions from URL location [&quot; + location + &quot;]&quot;);\n                }\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\n                        &quot;Failed to import bean definitions from URL location [&quot;\n                        + location + &quot;]&quot;, ele, ex);\n            }\n        }\n        else {\n            // 相对路径则根据相应的地质计算出绝对路径地址\n            try {\n                int importCount;\n                Resource relativeResource = getReaderContext().getResource()\n                                                .createRelative(location);\n                if (relativeResource.exists()) {\n                    importCount = getReaderContext().getReader()\n                                        .loadBeanDefinitions(relativeResource);\n                    actualResources.add(relativeResource);\n                }\n                else {\n                    String baseLocation = getReaderContext().getResource()\n                                            .getURL().toString();\n                    importCount = getReaderContext().getReader()\n                            .loadBeanDefinitions(  \n                                StringUtil.applyRelativePath(baseLocation, location),\n                                    actualResources);\n                }\n                if (logger.isDebugEnabled()) {\n                    logger.debug(&quot;Imported &quot; +  importCount + \n                                 &quot; bean definitions from relative location [&quot; \n                                     + location + &quot;]&quot;);\n                }\n            }\n            catch (IOException ex) {\n                getReaderContext().error(&quot;Failed to resolve current resource location&quot;, \n                                             ele, ex);\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(&quot;Failed to import bean definitions from \n                                         relative location [&quot; + location + &quot;]&quot;,\n                                                       ele, ex);\n            }\n        }\n        // 解析成功后，进行监听器激活处理\n        Resource[] actResArray = actualResources.toArray(new Resource[0]);\n        getReaderContext().fireImportProcessed(location, actResArray, \n                                               extractSource(ele));\n    }\n</code></pre>\n<p>解析 import 过程较为清晰，整个过程如下：</p>\n<ol>\n<li>获取 source 属性的值，该值表示资源的路径</li>\n<li>解析路径中的系统属性，如”${user.dir}”</li>\n<li>判断资源路径 location 是绝对路径还是相对路径</li>\n<li>如果是绝对路径，则调递归调用 Bean 的解析过程，进行另一次的解析</li>\n<li>如果是相对路径，则先计算出绝对路径得到 Resource，然后进行解析</li>\n<li>通知监听器，完成解析</li>\n</ol>\n<p><strong>判断路径</strong></p>\n<p>方法通过以下方法来判断 location 是为相对路径还是绝对路径：</p>\n<pre><code class=\"null\">absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();\n</code></pre>\n<p>判断绝对路径的规则如下：</p>\n<ul>\n<li>以 classpath*: 或者 classpath: 开头为绝对路径</li>\n<li>能够通过该 location 构建出 <code>java.net.URL</code>为绝对路径</li>\n<li>根据 location 构造 <code>java.net.URI</code> 判断调用 <code>isAbsolute()</code> 判断是否为绝对路径</li>\n</ul>\n<p><strong>绝对路径</strong></p>\n<p>如果 location 为绝对路径则调用 <code>loadBeanDefinitions()</code>，该方法在 AbstractBeanDefinitionReader 中定义。</p>\n<pre><code class=\"java\">    public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException {\n        ResourceLoader resourceLoader = getResourceLoader();\n        if (resourceLoader == null) {\n            throw new BeanDefinitionStoreException(\n                    &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);\n        }\n\n        if (resourceLoader instanceof ResourcePatternResolver) {\n            // Resource pattern matching available.\n            try {\n                Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n                int loadCount = loadBeanDefinitions(resources);\n                if (actualResources != null) {\n                    for (Resource resource : resources) {\n                        actualResources.add(resource);\n                    }\n                }\n                if (logger.isDebugEnabled()) {\n                    logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);\n                }\n                return loadCount;\n            }\n            catch (IOException ex) {\n                throw new BeanDefinitionStoreException(\n                        &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);\n            }\n        }\n        else {\n            // Can only load single resources by absolute URL.\n            Resource resource = resourceLoader.getResource(location);\n            int loadCount = loadBeanDefinitions(resource);\n            if (actualResources != null) {\n                actualResources.add(resource);\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);\n            }\n            return loadCount;\n        }\n    }\n</code></pre>\n<p>整个逻辑比较简单，首先获取 ResourceLoader，然后根据不同的 ResourceLoader 执行不同的逻辑，主要是可能存在多个 Resource，但是最终都会回归到 <code>XmlBeanDefinitionReader.loadBeanDefinitions()</code> ，所以这是一个递归的过程。</p>\n<p><strong>相对路径</strong></p>\n<p>如果是相对路径则会根据相应的 Resource 计算出相应的绝对路径，然后根据该路径构造一个 Resource，若该 Resource 存在，则调用 <code>XmlBeanDefinitionReader.loadBeanDefinitions()</code> 进行 BeanDefinition 加载，否则构造一个绝对 location ，调用 <code>AbstractBeanDefinitionReader.loadBeanDefinitions()</code> 方法，与绝对路径过程一样。</p>\n<p>至此，import 标签解析完毕，整个过程比较清晰明了：<strong>获取 source 属性值，得到正确的资源路径，然后调用loadBeanDefinitions() 方法进行递归的 BeanDefinition 加载</strong></p>\n<h3 id=\"嵌入式beans标签解析\"><a href=\"#嵌入式beans标签解析\" class=\"headerlink\" title=\"嵌入式beans标签解析\"></a>嵌入式beans标签解析</h3><p>对于嵌入式的beans标签，有点类似于import标签所提供的解析。无非是递归调用beans的解析过程。因此在这里就不具体分析。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-12alias，import标签的解析\"><a href=\"#spring源码解析之-12alias，import标签的解析\" class=\"headerlink\" title=\"spring源码解析之 12alias，import标签的解析\"></a>spring源码解析之 12alias，import标签的解析</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>alias标签解析</li>\n<li>import标签解析</li>\n<li>嵌入式beans标签解析</li>\n</ol>\n<p>通过前面较长的篇幅我们终于完成了默认标签中对bean标签的处理，那么我们之前提到过，对配置文件的解析包括对import标签，alias标签、bean标签的处理，而这三个的解析也是围绕着bean标签。下面我们先来看alias标签的解析。</p>\n<p>在bean进行定义时，除了使用id属性来制定名称之外，为了提供多个名称，可以使用alias标签来指定，而所有的这些名称都指向统一bean，在某些情况下提供别名非常有用，比如为了让应用的 每一个组件都能更容易地对公共组件进行引用。<br>","more":"<br>在xml中可以使用如下格式来指定bean的别名</p>\n<pre><code class=\"xml\">&lt;bean  id=&quot;testbean&quot; class=&quot;&quot;&gt;&lt;/bean&gt;\n&lt;alias name=&quot;testbean&quot; alias=&quot;test1,test2&quot;&gt;&lt;/alias&gt;\n</code></pre>\n<p>下面我们来深入分析下对于alias标签的解析过程</p>\n<pre><code class=\"java\">protected void processAliasRegistration(Element ele) {\n        //获取beannanme\n        String name = ele.getAttribute(NAME_ATTRIBUTE);\n        // 获取alias\n        String alias = ele.getAttribute(ALIAS_ATTRIBUTE);\n        boolean valid = true;\n        if (!StringUtils.hasText(name)) {\n            getReaderContext().error(&quot;Name must not be empty&quot;, ele);\n            valid = false;\n        }\n        if (!StringUtils.hasText(alias)) {\n            getReaderContext().error(&quot;Alias must not be empty&quot;, ele);\n            valid = false;\n        }\n        if (valid) {\n            try {\n                //注册alias\n                getReaderContext().getRegistry().registerAlias(name, alias);\n            }\n            catch (Exception ex) {\n                getReaderContext().error(&quot;Failed to register alias &#39;&quot; + alias +\n                        &quot;&#39; for bean with name &#39;&quot; + name + &quot;&#39;&quot;, ele, ex);\n            }\n            //别名注册后通知监听器做响应的处理\n            getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));\n        }\n    }\n</code></pre>\n<p>可以发现，跟之前讲过的bean中的alias注册大同小异，都是将别名与beanName组成一对注册到registry中。</p>\n<h3 id=\"import标签解析\"><a href=\"#import标签解析\" class=\"headerlink\" title=\"import标签解析\"></a>import标签解析</h3><p>经历过 Spring 配置文件的小伙伴都知道，如果工程比较大，配置文件的维护会让人觉得恐怖，文件太多了，想象将所有的配置都放在一个 spring.xml 配置文件中，哪种后怕感是不是很明显？所有针对这种情况 Spring 提供了一个分模块的思路，利用 import 标签，例如我们可以构造一个这样的 spring.xml。</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;import resource=&quot;spring-student.xml&quot;/&gt;\n    &lt;import resource=&quot;spring-student-dtd.xml&quot;/&gt;\n&lt;/beans&gt;\n</code></pre>\n<p>spring.xml 配置文件中使用 import 标签的方式导入其他模块的配置文件，如果有配置需要修改直接修改相应配置文件即可，若有新的模块需要引入直接增加 import 即可，这样大大简化了配置后期维护的复杂度，同时也易于管理。</p>\n<p>Spring 利用 <code>importBeanDefinitionResource()</code> 方法完成对 import 标签的解析。</p>\n<pre><code class=\"java\">    protected void importBeanDefinitionResource(Element ele) {\n        // 获取 resource 的属性值 \n        String location = ele.getAttribute(RESOURCE_ATTRIBUTE);\n        // 为空，直接退出\n        if (!StringUtils.hasText(location)) {\n            getReaderContext().error(&quot;Resource location must not be empty&quot;, ele);\n            return;\n        }\n\n        // 解析系统属性，格式如 ：&quot;${user.dir}&quot;\n        location = getReaderContext().\n                getEnvironment().resolveRequiredPlaceholders(location);\n\n        Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;&gt;(4);\n\n        // 判断 location 是相对路径还是绝对路径\n        boolean absoluteLocation = false;\n        try {\n            absoluteLocation = ResourcePatternUtils.isUrl(location) || \n                ResourceUtils.toURI(location).isAbsolute();\n        }\n        catch (URISyntaxException ex) {\n            // cannot convert to an URI, considering the location relative\n            // unless it is the well-known Spring prefix &quot;classpath*:&quot;\n        }\n\n        // 绝对路径\n        if (absoluteLocation) {\n            try {\n                // 直接根据地质加载相应的配置文件\n                int importCount = getReaderContext().getReader()\n                        .loadBeanDefinitions(location, actualResources);\n                if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Imported &quot; +  importCount \n                     + &quot; bean definitions from URL location [&quot; + location + &quot;]&quot;);\n                }\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\n                        &quot;Failed to import bean definitions from URL location [&quot;\n                        + location + &quot;]&quot;, ele, ex);\n            }\n        }\n        else {\n            // 相对路径则根据相应的地质计算出绝对路径地址\n            try {\n                int importCount;\n                Resource relativeResource = getReaderContext().getResource()\n                                                .createRelative(location);\n                if (relativeResource.exists()) {\n                    importCount = getReaderContext().getReader()\n                                        .loadBeanDefinitions(relativeResource);\n                    actualResources.add(relativeResource);\n                }\n                else {\n                    String baseLocation = getReaderContext().getResource()\n                                            .getURL().toString();\n                    importCount = getReaderContext().getReader()\n                            .loadBeanDefinitions(  \n                                StringUtil.applyRelativePath(baseLocation, location),\n                                    actualResources);\n                }\n                if (logger.isDebugEnabled()) {\n                    logger.debug(&quot;Imported &quot; +  importCount + \n                                 &quot; bean definitions from relative location [&quot; \n                                     + location + &quot;]&quot;);\n                }\n            }\n            catch (IOException ex) {\n                getReaderContext().error(&quot;Failed to resolve current resource location&quot;, \n                                             ele, ex);\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(&quot;Failed to import bean definitions from \n                                         relative location [&quot; + location + &quot;]&quot;,\n                                                       ele, ex);\n            }\n        }\n        // 解析成功后，进行监听器激活处理\n        Resource[] actResArray = actualResources.toArray(new Resource[0]);\n        getReaderContext().fireImportProcessed(location, actResArray, \n                                               extractSource(ele));\n    }\n</code></pre>\n<p>解析 import 过程较为清晰，整个过程如下：</p>\n<ol>\n<li>获取 source 属性的值，该值表示资源的路径</li>\n<li>解析路径中的系统属性，如”${user.dir}”</li>\n<li>判断资源路径 location 是绝对路径还是相对路径</li>\n<li>如果是绝对路径，则调递归调用 Bean 的解析过程，进行另一次的解析</li>\n<li>如果是相对路径，则先计算出绝对路径得到 Resource，然后进行解析</li>\n<li>通知监听器，完成解析</li>\n</ol>\n<p><strong>判断路径</strong></p>\n<p>方法通过以下方法来判断 location 是为相对路径还是绝对路径：</p>\n<pre><code class=\"null\">absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();\n</code></pre>\n<p>判断绝对路径的规则如下：</p>\n<ul>\n<li>以 classpath*: 或者 classpath: 开头为绝对路径</li>\n<li>能够通过该 location 构建出 <code>java.net.URL</code>为绝对路径</li>\n<li>根据 location 构造 <code>java.net.URI</code> 判断调用 <code>isAbsolute()</code> 判断是否为绝对路径</li>\n</ul>\n<p><strong>绝对路径</strong></p>\n<p>如果 location 为绝对路径则调用 <code>loadBeanDefinitions()</code>，该方法在 AbstractBeanDefinitionReader 中定义。</p>\n<pre><code class=\"java\">    public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException {\n        ResourceLoader resourceLoader = getResourceLoader();\n        if (resourceLoader == null) {\n            throw new BeanDefinitionStoreException(\n                    &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);\n        }\n\n        if (resourceLoader instanceof ResourcePatternResolver) {\n            // Resource pattern matching available.\n            try {\n                Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n                int loadCount = loadBeanDefinitions(resources);\n                if (actualResources != null) {\n                    for (Resource resource : resources) {\n                        actualResources.add(resource);\n                    }\n                }\n                if (logger.isDebugEnabled()) {\n                    logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);\n                }\n                return loadCount;\n            }\n            catch (IOException ex) {\n                throw new BeanDefinitionStoreException(\n                        &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);\n            }\n        }\n        else {\n            // Can only load single resources by absolute URL.\n            Resource resource = resourceLoader.getResource(location);\n            int loadCount = loadBeanDefinitions(resource);\n            if (actualResources != null) {\n                actualResources.add(resource);\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);\n            }\n            return loadCount;\n        }\n    }\n</code></pre>\n<p>整个逻辑比较简单，首先获取 ResourceLoader，然后根据不同的 ResourceLoader 执行不同的逻辑，主要是可能存在多个 Resource，但是最终都会回归到 <code>XmlBeanDefinitionReader.loadBeanDefinitions()</code> ，所以这是一个递归的过程。</p>\n<p><strong>相对路径</strong></p>\n<p>如果是相对路径则会根据相应的 Resource 计算出相应的绝对路径，然后根据该路径构造一个 Resource，若该 Resource 存在，则调用 <code>XmlBeanDefinitionReader.loadBeanDefinitions()</code> 进行 BeanDefinition 加载，否则构造一个绝对 location ，调用 <code>AbstractBeanDefinitionReader.loadBeanDefinitions()</code> 方法，与绝对路径过程一样。</p>\n<p>至此，import 标签解析完毕，整个过程比较清晰明了：<strong>获取 source 属性值，得到正确的资源路径，然后调用loadBeanDefinitions() 方法进行递归的 BeanDefinition 加载</strong></p>\n<h3 id=\"嵌入式beans标签解析\"><a href=\"#嵌入式beans标签解析\" class=\"headerlink\" title=\"嵌入式beans标签解析\"></a>嵌入式beans标签解析</h3><p>对于嵌入式的beans标签，有点类似于import标签所提供的解析。无非是递归调用beans的解析过程。因此在这里就不具体分析。</p>"},{"abbrlink":33,"title":" spring 源码解析之 14注册解析的BeanDefinition","author":"fengxiutianya","date":"2019-01-13T21:39:00.000Z","_content":"# spring 源码解析之 14注册解析的BeanDefinition\n\n`DefaultBeanDefinitionDocumentReader.processBeanDefinition()` 完成 Bean 标签解析的核心工作，如下：\n<!-- more-->\n\n```java\n    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\"Failed to register bean definition with name '\" +\n                        bdHolder.getBeanName() + \"'\", ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n        }\n    }\n```\n\n解析工作分为三步：\n\n1. 解析默认标签；\n2. 解析默认标签中的自定义属性标签；\n3. 注册解析后的 BeanDefinition。\n\n经过前面两个步骤的解析，这时的 BeanDefinition 已经可以满足后续的使用要求了，那么接下来的工作就是将这些 BeanDefinition 进行注册，也就是完成第三步。\n\n注册 BeanDefinition 由 `BeanDefinitionReaderUtils.registerBeanDefinition()` 完成。如下：\n\n```java\n    public static void registerBeanDefinition(\n            BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n            throws BeanDefinitionStoreException {\n\n        // 注册 beanName\n        String beanName = definitionHolder.getBeanName();\n        registry.registerBeanDefinition(beanName, \n                                        definitionHolder.getBeanDefinition());\n\n        // 注册 alias \n        String[] aliases = definitionHolder.getAliases();\n        if (aliases != null) {\n            for (String alias : aliases) {\n                registry.registerAlias(beanName, alias);\n            }\n        }\n    }\n```\n\n首先通过 beanName 注册 BeanDefinition ，然后再注册别名 alias。BeanDefinition 的注册由接口 BeanDefinitionRegistry 定义。\n\n### **通过 beanName 注册**\n\n`BeanDefinitionRegistry.registerBeanDefinition()` 实现通过 beanName 注册 BeanDefinition，如下：\n\n```java\n   public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n            throws BeanDefinitionStoreException {\n\n        // 校验 beanName 与 beanDefinition\n        Assert.hasText(beanName, \"Bean name must not be empty\");\n        Assert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\n        if (beanDefinition instanceof AbstractBeanDefinition) {\n            try {\n                // 校验 BeanDefinition\n                // 这是注册前的最后一次校验了，主要是对属性 methodOverrides 进行校验\n                // 校验methodOverride是否与工厂方法并存或者methodOverrides对应的方法根本不存在\n                ((AbstractBeanDefinition) beanDefinition).validate();\n            }\n            catch (BeanDefinitionValidationException ex) {\n                throw new BeanDefinitionStoreException(\n                    beanDefinition.getResourceDescription(), beanName,\n                        \"Validation of bean definition failed\", ex);\n            }\n        }\n\n        BeanDefinition oldBeanDefinition;\n\n        // 从缓存中获取指定 beanName 的 BeanDefinition\n        oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n        /**\n         * 如果存在\n         */\n        if (oldBeanDefinition != null) {\n            // 如果存在但是不允许覆盖，抛出异常\n            if (!isAllowBeanDefinitionOverriding()) {\n                throw new BeanDefinitionStoreException(\n                    beanDefinition.getResourceDescription(), beanName,\n                        \"Cannot register bean definition [\" + beanDefinition\n                                         + \"] for bean '\" + beanName\n                      +\"': There is already [\" + oldBeanDefinition + \"] bound.\");\n            }\n            //根据bean的角色来判断这个BeanDefinition是否是用户自定义的，然后覆盖了系统定义的bean\n            // 在spring中bean的角色分为\n            //  0代表 apllication 用户自定义\n            //  1代表 support \t配置，起到支撑作用\n            //  2代表 infrastructure 系统运行过程中背后起到支撑的作用\n            else if (oldBeanDefinition.getRole() < beanDefinition.getRole()) {\n\n                if (this.logger.isWarnEnabled()) {\n                    this.logger.warn(\"Overriding user-defined bean definition\n                                     for bean '\" + beanName +\n                     \"' with a framework-generated bean definition: replacing [\" +\n                            oldBeanDefinition + \"] with [\" + beanDefinition + \"]\");\n                }\n            }\n            // 覆盖 beanDefinition 与 被覆盖的 beanDefinition 不是同类\n            else if (!beanDefinition.equals(oldBeanDefinition)) {\n                if (this.logger.isInfoEnabled()) {\n                    this.logger.info(\"Overriding bean definition for bean '\"+ beanName \n                      + \"' with a different definition: replacing [\"+oldBeanDefinition \n                                     +\"] with [\" + beanDefinition + \"]\");\n                }\n            }\n            else {\n                if (this.logger.isDebugEnabled()) {\n                    this.logger.debug(\"Overriding bean definition for bean '\" + \n                           beanName +\"' with an equivalent definition: replacing [\"\n                                      + oldBeanDefinition +\n                            \"] with [\" + beanDefinition + \"]\");\n                }\n            }\n\n            // 允许覆盖，直接覆盖原有的 BeanDefinition\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n        }\n        //  系统不存在相同的BeanDefinition\n        else {\n        // 检测创建 Bean 阶段是否已经开启，如果开启了则需要对 beanDefinitionMap 进行并发控制\n            if (hasBeanCreationStarted()) {\n                // beanDefinitionMap 为全局变量，避免并发情况\n                synchronized (this.beanDefinitionMap) {\n                    //\n                    this.beanDefinitionMap.put(beanName, beanDefinition);\n                    List<String> updatedDefinitions = \n                        new ArrayList<>(this.beanDefinitionNames.size() + 1);\n                    updatedDefinitions.addAll(this.beanDefinitionNames);\n                    updatedDefinitions.add(beanName);\n                    this.beanDefinitionNames = updatedDefinitions;\n                    if (this.manualSingletonNames.contains(beanName)) {\n                        Set<String> updatedSingletons = \n                            new LinkedHashSet<>(this.manualSingletonNames);\n                        updatedSingletons.remove(beanName);\n                        this.manualSingletonNames = updatedSingletons;\n                    }\n                }\n            }\n            else {\n                // 不会存在并发情况，直接设置\n                this.beanDefinitionMap.put(beanName, beanDefinition);\n                this.beanDefinitionNames.add(beanName);\n                this.manualSingletonNames.remove(beanName);\n            }\n            this.frozenBeanDefinitionNames = null;\n        }\n\n        if (oldBeanDefinition != null || containsSingleton(beanName)) {\n            // 重新设置 beanName 对应的缓存\n            resetBeanDefinition(beanName);\n        }\n    }\n```\n\n处理过程如下：\n\n- 首先 BeanDefinition 进行校验，该校验也是注册过程中的最后一次校验了，主要是对 AbstractBeanDefinition 的 methodOverrides 属性进行校验。其中有一点我在这里在说明一下**methodOverrides不能和工厂方法并存，是因为未实现methodOverrides需要使用使用动态代理来改变这个类，如果使用cglib，则需要修改字节码，如果使用了工厂方法，是直接返回bean，而动态代理是无法修改这个对象的**\n- 根据 beanName 从缓存中获取 BeanDefinition，如果缓存中存在，则根据 allowBeanDefinitionOverriding 标志来判断是否允许覆盖，如果允许则直接覆盖，否则抛出 BeanDefinitionStoreException 异常\n- 若缓存中没有指定 beanName 的 BeanDefinition，则判断当前阶段是否已经开始了 Bean 的创建阶段，如果是，则需要对 beanDefinitionMap 进行加锁控制并发问题，否则直接设置即可。对于 `hasBeanCreationStarted()` 方法后续做详细介绍，这里不过多阐述。\n- 若缓存中存在该 beanName 或者单例bean 集合中存在该 beanName，则调用 `resetBeanDefinition()` 重置 BeanDefinition 缓存。\n\n其实整段代码的核心就在于 `this.beanDefinitionMap.put(beanName, beanDefinition);` 。BeanDefinition 的缓存也不是神奇的东西，就是定义 map ，key 为 beanName，value 为 BeanDefinition。\n\n**注册 alias**\n\n`BeanDefinitionRegistry.registerAlias` 完成 alias 的注册。\n\n```java\n    public void registerAlias(String name, String alias) {\n        // 校验 name 、 alias\n        Assert.hasText(name, \"'name' must not be empty\");\n        Assert.hasText(alias, \"'alias' must not be empty\");\n        synchronized (this.aliasMap) {\n            // name == alias 则去掉alias\n            if (alias.equals(name)) {\n                this.aliasMap.remove(alias);\n            }\n            else {\n                // 缓存缓存记录\n                String registeredName = this.aliasMap.get(alias);\n                if (registeredName != null) {\n                    // 缓存中的相等，则直接返回\n                    if (registeredName.equals(name)) {\n                        // An existing alias - no need to re-register\n                        return;\n                    }\n                    // 不允许则抛出异常\n                    if (!allowAliasOverriding()) {\n                        throw new IllegalStateException(\"Cannot register alias '\"\n                                + alias + \"' for name '\" +name + \n                    \"': It is already registered for name '\" + registeredName + \"'.\");\n                    }\n                }\n                // 当 A --> B 存在时，如果再次出现 A --> C --> B 则抛出异常\n                checkForAliasCircle(name, alias);\n                // 注册 alias\n                this.aliasMap.put(alias, name);\n            }\n        }\n    }\n```\n\n注册 alias 和注册 BeanDefinition 的过程差不多。在最后调用了 `checkForAliasCircle()` 来对别名进行了检测。\n\n```java\n    public boolean hasAlias(String name, String alias) {\n        for (Map.Entry<String, String> entry : this.aliasMap.entrySet()) {\n            String registeredName = entry.getValue();\n            if (registeredName.equals(name)) {\n                String registeredAlias = entry.getKey();\n                return (registeredAlias.equals(alias) \n                        || hasAlias(registeredAlias, alias));\n            }\n        }\n        return false;\n    }\n```\n\n如果 name 、 alias 为 1 、3 ，则构成 （1,3），加入集合中存在（3,A）、（A,1）的情况则会出错。\n\n到此为止BeanDefinition已经注册完成，下一步就是初始化bean。","source":"_posts/spring 源码分析/spring/spring源码解析之 14注册解析的BeanDefinition.md","raw":"abbrlink: 33\ntitle: ' spring 源码解析之 14注册解析的BeanDefinition'\ntags:\n  - spring\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-14 05:39:00\n---\n# spring 源码解析之 14注册解析的BeanDefinition\n\n`DefaultBeanDefinitionDocumentReader.processBeanDefinition()` 完成 Bean 标签解析的核心工作，如下：\n<!-- more-->\n\n```java\n    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\"Failed to register bean definition with name '\" +\n                        bdHolder.getBeanName() + \"'\", ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n        }\n    }\n```\n\n解析工作分为三步：\n\n1. 解析默认标签；\n2. 解析默认标签中的自定义属性标签；\n3. 注册解析后的 BeanDefinition。\n\n经过前面两个步骤的解析，这时的 BeanDefinition 已经可以满足后续的使用要求了，那么接下来的工作就是将这些 BeanDefinition 进行注册，也就是完成第三步。\n\n注册 BeanDefinition 由 `BeanDefinitionReaderUtils.registerBeanDefinition()` 完成。如下：\n\n```java\n    public static void registerBeanDefinition(\n            BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n            throws BeanDefinitionStoreException {\n\n        // 注册 beanName\n        String beanName = definitionHolder.getBeanName();\n        registry.registerBeanDefinition(beanName, \n                                        definitionHolder.getBeanDefinition());\n\n        // 注册 alias \n        String[] aliases = definitionHolder.getAliases();\n        if (aliases != null) {\n            for (String alias : aliases) {\n                registry.registerAlias(beanName, alias);\n            }\n        }\n    }\n```\n\n首先通过 beanName 注册 BeanDefinition ，然后再注册别名 alias。BeanDefinition 的注册由接口 BeanDefinitionRegistry 定义。\n\n### **通过 beanName 注册**\n\n`BeanDefinitionRegistry.registerBeanDefinition()` 实现通过 beanName 注册 BeanDefinition，如下：\n\n```java\n   public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n            throws BeanDefinitionStoreException {\n\n        // 校验 beanName 与 beanDefinition\n        Assert.hasText(beanName, \"Bean name must not be empty\");\n        Assert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\n        if (beanDefinition instanceof AbstractBeanDefinition) {\n            try {\n                // 校验 BeanDefinition\n                // 这是注册前的最后一次校验了，主要是对属性 methodOverrides 进行校验\n                // 校验methodOverride是否与工厂方法并存或者methodOverrides对应的方法根本不存在\n                ((AbstractBeanDefinition) beanDefinition).validate();\n            }\n            catch (BeanDefinitionValidationException ex) {\n                throw new BeanDefinitionStoreException(\n                    beanDefinition.getResourceDescription(), beanName,\n                        \"Validation of bean definition failed\", ex);\n            }\n        }\n\n        BeanDefinition oldBeanDefinition;\n\n        // 从缓存中获取指定 beanName 的 BeanDefinition\n        oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n        /**\n         * 如果存在\n         */\n        if (oldBeanDefinition != null) {\n            // 如果存在但是不允许覆盖，抛出异常\n            if (!isAllowBeanDefinitionOverriding()) {\n                throw new BeanDefinitionStoreException(\n                    beanDefinition.getResourceDescription(), beanName,\n                        \"Cannot register bean definition [\" + beanDefinition\n                                         + \"] for bean '\" + beanName\n                      +\"': There is already [\" + oldBeanDefinition + \"] bound.\");\n            }\n            //根据bean的角色来判断这个BeanDefinition是否是用户自定义的，然后覆盖了系统定义的bean\n            // 在spring中bean的角色分为\n            //  0代表 apllication 用户自定义\n            //  1代表 support \t配置，起到支撑作用\n            //  2代表 infrastructure 系统运行过程中背后起到支撑的作用\n            else if (oldBeanDefinition.getRole() < beanDefinition.getRole()) {\n\n                if (this.logger.isWarnEnabled()) {\n                    this.logger.warn(\"Overriding user-defined bean definition\n                                     for bean '\" + beanName +\n                     \"' with a framework-generated bean definition: replacing [\" +\n                            oldBeanDefinition + \"] with [\" + beanDefinition + \"]\");\n                }\n            }\n            // 覆盖 beanDefinition 与 被覆盖的 beanDefinition 不是同类\n            else if (!beanDefinition.equals(oldBeanDefinition)) {\n                if (this.logger.isInfoEnabled()) {\n                    this.logger.info(\"Overriding bean definition for bean '\"+ beanName \n                      + \"' with a different definition: replacing [\"+oldBeanDefinition \n                                     +\"] with [\" + beanDefinition + \"]\");\n                }\n            }\n            else {\n                if (this.logger.isDebugEnabled()) {\n                    this.logger.debug(\"Overriding bean definition for bean '\" + \n                           beanName +\"' with an equivalent definition: replacing [\"\n                                      + oldBeanDefinition +\n                            \"] with [\" + beanDefinition + \"]\");\n                }\n            }\n\n            // 允许覆盖，直接覆盖原有的 BeanDefinition\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n        }\n        //  系统不存在相同的BeanDefinition\n        else {\n        // 检测创建 Bean 阶段是否已经开启，如果开启了则需要对 beanDefinitionMap 进行并发控制\n            if (hasBeanCreationStarted()) {\n                // beanDefinitionMap 为全局变量，避免并发情况\n                synchronized (this.beanDefinitionMap) {\n                    //\n                    this.beanDefinitionMap.put(beanName, beanDefinition);\n                    List<String> updatedDefinitions = \n                        new ArrayList<>(this.beanDefinitionNames.size() + 1);\n                    updatedDefinitions.addAll(this.beanDefinitionNames);\n                    updatedDefinitions.add(beanName);\n                    this.beanDefinitionNames = updatedDefinitions;\n                    if (this.manualSingletonNames.contains(beanName)) {\n                        Set<String> updatedSingletons = \n                            new LinkedHashSet<>(this.manualSingletonNames);\n                        updatedSingletons.remove(beanName);\n                        this.manualSingletonNames = updatedSingletons;\n                    }\n                }\n            }\n            else {\n                // 不会存在并发情况，直接设置\n                this.beanDefinitionMap.put(beanName, beanDefinition);\n                this.beanDefinitionNames.add(beanName);\n                this.manualSingletonNames.remove(beanName);\n            }\n            this.frozenBeanDefinitionNames = null;\n        }\n\n        if (oldBeanDefinition != null || containsSingleton(beanName)) {\n            // 重新设置 beanName 对应的缓存\n            resetBeanDefinition(beanName);\n        }\n    }\n```\n\n处理过程如下：\n\n- 首先 BeanDefinition 进行校验，该校验也是注册过程中的最后一次校验了，主要是对 AbstractBeanDefinition 的 methodOverrides 属性进行校验。其中有一点我在这里在说明一下**methodOverrides不能和工厂方法并存，是因为未实现methodOverrides需要使用使用动态代理来改变这个类，如果使用cglib，则需要修改字节码，如果使用了工厂方法，是直接返回bean，而动态代理是无法修改这个对象的**\n- 根据 beanName 从缓存中获取 BeanDefinition，如果缓存中存在，则根据 allowBeanDefinitionOverriding 标志来判断是否允许覆盖，如果允许则直接覆盖，否则抛出 BeanDefinitionStoreException 异常\n- 若缓存中没有指定 beanName 的 BeanDefinition，则判断当前阶段是否已经开始了 Bean 的创建阶段，如果是，则需要对 beanDefinitionMap 进行加锁控制并发问题，否则直接设置即可。对于 `hasBeanCreationStarted()` 方法后续做详细介绍，这里不过多阐述。\n- 若缓存中存在该 beanName 或者单例bean 集合中存在该 beanName，则调用 `resetBeanDefinition()` 重置 BeanDefinition 缓存。\n\n其实整段代码的核心就在于 `this.beanDefinitionMap.put(beanName, beanDefinition);` 。BeanDefinition 的缓存也不是神奇的东西，就是定义 map ，key 为 beanName，value 为 BeanDefinition。\n\n**注册 alias**\n\n`BeanDefinitionRegistry.registerAlias` 完成 alias 的注册。\n\n```java\n    public void registerAlias(String name, String alias) {\n        // 校验 name 、 alias\n        Assert.hasText(name, \"'name' must not be empty\");\n        Assert.hasText(alias, \"'alias' must not be empty\");\n        synchronized (this.aliasMap) {\n            // name == alias 则去掉alias\n            if (alias.equals(name)) {\n                this.aliasMap.remove(alias);\n            }\n            else {\n                // 缓存缓存记录\n                String registeredName = this.aliasMap.get(alias);\n                if (registeredName != null) {\n                    // 缓存中的相等，则直接返回\n                    if (registeredName.equals(name)) {\n                        // An existing alias - no need to re-register\n                        return;\n                    }\n                    // 不允许则抛出异常\n                    if (!allowAliasOverriding()) {\n                        throw new IllegalStateException(\"Cannot register alias '\"\n                                + alias + \"' for name '\" +name + \n                    \"': It is already registered for name '\" + registeredName + \"'.\");\n                    }\n                }\n                // 当 A --> B 存在时，如果再次出现 A --> C --> B 则抛出异常\n                checkForAliasCircle(name, alias);\n                // 注册 alias\n                this.aliasMap.put(alias, name);\n            }\n        }\n    }\n```\n\n注册 alias 和注册 BeanDefinition 的过程差不多。在最后调用了 `checkForAliasCircle()` 来对别名进行了检测。\n\n```java\n    public boolean hasAlias(String name, String alias) {\n        for (Map.Entry<String, String> entry : this.aliasMap.entrySet()) {\n            String registeredName = entry.getValue();\n            if (registeredName.equals(name)) {\n                String registeredAlias = entry.getKey();\n                return (registeredAlias.equals(alias) \n                        || hasAlias(registeredAlias, alias));\n            }\n        }\n        return false;\n    }\n```\n\n如果 name 、 alias 为 1 、3 ，则构成 （1,3），加入集合中存在（3,A）、（A,1）的情况则会出错。\n\n到此为止BeanDefinition已经注册完成，下一步就是初始化bean。","slug":"spring 源码分析/spring/spring源码解析之 14注册解析的BeanDefinition","published":1,"updated":"2019-01-15T03:36:58.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovwb004o9q1u7trrvn1x","content":"<h1 id=\"spring-源码解析之-14注册解析的BeanDefinition\"><a href=\"#spring-源码解析之-14注册解析的BeanDefinition\" class=\"headerlink\" title=\"spring 源码解析之 14注册解析的BeanDefinition\"></a>spring 源码解析之 14注册解析的BeanDefinition</h1><p><code>DefaultBeanDefinitionDocumentReader.processBeanDefinition()</code> 完成 Bean 标签解析的核心工作，如下：<br><a id=\"more\"></a></p>\n<pre><code class=\"java\">    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +\n                        bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n        }\n    }\n</code></pre>\n<p>解析工作分为三步：</p>\n<ol>\n<li>解析默认标签；</li>\n<li>解析默认标签中的自定义属性标签；</li>\n<li>注册解析后的 BeanDefinition。</li>\n</ol>\n<p>经过前面两个步骤的解析，这时的 BeanDefinition 已经可以满足后续的使用要求了，那么接下来的工作就是将这些 BeanDefinition 进行注册，也就是完成第三步。</p>\n<p>注册 BeanDefinition 由 <code>BeanDefinitionReaderUtils.registerBeanDefinition()</code> 完成。如下：</p>\n<pre><code class=\"java\">    public static void registerBeanDefinition(\n            BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n            throws BeanDefinitionStoreException {\n\n        // 注册 beanName\n        String beanName = definitionHolder.getBeanName();\n        registry.registerBeanDefinition(beanName, \n                                        definitionHolder.getBeanDefinition());\n\n        // 注册 alias \n        String[] aliases = definitionHolder.getAliases();\n        if (aliases != null) {\n            for (String alias : aliases) {\n                registry.registerAlias(beanName, alias);\n            }\n        }\n    }\n</code></pre>\n<p>首先通过 beanName 注册 BeanDefinition ，然后再注册别名 alias。BeanDefinition 的注册由接口 BeanDefinitionRegistry 定义。</p>\n<h3 id=\"通过-beanName-注册\"><a href=\"#通过-beanName-注册\" class=\"headerlink\" title=\"通过 beanName 注册\"></a><strong>通过 beanName 注册</strong></h3><p><code>BeanDefinitionRegistry.registerBeanDefinition()</code> 实现通过 beanName 注册 BeanDefinition，如下：</p>\n<pre><code class=\"java\">   public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n            throws BeanDefinitionStoreException {\n\n        // 校验 beanName 与 beanDefinition\n        Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);\n        Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);\n\n        if (beanDefinition instanceof AbstractBeanDefinition) {\n            try {\n                // 校验 BeanDefinition\n                // 这是注册前的最后一次校验了，主要是对属性 methodOverrides 进行校验\n                // 校验methodOverride是否与工厂方法并存或者methodOverrides对应的方法根本不存在\n                ((AbstractBeanDefinition) beanDefinition).validate();\n            }\n            catch (BeanDefinitionValidationException ex) {\n                throw new BeanDefinitionStoreException(\n                    beanDefinition.getResourceDescription(), beanName,\n                        &quot;Validation of bean definition failed&quot;, ex);\n            }\n        }\n\n        BeanDefinition oldBeanDefinition;\n\n        // 从缓存中获取指定 beanName 的 BeanDefinition\n        oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n        /**\n         * 如果存在\n         */\n        if (oldBeanDefinition != null) {\n            // 如果存在但是不允许覆盖，抛出异常\n            if (!isAllowBeanDefinitionOverriding()) {\n                throw new BeanDefinitionStoreException(\n                    beanDefinition.getResourceDescription(), beanName,\n                        &quot;Cannot register bean definition [&quot; + beanDefinition\n                                         + &quot;] for bean &#39;&quot; + beanName\n                      +&quot;&#39;: There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);\n            }\n            //根据bean的角色来判断这个BeanDefinition是否是用户自定义的，然后覆盖了系统定义的bean\n            // 在spring中bean的角色分为\n            //  0代表 apllication 用户自定义\n            //  1代表 support     配置，起到支撑作用\n            //  2代表 infrastructure 系统运行过程中背后起到支撑的作用\n            else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) {\n\n                if (this.logger.isWarnEnabled()) {\n                    this.logger.warn(&quot;Overriding user-defined bean definition\n                                     for bean &#39;&quot; + beanName +\n                     &quot;&#39; with a framework-generated bean definition: replacing [&quot; +\n                            oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);\n                }\n            }\n            // 覆盖 beanDefinition 与 被覆盖的 beanDefinition 不是同类\n            else if (!beanDefinition.equals(oldBeanDefinition)) {\n                if (this.logger.isInfoEnabled()) {\n                    this.logger.info(&quot;Overriding bean definition for bean &#39;&quot;+ beanName \n                      + &quot;&#39; with a different definition: replacing [&quot;+oldBeanDefinition \n                                     +&quot;] with [&quot; + beanDefinition + &quot;]&quot;);\n                }\n            }\n            else {\n                if (this.logger.isDebugEnabled()) {\n                    this.logger.debug(&quot;Overriding bean definition for bean &#39;&quot; + \n                           beanName +&quot;&#39; with an equivalent definition: replacing [&quot;\n                                      + oldBeanDefinition +\n                            &quot;] with [&quot; + beanDefinition + &quot;]&quot;);\n                }\n            }\n\n            // 允许覆盖，直接覆盖原有的 BeanDefinition\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n        }\n        //  系统不存在相同的BeanDefinition\n        else {\n        // 检测创建 Bean 阶段是否已经开启，如果开启了则需要对 beanDefinitionMap 进行并发控制\n            if (hasBeanCreationStarted()) {\n                // beanDefinitionMap 为全局变量，避免并发情况\n                synchronized (this.beanDefinitionMap) {\n                    //\n                    this.beanDefinitionMap.put(beanName, beanDefinition);\n                    List&lt;String&gt; updatedDefinitions = \n                        new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);\n                    updatedDefinitions.addAll(this.beanDefinitionNames);\n                    updatedDefinitions.add(beanName);\n                    this.beanDefinitionNames = updatedDefinitions;\n                    if (this.manualSingletonNames.contains(beanName)) {\n                        Set&lt;String&gt; updatedSingletons = \n                            new LinkedHashSet&lt;&gt;(this.manualSingletonNames);\n                        updatedSingletons.remove(beanName);\n                        this.manualSingletonNames = updatedSingletons;\n                    }\n                }\n            }\n            else {\n                // 不会存在并发情况，直接设置\n                this.beanDefinitionMap.put(beanName, beanDefinition);\n                this.beanDefinitionNames.add(beanName);\n                this.manualSingletonNames.remove(beanName);\n            }\n            this.frozenBeanDefinitionNames = null;\n        }\n\n        if (oldBeanDefinition != null || containsSingleton(beanName)) {\n            // 重新设置 beanName 对应的缓存\n            resetBeanDefinition(beanName);\n        }\n    }\n</code></pre>\n<p>处理过程如下：</p>\n<ul>\n<li>首先 BeanDefinition 进行校验，该校验也是注册过程中的最后一次校验了，主要是对 AbstractBeanDefinition 的 methodOverrides 属性进行校验。其中有一点我在这里在说明一下<strong>methodOverrides不能和工厂方法并存，是因为未实现methodOverrides需要使用使用动态代理来改变这个类，如果使用cglib，则需要修改字节码，如果使用了工厂方法，是直接返回bean，而动态代理是无法修改这个对象的</strong></li>\n<li>根据 beanName 从缓存中获取 BeanDefinition，如果缓存中存在，则根据 allowBeanDefinitionOverriding 标志来判断是否允许覆盖，如果允许则直接覆盖，否则抛出 BeanDefinitionStoreException 异常</li>\n<li>若缓存中没有指定 beanName 的 BeanDefinition，则判断当前阶段是否已经开始了 Bean 的创建阶段，如果是，则需要对 beanDefinitionMap 进行加锁控制并发问题，否则直接设置即可。对于 <code>hasBeanCreationStarted()</code> 方法后续做详细介绍，这里不过多阐述。</li>\n<li>若缓存中存在该 beanName 或者单例bean 集合中存在该 beanName，则调用 <code>resetBeanDefinition()</code> 重置 BeanDefinition 缓存。</li>\n</ul>\n<p>其实整段代码的核心就在于 <code>this.beanDefinitionMap.put(beanName, beanDefinition);</code> 。BeanDefinition 的缓存也不是神奇的东西，就是定义 map ，key 为 beanName，value 为 BeanDefinition。</p>\n<p><strong>注册 alias</strong></p>\n<p><code>BeanDefinitionRegistry.registerAlias</code> 完成 alias 的注册。</p>\n<pre><code class=\"java\">    public void registerAlias(String name, String alias) {\n        // 校验 name 、 alias\n        Assert.hasText(name, &quot;&#39;name&#39; must not be empty&quot;);\n        Assert.hasText(alias, &quot;&#39;alias&#39; must not be empty&quot;);\n        synchronized (this.aliasMap) {\n            // name == alias 则去掉alias\n            if (alias.equals(name)) {\n                this.aliasMap.remove(alias);\n            }\n            else {\n                // 缓存缓存记录\n                String registeredName = this.aliasMap.get(alias);\n                if (registeredName != null) {\n                    // 缓存中的相等，则直接返回\n                    if (registeredName.equals(name)) {\n                        // An existing alias - no need to re-register\n                        return;\n                    }\n                    // 不允许则抛出异常\n                    if (!allowAliasOverriding()) {\n                        throw new IllegalStateException(&quot;Cannot register alias &#39;&quot;\n                                + alias + &quot;&#39; for name &#39;&quot; +name + \n                    &quot;&#39;: It is already registered for name &#39;&quot; + registeredName + &quot;&#39;.&quot;);\n                    }\n                }\n                // 当 A --&gt; B 存在时，如果再次出现 A --&gt; C --&gt; B 则抛出异常\n                checkForAliasCircle(name, alias);\n                // 注册 alias\n                this.aliasMap.put(alias, name);\n            }\n        }\n    }\n</code></pre>\n<p>注册 alias 和注册 BeanDefinition 的过程差不多。在最后调用了 <code>checkForAliasCircle()</code> 来对别名进行了检测。</p>\n<pre><code class=\"java\">    public boolean hasAlias(String name, String alias) {\n        for (Map.Entry&lt;String, String&gt; entry : this.aliasMap.entrySet()) {\n            String registeredName = entry.getValue();\n            if (registeredName.equals(name)) {\n                String registeredAlias = entry.getKey();\n                return (registeredAlias.equals(alias) \n                        || hasAlias(registeredAlias, alias));\n            }\n        }\n        return false;\n    }\n</code></pre>\n<p>如果 name 、 alias 为 1 、3 ，则构成 （1,3），加入集合中存在（3,A）、（A,1）的情况则会出错。</p>\n<p>到此为止BeanDefinition已经注册完成，下一步就是初始化bean。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring-源码解析之-14注册解析的BeanDefinition\"><a href=\"#spring-源码解析之-14注册解析的BeanDefinition\" class=\"headerlink\" title=\"spring 源码解析之 14注册解析的BeanDefinition\"></a>spring 源码解析之 14注册解析的BeanDefinition</h1><p><code>DefaultBeanDefinitionDocumentReader.processBeanDefinition()</code> 完成 Bean 标签解析的核心工作，如下：<br>","more":"</p>\n<pre><code class=\"java\">    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +\n                        bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n        }\n    }\n</code></pre>\n<p>解析工作分为三步：</p>\n<ol>\n<li>解析默认标签；</li>\n<li>解析默认标签中的自定义属性标签；</li>\n<li>注册解析后的 BeanDefinition。</li>\n</ol>\n<p>经过前面两个步骤的解析，这时的 BeanDefinition 已经可以满足后续的使用要求了，那么接下来的工作就是将这些 BeanDefinition 进行注册，也就是完成第三步。</p>\n<p>注册 BeanDefinition 由 <code>BeanDefinitionReaderUtils.registerBeanDefinition()</code> 完成。如下：</p>\n<pre><code class=\"java\">    public static void registerBeanDefinition(\n            BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n            throws BeanDefinitionStoreException {\n\n        // 注册 beanName\n        String beanName = definitionHolder.getBeanName();\n        registry.registerBeanDefinition(beanName, \n                                        definitionHolder.getBeanDefinition());\n\n        // 注册 alias \n        String[] aliases = definitionHolder.getAliases();\n        if (aliases != null) {\n            for (String alias : aliases) {\n                registry.registerAlias(beanName, alias);\n            }\n        }\n    }\n</code></pre>\n<p>首先通过 beanName 注册 BeanDefinition ，然后再注册别名 alias。BeanDefinition 的注册由接口 BeanDefinitionRegistry 定义。</p>\n<h3 id=\"通过-beanName-注册\"><a href=\"#通过-beanName-注册\" class=\"headerlink\" title=\"通过 beanName 注册\"></a><strong>通过 beanName 注册</strong></h3><p><code>BeanDefinitionRegistry.registerBeanDefinition()</code> 实现通过 beanName 注册 BeanDefinition，如下：</p>\n<pre><code class=\"java\">   public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n            throws BeanDefinitionStoreException {\n\n        // 校验 beanName 与 beanDefinition\n        Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);\n        Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);\n\n        if (beanDefinition instanceof AbstractBeanDefinition) {\n            try {\n                // 校验 BeanDefinition\n                // 这是注册前的最后一次校验了，主要是对属性 methodOverrides 进行校验\n                // 校验methodOverride是否与工厂方法并存或者methodOverrides对应的方法根本不存在\n                ((AbstractBeanDefinition) beanDefinition).validate();\n            }\n            catch (BeanDefinitionValidationException ex) {\n                throw new BeanDefinitionStoreException(\n                    beanDefinition.getResourceDescription(), beanName,\n                        &quot;Validation of bean definition failed&quot;, ex);\n            }\n        }\n\n        BeanDefinition oldBeanDefinition;\n\n        // 从缓存中获取指定 beanName 的 BeanDefinition\n        oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n        /**\n         * 如果存在\n         */\n        if (oldBeanDefinition != null) {\n            // 如果存在但是不允许覆盖，抛出异常\n            if (!isAllowBeanDefinitionOverriding()) {\n                throw new BeanDefinitionStoreException(\n                    beanDefinition.getResourceDescription(), beanName,\n                        &quot;Cannot register bean definition [&quot; + beanDefinition\n                                         + &quot;] for bean &#39;&quot; + beanName\n                      +&quot;&#39;: There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);\n            }\n            //根据bean的角色来判断这个BeanDefinition是否是用户自定义的，然后覆盖了系统定义的bean\n            // 在spring中bean的角色分为\n            //  0代表 apllication 用户自定义\n            //  1代表 support     配置，起到支撑作用\n            //  2代表 infrastructure 系统运行过程中背后起到支撑的作用\n            else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) {\n\n                if (this.logger.isWarnEnabled()) {\n                    this.logger.warn(&quot;Overriding user-defined bean definition\n                                     for bean &#39;&quot; + beanName +\n                     &quot;&#39; with a framework-generated bean definition: replacing [&quot; +\n                            oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);\n                }\n            }\n            // 覆盖 beanDefinition 与 被覆盖的 beanDefinition 不是同类\n            else if (!beanDefinition.equals(oldBeanDefinition)) {\n                if (this.logger.isInfoEnabled()) {\n                    this.logger.info(&quot;Overriding bean definition for bean &#39;&quot;+ beanName \n                      + &quot;&#39; with a different definition: replacing [&quot;+oldBeanDefinition \n                                     +&quot;] with [&quot; + beanDefinition + &quot;]&quot;);\n                }\n            }\n            else {\n                if (this.logger.isDebugEnabled()) {\n                    this.logger.debug(&quot;Overriding bean definition for bean &#39;&quot; + \n                           beanName +&quot;&#39; with an equivalent definition: replacing [&quot;\n                                      + oldBeanDefinition +\n                            &quot;] with [&quot; + beanDefinition + &quot;]&quot;);\n                }\n            }\n\n            // 允许覆盖，直接覆盖原有的 BeanDefinition\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n        }\n        //  系统不存在相同的BeanDefinition\n        else {\n        // 检测创建 Bean 阶段是否已经开启，如果开启了则需要对 beanDefinitionMap 进行并发控制\n            if (hasBeanCreationStarted()) {\n                // beanDefinitionMap 为全局变量，避免并发情况\n                synchronized (this.beanDefinitionMap) {\n                    //\n                    this.beanDefinitionMap.put(beanName, beanDefinition);\n                    List&lt;String&gt; updatedDefinitions = \n                        new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);\n                    updatedDefinitions.addAll(this.beanDefinitionNames);\n                    updatedDefinitions.add(beanName);\n                    this.beanDefinitionNames = updatedDefinitions;\n                    if (this.manualSingletonNames.contains(beanName)) {\n                        Set&lt;String&gt; updatedSingletons = \n                            new LinkedHashSet&lt;&gt;(this.manualSingletonNames);\n                        updatedSingletons.remove(beanName);\n                        this.manualSingletonNames = updatedSingletons;\n                    }\n                }\n            }\n            else {\n                // 不会存在并发情况，直接设置\n                this.beanDefinitionMap.put(beanName, beanDefinition);\n                this.beanDefinitionNames.add(beanName);\n                this.manualSingletonNames.remove(beanName);\n            }\n            this.frozenBeanDefinitionNames = null;\n        }\n\n        if (oldBeanDefinition != null || containsSingleton(beanName)) {\n            // 重新设置 beanName 对应的缓存\n            resetBeanDefinition(beanName);\n        }\n    }\n</code></pre>\n<p>处理过程如下：</p>\n<ul>\n<li>首先 BeanDefinition 进行校验，该校验也是注册过程中的最后一次校验了，主要是对 AbstractBeanDefinition 的 methodOverrides 属性进行校验。其中有一点我在这里在说明一下<strong>methodOverrides不能和工厂方法并存，是因为未实现methodOverrides需要使用使用动态代理来改变这个类，如果使用cglib，则需要修改字节码，如果使用了工厂方法，是直接返回bean，而动态代理是无法修改这个对象的</strong></li>\n<li>根据 beanName 从缓存中获取 BeanDefinition，如果缓存中存在，则根据 allowBeanDefinitionOverriding 标志来判断是否允许覆盖，如果允许则直接覆盖，否则抛出 BeanDefinitionStoreException 异常</li>\n<li>若缓存中没有指定 beanName 的 BeanDefinition，则判断当前阶段是否已经开始了 Bean 的创建阶段，如果是，则需要对 beanDefinitionMap 进行加锁控制并发问题，否则直接设置即可。对于 <code>hasBeanCreationStarted()</code> 方法后续做详细介绍，这里不过多阐述。</li>\n<li>若缓存中存在该 beanName 或者单例bean 集合中存在该 beanName，则调用 <code>resetBeanDefinition()</code> 重置 BeanDefinition 缓存。</li>\n</ul>\n<p>其实整段代码的核心就在于 <code>this.beanDefinitionMap.put(beanName, beanDefinition);</code> 。BeanDefinition 的缓存也不是神奇的东西，就是定义 map ，key 为 beanName，value 为 BeanDefinition。</p>\n<p><strong>注册 alias</strong></p>\n<p><code>BeanDefinitionRegistry.registerAlias</code> 完成 alias 的注册。</p>\n<pre><code class=\"java\">    public void registerAlias(String name, String alias) {\n        // 校验 name 、 alias\n        Assert.hasText(name, &quot;&#39;name&#39; must not be empty&quot;);\n        Assert.hasText(alias, &quot;&#39;alias&#39; must not be empty&quot;);\n        synchronized (this.aliasMap) {\n            // name == alias 则去掉alias\n            if (alias.equals(name)) {\n                this.aliasMap.remove(alias);\n            }\n            else {\n                // 缓存缓存记录\n                String registeredName = this.aliasMap.get(alias);\n                if (registeredName != null) {\n                    // 缓存中的相等，则直接返回\n                    if (registeredName.equals(name)) {\n                        // An existing alias - no need to re-register\n                        return;\n                    }\n                    // 不允许则抛出异常\n                    if (!allowAliasOverriding()) {\n                        throw new IllegalStateException(&quot;Cannot register alias &#39;&quot;\n                                + alias + &quot;&#39; for name &#39;&quot; +name + \n                    &quot;&#39;: It is already registered for name &#39;&quot; + registeredName + &quot;&#39;.&quot;);\n                    }\n                }\n                // 当 A --&gt; B 存在时，如果再次出现 A --&gt; C --&gt; B 则抛出异常\n                checkForAliasCircle(name, alias);\n                // 注册 alias\n                this.aliasMap.put(alias, name);\n            }\n        }\n    }\n</code></pre>\n<p>注册 alias 和注册 BeanDefinition 的过程差不多。在最后调用了 <code>checkForAliasCircle()</code> 来对别名进行了检测。</p>\n<pre><code class=\"java\">    public boolean hasAlias(String name, String alias) {\n        for (Map.Entry&lt;String, String&gt; entry : this.aliasMap.entrySet()) {\n            String registeredName = entry.getValue();\n            if (registeredName.equals(name)) {\n                String registeredAlias = entry.getKey();\n                return (registeredAlias.equals(alias) \n                        || hasAlias(registeredAlias, alias));\n            }\n        }\n        return false;\n    }\n</code></pre>\n<p>如果 name 、 alias 为 1 、3 ，则构成 （1,3），加入集合中存在（3,A）、（A,1）的情况则会出错。</p>\n<p>到此为止BeanDefinition已经注册完成，下一步就是初始化bean。</p>"},{"abbrlink":37,"title":"spring源码解析之 18parentBeanFactory 与依赖处理","author":"fengxiutianya","date":"2019-01-14T19:32:00.000Z","_content":"# spring源码解析之 18parentBeanFactory 与依赖处理\n\n从上篇文章中我们可以得知，如果从单例缓存中没有获取到单例 bean，则说明两种情况：\n\n1. 该 bean 的 scope 不是 singleton\n2. 该 bean 的 scope 是 singleton ,但是没有初始化完成\n\n本篇文章就来进行这部分的分析，不过将这部分分为俩篇博客来分析，这里先讲检测、parentBeanFactory与依赖处理，剩下的scope处理，主要在下一篇文章中讲解，本文所分析的具体源码如下：\n<!-- more -->\n\n```java\n\t\t\t/**\n\t\t\t * 只有个在单例情况下才会尝试解决循环依赖，原型模式情况下，\n\t\t\t * 如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，\n\t\t\t * 就会产生当A还未创建完的时候因为B的创建在此返回创建A，造成\n\t\t\t * 循环依赖，也就是下面这种情况\n\t\t\t */\n\t\t\tif (isPrototypeCurrentlyInCreation(beanName)) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName);\n\t\t\t}\n\n\t\t\t// 如果beanDefinitionMap中也就是在所有已加载的类中不包括beanName\n\t\t\t// 则会尝试从parentBeanFactory中检测\n\t\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\t\t// containsBeanDefinition 用于检测当前BeanFactory\n\t\t\t// 是否包含beanName的BeanDefinition\n\t\t\tif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n\t\t\t\t// 递归到BeanFactory中寻找,这点和下面的创建过程大体类型，只不过委托给父类来查找\n\t\t\t\tString nameToLookup = originalBeanName(name);\n\t\t\t\tif (parentBeanFactory instanceof AbstractBeanFactory) {\n\t\t\t\t\treturn ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n\t\t\t\t\t\t\tnameToLookup, requiredType, args, typeCheckOnly);\n\t\t\t\t} else if (args != null) {\n                    // 带有args的处理\n\t\t\t\t\t// Delegation to parent with explicit args.\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup, args);\n\t\t\t\t} else if (requiredType != null) {\n\t\t\t\t\t// 带有特定类型的处理\n\t\t\t\t\treturn parentBeanFactory.getBean(nameToLookup, requiredType);\n\t\t\t\t} else {\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 如果不是仅仅做类型检查则是创建bean，这里要进行记录\n\t\t\tif (!typeCheckOnly) {\n\t\t\t\tmarkBeanAsCreated(beanName);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// 将存储xml配置文件的GernericBeanDefinition转换为RootBeanDefinition\n\t\t\t\t// 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n\t\t\t\tfinal RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\tcheckMergedBeanDefinition(mbd, beanName, args);\n\n\t\t\t\t// 若存在依赖则需要递归实例化依赖的bean\n\t\t\t\t// 这里的getDependsOn返回的是对应bean属性depend-on设置的值\n\t\t\t\tString[] dependsOn = mbd.getDependsOn();\n\t\t\t\tif (dependsOn != null) {\n\t\t\t\t\tfor (String dep : dependsOn) {\n\t\t\t\t\t\tif (isDependent(beanName, dep)) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(\n                                mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"Circular depends-on relationship between '\" \n                                    + beanName + \"' and '\" + dep + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 缓存依赖调用\n\t\t\t\t\t\tregisterDependentBean(dep, beanName);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tgetBean(dep);\n\t\t\t\t\t\t} catch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(\n                                mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"'\" + beanName + \"' depends on missing bean '\" \n                                \t+ dep + \"'\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n```\n\n这段代码主要处理如下几个部分：\n\n1. 检测当前bean的scope是否是Prototype。如果是并且存在循环依赖则抛出 BeanCurrentlyInCreationException 异常。\n2. 如果 beanDefinitionMap 中不存在 beanName 的 BeanDefinition（即在 Spring bean 初始化过程中没有加载），则尝试从 parentBeanFactory 中加载。\n3. 判断是否为类型检查。\n4. 从 mergedBeanDefinitions 中获取 beanName 对应的 RootBeanDefinition，如果这个 BeanDefinition 是子 Bean 的话，则会合并父类的相关属性。\n5. 依赖处理。\n\n**检测当前bean是否是Prototype类型的循环依赖**\n\n在前面就提过，Spring 只解决单例模式下的循环依赖，对于原型模式的循环依赖则是抛出 BeanCurrentlyInCreationException 异常，所以首先检查该 beanName 是否处于原型模式下的循环依赖。如下：\n\n```java\nif (isPrototypeCurrentlyInCreation(beanName)) {\n    throw new BeanCurrentlyInCreationException(beanName);\n}\n```\n\n调用 `isPrototypeCurrentlyInCreation()` 判断当前 bean 是否正在创建，如下：\n\n```java\n    protected boolean isPrototypeCurrentlyInCreation(String beanName) {\n        Object curVal = this.prototypesCurrentlyInCreation.get();\n        return (curVal != null &&\n                (curVal.equals(beanName) || \n                 (curVal instanceof Set && ((Set<?>) curVal).contains(beanName))));\n    }\n```\n\n其实检测逻辑和单例模式一样，一个“集合”存放着正在创建的 bean，从该集合中进行判断即可，只不过单例模式的“集合”为 Set ，而原型模式的则是 ThreadLocal，prototypesCurrentlyInCreation 定义如下：\n\n```java\n    private final ThreadLocal<Object> prototypesCurrentlyInCreation = \n        new NamedThreadLocal<>(\"Prototype beans currently in creation\");\n```\n\n**检查父类 BeanFactory**\n\n若 containsBeanDefinition 中不存在 beanName 相对应的 BeanDefinition，则从 parentBeanFactory 中获取。\n\n```java\n    // 获取 parentBeanFactory\n    BeanFactory parentBeanFactory = getParentBeanFactory();\n    // parentBeanFactory 不为空且 beanDefinitionMap 中不存该 name 的 BeanDefinition\n    if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n        // 确定原始 beanName\n        String nameToLookup = originalBeanName(name);\n        // 若为 AbstractBeanFactory 类型，委托父类处理\n        if (parentBeanFactory instanceof AbstractBeanFactory) {\n            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                    nameToLookup, requiredType, args, typeCheckOnly);\n        }\n        else if (args != null) {\n            // 委托给构造函数 getBean() 处理\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n        }\n        else {\n            // 没有 args，委托给标准的 getBean() 处理\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n        }\n    }\n```\n\n整个过程较为简单，都是委托 parentBeanFactory 的 `getBean()` 进行处理，只不过在获取之前对 name 进行简单的处理，主要是想获取原始的 beanName，如下：\n\n```java\n    protected String originalBeanName(String name) {\n        String beanName = transformedBeanName(name);\n        if (name.startsWith(FACTORY_BEAN_PREFIX)) {\n            beanName = FACTORY_BEAN_PREFIX + beanName;\n        }\n        return beanName;\n    }\n```\n\n`transformedBeanName()` 是对 name 进行转换，获取真正的 beanName，因为我们传递的可能是 aliasName（这个过程在上一篇博客中分析 `transformedBeanName()` 有详细说明），如果 name 是以 “&” 开头的，则加上 “&”，因为在 `transformedBeanName()` 将 “&” 去掉了，这里补上。\n\n**类型检查**\n\n参数 typeCheckOnly 是用来判断调用 `getBean()` 是否为类型检查获取 bean。如果不是仅仅做类型检查则是创建bean，则需要调用 `markBeanAsCreated()` 记录：\n\n```java\n     protected void markBeanAsCreated(String beanName) {\n        // 没有创建\n        if (!this.alreadyCreated.contains(beanName)) {\n            // 加上全局锁\n            synchronized (this.mergedBeanDefinitions) {\n                // 再次检查一次：DCL 双检查模式\n                if (!this.alreadyCreated.contains(beanName)) {\n                    // 从 mergedBeanDefinitions 中删除 beanName，\n                    // 并在下次访问时重新创建它。\n                    clearMergedBeanDefinition(beanName);\n                    // 添加到已创建bean 集合中\n                    this.alreadyCreated.add(beanName);\n                }\n            }\n        }\n    }\n```\n\n**获取 RootBeanDefinition**\n\n```java\nfinal RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n```\n\n调用 `getMergedLocalBeanDefinition()` 获取相对应的 BeanDefinition，如下：\n\n```java\n    protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException {\n        // 快速从缓存中获取，如果不为空，则直接返回\n        RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName);\n        if (mbd != null) {\n            return mbd;\n        }\n        // 获取 RootBeanDefinition，\n        // 如果返回的 BeanDefinition 是子类 bean 的话，则合并父类相关属性\n        return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));\n    }\n```\n\n首先直接从 mergedBeanDefinitions 缓存中获取相应的 RootBeanDefinition，如果存在则直接返回否则调用 `getMergedBeanDefinition()` 获取 RootBeanDefinition，若获取的 BeanDefinition 为子 BeanDefinition，则需要合并父类的相关属性。\n\n**处理依赖**\n\n如果一个 bean 有依赖 bean 的话，那么在初始化该 bean 时是需要先初始化它所依赖的 bean。\n\n```java\n\t // 获取依赖。\n\t // 在初始化 bean 时解析 depends-on 标签时设置\n     String[] dependsOn = mbd.getDependsOn();\n     if (dependsOn != null) {\n        // 迭代依赖\n        for (String dep : dependsOn) {\n            // 检验依赖的bean 是否已经注册给当前 bean 获取其他传递依赖bean\n            if (isDependent(beanName, dep)) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Circular depends-on relationship between '\" \n                                                + beanName + \"' and '\" + dep + \"'\");\n            }\n            // 注册到依赖bean中\n            registerDependentBean(dep, beanName);\n            try {\n                // 调用 getBean 初始化依赖bean\n                getBean(dep);\n            }\n            catch (NoSuchBeanDefinitionException ex) {\n                throw new BeanCreationException(mbd.getResourceDescription(),\n                                                beanName, \"'\" + beanName \n                              + \"' depends on missing bean '\" + dep + \"'\", ex);\n            }\n        }\n    }\n```\n\n这段代码逻辑是：通过迭代的方式依次对依赖 bean 进行检测、校验，如果通过则调用 `getBean()` 实例化依赖 bean。\n\n`isDependent()` 是校验该依赖是否已经注册给当前 bean。\n\n```java\n    protected boolean isDependent(String beanName, String dependentBeanName) {\n        synchronized (this.dependentBeanMap) {\n            return isDependent(beanName, dependentBeanName, null);\n        }\n    }\n```\n\n同步加锁给 dependentBeanMap 对象，然后调用 `isDependent()` 校验。dependentBeanMap 对象保存的是依赖 beanName 之间的映射关系：beanName – > 依赖 beanName 的集合\n\n```java\n    private boolean isDependent(String beanName, String dependentBeanName,\n                                @Nullable Set<String> alreadySeen) {\n\n        // alreadySeen 已经检测的依赖 bean\n        if (alreadySeen != null && alreadySeen.contains(beanName)) {\n            return false;\n        }\n        // 获取原始 beanName\n        String canonicalName = canonicalName(beanName);\n        // 获取当前 beanName 的依赖集合\n        Set<String> dependentBeans = this.dependentBeanMap.get(canonicalName);\n        // 不存在依赖，返回false\n        if (dependentBeans == null) {\n            return false;\n        }\n        // 存在，则证明存在已经注册的依赖\n        if (dependentBeans.contains(dependentBeanName)) {\n            return true;\n        }\n        // 递归检测依赖\n        for (String transitiveDependency : dependentBeans) {\n            if (alreadySeen == null) {\n                alreadySeen = new HashSet<>();\n            }\n            alreadySeen.add(beanName);\n            if (isDependent(transitiveDependency, dependentBeanName, alreadySeen)) {\n                return true;\n            }\n        }\n        return false;\n    }\n```\n\n如果校验成功，则调用 `registerDependentBean()` 将该依赖进行注册，便于在销毁 bean 之前对其进行销毁。\n\n```java\n    public void registerDependentBean(String beanName, String dependentBeanName) {\n        String canonicalName = canonicalName(beanName);\n\n        synchronized (this.dependentBeanMap) {\n            Set<String> dependentBeans =\n                    this.dependentBeanMap.computeIfAbsent(canonicalName, \n                                                          k -> new LinkedHashSet<>(8));\n            if (!dependentBeans.add(dependentBeanName)) {\n                return;\n            }\n        }\n\n        synchronized (this.dependenciesForBeanMap) {\n            Set<String> dependenciesForBean =\n                    this.dependenciesForBeanMap.computeIfAbsent(dependentBeanName,\n                                           k -> new LinkedHashSet<>(8));\n            dependenciesForBean.add(canonicalName);\n        }\n    }\n```\n\n其实将就是该映射关系保存到两个集合中：dependentBeanMap、dependenciesForBeanMap。\n\n最后调用 `getBean()` 实例化依赖 bean。\n\n至此，加载 bean 的第二个部分也分析完毕了，下篇开始分析第三个部分：各大作用域 bean 的处理","source":"_posts/spring 源码分析/spring/spring源码解析之 18parentBeanFactory 与依赖处理.md","raw":"abbrlink: 37\ntitle: spring源码解析之 18parentBeanFactory 与依赖处理\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-15 03:32:00\n---\n# spring源码解析之 18parentBeanFactory 与依赖处理\n\n从上篇文章中我们可以得知，如果从单例缓存中没有获取到单例 bean，则说明两种情况：\n\n1. 该 bean 的 scope 不是 singleton\n2. 该 bean 的 scope 是 singleton ,但是没有初始化完成\n\n本篇文章就来进行这部分的分析，不过将这部分分为俩篇博客来分析，这里先讲检测、parentBeanFactory与依赖处理，剩下的scope处理，主要在下一篇文章中讲解，本文所分析的具体源码如下：\n<!-- more -->\n\n```java\n\t\t\t/**\n\t\t\t * 只有个在单例情况下才会尝试解决循环依赖，原型模式情况下，\n\t\t\t * 如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，\n\t\t\t * 就会产生当A还未创建完的时候因为B的创建在此返回创建A，造成\n\t\t\t * 循环依赖，也就是下面这种情况\n\t\t\t */\n\t\t\tif (isPrototypeCurrentlyInCreation(beanName)) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName);\n\t\t\t}\n\n\t\t\t// 如果beanDefinitionMap中也就是在所有已加载的类中不包括beanName\n\t\t\t// 则会尝试从parentBeanFactory中检测\n\t\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\t\t// containsBeanDefinition 用于检测当前BeanFactory\n\t\t\t// 是否包含beanName的BeanDefinition\n\t\t\tif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n\t\t\t\t// 递归到BeanFactory中寻找,这点和下面的创建过程大体类型，只不过委托给父类来查找\n\t\t\t\tString nameToLookup = originalBeanName(name);\n\t\t\t\tif (parentBeanFactory instanceof AbstractBeanFactory) {\n\t\t\t\t\treturn ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n\t\t\t\t\t\t\tnameToLookup, requiredType, args, typeCheckOnly);\n\t\t\t\t} else if (args != null) {\n                    // 带有args的处理\n\t\t\t\t\t// Delegation to parent with explicit args.\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup, args);\n\t\t\t\t} else if (requiredType != null) {\n\t\t\t\t\t// 带有特定类型的处理\n\t\t\t\t\treturn parentBeanFactory.getBean(nameToLookup, requiredType);\n\t\t\t\t} else {\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 如果不是仅仅做类型检查则是创建bean，这里要进行记录\n\t\t\tif (!typeCheckOnly) {\n\t\t\t\tmarkBeanAsCreated(beanName);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// 将存储xml配置文件的GernericBeanDefinition转换为RootBeanDefinition\n\t\t\t\t// 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n\t\t\t\tfinal RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\tcheckMergedBeanDefinition(mbd, beanName, args);\n\n\t\t\t\t// 若存在依赖则需要递归实例化依赖的bean\n\t\t\t\t// 这里的getDependsOn返回的是对应bean属性depend-on设置的值\n\t\t\t\tString[] dependsOn = mbd.getDependsOn();\n\t\t\t\tif (dependsOn != null) {\n\t\t\t\t\tfor (String dep : dependsOn) {\n\t\t\t\t\t\tif (isDependent(beanName, dep)) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(\n                                mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"Circular depends-on relationship between '\" \n                                    + beanName + \"' and '\" + dep + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 缓存依赖调用\n\t\t\t\t\t\tregisterDependentBean(dep, beanName);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tgetBean(dep);\n\t\t\t\t\t\t} catch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(\n                                mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"'\" + beanName + \"' depends on missing bean '\" \n                                \t+ dep + \"'\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n```\n\n这段代码主要处理如下几个部分：\n\n1. 检测当前bean的scope是否是Prototype。如果是并且存在循环依赖则抛出 BeanCurrentlyInCreationException 异常。\n2. 如果 beanDefinitionMap 中不存在 beanName 的 BeanDefinition（即在 Spring bean 初始化过程中没有加载），则尝试从 parentBeanFactory 中加载。\n3. 判断是否为类型检查。\n4. 从 mergedBeanDefinitions 中获取 beanName 对应的 RootBeanDefinition，如果这个 BeanDefinition 是子 Bean 的话，则会合并父类的相关属性。\n5. 依赖处理。\n\n**检测当前bean是否是Prototype类型的循环依赖**\n\n在前面就提过，Spring 只解决单例模式下的循环依赖，对于原型模式的循环依赖则是抛出 BeanCurrentlyInCreationException 异常，所以首先检查该 beanName 是否处于原型模式下的循环依赖。如下：\n\n```java\nif (isPrototypeCurrentlyInCreation(beanName)) {\n    throw new BeanCurrentlyInCreationException(beanName);\n}\n```\n\n调用 `isPrototypeCurrentlyInCreation()` 判断当前 bean 是否正在创建，如下：\n\n```java\n    protected boolean isPrototypeCurrentlyInCreation(String beanName) {\n        Object curVal = this.prototypesCurrentlyInCreation.get();\n        return (curVal != null &&\n                (curVal.equals(beanName) || \n                 (curVal instanceof Set && ((Set<?>) curVal).contains(beanName))));\n    }\n```\n\n其实检测逻辑和单例模式一样，一个“集合”存放着正在创建的 bean，从该集合中进行判断即可，只不过单例模式的“集合”为 Set ，而原型模式的则是 ThreadLocal，prototypesCurrentlyInCreation 定义如下：\n\n```java\n    private final ThreadLocal<Object> prototypesCurrentlyInCreation = \n        new NamedThreadLocal<>(\"Prototype beans currently in creation\");\n```\n\n**检查父类 BeanFactory**\n\n若 containsBeanDefinition 中不存在 beanName 相对应的 BeanDefinition，则从 parentBeanFactory 中获取。\n\n```java\n    // 获取 parentBeanFactory\n    BeanFactory parentBeanFactory = getParentBeanFactory();\n    // parentBeanFactory 不为空且 beanDefinitionMap 中不存该 name 的 BeanDefinition\n    if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n        // 确定原始 beanName\n        String nameToLookup = originalBeanName(name);\n        // 若为 AbstractBeanFactory 类型，委托父类处理\n        if (parentBeanFactory instanceof AbstractBeanFactory) {\n            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                    nameToLookup, requiredType, args, typeCheckOnly);\n        }\n        else if (args != null) {\n            // 委托给构造函数 getBean() 处理\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n        }\n        else {\n            // 没有 args，委托给标准的 getBean() 处理\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n        }\n    }\n```\n\n整个过程较为简单，都是委托 parentBeanFactory 的 `getBean()` 进行处理，只不过在获取之前对 name 进行简单的处理，主要是想获取原始的 beanName，如下：\n\n```java\n    protected String originalBeanName(String name) {\n        String beanName = transformedBeanName(name);\n        if (name.startsWith(FACTORY_BEAN_PREFIX)) {\n            beanName = FACTORY_BEAN_PREFIX + beanName;\n        }\n        return beanName;\n    }\n```\n\n`transformedBeanName()` 是对 name 进行转换，获取真正的 beanName，因为我们传递的可能是 aliasName（这个过程在上一篇博客中分析 `transformedBeanName()` 有详细说明），如果 name 是以 “&” 开头的，则加上 “&”，因为在 `transformedBeanName()` 将 “&” 去掉了，这里补上。\n\n**类型检查**\n\n参数 typeCheckOnly 是用来判断调用 `getBean()` 是否为类型检查获取 bean。如果不是仅仅做类型检查则是创建bean，则需要调用 `markBeanAsCreated()` 记录：\n\n```java\n     protected void markBeanAsCreated(String beanName) {\n        // 没有创建\n        if (!this.alreadyCreated.contains(beanName)) {\n            // 加上全局锁\n            synchronized (this.mergedBeanDefinitions) {\n                // 再次检查一次：DCL 双检查模式\n                if (!this.alreadyCreated.contains(beanName)) {\n                    // 从 mergedBeanDefinitions 中删除 beanName，\n                    // 并在下次访问时重新创建它。\n                    clearMergedBeanDefinition(beanName);\n                    // 添加到已创建bean 集合中\n                    this.alreadyCreated.add(beanName);\n                }\n            }\n        }\n    }\n```\n\n**获取 RootBeanDefinition**\n\n```java\nfinal RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n```\n\n调用 `getMergedLocalBeanDefinition()` 获取相对应的 BeanDefinition，如下：\n\n```java\n    protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException {\n        // 快速从缓存中获取，如果不为空，则直接返回\n        RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName);\n        if (mbd != null) {\n            return mbd;\n        }\n        // 获取 RootBeanDefinition，\n        // 如果返回的 BeanDefinition 是子类 bean 的话，则合并父类相关属性\n        return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));\n    }\n```\n\n首先直接从 mergedBeanDefinitions 缓存中获取相应的 RootBeanDefinition，如果存在则直接返回否则调用 `getMergedBeanDefinition()` 获取 RootBeanDefinition，若获取的 BeanDefinition 为子 BeanDefinition，则需要合并父类的相关属性。\n\n**处理依赖**\n\n如果一个 bean 有依赖 bean 的话，那么在初始化该 bean 时是需要先初始化它所依赖的 bean。\n\n```java\n\t // 获取依赖。\n\t // 在初始化 bean 时解析 depends-on 标签时设置\n     String[] dependsOn = mbd.getDependsOn();\n     if (dependsOn != null) {\n        // 迭代依赖\n        for (String dep : dependsOn) {\n            // 检验依赖的bean 是否已经注册给当前 bean 获取其他传递依赖bean\n            if (isDependent(beanName, dep)) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Circular depends-on relationship between '\" \n                                                + beanName + \"' and '\" + dep + \"'\");\n            }\n            // 注册到依赖bean中\n            registerDependentBean(dep, beanName);\n            try {\n                // 调用 getBean 初始化依赖bean\n                getBean(dep);\n            }\n            catch (NoSuchBeanDefinitionException ex) {\n                throw new BeanCreationException(mbd.getResourceDescription(),\n                                                beanName, \"'\" + beanName \n                              + \"' depends on missing bean '\" + dep + \"'\", ex);\n            }\n        }\n    }\n```\n\n这段代码逻辑是：通过迭代的方式依次对依赖 bean 进行检测、校验，如果通过则调用 `getBean()` 实例化依赖 bean。\n\n`isDependent()` 是校验该依赖是否已经注册给当前 bean。\n\n```java\n    protected boolean isDependent(String beanName, String dependentBeanName) {\n        synchronized (this.dependentBeanMap) {\n            return isDependent(beanName, dependentBeanName, null);\n        }\n    }\n```\n\n同步加锁给 dependentBeanMap 对象，然后调用 `isDependent()` 校验。dependentBeanMap 对象保存的是依赖 beanName 之间的映射关系：beanName – > 依赖 beanName 的集合\n\n```java\n    private boolean isDependent(String beanName, String dependentBeanName,\n                                @Nullable Set<String> alreadySeen) {\n\n        // alreadySeen 已经检测的依赖 bean\n        if (alreadySeen != null && alreadySeen.contains(beanName)) {\n            return false;\n        }\n        // 获取原始 beanName\n        String canonicalName = canonicalName(beanName);\n        // 获取当前 beanName 的依赖集合\n        Set<String> dependentBeans = this.dependentBeanMap.get(canonicalName);\n        // 不存在依赖，返回false\n        if (dependentBeans == null) {\n            return false;\n        }\n        // 存在，则证明存在已经注册的依赖\n        if (dependentBeans.contains(dependentBeanName)) {\n            return true;\n        }\n        // 递归检测依赖\n        for (String transitiveDependency : dependentBeans) {\n            if (alreadySeen == null) {\n                alreadySeen = new HashSet<>();\n            }\n            alreadySeen.add(beanName);\n            if (isDependent(transitiveDependency, dependentBeanName, alreadySeen)) {\n                return true;\n            }\n        }\n        return false;\n    }\n```\n\n如果校验成功，则调用 `registerDependentBean()` 将该依赖进行注册，便于在销毁 bean 之前对其进行销毁。\n\n```java\n    public void registerDependentBean(String beanName, String dependentBeanName) {\n        String canonicalName = canonicalName(beanName);\n\n        synchronized (this.dependentBeanMap) {\n            Set<String> dependentBeans =\n                    this.dependentBeanMap.computeIfAbsent(canonicalName, \n                                                          k -> new LinkedHashSet<>(8));\n            if (!dependentBeans.add(dependentBeanName)) {\n                return;\n            }\n        }\n\n        synchronized (this.dependenciesForBeanMap) {\n            Set<String> dependenciesForBean =\n                    this.dependenciesForBeanMap.computeIfAbsent(dependentBeanName,\n                                           k -> new LinkedHashSet<>(8));\n            dependenciesForBean.add(canonicalName);\n        }\n    }\n```\n\n其实将就是该映射关系保存到两个集合中：dependentBeanMap、dependenciesForBeanMap。\n\n最后调用 `getBean()` 实例化依赖 bean。\n\n至此，加载 bean 的第二个部分也分析完毕了，下篇开始分析第三个部分：各大作用域 bean 的处理","slug":"spring 源码分析/spring/spring源码解析之 18parentBeanFactory 与依赖处理","published":1,"updated":"2019-01-15T03:36:29.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovwd004r9q1ukh2nabpc","content":"<h1 id=\"spring源码解析之-18parentBeanFactory-与依赖处理\"><a href=\"#spring源码解析之-18parentBeanFactory-与依赖处理\" class=\"headerlink\" title=\"spring源码解析之 18parentBeanFactory 与依赖处理\"></a>spring源码解析之 18parentBeanFactory 与依赖处理</h1><p>从上篇文章中我们可以得知，如果从单例缓存中没有获取到单例 bean，则说明两种情况：</p>\n<ol>\n<li>该 bean 的 scope 不是 singleton</li>\n<li>该 bean 的 scope 是 singleton ,但是没有初始化完成</li>\n</ol>\n<p>本篇文章就来进行这部分的分析，不过将这部分分为俩篇博客来分析，这里先讲检测、parentBeanFactory与依赖处理，剩下的scope处理，主要在下一篇文章中讲解，本文所分析的具体源码如下：<br><a id=\"more\"></a></p>\n<pre><code class=\"java\">            /**\n             * 只有个在单例情况下才会尝试解决循环依赖，原型模式情况下，\n             * 如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，\n             * 就会产生当A还未创建完的时候因为B的创建在此返回创建A，造成\n             * 循环依赖，也就是下面这种情况\n             */\n            if (isPrototypeCurrentlyInCreation(beanName)) {\n                throw new BeanCurrentlyInCreationException(beanName);\n            }\n\n            // 如果beanDefinitionMap中也就是在所有已加载的类中不包括beanName\n            // 则会尝试从parentBeanFactory中检测\n            BeanFactory parentBeanFactory = getParentBeanFactory();\n            // containsBeanDefinition 用于检测当前BeanFactory\n            // 是否包含beanName的BeanDefinition\n            if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n                // 递归到BeanFactory中寻找,这点和下面的创建过程大体类型，只不过委托给父类来查找\n                String nameToLookup = originalBeanName(name);\n                if (parentBeanFactory instanceof AbstractBeanFactory) {\n                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                            nameToLookup, requiredType, args, typeCheckOnly);\n                } else if (args != null) {\n                    // 带有args的处理\n                    // Delegation to parent with explicit args.\n                    return (T) parentBeanFactory.getBean(nameToLookup, args);\n                } else if (requiredType != null) {\n                    // 带有特定类型的处理\n                    return parentBeanFactory.getBean(nameToLookup, requiredType);\n                } else {\n                    return (T) parentBeanFactory.getBean(nameToLookup);\n                }\n            }\n\n            // 如果不是仅仅做类型检查则是创建bean，这里要进行记录\n            if (!typeCheckOnly) {\n                markBeanAsCreated(beanName);\n            }\n\n            try {\n                // 将存储xml配置文件的GernericBeanDefinition转换为RootBeanDefinition\n                // 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n                final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n                checkMergedBeanDefinition(mbd, beanName, args);\n\n                // 若存在依赖则需要递归实例化依赖的bean\n                // 这里的getDependsOn返回的是对应bean属性depend-on设置的值\n                String[] dependsOn = mbd.getDependsOn();\n                if (dependsOn != null) {\n                    for (String dep : dependsOn) {\n                        if (isDependent(beanName, dep)) {\n                            throw new BeanCreationException(\n                                mbd.getResourceDescription(), beanName,\n                                    &quot;Circular depends-on relationship between &#39;&quot; \n                                    + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);\n                        }\n                        // 缓存依赖调用\n                        registerDependentBean(dep, beanName);\n                        try {\n                            getBean(dep);\n                        } catch (NoSuchBeanDefinitionException ex) {\n                            throw new BeanCreationException(\n                                mbd.getResourceDescription(), beanName,\n                                    &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; \n                                    + dep + &quot;&#39;&quot;, ex);\n                        }\n                    }\n                }\n</code></pre>\n<p>这段代码主要处理如下几个部分：</p>\n<ol>\n<li>检测当前bean的scope是否是Prototype。如果是并且存在循环依赖则抛出 BeanCurrentlyInCreationException 异常。</li>\n<li>如果 beanDefinitionMap 中不存在 beanName 的 BeanDefinition（即在 Spring bean 初始化过程中没有加载），则尝试从 parentBeanFactory 中加载。</li>\n<li>判断是否为类型检查。</li>\n<li>从 mergedBeanDefinitions 中获取 beanName 对应的 RootBeanDefinition，如果这个 BeanDefinition 是子 Bean 的话，则会合并父类的相关属性。</li>\n<li>依赖处理。</li>\n</ol>\n<p><strong>检测当前bean是否是Prototype类型的循环依赖</strong></p>\n<p>在前面就提过，Spring 只解决单例模式下的循环依赖，对于原型模式的循环依赖则是抛出 BeanCurrentlyInCreationException 异常，所以首先检查该 beanName 是否处于原型模式下的循环依赖。如下：</p>\n<pre><code class=\"java\">if (isPrototypeCurrentlyInCreation(beanName)) {\n    throw new BeanCurrentlyInCreationException(beanName);\n}\n</code></pre>\n<p>调用 <code>isPrototypeCurrentlyInCreation()</code> 判断当前 bean 是否正在创建，如下：</p>\n<pre><code class=\"java\">    protected boolean isPrototypeCurrentlyInCreation(String beanName) {\n        Object curVal = this.prototypesCurrentlyInCreation.get();\n        return (curVal != null &amp;&amp;\n                (curVal.equals(beanName) || \n                 (curVal instanceof Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));\n    }\n</code></pre>\n<p>其实检测逻辑和单例模式一样，一个“集合”存放着正在创建的 bean，从该集合中进行判断即可，只不过单例模式的“集合”为 Set ，而原型模式的则是 ThreadLocal，prototypesCurrentlyInCreation 定义如下：</p>\n<pre><code class=\"java\">    private final ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation = \n        new NamedThreadLocal&lt;&gt;(&quot;Prototype beans currently in creation&quot;);\n</code></pre>\n<p><strong>检查父类 BeanFactory</strong></p>\n<p>若 containsBeanDefinition 中不存在 beanName 相对应的 BeanDefinition，则从 parentBeanFactory 中获取。</p>\n<pre><code class=\"java\">    // 获取 parentBeanFactory\n    BeanFactory parentBeanFactory = getParentBeanFactory();\n    // parentBeanFactory 不为空且 beanDefinitionMap 中不存该 name 的 BeanDefinition\n    if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n        // 确定原始 beanName\n        String nameToLookup = originalBeanName(name);\n        // 若为 AbstractBeanFactory 类型，委托父类处理\n        if (parentBeanFactory instanceof AbstractBeanFactory) {\n            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                    nameToLookup, requiredType, args, typeCheckOnly);\n        }\n        else if (args != null) {\n            // 委托给构造函数 getBean() 处理\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n        }\n        else {\n            // 没有 args，委托给标准的 getBean() 处理\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n        }\n    }\n</code></pre>\n<p>整个过程较为简单，都是委托 parentBeanFactory 的 <code>getBean()</code> 进行处理，只不过在获取之前对 name 进行简单的处理，主要是想获取原始的 beanName，如下：</p>\n<pre><code class=\"java\">    protected String originalBeanName(String name) {\n        String beanName = transformedBeanName(name);\n        if (name.startsWith(FACTORY_BEAN_PREFIX)) {\n            beanName = FACTORY_BEAN_PREFIX + beanName;\n        }\n        return beanName;\n    }\n</code></pre>\n<p><code>transformedBeanName()</code> 是对 name 进行转换，获取真正的 beanName，因为我们传递的可能是 aliasName（这个过程在上一篇博客中分析 <code>transformedBeanName()</code> 有详细说明），如果 name 是以 “&amp;” 开头的，则加上 “&amp;”，因为在 <code>transformedBeanName()</code> 将 “&amp;” 去掉了，这里补上。</p>\n<p><strong>类型检查</strong></p>\n<p>参数 typeCheckOnly 是用来判断调用 <code>getBean()</code> 是否为类型检查获取 bean。如果不是仅仅做类型检查则是创建bean，则需要调用 <code>markBeanAsCreated()</code> 记录：</p>\n<pre><code class=\"java\">     protected void markBeanAsCreated(String beanName) {\n        // 没有创建\n        if (!this.alreadyCreated.contains(beanName)) {\n            // 加上全局锁\n            synchronized (this.mergedBeanDefinitions) {\n                // 再次检查一次：DCL 双检查模式\n                if (!this.alreadyCreated.contains(beanName)) {\n                    // 从 mergedBeanDefinitions 中删除 beanName，\n                    // 并在下次访问时重新创建它。\n                    clearMergedBeanDefinition(beanName);\n                    // 添加到已创建bean 集合中\n                    this.alreadyCreated.add(beanName);\n                }\n            }\n        }\n    }\n</code></pre>\n<p><strong>获取 RootBeanDefinition</strong></p>\n<pre><code class=\"java\">final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n</code></pre>\n<p>调用 <code>getMergedLocalBeanDefinition()</code> 获取相对应的 BeanDefinition，如下：</p>\n<pre><code class=\"java\">    protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException {\n        // 快速从缓存中获取，如果不为空，则直接返回\n        RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName);\n        if (mbd != null) {\n            return mbd;\n        }\n        // 获取 RootBeanDefinition，\n        // 如果返回的 BeanDefinition 是子类 bean 的话，则合并父类相关属性\n        return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));\n    }\n</code></pre>\n<p>首先直接从 mergedBeanDefinitions 缓存中获取相应的 RootBeanDefinition，如果存在则直接返回否则调用 <code>getMergedBeanDefinition()</code> 获取 RootBeanDefinition，若获取的 BeanDefinition 为子 BeanDefinition，则需要合并父类的相关属性。</p>\n<p><strong>处理依赖</strong></p>\n<p>如果一个 bean 有依赖 bean 的话，那么在初始化该 bean 时是需要先初始化它所依赖的 bean。</p>\n<pre><code class=\"java\">     // 获取依赖。\n     // 在初始化 bean 时解析 depends-on 标签时设置\n     String[] dependsOn = mbd.getDependsOn();\n     if (dependsOn != null) {\n        // 迭代依赖\n        for (String dep : dependsOn) {\n            // 检验依赖的bean 是否已经注册给当前 bean 获取其他传递依赖bean\n            if (isDependent(beanName, dep)) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        &quot;Circular depends-on relationship between &#39;&quot; \n                                                + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);\n            }\n            // 注册到依赖bean中\n            registerDependentBean(dep, beanName);\n            try {\n                // 调用 getBean 初始化依赖bean\n                getBean(dep);\n            }\n            catch (NoSuchBeanDefinitionException ex) {\n                throw new BeanCreationException(mbd.getResourceDescription(),\n                                                beanName, &quot;&#39;&quot; + beanName \n                              + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);\n            }\n        }\n    }\n</code></pre>\n<p>这段代码逻辑是：通过迭代的方式依次对依赖 bean 进行检测、校验，如果通过则调用 <code>getBean()</code> 实例化依赖 bean。</p>\n<p><code>isDependent()</code> 是校验该依赖是否已经注册给当前 bean。</p>\n<pre><code class=\"java\">    protected boolean isDependent(String beanName, String dependentBeanName) {\n        synchronized (this.dependentBeanMap) {\n            return isDependent(beanName, dependentBeanName, null);\n        }\n    }\n</code></pre>\n<p>同步加锁给 dependentBeanMap 对象，然后调用 <code>isDependent()</code> 校验。dependentBeanMap 对象保存的是依赖 beanName 之间的映射关系：beanName – &gt; 依赖 beanName 的集合</p>\n<pre><code class=\"java\">    private boolean isDependent(String beanName, String dependentBeanName,\n                                @Nullable Set&lt;String&gt; alreadySeen) {\n\n        // alreadySeen 已经检测的依赖 bean\n        if (alreadySeen != null &amp;&amp; alreadySeen.contains(beanName)) {\n            return false;\n        }\n        // 获取原始 beanName\n        String canonicalName = canonicalName(beanName);\n        // 获取当前 beanName 的依赖集合\n        Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(canonicalName);\n        // 不存在依赖，返回false\n        if (dependentBeans == null) {\n            return false;\n        }\n        // 存在，则证明存在已经注册的依赖\n        if (dependentBeans.contains(dependentBeanName)) {\n            return true;\n        }\n        // 递归检测依赖\n        for (String transitiveDependency : dependentBeans) {\n            if (alreadySeen == null) {\n                alreadySeen = new HashSet&lt;&gt;();\n            }\n            alreadySeen.add(beanName);\n            if (isDependent(transitiveDependency, dependentBeanName, alreadySeen)) {\n                return true;\n            }\n        }\n        return false;\n    }\n</code></pre>\n<p>如果校验成功，则调用 <code>registerDependentBean()</code> 将该依赖进行注册，便于在销毁 bean 之前对其进行销毁。</p>\n<pre><code class=\"java\">    public void registerDependentBean(String beanName, String dependentBeanName) {\n        String canonicalName = canonicalName(beanName);\n\n        synchronized (this.dependentBeanMap) {\n            Set&lt;String&gt; dependentBeans =\n                    this.dependentBeanMap.computeIfAbsent(canonicalName, \n                                                          k -&gt; new LinkedHashSet&lt;&gt;(8));\n            if (!dependentBeans.add(dependentBeanName)) {\n                return;\n            }\n        }\n\n        synchronized (this.dependenciesForBeanMap) {\n            Set&lt;String&gt; dependenciesForBean =\n                    this.dependenciesForBeanMap.computeIfAbsent(dependentBeanName,\n                                           k -&gt; new LinkedHashSet&lt;&gt;(8));\n            dependenciesForBean.add(canonicalName);\n        }\n    }\n</code></pre>\n<p>其实将就是该映射关系保存到两个集合中：dependentBeanMap、dependenciesForBeanMap。</p>\n<p>最后调用 <code>getBean()</code> 实例化依赖 bean。</p>\n<p>至此，加载 bean 的第二个部分也分析完毕了，下篇开始分析第三个部分：各大作用域 bean 的处理</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-18parentBeanFactory-与依赖处理\"><a href=\"#spring源码解析之-18parentBeanFactory-与依赖处理\" class=\"headerlink\" title=\"spring源码解析之 18parentBeanFactory 与依赖处理\"></a>spring源码解析之 18parentBeanFactory 与依赖处理</h1><p>从上篇文章中我们可以得知，如果从单例缓存中没有获取到单例 bean，则说明两种情况：</p>\n<ol>\n<li>该 bean 的 scope 不是 singleton</li>\n<li>该 bean 的 scope 是 singleton ,但是没有初始化完成</li>\n</ol>\n<p>本篇文章就来进行这部分的分析，不过将这部分分为俩篇博客来分析，这里先讲检测、parentBeanFactory与依赖处理，剩下的scope处理，主要在下一篇文章中讲解，本文所分析的具体源码如下：<br>","more":"</p>\n<pre><code class=\"java\">            /**\n             * 只有个在单例情况下才会尝试解决循环依赖，原型模式情况下，\n             * 如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，\n             * 就会产生当A还未创建完的时候因为B的创建在此返回创建A，造成\n             * 循环依赖，也就是下面这种情况\n             */\n            if (isPrototypeCurrentlyInCreation(beanName)) {\n                throw new BeanCurrentlyInCreationException(beanName);\n            }\n\n            // 如果beanDefinitionMap中也就是在所有已加载的类中不包括beanName\n            // 则会尝试从parentBeanFactory中检测\n            BeanFactory parentBeanFactory = getParentBeanFactory();\n            // containsBeanDefinition 用于检测当前BeanFactory\n            // 是否包含beanName的BeanDefinition\n            if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n                // 递归到BeanFactory中寻找,这点和下面的创建过程大体类型，只不过委托给父类来查找\n                String nameToLookup = originalBeanName(name);\n                if (parentBeanFactory instanceof AbstractBeanFactory) {\n                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                            nameToLookup, requiredType, args, typeCheckOnly);\n                } else if (args != null) {\n                    // 带有args的处理\n                    // Delegation to parent with explicit args.\n                    return (T) parentBeanFactory.getBean(nameToLookup, args);\n                } else if (requiredType != null) {\n                    // 带有特定类型的处理\n                    return parentBeanFactory.getBean(nameToLookup, requiredType);\n                } else {\n                    return (T) parentBeanFactory.getBean(nameToLookup);\n                }\n            }\n\n            // 如果不是仅仅做类型检查则是创建bean，这里要进行记录\n            if (!typeCheckOnly) {\n                markBeanAsCreated(beanName);\n            }\n\n            try {\n                // 将存储xml配置文件的GernericBeanDefinition转换为RootBeanDefinition\n                // 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n                final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n                checkMergedBeanDefinition(mbd, beanName, args);\n\n                // 若存在依赖则需要递归实例化依赖的bean\n                // 这里的getDependsOn返回的是对应bean属性depend-on设置的值\n                String[] dependsOn = mbd.getDependsOn();\n                if (dependsOn != null) {\n                    for (String dep : dependsOn) {\n                        if (isDependent(beanName, dep)) {\n                            throw new BeanCreationException(\n                                mbd.getResourceDescription(), beanName,\n                                    &quot;Circular depends-on relationship between &#39;&quot; \n                                    + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);\n                        }\n                        // 缓存依赖调用\n                        registerDependentBean(dep, beanName);\n                        try {\n                            getBean(dep);\n                        } catch (NoSuchBeanDefinitionException ex) {\n                            throw new BeanCreationException(\n                                mbd.getResourceDescription(), beanName,\n                                    &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; \n                                    + dep + &quot;&#39;&quot;, ex);\n                        }\n                    }\n                }\n</code></pre>\n<p>这段代码主要处理如下几个部分：</p>\n<ol>\n<li>检测当前bean的scope是否是Prototype。如果是并且存在循环依赖则抛出 BeanCurrentlyInCreationException 异常。</li>\n<li>如果 beanDefinitionMap 中不存在 beanName 的 BeanDefinition（即在 Spring bean 初始化过程中没有加载），则尝试从 parentBeanFactory 中加载。</li>\n<li>判断是否为类型检查。</li>\n<li>从 mergedBeanDefinitions 中获取 beanName 对应的 RootBeanDefinition，如果这个 BeanDefinition 是子 Bean 的话，则会合并父类的相关属性。</li>\n<li>依赖处理。</li>\n</ol>\n<p><strong>检测当前bean是否是Prototype类型的循环依赖</strong></p>\n<p>在前面就提过，Spring 只解决单例模式下的循环依赖，对于原型模式的循环依赖则是抛出 BeanCurrentlyInCreationException 异常，所以首先检查该 beanName 是否处于原型模式下的循环依赖。如下：</p>\n<pre><code class=\"java\">if (isPrototypeCurrentlyInCreation(beanName)) {\n    throw new BeanCurrentlyInCreationException(beanName);\n}\n</code></pre>\n<p>调用 <code>isPrototypeCurrentlyInCreation()</code> 判断当前 bean 是否正在创建，如下：</p>\n<pre><code class=\"java\">    protected boolean isPrototypeCurrentlyInCreation(String beanName) {\n        Object curVal = this.prototypesCurrentlyInCreation.get();\n        return (curVal != null &amp;&amp;\n                (curVal.equals(beanName) || \n                 (curVal instanceof Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));\n    }\n</code></pre>\n<p>其实检测逻辑和单例模式一样，一个“集合”存放着正在创建的 bean，从该集合中进行判断即可，只不过单例模式的“集合”为 Set ，而原型模式的则是 ThreadLocal，prototypesCurrentlyInCreation 定义如下：</p>\n<pre><code class=\"java\">    private final ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation = \n        new NamedThreadLocal&lt;&gt;(&quot;Prototype beans currently in creation&quot;);\n</code></pre>\n<p><strong>检查父类 BeanFactory</strong></p>\n<p>若 containsBeanDefinition 中不存在 beanName 相对应的 BeanDefinition，则从 parentBeanFactory 中获取。</p>\n<pre><code class=\"java\">    // 获取 parentBeanFactory\n    BeanFactory parentBeanFactory = getParentBeanFactory();\n    // parentBeanFactory 不为空且 beanDefinitionMap 中不存该 name 的 BeanDefinition\n    if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n        // 确定原始 beanName\n        String nameToLookup = originalBeanName(name);\n        // 若为 AbstractBeanFactory 类型，委托父类处理\n        if (parentBeanFactory instanceof AbstractBeanFactory) {\n            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                    nameToLookup, requiredType, args, typeCheckOnly);\n        }\n        else if (args != null) {\n            // 委托给构造函数 getBean() 处理\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n        }\n        else {\n            // 没有 args，委托给标准的 getBean() 处理\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n        }\n    }\n</code></pre>\n<p>整个过程较为简单，都是委托 parentBeanFactory 的 <code>getBean()</code> 进行处理，只不过在获取之前对 name 进行简单的处理，主要是想获取原始的 beanName，如下：</p>\n<pre><code class=\"java\">    protected String originalBeanName(String name) {\n        String beanName = transformedBeanName(name);\n        if (name.startsWith(FACTORY_BEAN_PREFIX)) {\n            beanName = FACTORY_BEAN_PREFIX + beanName;\n        }\n        return beanName;\n    }\n</code></pre>\n<p><code>transformedBeanName()</code> 是对 name 进行转换，获取真正的 beanName，因为我们传递的可能是 aliasName（这个过程在上一篇博客中分析 <code>transformedBeanName()</code> 有详细说明），如果 name 是以 “&amp;” 开头的，则加上 “&amp;”，因为在 <code>transformedBeanName()</code> 将 “&amp;” 去掉了，这里补上。</p>\n<p><strong>类型检查</strong></p>\n<p>参数 typeCheckOnly 是用来判断调用 <code>getBean()</code> 是否为类型检查获取 bean。如果不是仅仅做类型检查则是创建bean，则需要调用 <code>markBeanAsCreated()</code> 记录：</p>\n<pre><code class=\"java\">     protected void markBeanAsCreated(String beanName) {\n        // 没有创建\n        if (!this.alreadyCreated.contains(beanName)) {\n            // 加上全局锁\n            synchronized (this.mergedBeanDefinitions) {\n                // 再次检查一次：DCL 双检查模式\n                if (!this.alreadyCreated.contains(beanName)) {\n                    // 从 mergedBeanDefinitions 中删除 beanName，\n                    // 并在下次访问时重新创建它。\n                    clearMergedBeanDefinition(beanName);\n                    // 添加到已创建bean 集合中\n                    this.alreadyCreated.add(beanName);\n                }\n            }\n        }\n    }\n</code></pre>\n<p><strong>获取 RootBeanDefinition</strong></p>\n<pre><code class=\"java\">final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n</code></pre>\n<p>调用 <code>getMergedLocalBeanDefinition()</code> 获取相对应的 BeanDefinition，如下：</p>\n<pre><code class=\"java\">    protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException {\n        // 快速从缓存中获取，如果不为空，则直接返回\n        RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName);\n        if (mbd != null) {\n            return mbd;\n        }\n        // 获取 RootBeanDefinition，\n        // 如果返回的 BeanDefinition 是子类 bean 的话，则合并父类相关属性\n        return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));\n    }\n</code></pre>\n<p>首先直接从 mergedBeanDefinitions 缓存中获取相应的 RootBeanDefinition，如果存在则直接返回否则调用 <code>getMergedBeanDefinition()</code> 获取 RootBeanDefinition，若获取的 BeanDefinition 为子 BeanDefinition，则需要合并父类的相关属性。</p>\n<p><strong>处理依赖</strong></p>\n<p>如果一个 bean 有依赖 bean 的话，那么在初始化该 bean 时是需要先初始化它所依赖的 bean。</p>\n<pre><code class=\"java\">     // 获取依赖。\n     // 在初始化 bean 时解析 depends-on 标签时设置\n     String[] dependsOn = mbd.getDependsOn();\n     if (dependsOn != null) {\n        // 迭代依赖\n        for (String dep : dependsOn) {\n            // 检验依赖的bean 是否已经注册给当前 bean 获取其他传递依赖bean\n            if (isDependent(beanName, dep)) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        &quot;Circular depends-on relationship between &#39;&quot; \n                                                + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);\n            }\n            // 注册到依赖bean中\n            registerDependentBean(dep, beanName);\n            try {\n                // 调用 getBean 初始化依赖bean\n                getBean(dep);\n            }\n            catch (NoSuchBeanDefinitionException ex) {\n                throw new BeanCreationException(mbd.getResourceDescription(),\n                                                beanName, &quot;&#39;&quot; + beanName \n                              + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);\n            }\n        }\n    }\n</code></pre>\n<p>这段代码逻辑是：通过迭代的方式依次对依赖 bean 进行检测、校验，如果通过则调用 <code>getBean()</code> 实例化依赖 bean。</p>\n<p><code>isDependent()</code> 是校验该依赖是否已经注册给当前 bean。</p>\n<pre><code class=\"java\">    protected boolean isDependent(String beanName, String dependentBeanName) {\n        synchronized (this.dependentBeanMap) {\n            return isDependent(beanName, dependentBeanName, null);\n        }\n    }\n</code></pre>\n<p>同步加锁给 dependentBeanMap 对象，然后调用 <code>isDependent()</code> 校验。dependentBeanMap 对象保存的是依赖 beanName 之间的映射关系：beanName – &gt; 依赖 beanName 的集合</p>\n<pre><code class=\"java\">    private boolean isDependent(String beanName, String dependentBeanName,\n                                @Nullable Set&lt;String&gt; alreadySeen) {\n\n        // alreadySeen 已经检测的依赖 bean\n        if (alreadySeen != null &amp;&amp; alreadySeen.contains(beanName)) {\n            return false;\n        }\n        // 获取原始 beanName\n        String canonicalName = canonicalName(beanName);\n        // 获取当前 beanName 的依赖集合\n        Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(canonicalName);\n        // 不存在依赖，返回false\n        if (dependentBeans == null) {\n            return false;\n        }\n        // 存在，则证明存在已经注册的依赖\n        if (dependentBeans.contains(dependentBeanName)) {\n            return true;\n        }\n        // 递归检测依赖\n        for (String transitiveDependency : dependentBeans) {\n            if (alreadySeen == null) {\n                alreadySeen = new HashSet&lt;&gt;();\n            }\n            alreadySeen.add(beanName);\n            if (isDependent(transitiveDependency, dependentBeanName, alreadySeen)) {\n                return true;\n            }\n        }\n        return false;\n    }\n</code></pre>\n<p>如果校验成功，则调用 <code>registerDependentBean()</code> 将该依赖进行注册，便于在销毁 bean 之前对其进行销毁。</p>\n<pre><code class=\"java\">    public void registerDependentBean(String beanName, String dependentBeanName) {\n        String canonicalName = canonicalName(beanName);\n\n        synchronized (this.dependentBeanMap) {\n            Set&lt;String&gt; dependentBeans =\n                    this.dependentBeanMap.computeIfAbsent(canonicalName, \n                                                          k -&gt; new LinkedHashSet&lt;&gt;(8));\n            if (!dependentBeans.add(dependentBeanName)) {\n                return;\n            }\n        }\n\n        synchronized (this.dependenciesForBeanMap) {\n            Set&lt;String&gt; dependenciesForBean =\n                    this.dependenciesForBeanMap.computeIfAbsent(dependentBeanName,\n                                           k -&gt; new LinkedHashSet&lt;&gt;(8));\n            dependenciesForBean.add(canonicalName);\n        }\n    }\n</code></pre>\n<p>其实将就是该映射关系保存到两个集合中：dependentBeanMap、dependenciesForBeanMap。</p>\n<p>最后调用 <code>getBean()</code> 实例化依赖 bean。</p>\n<p>至此，加载 bean 的第二个部分也分析完毕了，下篇开始分析第三个部分：各大作用域 bean 的处理</p>"},{"abbrlink":45,"title":"spring源码解析之 24循环依赖处理","author":"fengxiutianya","date":"2019-01-14T19:38:00.000Z","_content":"# spring源码解析之 24 循环依赖处理\n\n这篇分析 `doCreateBean()` 第三个过程：循环依赖处理。其实循环依赖并不仅仅只是在 `doCreateBean()` 中处理，其实在整个加载 bean 的过程中都有涉及，所以下篇内容并不仅仅只局限于 `doCreateBean()`，而是从整个 Bean 的加载过程进行分析。\n<!-- more -->\n\n## 什么是循环依赖\n\n循环依赖其实就是循环引用，就是两个或者两个以上的 bean 互相引用对方，最终形成一个闭环，如 A 依赖 B，B 依赖 C，C 依赖 A，如下：\n\n![upload successful](/images/pasted-13.png)\n\n循环依赖 其实就是一个死循环的过程，在初始化 A 的时候发现引用了 B，这时就会去初始化 B，然后又发现 B 引用 C，跑去初始化 C，初始化 C 的时候发现引用了 A，则又会去初始化 A，依次循环永不退出，除非有终结条件。\n\nSpring 循环依赖的场景有两种：\n\n1. 构造器的循环依赖\n2. field 属性的循环依赖\n\n对于构造器的循环依赖，Spring 是无法解决的，只能抛出 BeanCurrentlyInCreationException 异常表示循环依赖，所以下面我们分析的都是基于 field 属性的循环依赖。\n\nSpring 只解决 scope 为 singleton 的循环依赖，对于scope 为 prototype 的 bean Spring 无法解决，直接抛出 BeanCurrentlyInCreationException 异常。为什么 Spring 不处理 prototype bean，其实如果理解 Spring 是如何解决 singleton bean 的循环依赖就明白了。这里先卖一个关子，我们先来关注 Spring 是如何解决 singleton bean 的循环依赖的。\n\n## 解决循环依赖\n\n我们先从加载 bean 最初始的方法 `doGetBean()` 开始。\n\n在 `doGetBean()` 中，首先会根据 beanName 从单例 bean 缓存中获取，如果不为空则直接返回。\n\n```java\nObject sharedInstance = getSingleton(beanName);\n```\n\n调用 `getSingleton()` 方法从单例缓存中获取，如下：\n\n```java\n    protected Object getSingleton(String beanName, boolean allowEarlyReference) {\n        Object singletonObject = this.singletonObjects.get(beanName);\n        if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n            synchronized (this.singletonObjects) {\n                singletonObject = this.earlySingletonObjects.get(beanName);\n                if (singletonObject == null && allowEarlyReference) {\n                    ObjectFactory<?> singletonFactory = \n                        this.singletonFactories.get(beanName);\n                    if (singletonFactory != null) {\n                        singletonObject = singletonFactory.getObject();\n                        this.earlySingletonObjects.put(beanName, singletonObject);\n                        this.singletonFactories.remove(beanName);\n                    }\n                }\n            }\n        }\n        return singletonObject;\n    }\n```\n\n这个方法主要是从三个缓存中获取，分别是：singletonObjects、earlySingletonObjects、singletonFactories，三者定义如下：\n\n```java\n    /** Cache of singleton objects: bean name --> bean instance */\n    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);\n\n    /** Cache of singleton factories: bean name --> ObjectFactory */\n    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);\n\n    /** Cache of early singleton objects: bean name --> bean instance */\n    private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);\n```\n\n意义如下：\n\n- singletonObjects：单例对象的cache\n- singletonFactories ： 单例对象工厂的cache\n- earlySingletonObjects ：提前暴光的单例对象的Cache\n\n他们就是 Spring 解决 singleton bean 的关键因素所在，我称他们为三级缓存，第一级为 singletonObjects，第二级为 earlySingletonObjects，第三级为 singletonFactories。这里我们可以通过 `getSingleton()` 看到他们是如何配合的，这分析该方法之前，提下其中的 `isSingletonCurrentlyInCreation()` 和 `allowEarlyReference`。\n\n- `isSingletonCurrentlyInCreation()`：判断当前 singleton bean 是否处于创建中。bean 处于创建中也就是说 bean 在初始化但是没有完成初始化，前面我们在从缓存从获取单例对象也提到过这个方法。这样的过程其实和 Spring 解决 bean 循环依赖的理念相辅相成，因为 Spring 解决 singleton bean 的核心就在于提前曝光 bean。\n- allowEarlyReference：从字面意思上面理解就是允许提前拿到引用。其实真正的意思是是否允许从 singletonFactories 缓存中通过 `getObject()` 拿到对象，为什么会有这样一个字段呢？原因就在于 singletonFactories 才是 Spring 解决 singleton bean 的诀窍所在，这个我们后续分析。\n\n`getSingleton()` 整个过程如下：首先从一级缓存 singletonObjects 获取，如果没有且当前指定的 beanName 正在创建，就再从二级缓存中 earlySingletonObjects 获取，如果还是没有获取到且运行 singletonFactories 通过 `getObject()` 获取，则从三级缓存 singletonFactories 获取，如果获取到则通过其 `getObject()` 获取对象，并将其加入到二级缓存 earlySingletonObjects 中 从三级缓存 singletonFactories 删除，如下：\n\n```java\nsingletonObject = singletonFactory.getObject();\nthis.earlySingletonObjects.put(beanName, singletonObject);\nthis.singletonFactories.remove(beanName);\n```\n\n这样就从三级缓存升级到二级缓存了。\n\n上面是从缓存中获取，但是缓存中的数据从哪里添加进来的呢？一直往下跟会发现在 `doCreateBean()` ( AbstractAutowireCapableBeanFactory ) 中，有这么一段代码：\n\n```java\nboolean earlySingletonExposure = (mbd.isSingleton() \n                                  && this.allowCircularReferences \n                                  && isSingletonCurrentlyInCreation(beanName));\nif (earlySingletonExposure) {\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Eagerly caching bean '\" + beanName +\n                        \"' to allow for resolving potential circular references\");\n    }\n    addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n}\n```\n\n如果 `earlySingletonExposure == true` 的话，则调用 `addSingletonFactory()` 将他们添加到缓存中，但是一个 bean 要具备如下条件才会添加至缓存中：\n\n- 单例\n- 运行提前暴露 bean\n- 当前 bean 正在创建中\n\n经过上面分析，我们了解添加addSingletonFactory满足什么条件才能调用，但是调用addSingletonFactory起到什么作用呢，我们还是以最简单AB循环依赖为例，类A中含有属性类B，类B中又含有属性A，那么初始化BeanA的过程入下图\n\n![upload successful](/images/pasted-23.png)\n\n![upload successful](/images/pasted-24.png)\n\ncong\n\n`addSingletonFactory()` 代码如下：\n\n```java\n    protected void addSingletonFactory(String beanName,\n                                       ObjectFactory<?> singletonFactory) {\n        Assert.notNull(singletonFactory, \"Singleton factory must not be null\");\n        synchronized (this.singletonObjects) {\n            if (!this.singletonObjects.containsKey(beanName)) {\n                this.singletonFactories.put(beanName, singletonFactory);\n                this.earlySingletonObjects.remove(beanName);\n                this.registeredSingletons.add(beanName);\n            }\n        }\n    }\n```\n\n从这段代码我们可以看出 singletonFactories 这个三级缓存才是解决 Spring Bean 循环依赖的诀窍所在。同时这段代码发生在 `createBeanInstance()` 方法之后，也就是说这个 bean 其实已经被创建出来了，但是它还不是很完美（没有进行属性填充和初始化），但是对于其他依赖它的对象而言已经足够了（可以根据对象引用定位到堆中对象），能够被认出来了，所以 Spring 在这个时候选择将该对象提前曝光出来让大家认识认识。\n\n**getEarlyBeanReference**如下\n\n```java\n\tprotected Object getEarlyBeanReference(String beanName,\n    \tRootBeanDefinition mbd, Object bean) {\n\t\tObject exposedObject = bean;\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (BeanPostProcessor bp : getBeanPostProcessors()) {\n\t\t\t\tif (bp instanceof SmartInstantiationAwareBeanPostProcessor) {\n\t\t\t\t\tSmartInstantiationAwareBeanPostProcessor ibp = \n\t\t\t\t\t(SmartInstantiationAwareBeanPostProcessor) bp;\n\t\t\t\t\texposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn exposedObject;\n\t}\n```\n\n![upload successful](/images/pasted-25.png)\n\n介绍到这里我们发现三级缓存 singletonFactories 和 二级缓存 earlySingletonObjects 中的值都有出处了，那一级缓存在哪里设置的呢？在类 DefaultSingletonBeanRegistry 中可以发现这个 `addSingleton()` 方法，源码如下：\n\n```java\n    protected void addSingleton(String beanName, Object singletonObject) {\n        synchronized (this.singletonObjects) {\n            this.singletonObjects.put(beanName, singletonObject);\n            this.singletonFactories.remove(beanName);\n            this.earlySingletonObjects.remove(beanName);\n            this.registeredSingletons.add(beanName);\n        }\n    }\n```\n\n添加至一级缓存，同时从二级、三级缓存中删除。这个方法在我们创建 bean 的链路中有哪个地方引用呢？其实在前面博客已经提到过了，在 `doGetBean()` 处理不同 scope 时，如果是 singleton，则调用 `getSingleton()`，如下：\n\n```java\n    public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {\n        Assert.notNull(beanName, \"Bean name must not be null\");\n        synchronized (this.singletonObjects) {\n            Object singletonObject = this.singletonObjects.get(beanName);\n            if (singletonObject == null) {\n                //....\n                try {\n                    singletonObject = singletonFactory.getObject();\n                    newSingleton = true;\n                }\n                //.....\n                if (newSingleton) {\n                    addSingleton(beanName, singletonObject);\n                }\n            }\n            return singletonObject;\n        }\n    }\n```\n\n至此，Spring 关于 singleton bean 循环依赖已经分析完毕了。所以我们基本上可以确定 Spring 解决循环依赖的方案了：Spring 在创建 bean 的时候并不是等它完全完成，而是在创建过程中将创建中的 bean 的 ObjectFactory 提前曝光（即加入到 singletonFactories 缓存中），这样一旦下一个 bean 创建的时候需要依赖 bean ，则直接使用 ObjectFactory 的 `getObject()` 获取了，也就是 `getSingleton()` 中的代码片段了。\n\n到这里，关于 Spring 解决 bean 循环依赖就已经分析完毕了。最后来描述下就上面那个循环依赖 Spring 解决的过程：首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来，然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来，这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)，这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories ），通过 ObjectFactory 提前曝光，所以可以通过 `ObjectFactory.getObject()` 拿到 A 对象，C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中，回到 B ，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了。\n\n通过上面的介绍，你或与已经明白了，为什么Prototype scope范围内的bean不处理循环依赖，是因为这种类型的bean不能缓存，也就不能提前曝光，所以也就没有办法成功创建其中任何一个bean，就无法打破这个环。","source":"_posts/spring 源码分析/spring/spring源码解析之 24循环依赖处理.md","raw":"abbrlink: 45\ntitle: spring源码解析之 24循环依赖处理\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-15 03:38:00\n---\n# spring源码解析之 24 循环依赖处理\n\n这篇分析 `doCreateBean()` 第三个过程：循环依赖处理。其实循环依赖并不仅仅只是在 `doCreateBean()` 中处理，其实在整个加载 bean 的过程中都有涉及，所以下篇内容并不仅仅只局限于 `doCreateBean()`，而是从整个 Bean 的加载过程进行分析。\n<!-- more -->\n\n## 什么是循环依赖\n\n循环依赖其实就是循环引用，就是两个或者两个以上的 bean 互相引用对方，最终形成一个闭环，如 A 依赖 B，B 依赖 C，C 依赖 A，如下：\n\n![upload successful](/images/pasted-13.png)\n\n循环依赖 其实就是一个死循环的过程，在初始化 A 的时候发现引用了 B，这时就会去初始化 B，然后又发现 B 引用 C，跑去初始化 C，初始化 C 的时候发现引用了 A，则又会去初始化 A，依次循环永不退出，除非有终结条件。\n\nSpring 循环依赖的场景有两种：\n\n1. 构造器的循环依赖\n2. field 属性的循环依赖\n\n对于构造器的循环依赖，Spring 是无法解决的，只能抛出 BeanCurrentlyInCreationException 异常表示循环依赖，所以下面我们分析的都是基于 field 属性的循环依赖。\n\nSpring 只解决 scope 为 singleton 的循环依赖，对于scope 为 prototype 的 bean Spring 无法解决，直接抛出 BeanCurrentlyInCreationException 异常。为什么 Spring 不处理 prototype bean，其实如果理解 Spring 是如何解决 singleton bean 的循环依赖就明白了。这里先卖一个关子，我们先来关注 Spring 是如何解决 singleton bean 的循环依赖的。\n\n## 解决循环依赖\n\n我们先从加载 bean 最初始的方法 `doGetBean()` 开始。\n\n在 `doGetBean()` 中，首先会根据 beanName 从单例 bean 缓存中获取，如果不为空则直接返回。\n\n```java\nObject sharedInstance = getSingleton(beanName);\n```\n\n调用 `getSingleton()` 方法从单例缓存中获取，如下：\n\n```java\n    protected Object getSingleton(String beanName, boolean allowEarlyReference) {\n        Object singletonObject = this.singletonObjects.get(beanName);\n        if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n            synchronized (this.singletonObjects) {\n                singletonObject = this.earlySingletonObjects.get(beanName);\n                if (singletonObject == null && allowEarlyReference) {\n                    ObjectFactory<?> singletonFactory = \n                        this.singletonFactories.get(beanName);\n                    if (singletonFactory != null) {\n                        singletonObject = singletonFactory.getObject();\n                        this.earlySingletonObjects.put(beanName, singletonObject);\n                        this.singletonFactories.remove(beanName);\n                    }\n                }\n            }\n        }\n        return singletonObject;\n    }\n```\n\n这个方法主要是从三个缓存中获取，分别是：singletonObjects、earlySingletonObjects、singletonFactories，三者定义如下：\n\n```java\n    /** Cache of singleton objects: bean name --> bean instance */\n    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);\n\n    /** Cache of singleton factories: bean name --> ObjectFactory */\n    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);\n\n    /** Cache of early singleton objects: bean name --> bean instance */\n    private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);\n```\n\n意义如下：\n\n- singletonObjects：单例对象的cache\n- singletonFactories ： 单例对象工厂的cache\n- earlySingletonObjects ：提前暴光的单例对象的Cache\n\n他们就是 Spring 解决 singleton bean 的关键因素所在，我称他们为三级缓存，第一级为 singletonObjects，第二级为 earlySingletonObjects，第三级为 singletonFactories。这里我们可以通过 `getSingleton()` 看到他们是如何配合的，这分析该方法之前，提下其中的 `isSingletonCurrentlyInCreation()` 和 `allowEarlyReference`。\n\n- `isSingletonCurrentlyInCreation()`：判断当前 singleton bean 是否处于创建中。bean 处于创建中也就是说 bean 在初始化但是没有完成初始化，前面我们在从缓存从获取单例对象也提到过这个方法。这样的过程其实和 Spring 解决 bean 循环依赖的理念相辅相成，因为 Spring 解决 singleton bean 的核心就在于提前曝光 bean。\n- allowEarlyReference：从字面意思上面理解就是允许提前拿到引用。其实真正的意思是是否允许从 singletonFactories 缓存中通过 `getObject()` 拿到对象，为什么会有这样一个字段呢？原因就在于 singletonFactories 才是 Spring 解决 singleton bean 的诀窍所在，这个我们后续分析。\n\n`getSingleton()` 整个过程如下：首先从一级缓存 singletonObjects 获取，如果没有且当前指定的 beanName 正在创建，就再从二级缓存中 earlySingletonObjects 获取，如果还是没有获取到且运行 singletonFactories 通过 `getObject()` 获取，则从三级缓存 singletonFactories 获取，如果获取到则通过其 `getObject()` 获取对象，并将其加入到二级缓存 earlySingletonObjects 中 从三级缓存 singletonFactories 删除，如下：\n\n```java\nsingletonObject = singletonFactory.getObject();\nthis.earlySingletonObjects.put(beanName, singletonObject);\nthis.singletonFactories.remove(beanName);\n```\n\n这样就从三级缓存升级到二级缓存了。\n\n上面是从缓存中获取，但是缓存中的数据从哪里添加进来的呢？一直往下跟会发现在 `doCreateBean()` ( AbstractAutowireCapableBeanFactory ) 中，有这么一段代码：\n\n```java\nboolean earlySingletonExposure = (mbd.isSingleton() \n                                  && this.allowCircularReferences \n                                  && isSingletonCurrentlyInCreation(beanName));\nif (earlySingletonExposure) {\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Eagerly caching bean '\" + beanName +\n                        \"' to allow for resolving potential circular references\");\n    }\n    addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n}\n```\n\n如果 `earlySingletonExposure == true` 的话，则调用 `addSingletonFactory()` 将他们添加到缓存中，但是一个 bean 要具备如下条件才会添加至缓存中：\n\n- 单例\n- 运行提前暴露 bean\n- 当前 bean 正在创建中\n\n经过上面分析，我们了解添加addSingletonFactory满足什么条件才能调用，但是调用addSingletonFactory起到什么作用呢，我们还是以最简单AB循环依赖为例，类A中含有属性类B，类B中又含有属性A，那么初始化BeanA的过程入下图\n\n![upload successful](/images/pasted-23.png)\n\n![upload successful](/images/pasted-24.png)\n\ncong\n\n`addSingletonFactory()` 代码如下：\n\n```java\n    protected void addSingletonFactory(String beanName,\n                                       ObjectFactory<?> singletonFactory) {\n        Assert.notNull(singletonFactory, \"Singleton factory must not be null\");\n        synchronized (this.singletonObjects) {\n            if (!this.singletonObjects.containsKey(beanName)) {\n                this.singletonFactories.put(beanName, singletonFactory);\n                this.earlySingletonObjects.remove(beanName);\n                this.registeredSingletons.add(beanName);\n            }\n        }\n    }\n```\n\n从这段代码我们可以看出 singletonFactories 这个三级缓存才是解决 Spring Bean 循环依赖的诀窍所在。同时这段代码发生在 `createBeanInstance()` 方法之后，也就是说这个 bean 其实已经被创建出来了，但是它还不是很完美（没有进行属性填充和初始化），但是对于其他依赖它的对象而言已经足够了（可以根据对象引用定位到堆中对象），能够被认出来了，所以 Spring 在这个时候选择将该对象提前曝光出来让大家认识认识。\n\n**getEarlyBeanReference**如下\n\n```java\n\tprotected Object getEarlyBeanReference(String beanName,\n    \tRootBeanDefinition mbd, Object bean) {\n\t\tObject exposedObject = bean;\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (BeanPostProcessor bp : getBeanPostProcessors()) {\n\t\t\t\tif (bp instanceof SmartInstantiationAwareBeanPostProcessor) {\n\t\t\t\t\tSmartInstantiationAwareBeanPostProcessor ibp = \n\t\t\t\t\t(SmartInstantiationAwareBeanPostProcessor) bp;\n\t\t\t\t\texposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn exposedObject;\n\t}\n```\n\n![upload successful](/images/pasted-25.png)\n\n介绍到这里我们发现三级缓存 singletonFactories 和 二级缓存 earlySingletonObjects 中的值都有出处了，那一级缓存在哪里设置的呢？在类 DefaultSingletonBeanRegistry 中可以发现这个 `addSingleton()` 方法，源码如下：\n\n```java\n    protected void addSingleton(String beanName, Object singletonObject) {\n        synchronized (this.singletonObjects) {\n            this.singletonObjects.put(beanName, singletonObject);\n            this.singletonFactories.remove(beanName);\n            this.earlySingletonObjects.remove(beanName);\n            this.registeredSingletons.add(beanName);\n        }\n    }\n```\n\n添加至一级缓存，同时从二级、三级缓存中删除。这个方法在我们创建 bean 的链路中有哪个地方引用呢？其实在前面博客已经提到过了，在 `doGetBean()` 处理不同 scope 时，如果是 singleton，则调用 `getSingleton()`，如下：\n\n```java\n    public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {\n        Assert.notNull(beanName, \"Bean name must not be null\");\n        synchronized (this.singletonObjects) {\n            Object singletonObject = this.singletonObjects.get(beanName);\n            if (singletonObject == null) {\n                //....\n                try {\n                    singletonObject = singletonFactory.getObject();\n                    newSingleton = true;\n                }\n                //.....\n                if (newSingleton) {\n                    addSingleton(beanName, singletonObject);\n                }\n            }\n            return singletonObject;\n        }\n    }\n```\n\n至此，Spring 关于 singleton bean 循环依赖已经分析完毕了。所以我们基本上可以确定 Spring 解决循环依赖的方案了：Spring 在创建 bean 的时候并不是等它完全完成，而是在创建过程中将创建中的 bean 的 ObjectFactory 提前曝光（即加入到 singletonFactories 缓存中），这样一旦下一个 bean 创建的时候需要依赖 bean ，则直接使用 ObjectFactory 的 `getObject()` 获取了，也就是 `getSingleton()` 中的代码片段了。\n\n到这里，关于 Spring 解决 bean 循环依赖就已经分析完毕了。最后来描述下就上面那个循环依赖 Spring 解决的过程：首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来，然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来，这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)，这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories ），通过 ObjectFactory 提前曝光，所以可以通过 `ObjectFactory.getObject()` 拿到 A 对象，C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中，回到 B ，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了。\n\n通过上面的介绍，你或与已经明白了，为什么Prototype scope范围内的bean不处理循环依赖，是因为这种类型的bean不能缓存，也就不能提前曝光，所以也就没有办法成功创建其中任何一个bean，就无法打破这个环。","slug":"spring 源码分析/spring/spring源码解析之 24循环依赖处理","published":1,"updated":"2019-01-16T08:34:49.186Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovwf004v9q1u108ke3gp","content":"<h1 id=\"spring源码解析之-24-循环依赖处理\"><a href=\"#spring源码解析之-24-循环依赖处理\" class=\"headerlink\" title=\"spring源码解析之 24 循环依赖处理\"></a>spring源码解析之 24 循环依赖处理</h1><p>这篇分析 <code>doCreateBean()</code> 第三个过程：循环依赖处理。其实循环依赖并不仅仅只是在 <code>doCreateBean()</code> 中处理，其实在整个加载 bean 的过程中都有涉及，所以下篇内容并不仅仅只局限于 <code>doCreateBean()</code>，而是从整个 Bean 的加载过程进行分析。<br><a id=\"more\"></a></p>\n<h2 id=\"什么是循环依赖\"><a href=\"#什么是循环依赖\" class=\"headerlink\" title=\"什么是循环依赖\"></a>什么是循环依赖</h2><p>循环依赖其实就是循环引用，就是两个或者两个以上的 bean 互相引用对方，最终形成一个闭环，如 A 依赖 B，B 依赖 C，C 依赖 A，如下：</p>\n<p><img src=\"/images/pasted-13.png\" alt=\"upload successful\"></p>\n<p>循环依赖 其实就是一个死循环的过程，在初始化 A 的时候发现引用了 B，这时就会去初始化 B，然后又发现 B 引用 C，跑去初始化 C，初始化 C 的时候发现引用了 A，则又会去初始化 A，依次循环永不退出，除非有终结条件。</p>\n<p>Spring 循环依赖的场景有两种：</p>\n<ol>\n<li>构造器的循环依赖</li>\n<li>field 属性的循环依赖</li>\n</ol>\n<p>对于构造器的循环依赖，Spring 是无法解决的，只能抛出 BeanCurrentlyInCreationException 异常表示循环依赖，所以下面我们分析的都是基于 field 属性的循环依赖。</p>\n<p>Spring 只解决 scope 为 singleton 的循环依赖，对于scope 为 prototype 的 bean Spring 无法解决，直接抛出 BeanCurrentlyInCreationException 异常。为什么 Spring 不处理 prototype bean，其实如果理解 Spring 是如何解决 singleton bean 的循环依赖就明白了。这里先卖一个关子，我们先来关注 Spring 是如何解决 singleton bean 的循环依赖的。</p>\n<h2 id=\"解决循环依赖\"><a href=\"#解决循环依赖\" class=\"headerlink\" title=\"解决循环依赖\"></a>解决循环依赖</h2><p>我们先从加载 bean 最初始的方法 <code>doGetBean()</code> 开始。</p>\n<p>在 <code>doGetBean()</code> 中，首先会根据 beanName 从单例 bean 缓存中获取，如果不为空则直接返回。</p>\n<pre><code class=\"java\">Object sharedInstance = getSingleton(beanName);\n</code></pre>\n<p>调用 <code>getSingleton()</code> 方法从单例缓存中获取，如下：</p>\n<pre><code class=\"java\">    protected Object getSingleton(String beanName, boolean allowEarlyReference) {\n        Object singletonObject = this.singletonObjects.get(beanName);\n        if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {\n            synchronized (this.singletonObjects) {\n                singletonObject = this.earlySingletonObjects.get(beanName);\n                if (singletonObject == null &amp;&amp; allowEarlyReference) {\n                    ObjectFactory&lt;?&gt; singletonFactory = \n                        this.singletonFactories.get(beanName);\n                    if (singletonFactory != null) {\n                        singletonObject = singletonFactory.getObject();\n                        this.earlySingletonObjects.put(beanName, singletonObject);\n                        this.singletonFactories.remove(beanName);\n                    }\n                }\n            }\n        }\n        return singletonObject;\n    }\n</code></pre>\n<p>这个方法主要是从三个缓存中获取，分别是：singletonObjects、earlySingletonObjects、singletonFactories，三者定义如下：</p>\n<pre><code class=\"java\">    /** Cache of singleton objects: bean name --&gt; bean instance */\n    private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);\n\n    /** Cache of singleton factories: bean name --&gt; ObjectFactory */\n    private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);\n\n    /** Cache of early singleton objects: bean name --&gt; bean instance */\n    private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);\n</code></pre>\n<p>意义如下：</p>\n<ul>\n<li>singletonObjects：单例对象的cache</li>\n<li>singletonFactories ： 单例对象工厂的cache</li>\n<li>earlySingletonObjects ：提前暴光的单例对象的Cache</li>\n</ul>\n<p>他们就是 Spring 解决 singleton bean 的关键因素所在，我称他们为三级缓存，第一级为 singletonObjects，第二级为 earlySingletonObjects，第三级为 singletonFactories。这里我们可以通过 <code>getSingleton()</code> 看到他们是如何配合的，这分析该方法之前，提下其中的 <code>isSingletonCurrentlyInCreation()</code> 和 <code>allowEarlyReference</code>。</p>\n<ul>\n<li><code>isSingletonCurrentlyInCreation()</code>：判断当前 singleton bean 是否处于创建中。bean 处于创建中也就是说 bean 在初始化但是没有完成初始化，前面我们在从缓存从获取单例对象也提到过这个方法。这样的过程其实和 Spring 解决 bean 循环依赖的理念相辅相成，因为 Spring 解决 singleton bean 的核心就在于提前曝光 bean。</li>\n<li>allowEarlyReference：从字面意思上面理解就是允许提前拿到引用。其实真正的意思是是否允许从 singletonFactories 缓存中通过 <code>getObject()</code> 拿到对象，为什么会有这样一个字段呢？原因就在于 singletonFactories 才是 Spring 解决 singleton bean 的诀窍所在，这个我们后续分析。</li>\n</ul>\n<p><code>getSingleton()</code> 整个过程如下：首先从一级缓存 singletonObjects 获取，如果没有且当前指定的 beanName 正在创建，就再从二级缓存中 earlySingletonObjects 获取，如果还是没有获取到且运行 singletonFactories 通过 <code>getObject()</code> 获取，则从三级缓存 singletonFactories 获取，如果获取到则通过其 <code>getObject()</code> 获取对象，并将其加入到二级缓存 earlySingletonObjects 中 从三级缓存 singletonFactories 删除，如下：</p>\n<pre><code class=\"java\">singletonObject = singletonFactory.getObject();\nthis.earlySingletonObjects.put(beanName, singletonObject);\nthis.singletonFactories.remove(beanName);\n</code></pre>\n<p>这样就从三级缓存升级到二级缓存了。</p>\n<p>上面是从缓存中获取，但是缓存中的数据从哪里添加进来的呢？一直往下跟会发现在 <code>doCreateBean()</code> ( AbstractAutowireCapableBeanFactory ) 中，有这么一段代码：</p>\n<pre><code class=\"java\">boolean earlySingletonExposure = (mbd.isSingleton() \n                                  &amp;&amp; this.allowCircularReferences \n                                  &amp;&amp; isSingletonCurrentlyInCreation(beanName));\nif (earlySingletonExposure) {\n    if (logger.isDebugEnabled()) {\n        logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +\n                        &quot;&#39; to allow for resolving potential circular references&quot;);\n    }\n    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n}\n</code></pre>\n<p>如果 <code>earlySingletonExposure == true</code> 的话，则调用 <code>addSingletonFactory()</code> 将他们添加到缓存中，但是一个 bean 要具备如下条件才会添加至缓存中：</p>\n<ul>\n<li>单例</li>\n<li>运行提前暴露 bean</li>\n<li>当前 bean 正在创建中</li>\n</ul>\n<p>经过上面分析，我们了解添加addSingletonFactory满足什么条件才能调用，但是调用addSingletonFactory起到什么作用呢，我们还是以最简单AB循环依赖为例，类A中含有属性类B，类B中又含有属性A，那么初始化BeanA的过程入下图</p>\n<p><img src=\"/images/pasted-23.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-24.png\" alt=\"upload successful\"></p>\n<p>cong</p>\n<p><code>addSingletonFactory()</code> 代码如下：</p>\n<pre><code class=\"java\">    protected void addSingletonFactory(String beanName,\n                                       ObjectFactory&lt;?&gt; singletonFactory) {\n        Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);\n        synchronized (this.singletonObjects) {\n            if (!this.singletonObjects.containsKey(beanName)) {\n                this.singletonFactories.put(beanName, singletonFactory);\n                this.earlySingletonObjects.remove(beanName);\n                this.registeredSingletons.add(beanName);\n            }\n        }\n    }\n</code></pre>\n<p>从这段代码我们可以看出 singletonFactories 这个三级缓存才是解决 Spring Bean 循环依赖的诀窍所在。同时这段代码发生在 <code>createBeanInstance()</code> 方法之后，也就是说这个 bean 其实已经被创建出来了，但是它还不是很完美（没有进行属性填充和初始化），但是对于其他依赖它的对象而言已经足够了（可以根据对象引用定位到堆中对象），能够被认出来了，所以 Spring 在这个时候选择将该对象提前曝光出来让大家认识认识。</p>\n<p><strong>getEarlyBeanReference</strong>如下</p>\n<pre><code class=\"java\">    protected Object getEarlyBeanReference(String beanName,\n        RootBeanDefinition mbd, Object bean) {\n        Object exposedObject = bean;\n        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {\n                    SmartInstantiationAwareBeanPostProcessor ibp = \n                    (SmartInstantiationAwareBeanPostProcessor) bp;\n                    exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);\n                }\n            }\n        }\n        return exposedObject;\n    }\n</code></pre>\n<p><img src=\"/images/pasted-25.png\" alt=\"upload successful\"></p>\n<p>介绍到这里我们发现三级缓存 singletonFactories 和 二级缓存 earlySingletonObjects 中的值都有出处了，那一级缓存在哪里设置的呢？在类 DefaultSingletonBeanRegistry 中可以发现这个 <code>addSingleton()</code> 方法，源码如下：</p>\n<pre><code class=\"java\">    protected void addSingleton(String beanName, Object singletonObject) {\n        synchronized (this.singletonObjects) {\n            this.singletonObjects.put(beanName, singletonObject);\n            this.singletonFactories.remove(beanName);\n            this.earlySingletonObjects.remove(beanName);\n            this.registeredSingletons.add(beanName);\n        }\n    }\n</code></pre>\n<p>添加至一级缓存，同时从二级、三级缓存中删除。这个方法在我们创建 bean 的链路中有哪个地方引用呢？其实在前面博客已经提到过了，在 <code>doGetBean()</code> 处理不同 scope 时，如果是 singleton，则调用 <code>getSingleton()</code>，如下：</p>\n<pre><code class=\"java\">    public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {\n        Assert.notNull(beanName, &quot;Bean name must not be null&quot;);\n        synchronized (this.singletonObjects) {\n            Object singletonObject = this.singletonObjects.get(beanName);\n            if (singletonObject == null) {\n                //....\n                try {\n                    singletonObject = singletonFactory.getObject();\n                    newSingleton = true;\n                }\n                //.....\n                if (newSingleton) {\n                    addSingleton(beanName, singletonObject);\n                }\n            }\n            return singletonObject;\n        }\n    }\n</code></pre>\n<p>至此，Spring 关于 singleton bean 循环依赖已经分析完毕了。所以我们基本上可以确定 Spring 解决循环依赖的方案了：Spring 在创建 bean 的时候并不是等它完全完成，而是在创建过程中将创建中的 bean 的 ObjectFactory 提前曝光（即加入到 singletonFactories 缓存中），这样一旦下一个 bean 创建的时候需要依赖 bean ，则直接使用 ObjectFactory 的 <code>getObject()</code> 获取了，也就是 <code>getSingleton()</code> 中的代码片段了。</p>\n<p>到这里，关于 Spring 解决 bean 循环依赖就已经分析完毕了。最后来描述下就上面那个循环依赖 Spring 解决的过程：首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来，然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来，这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)，这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories ），通过 ObjectFactory 提前曝光，所以可以通过 <code>ObjectFactory.getObject()</code> 拿到 A 对象，C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中，回到 B ，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了。</p>\n<p>通过上面的介绍，你或与已经明白了，为什么Prototype scope范围内的bean不处理循环依赖，是因为这种类型的bean不能缓存，也就不能提前曝光，所以也就没有办法成功创建其中任何一个bean，就无法打破这个环。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-24-循环依赖处理\"><a href=\"#spring源码解析之-24-循环依赖处理\" class=\"headerlink\" title=\"spring源码解析之 24 循环依赖处理\"></a>spring源码解析之 24 循环依赖处理</h1><p>这篇分析 <code>doCreateBean()</code> 第三个过程：循环依赖处理。其实循环依赖并不仅仅只是在 <code>doCreateBean()</code> 中处理，其实在整个加载 bean 的过程中都有涉及，所以下篇内容并不仅仅只局限于 <code>doCreateBean()</code>，而是从整个 Bean 的加载过程进行分析。<br>","more":"</p>\n<h2 id=\"什么是循环依赖\"><a href=\"#什么是循环依赖\" class=\"headerlink\" title=\"什么是循环依赖\"></a>什么是循环依赖</h2><p>循环依赖其实就是循环引用，就是两个或者两个以上的 bean 互相引用对方，最终形成一个闭环，如 A 依赖 B，B 依赖 C，C 依赖 A，如下：</p>\n<p><img src=\"/images/pasted-13.png\" alt=\"upload successful\"></p>\n<p>循环依赖 其实就是一个死循环的过程，在初始化 A 的时候发现引用了 B，这时就会去初始化 B，然后又发现 B 引用 C，跑去初始化 C，初始化 C 的时候发现引用了 A，则又会去初始化 A，依次循环永不退出，除非有终结条件。</p>\n<p>Spring 循环依赖的场景有两种：</p>\n<ol>\n<li>构造器的循环依赖</li>\n<li>field 属性的循环依赖</li>\n</ol>\n<p>对于构造器的循环依赖，Spring 是无法解决的，只能抛出 BeanCurrentlyInCreationException 异常表示循环依赖，所以下面我们分析的都是基于 field 属性的循环依赖。</p>\n<p>Spring 只解决 scope 为 singleton 的循环依赖，对于scope 为 prototype 的 bean Spring 无法解决，直接抛出 BeanCurrentlyInCreationException 异常。为什么 Spring 不处理 prototype bean，其实如果理解 Spring 是如何解决 singleton bean 的循环依赖就明白了。这里先卖一个关子，我们先来关注 Spring 是如何解决 singleton bean 的循环依赖的。</p>\n<h2 id=\"解决循环依赖\"><a href=\"#解决循环依赖\" class=\"headerlink\" title=\"解决循环依赖\"></a>解决循环依赖</h2><p>我们先从加载 bean 最初始的方法 <code>doGetBean()</code> 开始。</p>\n<p>在 <code>doGetBean()</code> 中，首先会根据 beanName 从单例 bean 缓存中获取，如果不为空则直接返回。</p>\n<pre><code class=\"java\">Object sharedInstance = getSingleton(beanName);\n</code></pre>\n<p>调用 <code>getSingleton()</code> 方法从单例缓存中获取，如下：</p>\n<pre><code class=\"java\">    protected Object getSingleton(String beanName, boolean allowEarlyReference) {\n        Object singletonObject = this.singletonObjects.get(beanName);\n        if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {\n            synchronized (this.singletonObjects) {\n                singletonObject = this.earlySingletonObjects.get(beanName);\n                if (singletonObject == null &amp;&amp; allowEarlyReference) {\n                    ObjectFactory&lt;?&gt; singletonFactory = \n                        this.singletonFactories.get(beanName);\n                    if (singletonFactory != null) {\n                        singletonObject = singletonFactory.getObject();\n                        this.earlySingletonObjects.put(beanName, singletonObject);\n                        this.singletonFactories.remove(beanName);\n                    }\n                }\n            }\n        }\n        return singletonObject;\n    }\n</code></pre>\n<p>这个方法主要是从三个缓存中获取，分别是：singletonObjects、earlySingletonObjects、singletonFactories，三者定义如下：</p>\n<pre><code class=\"java\">    /** Cache of singleton objects: bean name --&gt; bean instance */\n    private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);\n\n    /** Cache of singleton factories: bean name --&gt; ObjectFactory */\n    private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);\n\n    /** Cache of early singleton objects: bean name --&gt; bean instance */\n    private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);\n</code></pre>\n<p>意义如下：</p>\n<ul>\n<li>singletonObjects：单例对象的cache</li>\n<li>singletonFactories ： 单例对象工厂的cache</li>\n<li>earlySingletonObjects ：提前暴光的单例对象的Cache</li>\n</ul>\n<p>他们就是 Spring 解决 singleton bean 的关键因素所在，我称他们为三级缓存，第一级为 singletonObjects，第二级为 earlySingletonObjects，第三级为 singletonFactories。这里我们可以通过 <code>getSingleton()</code> 看到他们是如何配合的，这分析该方法之前，提下其中的 <code>isSingletonCurrentlyInCreation()</code> 和 <code>allowEarlyReference</code>。</p>\n<ul>\n<li><code>isSingletonCurrentlyInCreation()</code>：判断当前 singleton bean 是否处于创建中。bean 处于创建中也就是说 bean 在初始化但是没有完成初始化，前面我们在从缓存从获取单例对象也提到过这个方法。这样的过程其实和 Spring 解决 bean 循环依赖的理念相辅相成，因为 Spring 解决 singleton bean 的核心就在于提前曝光 bean。</li>\n<li>allowEarlyReference：从字面意思上面理解就是允许提前拿到引用。其实真正的意思是是否允许从 singletonFactories 缓存中通过 <code>getObject()</code> 拿到对象，为什么会有这样一个字段呢？原因就在于 singletonFactories 才是 Spring 解决 singleton bean 的诀窍所在，这个我们后续分析。</li>\n</ul>\n<p><code>getSingleton()</code> 整个过程如下：首先从一级缓存 singletonObjects 获取，如果没有且当前指定的 beanName 正在创建，就再从二级缓存中 earlySingletonObjects 获取，如果还是没有获取到且运行 singletonFactories 通过 <code>getObject()</code> 获取，则从三级缓存 singletonFactories 获取，如果获取到则通过其 <code>getObject()</code> 获取对象，并将其加入到二级缓存 earlySingletonObjects 中 从三级缓存 singletonFactories 删除，如下：</p>\n<pre><code class=\"java\">singletonObject = singletonFactory.getObject();\nthis.earlySingletonObjects.put(beanName, singletonObject);\nthis.singletonFactories.remove(beanName);\n</code></pre>\n<p>这样就从三级缓存升级到二级缓存了。</p>\n<p>上面是从缓存中获取，但是缓存中的数据从哪里添加进来的呢？一直往下跟会发现在 <code>doCreateBean()</code> ( AbstractAutowireCapableBeanFactory ) 中，有这么一段代码：</p>\n<pre><code class=\"java\">boolean earlySingletonExposure = (mbd.isSingleton() \n                                  &amp;&amp; this.allowCircularReferences \n                                  &amp;&amp; isSingletonCurrentlyInCreation(beanName));\nif (earlySingletonExposure) {\n    if (logger.isDebugEnabled()) {\n        logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +\n                        &quot;&#39; to allow for resolving potential circular references&quot;);\n    }\n    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n}\n</code></pre>\n<p>如果 <code>earlySingletonExposure == true</code> 的话，则调用 <code>addSingletonFactory()</code> 将他们添加到缓存中，但是一个 bean 要具备如下条件才会添加至缓存中：</p>\n<ul>\n<li>单例</li>\n<li>运行提前暴露 bean</li>\n<li>当前 bean 正在创建中</li>\n</ul>\n<p>经过上面分析，我们了解添加addSingletonFactory满足什么条件才能调用，但是调用addSingletonFactory起到什么作用呢，我们还是以最简单AB循环依赖为例，类A中含有属性类B，类B中又含有属性A，那么初始化BeanA的过程入下图</p>\n<p><img src=\"/images/pasted-23.png\" alt=\"upload successful\"></p>\n<p><img src=\"/images/pasted-24.png\" alt=\"upload successful\"></p>\n<p>cong</p>\n<p><code>addSingletonFactory()</code> 代码如下：</p>\n<pre><code class=\"java\">    protected void addSingletonFactory(String beanName,\n                                       ObjectFactory&lt;?&gt; singletonFactory) {\n        Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);\n        synchronized (this.singletonObjects) {\n            if (!this.singletonObjects.containsKey(beanName)) {\n                this.singletonFactories.put(beanName, singletonFactory);\n                this.earlySingletonObjects.remove(beanName);\n                this.registeredSingletons.add(beanName);\n            }\n        }\n    }\n</code></pre>\n<p>从这段代码我们可以看出 singletonFactories 这个三级缓存才是解决 Spring Bean 循环依赖的诀窍所在。同时这段代码发生在 <code>createBeanInstance()</code> 方法之后，也就是说这个 bean 其实已经被创建出来了，但是它还不是很完美（没有进行属性填充和初始化），但是对于其他依赖它的对象而言已经足够了（可以根据对象引用定位到堆中对象），能够被认出来了，所以 Spring 在这个时候选择将该对象提前曝光出来让大家认识认识。</p>\n<p><strong>getEarlyBeanReference</strong>如下</p>\n<pre><code class=\"java\">    protected Object getEarlyBeanReference(String beanName,\n        RootBeanDefinition mbd, Object bean) {\n        Object exposedObject = bean;\n        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {\n                    SmartInstantiationAwareBeanPostProcessor ibp = \n                    (SmartInstantiationAwareBeanPostProcessor) bp;\n                    exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);\n                }\n            }\n        }\n        return exposedObject;\n    }\n</code></pre>\n<p><img src=\"/images/pasted-25.png\" alt=\"upload successful\"></p>\n<p>介绍到这里我们发现三级缓存 singletonFactories 和 二级缓存 earlySingletonObjects 中的值都有出处了，那一级缓存在哪里设置的呢？在类 DefaultSingletonBeanRegistry 中可以发现这个 <code>addSingleton()</code> 方法，源码如下：</p>\n<pre><code class=\"java\">    protected void addSingleton(String beanName, Object singletonObject) {\n        synchronized (this.singletonObjects) {\n            this.singletonObjects.put(beanName, singletonObject);\n            this.singletonFactories.remove(beanName);\n            this.earlySingletonObjects.remove(beanName);\n            this.registeredSingletons.add(beanName);\n        }\n    }\n</code></pre>\n<p>添加至一级缓存，同时从二级、三级缓存中删除。这个方法在我们创建 bean 的链路中有哪个地方引用呢？其实在前面博客已经提到过了，在 <code>doGetBean()</code> 处理不同 scope 时，如果是 singleton，则调用 <code>getSingleton()</code>，如下：</p>\n<pre><code class=\"java\">    public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {\n        Assert.notNull(beanName, &quot;Bean name must not be null&quot;);\n        synchronized (this.singletonObjects) {\n            Object singletonObject = this.singletonObjects.get(beanName);\n            if (singletonObject == null) {\n                //....\n                try {\n                    singletonObject = singletonFactory.getObject();\n                    newSingleton = true;\n                }\n                //.....\n                if (newSingleton) {\n                    addSingleton(beanName, singletonObject);\n                }\n            }\n            return singletonObject;\n        }\n    }\n</code></pre>\n<p>至此，Spring 关于 singleton bean 循环依赖已经分析完毕了。所以我们基本上可以确定 Spring 解决循环依赖的方案了：Spring 在创建 bean 的时候并不是等它完全完成，而是在创建过程中将创建中的 bean 的 ObjectFactory 提前曝光（即加入到 singletonFactories 缓存中），这样一旦下一个 bean 创建的时候需要依赖 bean ，则直接使用 ObjectFactory 的 <code>getObject()</code> 获取了，也就是 <code>getSingleton()</code> 中的代码片段了。</p>\n<p>到这里，关于 Spring 解决 bean 循环依赖就已经分析完毕了。最后来描述下就上面那个循环依赖 Spring 解决的过程：首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来，然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来，这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)，这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories ），通过 ObjectFactory 提前曝光，所以可以通过 <code>ObjectFactory.getObject()</code> 拿到 A 对象，C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中，回到 B ，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了。</p>\n<p>通过上面的介绍，你或与已经明白了，为什么Prototype scope范围内的bean不处理循环依赖，是因为这种类型的bean不能缓存，也就不能提前曝光，所以也就没有办法成功创建其中任何一个bean，就无法打破这个环。</p>"},{"abbrlink":46,"title":"spring源码解析之 25bean的初始化","author":"fengxiutianya","date":"2019-01-14T19:57:00.000Z","_content":"# spring源码解析之 25bean的初始化\n\n前面我们已经分析了bean的创建，属性的注入，依赖处理，其实这时bean基本上已经可以用了，不知道你还记不记得我们在xml中还可以配置init-method属性，这个到现在为止还没有处理，这就是最后一步初始化，也就是 `initializeBean()`，所以这篇文章我们分析 `doCreateBean()` 中最后一步：初始化 bean。\n<!-- more -->\n```java\n    protected Object initializeBean(final String beanName, final Object bean, \n                                    @Nullable RootBeanDefinition mbd) {\n        // 这个判断现在可以不理，主要是为了安全，重点是invokeAwareMethods方法\n        if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n                invokeAwareMethods(beanName, bean);\n                return null;\n            }, getAccessControlContext());\n        }\n        else {\n            // / 激活 Aware 方法，对特殊的 bean 处理：\n            // Aware、BeanClassLoaderAware、BeanFactoryAware\n            invokeAwareMethods(beanName, bean);\n        }\n        Object wrappedBean = bean;\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 在调用init-method之前的处理\n            wrappedBean = \n                applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n        }\n\n        try {\n            // 激活用户自定义的 init 方法\n            invokeInitMethods(beanName, wrappedBean, mbd);\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(\n                    (mbd != null ? mbd.getResourceDescription() : null),\n                    beanName, \"Invocation of init method failed\", ex);\n        }\n        if (mbd == null || !mbd.isSynthetic()) {\n            // bean调用init-method之后的处理\n            wrappedBean = \n                applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n        }\n        return wrappedBean;\n    }\n```\n\n初始化 bean 的方法其实就是三个步骤的处理，而这三个步骤主要还是根据用户设定的来进行初始化，这三个过程为：\n\n1. 激活 Aware 方法\n2. 后置处理器的应用\n3. 激活自定义的 init 方法\n\n**激活 Aware 方法**\n\nAware ,英文翻译是意识到的，感知的，Spring 提供了诸多 Aware 接口用于辅助 Spring Bean 以编程的方式调用 Spring 容器，通过实现这些接口，可以增强 Spring Bean 的功能。\n\nSpring 提供了如下系列的 Aware 接口：\n\n- LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ\n- BeanClassLoaderAware：加载Spring Bean的类加载器\n- BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI\n- ResourceLoaderAware：底层访问资源的加载器\n- BeanFactoryAware：声明BeanFactory\n- PortletConfigAware：PortletConfig\n- PortletContextAware：PortletContext\n- ServletConfigAware：ServletConfig\n- ServletContextAware：ServletContext\n- MessageSourceAware：国际化\n- ApplicationEventPublisherAware：应用事件\n- NotificationPublisherAware：JMX通知\n- BeanNameAware：声明Spring Bean的名字\n\n`invokeAwareMethods()` 源码如下：\n\n```java\n    private void invokeAwareMethods(final String beanName, final Object bean) {\n        if (bean instanceof Aware) {\n            // 注入beanname\n            if (bean instanceof BeanNameAware) {\n                ((BeanNameAware) bean).setBeanName(beanName);\n            }\n            // 注入类加载器\n            if (bean instanceof BeanClassLoaderAware) {\n                ClassLoader bcl = getBeanClassLoader();\n                if (bcl != null) {\n                    ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);\n                }\n            }\n            // 注入beanFactory\n            if (bean instanceof BeanFactoryAware) {\n                ((BeanFactoryAware) bean)\n                \t.setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n            }\n        }\n    }\n```\n\n这里代码就没有什么好说的，主要是处理 BeanNameAware、BeanClassLoaderAware、BeanFactoryAware。关于 Aware 接口，后面会专门出篇文章对其进行详细分析说明的。\n\n**后置处理器的应用**\n\nBeanPostProcessor 在前面介绍 bean 加载的过程曾多次遇到，相信各位不陌生，这是 Spring 中开放式框架中必不可少的一个亮点。BeanPostProcessor 的作用是：如果我们想要在 Spring 容器完成 Bean 的实例化，配置和其他的初始化后添加一些自己的逻辑处理，那么请使用该接口，这个接口给与了用户充足的权限去更改或者扩展 Spring，是我们对 Spring 进行扩展和增强处理一个必不可少的接口。\n\n```java\n    public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, \n                                 String beanName) throws BeansException {\n\n        Object result = existingBean;\n        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n            Object current = beanProcessor.postProcessBeforeInitialization(result, \n                                                                           beanName);\n            if (current == null) {\n                return result;\n            }\n            result = current;\n        }\n        return result;\n    }\n\n    @Override\n    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, \n                               String beanName) throws BeansException {\n\n        Object result = existingBean;\n        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n            Object current = beanProcessor.postProcessAfterInitialization(result, \n                                                                          beanName);\n            if (current == null) {\n                return result;\n            }\n            result = current;\n        }\n        return result;\n    }\n```\n\n其实逻辑就是通过 `getBeanPostProcessors()` 获取定义的 BeanPostProcessor ，然后分别调用其 `postProcessBeforeInitialization()`、`postProcessAfterInitialization()` 进行业务处理。\n\n**激活自定义的 init 方法**\n\n如果熟悉 `<bean>` 标签的配置，一定不会忘记 `init-method` 方法，该方法的执行就是在这里执行的。\n\n```java\n   protected void invokeInitMethods(String beanName, final Object bean, \n                                    @Nullable RootBeanDefinition mbd)\n            throws Throwable {\n        // 首先会检查是否是 InitializingBean ，如果是的话需要调用 afterPropertiesSet()\n        boolean isInitializingBean = (bean instanceof InitializingBean);\n        if (isInitializingBean && \n            (mbd == null || !mbd.isExternallyManagedInitMethod(\"afterPropertiesSet\"))) \n        {\n            if (logger.isDebugEnabled()) {\n              \t// 省略日志\n            }\n            if (System.getSecurityManager() != null) {\n                try {\n                    AccessController.doPrivileged((PrivilegedExceptionAction<Object>) \n                                                  () -> {\n                        ((InitializingBean) bean).afterPropertiesSet();\n                        return null;\n                    }, getAccessControlContext());\n                }\n                catch (PrivilegedActionException pae) {\n                    throw pae.getException();\n                }\n            }\n            else {\n                // 属性初始化的处理\n                ((InitializingBean) bean).afterPropertiesSet();\n            }\n        }\n\n        if (mbd != null && bean.getClass() != NullBean.class) {\n            String initMethodName = mbd.getInitMethodName();\n            if (StringUtils.hasLength(initMethodName) &&\n                    !(isInitializingBean && \n                      \"afterPropertiesSet\".equals(initMethodName)) &&\n                    !mbd.isExternallyManagedInitMethod(initMethodName)) {\n                // 激活用户自定义的 初始化方法\n                invokeCustomInitMethod(beanName, bean, mbd);\n            }\n        }\n    }\n```\n\n首先检查是否为 InitializingBean ，如果是的话需要执行 `afterPropertiesSet()`，因为我们除了可以使用 `init-method`来自定初始化方法外，还可以实现 InitializingBean 接口，该接口仅有一个 `afterPropertiesSet()` 方法，而两者的执行先后顺序是先 `afterPropertiesSet()` 后 `init-method`。\n\n**注册DisposableBean**\n\nspring中不但提供了对于初始化方法的扩展入口同样也提供了销毁方法的扩展入口，对于销毁方法的扩展，处理我们熟知的配置属性destroy-method方法外，用户还可以注册后处理器DestructionAwareBeanpostProcessor来统一处理bean的销毁方法，具体代码如下\n\n```java\nprotected void registerDisposableBeanIfNecessary(String beanName, Object bean, \n                                                 RootBeanDefinition mbd) {\n\t\tAccessControlContext acc = (System.getSecurityManager() != null ? \n                                    getAccessControlContext() : null);\n    \n\t\tif (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {\n            // 单例bean的注册销毁\n\t\t\tif (mbd.isSingleton()) {\n                // 在bean销毁之前调用这个destroy-method\n\t\t\t\tregisterDisposableBean(beanName,\n\t\t\t\t\t\tnew DisposableBeanAdapter(bean, beanName, mbd, \n                                                  getBeanPostProcessors(), acc));\n            // 其他scope bean的注册销毁\n\t\t\t} else {\n\t\t\t\tScope scope = this.scopes.get(mbd.getScope());\n\t\t\t\tif (scope == null) {\n\t\t\t\t\t\t// 抛出异常省略\n\t\t\t\t}\n\t\t\t\tscope.registerDestructionCallback(beanName,\n\t\t\t\t\t\tnew DisposableBeanAdapter(bean, beanName, mbd, \n                                                  getBeanPostProcessors(), acc));\n\t\t\t}\n\t\t}\n\t}\n```\n\n其实这个销毁方法对于单例bean来说，扩展在这里我感觉是没有多大作用，因为单例bean的销毁是随着整个容器而销毁，而整个容器的销毁也代表者这个应用销毁，不起作用所以这里掉不掉用销毁方法已经没什么作用。对于其他的scope，是可以起作用的，类如request，session的scope是可以在里面加入一些定制化的逻辑。后面分析springMVC时会具体说道。","source":"_posts/spring 源码分析/spring/spring源码解析之 25bean的初始化.md","raw":"abbrlink: 46\ntitle: spring源码解析之 25bean的初始化\ntags:\n  - spring\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-15 03:57:00\n---\n# spring源码解析之 25bean的初始化\n\n前面我们已经分析了bean的创建，属性的注入，依赖处理，其实这时bean基本上已经可以用了，不知道你还记不记得我们在xml中还可以配置init-method属性，这个到现在为止还没有处理，这就是最后一步初始化，也就是 `initializeBean()`，所以这篇文章我们分析 `doCreateBean()` 中最后一步：初始化 bean。\n<!-- more -->\n```java\n    protected Object initializeBean(final String beanName, final Object bean, \n                                    @Nullable RootBeanDefinition mbd) {\n        // 这个判断现在可以不理，主要是为了安全，重点是invokeAwareMethods方法\n        if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n                invokeAwareMethods(beanName, bean);\n                return null;\n            }, getAccessControlContext());\n        }\n        else {\n            // / 激活 Aware 方法，对特殊的 bean 处理：\n            // Aware、BeanClassLoaderAware、BeanFactoryAware\n            invokeAwareMethods(beanName, bean);\n        }\n        Object wrappedBean = bean;\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 在调用init-method之前的处理\n            wrappedBean = \n                applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n        }\n\n        try {\n            // 激活用户自定义的 init 方法\n            invokeInitMethods(beanName, wrappedBean, mbd);\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(\n                    (mbd != null ? mbd.getResourceDescription() : null),\n                    beanName, \"Invocation of init method failed\", ex);\n        }\n        if (mbd == null || !mbd.isSynthetic()) {\n            // bean调用init-method之后的处理\n            wrappedBean = \n                applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n        }\n        return wrappedBean;\n    }\n```\n\n初始化 bean 的方法其实就是三个步骤的处理，而这三个步骤主要还是根据用户设定的来进行初始化，这三个过程为：\n\n1. 激活 Aware 方法\n2. 后置处理器的应用\n3. 激活自定义的 init 方法\n\n**激活 Aware 方法**\n\nAware ,英文翻译是意识到的，感知的，Spring 提供了诸多 Aware 接口用于辅助 Spring Bean 以编程的方式调用 Spring 容器，通过实现这些接口，可以增强 Spring Bean 的功能。\n\nSpring 提供了如下系列的 Aware 接口：\n\n- LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ\n- BeanClassLoaderAware：加载Spring Bean的类加载器\n- BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI\n- ResourceLoaderAware：底层访问资源的加载器\n- BeanFactoryAware：声明BeanFactory\n- PortletConfigAware：PortletConfig\n- PortletContextAware：PortletContext\n- ServletConfigAware：ServletConfig\n- ServletContextAware：ServletContext\n- MessageSourceAware：国际化\n- ApplicationEventPublisherAware：应用事件\n- NotificationPublisherAware：JMX通知\n- BeanNameAware：声明Spring Bean的名字\n\n`invokeAwareMethods()` 源码如下：\n\n```java\n    private void invokeAwareMethods(final String beanName, final Object bean) {\n        if (bean instanceof Aware) {\n            // 注入beanname\n            if (bean instanceof BeanNameAware) {\n                ((BeanNameAware) bean).setBeanName(beanName);\n            }\n            // 注入类加载器\n            if (bean instanceof BeanClassLoaderAware) {\n                ClassLoader bcl = getBeanClassLoader();\n                if (bcl != null) {\n                    ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);\n                }\n            }\n            // 注入beanFactory\n            if (bean instanceof BeanFactoryAware) {\n                ((BeanFactoryAware) bean)\n                \t.setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n            }\n        }\n    }\n```\n\n这里代码就没有什么好说的，主要是处理 BeanNameAware、BeanClassLoaderAware、BeanFactoryAware。关于 Aware 接口，后面会专门出篇文章对其进行详细分析说明的。\n\n**后置处理器的应用**\n\nBeanPostProcessor 在前面介绍 bean 加载的过程曾多次遇到，相信各位不陌生，这是 Spring 中开放式框架中必不可少的一个亮点。BeanPostProcessor 的作用是：如果我们想要在 Spring 容器完成 Bean 的实例化，配置和其他的初始化后添加一些自己的逻辑处理，那么请使用该接口，这个接口给与了用户充足的权限去更改或者扩展 Spring，是我们对 Spring 进行扩展和增强处理一个必不可少的接口。\n\n```java\n    public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, \n                                 String beanName) throws BeansException {\n\n        Object result = existingBean;\n        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n            Object current = beanProcessor.postProcessBeforeInitialization(result, \n                                                                           beanName);\n            if (current == null) {\n                return result;\n            }\n            result = current;\n        }\n        return result;\n    }\n\n    @Override\n    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, \n                               String beanName) throws BeansException {\n\n        Object result = existingBean;\n        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n            Object current = beanProcessor.postProcessAfterInitialization(result, \n                                                                          beanName);\n            if (current == null) {\n                return result;\n            }\n            result = current;\n        }\n        return result;\n    }\n```\n\n其实逻辑就是通过 `getBeanPostProcessors()` 获取定义的 BeanPostProcessor ，然后分别调用其 `postProcessBeforeInitialization()`、`postProcessAfterInitialization()` 进行业务处理。\n\n**激活自定义的 init 方法**\n\n如果熟悉 `<bean>` 标签的配置，一定不会忘记 `init-method` 方法，该方法的执行就是在这里执行的。\n\n```java\n   protected void invokeInitMethods(String beanName, final Object bean, \n                                    @Nullable RootBeanDefinition mbd)\n            throws Throwable {\n        // 首先会检查是否是 InitializingBean ，如果是的话需要调用 afterPropertiesSet()\n        boolean isInitializingBean = (bean instanceof InitializingBean);\n        if (isInitializingBean && \n            (mbd == null || !mbd.isExternallyManagedInitMethod(\"afterPropertiesSet\"))) \n        {\n            if (logger.isDebugEnabled()) {\n              \t// 省略日志\n            }\n            if (System.getSecurityManager() != null) {\n                try {\n                    AccessController.doPrivileged((PrivilegedExceptionAction<Object>) \n                                                  () -> {\n                        ((InitializingBean) bean).afterPropertiesSet();\n                        return null;\n                    }, getAccessControlContext());\n                }\n                catch (PrivilegedActionException pae) {\n                    throw pae.getException();\n                }\n            }\n            else {\n                // 属性初始化的处理\n                ((InitializingBean) bean).afterPropertiesSet();\n            }\n        }\n\n        if (mbd != null && bean.getClass() != NullBean.class) {\n            String initMethodName = mbd.getInitMethodName();\n            if (StringUtils.hasLength(initMethodName) &&\n                    !(isInitializingBean && \n                      \"afterPropertiesSet\".equals(initMethodName)) &&\n                    !mbd.isExternallyManagedInitMethod(initMethodName)) {\n                // 激活用户自定义的 初始化方法\n                invokeCustomInitMethod(beanName, bean, mbd);\n            }\n        }\n    }\n```\n\n首先检查是否为 InitializingBean ，如果是的话需要执行 `afterPropertiesSet()`，因为我们除了可以使用 `init-method`来自定初始化方法外，还可以实现 InitializingBean 接口，该接口仅有一个 `afterPropertiesSet()` 方法，而两者的执行先后顺序是先 `afterPropertiesSet()` 后 `init-method`。\n\n**注册DisposableBean**\n\nspring中不但提供了对于初始化方法的扩展入口同样也提供了销毁方法的扩展入口，对于销毁方法的扩展，处理我们熟知的配置属性destroy-method方法外，用户还可以注册后处理器DestructionAwareBeanpostProcessor来统一处理bean的销毁方法，具体代码如下\n\n```java\nprotected void registerDisposableBeanIfNecessary(String beanName, Object bean, \n                                                 RootBeanDefinition mbd) {\n\t\tAccessControlContext acc = (System.getSecurityManager() != null ? \n                                    getAccessControlContext() : null);\n    \n\t\tif (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {\n            // 单例bean的注册销毁\n\t\t\tif (mbd.isSingleton()) {\n                // 在bean销毁之前调用这个destroy-method\n\t\t\t\tregisterDisposableBean(beanName,\n\t\t\t\t\t\tnew DisposableBeanAdapter(bean, beanName, mbd, \n                                                  getBeanPostProcessors(), acc));\n            // 其他scope bean的注册销毁\n\t\t\t} else {\n\t\t\t\tScope scope = this.scopes.get(mbd.getScope());\n\t\t\t\tif (scope == null) {\n\t\t\t\t\t\t// 抛出异常省略\n\t\t\t\t}\n\t\t\t\tscope.registerDestructionCallback(beanName,\n\t\t\t\t\t\tnew DisposableBeanAdapter(bean, beanName, mbd, \n                                                  getBeanPostProcessors(), acc));\n\t\t\t}\n\t\t}\n\t}\n```\n\n其实这个销毁方法对于单例bean来说，扩展在这里我感觉是没有多大作用，因为单例bean的销毁是随着整个容器而销毁，而整个容器的销毁也代表者这个应用销毁，不起作用所以这里掉不掉用销毁方法已经没什么作用。对于其他的scope，是可以起作用的，类如request，session的scope是可以在里面加入一些定制化的逻辑。后面分析springMVC时会具体说道。","slug":"spring 源码分析/spring/spring源码解析之 25bean的初始化","published":1,"updated":"2019-01-16T08:34:38.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovwh004y9q1urb81arbd","content":"<h1 id=\"spring源码解析之-25bean的初始化\"><a href=\"#spring源码解析之-25bean的初始化\" class=\"headerlink\" title=\"spring源码解析之 25bean的初始化\"></a>spring源码解析之 25bean的初始化</h1><p>前面我们已经分析了bean的创建，属性的注入，依赖处理，其实这时bean基本上已经可以用了，不知道你还记不记得我们在xml中还可以配置init-method属性，这个到现在为止还没有处理，这就是最后一步初始化，也就是 <code>initializeBean()</code>，所以这篇文章我们分析 <code>doCreateBean()</code> 中最后一步：初始化 bean。<br><a id=\"more\"></a></p>\n<pre><code class=\"java\">    protected Object initializeBean(final String beanName, final Object bean, \n                                    @Nullable RootBeanDefinition mbd) {\n        // 这个判断现在可以不理，主要是为了安全，重点是invokeAwareMethods方法\n        if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {\n                invokeAwareMethods(beanName, bean);\n                return null;\n            }, getAccessControlContext());\n        }\n        else {\n            // / 激活 Aware 方法，对特殊的 bean 处理：\n            // Aware、BeanClassLoaderAware、BeanFactoryAware\n            invokeAwareMethods(beanName, bean);\n        }\n        Object wrappedBean = bean;\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 在调用init-method之前的处理\n            wrappedBean = \n                applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n        }\n\n        try {\n            // 激活用户自定义的 init 方法\n            invokeInitMethods(beanName, wrappedBean, mbd);\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(\n                    (mbd != null ? mbd.getResourceDescription() : null),\n                    beanName, &quot;Invocation of init method failed&quot;, ex);\n        }\n        if (mbd == null || !mbd.isSynthetic()) {\n            // bean调用init-method之后的处理\n            wrappedBean = \n                applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n        }\n        return wrappedBean;\n    }\n</code></pre>\n<p>初始化 bean 的方法其实就是三个步骤的处理，而这三个步骤主要还是根据用户设定的来进行初始化，这三个过程为：</p>\n<ol>\n<li>激活 Aware 方法</li>\n<li>后置处理器的应用</li>\n<li>激活自定义的 init 方法</li>\n</ol>\n<p><strong>激活 Aware 方法</strong></p>\n<p>Aware ,英文翻译是意识到的，感知的，Spring 提供了诸多 Aware 接口用于辅助 Spring Bean 以编程的方式调用 Spring 容器，通过实现这些接口，可以增强 Spring Bean 的功能。</p>\n<p>Spring 提供了如下系列的 Aware 接口：</p>\n<ul>\n<li>LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ</li>\n<li>BeanClassLoaderAware：加载Spring Bean的类加载器</li>\n<li>BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI</li>\n<li>ResourceLoaderAware：底层访问资源的加载器</li>\n<li>BeanFactoryAware：声明BeanFactory</li>\n<li>PortletConfigAware：PortletConfig</li>\n<li>PortletContextAware：PortletContext</li>\n<li>ServletConfigAware：ServletConfig</li>\n<li>ServletContextAware：ServletContext</li>\n<li>MessageSourceAware：国际化</li>\n<li>ApplicationEventPublisherAware：应用事件</li>\n<li>NotificationPublisherAware：JMX通知</li>\n<li>BeanNameAware：声明Spring Bean的名字</li>\n</ul>\n<p><code>invokeAwareMethods()</code> 源码如下：</p>\n<pre><code class=\"java\">    private void invokeAwareMethods(final String beanName, final Object bean) {\n        if (bean instanceof Aware) {\n            // 注入beanname\n            if (bean instanceof BeanNameAware) {\n                ((BeanNameAware) bean).setBeanName(beanName);\n            }\n            // 注入类加载器\n            if (bean instanceof BeanClassLoaderAware) {\n                ClassLoader bcl = getBeanClassLoader();\n                if (bcl != null) {\n                    ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);\n                }\n            }\n            // 注入beanFactory\n            if (bean instanceof BeanFactoryAware) {\n                ((BeanFactoryAware) bean)\n                    .setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n            }\n        }\n    }\n</code></pre>\n<p>这里代码就没有什么好说的，主要是处理 BeanNameAware、BeanClassLoaderAware、BeanFactoryAware。关于 Aware 接口，后面会专门出篇文章对其进行详细分析说明的。</p>\n<p><strong>后置处理器的应用</strong></p>\n<p>BeanPostProcessor 在前面介绍 bean 加载的过程曾多次遇到，相信各位不陌生，这是 Spring 中开放式框架中必不可少的一个亮点。BeanPostProcessor 的作用是：如果我们想要在 Spring 容器完成 Bean 的实例化，配置和其他的初始化后添加一些自己的逻辑处理，那么请使用该接口，这个接口给与了用户充足的权限去更改或者扩展 Spring，是我们对 Spring 进行扩展和增强处理一个必不可少的接口。</p>\n<pre><code class=\"java\">    public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, \n                                 String beanName) throws BeansException {\n\n        Object result = existingBean;\n        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n            Object current = beanProcessor.postProcessBeforeInitialization(result, \n                                                                           beanName);\n            if (current == null) {\n                return result;\n            }\n            result = current;\n        }\n        return result;\n    }\n\n    @Override\n    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, \n                               String beanName) throws BeansException {\n\n        Object result = existingBean;\n        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n            Object current = beanProcessor.postProcessAfterInitialization(result, \n                                                                          beanName);\n            if (current == null) {\n                return result;\n            }\n            result = current;\n        }\n        return result;\n    }\n</code></pre>\n<p>其实逻辑就是通过 <code>getBeanPostProcessors()</code> 获取定义的 BeanPostProcessor ，然后分别调用其 <code>postProcessBeforeInitialization()</code>、<code>postProcessAfterInitialization()</code> 进行业务处理。</p>\n<p><strong>激活自定义的 init 方法</strong></p>\n<p>如果熟悉 <code>&lt;bean&gt;</code> 标签的配置，一定不会忘记 <code>init-method</code> 方法，该方法的执行就是在这里执行的。</p>\n<pre><code class=\"java\">   protected void invokeInitMethods(String beanName, final Object bean, \n                                    @Nullable RootBeanDefinition mbd)\n            throws Throwable {\n        // 首先会检查是否是 InitializingBean ，如果是的话需要调用 afterPropertiesSet()\n        boolean isInitializingBean = (bean instanceof InitializingBean);\n        if (isInitializingBean &amp;&amp; \n            (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) \n        {\n            if (logger.isDebugEnabled()) {\n                  // 省略日志\n            }\n            if (System.getSecurityManager() != null) {\n                try {\n                    AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) \n                                                  () -&gt; {\n                        ((InitializingBean) bean).afterPropertiesSet();\n                        return null;\n                    }, getAccessControlContext());\n                }\n                catch (PrivilegedActionException pae) {\n                    throw pae.getException();\n                }\n            }\n            else {\n                // 属性初始化的处理\n                ((InitializingBean) bean).afterPropertiesSet();\n            }\n        }\n\n        if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) {\n            String initMethodName = mbd.getInitMethodName();\n            if (StringUtils.hasLength(initMethodName) &amp;&amp;\n                    !(isInitializingBean &amp;&amp; \n                      &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;\n                    !mbd.isExternallyManagedInitMethod(initMethodName)) {\n                // 激活用户自定义的 初始化方法\n                invokeCustomInitMethod(beanName, bean, mbd);\n            }\n        }\n    }\n</code></pre>\n<p>首先检查是否为 InitializingBean ，如果是的话需要执行 <code>afterPropertiesSet()</code>，因为我们除了可以使用 <code>init-method</code>来自定初始化方法外，还可以实现 InitializingBean 接口，该接口仅有一个 <code>afterPropertiesSet()</code> 方法，而两者的执行先后顺序是先 <code>afterPropertiesSet()</code> 后 <code>init-method</code>。</p>\n<p><strong>注册DisposableBean</strong></p>\n<p>spring中不但提供了对于初始化方法的扩展入口同样也提供了销毁方法的扩展入口，对于销毁方法的扩展，处理我们熟知的配置属性destroy-method方法外，用户还可以注册后处理器DestructionAwareBeanpostProcessor来统一处理bean的销毁方法，具体代码如下</p>\n<pre><code class=\"java\">protected void registerDisposableBeanIfNecessary(String beanName, Object bean, \n                                                 RootBeanDefinition mbd) {\n        AccessControlContext acc = (System.getSecurityManager() != null ? \n                                    getAccessControlContext() : null);\n\n        if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) {\n            // 单例bean的注册销毁\n            if (mbd.isSingleton()) {\n                // 在bean销毁之前调用这个destroy-method\n                registerDisposableBean(beanName,\n                        new DisposableBeanAdapter(bean, beanName, mbd, \n                                                  getBeanPostProcessors(), acc));\n            // 其他scope bean的注册销毁\n            } else {\n                Scope scope = this.scopes.get(mbd.getScope());\n                if (scope == null) {\n                        // 抛出异常省略\n                }\n                scope.registerDestructionCallback(beanName,\n                        new DisposableBeanAdapter(bean, beanName, mbd, \n                                                  getBeanPostProcessors(), acc));\n            }\n        }\n    }\n</code></pre>\n<p>其实这个销毁方法对于单例bean来说，扩展在这里我感觉是没有多大作用，因为单例bean的销毁是随着整个容器而销毁，而整个容器的销毁也代表者这个应用销毁，不起作用所以这里掉不掉用销毁方法已经没什么作用。对于其他的scope，是可以起作用的，类如request，session的scope是可以在里面加入一些定制化的逻辑。后面分析springMVC时会具体说道。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-25bean的初始化\"><a href=\"#spring源码解析之-25bean的初始化\" class=\"headerlink\" title=\"spring源码解析之 25bean的初始化\"></a>spring源码解析之 25bean的初始化</h1><p>前面我们已经分析了bean的创建，属性的注入，依赖处理，其实这时bean基本上已经可以用了，不知道你还记不记得我们在xml中还可以配置init-method属性，这个到现在为止还没有处理，这就是最后一步初始化，也就是 <code>initializeBean()</code>，所以这篇文章我们分析 <code>doCreateBean()</code> 中最后一步：初始化 bean。<br>","more":"</p>\n<pre><code class=\"java\">    protected Object initializeBean(final String beanName, final Object bean, \n                                    @Nullable RootBeanDefinition mbd) {\n        // 这个判断现在可以不理，主要是为了安全，重点是invokeAwareMethods方法\n        if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {\n                invokeAwareMethods(beanName, bean);\n                return null;\n            }, getAccessControlContext());\n        }\n        else {\n            // / 激活 Aware 方法，对特殊的 bean 处理：\n            // Aware、BeanClassLoaderAware、BeanFactoryAware\n            invokeAwareMethods(beanName, bean);\n        }\n        Object wrappedBean = bean;\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 在调用init-method之前的处理\n            wrappedBean = \n                applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n        }\n\n        try {\n            // 激活用户自定义的 init 方法\n            invokeInitMethods(beanName, wrappedBean, mbd);\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(\n                    (mbd != null ? mbd.getResourceDescription() : null),\n                    beanName, &quot;Invocation of init method failed&quot;, ex);\n        }\n        if (mbd == null || !mbd.isSynthetic()) {\n            // bean调用init-method之后的处理\n            wrappedBean = \n                applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n        }\n        return wrappedBean;\n    }\n</code></pre>\n<p>初始化 bean 的方法其实就是三个步骤的处理，而这三个步骤主要还是根据用户设定的来进行初始化，这三个过程为：</p>\n<ol>\n<li>激活 Aware 方法</li>\n<li>后置处理器的应用</li>\n<li>激活自定义的 init 方法</li>\n</ol>\n<p><strong>激活 Aware 方法</strong></p>\n<p>Aware ,英文翻译是意识到的，感知的，Spring 提供了诸多 Aware 接口用于辅助 Spring Bean 以编程的方式调用 Spring 容器，通过实现这些接口，可以增强 Spring Bean 的功能。</p>\n<p>Spring 提供了如下系列的 Aware 接口：</p>\n<ul>\n<li>LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ</li>\n<li>BeanClassLoaderAware：加载Spring Bean的类加载器</li>\n<li>BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI</li>\n<li>ResourceLoaderAware：底层访问资源的加载器</li>\n<li>BeanFactoryAware：声明BeanFactory</li>\n<li>PortletConfigAware：PortletConfig</li>\n<li>PortletContextAware：PortletContext</li>\n<li>ServletConfigAware：ServletConfig</li>\n<li>ServletContextAware：ServletContext</li>\n<li>MessageSourceAware：国际化</li>\n<li>ApplicationEventPublisherAware：应用事件</li>\n<li>NotificationPublisherAware：JMX通知</li>\n<li>BeanNameAware：声明Spring Bean的名字</li>\n</ul>\n<p><code>invokeAwareMethods()</code> 源码如下：</p>\n<pre><code class=\"java\">    private void invokeAwareMethods(final String beanName, final Object bean) {\n        if (bean instanceof Aware) {\n            // 注入beanname\n            if (bean instanceof BeanNameAware) {\n                ((BeanNameAware) bean).setBeanName(beanName);\n            }\n            // 注入类加载器\n            if (bean instanceof BeanClassLoaderAware) {\n                ClassLoader bcl = getBeanClassLoader();\n                if (bcl != null) {\n                    ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);\n                }\n            }\n            // 注入beanFactory\n            if (bean instanceof BeanFactoryAware) {\n                ((BeanFactoryAware) bean)\n                    .setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n            }\n        }\n    }\n</code></pre>\n<p>这里代码就没有什么好说的，主要是处理 BeanNameAware、BeanClassLoaderAware、BeanFactoryAware。关于 Aware 接口，后面会专门出篇文章对其进行详细分析说明的。</p>\n<p><strong>后置处理器的应用</strong></p>\n<p>BeanPostProcessor 在前面介绍 bean 加载的过程曾多次遇到，相信各位不陌生，这是 Spring 中开放式框架中必不可少的一个亮点。BeanPostProcessor 的作用是：如果我们想要在 Spring 容器完成 Bean 的实例化，配置和其他的初始化后添加一些自己的逻辑处理，那么请使用该接口，这个接口给与了用户充足的权限去更改或者扩展 Spring，是我们对 Spring 进行扩展和增强处理一个必不可少的接口。</p>\n<pre><code class=\"java\">    public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, \n                                 String beanName) throws BeansException {\n\n        Object result = existingBean;\n        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n            Object current = beanProcessor.postProcessBeforeInitialization(result, \n                                                                           beanName);\n            if (current == null) {\n                return result;\n            }\n            result = current;\n        }\n        return result;\n    }\n\n    @Override\n    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, \n                               String beanName) throws BeansException {\n\n        Object result = existingBean;\n        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n            Object current = beanProcessor.postProcessAfterInitialization(result, \n                                                                          beanName);\n            if (current == null) {\n                return result;\n            }\n            result = current;\n        }\n        return result;\n    }\n</code></pre>\n<p>其实逻辑就是通过 <code>getBeanPostProcessors()</code> 获取定义的 BeanPostProcessor ，然后分别调用其 <code>postProcessBeforeInitialization()</code>、<code>postProcessAfterInitialization()</code> 进行业务处理。</p>\n<p><strong>激活自定义的 init 方法</strong></p>\n<p>如果熟悉 <code>&lt;bean&gt;</code> 标签的配置，一定不会忘记 <code>init-method</code> 方法，该方法的执行就是在这里执行的。</p>\n<pre><code class=\"java\">   protected void invokeInitMethods(String beanName, final Object bean, \n                                    @Nullable RootBeanDefinition mbd)\n            throws Throwable {\n        // 首先会检查是否是 InitializingBean ，如果是的话需要调用 afterPropertiesSet()\n        boolean isInitializingBean = (bean instanceof InitializingBean);\n        if (isInitializingBean &amp;&amp; \n            (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) \n        {\n            if (logger.isDebugEnabled()) {\n                  // 省略日志\n            }\n            if (System.getSecurityManager() != null) {\n                try {\n                    AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) \n                                                  () -&gt; {\n                        ((InitializingBean) bean).afterPropertiesSet();\n                        return null;\n                    }, getAccessControlContext());\n                }\n                catch (PrivilegedActionException pae) {\n                    throw pae.getException();\n                }\n            }\n            else {\n                // 属性初始化的处理\n                ((InitializingBean) bean).afterPropertiesSet();\n            }\n        }\n\n        if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) {\n            String initMethodName = mbd.getInitMethodName();\n            if (StringUtils.hasLength(initMethodName) &amp;&amp;\n                    !(isInitializingBean &amp;&amp; \n                      &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;\n                    !mbd.isExternallyManagedInitMethod(initMethodName)) {\n                // 激活用户自定义的 初始化方法\n                invokeCustomInitMethod(beanName, bean, mbd);\n            }\n        }\n    }\n</code></pre>\n<p>首先检查是否为 InitializingBean ，如果是的话需要执行 <code>afterPropertiesSet()</code>，因为我们除了可以使用 <code>init-method</code>来自定初始化方法外，还可以实现 InitializingBean 接口，该接口仅有一个 <code>afterPropertiesSet()</code> 方法，而两者的执行先后顺序是先 <code>afterPropertiesSet()</code> 后 <code>init-method</code>。</p>\n<p><strong>注册DisposableBean</strong></p>\n<p>spring中不但提供了对于初始化方法的扩展入口同样也提供了销毁方法的扩展入口，对于销毁方法的扩展，处理我们熟知的配置属性destroy-method方法外，用户还可以注册后处理器DestructionAwareBeanpostProcessor来统一处理bean的销毁方法，具体代码如下</p>\n<pre><code class=\"java\">protected void registerDisposableBeanIfNecessary(String beanName, Object bean, \n                                                 RootBeanDefinition mbd) {\n        AccessControlContext acc = (System.getSecurityManager() != null ? \n                                    getAccessControlContext() : null);\n\n        if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) {\n            // 单例bean的注册销毁\n            if (mbd.isSingleton()) {\n                // 在bean销毁之前调用这个destroy-method\n                registerDisposableBean(beanName,\n                        new DisposableBeanAdapter(bean, beanName, mbd, \n                                                  getBeanPostProcessors(), acc));\n            // 其他scope bean的注册销毁\n            } else {\n                Scope scope = this.scopes.get(mbd.getScope());\n                if (scope == null) {\n                        // 抛出异常省略\n                }\n                scope.registerDestructionCallback(beanName,\n                        new DisposableBeanAdapter(bean, beanName, mbd, \n                                                  getBeanPostProcessors(), acc));\n            }\n        }\n    }\n</code></pre>\n<p>其实这个销毁方法对于单例bean来说，扩展在这里我感觉是没有多大作用，因为单例bean的销毁是随着整个容器而销毁，而整个容器的销毁也代表者这个应用销毁，不起作用所以这里掉不掉用销毁方法已经没什么作用。对于其他的scope，是可以起作用的，类如request，session的scope是可以在里面加入一些定制化的逻辑。后面分析springMVC时会具体说道。</p>"},{"abbrlink":48,"title":"spring源码解析之 27深入分析BeanPostProcessor接口","author":"fengxiutianya","date":"2019-01-14T22:39:00.000Z","_content":"# spring源码解析之 27深入分析BeanPostProcessor接口\n\nSpring 作为优秀的开源框架，它为我们提供了丰富的可扩展点，除了前面提到的 Aware 接口，还包括其他部分，其中一个很重要的就是 BeanPostProcessor。这篇文章主要介绍 BeanPostProcessor 的使用以及其实现原理。我们先看 BeanPostProcessor 的定位：\n\nBeanPostProcessor 的作用：在 Bean 完成实例化后，如果我们需要对其进行一些配置、增加一些自己的处理逻辑，那么请使用 BeanPostProcessor。\n<!-- more -->\n\n## BeanPostProcessor 实例\n\n首先定义一个类，该类实现 BeanPostProcessor 接口，如下：\n\n```java\npublic class BeanPostProcessorTest implements BeanPostProcessor{\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(\"Bean [\" + beanName + \"] 开始初始化\");\n        // 这里一定要返回 bean，不能返回 null\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(\"Bean [\" + beanName + \"] 完成初始化\");\n        return bean;\n    }\n\n    public void display(){\n        System.out.println(\"hello BeanPostProcessor!!!\");\n    }\n}\n```\n\n测试方法如下：\n\n```java\nClassPathResource resource = new ClassPathResource(\"spring.xml\");\nDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\nXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\nreader.loadBeanDefinitions(resource);\n\nBeanPostProcessorTest test = (BeanPostProcessorTest) factory.getBean(\"beanPostProcessorTest\");\ntest.display();\n```\n\n运行结果：\n\n运行结果：\n\n![upload successful](/images/pasted-14.png)\n\n运行结果比较奇怪，为什么没有执行 `postProcessBeforeInitialization()` 和 `postProcessAfterInitialization()`呢？\n\n我们 debug 跟踪下代码，这两个方法在 `initializeBean()` 方法处调用下，如下：\n\n![upload successful](/images/pasted-15.png)\n\ndebug，在 `postProcessBeforeInitialization()`方法中结果如下：\n\n![upload successful](/images/pasted-16.png)\n\n这段代码是通过迭代 `getBeanPostProcessors()` 返回的结果集来调用 `postProcessBeforeInitialization()`，但是在这里我们看到该方法返回的结果集为空，所以肯定不会执行相应的 `postProcessBeforeInitialization()` 方法咯。怎么办？答案不言而喻：只需要 `getBeanPostProcessors()` 返回的结果集中存在至少一个元素即可，该方法定义如下：\n\n```java\n public List<BeanPostProcessor> getBeanPostProcessors() {\n  return this.beanPostProcessors;\n }\n```\n\n返回的 beanPostProcessors 是一个 private 的 List ，也就是说只要该类中存在 `beanPostProcessors.add()` 的调用我们就找到了入口，在类 AbstractBeanFactory 中找到了如下代码：\n\n```java\n @Override\n public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {\n  Assert.notNull(beanPostProcessor, \"BeanPostProcessor must not be null\");\n  this.beanPostProcessors.remove(beanPostProcessor);\n  this.beanPostProcessors.add(beanPostProcessor);\n  if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {\n   this.hasInstantiationAwareBeanPostProcessors = true;\n  }\n  if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {\n   this.hasDestructionAwareBeanPostProcessors = true;\n  }\n }\n```\n\n该方法是由 AbstractBeanFactory 的父类 ConfigurableBeanFactory 定义，它的核心意思就是将指定 BeanPostProcessor 注册到该 BeanFactory 创建的 bean 中，同时它是按照插入的顺序进行注册的，完全忽略 Ordered 接口所表达任何排序语义（在 BeanPostProcessor 中我们提供一个 Ordered 顺序，这个后面讲解）。\n\n到这里应该就比较熟悉了，其实只需要显示调用 `addBeanPostProcessor()` 就可以了，加入如下代码。\n\n```java\nBeanPostProcessorTest beanPostProcessorTest = new BeanPostProcessorTest();\nfactory.addBeanPostProcessor(beanPostProcessorTest);\n```\n\n运行结果：\n\n![upload successful](/images/pasted-17.png)\n\n其实还有一种更加简单的方法，这个我们后面再说，先看 BeanPostProcessor 的原理。\n\n## BeanPostProcessor 基本原理\n\nBeanPostProcessor 接口定义如下：\n\n```java\npublic interface BeanPostProcessor {\n @Nullable\n default Object postProcessBeforeInitialization(Object bean, String beanName) \n     throws BeansException {\n  return bean;\n }\n\n @Nullable\n default Object postProcessAfterInitialization(Object bean, String beanName)\n     throws BeansException {\n  return bean;\n }\n}\n```\n\nBeanPostProcessor 可以理解为是 Spring 的一个工厂钩子（其实 Spring 提供一系列的钩子，如 Aware 、InitializingBean、DisposableBean），它是 Spring 提供的对象实例化阶段强有力的扩展点，允许 Spring 在实例化 bean 阶段对其进行定制化修改，比较常见的使用场景是处理标记接口实现类或者为当前对象提供代理实现（例如AOP）。\n\n一般普通的 BeanFactory 是不支持自动注册 BeanPostProcessor 的，需要我们手动调用 `addBeanPostProcessor()` 进行注册，注册后的 BeanPostProcessor 适用于所有该 BeanFactory 创建的 bean，但是 ApplicationContext 可以在其 bean 定义中自动检测所有的 BeanPostProcessor 并自动完成注册，同时将他们应用到随后创建的任何 bean 中。\n\n`postProcessBeforeInitialization()` 和 `postProcessAfterInitialization()` 两个方法都接收一个 Object 类型的 bean，一个 String 类型的 beanName，其中 bean 是已经实例化了的 instanceBean，能拿到这个你是不是可以对它为所欲为了？ 这两个方法是初始化 bean 的前后置处理器，他们应用 `invokeInitMethods()` 前后。如下图：\n\n![upload successful](/images/pasted-18.png)\n\n代码层次上面已经贴出来，这里再贴一次：\n\n![upload successful](/images/pasted-19.png)\n\n两者源码如下：\n\n```java\n @Override\n public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, \n                       String beanName) throws BeansException {\n\n  Object result = existingBean;\n  for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n   Object current = beanProcessor.postProcessBeforeInitialization(result, beanName);\n   if (current == null) {\n    return result;\n   }\n   result = current;\n  }\n  return result;\n }\n\n @Override\n public Object applyBeanPostProcessorsAfterInitialization(Object existingBean,\n                                      String beanName) throws BeansException {\n\n  Object result = existingBean;\n  for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n   Object current = beanProcessor.postProcessAfterInitialization(result, beanName);\n   if (current == null) {\n    return result;\n   }\n   result = current;\n  }\n  return result;\n }\n```\n\n`getBeanPostProcessors()` 返回的是 beanPostProcessors 集合，该集合里面存放就是我们自定义的 BeanPostProcessor，如果该集合中存在元素则调用相应的方法，否则就直接返回 bean 了。这也是为什么使用 BeanFactory 容器是无法输出自定义 BeanPostProcessor 里面的内容，因为在 `BeanFactory.getBean()` 的过程中根本就没有将我们自定义的 BeanPostProcessor 注入进来，所以要想 BeanFactory 容器 的 BeanPostProcessor 生效我们必须手动调用 `addBeanPostProcessor()` 将定义的 BeanPostProcessor 注册到相应的 BeanFactory 中。但是 ApplicationContext 不需要手动，因为 ApplicationContext 会自动检测并完成注册。这个在后面讲解ApplicationConext源码时会具体进行分析。\n\n至此，BeanPostProcessor 已经分析完毕了，这里简单总结下：\n\n1. BeanPostProcessor 的作用域是容器级别的，它只和所在的容器相关 ，当 BeanPostProcessor 完成注册后，它会应用于所有跟它在同一个容器内的 bean。\n2. BeanFactory 和 ApplicationContext 对 BeanPostProcessor 的处理不同，ApplicationContext 会自动检测所有实现了 BeanPostProcessor 接口的 bean，并完成注册，但是使用 BeanFactory 容器时则需要手动调用 `addBeanPostProcessor()` 完成注册\n3. ApplicationContext 的 BeanPostProcessor 支持 Ordered，而 BeanFactory 的 BeanPostProcessor 是不支持的，原因在于ApplicationContext 会对 BeanPostProcessor 进行 Ordered 检测并完成排序，而 BeanFactory 中的 BeanPostProcessor 只跟注册的顺序有关。\n\n下面我们来看一个例子，也是用来解决上篇博客中遗留的一个问题，如何试下一个自定义的Aware，假设我们需要实现一个获取数据库连接的Aware\n\nConnectionAware接口定义如下\n\n```java\npublic interface ConnectionAware{\n    public void setConnection(Connection con);\n}\n```\n\n添加一个BeanPostProcessor来处理这个ConnectionAware，定义如下：\n\n```java\npublic class ConnectionAwareBeanPostProcessor implements BeanPostProcessor {\n\tprivate Connection connection;\n\n\tpublic ConnectionAware(Connection connection) {\n\t\tthis.connection = connection;\n\t}\n\n\t// 不做任何处理\n\t@Override\n\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) \n        throws BeansException {\n\t\treturn bean;\n\t}\n\n    // 设置connection\n\t@Override\n\tpublic Object postProcessAfterInitialization(Object bean, String beanName) \n        throws BeansException {\n\t\tif (bean instanceof ConnectionAware){\n\t\t\t((ConnectionAware)bean).setConnection(connection);\n\t\t\treturn bean;\n\t\t}\n\t\treturn bean;\n\t}\n}\n```\n\n剩下的即可以按文章开始的时候那样写，生成一个ConnectionAwareBeanPostProcessor对象然后通过addBeanPostProcessor注册到BeanFactory中，这样后面再生成bean的时候就会处理此类型的Aware。如果是ApplicationContext则不用进行注册，因为它会自动帮你注册，后面我会具体讲解这部分功能。","source":"_posts/spring 源码分析/spring/spring源码解析之 27深入分析BeanPostProcessor接口.md","raw":"abbrlink: 48\ntitle: spring源码解析之 27深入分析BeanPostProcessor接口\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-15 06:39:00\n---\n# spring源码解析之 27深入分析BeanPostProcessor接口\n\nSpring 作为优秀的开源框架，它为我们提供了丰富的可扩展点，除了前面提到的 Aware 接口，还包括其他部分，其中一个很重要的就是 BeanPostProcessor。这篇文章主要介绍 BeanPostProcessor 的使用以及其实现原理。我们先看 BeanPostProcessor 的定位：\n\nBeanPostProcessor 的作用：在 Bean 完成实例化后，如果我们需要对其进行一些配置、增加一些自己的处理逻辑，那么请使用 BeanPostProcessor。\n<!-- more -->\n\n## BeanPostProcessor 实例\n\n首先定义一个类，该类实现 BeanPostProcessor 接口，如下：\n\n```java\npublic class BeanPostProcessorTest implements BeanPostProcessor{\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(\"Bean [\" + beanName + \"] 开始初始化\");\n        // 这里一定要返回 bean，不能返回 null\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(\"Bean [\" + beanName + \"] 完成初始化\");\n        return bean;\n    }\n\n    public void display(){\n        System.out.println(\"hello BeanPostProcessor!!!\");\n    }\n}\n```\n\n测试方法如下：\n\n```java\nClassPathResource resource = new ClassPathResource(\"spring.xml\");\nDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\nXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\nreader.loadBeanDefinitions(resource);\n\nBeanPostProcessorTest test = (BeanPostProcessorTest) factory.getBean(\"beanPostProcessorTest\");\ntest.display();\n```\n\n运行结果：\n\n运行结果：\n\n![upload successful](/images/pasted-14.png)\n\n运行结果比较奇怪，为什么没有执行 `postProcessBeforeInitialization()` 和 `postProcessAfterInitialization()`呢？\n\n我们 debug 跟踪下代码，这两个方法在 `initializeBean()` 方法处调用下，如下：\n\n![upload successful](/images/pasted-15.png)\n\ndebug，在 `postProcessBeforeInitialization()`方法中结果如下：\n\n![upload successful](/images/pasted-16.png)\n\n这段代码是通过迭代 `getBeanPostProcessors()` 返回的结果集来调用 `postProcessBeforeInitialization()`，但是在这里我们看到该方法返回的结果集为空，所以肯定不会执行相应的 `postProcessBeforeInitialization()` 方法咯。怎么办？答案不言而喻：只需要 `getBeanPostProcessors()` 返回的结果集中存在至少一个元素即可，该方法定义如下：\n\n```java\n public List<BeanPostProcessor> getBeanPostProcessors() {\n  return this.beanPostProcessors;\n }\n```\n\n返回的 beanPostProcessors 是一个 private 的 List ，也就是说只要该类中存在 `beanPostProcessors.add()` 的调用我们就找到了入口，在类 AbstractBeanFactory 中找到了如下代码：\n\n```java\n @Override\n public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {\n  Assert.notNull(beanPostProcessor, \"BeanPostProcessor must not be null\");\n  this.beanPostProcessors.remove(beanPostProcessor);\n  this.beanPostProcessors.add(beanPostProcessor);\n  if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {\n   this.hasInstantiationAwareBeanPostProcessors = true;\n  }\n  if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {\n   this.hasDestructionAwareBeanPostProcessors = true;\n  }\n }\n```\n\n该方法是由 AbstractBeanFactory 的父类 ConfigurableBeanFactory 定义，它的核心意思就是将指定 BeanPostProcessor 注册到该 BeanFactory 创建的 bean 中，同时它是按照插入的顺序进行注册的，完全忽略 Ordered 接口所表达任何排序语义（在 BeanPostProcessor 中我们提供一个 Ordered 顺序，这个后面讲解）。\n\n到这里应该就比较熟悉了，其实只需要显示调用 `addBeanPostProcessor()` 就可以了，加入如下代码。\n\n```java\nBeanPostProcessorTest beanPostProcessorTest = new BeanPostProcessorTest();\nfactory.addBeanPostProcessor(beanPostProcessorTest);\n```\n\n运行结果：\n\n![upload successful](/images/pasted-17.png)\n\n其实还有一种更加简单的方法，这个我们后面再说，先看 BeanPostProcessor 的原理。\n\n## BeanPostProcessor 基本原理\n\nBeanPostProcessor 接口定义如下：\n\n```java\npublic interface BeanPostProcessor {\n @Nullable\n default Object postProcessBeforeInitialization(Object bean, String beanName) \n     throws BeansException {\n  return bean;\n }\n\n @Nullable\n default Object postProcessAfterInitialization(Object bean, String beanName)\n     throws BeansException {\n  return bean;\n }\n}\n```\n\nBeanPostProcessor 可以理解为是 Spring 的一个工厂钩子（其实 Spring 提供一系列的钩子，如 Aware 、InitializingBean、DisposableBean），它是 Spring 提供的对象实例化阶段强有力的扩展点，允许 Spring 在实例化 bean 阶段对其进行定制化修改，比较常见的使用场景是处理标记接口实现类或者为当前对象提供代理实现（例如AOP）。\n\n一般普通的 BeanFactory 是不支持自动注册 BeanPostProcessor 的，需要我们手动调用 `addBeanPostProcessor()` 进行注册，注册后的 BeanPostProcessor 适用于所有该 BeanFactory 创建的 bean，但是 ApplicationContext 可以在其 bean 定义中自动检测所有的 BeanPostProcessor 并自动完成注册，同时将他们应用到随后创建的任何 bean 中。\n\n`postProcessBeforeInitialization()` 和 `postProcessAfterInitialization()` 两个方法都接收一个 Object 类型的 bean，一个 String 类型的 beanName，其中 bean 是已经实例化了的 instanceBean，能拿到这个你是不是可以对它为所欲为了？ 这两个方法是初始化 bean 的前后置处理器，他们应用 `invokeInitMethods()` 前后。如下图：\n\n![upload successful](/images/pasted-18.png)\n\n代码层次上面已经贴出来，这里再贴一次：\n\n![upload successful](/images/pasted-19.png)\n\n两者源码如下：\n\n```java\n @Override\n public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, \n                       String beanName) throws BeansException {\n\n  Object result = existingBean;\n  for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n   Object current = beanProcessor.postProcessBeforeInitialization(result, beanName);\n   if (current == null) {\n    return result;\n   }\n   result = current;\n  }\n  return result;\n }\n\n @Override\n public Object applyBeanPostProcessorsAfterInitialization(Object existingBean,\n                                      String beanName) throws BeansException {\n\n  Object result = existingBean;\n  for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n   Object current = beanProcessor.postProcessAfterInitialization(result, beanName);\n   if (current == null) {\n    return result;\n   }\n   result = current;\n  }\n  return result;\n }\n```\n\n`getBeanPostProcessors()` 返回的是 beanPostProcessors 集合，该集合里面存放就是我们自定义的 BeanPostProcessor，如果该集合中存在元素则调用相应的方法，否则就直接返回 bean 了。这也是为什么使用 BeanFactory 容器是无法输出自定义 BeanPostProcessor 里面的内容，因为在 `BeanFactory.getBean()` 的过程中根本就没有将我们自定义的 BeanPostProcessor 注入进来，所以要想 BeanFactory 容器 的 BeanPostProcessor 生效我们必须手动调用 `addBeanPostProcessor()` 将定义的 BeanPostProcessor 注册到相应的 BeanFactory 中。但是 ApplicationContext 不需要手动，因为 ApplicationContext 会自动检测并完成注册。这个在后面讲解ApplicationConext源码时会具体进行分析。\n\n至此，BeanPostProcessor 已经分析完毕了，这里简单总结下：\n\n1. BeanPostProcessor 的作用域是容器级别的，它只和所在的容器相关 ，当 BeanPostProcessor 完成注册后，它会应用于所有跟它在同一个容器内的 bean。\n2. BeanFactory 和 ApplicationContext 对 BeanPostProcessor 的处理不同，ApplicationContext 会自动检测所有实现了 BeanPostProcessor 接口的 bean，并完成注册，但是使用 BeanFactory 容器时则需要手动调用 `addBeanPostProcessor()` 完成注册\n3. ApplicationContext 的 BeanPostProcessor 支持 Ordered，而 BeanFactory 的 BeanPostProcessor 是不支持的，原因在于ApplicationContext 会对 BeanPostProcessor 进行 Ordered 检测并完成排序，而 BeanFactory 中的 BeanPostProcessor 只跟注册的顺序有关。\n\n下面我们来看一个例子，也是用来解决上篇博客中遗留的一个问题，如何试下一个自定义的Aware，假设我们需要实现一个获取数据库连接的Aware\n\nConnectionAware接口定义如下\n\n```java\npublic interface ConnectionAware{\n    public void setConnection(Connection con);\n}\n```\n\n添加一个BeanPostProcessor来处理这个ConnectionAware，定义如下：\n\n```java\npublic class ConnectionAwareBeanPostProcessor implements BeanPostProcessor {\n\tprivate Connection connection;\n\n\tpublic ConnectionAware(Connection connection) {\n\t\tthis.connection = connection;\n\t}\n\n\t// 不做任何处理\n\t@Override\n\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) \n        throws BeansException {\n\t\treturn bean;\n\t}\n\n    // 设置connection\n\t@Override\n\tpublic Object postProcessAfterInitialization(Object bean, String beanName) \n        throws BeansException {\n\t\tif (bean instanceof ConnectionAware){\n\t\t\t((ConnectionAware)bean).setConnection(connection);\n\t\t\treturn bean;\n\t\t}\n\t\treturn bean;\n\t}\n}\n```\n\n剩下的即可以按文章开始的时候那样写，生成一个ConnectionAwareBeanPostProcessor对象然后通过addBeanPostProcessor注册到BeanFactory中，这样后面再生成bean的时候就会处理此类型的Aware。如果是ApplicationContext则不用进行注册，因为它会自动帮你注册，后面我会具体讲解这部分功能。","slug":"spring 源码分析/spring/spring源码解析之 27深入分析BeanPostProcessor接口","published":1,"updated":"2019-01-16T08:34:14.071Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovwi00519q1um6z576mb","content":"<h1 id=\"spring源码解析之-27深入分析BeanPostProcessor接口\"><a href=\"#spring源码解析之-27深入分析BeanPostProcessor接口\" class=\"headerlink\" title=\"spring源码解析之 27深入分析BeanPostProcessor接口\"></a>spring源码解析之 27深入分析BeanPostProcessor接口</h1><p>Spring 作为优秀的开源框架，它为我们提供了丰富的可扩展点，除了前面提到的 Aware 接口，还包括其他部分，其中一个很重要的就是 BeanPostProcessor。这篇文章主要介绍 BeanPostProcessor 的使用以及其实现原理。我们先看 BeanPostProcessor 的定位：</p>\n<p>BeanPostProcessor 的作用：在 Bean 完成实例化后，如果我们需要对其进行一些配置、增加一些自己的处理逻辑，那么请使用 BeanPostProcessor。<br><a id=\"more\"></a></p>\n<h2 id=\"BeanPostProcessor-实例\"><a href=\"#BeanPostProcessor-实例\" class=\"headerlink\" title=\"BeanPostProcessor 实例\"></a>BeanPostProcessor 实例</h2><p>首先定义一个类，该类实现 BeanPostProcessor 接口，如下：</p>\n<pre><code class=\"java\">public class BeanPostProcessorTest implements BeanPostProcessor{\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(&quot;Bean [&quot; + beanName + &quot;] 开始初始化&quot;);\n        // 这里一定要返回 bean，不能返回 null\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(&quot;Bean [&quot; + beanName + &quot;] 完成初始化&quot;);\n        return bean;\n    }\n\n    public void display(){\n        System.out.println(&quot;hello BeanPostProcessor!!!&quot;);\n    }\n}\n</code></pre>\n<p>测试方法如下：</p>\n<pre><code class=\"java\">ClassPathResource resource = new ClassPathResource(&quot;spring.xml&quot;);\nDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\nXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\nreader.loadBeanDefinitions(resource);\n\nBeanPostProcessorTest test = (BeanPostProcessorTest) factory.getBean(&quot;beanPostProcessorTest&quot;);\ntest.display();\n</code></pre>\n<p>运行结果：</p>\n<p>运行结果：</p>\n<p><img src=\"/images/pasted-14.png\" alt=\"upload successful\"></p>\n<p>运行结果比较奇怪，为什么没有执行 <code>postProcessBeforeInitialization()</code> 和 <code>postProcessAfterInitialization()</code>呢？</p>\n<p>我们 debug 跟踪下代码，这两个方法在 <code>initializeBean()</code> 方法处调用下，如下：</p>\n<p><img src=\"/images/pasted-15.png\" alt=\"upload successful\"></p>\n<p>debug，在 <code>postProcessBeforeInitialization()</code>方法中结果如下：</p>\n<p><img src=\"/images/pasted-16.png\" alt=\"upload successful\"></p>\n<p>这段代码是通过迭代 <code>getBeanPostProcessors()</code> 返回的结果集来调用 <code>postProcessBeforeInitialization()</code>，但是在这里我们看到该方法返回的结果集为空，所以肯定不会执行相应的 <code>postProcessBeforeInitialization()</code> 方法咯。怎么办？答案不言而喻：只需要 <code>getBeanPostProcessors()</code> 返回的结果集中存在至少一个元素即可，该方法定义如下：</p>\n<pre><code class=\"java\"> public List&lt;BeanPostProcessor&gt; getBeanPostProcessors() {\n  return this.beanPostProcessors;\n }\n</code></pre>\n<p>返回的 beanPostProcessors 是一个 private 的 List ，也就是说只要该类中存在 <code>beanPostProcessors.add()</code> 的调用我们就找到了入口，在类 AbstractBeanFactory 中找到了如下代码：</p>\n<pre><code class=\"java\"> @Override\n public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {\n  Assert.notNull(beanPostProcessor, &quot;BeanPostProcessor must not be null&quot;);\n  this.beanPostProcessors.remove(beanPostProcessor);\n  this.beanPostProcessors.add(beanPostProcessor);\n  if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {\n   this.hasInstantiationAwareBeanPostProcessors = true;\n  }\n  if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {\n   this.hasDestructionAwareBeanPostProcessors = true;\n  }\n }\n</code></pre>\n<p>该方法是由 AbstractBeanFactory 的父类 ConfigurableBeanFactory 定义，它的核心意思就是将指定 BeanPostProcessor 注册到该 BeanFactory 创建的 bean 中，同时它是按照插入的顺序进行注册的，完全忽略 Ordered 接口所表达任何排序语义（在 BeanPostProcessor 中我们提供一个 Ordered 顺序，这个后面讲解）。</p>\n<p>到这里应该就比较熟悉了，其实只需要显示调用 <code>addBeanPostProcessor()</code> 就可以了，加入如下代码。</p>\n<pre><code class=\"java\">BeanPostProcessorTest beanPostProcessorTest = new BeanPostProcessorTest();\nfactory.addBeanPostProcessor(beanPostProcessorTest);\n</code></pre>\n<p>运行结果：</p>\n<p><img src=\"/images/pasted-17.png\" alt=\"upload successful\"></p>\n<p>其实还有一种更加简单的方法，这个我们后面再说，先看 BeanPostProcessor 的原理。</p>\n<h2 id=\"BeanPostProcessor-基本原理\"><a href=\"#BeanPostProcessor-基本原理\" class=\"headerlink\" title=\"BeanPostProcessor 基本原理\"></a>BeanPostProcessor 基本原理</h2><p>BeanPostProcessor 接口定义如下：</p>\n<pre><code class=\"java\">public interface BeanPostProcessor {\n @Nullable\n default Object postProcessBeforeInitialization(Object bean, String beanName) \n     throws BeansException {\n  return bean;\n }\n\n @Nullable\n default Object postProcessAfterInitialization(Object bean, String beanName)\n     throws BeansException {\n  return bean;\n }\n}\n</code></pre>\n<p>BeanPostProcessor 可以理解为是 Spring 的一个工厂钩子（其实 Spring 提供一系列的钩子，如 Aware 、InitializingBean、DisposableBean），它是 Spring 提供的对象实例化阶段强有力的扩展点，允许 Spring 在实例化 bean 阶段对其进行定制化修改，比较常见的使用场景是处理标记接口实现类或者为当前对象提供代理实现（例如AOP）。</p>\n<p>一般普通的 BeanFactory 是不支持自动注册 BeanPostProcessor 的，需要我们手动调用 <code>addBeanPostProcessor()</code> 进行注册，注册后的 BeanPostProcessor 适用于所有该 BeanFactory 创建的 bean，但是 ApplicationContext 可以在其 bean 定义中自动检测所有的 BeanPostProcessor 并自动完成注册，同时将他们应用到随后创建的任何 bean 中。</p>\n<p><code>postProcessBeforeInitialization()</code> 和 <code>postProcessAfterInitialization()</code> 两个方法都接收一个 Object 类型的 bean，一个 String 类型的 beanName，其中 bean 是已经实例化了的 instanceBean，能拿到这个你是不是可以对它为所欲为了？ 这两个方法是初始化 bean 的前后置处理器，他们应用 <code>invokeInitMethods()</code> 前后。如下图：</p>\n<p><img src=\"/images/pasted-18.png\" alt=\"upload successful\"></p>\n<p>代码层次上面已经贴出来，这里再贴一次：</p>\n<p><img src=\"/images/pasted-19.png\" alt=\"upload successful\"></p>\n<p>两者源码如下：</p>\n<pre><code class=\"java\"> @Override\n public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, \n                       String beanName) throws BeansException {\n\n  Object result = existingBean;\n  for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n   Object current = beanProcessor.postProcessBeforeInitialization(result, beanName);\n   if (current == null) {\n    return result;\n   }\n   result = current;\n  }\n  return result;\n }\n\n @Override\n public Object applyBeanPostProcessorsAfterInitialization(Object existingBean,\n                                      String beanName) throws BeansException {\n\n  Object result = existingBean;\n  for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n   Object current = beanProcessor.postProcessAfterInitialization(result, beanName);\n   if (current == null) {\n    return result;\n   }\n   result = current;\n  }\n  return result;\n }\n</code></pre>\n<p><code>getBeanPostProcessors()</code> 返回的是 beanPostProcessors 集合，该集合里面存放就是我们自定义的 BeanPostProcessor，如果该集合中存在元素则调用相应的方法，否则就直接返回 bean 了。这也是为什么使用 BeanFactory 容器是无法输出自定义 BeanPostProcessor 里面的内容，因为在 <code>BeanFactory.getBean()</code> 的过程中根本就没有将我们自定义的 BeanPostProcessor 注入进来，所以要想 BeanFactory 容器 的 BeanPostProcessor 生效我们必须手动调用 <code>addBeanPostProcessor()</code> 将定义的 BeanPostProcessor 注册到相应的 BeanFactory 中。但是 ApplicationContext 不需要手动，因为 ApplicationContext 会自动检测并完成注册。这个在后面讲解ApplicationConext源码时会具体进行分析。</p>\n<p>至此，BeanPostProcessor 已经分析完毕了，这里简单总结下：</p>\n<ol>\n<li>BeanPostProcessor 的作用域是容器级别的，它只和所在的容器相关 ，当 BeanPostProcessor 完成注册后，它会应用于所有跟它在同一个容器内的 bean。</li>\n<li>BeanFactory 和 ApplicationContext 对 BeanPostProcessor 的处理不同，ApplicationContext 会自动检测所有实现了 BeanPostProcessor 接口的 bean，并完成注册，但是使用 BeanFactory 容器时则需要手动调用 <code>addBeanPostProcessor()</code> 完成注册</li>\n<li>ApplicationContext 的 BeanPostProcessor 支持 Ordered，而 BeanFactory 的 BeanPostProcessor 是不支持的，原因在于ApplicationContext 会对 BeanPostProcessor 进行 Ordered 检测并完成排序，而 BeanFactory 中的 BeanPostProcessor 只跟注册的顺序有关。</li>\n</ol>\n<p>下面我们来看一个例子，也是用来解决上篇博客中遗留的一个问题，如何试下一个自定义的Aware，假设我们需要实现一个获取数据库连接的Aware</p>\n<p>ConnectionAware接口定义如下</p>\n<pre><code class=\"java\">public interface ConnectionAware{\n    public void setConnection(Connection con);\n}\n</code></pre>\n<p>添加一个BeanPostProcessor来处理这个ConnectionAware，定义如下：</p>\n<pre><code class=\"java\">public class ConnectionAwareBeanPostProcessor implements BeanPostProcessor {\n    private Connection connection;\n\n    public ConnectionAware(Connection connection) {\n        this.connection = connection;\n    }\n\n    // 不做任何处理\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) \n        throws BeansException {\n        return bean;\n    }\n\n    // 设置connection\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) \n        throws BeansException {\n        if (bean instanceof ConnectionAware){\n            ((ConnectionAware)bean).setConnection(connection);\n            return bean;\n        }\n        return bean;\n    }\n}\n</code></pre>\n<p>剩下的即可以按文章开始的时候那样写，生成一个ConnectionAwareBeanPostProcessor对象然后通过addBeanPostProcessor注册到BeanFactory中，这样后面再生成bean的时候就会处理此类型的Aware。如果是ApplicationContext则不用进行注册，因为它会自动帮你注册，后面我会具体讲解这部分功能。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-27深入分析BeanPostProcessor接口\"><a href=\"#spring源码解析之-27深入分析BeanPostProcessor接口\" class=\"headerlink\" title=\"spring源码解析之 27深入分析BeanPostProcessor接口\"></a>spring源码解析之 27深入分析BeanPostProcessor接口</h1><p>Spring 作为优秀的开源框架，它为我们提供了丰富的可扩展点，除了前面提到的 Aware 接口，还包括其他部分，其中一个很重要的就是 BeanPostProcessor。这篇文章主要介绍 BeanPostProcessor 的使用以及其实现原理。我们先看 BeanPostProcessor 的定位：</p>\n<p>BeanPostProcessor 的作用：在 Bean 完成实例化后，如果我们需要对其进行一些配置、增加一些自己的处理逻辑，那么请使用 BeanPostProcessor。<br>","more":"</p>\n<h2 id=\"BeanPostProcessor-实例\"><a href=\"#BeanPostProcessor-实例\" class=\"headerlink\" title=\"BeanPostProcessor 实例\"></a>BeanPostProcessor 实例</h2><p>首先定义一个类，该类实现 BeanPostProcessor 接口，如下：</p>\n<pre><code class=\"java\">public class BeanPostProcessorTest implements BeanPostProcessor{\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(&quot;Bean [&quot; + beanName + &quot;] 开始初始化&quot;);\n        // 这里一定要返回 bean，不能返回 null\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(&quot;Bean [&quot; + beanName + &quot;] 完成初始化&quot;);\n        return bean;\n    }\n\n    public void display(){\n        System.out.println(&quot;hello BeanPostProcessor!!!&quot;);\n    }\n}\n</code></pre>\n<p>测试方法如下：</p>\n<pre><code class=\"java\">ClassPathResource resource = new ClassPathResource(&quot;spring.xml&quot;);\nDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\nXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\nreader.loadBeanDefinitions(resource);\n\nBeanPostProcessorTest test = (BeanPostProcessorTest) factory.getBean(&quot;beanPostProcessorTest&quot;);\ntest.display();\n</code></pre>\n<p>运行结果：</p>\n<p>运行结果：</p>\n<p><img src=\"/images/pasted-14.png\" alt=\"upload successful\"></p>\n<p>运行结果比较奇怪，为什么没有执行 <code>postProcessBeforeInitialization()</code> 和 <code>postProcessAfterInitialization()</code>呢？</p>\n<p>我们 debug 跟踪下代码，这两个方法在 <code>initializeBean()</code> 方法处调用下，如下：</p>\n<p><img src=\"/images/pasted-15.png\" alt=\"upload successful\"></p>\n<p>debug，在 <code>postProcessBeforeInitialization()</code>方法中结果如下：</p>\n<p><img src=\"/images/pasted-16.png\" alt=\"upload successful\"></p>\n<p>这段代码是通过迭代 <code>getBeanPostProcessors()</code> 返回的结果集来调用 <code>postProcessBeforeInitialization()</code>，但是在这里我们看到该方法返回的结果集为空，所以肯定不会执行相应的 <code>postProcessBeforeInitialization()</code> 方法咯。怎么办？答案不言而喻：只需要 <code>getBeanPostProcessors()</code> 返回的结果集中存在至少一个元素即可，该方法定义如下：</p>\n<pre><code class=\"java\"> public List&lt;BeanPostProcessor&gt; getBeanPostProcessors() {\n  return this.beanPostProcessors;\n }\n</code></pre>\n<p>返回的 beanPostProcessors 是一个 private 的 List ，也就是说只要该类中存在 <code>beanPostProcessors.add()</code> 的调用我们就找到了入口，在类 AbstractBeanFactory 中找到了如下代码：</p>\n<pre><code class=\"java\"> @Override\n public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {\n  Assert.notNull(beanPostProcessor, &quot;BeanPostProcessor must not be null&quot;);\n  this.beanPostProcessors.remove(beanPostProcessor);\n  this.beanPostProcessors.add(beanPostProcessor);\n  if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {\n   this.hasInstantiationAwareBeanPostProcessors = true;\n  }\n  if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {\n   this.hasDestructionAwareBeanPostProcessors = true;\n  }\n }\n</code></pre>\n<p>该方法是由 AbstractBeanFactory 的父类 ConfigurableBeanFactory 定义，它的核心意思就是将指定 BeanPostProcessor 注册到该 BeanFactory 创建的 bean 中，同时它是按照插入的顺序进行注册的，完全忽略 Ordered 接口所表达任何排序语义（在 BeanPostProcessor 中我们提供一个 Ordered 顺序，这个后面讲解）。</p>\n<p>到这里应该就比较熟悉了，其实只需要显示调用 <code>addBeanPostProcessor()</code> 就可以了，加入如下代码。</p>\n<pre><code class=\"java\">BeanPostProcessorTest beanPostProcessorTest = new BeanPostProcessorTest();\nfactory.addBeanPostProcessor(beanPostProcessorTest);\n</code></pre>\n<p>运行结果：</p>\n<p><img src=\"/images/pasted-17.png\" alt=\"upload successful\"></p>\n<p>其实还有一种更加简单的方法，这个我们后面再说，先看 BeanPostProcessor 的原理。</p>\n<h2 id=\"BeanPostProcessor-基本原理\"><a href=\"#BeanPostProcessor-基本原理\" class=\"headerlink\" title=\"BeanPostProcessor 基本原理\"></a>BeanPostProcessor 基本原理</h2><p>BeanPostProcessor 接口定义如下：</p>\n<pre><code class=\"java\">public interface BeanPostProcessor {\n @Nullable\n default Object postProcessBeforeInitialization(Object bean, String beanName) \n     throws BeansException {\n  return bean;\n }\n\n @Nullable\n default Object postProcessAfterInitialization(Object bean, String beanName)\n     throws BeansException {\n  return bean;\n }\n}\n</code></pre>\n<p>BeanPostProcessor 可以理解为是 Spring 的一个工厂钩子（其实 Spring 提供一系列的钩子，如 Aware 、InitializingBean、DisposableBean），它是 Spring 提供的对象实例化阶段强有力的扩展点，允许 Spring 在实例化 bean 阶段对其进行定制化修改，比较常见的使用场景是处理标记接口实现类或者为当前对象提供代理实现（例如AOP）。</p>\n<p>一般普通的 BeanFactory 是不支持自动注册 BeanPostProcessor 的，需要我们手动调用 <code>addBeanPostProcessor()</code> 进行注册，注册后的 BeanPostProcessor 适用于所有该 BeanFactory 创建的 bean，但是 ApplicationContext 可以在其 bean 定义中自动检测所有的 BeanPostProcessor 并自动完成注册，同时将他们应用到随后创建的任何 bean 中。</p>\n<p><code>postProcessBeforeInitialization()</code> 和 <code>postProcessAfterInitialization()</code> 两个方法都接收一个 Object 类型的 bean，一个 String 类型的 beanName，其中 bean 是已经实例化了的 instanceBean，能拿到这个你是不是可以对它为所欲为了？ 这两个方法是初始化 bean 的前后置处理器，他们应用 <code>invokeInitMethods()</code> 前后。如下图：</p>\n<p><img src=\"/images/pasted-18.png\" alt=\"upload successful\"></p>\n<p>代码层次上面已经贴出来，这里再贴一次：</p>\n<p><img src=\"/images/pasted-19.png\" alt=\"upload successful\"></p>\n<p>两者源码如下：</p>\n<pre><code class=\"java\"> @Override\n public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, \n                       String beanName) throws BeansException {\n\n  Object result = existingBean;\n  for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n   Object current = beanProcessor.postProcessBeforeInitialization(result, beanName);\n   if (current == null) {\n    return result;\n   }\n   result = current;\n  }\n  return result;\n }\n\n @Override\n public Object applyBeanPostProcessorsAfterInitialization(Object existingBean,\n                                      String beanName) throws BeansException {\n\n  Object result = existingBean;\n  for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n   Object current = beanProcessor.postProcessAfterInitialization(result, beanName);\n   if (current == null) {\n    return result;\n   }\n   result = current;\n  }\n  return result;\n }\n</code></pre>\n<p><code>getBeanPostProcessors()</code> 返回的是 beanPostProcessors 集合，该集合里面存放就是我们自定义的 BeanPostProcessor，如果该集合中存在元素则调用相应的方法，否则就直接返回 bean 了。这也是为什么使用 BeanFactory 容器是无法输出自定义 BeanPostProcessor 里面的内容，因为在 <code>BeanFactory.getBean()</code> 的过程中根本就没有将我们自定义的 BeanPostProcessor 注入进来，所以要想 BeanFactory 容器 的 BeanPostProcessor 生效我们必须手动调用 <code>addBeanPostProcessor()</code> 将定义的 BeanPostProcessor 注册到相应的 BeanFactory 中。但是 ApplicationContext 不需要手动，因为 ApplicationContext 会自动检测并完成注册。这个在后面讲解ApplicationConext源码时会具体进行分析。</p>\n<p>至此，BeanPostProcessor 已经分析完毕了，这里简单总结下：</p>\n<ol>\n<li>BeanPostProcessor 的作用域是容器级别的，它只和所在的容器相关 ，当 BeanPostProcessor 完成注册后，它会应用于所有跟它在同一个容器内的 bean。</li>\n<li>BeanFactory 和 ApplicationContext 对 BeanPostProcessor 的处理不同，ApplicationContext 会自动检测所有实现了 BeanPostProcessor 接口的 bean，并完成注册，但是使用 BeanFactory 容器时则需要手动调用 <code>addBeanPostProcessor()</code> 完成注册</li>\n<li>ApplicationContext 的 BeanPostProcessor 支持 Ordered，而 BeanFactory 的 BeanPostProcessor 是不支持的，原因在于ApplicationContext 会对 BeanPostProcessor 进行 Ordered 检测并完成排序，而 BeanFactory 中的 BeanPostProcessor 只跟注册的顺序有关。</li>\n</ol>\n<p>下面我们来看一个例子，也是用来解决上篇博客中遗留的一个问题，如何试下一个自定义的Aware，假设我们需要实现一个获取数据库连接的Aware</p>\n<p>ConnectionAware接口定义如下</p>\n<pre><code class=\"java\">public interface ConnectionAware{\n    public void setConnection(Connection con);\n}\n</code></pre>\n<p>添加一个BeanPostProcessor来处理这个ConnectionAware，定义如下：</p>\n<pre><code class=\"java\">public class ConnectionAwareBeanPostProcessor implements BeanPostProcessor {\n    private Connection connection;\n\n    public ConnectionAware(Connection connection) {\n        this.connection = connection;\n    }\n\n    // 不做任何处理\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) \n        throws BeansException {\n        return bean;\n    }\n\n    // 设置connection\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) \n        throws BeansException {\n        if (bean instanceof ConnectionAware){\n            ((ConnectionAware)bean).setConnection(connection);\n            return bean;\n        }\n        return bean;\n    }\n}\n</code></pre>\n<p>剩下的即可以按文章开始的时候那样写，生成一个ConnectionAwareBeanPostProcessor对象然后通过addBeanPostProcessor注册到BeanFactory中，这样后面再生成bean的时候就会处理此类型的Aware。如果是ApplicationContext则不用进行注册，因为它会自动帮你注册，后面我会具体讲解这部分功能。</p>"},{"abbrlink":29,"title":"spring 源码解析之 10bean标签：constructor-arg、property子元素","author":"fengxiutianya","date":"2019-01-13T21:21:00.000Z","_content":"# spring 源码解析之 10bean标签：constructor-arg、property子元素\n\n### 概述\n\n1. Constructor-arg子元素解析\n2. property子元素解析\n<!-- more-->\n\n### constructor-arg子元素解析\n\n简单例子\n\n```java\npublic class StudentService {\n    private String name;\n\n    private Integer age;\n\n    private BookService bookService;\n\n    StudentService(String name, Integer age, BookService bookService){\n        this.name = name;\n        this.age = age;\n        this.bookService = bookService;\n    }\n}\n```\n\n```xml\n<bean id=\"bookService\" class=\"org.springframework.core.service.BookService\"/>\n\n<bean id=\"studentService\" class=\"org.springframework.core.service.StudentService\">\n    <constructor-arg index=\"0\" value=\"chenssy\"/>\n    <constructor-arg name=\"age\" value=\"100\"/>\n    <constructor-arg name=\"bookService\" ref=\"bookService\"/>\n</bean>\n```\n\nStudentService 定义一个构造函数，配置文件中使用 constructor-arg 元素对其配置，该元素可以实现对 StudentService 自动寻找对应的构造函数，并在初始化的时候将值当做参数进行设置。`parseConstructorArgElements()` 方法完成 constructor-arg 子元素的解析。\n\n```java\n    public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {\n        NodeList nl = beanEle.getChildNodes();\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            if (isCandidateElement(node) &&\n                \tnodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {\n                parseConstructorArgElement((Element) node, bd);\n            }\n        }\n    }\n```\n\n遍历所有子元素，如果为 constructor-arg 则调用 `parseConstructorArgElement()` 进行解析。\n\n```java\n    public void parseConstructorArgElement(Element ele, BeanDefinition bd) {\n        // 提取 index、type、name 属性值\n        String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);\n        String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);\n        String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n        // 如果有index\n        if (StringUtils.hasLength(indexAttr)) {\n            try {\n                int index = Integer.parseInt(indexAttr);\n                if (index < 0) {\n                    error(\"'index' cannot be lower than 0\", ele);\n                }\n                else {\n                    try {\n                        // 构造一个 ConstructorArgumentEntry 并将其加入到 ParseState 中\n                        this.parseState.push(new ConstructorArgumentEntry(index));\n\n                        // 解析 ele 对应属性元素\n                        Object value = parsePropertyValue(ele, bd, null);\n\n                        // 根据解析的属性元素构造一个 valueHolder 对象\n                        ConstructorArgumentValues.ValueHolder valueHolder = \n                            new ConstructorArgumentValues.ValueHolder(value);\n                        if (StringUtils.hasLength(typeAttr)) {\n                            valueHolder.setType(typeAttr);\n                        }\n                        if (StringUtils.hasLength(nameAttr)) {\n                            valueHolder.setName(nameAttr);\n                        }\n                        //\n                        valueHolder.setSource(extractSource(ele));\n\n                        // 不允许重复指定相同参数\n                        if (bd.getConstructorArgumentValues()\n                            \t.hasIndexedArgumentValue(index)) {\n                            error(\"Ambiguous constructor-arg entries for index \" \n                                  + index, ele);\n                        }\n                        else {\n                            // 加入到 indexedArgumentValues 中\n                            bd.getConstructorArgumentValues()\n                                .addIndexedArgumentValue(index, valueHolder);\n                        }\n                    }\n                    finally {\n                        this.parseState.pop();\n                    }\n                }\n            }\n            catch (NumberFormatException ex) {\n                error(\"Attribute 'index' of tag 'constructor-arg' \n                      \tmust be an integer\", ele);\n            }\n        }\n        else {\n            // 没有index属性则忽略属性，\n            try {\n                this.parseState.push(new ConstructorArgumentEntry());\n                Object value = parsePropertyValue(ele, bd, null);\n                ConstructorArgumentValues.ValueHolder valueHolder = \n                    new ConstructorArgumentValues.ValueHolder(value);\n                if (StringUtils.hasLength(typeAttr)) {\n                    valueHolder.setType(typeAttr);\n                }\n                if (StringUtils.hasLength(nameAttr)) {\n                    valueHolder.setName(nameAttr);\n                }\n                valueHolder.setSource(extractSource(ele));\n                // 保存参数位置在GenericArgumentValue\n                bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);\n            }\n            finally {\n                this.parseState.pop();\n            }\n        }\n    }\n```\n\n首先获取 index、type、name 三个属性值，然后根据是否存在 index 来区分。其实两者逻辑都差不多，总共分为如下几个步骤（以有 index 为例）：\n\n1. 构造 ConstructorArgumentEntry 对象并将其加入到 ParseState 队列中。ConstructorArgumentEntry 表示构造函数的参数。\n2. 调用 `parsePropertyValue()` 解析 constructor-arg 子元素，返回结果值\n3. 根据解析的结果值构造 `ConstructorArgumentValues.ValueHolder` 实例对象\n4. 将 type、name 封装到 `ConstructorArgumentValues.ValueHolder` 中，然后将 ValueHolder 实例对象添加到 indexedArgumentValues 中。\n\n无 index 的处理逻辑差不多，只有几点不同：构造 ConstructorArgumentEntry 对象时是调用无参构造函数；最后是将 ValueHolder 实例添加到 genericArgumentValues 中。\n\n`parsePropertyValue()` 对子元素进一步解析。\n\n```java\n    public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {\n        String elementName = (propertyName != null) ?\n                \"<property> element for property '\" + propertyName + \"'\" :\n                \"<constructor-arg> element\";\n\t\t// 一个属性只能对应一种类型:ref value list等\n        NodeList nl = ele.getChildNodes();\n        Element subElement = null;\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            // meta 、description 不处理\n            if (node instanceof Element && \n                !nodeNameEquals(node, DESCRIPTION_ELEMENT) &&\n                    !nodeNameEquals(node, META_ELEMENT)) {\n                if (subElement != null) {\n                    error(elementName + \n                          \" must not contain more than one sub-element\", ele);\n                }\n                else {\n                    subElement = (Element) node;\n                }\n            }\n        }\n\n        // 解析 ref 元素\n        boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);\n        // 解析 value 元素\n        boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);\n\n        // constructor-arg 子元素有两种情况不存在\n        // 1. 即存在 ref 又存在 value\n        // 2. 存在 ref 或者 value，但是又有子元素\n        if ((hasRefAttribute && hasValueAttribute) ||\n                ((hasRefAttribute || hasValueAttribute) && subElement != null)) {\n            error(elementName +\n                    \" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element\", ele);\n        }\n\n        if (hasRefAttribute) {\n            // 获取 ref 属性值\n            String refName = ele.getAttribute(REF_ATTRIBUTE);\n            if (!StringUtils.hasText(refName)) {\n                error(elementName + \" contains empty 'ref' attribute\", ele);\n            }\n            // 将 ref 属性值构造为 RuntimeBeanReference 实例对象\n            RuntimeBeanReference ref = new RuntimeBeanReference(refName);\n            ref.setSource(extractSource(ele));\n            return ref;\n        }\n        else if (hasValueAttribute) {\n            // 解析 value 属性值，构造 TypedStringValue 实例对象\n            TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));\n            valueHolder.setSource(extractSource(ele));\n            return valueHolder;\n        }\n        else if (subElement != null) {\n            // 解析子元素\n            return parsePropertySubElement(subElement, bd);\n        }\n        else {\n            // Neither child element nor \"ref\" or \"value\" attribute found.\n            error(elementName + \" must specify a ref or value\", ele);\n            return null;\n        }\n    }\n```\n\n1. 首先略过description或者meta\n\n2. 提取 constructor-arg 子元素的 ref 和 value 的属性值，对其进行判断，以下两种情况是不允许存在的\n\n   - ref 和 value 属性同时存在\n   - 存在 ref 或者 value 且又有子元素\n\n3. 若存在 ref 属性，则获取其值并将其封装进 RuntimeBeanReference 实例对象中\n\n   ```xml\n   <construct-arg ref=\"\"/>\n   ```\n\n4. 若存在 value 属性，则获取其值并将其封装进 TypedStringValue 实例对象中\n\n   ```xml\n   <construct-arg value=\"a\"/>\n   ```\n\n5. 如果子元素不为空，则调用 `parsePropertySubElement()` 进行子元素进一步处理\n\n   ```xml\n   <construct-arg>\n       <map>\n       \t<entry key=\"\" value=\"\"></entry>\n       </map>\n   </construct-arg>\n   ```\n\n   具体源码如下\n\n   ```java\n    public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) {\n           return parsePropertySubElement(ele, bd, null);\n    }\n   \n       public Object parsePropertySubElement(Element ele,\n                                             @Nullable BeanDefinition bd,\n                                             @Nullable String defaultValueType) {\n           // 如果不是默认命名空间，则调用自定义解析\n           if (!isDefaultNamespace(ele)) {\n               return parseNestedCustomElement(ele, bd);\n           }\n           // 解析内置bean\n           else if (nodeNameEquals(ele, BEAN_ELEMENT)) {\n               BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);\n               if (nestedBd != null) {\n                   nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);\n               }\n               return nestedBd;\n           }\n           // 解析ref属性\n           else if (nodeNameEquals(ele, REF_ELEMENT)) {\n               // A generic reference to any name of any bean.\n               String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);\n               boolean toParent = false;\n               if (!StringUtils.hasLength(refName)) {\n                   // A reference to the id of another bean in a parent context.\n                   refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);\n                   toParent = true;\n                   if (!StringUtils.hasLength(refName)) {\n                       error(\"'bean' or 'parent' is required for <ref> element\", ele);\n                       return null;\n                   }\n               }\n               if (!StringUtils.hasText(refName)) {\n                   error(\"<ref> element contains empty target attribute\", ele);\n                   return null;\n               }\n               RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);\n               ref.setSource(extractSource(ele));\n               return ref;\n           }\n           // 解析idref\n           else if (nodeNameEquals(ele, IDREF_ELEMENT)) {\n               return parseIdRefElement(ele);\n           }\n           // 解析value子元素\n           else if (nodeNameEquals(ele, VALUE_ELEMENT)) {\n               return parseValueElement(ele, defaultValueType);\n           }\n           // 解析null子元素的解析\n           else if (nodeNameEquals(ele, NULL_ELEMENT)) {\n               // It's a distinguished null value. Let's wrap it in a TypedStringValue\n               // object in order to preserve the source location.\n               TypedStringValue nullHolder = new TypedStringValue(null);\n               nullHolder.setSource(extractSource(ele));\n               return nullHolder;\n           }\n           // 解析数组\n           else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {\n               return parseArrayElement(ele, bd);\n           }\n           // 解析list\n           else if (nodeNameEquals(ele, LIST_ELEMENT)) {\n               return parseListElement(ele, bd);\n           }\n           // 解析set\n           else if (nodeNameEquals(ele, SET_ELEMENT)) {\n               return parseSetElement(ele, bd);\n           }\n           // 解析map\n           else if (nodeNameEquals(ele, MAP_ELEMENT)) {\n               return parseMapElement(ele, bd);\n           }\n           // 解析props子元素\n           else if (nodeNameEquals(ele, PROPS_ELEMENT)) {\n               return parsePropsElement(ele);\n           }\n           // 如果都不是，则返回错误\n           else {\n               error(\"Unknown property sub-element: [\" + \n                     ele.getNodeName() + \"]\", ele);\n               return null;\n           }\n       }\n   ```\n\n上面我们已经大体上了解construct的解析过程，对各个子类进行分类处理，详细情况如果各位有兴趣可以移步源码进行深一步的探究。\n\n### property 子元素解析\n\n   我们一般使用如下方式来使用 property 子元素。\n\n   ```xml\n<bean id=\"studentService\" class=\"org.springframework.core.service.StudentService\">\n           <property name=\"name\" value=\"chenssy\"/>\n           <property name=\"age\" value=\"18\"/>\n </bean>\n   ```\n\n   对于 property 子元素的解析，Spring 调用 `parsePropertyElements()`。如下：\n\n   ```java\n       public void parsePropertyElements(Element beanEle, BeanDefinition bd) {\n           NodeList nl = beanEle.getChildNodes();\n           for (int i = 0; i < nl.getLength(); i++) {\n               Node node = nl.item(i);\n               if (isCandidateElement(node) && nodeNameEquals(node, PROPERTY_ELEMENT)) {\n                   parsePropertyElement((Element) node, bd);\n               }\n           }\n       }\n   ```\n\n   和 constructor-arg 子元素差不多，同样是提取所有的 property 的子元素，然后调用 `parsePropertyElement()` 进行分析。\n\n   ```java\n       public void parsePropertyElement(Element ele, BeanDefinition bd) {\n           // 获取 name 属性\n           String propertyName = ele.getAttribute(NAME_ATTRIBUTE);\n           if (!StringUtils.hasLength(propertyName)) {\n               error(\"Tag 'property' must have a 'name' attribute\", ele);\n               return;\n           }\n           this.parseState.push(new PropertyEntry(propertyName));\n           try {\n               // 如果存在相同的 name\n               if (bd.getPropertyValues().contains(propertyName)) {\n                   error(\"Multiple 'property' definitions for property '\" + \n                         propertyName + \"'\", ele);\n                   return;\n               }\n   \n               // 解析属性值\n               Object val = parsePropertyValue(ele, bd, propertyName);\n               // 根据解析的属性值构造 PropertyValue 实例对象\n               PropertyValue pv = new PropertyValue(propertyName, val);\n               parseMetaElements(ele, pv);\n               pv.setSource(extractSource(ele));\n               // 添加到 MutablePropertyValues 中\n               bd.getPropertyValues().addPropertyValue(pv);\n           }\n           finally {\n               this.parseState.pop();\n           }\n       }\n   ```\n\n与解析 constructor-arg 子元素步骤差不多。调用 `parsePropertyValue()` 解析子元素属性值，然后根据该值构造 PropertyValue 实例对象并将其添加到 BeanDefinition 中的 MutablePropertyValues 中。\n\n### qualifier子元素解析\n\n对于qualifier元素的获取，我们接触更多的是注解的形式，在使用spring框架中进行自动注入时，spring容器中匹配的候选Bean数目必须有且仅有一个。当找不到一个匹配的bean时，Spring容器将抛出BeanCreationException异常，并且指出必须至少拥有一个匹配的bean。\n\nspring允许我们通过qualifier指定注入bean的名称，这样歧义就消除了，而对于配置方式如下\n\n```xml\n<bean id=\"\" name=\"\">\n    <qualifier type=\"\"  value=\"\"></qualifier>\n</bean>\n```\n\n解析过程与之前大同小异，这里不再重复叙述","source":"_posts/spring 源码分析/spring/spring源码解析之 10bean标签：constructor-arg、property子元素.md","raw":"abbrlink: 29\ntitle: spring 源码解析之 10bean标签：constructor-arg、property子元素\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-14 05:21:00\n---\n# spring 源码解析之 10bean标签：constructor-arg、property子元素\n\n### 概述\n\n1. Constructor-arg子元素解析\n2. property子元素解析\n<!-- more-->\n\n### constructor-arg子元素解析\n\n简单例子\n\n```java\npublic class StudentService {\n    private String name;\n\n    private Integer age;\n\n    private BookService bookService;\n\n    StudentService(String name, Integer age, BookService bookService){\n        this.name = name;\n        this.age = age;\n        this.bookService = bookService;\n    }\n}\n```\n\n```xml\n<bean id=\"bookService\" class=\"org.springframework.core.service.BookService\"/>\n\n<bean id=\"studentService\" class=\"org.springframework.core.service.StudentService\">\n    <constructor-arg index=\"0\" value=\"chenssy\"/>\n    <constructor-arg name=\"age\" value=\"100\"/>\n    <constructor-arg name=\"bookService\" ref=\"bookService\"/>\n</bean>\n```\n\nStudentService 定义一个构造函数，配置文件中使用 constructor-arg 元素对其配置，该元素可以实现对 StudentService 自动寻找对应的构造函数，并在初始化的时候将值当做参数进行设置。`parseConstructorArgElements()` 方法完成 constructor-arg 子元素的解析。\n\n```java\n    public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {\n        NodeList nl = beanEle.getChildNodes();\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            if (isCandidateElement(node) &&\n                \tnodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {\n                parseConstructorArgElement((Element) node, bd);\n            }\n        }\n    }\n```\n\n遍历所有子元素，如果为 constructor-arg 则调用 `parseConstructorArgElement()` 进行解析。\n\n```java\n    public void parseConstructorArgElement(Element ele, BeanDefinition bd) {\n        // 提取 index、type、name 属性值\n        String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);\n        String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);\n        String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n        // 如果有index\n        if (StringUtils.hasLength(indexAttr)) {\n            try {\n                int index = Integer.parseInt(indexAttr);\n                if (index < 0) {\n                    error(\"'index' cannot be lower than 0\", ele);\n                }\n                else {\n                    try {\n                        // 构造一个 ConstructorArgumentEntry 并将其加入到 ParseState 中\n                        this.parseState.push(new ConstructorArgumentEntry(index));\n\n                        // 解析 ele 对应属性元素\n                        Object value = parsePropertyValue(ele, bd, null);\n\n                        // 根据解析的属性元素构造一个 valueHolder 对象\n                        ConstructorArgumentValues.ValueHolder valueHolder = \n                            new ConstructorArgumentValues.ValueHolder(value);\n                        if (StringUtils.hasLength(typeAttr)) {\n                            valueHolder.setType(typeAttr);\n                        }\n                        if (StringUtils.hasLength(nameAttr)) {\n                            valueHolder.setName(nameAttr);\n                        }\n                        //\n                        valueHolder.setSource(extractSource(ele));\n\n                        // 不允许重复指定相同参数\n                        if (bd.getConstructorArgumentValues()\n                            \t.hasIndexedArgumentValue(index)) {\n                            error(\"Ambiguous constructor-arg entries for index \" \n                                  + index, ele);\n                        }\n                        else {\n                            // 加入到 indexedArgumentValues 中\n                            bd.getConstructorArgumentValues()\n                                .addIndexedArgumentValue(index, valueHolder);\n                        }\n                    }\n                    finally {\n                        this.parseState.pop();\n                    }\n                }\n            }\n            catch (NumberFormatException ex) {\n                error(\"Attribute 'index' of tag 'constructor-arg' \n                      \tmust be an integer\", ele);\n            }\n        }\n        else {\n            // 没有index属性则忽略属性，\n            try {\n                this.parseState.push(new ConstructorArgumentEntry());\n                Object value = parsePropertyValue(ele, bd, null);\n                ConstructorArgumentValues.ValueHolder valueHolder = \n                    new ConstructorArgumentValues.ValueHolder(value);\n                if (StringUtils.hasLength(typeAttr)) {\n                    valueHolder.setType(typeAttr);\n                }\n                if (StringUtils.hasLength(nameAttr)) {\n                    valueHolder.setName(nameAttr);\n                }\n                valueHolder.setSource(extractSource(ele));\n                // 保存参数位置在GenericArgumentValue\n                bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);\n            }\n            finally {\n                this.parseState.pop();\n            }\n        }\n    }\n```\n\n首先获取 index、type、name 三个属性值，然后根据是否存在 index 来区分。其实两者逻辑都差不多，总共分为如下几个步骤（以有 index 为例）：\n\n1. 构造 ConstructorArgumentEntry 对象并将其加入到 ParseState 队列中。ConstructorArgumentEntry 表示构造函数的参数。\n2. 调用 `parsePropertyValue()` 解析 constructor-arg 子元素，返回结果值\n3. 根据解析的结果值构造 `ConstructorArgumentValues.ValueHolder` 实例对象\n4. 将 type、name 封装到 `ConstructorArgumentValues.ValueHolder` 中，然后将 ValueHolder 实例对象添加到 indexedArgumentValues 中。\n\n无 index 的处理逻辑差不多，只有几点不同：构造 ConstructorArgumentEntry 对象时是调用无参构造函数；最后是将 ValueHolder 实例添加到 genericArgumentValues 中。\n\n`parsePropertyValue()` 对子元素进一步解析。\n\n```java\n    public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {\n        String elementName = (propertyName != null) ?\n                \"<property> element for property '\" + propertyName + \"'\" :\n                \"<constructor-arg> element\";\n\t\t// 一个属性只能对应一种类型:ref value list等\n        NodeList nl = ele.getChildNodes();\n        Element subElement = null;\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            // meta 、description 不处理\n            if (node instanceof Element && \n                !nodeNameEquals(node, DESCRIPTION_ELEMENT) &&\n                    !nodeNameEquals(node, META_ELEMENT)) {\n                if (subElement != null) {\n                    error(elementName + \n                          \" must not contain more than one sub-element\", ele);\n                }\n                else {\n                    subElement = (Element) node;\n                }\n            }\n        }\n\n        // 解析 ref 元素\n        boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);\n        // 解析 value 元素\n        boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);\n\n        // constructor-arg 子元素有两种情况不存在\n        // 1. 即存在 ref 又存在 value\n        // 2. 存在 ref 或者 value，但是又有子元素\n        if ((hasRefAttribute && hasValueAttribute) ||\n                ((hasRefAttribute || hasValueAttribute) && subElement != null)) {\n            error(elementName +\n                    \" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element\", ele);\n        }\n\n        if (hasRefAttribute) {\n            // 获取 ref 属性值\n            String refName = ele.getAttribute(REF_ATTRIBUTE);\n            if (!StringUtils.hasText(refName)) {\n                error(elementName + \" contains empty 'ref' attribute\", ele);\n            }\n            // 将 ref 属性值构造为 RuntimeBeanReference 实例对象\n            RuntimeBeanReference ref = new RuntimeBeanReference(refName);\n            ref.setSource(extractSource(ele));\n            return ref;\n        }\n        else if (hasValueAttribute) {\n            // 解析 value 属性值，构造 TypedStringValue 实例对象\n            TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));\n            valueHolder.setSource(extractSource(ele));\n            return valueHolder;\n        }\n        else if (subElement != null) {\n            // 解析子元素\n            return parsePropertySubElement(subElement, bd);\n        }\n        else {\n            // Neither child element nor \"ref\" or \"value\" attribute found.\n            error(elementName + \" must specify a ref or value\", ele);\n            return null;\n        }\n    }\n```\n\n1. 首先略过description或者meta\n\n2. 提取 constructor-arg 子元素的 ref 和 value 的属性值，对其进行判断，以下两种情况是不允许存在的\n\n   - ref 和 value 属性同时存在\n   - 存在 ref 或者 value 且又有子元素\n\n3. 若存在 ref 属性，则获取其值并将其封装进 RuntimeBeanReference 实例对象中\n\n   ```xml\n   <construct-arg ref=\"\"/>\n   ```\n\n4. 若存在 value 属性，则获取其值并将其封装进 TypedStringValue 实例对象中\n\n   ```xml\n   <construct-arg value=\"a\"/>\n   ```\n\n5. 如果子元素不为空，则调用 `parsePropertySubElement()` 进行子元素进一步处理\n\n   ```xml\n   <construct-arg>\n       <map>\n       \t<entry key=\"\" value=\"\"></entry>\n       </map>\n   </construct-arg>\n   ```\n\n   具体源码如下\n\n   ```java\n    public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) {\n           return parsePropertySubElement(ele, bd, null);\n    }\n   \n       public Object parsePropertySubElement(Element ele,\n                                             @Nullable BeanDefinition bd,\n                                             @Nullable String defaultValueType) {\n           // 如果不是默认命名空间，则调用自定义解析\n           if (!isDefaultNamespace(ele)) {\n               return parseNestedCustomElement(ele, bd);\n           }\n           // 解析内置bean\n           else if (nodeNameEquals(ele, BEAN_ELEMENT)) {\n               BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);\n               if (nestedBd != null) {\n                   nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);\n               }\n               return nestedBd;\n           }\n           // 解析ref属性\n           else if (nodeNameEquals(ele, REF_ELEMENT)) {\n               // A generic reference to any name of any bean.\n               String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);\n               boolean toParent = false;\n               if (!StringUtils.hasLength(refName)) {\n                   // A reference to the id of another bean in a parent context.\n                   refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);\n                   toParent = true;\n                   if (!StringUtils.hasLength(refName)) {\n                       error(\"'bean' or 'parent' is required for <ref> element\", ele);\n                       return null;\n                   }\n               }\n               if (!StringUtils.hasText(refName)) {\n                   error(\"<ref> element contains empty target attribute\", ele);\n                   return null;\n               }\n               RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);\n               ref.setSource(extractSource(ele));\n               return ref;\n           }\n           // 解析idref\n           else if (nodeNameEquals(ele, IDREF_ELEMENT)) {\n               return parseIdRefElement(ele);\n           }\n           // 解析value子元素\n           else if (nodeNameEquals(ele, VALUE_ELEMENT)) {\n               return parseValueElement(ele, defaultValueType);\n           }\n           // 解析null子元素的解析\n           else if (nodeNameEquals(ele, NULL_ELEMENT)) {\n               // It's a distinguished null value. Let's wrap it in a TypedStringValue\n               // object in order to preserve the source location.\n               TypedStringValue nullHolder = new TypedStringValue(null);\n               nullHolder.setSource(extractSource(ele));\n               return nullHolder;\n           }\n           // 解析数组\n           else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {\n               return parseArrayElement(ele, bd);\n           }\n           // 解析list\n           else if (nodeNameEquals(ele, LIST_ELEMENT)) {\n               return parseListElement(ele, bd);\n           }\n           // 解析set\n           else if (nodeNameEquals(ele, SET_ELEMENT)) {\n               return parseSetElement(ele, bd);\n           }\n           // 解析map\n           else if (nodeNameEquals(ele, MAP_ELEMENT)) {\n               return parseMapElement(ele, bd);\n           }\n           // 解析props子元素\n           else if (nodeNameEquals(ele, PROPS_ELEMENT)) {\n               return parsePropsElement(ele);\n           }\n           // 如果都不是，则返回错误\n           else {\n               error(\"Unknown property sub-element: [\" + \n                     ele.getNodeName() + \"]\", ele);\n               return null;\n           }\n       }\n   ```\n\n上面我们已经大体上了解construct的解析过程，对各个子类进行分类处理，详细情况如果各位有兴趣可以移步源码进行深一步的探究。\n\n### property 子元素解析\n\n   我们一般使用如下方式来使用 property 子元素。\n\n   ```xml\n<bean id=\"studentService\" class=\"org.springframework.core.service.StudentService\">\n           <property name=\"name\" value=\"chenssy\"/>\n           <property name=\"age\" value=\"18\"/>\n </bean>\n   ```\n\n   对于 property 子元素的解析，Spring 调用 `parsePropertyElements()`。如下：\n\n   ```java\n       public void parsePropertyElements(Element beanEle, BeanDefinition bd) {\n           NodeList nl = beanEle.getChildNodes();\n           for (int i = 0; i < nl.getLength(); i++) {\n               Node node = nl.item(i);\n               if (isCandidateElement(node) && nodeNameEquals(node, PROPERTY_ELEMENT)) {\n                   parsePropertyElement((Element) node, bd);\n               }\n           }\n       }\n   ```\n\n   和 constructor-arg 子元素差不多，同样是提取所有的 property 的子元素，然后调用 `parsePropertyElement()` 进行分析。\n\n   ```java\n       public void parsePropertyElement(Element ele, BeanDefinition bd) {\n           // 获取 name 属性\n           String propertyName = ele.getAttribute(NAME_ATTRIBUTE);\n           if (!StringUtils.hasLength(propertyName)) {\n               error(\"Tag 'property' must have a 'name' attribute\", ele);\n               return;\n           }\n           this.parseState.push(new PropertyEntry(propertyName));\n           try {\n               // 如果存在相同的 name\n               if (bd.getPropertyValues().contains(propertyName)) {\n                   error(\"Multiple 'property' definitions for property '\" + \n                         propertyName + \"'\", ele);\n                   return;\n               }\n   \n               // 解析属性值\n               Object val = parsePropertyValue(ele, bd, propertyName);\n               // 根据解析的属性值构造 PropertyValue 实例对象\n               PropertyValue pv = new PropertyValue(propertyName, val);\n               parseMetaElements(ele, pv);\n               pv.setSource(extractSource(ele));\n               // 添加到 MutablePropertyValues 中\n               bd.getPropertyValues().addPropertyValue(pv);\n           }\n           finally {\n               this.parseState.pop();\n           }\n       }\n   ```\n\n与解析 constructor-arg 子元素步骤差不多。调用 `parsePropertyValue()` 解析子元素属性值，然后根据该值构造 PropertyValue 实例对象并将其添加到 BeanDefinition 中的 MutablePropertyValues 中。\n\n### qualifier子元素解析\n\n对于qualifier元素的获取，我们接触更多的是注解的形式，在使用spring框架中进行自动注入时，spring容器中匹配的候选Bean数目必须有且仅有一个。当找不到一个匹配的bean时，Spring容器将抛出BeanCreationException异常，并且指出必须至少拥有一个匹配的bean。\n\nspring允许我们通过qualifier指定注入bean的名称，这样歧义就消除了，而对于配置方式如下\n\n```xml\n<bean id=\"\" name=\"\">\n    <qualifier type=\"\"  value=\"\"></qualifier>\n</bean>\n```\n\n解析过程与之前大同小异，这里不再重复叙述","slug":"spring 源码分析/spring/spring源码解析之 10bean标签：constructor-arg、property子元素","published":1,"updated":"2019-01-15T03:37:31.126Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovx2005c9q1ubqg5hnsr","content":"<h1 id=\"spring-源码解析之-10bean标签：constructor-arg、property子元素\"><a href=\"#spring-源码解析之-10bean标签：constructor-arg、property子元素\" class=\"headerlink\" title=\"spring 源码解析之 10bean标签：constructor-arg、property子元素\"></a>spring 源码解析之 10bean标签：constructor-arg、property子元素</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>Constructor-arg子元素解析</li>\n<li>property子元素解析<a id=\"more\"></a>\n</li>\n</ol>\n<h3 id=\"constructor-arg子元素解析\"><a href=\"#constructor-arg子元素解析\" class=\"headerlink\" title=\"constructor-arg子元素解析\"></a>constructor-arg子元素解析</h3><p>简单例子</p>\n<pre><code class=\"java\">public class StudentService {\n    private String name;\n\n    private Integer age;\n\n    private BookService bookService;\n\n    StudentService(String name, Integer age, BookService bookService){\n        this.name = name;\n        this.age = age;\n        this.bookService = bookService;\n    }\n}\n</code></pre>\n<pre><code class=\"xml\">&lt;bean id=&quot;bookService&quot; class=&quot;org.springframework.core.service.BookService&quot;/&gt;\n\n&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.service.StudentService&quot;&gt;\n    &lt;constructor-arg index=&quot;0&quot; value=&quot;chenssy&quot;/&gt;\n    &lt;constructor-arg name=&quot;age&quot; value=&quot;100&quot;/&gt;\n    &lt;constructor-arg name=&quot;bookService&quot; ref=&quot;bookService&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>StudentService 定义一个构造函数，配置文件中使用 constructor-arg 元素对其配置，该元素可以实现对 StudentService 自动寻找对应的构造函数，并在初始化的时候将值当做参数进行设置。<code>parseConstructorArgElements()</code> 方法完成 constructor-arg 子元素的解析。</p>\n<pre><code class=\"java\">    public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {\n        NodeList nl = beanEle.getChildNodes();\n        for (int i = 0; i &lt; nl.getLength(); i++) {\n            Node node = nl.item(i);\n            if (isCandidateElement(node) &amp;&amp;\n                    nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {\n                parseConstructorArgElement((Element) node, bd);\n            }\n        }\n    }\n</code></pre>\n<p>遍历所有子元素，如果为 constructor-arg 则调用 <code>parseConstructorArgElement()</code> 进行解析。</p>\n<pre><code class=\"java\">    public void parseConstructorArgElement(Element ele, BeanDefinition bd) {\n        // 提取 index、type、name 属性值\n        String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);\n        String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);\n        String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n        // 如果有index\n        if (StringUtils.hasLength(indexAttr)) {\n            try {\n                int index = Integer.parseInt(indexAttr);\n                if (index &lt; 0) {\n                    error(&quot;&#39;index&#39; cannot be lower than 0&quot;, ele);\n                }\n                else {\n                    try {\n                        // 构造一个 ConstructorArgumentEntry 并将其加入到 ParseState 中\n                        this.parseState.push(new ConstructorArgumentEntry(index));\n\n                        // 解析 ele 对应属性元素\n                        Object value = parsePropertyValue(ele, bd, null);\n\n                        // 根据解析的属性元素构造一个 valueHolder 对象\n                        ConstructorArgumentValues.ValueHolder valueHolder = \n                            new ConstructorArgumentValues.ValueHolder(value);\n                        if (StringUtils.hasLength(typeAttr)) {\n                            valueHolder.setType(typeAttr);\n                        }\n                        if (StringUtils.hasLength(nameAttr)) {\n                            valueHolder.setName(nameAttr);\n                        }\n                        //\n                        valueHolder.setSource(extractSource(ele));\n\n                        // 不允许重复指定相同参数\n                        if (bd.getConstructorArgumentValues()\n                                .hasIndexedArgumentValue(index)) {\n                            error(&quot;Ambiguous constructor-arg entries for index &quot; \n                                  + index, ele);\n                        }\n                        else {\n                            // 加入到 indexedArgumentValues 中\n                            bd.getConstructorArgumentValues()\n                                .addIndexedArgumentValue(index, valueHolder);\n                        }\n                    }\n                    finally {\n                        this.parseState.pop();\n                    }\n                }\n            }\n            catch (NumberFormatException ex) {\n                error(&quot;Attribute &#39;index&#39; of tag &#39;constructor-arg&#39; \n                          must be an integer&quot;, ele);\n            }\n        }\n        else {\n            // 没有index属性则忽略属性，\n            try {\n                this.parseState.push(new ConstructorArgumentEntry());\n                Object value = parsePropertyValue(ele, bd, null);\n                ConstructorArgumentValues.ValueHolder valueHolder = \n                    new ConstructorArgumentValues.ValueHolder(value);\n                if (StringUtils.hasLength(typeAttr)) {\n                    valueHolder.setType(typeAttr);\n                }\n                if (StringUtils.hasLength(nameAttr)) {\n                    valueHolder.setName(nameAttr);\n                }\n                valueHolder.setSource(extractSource(ele));\n                // 保存参数位置在GenericArgumentValue\n                bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);\n            }\n            finally {\n                this.parseState.pop();\n            }\n        }\n    }\n</code></pre>\n<p>首先获取 index、type、name 三个属性值，然后根据是否存在 index 来区分。其实两者逻辑都差不多，总共分为如下几个步骤（以有 index 为例）：</p>\n<ol>\n<li>构造 ConstructorArgumentEntry 对象并将其加入到 ParseState 队列中。ConstructorArgumentEntry 表示构造函数的参数。</li>\n<li>调用 <code>parsePropertyValue()</code> 解析 constructor-arg 子元素，返回结果值</li>\n<li>根据解析的结果值构造 <code>ConstructorArgumentValues.ValueHolder</code> 实例对象</li>\n<li>将 type、name 封装到 <code>ConstructorArgumentValues.ValueHolder</code> 中，然后将 ValueHolder 实例对象添加到 indexedArgumentValues 中。</li>\n</ol>\n<p>无 index 的处理逻辑差不多，只有几点不同：构造 ConstructorArgumentEntry 对象时是调用无参构造函数；最后是将 ValueHolder 实例添加到 genericArgumentValues 中。</p>\n<p><code>parsePropertyValue()</code> 对子元素进一步解析。</p>\n<pre><code class=\"java\">    public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {\n        String elementName = (propertyName != null) ?\n                &quot;&lt;property&gt; element for property &#39;&quot; + propertyName + &quot;&#39;&quot; :\n                &quot;&lt;constructor-arg&gt; element&quot;;\n        // 一个属性只能对应一种类型:ref value list等\n        NodeList nl = ele.getChildNodes();\n        Element subElement = null;\n        for (int i = 0; i &lt; nl.getLength(); i++) {\n            Node node = nl.item(i);\n            // meta 、description 不处理\n            if (node instanceof Element &amp;&amp; \n                !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;\n                    !nodeNameEquals(node, META_ELEMENT)) {\n                if (subElement != null) {\n                    error(elementName + \n                          &quot; must not contain more than one sub-element&quot;, ele);\n                }\n                else {\n                    subElement = (Element) node;\n                }\n            }\n        }\n\n        // 解析 ref 元素\n        boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);\n        // 解析 value 元素\n        boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);\n\n        // constructor-arg 子元素有两种情况不存在\n        // 1. 即存在 ref 又存在 value\n        // 2. 存在 ref 或者 value，但是又有子元素\n        if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||\n                ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) {\n            error(elementName +\n                    &quot; is only allowed to contain either &#39;ref&#39; attribute OR &#39;value&#39; attribute OR sub-element&quot;, ele);\n        }\n\n        if (hasRefAttribute) {\n            // 获取 ref 属性值\n            String refName = ele.getAttribute(REF_ATTRIBUTE);\n            if (!StringUtils.hasText(refName)) {\n                error(elementName + &quot; contains empty &#39;ref&#39; attribute&quot;, ele);\n            }\n            // 将 ref 属性值构造为 RuntimeBeanReference 实例对象\n            RuntimeBeanReference ref = new RuntimeBeanReference(refName);\n            ref.setSource(extractSource(ele));\n            return ref;\n        }\n        else if (hasValueAttribute) {\n            // 解析 value 属性值，构造 TypedStringValue 实例对象\n            TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));\n            valueHolder.setSource(extractSource(ele));\n            return valueHolder;\n        }\n        else if (subElement != null) {\n            // 解析子元素\n            return parsePropertySubElement(subElement, bd);\n        }\n        else {\n            // Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found.\n            error(elementName + &quot; must specify a ref or value&quot;, ele);\n            return null;\n        }\n    }\n</code></pre>\n<ol>\n<li><p>首先略过description或者meta</p>\n</li>\n<li><p>提取 constructor-arg 子元素的 ref 和 value 的属性值，对其进行判断，以下两种情况是不允许存在的</p>\n<ul>\n<li>ref 和 value 属性同时存在</li>\n<li>存在 ref 或者 value 且又有子元素</li>\n</ul>\n</li>\n<li><p>若存在 ref 属性，则获取其值并将其封装进 RuntimeBeanReference 实例对象中</p>\n<pre><code class=\"xml\">&lt;construct-arg ref=&quot;&quot;/&gt;\n</code></pre>\n</li>\n<li><p>若存在 value 属性，则获取其值并将其封装进 TypedStringValue 实例对象中</p>\n<pre><code class=\"xml\">&lt;construct-arg value=&quot;a&quot;/&gt;\n</code></pre>\n</li>\n<li><p>如果子元素不为空，则调用 <code>parsePropertySubElement()</code> 进行子元素进一步处理</p>\n<pre><code class=\"xml\">&lt;construct-arg&gt;\n    &lt;map&gt;\n        &lt;entry key=&quot;&quot; value=&quot;&quot;&gt;&lt;/entry&gt;\n    &lt;/map&gt;\n&lt;/construct-arg&gt;\n</code></pre>\n<p>具体源码如下</p>\n<pre><code class=\"java\"> public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) {\n        return parsePropertySubElement(ele, bd, null);\n }\n\n    public Object parsePropertySubElement(Element ele,\n                                          @Nullable BeanDefinition bd,\n                                          @Nullable String defaultValueType) {\n        // 如果不是默认命名空间，则调用自定义解析\n        if (!isDefaultNamespace(ele)) {\n            return parseNestedCustomElement(ele, bd);\n        }\n        // 解析内置bean\n        else if (nodeNameEquals(ele, BEAN_ELEMENT)) {\n            BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);\n            if (nestedBd != null) {\n                nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);\n            }\n            return nestedBd;\n        }\n        // 解析ref属性\n        else if (nodeNameEquals(ele, REF_ELEMENT)) {\n            // A generic reference to any name of any bean.\n            String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);\n            boolean toParent = false;\n            if (!StringUtils.hasLength(refName)) {\n                // A reference to the id of another bean in a parent context.\n                refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);\n                toParent = true;\n                if (!StringUtils.hasLength(refName)) {\n                    error(&quot;&#39;bean&#39; or &#39;parent&#39; is required for &lt;ref&gt; element&quot;, ele);\n                    return null;\n                }\n            }\n            if (!StringUtils.hasText(refName)) {\n                error(&quot;&lt;ref&gt; element contains empty target attribute&quot;, ele);\n                return null;\n            }\n            RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);\n            ref.setSource(extractSource(ele));\n            return ref;\n        }\n        // 解析idref\n        else if (nodeNameEquals(ele, IDREF_ELEMENT)) {\n            return parseIdRefElement(ele);\n        }\n        // 解析value子元素\n        else if (nodeNameEquals(ele, VALUE_ELEMENT)) {\n            return parseValueElement(ele, defaultValueType);\n        }\n        // 解析null子元素的解析\n        else if (nodeNameEquals(ele, NULL_ELEMENT)) {\n            // It&#39;s a distinguished null value. Let&#39;s wrap it in a TypedStringValue\n            // object in order to preserve the source location.\n            TypedStringValue nullHolder = new TypedStringValue(null);\n            nullHolder.setSource(extractSource(ele));\n            return nullHolder;\n        }\n        // 解析数组\n        else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {\n            return parseArrayElement(ele, bd);\n        }\n        // 解析list\n        else if (nodeNameEquals(ele, LIST_ELEMENT)) {\n            return parseListElement(ele, bd);\n        }\n        // 解析set\n        else if (nodeNameEquals(ele, SET_ELEMENT)) {\n            return parseSetElement(ele, bd);\n        }\n        // 解析map\n        else if (nodeNameEquals(ele, MAP_ELEMENT)) {\n            return parseMapElement(ele, bd);\n        }\n        // 解析props子元素\n        else if (nodeNameEquals(ele, PROPS_ELEMENT)) {\n            return parsePropsElement(ele);\n        }\n        // 如果都不是，则返回错误\n        else {\n            error(&quot;Unknown property sub-element: [&quot; + \n                  ele.getNodeName() + &quot;]&quot;, ele);\n            return null;\n        }\n    }\n</code></pre>\n</li>\n</ol>\n<p>上面我们已经大体上了解construct的解析过程，对各个子类进行分类处理，详细情况如果各位有兴趣可以移步源码进行深一步的探究。</p>\n<h3 id=\"property-子元素解析\"><a href=\"#property-子元素解析\" class=\"headerlink\" title=\"property 子元素解析\"></a>property 子元素解析</h3><p>   我们一般使用如下方式来使用 property 子元素。</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.service.StudentService&quot;&gt;\n           &lt;property name=&quot;name&quot; value=&quot;chenssy&quot;/&gt;\n           &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;\n &lt;/bean&gt;\n</code></pre>\n<p>   对于 property 子元素的解析，Spring 调用 <code>parsePropertyElements()</code>。如下：</p>\n<pre><code class=\"java\">       public void parsePropertyElements(Element beanEle, BeanDefinition bd) {\n           NodeList nl = beanEle.getChildNodes();\n           for (int i = 0; i &lt; nl.getLength(); i++) {\n               Node node = nl.item(i);\n               if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) {\n                   parsePropertyElement((Element) node, bd);\n               }\n           }\n       }\n</code></pre>\n<p>   和 constructor-arg 子元素差不多，同样是提取所有的 property 的子元素，然后调用 <code>parsePropertyElement()</code> 进行分析。</p>\n<pre><code class=\"java\">       public void parsePropertyElement(Element ele, BeanDefinition bd) {\n           // 获取 name 属性\n           String propertyName = ele.getAttribute(NAME_ATTRIBUTE);\n           if (!StringUtils.hasLength(propertyName)) {\n               error(&quot;Tag &#39;property&#39; must have a &#39;name&#39; attribute&quot;, ele);\n               return;\n           }\n           this.parseState.push(new PropertyEntry(propertyName));\n           try {\n               // 如果存在相同的 name\n               if (bd.getPropertyValues().contains(propertyName)) {\n                   error(&quot;Multiple &#39;property&#39; definitions for property &#39;&quot; + \n                         propertyName + &quot;&#39;&quot;, ele);\n                   return;\n               }\n\n               // 解析属性值\n               Object val = parsePropertyValue(ele, bd, propertyName);\n               // 根据解析的属性值构造 PropertyValue 实例对象\n               PropertyValue pv = new PropertyValue(propertyName, val);\n               parseMetaElements(ele, pv);\n               pv.setSource(extractSource(ele));\n               // 添加到 MutablePropertyValues 中\n               bd.getPropertyValues().addPropertyValue(pv);\n           }\n           finally {\n               this.parseState.pop();\n           }\n       }\n</code></pre>\n<p>与解析 constructor-arg 子元素步骤差不多。调用 <code>parsePropertyValue()</code> 解析子元素属性值，然后根据该值构造 PropertyValue 实例对象并将其添加到 BeanDefinition 中的 MutablePropertyValues 中。</p>\n<h3 id=\"qualifier子元素解析\"><a href=\"#qualifier子元素解析\" class=\"headerlink\" title=\"qualifier子元素解析\"></a>qualifier子元素解析</h3><p>对于qualifier元素的获取，我们接触更多的是注解的形式，在使用spring框架中进行自动注入时，spring容器中匹配的候选Bean数目必须有且仅有一个。当找不到一个匹配的bean时，Spring容器将抛出BeanCreationException异常，并且指出必须至少拥有一个匹配的bean。</p>\n<p>spring允许我们通过qualifier指定注入bean的名称，这样歧义就消除了，而对于配置方式如下</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;&quot; name=&quot;&quot;&gt;\n    &lt;qualifier type=&quot;&quot;  value=&quot;&quot;&gt;&lt;/qualifier&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>解析过程与之前大同小异，这里不再重复叙述</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring-源码解析之-10bean标签：constructor-arg、property子元素\"><a href=\"#spring-源码解析之-10bean标签：constructor-arg、property子元素\" class=\"headerlink\" title=\"spring 源码解析之 10bean标签：constructor-arg、property子元素\"></a>spring 源码解析之 10bean标签：constructor-arg、property子元素</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>Constructor-arg子元素解析</li>\n<li>property子元素解析","more":"</li>\n</ol>\n<h3 id=\"constructor-arg子元素解析\"><a href=\"#constructor-arg子元素解析\" class=\"headerlink\" title=\"constructor-arg子元素解析\"></a>constructor-arg子元素解析</h3><p>简单例子</p>\n<pre><code class=\"java\">public class StudentService {\n    private String name;\n\n    private Integer age;\n\n    private BookService bookService;\n\n    StudentService(String name, Integer age, BookService bookService){\n        this.name = name;\n        this.age = age;\n        this.bookService = bookService;\n    }\n}\n</code></pre>\n<pre><code class=\"xml\">&lt;bean id=&quot;bookService&quot; class=&quot;org.springframework.core.service.BookService&quot;/&gt;\n\n&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.service.StudentService&quot;&gt;\n    &lt;constructor-arg index=&quot;0&quot; value=&quot;chenssy&quot;/&gt;\n    &lt;constructor-arg name=&quot;age&quot; value=&quot;100&quot;/&gt;\n    &lt;constructor-arg name=&quot;bookService&quot; ref=&quot;bookService&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>StudentService 定义一个构造函数，配置文件中使用 constructor-arg 元素对其配置，该元素可以实现对 StudentService 自动寻找对应的构造函数，并在初始化的时候将值当做参数进行设置。<code>parseConstructorArgElements()</code> 方法完成 constructor-arg 子元素的解析。</p>\n<pre><code class=\"java\">    public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {\n        NodeList nl = beanEle.getChildNodes();\n        for (int i = 0; i &lt; nl.getLength(); i++) {\n            Node node = nl.item(i);\n            if (isCandidateElement(node) &amp;&amp;\n                    nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {\n                parseConstructorArgElement((Element) node, bd);\n            }\n        }\n    }\n</code></pre>\n<p>遍历所有子元素，如果为 constructor-arg 则调用 <code>parseConstructorArgElement()</code> 进行解析。</p>\n<pre><code class=\"java\">    public void parseConstructorArgElement(Element ele, BeanDefinition bd) {\n        // 提取 index、type、name 属性值\n        String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);\n        String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);\n        String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n        // 如果有index\n        if (StringUtils.hasLength(indexAttr)) {\n            try {\n                int index = Integer.parseInt(indexAttr);\n                if (index &lt; 0) {\n                    error(&quot;&#39;index&#39; cannot be lower than 0&quot;, ele);\n                }\n                else {\n                    try {\n                        // 构造一个 ConstructorArgumentEntry 并将其加入到 ParseState 中\n                        this.parseState.push(new ConstructorArgumentEntry(index));\n\n                        // 解析 ele 对应属性元素\n                        Object value = parsePropertyValue(ele, bd, null);\n\n                        // 根据解析的属性元素构造一个 valueHolder 对象\n                        ConstructorArgumentValues.ValueHolder valueHolder = \n                            new ConstructorArgumentValues.ValueHolder(value);\n                        if (StringUtils.hasLength(typeAttr)) {\n                            valueHolder.setType(typeAttr);\n                        }\n                        if (StringUtils.hasLength(nameAttr)) {\n                            valueHolder.setName(nameAttr);\n                        }\n                        //\n                        valueHolder.setSource(extractSource(ele));\n\n                        // 不允许重复指定相同参数\n                        if (bd.getConstructorArgumentValues()\n                                .hasIndexedArgumentValue(index)) {\n                            error(&quot;Ambiguous constructor-arg entries for index &quot; \n                                  + index, ele);\n                        }\n                        else {\n                            // 加入到 indexedArgumentValues 中\n                            bd.getConstructorArgumentValues()\n                                .addIndexedArgumentValue(index, valueHolder);\n                        }\n                    }\n                    finally {\n                        this.parseState.pop();\n                    }\n                }\n            }\n            catch (NumberFormatException ex) {\n                error(&quot;Attribute &#39;index&#39; of tag &#39;constructor-arg&#39; \n                          must be an integer&quot;, ele);\n            }\n        }\n        else {\n            // 没有index属性则忽略属性，\n            try {\n                this.parseState.push(new ConstructorArgumentEntry());\n                Object value = parsePropertyValue(ele, bd, null);\n                ConstructorArgumentValues.ValueHolder valueHolder = \n                    new ConstructorArgumentValues.ValueHolder(value);\n                if (StringUtils.hasLength(typeAttr)) {\n                    valueHolder.setType(typeAttr);\n                }\n                if (StringUtils.hasLength(nameAttr)) {\n                    valueHolder.setName(nameAttr);\n                }\n                valueHolder.setSource(extractSource(ele));\n                // 保存参数位置在GenericArgumentValue\n                bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);\n            }\n            finally {\n                this.parseState.pop();\n            }\n        }\n    }\n</code></pre>\n<p>首先获取 index、type、name 三个属性值，然后根据是否存在 index 来区分。其实两者逻辑都差不多，总共分为如下几个步骤（以有 index 为例）：</p>\n<ol>\n<li>构造 ConstructorArgumentEntry 对象并将其加入到 ParseState 队列中。ConstructorArgumentEntry 表示构造函数的参数。</li>\n<li>调用 <code>parsePropertyValue()</code> 解析 constructor-arg 子元素，返回结果值</li>\n<li>根据解析的结果值构造 <code>ConstructorArgumentValues.ValueHolder</code> 实例对象</li>\n<li>将 type、name 封装到 <code>ConstructorArgumentValues.ValueHolder</code> 中，然后将 ValueHolder 实例对象添加到 indexedArgumentValues 中。</li>\n</ol>\n<p>无 index 的处理逻辑差不多，只有几点不同：构造 ConstructorArgumentEntry 对象时是调用无参构造函数；最后是将 ValueHolder 实例添加到 genericArgumentValues 中。</p>\n<p><code>parsePropertyValue()</code> 对子元素进一步解析。</p>\n<pre><code class=\"java\">    public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {\n        String elementName = (propertyName != null) ?\n                &quot;&lt;property&gt; element for property &#39;&quot; + propertyName + &quot;&#39;&quot; :\n                &quot;&lt;constructor-arg&gt; element&quot;;\n        // 一个属性只能对应一种类型:ref value list等\n        NodeList nl = ele.getChildNodes();\n        Element subElement = null;\n        for (int i = 0; i &lt; nl.getLength(); i++) {\n            Node node = nl.item(i);\n            // meta 、description 不处理\n            if (node instanceof Element &amp;&amp; \n                !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;\n                    !nodeNameEquals(node, META_ELEMENT)) {\n                if (subElement != null) {\n                    error(elementName + \n                          &quot; must not contain more than one sub-element&quot;, ele);\n                }\n                else {\n                    subElement = (Element) node;\n                }\n            }\n        }\n\n        // 解析 ref 元素\n        boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);\n        // 解析 value 元素\n        boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);\n\n        // constructor-arg 子元素有两种情况不存在\n        // 1. 即存在 ref 又存在 value\n        // 2. 存在 ref 或者 value，但是又有子元素\n        if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||\n                ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) {\n            error(elementName +\n                    &quot; is only allowed to contain either &#39;ref&#39; attribute OR &#39;value&#39; attribute OR sub-element&quot;, ele);\n        }\n\n        if (hasRefAttribute) {\n            // 获取 ref 属性值\n            String refName = ele.getAttribute(REF_ATTRIBUTE);\n            if (!StringUtils.hasText(refName)) {\n                error(elementName + &quot; contains empty &#39;ref&#39; attribute&quot;, ele);\n            }\n            // 将 ref 属性值构造为 RuntimeBeanReference 实例对象\n            RuntimeBeanReference ref = new RuntimeBeanReference(refName);\n            ref.setSource(extractSource(ele));\n            return ref;\n        }\n        else if (hasValueAttribute) {\n            // 解析 value 属性值，构造 TypedStringValue 实例对象\n            TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));\n            valueHolder.setSource(extractSource(ele));\n            return valueHolder;\n        }\n        else if (subElement != null) {\n            // 解析子元素\n            return parsePropertySubElement(subElement, bd);\n        }\n        else {\n            // Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found.\n            error(elementName + &quot; must specify a ref or value&quot;, ele);\n            return null;\n        }\n    }\n</code></pre>\n<ol>\n<li><p>首先略过description或者meta</p>\n</li>\n<li><p>提取 constructor-arg 子元素的 ref 和 value 的属性值，对其进行判断，以下两种情况是不允许存在的</p>\n<ul>\n<li>ref 和 value 属性同时存在</li>\n<li>存在 ref 或者 value 且又有子元素</li>\n</ul>\n</li>\n<li><p>若存在 ref 属性，则获取其值并将其封装进 RuntimeBeanReference 实例对象中</p>\n<pre><code class=\"xml\">&lt;construct-arg ref=&quot;&quot;/&gt;\n</code></pre>\n</li>\n<li><p>若存在 value 属性，则获取其值并将其封装进 TypedStringValue 实例对象中</p>\n<pre><code class=\"xml\">&lt;construct-arg value=&quot;a&quot;/&gt;\n</code></pre>\n</li>\n<li><p>如果子元素不为空，则调用 <code>parsePropertySubElement()</code> 进行子元素进一步处理</p>\n<pre><code class=\"xml\">&lt;construct-arg&gt;\n    &lt;map&gt;\n        &lt;entry key=&quot;&quot; value=&quot;&quot;&gt;&lt;/entry&gt;\n    &lt;/map&gt;\n&lt;/construct-arg&gt;\n</code></pre>\n<p>具体源码如下</p>\n<pre><code class=\"java\"> public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) {\n        return parsePropertySubElement(ele, bd, null);\n }\n\n    public Object parsePropertySubElement(Element ele,\n                                          @Nullable BeanDefinition bd,\n                                          @Nullable String defaultValueType) {\n        // 如果不是默认命名空间，则调用自定义解析\n        if (!isDefaultNamespace(ele)) {\n            return parseNestedCustomElement(ele, bd);\n        }\n        // 解析内置bean\n        else if (nodeNameEquals(ele, BEAN_ELEMENT)) {\n            BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);\n            if (nestedBd != null) {\n                nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);\n            }\n            return nestedBd;\n        }\n        // 解析ref属性\n        else if (nodeNameEquals(ele, REF_ELEMENT)) {\n            // A generic reference to any name of any bean.\n            String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);\n            boolean toParent = false;\n            if (!StringUtils.hasLength(refName)) {\n                // A reference to the id of another bean in a parent context.\n                refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);\n                toParent = true;\n                if (!StringUtils.hasLength(refName)) {\n                    error(&quot;&#39;bean&#39; or &#39;parent&#39; is required for &lt;ref&gt; element&quot;, ele);\n                    return null;\n                }\n            }\n            if (!StringUtils.hasText(refName)) {\n                error(&quot;&lt;ref&gt; element contains empty target attribute&quot;, ele);\n                return null;\n            }\n            RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);\n            ref.setSource(extractSource(ele));\n            return ref;\n        }\n        // 解析idref\n        else if (nodeNameEquals(ele, IDREF_ELEMENT)) {\n            return parseIdRefElement(ele);\n        }\n        // 解析value子元素\n        else if (nodeNameEquals(ele, VALUE_ELEMENT)) {\n            return parseValueElement(ele, defaultValueType);\n        }\n        // 解析null子元素的解析\n        else if (nodeNameEquals(ele, NULL_ELEMENT)) {\n            // It&#39;s a distinguished null value. Let&#39;s wrap it in a TypedStringValue\n            // object in order to preserve the source location.\n            TypedStringValue nullHolder = new TypedStringValue(null);\n            nullHolder.setSource(extractSource(ele));\n            return nullHolder;\n        }\n        // 解析数组\n        else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {\n            return parseArrayElement(ele, bd);\n        }\n        // 解析list\n        else if (nodeNameEquals(ele, LIST_ELEMENT)) {\n            return parseListElement(ele, bd);\n        }\n        // 解析set\n        else if (nodeNameEquals(ele, SET_ELEMENT)) {\n            return parseSetElement(ele, bd);\n        }\n        // 解析map\n        else if (nodeNameEquals(ele, MAP_ELEMENT)) {\n            return parseMapElement(ele, bd);\n        }\n        // 解析props子元素\n        else if (nodeNameEquals(ele, PROPS_ELEMENT)) {\n            return parsePropsElement(ele);\n        }\n        // 如果都不是，则返回错误\n        else {\n            error(&quot;Unknown property sub-element: [&quot; + \n                  ele.getNodeName() + &quot;]&quot;, ele);\n            return null;\n        }\n    }\n</code></pre>\n</li>\n</ol>\n<p>上面我们已经大体上了解construct的解析过程，对各个子类进行分类处理，详细情况如果各位有兴趣可以移步源码进行深一步的探究。</p>\n<h3 id=\"property-子元素解析\"><a href=\"#property-子元素解析\" class=\"headerlink\" title=\"property 子元素解析\"></a>property 子元素解析</h3><p>   我们一般使用如下方式来使用 property 子元素。</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.service.StudentService&quot;&gt;\n           &lt;property name=&quot;name&quot; value=&quot;chenssy&quot;/&gt;\n           &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;\n &lt;/bean&gt;\n</code></pre>\n<p>   对于 property 子元素的解析，Spring 调用 <code>parsePropertyElements()</code>。如下：</p>\n<pre><code class=\"java\">       public void parsePropertyElements(Element beanEle, BeanDefinition bd) {\n           NodeList nl = beanEle.getChildNodes();\n           for (int i = 0; i &lt; nl.getLength(); i++) {\n               Node node = nl.item(i);\n               if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) {\n                   parsePropertyElement((Element) node, bd);\n               }\n           }\n       }\n</code></pre>\n<p>   和 constructor-arg 子元素差不多，同样是提取所有的 property 的子元素，然后调用 <code>parsePropertyElement()</code> 进行分析。</p>\n<pre><code class=\"java\">       public void parsePropertyElement(Element ele, BeanDefinition bd) {\n           // 获取 name 属性\n           String propertyName = ele.getAttribute(NAME_ATTRIBUTE);\n           if (!StringUtils.hasLength(propertyName)) {\n               error(&quot;Tag &#39;property&#39; must have a &#39;name&#39; attribute&quot;, ele);\n               return;\n           }\n           this.parseState.push(new PropertyEntry(propertyName));\n           try {\n               // 如果存在相同的 name\n               if (bd.getPropertyValues().contains(propertyName)) {\n                   error(&quot;Multiple &#39;property&#39; definitions for property &#39;&quot; + \n                         propertyName + &quot;&#39;&quot;, ele);\n                   return;\n               }\n\n               // 解析属性值\n               Object val = parsePropertyValue(ele, bd, propertyName);\n               // 根据解析的属性值构造 PropertyValue 实例对象\n               PropertyValue pv = new PropertyValue(propertyName, val);\n               parseMetaElements(ele, pv);\n               pv.setSource(extractSource(ele));\n               // 添加到 MutablePropertyValues 中\n               bd.getPropertyValues().addPropertyValue(pv);\n           }\n           finally {\n               this.parseState.pop();\n           }\n       }\n</code></pre>\n<p>与解析 constructor-arg 子元素步骤差不多。调用 <code>parsePropertyValue()</code> 解析子元素属性值，然后根据该值构造 PropertyValue 实例对象并将其添加到 BeanDefinition 中的 MutablePropertyValues 中。</p>\n<h3 id=\"qualifier子元素解析\"><a href=\"#qualifier子元素解析\" class=\"headerlink\" title=\"qualifier子元素解析\"></a>qualifier子元素解析</h3><p>对于qualifier元素的获取，我们接触更多的是注解的形式，在使用spring框架中进行自动注入时，spring容器中匹配的候选Bean数目必须有且仅有一个。当找不到一个匹配的bean时，Spring容器将抛出BeanCreationException异常，并且指出必须至少拥有一个匹配的bean。</p>\n<p>spring允许我们通过qualifier指定注入bean的名称，这样歧义就消除了，而对于配置方式如下</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;&quot; name=&quot;&quot;&gt;\n    &lt;qualifier type=&quot;&quot;  value=&quot;&quot;&gt;&lt;/qualifier&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>解析过程与之前大同小异，这里不再重复叙述</p>"},{"abbrlink":34,"title":"spring源码解析之 15BeanDefinition解析总结","author":"fengxitianya","date":"2019-01-13T22:19:00.000Z","_content":"# spring源码解析之 15BeanDefinition解析总结\n\n前面 13 篇博文从源码层次分析了 IOC 整个初始化过程，这篇就这些内容做一个总结将其连贯起来。\n\n在前文提过，IOC 容器的初始化过程分为三步骤：Resource 定位、BeanDefinition 的载入和解析，BeanDefinition 注册。\n<!-- more-->\n\n![upload successful](/images/pasted-11.png)\n\n- **Resource 定位**。我们一般用外部资源来描述 Bean 对象，所以在初始化 IOC 容器的第一步就是需要定位这个外部资源。\n- **BeanDefinition 的载入和解析**。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IOC 容器的内部数据结构：BeanDefinition。在 IOC 容器内部维护着一个 BeanDefinition Map 的数据结构，在配置文件中每一个都对应着一个BeanDefinition对象。\n- **BeanDefinition 注册**。向IOC容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistery 接口来实现的。在 IOC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IOC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。在这里需要注意的一点是这个过程并没有完成依赖注入，依赖注册是发生在应用第一次调用 `getBean()` 向容器索要 Bean 时。当然我们可以通过设置预处理，即对某个 Bean 设置 lazyinit 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。\n\n还记得在博客[spring 源码解析之 04加载bean](https://taolove.top/posts/23/) 中提供的一段代码吗？这里我们同样也以这段代码作为我们研究 IOC 初始化过程的开端，如下：\n\n```java\nClassPathResource resource = new ClassPathResource(\"bean.xml\");\nDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\nXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\nreader.loadBeanDefinitions(resource);\n```\n\n刚刚开始的时候可能对上面这几行代码不知道什么意思，现在应该就一目了然了。\n\n- `ClassPathResource resource = new ClassPathResource(\"bean.xml\");`： 根据 Xml 配置文件创建 Resource 资源对象。ClassPathResource 是 Resource 接口的子类，bean.xml 文件中的内容是我们定义的 Bean 信息。\n- `DefaultListableBeanFactory factory = new DefaultListableBeanFactory();` 创建一个 BeanFactory。DefaultListableBeanFactory 是 BeanFactory 的一个子类，BeanFactory 作为一个接口，其实它本身是不具有独立使用的功能的，而 DefaultListableBeanFactory 则是真正可以独立使用的 IOC 容器，它是整个 Spring IOC 的始祖，在后续会有专门的文章来分析它。\n- `XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);`：创建 XmlBeanDefinitionReader 读取器，用于载入 BeanDefinition 。\n- `reader.loadBeanDefinitions(resource);`：开启 Bean 的载入和注册进程，完成后的 Bean 放置在 IOC 容器中。\n\n## Resource 定位\n\nSpring 为了解决资源定位的问题，提供了两个接口：Resource、ResourceLoader，其中 Resource 接口是 Spring 统一资源的抽象接口，ResourceLoader 则是 Spring 资源加载的统一抽象。关于Resource、ResourceLoader 的更多知识请关注[spring源码解析之 03统一资源加载](https://taolove.top/posts/22/)\n\nResource 资源的定位需要 Resource 和 ResourceLoader 两个接口互相配合，在上面那段代码中 `new ClassPathResource(\"bean.xml\")` 为我们定义了资源，那么 ResourceLoader 则是在什么时候初始化的呢？看 XmlBeanDefinitionReader 构造方法：\n\n```java\n    public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) {\n        super(registry);\n    }\n```\n\n直接调用父类 AbstractBeanDefinitionReader ：\n\n```java\n    protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) {\n        Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n        this.registry = registry;\n\n        // Determine ResourceLoader to use.\n        if (this.registry instanceof ResourceLoader) {\n            this.resourceLoader = (ResourceLoader) this.registry;\n        }\n        else {\n            this.resourceLoader = new PathMatchingResourcePatternResolver();\n        }\n\n        // Inherit Environment if possible\n        if (this.registry instanceof EnvironmentCapable) {\n            this.environment = ((EnvironmentCapable) this.registry).getEnvironment();\n        }\n        else {\n            this.environment = new StandardEnvironment();\n        }\n    }\n```\n\n核心在于设置 resourceLoader 这段，如果设置了 ResourceLoader 则用设置的，否则使用 PathMatchingResourcePatternResolver ，该类是一个集大成者的 ResourceLoader。\n\n## BeanDefinition 的载入和解析\n\n`reader.loadBeanDefinitions(resource);` 开启 BeanDefinition 的解析过程。如下：\n\n```java\n    public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {\n        return loadBeanDefinitions(new EncodedResource(resource));\n    }\n```\n\n在这个方法会将资源 resource 包装成一个 EncodedResource 实例对象，然后调用 `loadBeanDefinitions()` 方法，而将 Resource 封装成 EncodedResource 主要是为了对 Resource 进行编码，保证内容读取的正确性。\n\n```java\n   public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n        // 省略一些代码\n        try {\n            // 将资源文件转为 InputStream 的 IO 流\n            InputStream inputStream = encodedResource.getResource().getInputStream();\n            try {\n                // 从 InputStream 中得到 XML 的解析源\n                InputSource inputSource = new InputSource(inputStream);\n                if (encodedResource.getEncoding() != null) {\n                    inputSource.setEncoding(encodedResource.getEncoding());\n                }\n\n                // 具体的读取过程\n                return doLoadBeanDefinitions(inputSource, \n                                             encodedResource.getResource());\n            }\n            finally {\n                inputStream.close();\n            }\n        }\n        // 省略一些代码\n    }\n```\n\n从 encodedResource 源中获取 xml 的解析源，调用 `doLoadBeanDefinitions()` 执行具体的解析过程。\n\n```java\n    protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n            throws BeanDefinitionStoreException {\n        try {\n            Document doc = doLoadDocument(inputSource, resource);\n            return registerBeanDefinitions(doc, resource);\n        }\n        // 省略很多catch代码\n```\n\n在该方法中主要做两件事：\n\n1. 根据 xml 解析源获取相应的 Document 对象\n\n2. 调用 `registerBeanDefinitions()` 开启 BeanDefinition 的解析注册过程。\n\n### 转换为 Document 对象\n\n调用 `doLoadDocument()` 会将 Bean 定义的资源转换为 Document 对象。\n\n```java\n    protected Document doLoadDocument(InputSource inputSource, Resource resource) \n        throws Exception {\n        return this.documentLoader\n            .loadDocument(inputSource, getEntityResolver(), this.errorHandler,\n                getValidationModeForResource(resource), isNamespaceAware());\n    }\n```\n\n`loadDocument()` 方法接受五个参数：\n\n- **inputSource**：加载 Document 的 Resource 源\n- **entityResolver**：解析文件的解析器\n- **errorHandler**：处理加载 Document 对象的过程的错误\n- **validationMode**：验证模式\n- **namespaceAware**：命名空间支持。如果要提供对 XML 名称空间的支持，则为true\n\n对于这五个参数，有两个参数需要重点关注下：entityResolver、validationMode。这两个参数分别在[spring 源码解析之 04（上）加载bean](http://127.0.0.1:4000/posts/23/)   和  [spring源码解析之 04（下）获取验证模型](http://127.0.0.1:4000/posts/35/) 中有详细的讲述。\n\n`loadDocument()` 在类 DefaultDocumentLoader 中提供了实现，如下：\n\n```java\n    public Document loadDocument(InputSource inputSource, \n                                 EntityResolver entityResolver,\n            ErrorHandler errorHandler, int validationMode, boolean namespaceAware) \n        throws Exception {\n        // 创建文件解析工厂\n        DocumentBuilderFactory factory = \n            createDocumentBuilderFactory(validationMode, namespaceAware);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Using JAXP provider [\" + factory.getClass().getName() + \"]\");\n        }\n        // 创建文档解析器\n        DocumentBuilder builder = \n            createDocumentBuilder(factory, entityResolver, errorHandler);\n        // 解析 Spring 的 Bean 定义资源\n        return builder.parse(inputSource);\n    }\n```\n\n这到这里，就已经将定义的 Bean 资源文件，载入并转换为 Document 对象了，那么下一步就是如何将其解析为 Spring IOC 管理的 Bean 对象并将其注册到容器中。这个过程有方法 `registerBeanDefinitions()` 实现。如下：\n\n```java\n    public int registerBeanDefinitions(Document doc, Resource resource)\n        throws BeanDefinitionStoreException {\n       // 创建 BeanDefinitionDocumentReader 来对 xml 格式的BeanDefinition 解析\n        BeanDefinitionDocumentReader documentReader = \n            \t\tcreateBeanDefinitionDocumentReader();\n        // 获得容器中注册的Bean数量\n        int countBefore = getRegistry().getBeanDefinitionCount();\n\n        // 解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口，\n        // 具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成\n        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n        return getRegistry().getBeanDefinitionCount() - countBefore;\n    }\n```\n\n首先创建 BeanDefinition 的解析器 BeanDefinitionDocumentReader，然后调用 `documentReader.registerBeanDefinitions()` 开启解析过程，这里使用的是委派模式，具体的实现由子类 DefaultBeanDefinitionDocumentReader 完成。\n\n```java\n    public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n       // 获得XML描述符\n        this.readerContext = readerContext;\n        logger.debug(\"Loading bean definitions\");\n\n        // 获得Document的根元素\n        Element root = doc.getDocumentElement();\n\n        // 解析根元素\n        doRegisterBeanDefinitions(root);\n    }\n```\n\n### 对 Document 对象的解析\n\n从 Document 对象中获取根元素 root，然后调用 `doRegisterBeanDefinitions()` 开启真正的解析过程。\n\n```java\n    protected void doRegisterBeanDefinitions(Element root) {\n        BeanDefinitionParserDelegate parent = this.delegate;\n        this.delegate = createDelegate(getReaderContext(), root, parent);\n\n       // 省略部分代码\n\n        preProcessXml(root);\n        parseBeanDefinitions(root, this.delegate);\n        postProcessXml(root);\n\n        this.delegate = parent;\n    }\n```\n\n`preProcessXml()`、`postProcessXml()` 为前置、后置增强处理，目前 Spring 中都是空实现， `parseBeanDefinitions()` 是对根元素 root 的解析注册过程。\n\n```java\n    protected void parseBeanDefinitions(Element root, \n                                        BeanDefinitionParserDelegate delegate) {\n       // Bean定义的Document对象使用了Spring默认的XML命名空间\n        if (delegate.isDefaultNamespace(root)) {\n          // 获取Bean定义的Document对象根元素的所有子节点\n            NodeList nl = root.getChildNodes();\n            for (int i = 0; i < nl.getLength(); i++) {\n                Node node = nl.item(i);\n                // 获得Document节点是XML元素节点 \n                if (node instanceof Element) {\n                    Element ele = (Element) node;\n                    // Bean定义的Document的元素节点使用的是Spring默认的XML命名空间\n                    if (delegate.isDefaultNamespace(ele)) {\n                       // 使用Spring的Bean规则解析元素节点（默认解析规则）\n                        parseDefaultElement(ele, delegate);\n                    }\n                    else {\n                       // 没有使用Spring默认的XML命名空间，则使用用户自定义的解析规则解析元素节点 \n                        delegate.parseCustomElement(ele);\n                    }\n                }\n            }\n        }\n        else {\n          // Document 的根节点没有使用Spring默认的命名空间，则使用用户自定义的解析规则解析\n            delegate.parseCustomElement(root);\n        }\n    }\n```\n\n迭代 root 元素的所有子节点，对其进行判断，若节点为默认命名空间，则ID调用 `parseDefaultElement()` 开启默认标签的解析注册过程，否则调用 `parseCustomElement()` 开启自定义标签的解析注册过程。\n\n### 标签解析\n\n若定义的元素节点使用的是 Spring 默认命名空间，则调用 `parseDefaultElement()` 进行默认标签解析，如下：\n\n```java\n    private void parseDefaultElement(Element ele, \n                                     BeanDefinitionParserDelegate delegate) {\n       // 如果元素节点是<Import>导入元素，进行导入解析\n        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n            importBeanDefinitionResource(ele);\n        }\n        // 如果元素节点是<Alias>别名元素，进行别名解析 \n        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n            processAliasRegistration(ele);\n        }\n        // 如果元素节点<Bean>元素，则进行Bean解析注册\n        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n            processBeanDefinition(ele, delegate);\n        }\n\n        // // 如果元素节点<Beans>元素，则进行Beans解析\n        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n            // recurse\n            doRegisterBeanDefinitions(ele);\n        }\n    }\n```\n\n对四大标签：import、alias、bean、beans 进行解析，其中 bean 标签的解析为核心工作。关于各个标签的解析过程见如下文章：\n\n-  [spring源码解析之  12alias、import、beans标签的解析](http://127.0.0.1:4000/posts/31/)\n- [spring源码解析之   11bean标签：解析自定义标签](http://127.0.0.1:4000/posts/30/)\n-  [spring 源码解析之 10bean标签：constructor-arg、property子元素](http://127.0.0.1:4000/posts/29/)\n-  [spring源码解析之 09bean 标签：meta、lookup-method、replace-method](http://127.0.0.1:4000/posts/28/)\n-  [Spring源码解析之 08bean标签：BeanDefinition](http://127.0.0.1:4000/posts/27/)\n-  [spring源码解析之 07bean标签:开启解析进程](http://127.0.0.1:4000/posts/26/)\n\n对于默认标签则由 `parseCustomElement()` 负责解析。\n\n```java\n    public BeanDefinition parseCustomElement(Element ele) {\n        return parseCustomElement(ele, null);\n    }\n\n    public BeanDefinition parseCustomElement(Element ele, \n                                             @Nullable BeanDefinition containingBd) {\n        String namespaceUri = getNamespaceURI(ele);\n        if (namespaceUri == null) {\n            return null;\n        }\n        NamespaceHandler handler = this.readerContext\n            \t\t.getNamespaceHandlerResolver().resolve(namespaceUri);\n        if (handler == null) {\n            error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" \n                  \t+ namespaceUri + \"]\", ele);\n            return null;\n        }\n        return handler.parse(ele, new ParserContext(this.readerContext, this, \n                                                    containingBd));\n    }\n```\n\n获取节点的 namespaceUri，然后根据该 namespaceuri 获取相对应的 Handler，调用 Handler 的 `parse()` 方法即完成自定义标签的解析和注入。想了解更多参考：[spring源码解析之 13自定义标签解析](http://127.0.0.1:4000/posts/32/)\n\n## 注册 BeanDefinition\n\n经过上面的解析，则将 Document 对象里面的 Bean 标签解析成了一个个的 BeanDefinition ，下一步则是将这些 BeanDefinition 注册到 IOC 容器中。动作的触发是在解析 Bean 标签完成后，如下：\n\n```java\n    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\"Failed to register bean definition with name '\" +\n                        bdHolder.getBeanName() + \"'\", ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n        }\n    }\n```\n\n调用 `BeanDefinitionReaderUtils.registerBeanDefinition()` 注册，其实这里面也是调用 BeanDefinitionRegistry 的 `registerBeanDefinition()`来注册 BeanDefinition ，不过最终的实现是在 DefaultListableBeanFactory 中实现，如下：\n\n```java\n    @Override\n    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n            throws BeanDefinitionStoreException {\n\n      // 省略一堆校验\n\n        BeanDefinition oldBeanDefinition;\n\n        oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n          // 省略一堆 if\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n        }\n        else {\n            if (hasBeanCreationStarted()) {\n                // Cannot modify startup-time collection elements anymore (for stable iteration)\n                synchronized (this.beanDefinitionMap) {\n                    this.beanDefinitionMap.put(beanName, beanDefinition);\n                    List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);\n                    updatedDefinitions.addAll(this.beanDefinitionNames);\n                    updatedDefinitions.add(beanName);\n                    this.beanDefinitionNames = updatedDefinitions;\n                    if (this.manualSingletonNames.contains(beanName)) {\n                        Set<String> updatedSingletons = new LinkedHashSet<>(this.manualSingletonNames);\n                        updatedSingletons.remove(beanName);\n                        this.manualSingletonNames = updatedSingletons;\n                    }\n                }\n            }\n            else {\n                // Still in startup registration phase\n                this.beanDefinitionMap.put(beanName, beanDefinition);\n                this.beanDefinitionNames.add(beanName);\n                this.manualSingletonNames.remove(beanName);\n            }\n            this.frozenBeanDefinitionNames = null;\n        }\n\n        if (oldBeanDefinition != null || containsSingleton(beanName)) {\n            resetBeanDefinition(beanName);\n        }\n    }\n```\n\n这段代码最核心的部分是这句 `this.beanDefinitionMap.put(beanName, beanDefinition)` ，所以注册过程也不是那么的高大上，就是利用一个 Map 的集合对象来存放，key 是 beanName，value 是 BeanDefinition。\n\n至此，整个 IOC 的初始化过程就已经完成了，从 Bean 资源的定位，转换为 Document 对象，接着对其进行解析，最后注册到 IOC 容器中，都已经完美地完成了。现在 IOC 容器中已经建立了整个 Bean 的配置信息，这些 Bean 可以被检索、使用、维护，他们是控制反转的基础，是后面注入 Bean 的依赖。\n\n更多阅读：\n\n- [spring源码解析](https://taolove.top/tags/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/)","source":"_posts/spring 源码分析/spring/spring源码解析之 15BeanDefinition解析总结.md","raw":"abbrlink: 34\ntitle: spring源码解析之 15BeanDefinition解析总结\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxitianya\ndate: 2019-01-14 06:19:00\n---\n# spring源码解析之 15BeanDefinition解析总结\n\n前面 13 篇博文从源码层次分析了 IOC 整个初始化过程，这篇就这些内容做一个总结将其连贯起来。\n\n在前文提过，IOC 容器的初始化过程分为三步骤：Resource 定位、BeanDefinition 的载入和解析，BeanDefinition 注册。\n<!-- more-->\n\n![upload successful](/images/pasted-11.png)\n\n- **Resource 定位**。我们一般用外部资源来描述 Bean 对象，所以在初始化 IOC 容器的第一步就是需要定位这个外部资源。\n- **BeanDefinition 的载入和解析**。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IOC 容器的内部数据结构：BeanDefinition。在 IOC 容器内部维护着一个 BeanDefinition Map 的数据结构，在配置文件中每一个都对应着一个BeanDefinition对象。\n- **BeanDefinition 注册**。向IOC容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistery 接口来实现的。在 IOC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IOC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。在这里需要注意的一点是这个过程并没有完成依赖注入，依赖注册是发生在应用第一次调用 `getBean()` 向容器索要 Bean 时。当然我们可以通过设置预处理，即对某个 Bean 设置 lazyinit 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。\n\n还记得在博客[spring 源码解析之 04加载bean](https://taolove.top/posts/23/) 中提供的一段代码吗？这里我们同样也以这段代码作为我们研究 IOC 初始化过程的开端，如下：\n\n```java\nClassPathResource resource = new ClassPathResource(\"bean.xml\");\nDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\nXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\nreader.loadBeanDefinitions(resource);\n```\n\n刚刚开始的时候可能对上面这几行代码不知道什么意思，现在应该就一目了然了。\n\n- `ClassPathResource resource = new ClassPathResource(\"bean.xml\");`： 根据 Xml 配置文件创建 Resource 资源对象。ClassPathResource 是 Resource 接口的子类，bean.xml 文件中的内容是我们定义的 Bean 信息。\n- `DefaultListableBeanFactory factory = new DefaultListableBeanFactory();` 创建一个 BeanFactory。DefaultListableBeanFactory 是 BeanFactory 的一个子类，BeanFactory 作为一个接口，其实它本身是不具有独立使用的功能的，而 DefaultListableBeanFactory 则是真正可以独立使用的 IOC 容器，它是整个 Spring IOC 的始祖，在后续会有专门的文章来分析它。\n- `XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);`：创建 XmlBeanDefinitionReader 读取器，用于载入 BeanDefinition 。\n- `reader.loadBeanDefinitions(resource);`：开启 Bean 的载入和注册进程，完成后的 Bean 放置在 IOC 容器中。\n\n## Resource 定位\n\nSpring 为了解决资源定位的问题，提供了两个接口：Resource、ResourceLoader，其中 Resource 接口是 Spring 统一资源的抽象接口，ResourceLoader 则是 Spring 资源加载的统一抽象。关于Resource、ResourceLoader 的更多知识请关注[spring源码解析之 03统一资源加载](https://taolove.top/posts/22/)\n\nResource 资源的定位需要 Resource 和 ResourceLoader 两个接口互相配合，在上面那段代码中 `new ClassPathResource(\"bean.xml\")` 为我们定义了资源，那么 ResourceLoader 则是在什么时候初始化的呢？看 XmlBeanDefinitionReader 构造方法：\n\n```java\n    public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) {\n        super(registry);\n    }\n```\n\n直接调用父类 AbstractBeanDefinitionReader ：\n\n```java\n    protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) {\n        Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n        this.registry = registry;\n\n        // Determine ResourceLoader to use.\n        if (this.registry instanceof ResourceLoader) {\n            this.resourceLoader = (ResourceLoader) this.registry;\n        }\n        else {\n            this.resourceLoader = new PathMatchingResourcePatternResolver();\n        }\n\n        // Inherit Environment if possible\n        if (this.registry instanceof EnvironmentCapable) {\n            this.environment = ((EnvironmentCapable) this.registry).getEnvironment();\n        }\n        else {\n            this.environment = new StandardEnvironment();\n        }\n    }\n```\n\n核心在于设置 resourceLoader 这段，如果设置了 ResourceLoader 则用设置的，否则使用 PathMatchingResourcePatternResolver ，该类是一个集大成者的 ResourceLoader。\n\n## BeanDefinition 的载入和解析\n\n`reader.loadBeanDefinitions(resource);` 开启 BeanDefinition 的解析过程。如下：\n\n```java\n    public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {\n        return loadBeanDefinitions(new EncodedResource(resource));\n    }\n```\n\n在这个方法会将资源 resource 包装成一个 EncodedResource 实例对象，然后调用 `loadBeanDefinitions()` 方法，而将 Resource 封装成 EncodedResource 主要是为了对 Resource 进行编码，保证内容读取的正确性。\n\n```java\n   public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n        // 省略一些代码\n        try {\n            // 将资源文件转为 InputStream 的 IO 流\n            InputStream inputStream = encodedResource.getResource().getInputStream();\n            try {\n                // 从 InputStream 中得到 XML 的解析源\n                InputSource inputSource = new InputSource(inputStream);\n                if (encodedResource.getEncoding() != null) {\n                    inputSource.setEncoding(encodedResource.getEncoding());\n                }\n\n                // 具体的读取过程\n                return doLoadBeanDefinitions(inputSource, \n                                             encodedResource.getResource());\n            }\n            finally {\n                inputStream.close();\n            }\n        }\n        // 省略一些代码\n    }\n```\n\n从 encodedResource 源中获取 xml 的解析源，调用 `doLoadBeanDefinitions()` 执行具体的解析过程。\n\n```java\n    protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n            throws BeanDefinitionStoreException {\n        try {\n            Document doc = doLoadDocument(inputSource, resource);\n            return registerBeanDefinitions(doc, resource);\n        }\n        // 省略很多catch代码\n```\n\n在该方法中主要做两件事：\n\n1. 根据 xml 解析源获取相应的 Document 对象\n\n2. 调用 `registerBeanDefinitions()` 开启 BeanDefinition 的解析注册过程。\n\n### 转换为 Document 对象\n\n调用 `doLoadDocument()` 会将 Bean 定义的资源转换为 Document 对象。\n\n```java\n    protected Document doLoadDocument(InputSource inputSource, Resource resource) \n        throws Exception {\n        return this.documentLoader\n            .loadDocument(inputSource, getEntityResolver(), this.errorHandler,\n                getValidationModeForResource(resource), isNamespaceAware());\n    }\n```\n\n`loadDocument()` 方法接受五个参数：\n\n- **inputSource**：加载 Document 的 Resource 源\n- **entityResolver**：解析文件的解析器\n- **errorHandler**：处理加载 Document 对象的过程的错误\n- **validationMode**：验证模式\n- **namespaceAware**：命名空间支持。如果要提供对 XML 名称空间的支持，则为true\n\n对于这五个参数，有两个参数需要重点关注下：entityResolver、validationMode。这两个参数分别在[spring 源码解析之 04（上）加载bean](http://127.0.0.1:4000/posts/23/)   和  [spring源码解析之 04（下）获取验证模型](http://127.0.0.1:4000/posts/35/) 中有详细的讲述。\n\n`loadDocument()` 在类 DefaultDocumentLoader 中提供了实现，如下：\n\n```java\n    public Document loadDocument(InputSource inputSource, \n                                 EntityResolver entityResolver,\n            ErrorHandler errorHandler, int validationMode, boolean namespaceAware) \n        throws Exception {\n        // 创建文件解析工厂\n        DocumentBuilderFactory factory = \n            createDocumentBuilderFactory(validationMode, namespaceAware);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Using JAXP provider [\" + factory.getClass().getName() + \"]\");\n        }\n        // 创建文档解析器\n        DocumentBuilder builder = \n            createDocumentBuilder(factory, entityResolver, errorHandler);\n        // 解析 Spring 的 Bean 定义资源\n        return builder.parse(inputSource);\n    }\n```\n\n这到这里，就已经将定义的 Bean 资源文件，载入并转换为 Document 对象了，那么下一步就是如何将其解析为 Spring IOC 管理的 Bean 对象并将其注册到容器中。这个过程有方法 `registerBeanDefinitions()` 实现。如下：\n\n```java\n    public int registerBeanDefinitions(Document doc, Resource resource)\n        throws BeanDefinitionStoreException {\n       // 创建 BeanDefinitionDocumentReader 来对 xml 格式的BeanDefinition 解析\n        BeanDefinitionDocumentReader documentReader = \n            \t\tcreateBeanDefinitionDocumentReader();\n        // 获得容器中注册的Bean数量\n        int countBefore = getRegistry().getBeanDefinitionCount();\n\n        // 解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口，\n        // 具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成\n        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n        return getRegistry().getBeanDefinitionCount() - countBefore;\n    }\n```\n\n首先创建 BeanDefinition 的解析器 BeanDefinitionDocumentReader，然后调用 `documentReader.registerBeanDefinitions()` 开启解析过程，这里使用的是委派模式，具体的实现由子类 DefaultBeanDefinitionDocumentReader 完成。\n\n```java\n    public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n       // 获得XML描述符\n        this.readerContext = readerContext;\n        logger.debug(\"Loading bean definitions\");\n\n        // 获得Document的根元素\n        Element root = doc.getDocumentElement();\n\n        // 解析根元素\n        doRegisterBeanDefinitions(root);\n    }\n```\n\n### 对 Document 对象的解析\n\n从 Document 对象中获取根元素 root，然后调用 `doRegisterBeanDefinitions()` 开启真正的解析过程。\n\n```java\n    protected void doRegisterBeanDefinitions(Element root) {\n        BeanDefinitionParserDelegate parent = this.delegate;\n        this.delegate = createDelegate(getReaderContext(), root, parent);\n\n       // 省略部分代码\n\n        preProcessXml(root);\n        parseBeanDefinitions(root, this.delegate);\n        postProcessXml(root);\n\n        this.delegate = parent;\n    }\n```\n\n`preProcessXml()`、`postProcessXml()` 为前置、后置增强处理，目前 Spring 中都是空实现， `parseBeanDefinitions()` 是对根元素 root 的解析注册过程。\n\n```java\n    protected void parseBeanDefinitions(Element root, \n                                        BeanDefinitionParserDelegate delegate) {\n       // Bean定义的Document对象使用了Spring默认的XML命名空间\n        if (delegate.isDefaultNamespace(root)) {\n          // 获取Bean定义的Document对象根元素的所有子节点\n            NodeList nl = root.getChildNodes();\n            for (int i = 0; i < nl.getLength(); i++) {\n                Node node = nl.item(i);\n                // 获得Document节点是XML元素节点 \n                if (node instanceof Element) {\n                    Element ele = (Element) node;\n                    // Bean定义的Document的元素节点使用的是Spring默认的XML命名空间\n                    if (delegate.isDefaultNamespace(ele)) {\n                       // 使用Spring的Bean规则解析元素节点（默认解析规则）\n                        parseDefaultElement(ele, delegate);\n                    }\n                    else {\n                       // 没有使用Spring默认的XML命名空间，则使用用户自定义的解析规则解析元素节点 \n                        delegate.parseCustomElement(ele);\n                    }\n                }\n            }\n        }\n        else {\n          // Document 的根节点没有使用Spring默认的命名空间，则使用用户自定义的解析规则解析\n            delegate.parseCustomElement(root);\n        }\n    }\n```\n\n迭代 root 元素的所有子节点，对其进行判断，若节点为默认命名空间，则ID调用 `parseDefaultElement()` 开启默认标签的解析注册过程，否则调用 `parseCustomElement()` 开启自定义标签的解析注册过程。\n\n### 标签解析\n\n若定义的元素节点使用的是 Spring 默认命名空间，则调用 `parseDefaultElement()` 进行默认标签解析，如下：\n\n```java\n    private void parseDefaultElement(Element ele, \n                                     BeanDefinitionParserDelegate delegate) {\n       // 如果元素节点是<Import>导入元素，进行导入解析\n        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n            importBeanDefinitionResource(ele);\n        }\n        // 如果元素节点是<Alias>别名元素，进行别名解析 \n        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n            processAliasRegistration(ele);\n        }\n        // 如果元素节点<Bean>元素，则进行Bean解析注册\n        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n            processBeanDefinition(ele, delegate);\n        }\n\n        // // 如果元素节点<Beans>元素，则进行Beans解析\n        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n            // recurse\n            doRegisterBeanDefinitions(ele);\n        }\n    }\n```\n\n对四大标签：import、alias、bean、beans 进行解析，其中 bean 标签的解析为核心工作。关于各个标签的解析过程见如下文章：\n\n-  [spring源码解析之  12alias、import、beans标签的解析](http://127.0.0.1:4000/posts/31/)\n- [spring源码解析之   11bean标签：解析自定义标签](http://127.0.0.1:4000/posts/30/)\n-  [spring 源码解析之 10bean标签：constructor-arg、property子元素](http://127.0.0.1:4000/posts/29/)\n-  [spring源码解析之 09bean 标签：meta、lookup-method、replace-method](http://127.0.0.1:4000/posts/28/)\n-  [Spring源码解析之 08bean标签：BeanDefinition](http://127.0.0.1:4000/posts/27/)\n-  [spring源码解析之 07bean标签:开启解析进程](http://127.0.0.1:4000/posts/26/)\n\n对于默认标签则由 `parseCustomElement()` 负责解析。\n\n```java\n    public BeanDefinition parseCustomElement(Element ele) {\n        return parseCustomElement(ele, null);\n    }\n\n    public BeanDefinition parseCustomElement(Element ele, \n                                             @Nullable BeanDefinition containingBd) {\n        String namespaceUri = getNamespaceURI(ele);\n        if (namespaceUri == null) {\n            return null;\n        }\n        NamespaceHandler handler = this.readerContext\n            \t\t.getNamespaceHandlerResolver().resolve(namespaceUri);\n        if (handler == null) {\n            error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" \n                  \t+ namespaceUri + \"]\", ele);\n            return null;\n        }\n        return handler.parse(ele, new ParserContext(this.readerContext, this, \n                                                    containingBd));\n    }\n```\n\n获取节点的 namespaceUri，然后根据该 namespaceuri 获取相对应的 Handler，调用 Handler 的 `parse()` 方法即完成自定义标签的解析和注入。想了解更多参考：[spring源码解析之 13自定义标签解析](http://127.0.0.1:4000/posts/32/)\n\n## 注册 BeanDefinition\n\n经过上面的解析，则将 Document 对象里面的 Bean 标签解析成了一个个的 BeanDefinition ，下一步则是将这些 BeanDefinition 注册到 IOC 容器中。动作的触发是在解析 Bean 标签完成后，如下：\n\n```java\n    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(\"Failed to register bean definition with name '\" +\n                        bdHolder.getBeanName() + \"'\", ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n        }\n    }\n```\n\n调用 `BeanDefinitionReaderUtils.registerBeanDefinition()` 注册，其实这里面也是调用 BeanDefinitionRegistry 的 `registerBeanDefinition()`来注册 BeanDefinition ，不过最终的实现是在 DefaultListableBeanFactory 中实现，如下：\n\n```java\n    @Override\n    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n            throws BeanDefinitionStoreException {\n\n      // 省略一堆校验\n\n        BeanDefinition oldBeanDefinition;\n\n        oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n          // 省略一堆 if\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n        }\n        else {\n            if (hasBeanCreationStarted()) {\n                // Cannot modify startup-time collection elements anymore (for stable iteration)\n                synchronized (this.beanDefinitionMap) {\n                    this.beanDefinitionMap.put(beanName, beanDefinition);\n                    List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);\n                    updatedDefinitions.addAll(this.beanDefinitionNames);\n                    updatedDefinitions.add(beanName);\n                    this.beanDefinitionNames = updatedDefinitions;\n                    if (this.manualSingletonNames.contains(beanName)) {\n                        Set<String> updatedSingletons = new LinkedHashSet<>(this.manualSingletonNames);\n                        updatedSingletons.remove(beanName);\n                        this.manualSingletonNames = updatedSingletons;\n                    }\n                }\n            }\n            else {\n                // Still in startup registration phase\n                this.beanDefinitionMap.put(beanName, beanDefinition);\n                this.beanDefinitionNames.add(beanName);\n                this.manualSingletonNames.remove(beanName);\n            }\n            this.frozenBeanDefinitionNames = null;\n        }\n\n        if (oldBeanDefinition != null || containsSingleton(beanName)) {\n            resetBeanDefinition(beanName);\n        }\n    }\n```\n\n这段代码最核心的部分是这句 `this.beanDefinitionMap.put(beanName, beanDefinition)` ，所以注册过程也不是那么的高大上，就是利用一个 Map 的集合对象来存放，key 是 beanName，value 是 BeanDefinition。\n\n至此，整个 IOC 的初始化过程就已经完成了，从 Bean 资源的定位，转换为 Document 对象，接着对其进行解析，最后注册到 IOC 容器中，都已经完美地完成了。现在 IOC 容器中已经建立了整个 Bean 的配置信息，这些 Bean 可以被检索、使用、维护，他们是控制反转的基础，是后面注入 Bean 的依赖。\n\n更多阅读：\n\n- [spring源码解析](https://taolove.top/tags/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/)","slug":"spring 源码分析/spring/spring源码解析之 15BeanDefinition解析总结","published":1,"updated":"2019-01-15T03:36:48.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovx3005d9q1u4n3rn4ca","content":"<h1 id=\"spring源码解析之-15BeanDefinition解析总结\"><a href=\"#spring源码解析之-15BeanDefinition解析总结\" class=\"headerlink\" title=\"spring源码解析之 15BeanDefinition解析总结\"></a>spring源码解析之 15BeanDefinition解析总结</h1><p>前面 13 篇博文从源码层次分析了 IOC 整个初始化过程，这篇就这些内容做一个总结将其连贯起来。</p>\n<p>在前文提过，IOC 容器的初始化过程分为三步骤：Resource 定位、BeanDefinition 的载入和解析，BeanDefinition 注册。<br><a id=\"more\"></a></p>\n<p><img src=\"/images/pasted-11.png\" alt=\"upload successful\"></p>\n<ul>\n<li><strong>Resource 定位</strong>。我们一般用外部资源来描述 Bean 对象，所以在初始化 IOC 容器的第一步就是需要定位这个外部资源。</li>\n<li><strong>BeanDefinition 的载入和解析</strong>。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IOC 容器的内部数据结构：BeanDefinition。在 IOC 容器内部维护着一个 BeanDefinition Map 的数据结构，在配置文件中每一个都对应着一个BeanDefinition对象。</li>\n<li><strong>BeanDefinition 注册</strong>。向IOC容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistery 接口来实现的。在 IOC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IOC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。在这里需要注意的一点是这个过程并没有完成依赖注入，依赖注册是发生在应用第一次调用 <code>getBean()</code> 向容器索要 Bean 时。当然我们可以通过设置预处理，即对某个 Bean 设置 lazyinit 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。</li>\n</ul>\n<p>还记得在博客<a href=\"https://taolove.top/posts/23/\">spring 源码解析之 04加载bean</a> 中提供的一段代码吗？这里我们同样也以这段代码作为我们研究 IOC 初始化过程的开端，如下：</p>\n<pre><code class=\"java\">ClassPathResource resource = new ClassPathResource(&quot;bean.xml&quot;);\nDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\nXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\nreader.loadBeanDefinitions(resource);\n</code></pre>\n<p>刚刚开始的时候可能对上面这几行代码不知道什么意思，现在应该就一目了然了。</p>\n<ul>\n<li><code>ClassPathResource resource = new ClassPathResource(&quot;bean.xml&quot;);</code>： 根据 Xml 配置文件创建 Resource 资源对象。ClassPathResource 是 Resource 接口的子类，bean.xml 文件中的内容是我们定义的 Bean 信息。</li>\n<li><code>DefaultListableBeanFactory factory = new DefaultListableBeanFactory();</code> 创建一个 BeanFactory。DefaultListableBeanFactory 是 BeanFactory 的一个子类，BeanFactory 作为一个接口，其实它本身是不具有独立使用的功能的，而 DefaultListableBeanFactory 则是真正可以独立使用的 IOC 容器，它是整个 Spring IOC 的始祖，在后续会有专门的文章来分析它。</li>\n<li><code>XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);</code>：创建 XmlBeanDefinitionReader 读取器，用于载入 BeanDefinition 。</li>\n<li><code>reader.loadBeanDefinitions(resource);</code>：开启 Bean 的载入和注册进程，完成后的 Bean 放置在 IOC 容器中。</li>\n</ul>\n<h2 id=\"Resource-定位\"><a href=\"#Resource-定位\" class=\"headerlink\" title=\"Resource 定位\"></a>Resource 定位</h2><p>Spring 为了解决资源定位的问题，提供了两个接口：Resource、ResourceLoader，其中 Resource 接口是 Spring 统一资源的抽象接口，ResourceLoader 则是 Spring 资源加载的统一抽象。关于Resource、ResourceLoader 的更多知识请关注<a href=\"https://taolove.top/posts/22/\">spring源码解析之 03统一资源加载</a></p>\n<p>Resource 资源的定位需要 Resource 和 ResourceLoader 两个接口互相配合，在上面那段代码中 <code>new ClassPathResource(&quot;bean.xml&quot;)</code> 为我们定义了资源，那么 ResourceLoader 则是在什么时候初始化的呢？看 XmlBeanDefinitionReader 构造方法：</p>\n<pre><code class=\"java\">    public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) {\n        super(registry);\n    }\n</code></pre>\n<p>直接调用父类 AbstractBeanDefinitionReader ：</p>\n<pre><code class=\"java\">    protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) {\n        Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);\n        this.registry = registry;\n\n        // Determine ResourceLoader to use.\n        if (this.registry instanceof ResourceLoader) {\n            this.resourceLoader = (ResourceLoader) this.registry;\n        }\n        else {\n            this.resourceLoader = new PathMatchingResourcePatternResolver();\n        }\n\n        // Inherit Environment if possible\n        if (this.registry instanceof EnvironmentCapable) {\n            this.environment = ((EnvironmentCapable) this.registry).getEnvironment();\n        }\n        else {\n            this.environment = new StandardEnvironment();\n        }\n    }\n</code></pre>\n<p>核心在于设置 resourceLoader 这段，如果设置了 ResourceLoader 则用设置的，否则使用 PathMatchingResourcePatternResolver ，该类是一个集大成者的 ResourceLoader。</p>\n<h2 id=\"BeanDefinition-的载入和解析\"><a href=\"#BeanDefinition-的载入和解析\" class=\"headerlink\" title=\"BeanDefinition 的载入和解析\"></a>BeanDefinition 的载入和解析</h2><p><code>reader.loadBeanDefinitions(resource);</code> 开启 BeanDefinition 的解析过程。如下：</p>\n<pre><code class=\"java\">    public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {\n        return loadBeanDefinitions(new EncodedResource(resource));\n    }\n</code></pre>\n<p>在这个方法会将资源 resource 包装成一个 EncodedResource 实例对象，然后调用 <code>loadBeanDefinitions()</code> 方法，而将 Resource 封装成 EncodedResource 主要是为了对 Resource 进行编码，保证内容读取的正确性。</p>\n<pre><code class=\"java\">   public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n        // 省略一些代码\n        try {\n            // 将资源文件转为 InputStream 的 IO 流\n            InputStream inputStream = encodedResource.getResource().getInputStream();\n            try {\n                // 从 InputStream 中得到 XML 的解析源\n                InputSource inputSource = new InputSource(inputStream);\n                if (encodedResource.getEncoding() != null) {\n                    inputSource.setEncoding(encodedResource.getEncoding());\n                }\n\n                // 具体的读取过程\n                return doLoadBeanDefinitions(inputSource, \n                                             encodedResource.getResource());\n            }\n            finally {\n                inputStream.close();\n            }\n        }\n        // 省略一些代码\n    }\n</code></pre>\n<p>从 encodedResource 源中获取 xml 的解析源，调用 <code>doLoadBeanDefinitions()</code> 执行具体的解析过程。</p>\n<pre><code class=\"java\">    protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n            throws BeanDefinitionStoreException {\n        try {\n            Document doc = doLoadDocument(inputSource, resource);\n            return registerBeanDefinitions(doc, resource);\n        }\n        // 省略很多catch代码\n</code></pre>\n<p>在该方法中主要做两件事：</p>\n<ol>\n<li><p>根据 xml 解析源获取相应的 Document 对象</p>\n</li>\n<li><p>调用 <code>registerBeanDefinitions()</code> 开启 BeanDefinition 的解析注册过程。</p>\n</li>\n</ol>\n<h3 id=\"转换为-Document-对象\"><a href=\"#转换为-Document-对象\" class=\"headerlink\" title=\"转换为 Document 对象\"></a>转换为 Document 对象</h3><p>调用 <code>doLoadDocument()</code> 会将 Bean 定义的资源转换为 Document 对象。</p>\n<pre><code class=\"java\">    protected Document doLoadDocument(InputSource inputSource, Resource resource) \n        throws Exception {\n        return this.documentLoader\n            .loadDocument(inputSource, getEntityResolver(), this.errorHandler,\n                getValidationModeForResource(resource), isNamespaceAware());\n    }\n</code></pre>\n<p><code>loadDocument()</code> 方法接受五个参数：</p>\n<ul>\n<li><strong>inputSource</strong>：加载 Document 的 Resource 源</li>\n<li><strong>entityResolver</strong>：解析文件的解析器</li>\n<li><strong>errorHandler</strong>：处理加载 Document 对象的过程的错误</li>\n<li><strong>validationMode</strong>：验证模式</li>\n<li><strong>namespaceAware</strong>：命名空间支持。如果要提供对 XML 名称空间的支持，则为true</li>\n</ul>\n<p>对于这五个参数，有两个参数需要重点关注下：entityResolver、validationMode。这两个参数分别在<a href=\"http://127.0.0.1:4000/posts/23/\" target=\"_blank\" rel=\"noopener\">spring 源码解析之 04（上）加载bean</a>   和  <a href=\"http://127.0.0.1:4000/posts/35/\" target=\"_blank\" rel=\"noopener\">spring源码解析之 04（下）获取验证模型</a> 中有详细的讲述。</p>\n<p><code>loadDocument()</code> 在类 DefaultDocumentLoader 中提供了实现，如下：</p>\n<pre><code class=\"java\">    public Document loadDocument(InputSource inputSource, \n                                 EntityResolver entityResolver,\n            ErrorHandler errorHandler, int validationMode, boolean namespaceAware) \n        throws Exception {\n        // 创建文件解析工厂\n        DocumentBuilderFactory factory = \n            createDocumentBuilderFactory(validationMode, namespaceAware);\n        if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);\n        }\n        // 创建文档解析器\n        DocumentBuilder builder = \n            createDocumentBuilder(factory, entityResolver, errorHandler);\n        // 解析 Spring 的 Bean 定义资源\n        return builder.parse(inputSource);\n    }\n</code></pre>\n<p>这到这里，就已经将定义的 Bean 资源文件，载入并转换为 Document 对象了，那么下一步就是如何将其解析为 Spring IOC 管理的 Bean 对象并将其注册到容器中。这个过程有方法 <code>registerBeanDefinitions()</code> 实现。如下：</p>\n<pre><code class=\"java\">    public int registerBeanDefinitions(Document doc, Resource resource)\n        throws BeanDefinitionStoreException {\n       // 创建 BeanDefinitionDocumentReader 来对 xml 格式的BeanDefinition 解析\n        BeanDefinitionDocumentReader documentReader = \n                    createBeanDefinitionDocumentReader();\n        // 获得容器中注册的Bean数量\n        int countBefore = getRegistry().getBeanDefinitionCount();\n\n        // 解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口，\n        // 具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成\n        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n        return getRegistry().getBeanDefinitionCount() - countBefore;\n    }\n</code></pre>\n<p>首先创建 BeanDefinition 的解析器 BeanDefinitionDocumentReader，然后调用 <code>documentReader.registerBeanDefinitions()</code> 开启解析过程，这里使用的是委派模式，具体的实现由子类 DefaultBeanDefinitionDocumentReader 完成。</p>\n<pre><code class=\"java\">    public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n       // 获得XML描述符\n        this.readerContext = readerContext;\n        logger.debug(&quot;Loading bean definitions&quot;);\n\n        // 获得Document的根元素\n        Element root = doc.getDocumentElement();\n\n        // 解析根元素\n        doRegisterBeanDefinitions(root);\n    }\n</code></pre>\n<h3 id=\"对-Document-对象的解析\"><a href=\"#对-Document-对象的解析\" class=\"headerlink\" title=\"对 Document 对象的解析\"></a>对 Document 对象的解析</h3><p>从 Document 对象中获取根元素 root，然后调用 <code>doRegisterBeanDefinitions()</code> 开启真正的解析过程。</p>\n<pre><code class=\"java\">    protected void doRegisterBeanDefinitions(Element root) {\n        BeanDefinitionParserDelegate parent = this.delegate;\n        this.delegate = createDelegate(getReaderContext(), root, parent);\n\n       // 省略部分代码\n\n        preProcessXml(root);\n        parseBeanDefinitions(root, this.delegate);\n        postProcessXml(root);\n\n        this.delegate = parent;\n    }\n</code></pre>\n<p><code>preProcessXml()</code>、<code>postProcessXml()</code> 为前置、后置增强处理，目前 Spring 中都是空实现， <code>parseBeanDefinitions()</code> 是对根元素 root 的解析注册过程。</p>\n<pre><code class=\"java\">    protected void parseBeanDefinitions(Element root, \n                                        BeanDefinitionParserDelegate delegate) {\n       // Bean定义的Document对象使用了Spring默认的XML命名空间\n        if (delegate.isDefaultNamespace(root)) {\n          // 获取Bean定义的Document对象根元素的所有子节点\n            NodeList nl = root.getChildNodes();\n            for (int i = 0; i &lt; nl.getLength(); i++) {\n                Node node = nl.item(i);\n                // 获得Document节点是XML元素节点 \n                if (node instanceof Element) {\n                    Element ele = (Element) node;\n                    // Bean定义的Document的元素节点使用的是Spring默认的XML命名空间\n                    if (delegate.isDefaultNamespace(ele)) {\n                       // 使用Spring的Bean规则解析元素节点（默认解析规则）\n                        parseDefaultElement(ele, delegate);\n                    }\n                    else {\n                       // 没有使用Spring默认的XML命名空间，则使用用户自定义的解析规则解析元素节点 \n                        delegate.parseCustomElement(ele);\n                    }\n                }\n            }\n        }\n        else {\n          // Document 的根节点没有使用Spring默认的命名空间，则使用用户自定义的解析规则解析\n            delegate.parseCustomElement(root);\n        }\n    }\n</code></pre>\n<p>迭代 root 元素的所有子节点，对其进行判断，若节点为默认命名空间，则ID调用 <code>parseDefaultElement()</code> 开启默认标签的解析注册过程，否则调用 <code>parseCustomElement()</code> 开启自定义标签的解析注册过程。</p>\n<h3 id=\"标签解析\"><a href=\"#标签解析\" class=\"headerlink\" title=\"标签解析\"></a>标签解析</h3><p>若定义的元素节点使用的是 Spring 默认命名空间，则调用 <code>parseDefaultElement()</code> 进行默认标签解析，如下：</p>\n<pre><code class=\"java\">    private void parseDefaultElement(Element ele, \n                                     BeanDefinitionParserDelegate delegate) {\n       // 如果元素节点是&lt;Import&gt;导入元素，进行导入解析\n        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n            importBeanDefinitionResource(ele);\n        }\n        // 如果元素节点是&lt;Alias&gt;别名元素，进行别名解析 \n        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n            processAliasRegistration(ele);\n        }\n        // 如果元素节点&lt;Bean&gt;元素，则进行Bean解析注册\n        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n            processBeanDefinition(ele, delegate);\n        }\n\n        // // 如果元素节点&lt;Beans&gt;元素，则进行Beans解析\n        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n            // recurse\n            doRegisterBeanDefinitions(ele);\n        }\n    }\n</code></pre>\n<p>对四大标签：import、alias、bean、beans 进行解析，其中 bean 标签的解析为核心工作。关于各个标签的解析过程见如下文章：</p>\n<ul>\n<li><a href=\"http://127.0.0.1:4000/posts/31/\" target=\"_blank\" rel=\"noopener\">spring源码解析之  12alias、import、beans标签的解析</a></li>\n<li><a href=\"http://127.0.0.1:4000/posts/30/\" target=\"_blank\" rel=\"noopener\">spring源码解析之   11bean标签：解析自定义标签</a></li>\n<li><a href=\"http://127.0.0.1:4000/posts/29/\" target=\"_blank\" rel=\"noopener\">spring 源码解析之 10bean标签：constructor-arg、property子元素</a></li>\n<li><a href=\"http://127.0.0.1:4000/posts/28/\" target=\"_blank\" rel=\"noopener\">spring源码解析之 09bean 标签：meta、lookup-method、replace-method</a></li>\n<li><a href=\"http://127.0.0.1:4000/posts/27/\" target=\"_blank\" rel=\"noopener\">Spring源码解析之 08bean标签：BeanDefinition</a></li>\n<li><a href=\"http://127.0.0.1:4000/posts/26/\" target=\"_blank\" rel=\"noopener\">spring源码解析之 07bean标签:开启解析进程</a></li>\n</ul>\n<p>对于默认标签则由 <code>parseCustomElement()</code> 负责解析。</p>\n<pre><code class=\"java\">    public BeanDefinition parseCustomElement(Element ele) {\n        return parseCustomElement(ele, null);\n    }\n\n    public BeanDefinition parseCustomElement(Element ele, \n                                             @Nullable BeanDefinition containingBd) {\n        String namespaceUri = getNamespaceURI(ele);\n        if (namespaceUri == null) {\n            return null;\n        }\n        NamespaceHandler handler = this.readerContext\n                    .getNamespaceHandlerResolver().resolve(namespaceUri);\n        if (handler == null) {\n            error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; \n                      + namespaceUri + &quot;]&quot;, ele);\n            return null;\n        }\n        return handler.parse(ele, new ParserContext(this.readerContext, this, \n                                                    containingBd));\n    }\n</code></pre>\n<p>获取节点的 namespaceUri，然后根据该 namespaceuri 获取相对应的 Handler，调用 Handler 的 <code>parse()</code> 方法即完成自定义标签的解析和注入。想了解更多参考：<a href=\"http://127.0.0.1:4000/posts/32/\" target=\"_blank\" rel=\"noopener\">spring源码解析之 13自定义标签解析</a></p>\n<h2 id=\"注册-BeanDefinition\"><a href=\"#注册-BeanDefinition\" class=\"headerlink\" title=\"注册 BeanDefinition\"></a>注册 BeanDefinition</h2><p>经过上面的解析，则将 Document 对象里面的 Bean 标签解析成了一个个的 BeanDefinition ，下一步则是将这些 BeanDefinition 注册到 IOC 容器中。动作的触发是在解析 Bean 标签完成后，如下：</p>\n<pre><code class=\"java\">    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +\n                        bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n        }\n    }\n</code></pre>\n<p>调用 <code>BeanDefinitionReaderUtils.registerBeanDefinition()</code> 注册，其实这里面也是调用 BeanDefinitionRegistry 的 <code>registerBeanDefinition()</code>来注册 BeanDefinition ，不过最终的实现是在 DefaultListableBeanFactory 中实现，如下：</p>\n<pre><code class=\"java\">    @Override\n    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n            throws BeanDefinitionStoreException {\n\n      // 省略一堆校验\n\n        BeanDefinition oldBeanDefinition;\n\n        oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n          // 省略一堆 if\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n        }\n        else {\n            if (hasBeanCreationStarted()) {\n                // Cannot modify startup-time collection elements anymore (for stable iteration)\n                synchronized (this.beanDefinitionMap) {\n                    this.beanDefinitionMap.put(beanName, beanDefinition);\n                    List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);\n                    updatedDefinitions.addAll(this.beanDefinitionNames);\n                    updatedDefinitions.add(beanName);\n                    this.beanDefinitionNames = updatedDefinitions;\n                    if (this.manualSingletonNames.contains(beanName)) {\n                        Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;&gt;(this.manualSingletonNames);\n                        updatedSingletons.remove(beanName);\n                        this.manualSingletonNames = updatedSingletons;\n                    }\n                }\n            }\n            else {\n                // Still in startup registration phase\n                this.beanDefinitionMap.put(beanName, beanDefinition);\n                this.beanDefinitionNames.add(beanName);\n                this.manualSingletonNames.remove(beanName);\n            }\n            this.frozenBeanDefinitionNames = null;\n        }\n\n        if (oldBeanDefinition != null || containsSingleton(beanName)) {\n            resetBeanDefinition(beanName);\n        }\n    }\n</code></pre>\n<p>这段代码最核心的部分是这句 <code>this.beanDefinitionMap.put(beanName, beanDefinition)</code> ，所以注册过程也不是那么的高大上，就是利用一个 Map 的集合对象来存放，key 是 beanName，value 是 BeanDefinition。</p>\n<p>至此，整个 IOC 的初始化过程就已经完成了，从 Bean 资源的定位，转换为 Document 对象，接着对其进行解析，最后注册到 IOC 容器中，都已经完美地完成了。现在 IOC 容器中已经建立了整个 Bean 的配置信息，这些 Bean 可以被检索、使用、维护，他们是控制反转的基础，是后面注入 Bean 的依赖。</p>\n<p>更多阅读：</p>\n<ul>\n<li><a href=\"https://taolove.top/tags/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/\">spring源码解析</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-15BeanDefinition解析总结\"><a href=\"#spring源码解析之-15BeanDefinition解析总结\" class=\"headerlink\" title=\"spring源码解析之 15BeanDefinition解析总结\"></a>spring源码解析之 15BeanDefinition解析总结</h1><p>前面 13 篇博文从源码层次分析了 IOC 整个初始化过程，这篇就这些内容做一个总结将其连贯起来。</p>\n<p>在前文提过，IOC 容器的初始化过程分为三步骤：Resource 定位、BeanDefinition 的载入和解析，BeanDefinition 注册。<br>","more":"</p>\n<p><img src=\"/images/pasted-11.png\" alt=\"upload successful\"></p>\n<ul>\n<li><strong>Resource 定位</strong>。我们一般用外部资源来描述 Bean 对象，所以在初始化 IOC 容器的第一步就是需要定位这个外部资源。</li>\n<li><strong>BeanDefinition 的载入和解析</strong>。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IOC 容器的内部数据结构：BeanDefinition。在 IOC 容器内部维护着一个 BeanDefinition Map 的数据结构，在配置文件中每一个都对应着一个BeanDefinition对象。</li>\n<li><strong>BeanDefinition 注册</strong>。向IOC容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistery 接口来实现的。在 IOC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IOC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。在这里需要注意的一点是这个过程并没有完成依赖注入，依赖注册是发生在应用第一次调用 <code>getBean()</code> 向容器索要 Bean 时。当然我们可以通过设置预处理，即对某个 Bean 设置 lazyinit 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。</li>\n</ul>\n<p>还记得在博客<a href=\"https://taolove.top/posts/23/\">spring 源码解析之 04加载bean</a> 中提供的一段代码吗？这里我们同样也以这段代码作为我们研究 IOC 初始化过程的开端，如下：</p>\n<pre><code class=\"java\">ClassPathResource resource = new ClassPathResource(&quot;bean.xml&quot;);\nDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\nXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\nreader.loadBeanDefinitions(resource);\n</code></pre>\n<p>刚刚开始的时候可能对上面这几行代码不知道什么意思，现在应该就一目了然了。</p>\n<ul>\n<li><code>ClassPathResource resource = new ClassPathResource(&quot;bean.xml&quot;);</code>： 根据 Xml 配置文件创建 Resource 资源对象。ClassPathResource 是 Resource 接口的子类，bean.xml 文件中的内容是我们定义的 Bean 信息。</li>\n<li><code>DefaultListableBeanFactory factory = new DefaultListableBeanFactory();</code> 创建一个 BeanFactory。DefaultListableBeanFactory 是 BeanFactory 的一个子类，BeanFactory 作为一个接口，其实它本身是不具有独立使用的功能的，而 DefaultListableBeanFactory 则是真正可以独立使用的 IOC 容器，它是整个 Spring IOC 的始祖，在后续会有专门的文章来分析它。</li>\n<li><code>XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);</code>：创建 XmlBeanDefinitionReader 读取器，用于载入 BeanDefinition 。</li>\n<li><code>reader.loadBeanDefinitions(resource);</code>：开启 Bean 的载入和注册进程，完成后的 Bean 放置在 IOC 容器中。</li>\n</ul>\n<h2 id=\"Resource-定位\"><a href=\"#Resource-定位\" class=\"headerlink\" title=\"Resource 定位\"></a>Resource 定位</h2><p>Spring 为了解决资源定位的问题，提供了两个接口：Resource、ResourceLoader，其中 Resource 接口是 Spring 统一资源的抽象接口，ResourceLoader 则是 Spring 资源加载的统一抽象。关于Resource、ResourceLoader 的更多知识请关注<a href=\"https://taolove.top/posts/22/\">spring源码解析之 03统一资源加载</a></p>\n<p>Resource 资源的定位需要 Resource 和 ResourceLoader 两个接口互相配合，在上面那段代码中 <code>new ClassPathResource(&quot;bean.xml&quot;)</code> 为我们定义了资源，那么 ResourceLoader 则是在什么时候初始化的呢？看 XmlBeanDefinitionReader 构造方法：</p>\n<pre><code class=\"java\">    public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) {\n        super(registry);\n    }\n</code></pre>\n<p>直接调用父类 AbstractBeanDefinitionReader ：</p>\n<pre><code class=\"java\">    protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) {\n        Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);\n        this.registry = registry;\n\n        // Determine ResourceLoader to use.\n        if (this.registry instanceof ResourceLoader) {\n            this.resourceLoader = (ResourceLoader) this.registry;\n        }\n        else {\n            this.resourceLoader = new PathMatchingResourcePatternResolver();\n        }\n\n        // Inherit Environment if possible\n        if (this.registry instanceof EnvironmentCapable) {\n            this.environment = ((EnvironmentCapable) this.registry).getEnvironment();\n        }\n        else {\n            this.environment = new StandardEnvironment();\n        }\n    }\n</code></pre>\n<p>核心在于设置 resourceLoader 这段，如果设置了 ResourceLoader 则用设置的，否则使用 PathMatchingResourcePatternResolver ，该类是一个集大成者的 ResourceLoader。</p>\n<h2 id=\"BeanDefinition-的载入和解析\"><a href=\"#BeanDefinition-的载入和解析\" class=\"headerlink\" title=\"BeanDefinition 的载入和解析\"></a>BeanDefinition 的载入和解析</h2><p><code>reader.loadBeanDefinitions(resource);</code> 开启 BeanDefinition 的解析过程。如下：</p>\n<pre><code class=\"java\">    public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {\n        return loadBeanDefinitions(new EncodedResource(resource));\n    }\n</code></pre>\n<p>在这个方法会将资源 resource 包装成一个 EncodedResource 实例对象，然后调用 <code>loadBeanDefinitions()</code> 方法，而将 Resource 封装成 EncodedResource 主要是为了对 Resource 进行编码，保证内容读取的正确性。</p>\n<pre><code class=\"java\">   public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n        // 省略一些代码\n        try {\n            // 将资源文件转为 InputStream 的 IO 流\n            InputStream inputStream = encodedResource.getResource().getInputStream();\n            try {\n                // 从 InputStream 中得到 XML 的解析源\n                InputSource inputSource = new InputSource(inputStream);\n                if (encodedResource.getEncoding() != null) {\n                    inputSource.setEncoding(encodedResource.getEncoding());\n                }\n\n                // 具体的读取过程\n                return doLoadBeanDefinitions(inputSource, \n                                             encodedResource.getResource());\n            }\n            finally {\n                inputStream.close();\n            }\n        }\n        // 省略一些代码\n    }\n</code></pre>\n<p>从 encodedResource 源中获取 xml 的解析源，调用 <code>doLoadBeanDefinitions()</code> 执行具体的解析过程。</p>\n<pre><code class=\"java\">    protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n            throws BeanDefinitionStoreException {\n        try {\n            Document doc = doLoadDocument(inputSource, resource);\n            return registerBeanDefinitions(doc, resource);\n        }\n        // 省略很多catch代码\n</code></pre>\n<p>在该方法中主要做两件事：</p>\n<ol>\n<li><p>根据 xml 解析源获取相应的 Document 对象</p>\n</li>\n<li><p>调用 <code>registerBeanDefinitions()</code> 开启 BeanDefinition 的解析注册过程。</p>\n</li>\n</ol>\n<h3 id=\"转换为-Document-对象\"><a href=\"#转换为-Document-对象\" class=\"headerlink\" title=\"转换为 Document 对象\"></a>转换为 Document 对象</h3><p>调用 <code>doLoadDocument()</code> 会将 Bean 定义的资源转换为 Document 对象。</p>\n<pre><code class=\"java\">    protected Document doLoadDocument(InputSource inputSource, Resource resource) \n        throws Exception {\n        return this.documentLoader\n            .loadDocument(inputSource, getEntityResolver(), this.errorHandler,\n                getValidationModeForResource(resource), isNamespaceAware());\n    }\n</code></pre>\n<p><code>loadDocument()</code> 方法接受五个参数：</p>\n<ul>\n<li><strong>inputSource</strong>：加载 Document 的 Resource 源</li>\n<li><strong>entityResolver</strong>：解析文件的解析器</li>\n<li><strong>errorHandler</strong>：处理加载 Document 对象的过程的错误</li>\n<li><strong>validationMode</strong>：验证模式</li>\n<li><strong>namespaceAware</strong>：命名空间支持。如果要提供对 XML 名称空间的支持，则为true</li>\n</ul>\n<p>对于这五个参数，有两个参数需要重点关注下：entityResolver、validationMode。这两个参数分别在<a href=\"http://127.0.0.1:4000/posts/23/\" target=\"_blank\" rel=\"noopener\">spring 源码解析之 04（上）加载bean</a>   和  <a href=\"http://127.0.0.1:4000/posts/35/\" target=\"_blank\" rel=\"noopener\">spring源码解析之 04（下）获取验证模型</a> 中有详细的讲述。</p>\n<p><code>loadDocument()</code> 在类 DefaultDocumentLoader 中提供了实现，如下：</p>\n<pre><code class=\"java\">    public Document loadDocument(InputSource inputSource, \n                                 EntityResolver entityResolver,\n            ErrorHandler errorHandler, int validationMode, boolean namespaceAware) \n        throws Exception {\n        // 创建文件解析工厂\n        DocumentBuilderFactory factory = \n            createDocumentBuilderFactory(validationMode, namespaceAware);\n        if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);\n        }\n        // 创建文档解析器\n        DocumentBuilder builder = \n            createDocumentBuilder(factory, entityResolver, errorHandler);\n        // 解析 Spring 的 Bean 定义资源\n        return builder.parse(inputSource);\n    }\n</code></pre>\n<p>这到这里，就已经将定义的 Bean 资源文件，载入并转换为 Document 对象了，那么下一步就是如何将其解析为 Spring IOC 管理的 Bean 对象并将其注册到容器中。这个过程有方法 <code>registerBeanDefinitions()</code> 实现。如下：</p>\n<pre><code class=\"java\">    public int registerBeanDefinitions(Document doc, Resource resource)\n        throws BeanDefinitionStoreException {\n       // 创建 BeanDefinitionDocumentReader 来对 xml 格式的BeanDefinition 解析\n        BeanDefinitionDocumentReader documentReader = \n                    createBeanDefinitionDocumentReader();\n        // 获得容器中注册的Bean数量\n        int countBefore = getRegistry().getBeanDefinitionCount();\n\n        // 解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口，\n        // 具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成\n        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n        return getRegistry().getBeanDefinitionCount() - countBefore;\n    }\n</code></pre>\n<p>首先创建 BeanDefinition 的解析器 BeanDefinitionDocumentReader，然后调用 <code>documentReader.registerBeanDefinitions()</code> 开启解析过程，这里使用的是委派模式，具体的实现由子类 DefaultBeanDefinitionDocumentReader 完成。</p>\n<pre><code class=\"java\">    public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n       // 获得XML描述符\n        this.readerContext = readerContext;\n        logger.debug(&quot;Loading bean definitions&quot;);\n\n        // 获得Document的根元素\n        Element root = doc.getDocumentElement();\n\n        // 解析根元素\n        doRegisterBeanDefinitions(root);\n    }\n</code></pre>\n<h3 id=\"对-Document-对象的解析\"><a href=\"#对-Document-对象的解析\" class=\"headerlink\" title=\"对 Document 对象的解析\"></a>对 Document 对象的解析</h3><p>从 Document 对象中获取根元素 root，然后调用 <code>doRegisterBeanDefinitions()</code> 开启真正的解析过程。</p>\n<pre><code class=\"java\">    protected void doRegisterBeanDefinitions(Element root) {\n        BeanDefinitionParserDelegate parent = this.delegate;\n        this.delegate = createDelegate(getReaderContext(), root, parent);\n\n       // 省略部分代码\n\n        preProcessXml(root);\n        parseBeanDefinitions(root, this.delegate);\n        postProcessXml(root);\n\n        this.delegate = parent;\n    }\n</code></pre>\n<p><code>preProcessXml()</code>、<code>postProcessXml()</code> 为前置、后置增强处理，目前 Spring 中都是空实现， <code>parseBeanDefinitions()</code> 是对根元素 root 的解析注册过程。</p>\n<pre><code class=\"java\">    protected void parseBeanDefinitions(Element root, \n                                        BeanDefinitionParserDelegate delegate) {\n       // Bean定义的Document对象使用了Spring默认的XML命名空间\n        if (delegate.isDefaultNamespace(root)) {\n          // 获取Bean定义的Document对象根元素的所有子节点\n            NodeList nl = root.getChildNodes();\n            for (int i = 0; i &lt; nl.getLength(); i++) {\n                Node node = nl.item(i);\n                // 获得Document节点是XML元素节点 \n                if (node instanceof Element) {\n                    Element ele = (Element) node;\n                    // Bean定义的Document的元素节点使用的是Spring默认的XML命名空间\n                    if (delegate.isDefaultNamespace(ele)) {\n                       // 使用Spring的Bean规则解析元素节点（默认解析规则）\n                        parseDefaultElement(ele, delegate);\n                    }\n                    else {\n                       // 没有使用Spring默认的XML命名空间，则使用用户自定义的解析规则解析元素节点 \n                        delegate.parseCustomElement(ele);\n                    }\n                }\n            }\n        }\n        else {\n          // Document 的根节点没有使用Spring默认的命名空间，则使用用户自定义的解析规则解析\n            delegate.parseCustomElement(root);\n        }\n    }\n</code></pre>\n<p>迭代 root 元素的所有子节点，对其进行判断，若节点为默认命名空间，则ID调用 <code>parseDefaultElement()</code> 开启默认标签的解析注册过程，否则调用 <code>parseCustomElement()</code> 开启自定义标签的解析注册过程。</p>\n<h3 id=\"标签解析\"><a href=\"#标签解析\" class=\"headerlink\" title=\"标签解析\"></a>标签解析</h3><p>若定义的元素节点使用的是 Spring 默认命名空间，则调用 <code>parseDefaultElement()</code> 进行默认标签解析，如下：</p>\n<pre><code class=\"java\">    private void parseDefaultElement(Element ele, \n                                     BeanDefinitionParserDelegate delegate) {\n       // 如果元素节点是&lt;Import&gt;导入元素，进行导入解析\n        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n            importBeanDefinitionResource(ele);\n        }\n        // 如果元素节点是&lt;Alias&gt;别名元素，进行别名解析 \n        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n            processAliasRegistration(ele);\n        }\n        // 如果元素节点&lt;Bean&gt;元素，则进行Bean解析注册\n        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n            processBeanDefinition(ele, delegate);\n        }\n\n        // // 如果元素节点&lt;Beans&gt;元素，则进行Beans解析\n        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n            // recurse\n            doRegisterBeanDefinitions(ele);\n        }\n    }\n</code></pre>\n<p>对四大标签：import、alias、bean、beans 进行解析，其中 bean 标签的解析为核心工作。关于各个标签的解析过程见如下文章：</p>\n<ul>\n<li><a href=\"http://127.0.0.1:4000/posts/31/\" target=\"_blank\" rel=\"noopener\">spring源码解析之  12alias、import、beans标签的解析</a></li>\n<li><a href=\"http://127.0.0.1:4000/posts/30/\" target=\"_blank\" rel=\"noopener\">spring源码解析之   11bean标签：解析自定义标签</a></li>\n<li><a href=\"http://127.0.0.1:4000/posts/29/\" target=\"_blank\" rel=\"noopener\">spring 源码解析之 10bean标签：constructor-arg、property子元素</a></li>\n<li><a href=\"http://127.0.0.1:4000/posts/28/\" target=\"_blank\" rel=\"noopener\">spring源码解析之 09bean 标签：meta、lookup-method、replace-method</a></li>\n<li><a href=\"http://127.0.0.1:4000/posts/27/\" target=\"_blank\" rel=\"noopener\">Spring源码解析之 08bean标签：BeanDefinition</a></li>\n<li><a href=\"http://127.0.0.1:4000/posts/26/\" target=\"_blank\" rel=\"noopener\">spring源码解析之 07bean标签:开启解析进程</a></li>\n</ul>\n<p>对于默认标签则由 <code>parseCustomElement()</code> 负责解析。</p>\n<pre><code class=\"java\">    public BeanDefinition parseCustomElement(Element ele) {\n        return parseCustomElement(ele, null);\n    }\n\n    public BeanDefinition parseCustomElement(Element ele, \n                                             @Nullable BeanDefinition containingBd) {\n        String namespaceUri = getNamespaceURI(ele);\n        if (namespaceUri == null) {\n            return null;\n        }\n        NamespaceHandler handler = this.readerContext\n                    .getNamespaceHandlerResolver().resolve(namespaceUri);\n        if (handler == null) {\n            error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; \n                      + namespaceUri + &quot;]&quot;, ele);\n            return null;\n        }\n        return handler.parse(ele, new ParserContext(this.readerContext, this, \n                                                    containingBd));\n    }\n</code></pre>\n<p>获取节点的 namespaceUri，然后根据该 namespaceuri 获取相对应的 Handler，调用 Handler 的 <code>parse()</code> 方法即完成自定义标签的解析和注入。想了解更多参考：<a href=\"http://127.0.0.1:4000/posts/32/\" target=\"_blank\" rel=\"noopener\">spring源码解析之 13自定义标签解析</a></p>\n<h2 id=\"注册-BeanDefinition\"><a href=\"#注册-BeanDefinition\" class=\"headerlink\" title=\"注册 BeanDefinition\"></a>注册 BeanDefinition</h2><p>经过上面的解析，则将 Document 对象里面的 Bean 标签解析成了一个个的 BeanDefinition ，下一步则是将这些 BeanDefinition 注册到 IOC 容器中。动作的触发是在解析 Bean 标签完成后，如下：</p>\n<pre><code class=\"java\">    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n        if (bdHolder != null) {\n            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n            try {\n                // Register the final decorated instance.\n                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n            }\n            catch (BeanDefinitionStoreException ex) {\n                getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +\n                        bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);\n            }\n            // Send registration event.\n            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n        }\n    }\n</code></pre>\n<p>调用 <code>BeanDefinitionReaderUtils.registerBeanDefinition()</code> 注册，其实这里面也是调用 BeanDefinitionRegistry 的 <code>registerBeanDefinition()</code>来注册 BeanDefinition ，不过最终的实现是在 DefaultListableBeanFactory 中实现，如下：</p>\n<pre><code class=\"java\">    @Override\n    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n            throws BeanDefinitionStoreException {\n\n      // 省略一堆校验\n\n        BeanDefinition oldBeanDefinition;\n\n        oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n          // 省略一堆 if\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n        }\n        else {\n            if (hasBeanCreationStarted()) {\n                // Cannot modify startup-time collection elements anymore (for stable iteration)\n                synchronized (this.beanDefinitionMap) {\n                    this.beanDefinitionMap.put(beanName, beanDefinition);\n                    List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);\n                    updatedDefinitions.addAll(this.beanDefinitionNames);\n                    updatedDefinitions.add(beanName);\n                    this.beanDefinitionNames = updatedDefinitions;\n                    if (this.manualSingletonNames.contains(beanName)) {\n                        Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;&gt;(this.manualSingletonNames);\n                        updatedSingletons.remove(beanName);\n                        this.manualSingletonNames = updatedSingletons;\n                    }\n                }\n            }\n            else {\n                // Still in startup registration phase\n                this.beanDefinitionMap.put(beanName, beanDefinition);\n                this.beanDefinitionNames.add(beanName);\n                this.manualSingletonNames.remove(beanName);\n            }\n            this.frozenBeanDefinitionNames = null;\n        }\n\n        if (oldBeanDefinition != null || containsSingleton(beanName)) {\n            resetBeanDefinition(beanName);\n        }\n    }\n</code></pre>\n<p>这段代码最核心的部分是这句 <code>this.beanDefinitionMap.put(beanName, beanDefinition)</code> ，所以注册过程也不是那么的高大上，就是利用一个 Map 的集合对象来存放，key 是 beanName，value 是 BeanDefinition。</p>\n<p>至此，整个 IOC 的初始化过程就已经完成了，从 Bean 资源的定位，转换为 Document 对象，接着对其进行解析，最后注册到 IOC 容器中，都已经完美地完成了。现在 IOC 容器中已经建立了整个 Bean 的配置信息，这些 Bean 可以被检索、使用、维护，他们是控制反转的基础，是后面注入 Bean 的依赖。</p>\n<p>更多阅读：</p>\n<ul>\n<li><a href=\"https://taolove.top/tags/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/\">spring源码解析</a></li>\n</ul>"},{"abbrlink":32,"title":"spring源码解析之 13自定义标签解析","author":"fengxiutianya","date":"2019-01-13T21:37:00.000Z","_content":"# spring源码解析之 13自定义标签解析\n\n### 概述\n\n1. 自定义标签简介\n2. 源码分析\n\n### 自定义标签简介\n\n在之前的分析中，我们提到了在Spring中存在默认标签与自定义标签俩种，而在上一章节中我们分析了Spring中对默认标签的解析过程。但是遗留了一个问题，就是对自定义标签的解析。这里先回顾以下当完成从配置文件到Document的转换并提取对应的root后，就开始了所有元素的解析，而在这一过程中便开始了默认标签和自定义标签俩种格式的区分，代码如下：\n<!-- more-->\n\n```java\n\tprotected void parseBeanDefinitions(Element root, \n\t\t\t\tBeanDefinitionParserDelegate delegate) {\n\t\tif (delegate.isDefaultNamespace(root)) {\n\t\t\tNodeList nl = root.getChildNodes();\n\t\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tif (node instanceof Element) {\n\t\t\t\t\tElement ele = (Element) node;\n\t\t\t\t\tif (delegate.isDefaultNamespace(ele)) {\n\t\t\t\t\t\tparseDefaultElement(ele, delegate);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdelegate.parseCustomElement(ele);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdelegate.parseCustomElement(root);\n\t\t}\n\t}\n```\n\n本篇我们主要是围绕着`delegate.parseCustomElement(root)`来进行开展，当Spring拿到一个元素时，首先要做的是根据命名空间进行解析，如果是默认命名空间，则使用parseDefaultElement方法进行元素解析，否则使用parseCustomElement方法进行解析。在分析自定义表亲过程钱，我们先了解一下自定义标签的使用过程。\n\n扩展 Spring 自定义标签配置一般需要以下几个步骤：\n\n1. 创建一个需要扩展的组件\n2. 定义一个 XSD 文件，用于描述组件内容\n3. 创建一个实现 AbstractSingleBeanDefinitionParser 接口的类，用来解析 XSD 文件中的定义和组件定义\n4. 创建一个 Handler，继承 NamespaceHandlerSupport ，用于将组件注册到 Spring 容器\n5. 编写 Spring.handlers 和 Spring.schemas 文件\n\n下面就按照上面的步骤来实现一个自定义标签组件。\n\n**创建组件**\n\n该组件就是一个普通的 JavaBean，没有任何特别之处。\n\n```java\npublic class User {\n    private String id;\n\n    private String userName;\n\n    private String email;\n}\n```\n\n**定义 XSD 文件**\n\n```null\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n            xmlns=\"http://www.cmsblogs.com/schema/user\" targetNamespace=\"http://www.cmsblogs.com/schema/user\"\n            elementFormDefault=\"qualified\">\n    <xsd:element name=\"user\">\n        <xsd:complexType>\n            <xsd:attribute name=\"id\" type=\"xsd:string\" />\n            <xsd:attribute name=\"userName\" type=\"xsd:string\" />\n            <xsd:attribute name=\"email\" type=\"xsd:string\" />\n        </xsd:complexType>\n    </xsd:element>\n</xsd:schema>\n```\n\n上面除了对 User 这个 JavaBean 进行了描述外，还定义了 `xmlns=\"http://www.cmsblogs.com/schema/user\" targetNamespace=\"http://www.cmsblogs.com/schema/user\"` 这两个值，这两个值在后面是有大作用的。\n\n**Parser 类**\n\n定义一个 Parser 类，该类继承 AbstractSingleBeanDefinitionParser ，并实现 `getBeanClass()` 和 `doParse()` 两个方法。主要是用于解析 XSD 文件中的定义和组件定义。\n\n```java\npublic class UserDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\n    @Override\n    protected Class<?> getBeanClass(Element element) {\n        return User.class;\n    }\n    @Override\n    protected void doParse(Element element, BeanDefinitionBuilder builder) {\n        String id = element.getAttribute(\"id\");\n        String userName=element.getAttribute(\"userName\");\n        String email=element.getAttribute(\"email\");\n        if(StringUtils.hasText(id)){\n            builder.addPropertyValue(\"id\",id);\n        }\n        if(StringUtils.hasText(userName)){\n            builder.addPropertyValue(\"userName\", userName);\n        }\n        if(StringUtils.hasText(email)){\n            builder.addPropertyValue(\"email\", email);\n        }\n\n    }\n}\n```\n\n**Handler 类**\n\n定义 Handler 类，继承 NamespaceHandlerSupport ,主要目的是将组件注册到 Spring 容器中。\n\n```java\npublic class UserNamespaceHandler extends NamespaceHandlerSupport {\n\n    @Override\n    public void init() {\n        registerBeanDefinitionParser(\"user\",new UserDefinitionParser());\n    }\n}\n```\n\n**Spring.handlers**\n\n```\nhttp\\://www.cmsblogs.com/schema/user=org.springframework.core.customelement.UserNamespaceHandler\n```\n\n**Spring.schemas**\n\n```null\nhttp\\://www.cmsblogs.com/schema/user.xsd=user.xsd\n```\n\n经过上面几个步骤，就可以使用自定义的标签了。在 xml 配置文件中使用如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:myTag=\"http://www.cmsblogs.com/schema/user\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.cmsblogs.com/schema/user http://www.cmsblogs.com/schema/user.xsd\">\n\n    <myTag:user id=\"user\" email=\"12233445566@qq.com\" userName=\"chenssy\" />\n</beans>\n```\n\n测试：\n\n```java\n    public static void main(String[] args){\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"spring.xml\");\n\n        User user = (User) context.getBean(\"user\");\n\n        System.out.println(user.getUserName() + \"----\" + user.getEmail());\n    }\n}\n```\n\n运行结果\n\n```\nuser----chenssy---12233445566@qq.com\n```\n\n### 源码分析\n\n上面已经演示了 Spring 自定义标签的使用，下面就来分析自定义标签的解析过程。\n\n`DefaultBeanDefinitionDocumentReader.parseBeanDefinitions()` 负责标签的解析工作，其中它根据命名空间的不同进行不同标签的解析，其中自定义标签由 `delegate.parseCustomElement()` 实现。如下：\n\n```java\n    public BeanDefinition parseCustomElement(Element ele) {\n        return parseCustomElement(ele, null);\n    }\n```\n\n调用 `parseCustomElement()` 方法，如下：\n\n```java\n    public BeanDefinition parseCustomElement(Element ele, \n                                             @Nullable BeanDefinition containingBd) {\n        // 获取 namespaceUri\n        String namespaceUri = getNamespaceURI(ele);\n        if (namespaceUri == null) {\n            return null;\n        }\n\n        // 根据 namespaceUri 获取相应的 Handler\n        NamespaceHandler handler = \n            this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n        if (handler == null) {\n            error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" \n                  + namespaceUri + \"]\", ele);\n            return null;\n        }\n\n        // 调用自定义的 Handler 处理\n        return handler.parse(ele, new ParserContext(this.readerContext, this, \n                                                    containingBd));\n    }\n```\n\n处理过程分为三步：\n\n1. 获取 namespaceUri\n2. 根据 namespaceUri 获取相应的 Handler\n3. 调用自定义的 Handler 处理\n\n这个处理过程很简单明了，根据 namespaceUri 获取 Handler，这个映射关系我们在 Spring.handlers 中已经定义了，所以只需要找到该类，然后初始化返回，最后调用该 Handler 对象的 `parse()` 方法处理，该方法我们也提供了实现。所以上面的核心就在于怎么找到该 Handler 类。调用方法为：`this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri)`\n\n`getNamespaceHandlerResolver()` 方法返回的命名空间的解析器，该解析定义在 `XmlReaderContext` 中，如下：\n\n```java\n    public final NamespaceHandlerResolver getNamespaceHandlerResolver() {\n        return this.namespaceHandlerResolver;\n    }\n```\n\n这里直接返回，那是在什么时候初始化的呢？在前面提到过注册 BeanDefinition 时，首先是通过 `createBeanDefinitionDocumentReader()` 获取 Document 解析器 BeanDefinitionDocumentReader 实例，然后调用该实例 `registerBeanDefinitions()` 方法进行注册。`registerBeanDefinitions()` 方法需要提供两个参数，一个是 Document 实例 doc，一个是 XmlReaderContext 实例 readerContext，readerContext 实例对象由 `createReaderContext()` 方法提供。namespaceHandlerResolver 实例对象就是在这个时候初始化的。如下：\n\n```java\n    public XmlReaderContext createReaderContext(Resource resource) {\n        return new XmlReaderContext(resource, this.problemReporter, this.eventListener,\n                this.sourceExtractor, this, getNamespaceHandlerResolver());\n    }\n```\n\nXmlReaderContext 构造函数中最后一个参数就是 NamespaceHandlerResolver 对象，该对象由 `getNamespaceHandlerResolver()` 提供，如下：\n\n```java\n    public NamespaceHandlerResolver getNamespaceHandlerResolver() {\n        if (this.namespaceHandlerResolver == null) {\n            this.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();\n        }\n        return this.namespaceHandlerResolver;\n    }\n\n    protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() {\n        ClassLoader cl = (getResourceLoader() != null ? \n                          getResourceLoader().getClassLoader() : getBeanClassLoader());\n        return new DefaultNamespaceHandlerResolver(cl);\n    }\n```\n\n所以 `getNamespaceHandlerResolver().resolve(namespaceUri)` 调用的就是 DefaultNamespaceHandlerResolver 的 `resolve()`。如下：\n\n```java\n   public NamespaceHandler resolve(String namespaceUri) {\n        // 获取所有已经配置的 Handler 映射\n        Map<String, Object> handlerMappings = getHandlerMappings();\n\n        // 根据 namespaceUri 获取 handler的信息：这里一般都是类路径\n        Object handlerOrClassName = handlerMappings.get(namespaceUri);\n        if (handlerOrClassName == null) {\n            return null;\n        }\n        else if (handlerOrClassName instanceof NamespaceHandler) {\n            // 如果已经做过解析，直接返回\n            return (NamespaceHandler) handlerOrClassName;\n        }\n        else {\n            String className = (String) handlerOrClassName;\n            try {\n\n                Class<?> handlerClass = ClassUtils.forName(className, \n                                                           this.classLoader);\n                if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {\n                    throw new FatalBeanException(\"Class [\" + className \n                                                 + \"] for namespace [\" + namespaceUri\n                                                 + \"] does not implement the [\" \n                                                 + NamespaceHandler.class.getName() \n                                                 + \"] interface\");\n                }\n\n                // 初始化类\n                NamespaceHandler namespaceHandler = \n                    (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);\n\n                // 调用 init() 方法\n                namespaceHandler.init();\n\n                // 记录在缓存\n                handlerMappings.put(namespaceUri, namespaceHandler);\n                return namespaceHandler;\n            }\n            catch (ClassNotFoundException ex) {\n                throw new FatalBeanException(\"Could not find NamespaceHandler class [\" \n                                             + className +\n                        \"] for namespace [\" + namespaceUri + \"]\", ex);\n            }\n            catch (LinkageError err) {\n                throw new FatalBeanException(\"Unresolvable class definition for \n                                             NamespaceHandler class [\" +\n                        className + \"] for namespace [\" + namespaceUri + \"]\", err);\n            }\n        }\n    }\n```\n\n首先调用 `getHandlerMappings()` 获取所有配置文件中的映射关系 handlerMappings ，该关系为 `<命名空间,类路径>`，然后根据命名空间 namespaceUri 从映射关系中获取相应的信息，如果为空或者已经初始化了就直接返回，否则根据反射对其进行初始化，同时调用其 `init()` 方法，最后将该 Handler 对象缓存。\n\n`init()` 方法主要是将自定义标签解析器进行注册，如我们自定义的 `init()` ：\n\n```java\n    @Override\n    public void init() {\n        registerBeanDefinitionParser(\"user\",new UserDefinitionParser());\n    }\n```\n\n在这里你可以注册多个标签解析器，当前示例只支持`< myName:user >`。你也可以注册`<myname:A>`、`<myname:B>`等，是的myname的命名空间中可以支持多种标签解析。\n\n在init方法里面直接调用父类的 `registerBeanDefinitionParser()` 方法进行注册：\n\n```java\n    protected final void registerBeanDefinitionParser(String elementName, \n                                                      BeanDefinitionParser parser) {\n        this.parsers.put(elementName, parser);\n    }\n```\n\n其实就是将映射关系放在一个 Map 结构的 parsers 对象中：`private final Map<String, BeanDefinitionParser> parsers` 。\n\n注册后，命名空间处理器可以根据标签的不同来调用不同的解析器进行解析。那么根据上面函数与之前介绍过的例子，我们基本上可以推断getHandlerMappings的主要功能就是读取Spring.handlers配置文件并将配置文件缓存在map中。\n\n```java\nprivate Map<String, Object> getHandlerMappings() {\n\t\tMap<String, Object> handlerMappings = this.handlerMappings;\n\t\tif (handlerMappings == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\thandlerMappings = this.handlerMappings;\n\t\t\t\tif (handlerMappings == null) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Loading NamespaceHandler mappings from [\"\n                                     + this.handlerMappingsLocation + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n                        // handlerMappingsLocation 默认是META-INF/Spring.handlers\n\t\t\t\t\t\tProperties mappings =PropertiesLoaderUtils.loadAllProperties(\n                            this.handlerMappingsLocation, this.classLoader);\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Loaded NamespaceHandler mappings: \"\n                                         + mappings);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandlerMappings = new ConcurrentHashMap<>(mappings.size());\n\t\t\t\t\t\tCollectionUtils.mergePropertiesIntoMap(mappings, \n                                                               handlerMappings);\n\t\t\t\t\t\tthis.handlerMappings = handlerMappings;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Unable to load NamespaceHandler mappings from location [\" \n                            + this.handlerMappingsLocation + \"]\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn handlerMappings;\n\t}\n```\n\n同我们想的一样，借助了PropertiesLoaderUtils对属性handlerMappingsLocation进行了配置文件的读取，handlerMappingLocation被默认初始化为`META-INF/Spring.handlers`\n\n上面完整的分析了根据 namespaceUri 获取相应的 NamespaceHandler 对象，然后调用其 `parse()` 方法开始自定义标签的解析，如下：\n\n```java\n    public BeanDefinition parse(Element element, ParserContext parserContext) {\n        BeanDefinitionParser parser = findParserForElement(element, parserContext);\n        return (parser != null ? parser.parse(element, parserContext) : null);\n    }\n```\n\n调用 `findParserForElement()` 方法获取 BeanDefinitionParser 实例，其实就是获取在 `init()` 方法里面注册的实例对象。如下：\n\n```java\n    private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {\n        String localName = parserContext.getDelegate().getLocalName(element);\n        BeanDefinitionParser parser = this.parsers.get(localName);\n        if (parser == null) {\n            parserContext.getReaderContext().fatal(\n                    \"Cannot locate BeanDefinitionParser for element [\" + localName\n                \t\t+ \"]\", element);\n        }\n        return parser;\n    }\n```\n\n获取 localName，在上面的例子中就是 ： user，然后从 Map 实例 parsers 中获取 BeanDefinitionParser 对象。返回 BeanDefinitionParser 对象后，调用其 `parse()`，该方法在 AbstractBeanDefinitionParser 中实现：\n\n```java\n    public final BeanDefinition parse(Element element, ParserContext parserContext) {\n        AbstractBeanDefinition definition = parseInternal(element, parserContext);\n        if (definition != null && !parserContext.isNested()) {\n            try {\n                String id = resolveId(element, definition, parserContext);\n                if (!StringUtils.hasText(id)) {\n                    parserContext.getReaderContext().error(\n                            \"Id is required for element '\" + \n                        parserContext.getDelegate().getLocalName(element)\n                                    + \"' when used as a top-level tag\", element);\n                }\n                String[] aliases = null;\n                if (shouldParseNameAsAliases()) {\n                    String name = element.getAttribute(NAME_ATTRIBUTE);\n                    if (StringUtils.hasLength(name)) {\n                        aliases = StringUtils.trimArrayElements\n                            (StringUtils.commaDelimitedListToStringArray(name));\n                    }\n                }\n                BeanDefinitionHolder holder = \n                    new BeanDefinitionHolder(definition, id, aliases);\n                registerBeanDefinition(holder, parserContext.getRegistry());\n                if (shouldFireEvents()) {\n                    BeanComponentDefinition componentDefinition =\n                        new BeanComponentDefinition(holder);\n                    postProcessComponentDefinition(componentDefinition);\n                    parserContext.registerComponent(componentDefinition);\n                }\n            }\n            catch (BeanDefinitionStoreException ex) {\n                String msg = ex.getMessage();\n                parserContext.getReaderContext().error((msg != null ? msg : \n                                                        ex.toString()), element);\n                return null;\n            }\n        }\n        return definition;\n    }\n```\n\n核心在方法 `parseInternal()` 为什么这么说，以为该方法返回的是 AbstractBeanDefinition 对象，从前面默认标签的解析工作中我们就可以判断该方法就是将标签解析为 AbstractBeanDefinition ，且后续代码都是将 AbstractBeanDefinition 转换为 BeanDefinitionHolder，所以真正的解析工作都交由 `parseInternal()` 实现，如下：\n\n```java\n    protected final AbstractBeanDefinition parseInternal(Element element,\n                                                         ParserContext parserContext) {\n        // 获取\n        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition();\n\n        // 获取父类元素\n        String parentName = getParentName(element);\n        if (parentName != null) {\n            builder.getRawBeanDefinition().setParentName(parentName);\n        }\n\n        // 获取自定义标签中的 class，这个时候会去调用自定义解析中的 getBeanClass()\n        Class<?> beanClass = getBeanClass(element);\n        if (beanClass != null) {\n            builder.getRawBeanDefinition().setBeanClass(beanClass);\n        }\n        else {\n            // beanClass 为 null，意味着子类并没有重写 getBeanClass() 方法，\n            // 则尝试去判断是否重写了 getBeanClassName()\n            String beanClassName = getBeanClassName(element);\n            if (beanClassName != null) {\n                builder.getRawBeanDefinition().setBeanClassName(beanClassName);\n            }\n        }\n        builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));\n        BeanDefinition containingBd = parserContext.getContainingBeanDefinition();\n        if (containingBd != null) {\n            // Inner bean definition must receive same scope as containing bean.\n            builder.setScope(containingBd.getScope());\n        }\n        if (parserContext.isDefaultLazyInit()) {\n            // Default-lazy-init applies to custom bean definitions as well.\n            builder.setLazyInit(true);\n        }\n\n        // 调用子类的 doParse() 进行解析\n        doParse(element, parserContext, builder);\n        return builder.getBeanDefinition();\n    }\n```\n\n在该方法中我们主要关注两个方法：`getBeanClass()` 、`doParse()`。对于 `getBeanClass()` 方法，AbstractSingleBeanDefinitionParser 类并没有提供具体实现，而是直接返回 null，意味着它希望子类能够重写该方法，当然如果没有重写该方法，这会去调用 `getBeanClassName()` ，判断子类是否已经重写了该方法。对于 `doParse()` 则是直接空实现。所以对于 `parseInternal()` 而言它总是期待它的子类能够实现 `getBeanClass()`、`doParse()`，其中 `doParse()` 尤为重要，如果你不提供实现，怎么来解析自定义标签呢？最后将自定义的解析器：UserDefinitionParser 再次回观。\n\n```java\npublic class UserDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\n    @Override\n    protected Class<?> getBeanClass(Element element) {\n        return User.class;\n    }\n    @Override\n    protected void doParse(Element element, BeanDefinitionBuilder builder) {\n        String id = element.getAttribute(\"id\");\n        String userName=element.getAttribute(\"userName\");\n        String email=element.getAttribute(\"email\");\n        if(StringUtils.hasText(id)){\n            builder.addPropertyValue(\"id\",id);\n        }\n        if(StringUtils.hasText(userName)){\n            builder.addPropertyValue(\"userName\", userName);\n        }\n        if(StringUtils.hasText(email)){\n            builder.addPropertyValue(\"email\", email);\n        }\n\n    }\n}\n```\n\n至此，自定义标签的解析过程已经分析完成了。其实整个过程还是较为简单：首先会加载 handlers 文件，将其中内容进行一个解析，形成 `<namespaceUri,类路径> `这样的一个映射，然后根据获取的 namespaceUri 就可以得到相应的类路径，对其进行初始化等到相应的 Handler 对象，调用 `parse()` 方法，在该方法中根据标签的 localName 得到相应的 BeanDefinitionParser 实例对象，调用 `parse()` ，该方法定义在 AbstractBeanDefinitionParser 抽象类中，核心逻辑封装在其 `parseInternal()` 中，该方法返回一个 AbstractBeanDefinition 实例对象，其主要是在 AbstractSingleBeanDefinitionParser 中实现，对于自定义的 Parser 类，其需要实现 `getBeanClass()` 或者 `getBeanClassName()` 和 `doParse()`。\n\n另外回顾一下整个自定义标签的处理过程，虽然示例中我们只定义了与我们逻辑相关的工作，类如`UserDefinitionParser`中我们只定义了getBeanClss和doParse俩个函数。但是其它的工作，类如创建BeanDefinition以及默认标签的设置，对于这些spring已经默认设置过了，为了方便我们实现知识暴露出一些个性化定义的接口，方便我们进行定制。","source":"_posts/spring 源码分析/spring/spring源码解析之 13自定义标签解析.md","raw":"abbrlink: 32\ntitle: spring源码解析之 13自定义标签解析\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-14 05:37:00\n---\n# spring源码解析之 13自定义标签解析\n\n### 概述\n\n1. 自定义标签简介\n2. 源码分析\n\n### 自定义标签简介\n\n在之前的分析中，我们提到了在Spring中存在默认标签与自定义标签俩种，而在上一章节中我们分析了Spring中对默认标签的解析过程。但是遗留了一个问题，就是对自定义标签的解析。这里先回顾以下当完成从配置文件到Document的转换并提取对应的root后，就开始了所有元素的解析，而在这一过程中便开始了默认标签和自定义标签俩种格式的区分，代码如下：\n<!-- more-->\n\n```java\n\tprotected void parseBeanDefinitions(Element root, \n\t\t\t\tBeanDefinitionParserDelegate delegate) {\n\t\tif (delegate.isDefaultNamespace(root)) {\n\t\t\tNodeList nl = root.getChildNodes();\n\t\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tif (node instanceof Element) {\n\t\t\t\t\tElement ele = (Element) node;\n\t\t\t\t\tif (delegate.isDefaultNamespace(ele)) {\n\t\t\t\t\t\tparseDefaultElement(ele, delegate);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdelegate.parseCustomElement(ele);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdelegate.parseCustomElement(root);\n\t\t}\n\t}\n```\n\n本篇我们主要是围绕着`delegate.parseCustomElement(root)`来进行开展，当Spring拿到一个元素时，首先要做的是根据命名空间进行解析，如果是默认命名空间，则使用parseDefaultElement方法进行元素解析，否则使用parseCustomElement方法进行解析。在分析自定义表亲过程钱，我们先了解一下自定义标签的使用过程。\n\n扩展 Spring 自定义标签配置一般需要以下几个步骤：\n\n1. 创建一个需要扩展的组件\n2. 定义一个 XSD 文件，用于描述组件内容\n3. 创建一个实现 AbstractSingleBeanDefinitionParser 接口的类，用来解析 XSD 文件中的定义和组件定义\n4. 创建一个 Handler，继承 NamespaceHandlerSupport ，用于将组件注册到 Spring 容器\n5. 编写 Spring.handlers 和 Spring.schemas 文件\n\n下面就按照上面的步骤来实现一个自定义标签组件。\n\n**创建组件**\n\n该组件就是一个普通的 JavaBean，没有任何特别之处。\n\n```java\npublic class User {\n    private String id;\n\n    private String userName;\n\n    private String email;\n}\n```\n\n**定义 XSD 文件**\n\n```null\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n            xmlns=\"http://www.cmsblogs.com/schema/user\" targetNamespace=\"http://www.cmsblogs.com/schema/user\"\n            elementFormDefault=\"qualified\">\n    <xsd:element name=\"user\">\n        <xsd:complexType>\n            <xsd:attribute name=\"id\" type=\"xsd:string\" />\n            <xsd:attribute name=\"userName\" type=\"xsd:string\" />\n            <xsd:attribute name=\"email\" type=\"xsd:string\" />\n        </xsd:complexType>\n    </xsd:element>\n</xsd:schema>\n```\n\n上面除了对 User 这个 JavaBean 进行了描述外，还定义了 `xmlns=\"http://www.cmsblogs.com/schema/user\" targetNamespace=\"http://www.cmsblogs.com/schema/user\"` 这两个值，这两个值在后面是有大作用的。\n\n**Parser 类**\n\n定义一个 Parser 类，该类继承 AbstractSingleBeanDefinitionParser ，并实现 `getBeanClass()` 和 `doParse()` 两个方法。主要是用于解析 XSD 文件中的定义和组件定义。\n\n```java\npublic class UserDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\n    @Override\n    protected Class<?> getBeanClass(Element element) {\n        return User.class;\n    }\n    @Override\n    protected void doParse(Element element, BeanDefinitionBuilder builder) {\n        String id = element.getAttribute(\"id\");\n        String userName=element.getAttribute(\"userName\");\n        String email=element.getAttribute(\"email\");\n        if(StringUtils.hasText(id)){\n            builder.addPropertyValue(\"id\",id);\n        }\n        if(StringUtils.hasText(userName)){\n            builder.addPropertyValue(\"userName\", userName);\n        }\n        if(StringUtils.hasText(email)){\n            builder.addPropertyValue(\"email\", email);\n        }\n\n    }\n}\n```\n\n**Handler 类**\n\n定义 Handler 类，继承 NamespaceHandlerSupport ,主要目的是将组件注册到 Spring 容器中。\n\n```java\npublic class UserNamespaceHandler extends NamespaceHandlerSupport {\n\n    @Override\n    public void init() {\n        registerBeanDefinitionParser(\"user\",new UserDefinitionParser());\n    }\n}\n```\n\n**Spring.handlers**\n\n```\nhttp\\://www.cmsblogs.com/schema/user=org.springframework.core.customelement.UserNamespaceHandler\n```\n\n**Spring.schemas**\n\n```null\nhttp\\://www.cmsblogs.com/schema/user.xsd=user.xsd\n```\n\n经过上面几个步骤，就可以使用自定义的标签了。在 xml 配置文件中使用如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:myTag=\"http://www.cmsblogs.com/schema/user\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.cmsblogs.com/schema/user http://www.cmsblogs.com/schema/user.xsd\">\n\n    <myTag:user id=\"user\" email=\"12233445566@qq.com\" userName=\"chenssy\" />\n</beans>\n```\n\n测试：\n\n```java\n    public static void main(String[] args){\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"spring.xml\");\n\n        User user = (User) context.getBean(\"user\");\n\n        System.out.println(user.getUserName() + \"----\" + user.getEmail());\n    }\n}\n```\n\n运行结果\n\n```\nuser----chenssy---12233445566@qq.com\n```\n\n### 源码分析\n\n上面已经演示了 Spring 自定义标签的使用，下面就来分析自定义标签的解析过程。\n\n`DefaultBeanDefinitionDocumentReader.parseBeanDefinitions()` 负责标签的解析工作，其中它根据命名空间的不同进行不同标签的解析，其中自定义标签由 `delegate.parseCustomElement()` 实现。如下：\n\n```java\n    public BeanDefinition parseCustomElement(Element ele) {\n        return parseCustomElement(ele, null);\n    }\n```\n\n调用 `parseCustomElement()` 方法，如下：\n\n```java\n    public BeanDefinition parseCustomElement(Element ele, \n                                             @Nullable BeanDefinition containingBd) {\n        // 获取 namespaceUri\n        String namespaceUri = getNamespaceURI(ele);\n        if (namespaceUri == null) {\n            return null;\n        }\n\n        // 根据 namespaceUri 获取相应的 Handler\n        NamespaceHandler handler = \n            this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n        if (handler == null) {\n            error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" \n                  + namespaceUri + \"]\", ele);\n            return null;\n        }\n\n        // 调用自定义的 Handler 处理\n        return handler.parse(ele, new ParserContext(this.readerContext, this, \n                                                    containingBd));\n    }\n```\n\n处理过程分为三步：\n\n1. 获取 namespaceUri\n2. 根据 namespaceUri 获取相应的 Handler\n3. 调用自定义的 Handler 处理\n\n这个处理过程很简单明了，根据 namespaceUri 获取 Handler，这个映射关系我们在 Spring.handlers 中已经定义了，所以只需要找到该类，然后初始化返回，最后调用该 Handler 对象的 `parse()` 方法处理，该方法我们也提供了实现。所以上面的核心就在于怎么找到该 Handler 类。调用方法为：`this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri)`\n\n`getNamespaceHandlerResolver()` 方法返回的命名空间的解析器，该解析定义在 `XmlReaderContext` 中，如下：\n\n```java\n    public final NamespaceHandlerResolver getNamespaceHandlerResolver() {\n        return this.namespaceHandlerResolver;\n    }\n```\n\n这里直接返回，那是在什么时候初始化的呢？在前面提到过注册 BeanDefinition 时，首先是通过 `createBeanDefinitionDocumentReader()` 获取 Document 解析器 BeanDefinitionDocumentReader 实例，然后调用该实例 `registerBeanDefinitions()` 方法进行注册。`registerBeanDefinitions()` 方法需要提供两个参数，一个是 Document 实例 doc，一个是 XmlReaderContext 实例 readerContext，readerContext 实例对象由 `createReaderContext()` 方法提供。namespaceHandlerResolver 实例对象就是在这个时候初始化的。如下：\n\n```java\n    public XmlReaderContext createReaderContext(Resource resource) {\n        return new XmlReaderContext(resource, this.problemReporter, this.eventListener,\n                this.sourceExtractor, this, getNamespaceHandlerResolver());\n    }\n```\n\nXmlReaderContext 构造函数中最后一个参数就是 NamespaceHandlerResolver 对象，该对象由 `getNamespaceHandlerResolver()` 提供，如下：\n\n```java\n    public NamespaceHandlerResolver getNamespaceHandlerResolver() {\n        if (this.namespaceHandlerResolver == null) {\n            this.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();\n        }\n        return this.namespaceHandlerResolver;\n    }\n\n    protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() {\n        ClassLoader cl = (getResourceLoader() != null ? \n                          getResourceLoader().getClassLoader() : getBeanClassLoader());\n        return new DefaultNamespaceHandlerResolver(cl);\n    }\n```\n\n所以 `getNamespaceHandlerResolver().resolve(namespaceUri)` 调用的就是 DefaultNamespaceHandlerResolver 的 `resolve()`。如下：\n\n```java\n   public NamespaceHandler resolve(String namespaceUri) {\n        // 获取所有已经配置的 Handler 映射\n        Map<String, Object> handlerMappings = getHandlerMappings();\n\n        // 根据 namespaceUri 获取 handler的信息：这里一般都是类路径\n        Object handlerOrClassName = handlerMappings.get(namespaceUri);\n        if (handlerOrClassName == null) {\n            return null;\n        }\n        else if (handlerOrClassName instanceof NamespaceHandler) {\n            // 如果已经做过解析，直接返回\n            return (NamespaceHandler) handlerOrClassName;\n        }\n        else {\n            String className = (String) handlerOrClassName;\n            try {\n\n                Class<?> handlerClass = ClassUtils.forName(className, \n                                                           this.classLoader);\n                if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {\n                    throw new FatalBeanException(\"Class [\" + className \n                                                 + \"] for namespace [\" + namespaceUri\n                                                 + \"] does not implement the [\" \n                                                 + NamespaceHandler.class.getName() \n                                                 + \"] interface\");\n                }\n\n                // 初始化类\n                NamespaceHandler namespaceHandler = \n                    (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);\n\n                // 调用 init() 方法\n                namespaceHandler.init();\n\n                // 记录在缓存\n                handlerMappings.put(namespaceUri, namespaceHandler);\n                return namespaceHandler;\n            }\n            catch (ClassNotFoundException ex) {\n                throw new FatalBeanException(\"Could not find NamespaceHandler class [\" \n                                             + className +\n                        \"] for namespace [\" + namespaceUri + \"]\", ex);\n            }\n            catch (LinkageError err) {\n                throw new FatalBeanException(\"Unresolvable class definition for \n                                             NamespaceHandler class [\" +\n                        className + \"] for namespace [\" + namespaceUri + \"]\", err);\n            }\n        }\n    }\n```\n\n首先调用 `getHandlerMappings()` 获取所有配置文件中的映射关系 handlerMappings ，该关系为 `<命名空间,类路径>`，然后根据命名空间 namespaceUri 从映射关系中获取相应的信息，如果为空或者已经初始化了就直接返回，否则根据反射对其进行初始化，同时调用其 `init()` 方法，最后将该 Handler 对象缓存。\n\n`init()` 方法主要是将自定义标签解析器进行注册，如我们自定义的 `init()` ：\n\n```java\n    @Override\n    public void init() {\n        registerBeanDefinitionParser(\"user\",new UserDefinitionParser());\n    }\n```\n\n在这里你可以注册多个标签解析器，当前示例只支持`< myName:user >`。你也可以注册`<myname:A>`、`<myname:B>`等，是的myname的命名空间中可以支持多种标签解析。\n\n在init方法里面直接调用父类的 `registerBeanDefinitionParser()` 方法进行注册：\n\n```java\n    protected final void registerBeanDefinitionParser(String elementName, \n                                                      BeanDefinitionParser parser) {\n        this.parsers.put(elementName, parser);\n    }\n```\n\n其实就是将映射关系放在一个 Map 结构的 parsers 对象中：`private final Map<String, BeanDefinitionParser> parsers` 。\n\n注册后，命名空间处理器可以根据标签的不同来调用不同的解析器进行解析。那么根据上面函数与之前介绍过的例子，我们基本上可以推断getHandlerMappings的主要功能就是读取Spring.handlers配置文件并将配置文件缓存在map中。\n\n```java\nprivate Map<String, Object> getHandlerMappings() {\n\t\tMap<String, Object> handlerMappings = this.handlerMappings;\n\t\tif (handlerMappings == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\thandlerMappings = this.handlerMappings;\n\t\t\t\tif (handlerMappings == null) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Loading NamespaceHandler mappings from [\"\n                                     + this.handlerMappingsLocation + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n                        // handlerMappingsLocation 默认是META-INF/Spring.handlers\n\t\t\t\t\t\tProperties mappings =PropertiesLoaderUtils.loadAllProperties(\n                            this.handlerMappingsLocation, this.classLoader);\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Loaded NamespaceHandler mappings: \"\n                                         + mappings);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandlerMappings = new ConcurrentHashMap<>(mappings.size());\n\t\t\t\t\t\tCollectionUtils.mergePropertiesIntoMap(mappings, \n                                                               handlerMappings);\n\t\t\t\t\t\tthis.handlerMappings = handlerMappings;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Unable to load NamespaceHandler mappings from location [\" \n                            + this.handlerMappingsLocation + \"]\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn handlerMappings;\n\t}\n```\n\n同我们想的一样，借助了PropertiesLoaderUtils对属性handlerMappingsLocation进行了配置文件的读取，handlerMappingLocation被默认初始化为`META-INF/Spring.handlers`\n\n上面完整的分析了根据 namespaceUri 获取相应的 NamespaceHandler 对象，然后调用其 `parse()` 方法开始自定义标签的解析，如下：\n\n```java\n    public BeanDefinition parse(Element element, ParserContext parserContext) {\n        BeanDefinitionParser parser = findParserForElement(element, parserContext);\n        return (parser != null ? parser.parse(element, parserContext) : null);\n    }\n```\n\n调用 `findParserForElement()` 方法获取 BeanDefinitionParser 实例，其实就是获取在 `init()` 方法里面注册的实例对象。如下：\n\n```java\n    private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {\n        String localName = parserContext.getDelegate().getLocalName(element);\n        BeanDefinitionParser parser = this.parsers.get(localName);\n        if (parser == null) {\n            parserContext.getReaderContext().fatal(\n                    \"Cannot locate BeanDefinitionParser for element [\" + localName\n                \t\t+ \"]\", element);\n        }\n        return parser;\n    }\n```\n\n获取 localName，在上面的例子中就是 ： user，然后从 Map 实例 parsers 中获取 BeanDefinitionParser 对象。返回 BeanDefinitionParser 对象后，调用其 `parse()`，该方法在 AbstractBeanDefinitionParser 中实现：\n\n```java\n    public final BeanDefinition parse(Element element, ParserContext parserContext) {\n        AbstractBeanDefinition definition = parseInternal(element, parserContext);\n        if (definition != null && !parserContext.isNested()) {\n            try {\n                String id = resolveId(element, definition, parserContext);\n                if (!StringUtils.hasText(id)) {\n                    parserContext.getReaderContext().error(\n                            \"Id is required for element '\" + \n                        parserContext.getDelegate().getLocalName(element)\n                                    + \"' when used as a top-level tag\", element);\n                }\n                String[] aliases = null;\n                if (shouldParseNameAsAliases()) {\n                    String name = element.getAttribute(NAME_ATTRIBUTE);\n                    if (StringUtils.hasLength(name)) {\n                        aliases = StringUtils.trimArrayElements\n                            (StringUtils.commaDelimitedListToStringArray(name));\n                    }\n                }\n                BeanDefinitionHolder holder = \n                    new BeanDefinitionHolder(definition, id, aliases);\n                registerBeanDefinition(holder, parserContext.getRegistry());\n                if (shouldFireEvents()) {\n                    BeanComponentDefinition componentDefinition =\n                        new BeanComponentDefinition(holder);\n                    postProcessComponentDefinition(componentDefinition);\n                    parserContext.registerComponent(componentDefinition);\n                }\n            }\n            catch (BeanDefinitionStoreException ex) {\n                String msg = ex.getMessage();\n                parserContext.getReaderContext().error((msg != null ? msg : \n                                                        ex.toString()), element);\n                return null;\n            }\n        }\n        return definition;\n    }\n```\n\n核心在方法 `parseInternal()` 为什么这么说，以为该方法返回的是 AbstractBeanDefinition 对象，从前面默认标签的解析工作中我们就可以判断该方法就是将标签解析为 AbstractBeanDefinition ，且后续代码都是将 AbstractBeanDefinition 转换为 BeanDefinitionHolder，所以真正的解析工作都交由 `parseInternal()` 实现，如下：\n\n```java\n    protected final AbstractBeanDefinition parseInternal(Element element,\n                                                         ParserContext parserContext) {\n        // 获取\n        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition();\n\n        // 获取父类元素\n        String parentName = getParentName(element);\n        if (parentName != null) {\n            builder.getRawBeanDefinition().setParentName(parentName);\n        }\n\n        // 获取自定义标签中的 class，这个时候会去调用自定义解析中的 getBeanClass()\n        Class<?> beanClass = getBeanClass(element);\n        if (beanClass != null) {\n            builder.getRawBeanDefinition().setBeanClass(beanClass);\n        }\n        else {\n            // beanClass 为 null，意味着子类并没有重写 getBeanClass() 方法，\n            // 则尝试去判断是否重写了 getBeanClassName()\n            String beanClassName = getBeanClassName(element);\n            if (beanClassName != null) {\n                builder.getRawBeanDefinition().setBeanClassName(beanClassName);\n            }\n        }\n        builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));\n        BeanDefinition containingBd = parserContext.getContainingBeanDefinition();\n        if (containingBd != null) {\n            // Inner bean definition must receive same scope as containing bean.\n            builder.setScope(containingBd.getScope());\n        }\n        if (parserContext.isDefaultLazyInit()) {\n            // Default-lazy-init applies to custom bean definitions as well.\n            builder.setLazyInit(true);\n        }\n\n        // 调用子类的 doParse() 进行解析\n        doParse(element, parserContext, builder);\n        return builder.getBeanDefinition();\n    }\n```\n\n在该方法中我们主要关注两个方法：`getBeanClass()` 、`doParse()`。对于 `getBeanClass()` 方法，AbstractSingleBeanDefinitionParser 类并没有提供具体实现，而是直接返回 null，意味着它希望子类能够重写该方法，当然如果没有重写该方法，这会去调用 `getBeanClassName()` ，判断子类是否已经重写了该方法。对于 `doParse()` 则是直接空实现。所以对于 `parseInternal()` 而言它总是期待它的子类能够实现 `getBeanClass()`、`doParse()`，其中 `doParse()` 尤为重要，如果你不提供实现，怎么来解析自定义标签呢？最后将自定义的解析器：UserDefinitionParser 再次回观。\n\n```java\npublic class UserDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\n    @Override\n    protected Class<?> getBeanClass(Element element) {\n        return User.class;\n    }\n    @Override\n    protected void doParse(Element element, BeanDefinitionBuilder builder) {\n        String id = element.getAttribute(\"id\");\n        String userName=element.getAttribute(\"userName\");\n        String email=element.getAttribute(\"email\");\n        if(StringUtils.hasText(id)){\n            builder.addPropertyValue(\"id\",id);\n        }\n        if(StringUtils.hasText(userName)){\n            builder.addPropertyValue(\"userName\", userName);\n        }\n        if(StringUtils.hasText(email)){\n            builder.addPropertyValue(\"email\", email);\n        }\n\n    }\n}\n```\n\n至此，自定义标签的解析过程已经分析完成了。其实整个过程还是较为简单：首先会加载 handlers 文件，将其中内容进行一个解析，形成 `<namespaceUri,类路径> `这样的一个映射，然后根据获取的 namespaceUri 就可以得到相应的类路径，对其进行初始化等到相应的 Handler 对象，调用 `parse()` 方法，在该方法中根据标签的 localName 得到相应的 BeanDefinitionParser 实例对象，调用 `parse()` ，该方法定义在 AbstractBeanDefinitionParser 抽象类中，核心逻辑封装在其 `parseInternal()` 中，该方法返回一个 AbstractBeanDefinition 实例对象，其主要是在 AbstractSingleBeanDefinitionParser 中实现，对于自定义的 Parser 类，其需要实现 `getBeanClass()` 或者 `getBeanClassName()` 和 `doParse()`。\n\n另外回顾一下整个自定义标签的处理过程，虽然示例中我们只定义了与我们逻辑相关的工作，类如`UserDefinitionParser`中我们只定义了getBeanClss和doParse俩个函数。但是其它的工作，类如创建BeanDefinition以及默认标签的设置，对于这些spring已经默认设置过了，为了方便我们实现知识暴露出一些个性化定义的接口，方便我们进行定制。","slug":"spring 源码分析/spring/spring源码解析之 13自定义标签解析","published":1,"updated":"2019-01-15T03:37:06.297Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovx5005f9q1up1xlvc80","content":"<h1 id=\"spring源码解析之-13自定义标签解析\"><a href=\"#spring源码解析之-13自定义标签解析\" class=\"headerlink\" title=\"spring源码解析之 13自定义标签解析\"></a>spring源码解析之 13自定义标签解析</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>自定义标签简介</li>\n<li>源码分析</li>\n</ol>\n<h3 id=\"自定义标签简介\"><a href=\"#自定义标签简介\" class=\"headerlink\" title=\"自定义标签简介\"></a>自定义标签简介</h3><p>在之前的分析中，我们提到了在Spring中存在默认标签与自定义标签俩种，而在上一章节中我们分析了Spring中对默认标签的解析过程。但是遗留了一个问题，就是对自定义标签的解析。这里先回顾以下当完成从配置文件到Document的转换并提取对应的root后，就开始了所有元素的解析，而在这一过程中便开始了默认标签和自定义标签俩种格式的区分，代码如下：<br><a id=\"more\"></a></p>\n<pre><code class=\"java\">    protected void parseBeanDefinitions(Element root, \n                BeanDefinitionParserDelegate delegate) {\n        if (delegate.isDefaultNamespace(root)) {\n            NodeList nl = root.getChildNodes();\n            for (int i = 0; i &lt; nl.getLength(); i++) {\n                Node node = nl.item(i);\n                if (node instanceof Element) {\n                    Element ele = (Element) node;\n                    if (delegate.isDefaultNamespace(ele)) {\n                        parseDefaultElement(ele, delegate);\n                    }\n                    else {\n                        delegate.parseCustomElement(ele);\n                    }\n                }\n            }\n        }\n        else {\n            delegate.parseCustomElement(root);\n        }\n    }\n</code></pre>\n<p>本篇我们主要是围绕着<code>delegate.parseCustomElement(root)</code>来进行开展，当Spring拿到一个元素时，首先要做的是根据命名空间进行解析，如果是默认命名空间，则使用parseDefaultElement方法进行元素解析，否则使用parseCustomElement方法进行解析。在分析自定义表亲过程钱，我们先了解一下自定义标签的使用过程。</p>\n<p>扩展 Spring 自定义标签配置一般需要以下几个步骤：</p>\n<ol>\n<li>创建一个需要扩展的组件</li>\n<li>定义一个 XSD 文件，用于描述组件内容</li>\n<li>创建一个实现 AbstractSingleBeanDefinitionParser 接口的类，用来解析 XSD 文件中的定义和组件定义</li>\n<li>创建一个 Handler，继承 NamespaceHandlerSupport ，用于将组件注册到 Spring 容器</li>\n<li>编写 Spring.handlers 和 Spring.schemas 文件</li>\n</ol>\n<p>下面就按照上面的步骤来实现一个自定义标签组件。</p>\n<p><strong>创建组件</strong></p>\n<p>该组件就是一个普通的 JavaBean，没有任何特别之处。</p>\n<pre><code class=\"java\">public class User {\n    private String id;\n\n    private String userName;\n\n    private String email;\n}\n</code></pre>\n<p><strong>定义 XSD 文件</strong></p>\n<pre><code class=\"null\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;\n            xmlns=&quot;http://www.cmsblogs.com/schema/user&quot; targetNamespace=&quot;http://www.cmsblogs.com/schema/user&quot;\n            elementFormDefault=&quot;qualified&quot;&gt;\n    &lt;xsd:element name=&quot;user&quot;&gt;\n        &lt;xsd:complexType&gt;\n            &lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot; /&gt;\n            &lt;xsd:attribute name=&quot;userName&quot; type=&quot;xsd:string&quot; /&gt;\n            &lt;xsd:attribute name=&quot;email&quot; type=&quot;xsd:string&quot; /&gt;\n        &lt;/xsd:complexType&gt;\n    &lt;/xsd:element&gt;\n&lt;/xsd:schema&gt;\n</code></pre>\n<p>上面除了对 User 这个 JavaBean 进行了描述外，还定义了 <code>xmlns=&quot;http://www.cmsblogs.com/schema/user&quot; targetNamespace=&quot;http://www.cmsblogs.com/schema/user&quot;</code> 这两个值，这两个值在后面是有大作用的。</p>\n<p><strong>Parser 类</strong></p>\n<p>定义一个 Parser 类，该类继承 AbstractSingleBeanDefinitionParser ，并实现 <code>getBeanClass()</code> 和 <code>doParse()</code> 两个方法。主要是用于解析 XSD 文件中的定义和组件定义。</p>\n<pre><code class=\"java\">public class UserDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\n    @Override\n    protected Class&lt;?&gt; getBeanClass(Element element) {\n        return User.class;\n    }\n    @Override\n    protected void doParse(Element element, BeanDefinitionBuilder builder) {\n        String id = element.getAttribute(&quot;id&quot;);\n        String userName=element.getAttribute(&quot;userName&quot;);\n        String email=element.getAttribute(&quot;email&quot;);\n        if(StringUtils.hasText(id)){\n            builder.addPropertyValue(&quot;id&quot;,id);\n        }\n        if(StringUtils.hasText(userName)){\n            builder.addPropertyValue(&quot;userName&quot;, userName);\n        }\n        if(StringUtils.hasText(email)){\n            builder.addPropertyValue(&quot;email&quot;, email);\n        }\n\n    }\n}\n</code></pre>\n<p><strong>Handler 类</strong></p>\n<p>定义 Handler 类，继承 NamespaceHandlerSupport ,主要目的是将组件注册到 Spring 容器中。</p>\n<pre><code class=\"java\">public class UserNamespaceHandler extends NamespaceHandlerSupport {\n\n    @Override\n    public void init() {\n        registerBeanDefinitionParser(&quot;user&quot;,new UserDefinitionParser());\n    }\n}\n</code></pre>\n<p><strong>Spring.handlers</strong></p>\n<pre><code>http\\://www.cmsblogs.com/schema/user=org.springframework.core.customelement.UserNamespaceHandler\n</code></pre><p><strong>Spring.schemas</strong></p>\n<pre><code class=\"null\">http\\://www.cmsblogs.com/schema/user.xsd=user.xsd\n</code></pre>\n<p>经过上面几个步骤，就可以使用自定义的标签了。在 xml 配置文件中使用如下：</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:myTag=&quot;http://www.cmsblogs.com/schema/user&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.cmsblogs.com/schema/user http://www.cmsblogs.com/schema/user.xsd&quot;&gt;\n\n    &lt;myTag:user id=&quot;user&quot; email=&quot;12233445566@qq.com&quot; userName=&quot;chenssy&quot; /&gt;\n&lt;/beans&gt;\n</code></pre>\n<p>测试：</p>\n<pre><code class=\"java\">    public static void main(String[] args){\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);\n\n        User user = (User) context.getBean(&quot;user&quot;);\n\n        System.out.println(user.getUserName() + &quot;----&quot; + user.getEmail());\n    }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>user----chenssy---12233445566@qq.com\n</code></pre><h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>上面已经演示了 Spring 自定义标签的使用，下面就来分析自定义标签的解析过程。</p>\n<p><code>DefaultBeanDefinitionDocumentReader.parseBeanDefinitions()</code> 负责标签的解析工作，其中它根据命名空间的不同进行不同标签的解析，其中自定义标签由 <code>delegate.parseCustomElement()</code> 实现。如下：</p>\n<pre><code class=\"java\">    public BeanDefinition parseCustomElement(Element ele) {\n        return parseCustomElement(ele, null);\n    }\n</code></pre>\n<p>调用 <code>parseCustomElement()</code> 方法，如下：</p>\n<pre><code class=\"java\">    public BeanDefinition parseCustomElement(Element ele, \n                                             @Nullable BeanDefinition containingBd) {\n        // 获取 namespaceUri\n        String namespaceUri = getNamespaceURI(ele);\n        if (namespaceUri == null) {\n            return null;\n        }\n\n        // 根据 namespaceUri 获取相应的 Handler\n        NamespaceHandler handler = \n            this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n        if (handler == null) {\n            error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; \n                  + namespaceUri + &quot;]&quot;, ele);\n            return null;\n        }\n\n        // 调用自定义的 Handler 处理\n        return handler.parse(ele, new ParserContext(this.readerContext, this, \n                                                    containingBd));\n    }\n</code></pre>\n<p>处理过程分为三步：</p>\n<ol>\n<li>获取 namespaceUri</li>\n<li>根据 namespaceUri 获取相应的 Handler</li>\n<li>调用自定义的 Handler 处理</li>\n</ol>\n<p>这个处理过程很简单明了，根据 namespaceUri 获取 Handler，这个映射关系我们在 Spring.handlers 中已经定义了，所以只需要找到该类，然后初始化返回，最后调用该 Handler 对象的 <code>parse()</code> 方法处理，该方法我们也提供了实现。所以上面的核心就在于怎么找到该 Handler 类。调用方法为：<code>this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri)</code></p>\n<p><code>getNamespaceHandlerResolver()</code> 方法返回的命名空间的解析器，该解析定义在 <code>XmlReaderContext</code> 中，如下：</p>\n<pre><code class=\"java\">    public final NamespaceHandlerResolver getNamespaceHandlerResolver() {\n        return this.namespaceHandlerResolver;\n    }\n</code></pre>\n<p>这里直接返回，那是在什么时候初始化的呢？在前面提到过注册 BeanDefinition 时，首先是通过 <code>createBeanDefinitionDocumentReader()</code> 获取 Document 解析器 BeanDefinitionDocumentReader 实例，然后调用该实例 <code>registerBeanDefinitions()</code> 方法进行注册。<code>registerBeanDefinitions()</code> 方法需要提供两个参数，一个是 Document 实例 doc，一个是 XmlReaderContext 实例 readerContext，readerContext 实例对象由 <code>createReaderContext()</code> 方法提供。namespaceHandlerResolver 实例对象就是在这个时候初始化的。如下：</p>\n<pre><code class=\"java\">    public XmlReaderContext createReaderContext(Resource resource) {\n        return new XmlReaderContext(resource, this.problemReporter, this.eventListener,\n                this.sourceExtractor, this, getNamespaceHandlerResolver());\n    }\n</code></pre>\n<p>XmlReaderContext 构造函数中最后一个参数就是 NamespaceHandlerResolver 对象，该对象由 <code>getNamespaceHandlerResolver()</code> 提供，如下：</p>\n<pre><code class=\"java\">    public NamespaceHandlerResolver getNamespaceHandlerResolver() {\n        if (this.namespaceHandlerResolver == null) {\n            this.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();\n        }\n        return this.namespaceHandlerResolver;\n    }\n\n    protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() {\n        ClassLoader cl = (getResourceLoader() != null ? \n                          getResourceLoader().getClassLoader() : getBeanClassLoader());\n        return new DefaultNamespaceHandlerResolver(cl);\n    }\n</code></pre>\n<p>所以 <code>getNamespaceHandlerResolver().resolve(namespaceUri)</code> 调用的就是 DefaultNamespaceHandlerResolver 的 <code>resolve()</code>。如下：</p>\n<pre><code class=\"java\">   public NamespaceHandler resolve(String namespaceUri) {\n        // 获取所有已经配置的 Handler 映射\n        Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();\n\n        // 根据 namespaceUri 获取 handler的信息：这里一般都是类路径\n        Object handlerOrClassName = handlerMappings.get(namespaceUri);\n        if (handlerOrClassName == null) {\n            return null;\n        }\n        else if (handlerOrClassName instanceof NamespaceHandler) {\n            // 如果已经做过解析，直接返回\n            return (NamespaceHandler) handlerOrClassName;\n        }\n        else {\n            String className = (String) handlerOrClassName;\n            try {\n\n                Class&lt;?&gt; handlerClass = ClassUtils.forName(className, \n                                                           this.classLoader);\n                if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {\n                    throw new FatalBeanException(&quot;Class [&quot; + className \n                                                 + &quot;] for namespace [&quot; + namespaceUri\n                                                 + &quot;] does not implement the [&quot; \n                                                 + NamespaceHandler.class.getName() \n                                                 + &quot;] interface&quot;);\n                }\n\n                // 初始化类\n                NamespaceHandler namespaceHandler = \n                    (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);\n\n                // 调用 init() 方法\n                namespaceHandler.init();\n\n                // 记录在缓存\n                handlerMappings.put(namespaceUri, namespaceHandler);\n                return namespaceHandler;\n            }\n            catch (ClassNotFoundException ex) {\n                throw new FatalBeanException(&quot;Could not find NamespaceHandler class [&quot; \n                                             + className +\n                        &quot;] for namespace [&quot; + namespaceUri + &quot;]&quot;, ex);\n            }\n            catch (LinkageError err) {\n                throw new FatalBeanException(&quot;Unresolvable class definition for \n                                             NamespaceHandler class [&quot; +\n                        className + &quot;] for namespace [&quot; + namespaceUri + &quot;]&quot;, err);\n            }\n        }\n    }\n</code></pre>\n<p>首先调用 <code>getHandlerMappings()</code> 获取所有配置文件中的映射关系 handlerMappings ，该关系为 <code>&lt;命名空间,类路径&gt;</code>，然后根据命名空间 namespaceUri 从映射关系中获取相应的信息，如果为空或者已经初始化了就直接返回，否则根据反射对其进行初始化，同时调用其 <code>init()</code> 方法，最后将该 Handler 对象缓存。</p>\n<p><code>init()</code> 方法主要是将自定义标签解析器进行注册，如我们自定义的 <code>init()</code> ：</p>\n<pre><code class=\"java\">    @Override\n    public void init() {\n        registerBeanDefinitionParser(&quot;user&quot;,new UserDefinitionParser());\n    }\n</code></pre>\n<p>在这里你可以注册多个标签解析器，当前示例只支持<code>&lt; myName:user &gt;</code>。你也可以注册<code>&lt;myname:A&gt;</code>、<code>&lt;myname:B&gt;</code>等，是的myname的命名空间中可以支持多种标签解析。</p>\n<p>在init方法里面直接调用父类的 <code>registerBeanDefinitionParser()</code> 方法进行注册：</p>\n<pre><code class=\"java\">    protected final void registerBeanDefinitionParser(String elementName, \n                                                      BeanDefinitionParser parser) {\n        this.parsers.put(elementName, parser);\n    }\n</code></pre>\n<p>其实就是将映射关系放在一个 Map 结构的 parsers 对象中：<code>private final Map&lt;String, BeanDefinitionParser&gt; parsers</code> 。</p>\n<p>注册后，命名空间处理器可以根据标签的不同来调用不同的解析器进行解析。那么根据上面函数与之前介绍过的例子，我们基本上可以推断getHandlerMappings的主要功能就是读取Spring.handlers配置文件并将配置文件缓存在map中。</p>\n<pre><code class=\"java\">private Map&lt;String, Object&gt; getHandlerMappings() {\n        Map&lt;String, Object&gt; handlerMappings = this.handlerMappings;\n        if (handlerMappings == null) {\n            synchronized (this) {\n                handlerMappings = this.handlerMappings;\n                if (handlerMappings == null) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(&quot;Loading NamespaceHandler mappings from [&quot;\n                                     + this.handlerMappingsLocation + &quot;]&quot;);\n                    }\n                    try {\n                        // handlerMappingsLocation 默认是META-INF/Spring.handlers\n                        Properties mappings =PropertiesLoaderUtils.loadAllProperties(\n                            this.handlerMappingsLocation, this.classLoader);\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(&quot;Loaded NamespaceHandler mappings: &quot;\n                                         + mappings);\n                        }\n                        handlerMappings = new ConcurrentHashMap&lt;&gt;(mappings.size());\n                        CollectionUtils.mergePropertiesIntoMap(mappings, \n                                                               handlerMappings);\n                        this.handlerMappings = handlerMappings;\n                    }\n                    catch (IOException ex) {\n                        throw new IllegalStateException(\n                        &quot;Unable to load NamespaceHandler mappings from location [&quot; \n                            + this.handlerMappingsLocation + &quot;]&quot;, ex);\n                    }\n                }\n            }\n        }\n        return handlerMappings;\n    }\n</code></pre>\n<p>同我们想的一样，借助了PropertiesLoaderUtils对属性handlerMappingsLocation进行了配置文件的读取，handlerMappingLocation被默认初始化为<code>META-INF/Spring.handlers</code></p>\n<p>上面完整的分析了根据 namespaceUri 获取相应的 NamespaceHandler 对象，然后调用其 <code>parse()</code> 方法开始自定义标签的解析，如下：</p>\n<pre><code class=\"java\">    public BeanDefinition parse(Element element, ParserContext parserContext) {\n        BeanDefinitionParser parser = findParserForElement(element, parserContext);\n        return (parser != null ? parser.parse(element, parserContext) : null);\n    }\n</code></pre>\n<p>调用 <code>findParserForElement()</code> 方法获取 BeanDefinitionParser 实例，其实就是获取在 <code>init()</code> 方法里面注册的实例对象。如下：</p>\n<pre><code class=\"java\">    private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {\n        String localName = parserContext.getDelegate().getLocalName(element);\n        BeanDefinitionParser parser = this.parsers.get(localName);\n        if (parser == null) {\n            parserContext.getReaderContext().fatal(\n                    &quot;Cannot locate BeanDefinitionParser for element [&quot; + localName\n                        + &quot;]&quot;, element);\n        }\n        return parser;\n    }\n</code></pre>\n<p>获取 localName，在上面的例子中就是 ： user，然后从 Map 实例 parsers 中获取 BeanDefinitionParser 对象。返回 BeanDefinitionParser 对象后，调用其 <code>parse()</code>，该方法在 AbstractBeanDefinitionParser 中实现：</p>\n<pre><code class=\"java\">    public final BeanDefinition parse(Element element, ParserContext parserContext) {\n        AbstractBeanDefinition definition = parseInternal(element, parserContext);\n        if (definition != null &amp;&amp; !parserContext.isNested()) {\n            try {\n                String id = resolveId(element, definition, parserContext);\n                if (!StringUtils.hasText(id)) {\n                    parserContext.getReaderContext().error(\n                            &quot;Id is required for element &#39;&quot; + \n                        parserContext.getDelegate().getLocalName(element)\n                                    + &quot;&#39; when used as a top-level tag&quot;, element);\n                }\n                String[] aliases = null;\n                if (shouldParseNameAsAliases()) {\n                    String name = element.getAttribute(NAME_ATTRIBUTE);\n                    if (StringUtils.hasLength(name)) {\n                        aliases = StringUtils.trimArrayElements\n                            (StringUtils.commaDelimitedListToStringArray(name));\n                    }\n                }\n                BeanDefinitionHolder holder = \n                    new BeanDefinitionHolder(definition, id, aliases);\n                registerBeanDefinition(holder, parserContext.getRegistry());\n                if (shouldFireEvents()) {\n                    BeanComponentDefinition componentDefinition =\n                        new BeanComponentDefinition(holder);\n                    postProcessComponentDefinition(componentDefinition);\n                    parserContext.registerComponent(componentDefinition);\n                }\n            }\n            catch (BeanDefinitionStoreException ex) {\n                String msg = ex.getMessage();\n                parserContext.getReaderContext().error((msg != null ? msg : \n                                                        ex.toString()), element);\n                return null;\n            }\n        }\n        return definition;\n    }\n</code></pre>\n<p>核心在方法 <code>parseInternal()</code> 为什么这么说，以为该方法返回的是 AbstractBeanDefinition 对象，从前面默认标签的解析工作中我们就可以判断该方法就是将标签解析为 AbstractBeanDefinition ，且后续代码都是将 AbstractBeanDefinition 转换为 BeanDefinitionHolder，所以真正的解析工作都交由 <code>parseInternal()</code> 实现，如下：</p>\n<pre><code class=\"java\">    protected final AbstractBeanDefinition parseInternal(Element element,\n                                                         ParserContext parserContext) {\n        // 获取\n        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition();\n\n        // 获取父类元素\n        String parentName = getParentName(element);\n        if (parentName != null) {\n            builder.getRawBeanDefinition().setParentName(parentName);\n        }\n\n        // 获取自定义标签中的 class，这个时候会去调用自定义解析中的 getBeanClass()\n        Class&lt;?&gt; beanClass = getBeanClass(element);\n        if (beanClass != null) {\n            builder.getRawBeanDefinition().setBeanClass(beanClass);\n        }\n        else {\n            // beanClass 为 null，意味着子类并没有重写 getBeanClass() 方法，\n            // 则尝试去判断是否重写了 getBeanClassName()\n            String beanClassName = getBeanClassName(element);\n            if (beanClassName != null) {\n                builder.getRawBeanDefinition().setBeanClassName(beanClassName);\n            }\n        }\n        builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));\n        BeanDefinition containingBd = parserContext.getContainingBeanDefinition();\n        if (containingBd != null) {\n            // Inner bean definition must receive same scope as containing bean.\n            builder.setScope(containingBd.getScope());\n        }\n        if (parserContext.isDefaultLazyInit()) {\n            // Default-lazy-init applies to custom bean definitions as well.\n            builder.setLazyInit(true);\n        }\n\n        // 调用子类的 doParse() 进行解析\n        doParse(element, parserContext, builder);\n        return builder.getBeanDefinition();\n    }\n</code></pre>\n<p>在该方法中我们主要关注两个方法：<code>getBeanClass()</code> 、<code>doParse()</code>。对于 <code>getBeanClass()</code> 方法，AbstractSingleBeanDefinitionParser 类并没有提供具体实现，而是直接返回 null，意味着它希望子类能够重写该方法，当然如果没有重写该方法，这会去调用 <code>getBeanClassName()</code> ，判断子类是否已经重写了该方法。对于 <code>doParse()</code> 则是直接空实现。所以对于 <code>parseInternal()</code> 而言它总是期待它的子类能够实现 <code>getBeanClass()</code>、<code>doParse()</code>，其中 <code>doParse()</code> 尤为重要，如果你不提供实现，怎么来解析自定义标签呢？最后将自定义的解析器：UserDefinitionParser 再次回观。</p>\n<pre><code class=\"java\">public class UserDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\n    @Override\n    protected Class&lt;?&gt; getBeanClass(Element element) {\n        return User.class;\n    }\n    @Override\n    protected void doParse(Element element, BeanDefinitionBuilder builder) {\n        String id = element.getAttribute(&quot;id&quot;);\n        String userName=element.getAttribute(&quot;userName&quot;);\n        String email=element.getAttribute(&quot;email&quot;);\n        if(StringUtils.hasText(id)){\n            builder.addPropertyValue(&quot;id&quot;,id);\n        }\n        if(StringUtils.hasText(userName)){\n            builder.addPropertyValue(&quot;userName&quot;, userName);\n        }\n        if(StringUtils.hasText(email)){\n            builder.addPropertyValue(&quot;email&quot;, email);\n        }\n\n    }\n}\n</code></pre>\n<p>至此，自定义标签的解析过程已经分析完成了。其实整个过程还是较为简单：首先会加载 handlers 文件，将其中内容进行一个解析，形成 <code>&lt;namespaceUri,类路径&gt;</code>这样的一个映射，然后根据获取的 namespaceUri 就可以得到相应的类路径，对其进行初始化等到相应的 Handler 对象，调用 <code>parse()</code> 方法，在该方法中根据标签的 localName 得到相应的 BeanDefinitionParser 实例对象，调用 <code>parse()</code> ，该方法定义在 AbstractBeanDefinitionParser 抽象类中，核心逻辑封装在其 <code>parseInternal()</code> 中，该方法返回一个 AbstractBeanDefinition 实例对象，其主要是在 AbstractSingleBeanDefinitionParser 中实现，对于自定义的 Parser 类，其需要实现 <code>getBeanClass()</code> 或者 <code>getBeanClassName()</code> 和 <code>doParse()</code>。</p>\n<p>另外回顾一下整个自定义标签的处理过程，虽然示例中我们只定义了与我们逻辑相关的工作，类如<code>UserDefinitionParser</code>中我们只定义了getBeanClss和doParse俩个函数。但是其它的工作，类如创建BeanDefinition以及默认标签的设置，对于这些spring已经默认设置过了，为了方便我们实现知识暴露出一些个性化定义的接口，方便我们进行定制。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-13自定义标签解析\"><a href=\"#spring源码解析之-13自定义标签解析\" class=\"headerlink\" title=\"spring源码解析之 13自定义标签解析\"></a>spring源码解析之 13自定义标签解析</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>自定义标签简介</li>\n<li>源码分析</li>\n</ol>\n<h3 id=\"自定义标签简介\"><a href=\"#自定义标签简介\" class=\"headerlink\" title=\"自定义标签简介\"></a>自定义标签简介</h3><p>在之前的分析中，我们提到了在Spring中存在默认标签与自定义标签俩种，而在上一章节中我们分析了Spring中对默认标签的解析过程。但是遗留了一个问题，就是对自定义标签的解析。这里先回顾以下当完成从配置文件到Document的转换并提取对应的root后，就开始了所有元素的解析，而在这一过程中便开始了默认标签和自定义标签俩种格式的区分，代码如下：<br>","more":"</p>\n<pre><code class=\"java\">    protected void parseBeanDefinitions(Element root, \n                BeanDefinitionParserDelegate delegate) {\n        if (delegate.isDefaultNamespace(root)) {\n            NodeList nl = root.getChildNodes();\n            for (int i = 0; i &lt; nl.getLength(); i++) {\n                Node node = nl.item(i);\n                if (node instanceof Element) {\n                    Element ele = (Element) node;\n                    if (delegate.isDefaultNamespace(ele)) {\n                        parseDefaultElement(ele, delegate);\n                    }\n                    else {\n                        delegate.parseCustomElement(ele);\n                    }\n                }\n            }\n        }\n        else {\n            delegate.parseCustomElement(root);\n        }\n    }\n</code></pre>\n<p>本篇我们主要是围绕着<code>delegate.parseCustomElement(root)</code>来进行开展，当Spring拿到一个元素时，首先要做的是根据命名空间进行解析，如果是默认命名空间，则使用parseDefaultElement方法进行元素解析，否则使用parseCustomElement方法进行解析。在分析自定义表亲过程钱，我们先了解一下自定义标签的使用过程。</p>\n<p>扩展 Spring 自定义标签配置一般需要以下几个步骤：</p>\n<ol>\n<li>创建一个需要扩展的组件</li>\n<li>定义一个 XSD 文件，用于描述组件内容</li>\n<li>创建一个实现 AbstractSingleBeanDefinitionParser 接口的类，用来解析 XSD 文件中的定义和组件定义</li>\n<li>创建一个 Handler，继承 NamespaceHandlerSupport ，用于将组件注册到 Spring 容器</li>\n<li>编写 Spring.handlers 和 Spring.schemas 文件</li>\n</ol>\n<p>下面就按照上面的步骤来实现一个自定义标签组件。</p>\n<p><strong>创建组件</strong></p>\n<p>该组件就是一个普通的 JavaBean，没有任何特别之处。</p>\n<pre><code class=\"java\">public class User {\n    private String id;\n\n    private String userName;\n\n    private String email;\n}\n</code></pre>\n<p><strong>定义 XSD 文件</strong></p>\n<pre><code class=\"null\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;\n            xmlns=&quot;http://www.cmsblogs.com/schema/user&quot; targetNamespace=&quot;http://www.cmsblogs.com/schema/user&quot;\n            elementFormDefault=&quot;qualified&quot;&gt;\n    &lt;xsd:element name=&quot;user&quot;&gt;\n        &lt;xsd:complexType&gt;\n            &lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot; /&gt;\n            &lt;xsd:attribute name=&quot;userName&quot; type=&quot;xsd:string&quot; /&gt;\n            &lt;xsd:attribute name=&quot;email&quot; type=&quot;xsd:string&quot; /&gt;\n        &lt;/xsd:complexType&gt;\n    &lt;/xsd:element&gt;\n&lt;/xsd:schema&gt;\n</code></pre>\n<p>上面除了对 User 这个 JavaBean 进行了描述外，还定义了 <code>xmlns=&quot;http://www.cmsblogs.com/schema/user&quot; targetNamespace=&quot;http://www.cmsblogs.com/schema/user&quot;</code> 这两个值，这两个值在后面是有大作用的。</p>\n<p><strong>Parser 类</strong></p>\n<p>定义一个 Parser 类，该类继承 AbstractSingleBeanDefinitionParser ，并实现 <code>getBeanClass()</code> 和 <code>doParse()</code> 两个方法。主要是用于解析 XSD 文件中的定义和组件定义。</p>\n<pre><code class=\"java\">public class UserDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\n    @Override\n    protected Class&lt;?&gt; getBeanClass(Element element) {\n        return User.class;\n    }\n    @Override\n    protected void doParse(Element element, BeanDefinitionBuilder builder) {\n        String id = element.getAttribute(&quot;id&quot;);\n        String userName=element.getAttribute(&quot;userName&quot;);\n        String email=element.getAttribute(&quot;email&quot;);\n        if(StringUtils.hasText(id)){\n            builder.addPropertyValue(&quot;id&quot;,id);\n        }\n        if(StringUtils.hasText(userName)){\n            builder.addPropertyValue(&quot;userName&quot;, userName);\n        }\n        if(StringUtils.hasText(email)){\n            builder.addPropertyValue(&quot;email&quot;, email);\n        }\n\n    }\n}\n</code></pre>\n<p><strong>Handler 类</strong></p>\n<p>定义 Handler 类，继承 NamespaceHandlerSupport ,主要目的是将组件注册到 Spring 容器中。</p>\n<pre><code class=\"java\">public class UserNamespaceHandler extends NamespaceHandlerSupport {\n\n    @Override\n    public void init() {\n        registerBeanDefinitionParser(&quot;user&quot;,new UserDefinitionParser());\n    }\n}\n</code></pre>\n<p><strong>Spring.handlers</strong></p>\n<pre><code>http\\://www.cmsblogs.com/schema/user=org.springframework.core.customelement.UserNamespaceHandler\n</code></pre><p><strong>Spring.schemas</strong></p>\n<pre><code class=\"null\">http\\://www.cmsblogs.com/schema/user.xsd=user.xsd\n</code></pre>\n<p>经过上面几个步骤，就可以使用自定义的标签了。在 xml 配置文件中使用如下：</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:myTag=&quot;http://www.cmsblogs.com/schema/user&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.cmsblogs.com/schema/user http://www.cmsblogs.com/schema/user.xsd&quot;&gt;\n\n    &lt;myTag:user id=&quot;user&quot; email=&quot;12233445566@qq.com&quot; userName=&quot;chenssy&quot; /&gt;\n&lt;/beans&gt;\n</code></pre>\n<p>测试：</p>\n<pre><code class=\"java\">    public static void main(String[] args){\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);\n\n        User user = (User) context.getBean(&quot;user&quot;);\n\n        System.out.println(user.getUserName() + &quot;----&quot; + user.getEmail());\n    }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>user----chenssy---12233445566@qq.com\n</code></pre><h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>上面已经演示了 Spring 自定义标签的使用，下面就来分析自定义标签的解析过程。</p>\n<p><code>DefaultBeanDefinitionDocumentReader.parseBeanDefinitions()</code> 负责标签的解析工作，其中它根据命名空间的不同进行不同标签的解析，其中自定义标签由 <code>delegate.parseCustomElement()</code> 实现。如下：</p>\n<pre><code class=\"java\">    public BeanDefinition parseCustomElement(Element ele) {\n        return parseCustomElement(ele, null);\n    }\n</code></pre>\n<p>调用 <code>parseCustomElement()</code> 方法，如下：</p>\n<pre><code class=\"java\">    public BeanDefinition parseCustomElement(Element ele, \n                                             @Nullable BeanDefinition containingBd) {\n        // 获取 namespaceUri\n        String namespaceUri = getNamespaceURI(ele);\n        if (namespaceUri == null) {\n            return null;\n        }\n\n        // 根据 namespaceUri 获取相应的 Handler\n        NamespaceHandler handler = \n            this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n        if (handler == null) {\n            error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; \n                  + namespaceUri + &quot;]&quot;, ele);\n            return null;\n        }\n\n        // 调用自定义的 Handler 处理\n        return handler.parse(ele, new ParserContext(this.readerContext, this, \n                                                    containingBd));\n    }\n</code></pre>\n<p>处理过程分为三步：</p>\n<ol>\n<li>获取 namespaceUri</li>\n<li>根据 namespaceUri 获取相应的 Handler</li>\n<li>调用自定义的 Handler 处理</li>\n</ol>\n<p>这个处理过程很简单明了，根据 namespaceUri 获取 Handler，这个映射关系我们在 Spring.handlers 中已经定义了，所以只需要找到该类，然后初始化返回，最后调用该 Handler 对象的 <code>parse()</code> 方法处理，该方法我们也提供了实现。所以上面的核心就在于怎么找到该 Handler 类。调用方法为：<code>this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri)</code></p>\n<p><code>getNamespaceHandlerResolver()</code> 方法返回的命名空间的解析器，该解析定义在 <code>XmlReaderContext</code> 中，如下：</p>\n<pre><code class=\"java\">    public final NamespaceHandlerResolver getNamespaceHandlerResolver() {\n        return this.namespaceHandlerResolver;\n    }\n</code></pre>\n<p>这里直接返回，那是在什么时候初始化的呢？在前面提到过注册 BeanDefinition 时，首先是通过 <code>createBeanDefinitionDocumentReader()</code> 获取 Document 解析器 BeanDefinitionDocumentReader 实例，然后调用该实例 <code>registerBeanDefinitions()</code> 方法进行注册。<code>registerBeanDefinitions()</code> 方法需要提供两个参数，一个是 Document 实例 doc，一个是 XmlReaderContext 实例 readerContext，readerContext 实例对象由 <code>createReaderContext()</code> 方法提供。namespaceHandlerResolver 实例对象就是在这个时候初始化的。如下：</p>\n<pre><code class=\"java\">    public XmlReaderContext createReaderContext(Resource resource) {\n        return new XmlReaderContext(resource, this.problemReporter, this.eventListener,\n                this.sourceExtractor, this, getNamespaceHandlerResolver());\n    }\n</code></pre>\n<p>XmlReaderContext 构造函数中最后一个参数就是 NamespaceHandlerResolver 对象，该对象由 <code>getNamespaceHandlerResolver()</code> 提供，如下：</p>\n<pre><code class=\"java\">    public NamespaceHandlerResolver getNamespaceHandlerResolver() {\n        if (this.namespaceHandlerResolver == null) {\n            this.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();\n        }\n        return this.namespaceHandlerResolver;\n    }\n\n    protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() {\n        ClassLoader cl = (getResourceLoader() != null ? \n                          getResourceLoader().getClassLoader() : getBeanClassLoader());\n        return new DefaultNamespaceHandlerResolver(cl);\n    }\n</code></pre>\n<p>所以 <code>getNamespaceHandlerResolver().resolve(namespaceUri)</code> 调用的就是 DefaultNamespaceHandlerResolver 的 <code>resolve()</code>。如下：</p>\n<pre><code class=\"java\">   public NamespaceHandler resolve(String namespaceUri) {\n        // 获取所有已经配置的 Handler 映射\n        Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();\n\n        // 根据 namespaceUri 获取 handler的信息：这里一般都是类路径\n        Object handlerOrClassName = handlerMappings.get(namespaceUri);\n        if (handlerOrClassName == null) {\n            return null;\n        }\n        else if (handlerOrClassName instanceof NamespaceHandler) {\n            // 如果已经做过解析，直接返回\n            return (NamespaceHandler) handlerOrClassName;\n        }\n        else {\n            String className = (String) handlerOrClassName;\n            try {\n\n                Class&lt;?&gt; handlerClass = ClassUtils.forName(className, \n                                                           this.classLoader);\n                if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {\n                    throw new FatalBeanException(&quot;Class [&quot; + className \n                                                 + &quot;] for namespace [&quot; + namespaceUri\n                                                 + &quot;] does not implement the [&quot; \n                                                 + NamespaceHandler.class.getName() \n                                                 + &quot;] interface&quot;);\n                }\n\n                // 初始化类\n                NamespaceHandler namespaceHandler = \n                    (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);\n\n                // 调用 init() 方法\n                namespaceHandler.init();\n\n                // 记录在缓存\n                handlerMappings.put(namespaceUri, namespaceHandler);\n                return namespaceHandler;\n            }\n            catch (ClassNotFoundException ex) {\n                throw new FatalBeanException(&quot;Could not find NamespaceHandler class [&quot; \n                                             + className +\n                        &quot;] for namespace [&quot; + namespaceUri + &quot;]&quot;, ex);\n            }\n            catch (LinkageError err) {\n                throw new FatalBeanException(&quot;Unresolvable class definition for \n                                             NamespaceHandler class [&quot; +\n                        className + &quot;] for namespace [&quot; + namespaceUri + &quot;]&quot;, err);\n            }\n        }\n    }\n</code></pre>\n<p>首先调用 <code>getHandlerMappings()</code> 获取所有配置文件中的映射关系 handlerMappings ，该关系为 <code>&lt;命名空间,类路径&gt;</code>，然后根据命名空间 namespaceUri 从映射关系中获取相应的信息，如果为空或者已经初始化了就直接返回，否则根据反射对其进行初始化，同时调用其 <code>init()</code> 方法，最后将该 Handler 对象缓存。</p>\n<p><code>init()</code> 方法主要是将自定义标签解析器进行注册，如我们自定义的 <code>init()</code> ：</p>\n<pre><code class=\"java\">    @Override\n    public void init() {\n        registerBeanDefinitionParser(&quot;user&quot;,new UserDefinitionParser());\n    }\n</code></pre>\n<p>在这里你可以注册多个标签解析器，当前示例只支持<code>&lt; myName:user &gt;</code>。你也可以注册<code>&lt;myname:A&gt;</code>、<code>&lt;myname:B&gt;</code>等，是的myname的命名空间中可以支持多种标签解析。</p>\n<p>在init方法里面直接调用父类的 <code>registerBeanDefinitionParser()</code> 方法进行注册：</p>\n<pre><code class=\"java\">    protected final void registerBeanDefinitionParser(String elementName, \n                                                      BeanDefinitionParser parser) {\n        this.parsers.put(elementName, parser);\n    }\n</code></pre>\n<p>其实就是将映射关系放在一个 Map 结构的 parsers 对象中：<code>private final Map&lt;String, BeanDefinitionParser&gt; parsers</code> 。</p>\n<p>注册后，命名空间处理器可以根据标签的不同来调用不同的解析器进行解析。那么根据上面函数与之前介绍过的例子，我们基本上可以推断getHandlerMappings的主要功能就是读取Spring.handlers配置文件并将配置文件缓存在map中。</p>\n<pre><code class=\"java\">private Map&lt;String, Object&gt; getHandlerMappings() {\n        Map&lt;String, Object&gt; handlerMappings = this.handlerMappings;\n        if (handlerMappings == null) {\n            synchronized (this) {\n                handlerMappings = this.handlerMappings;\n                if (handlerMappings == null) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(&quot;Loading NamespaceHandler mappings from [&quot;\n                                     + this.handlerMappingsLocation + &quot;]&quot;);\n                    }\n                    try {\n                        // handlerMappingsLocation 默认是META-INF/Spring.handlers\n                        Properties mappings =PropertiesLoaderUtils.loadAllProperties(\n                            this.handlerMappingsLocation, this.classLoader);\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(&quot;Loaded NamespaceHandler mappings: &quot;\n                                         + mappings);\n                        }\n                        handlerMappings = new ConcurrentHashMap&lt;&gt;(mappings.size());\n                        CollectionUtils.mergePropertiesIntoMap(mappings, \n                                                               handlerMappings);\n                        this.handlerMappings = handlerMappings;\n                    }\n                    catch (IOException ex) {\n                        throw new IllegalStateException(\n                        &quot;Unable to load NamespaceHandler mappings from location [&quot; \n                            + this.handlerMappingsLocation + &quot;]&quot;, ex);\n                    }\n                }\n            }\n        }\n        return handlerMappings;\n    }\n</code></pre>\n<p>同我们想的一样，借助了PropertiesLoaderUtils对属性handlerMappingsLocation进行了配置文件的读取，handlerMappingLocation被默认初始化为<code>META-INF/Spring.handlers</code></p>\n<p>上面完整的分析了根据 namespaceUri 获取相应的 NamespaceHandler 对象，然后调用其 <code>parse()</code> 方法开始自定义标签的解析，如下：</p>\n<pre><code class=\"java\">    public BeanDefinition parse(Element element, ParserContext parserContext) {\n        BeanDefinitionParser parser = findParserForElement(element, parserContext);\n        return (parser != null ? parser.parse(element, parserContext) : null);\n    }\n</code></pre>\n<p>调用 <code>findParserForElement()</code> 方法获取 BeanDefinitionParser 实例，其实就是获取在 <code>init()</code> 方法里面注册的实例对象。如下：</p>\n<pre><code class=\"java\">    private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {\n        String localName = parserContext.getDelegate().getLocalName(element);\n        BeanDefinitionParser parser = this.parsers.get(localName);\n        if (parser == null) {\n            parserContext.getReaderContext().fatal(\n                    &quot;Cannot locate BeanDefinitionParser for element [&quot; + localName\n                        + &quot;]&quot;, element);\n        }\n        return parser;\n    }\n</code></pre>\n<p>获取 localName，在上面的例子中就是 ： user，然后从 Map 实例 parsers 中获取 BeanDefinitionParser 对象。返回 BeanDefinitionParser 对象后，调用其 <code>parse()</code>，该方法在 AbstractBeanDefinitionParser 中实现：</p>\n<pre><code class=\"java\">    public final BeanDefinition parse(Element element, ParserContext parserContext) {\n        AbstractBeanDefinition definition = parseInternal(element, parserContext);\n        if (definition != null &amp;&amp; !parserContext.isNested()) {\n            try {\n                String id = resolveId(element, definition, parserContext);\n                if (!StringUtils.hasText(id)) {\n                    parserContext.getReaderContext().error(\n                            &quot;Id is required for element &#39;&quot; + \n                        parserContext.getDelegate().getLocalName(element)\n                                    + &quot;&#39; when used as a top-level tag&quot;, element);\n                }\n                String[] aliases = null;\n                if (shouldParseNameAsAliases()) {\n                    String name = element.getAttribute(NAME_ATTRIBUTE);\n                    if (StringUtils.hasLength(name)) {\n                        aliases = StringUtils.trimArrayElements\n                            (StringUtils.commaDelimitedListToStringArray(name));\n                    }\n                }\n                BeanDefinitionHolder holder = \n                    new BeanDefinitionHolder(definition, id, aliases);\n                registerBeanDefinition(holder, parserContext.getRegistry());\n                if (shouldFireEvents()) {\n                    BeanComponentDefinition componentDefinition =\n                        new BeanComponentDefinition(holder);\n                    postProcessComponentDefinition(componentDefinition);\n                    parserContext.registerComponent(componentDefinition);\n                }\n            }\n            catch (BeanDefinitionStoreException ex) {\n                String msg = ex.getMessage();\n                parserContext.getReaderContext().error((msg != null ? msg : \n                                                        ex.toString()), element);\n                return null;\n            }\n        }\n        return definition;\n    }\n</code></pre>\n<p>核心在方法 <code>parseInternal()</code> 为什么这么说，以为该方法返回的是 AbstractBeanDefinition 对象，从前面默认标签的解析工作中我们就可以判断该方法就是将标签解析为 AbstractBeanDefinition ，且后续代码都是将 AbstractBeanDefinition 转换为 BeanDefinitionHolder，所以真正的解析工作都交由 <code>parseInternal()</code> 实现，如下：</p>\n<pre><code class=\"java\">    protected final AbstractBeanDefinition parseInternal(Element element,\n                                                         ParserContext parserContext) {\n        // 获取\n        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition();\n\n        // 获取父类元素\n        String parentName = getParentName(element);\n        if (parentName != null) {\n            builder.getRawBeanDefinition().setParentName(parentName);\n        }\n\n        // 获取自定义标签中的 class，这个时候会去调用自定义解析中的 getBeanClass()\n        Class&lt;?&gt; beanClass = getBeanClass(element);\n        if (beanClass != null) {\n            builder.getRawBeanDefinition().setBeanClass(beanClass);\n        }\n        else {\n            // beanClass 为 null，意味着子类并没有重写 getBeanClass() 方法，\n            // 则尝试去判断是否重写了 getBeanClassName()\n            String beanClassName = getBeanClassName(element);\n            if (beanClassName != null) {\n                builder.getRawBeanDefinition().setBeanClassName(beanClassName);\n            }\n        }\n        builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));\n        BeanDefinition containingBd = parserContext.getContainingBeanDefinition();\n        if (containingBd != null) {\n            // Inner bean definition must receive same scope as containing bean.\n            builder.setScope(containingBd.getScope());\n        }\n        if (parserContext.isDefaultLazyInit()) {\n            // Default-lazy-init applies to custom bean definitions as well.\n            builder.setLazyInit(true);\n        }\n\n        // 调用子类的 doParse() 进行解析\n        doParse(element, parserContext, builder);\n        return builder.getBeanDefinition();\n    }\n</code></pre>\n<p>在该方法中我们主要关注两个方法：<code>getBeanClass()</code> 、<code>doParse()</code>。对于 <code>getBeanClass()</code> 方法，AbstractSingleBeanDefinitionParser 类并没有提供具体实现，而是直接返回 null，意味着它希望子类能够重写该方法，当然如果没有重写该方法，这会去调用 <code>getBeanClassName()</code> ，判断子类是否已经重写了该方法。对于 <code>doParse()</code> 则是直接空实现。所以对于 <code>parseInternal()</code> 而言它总是期待它的子类能够实现 <code>getBeanClass()</code>、<code>doParse()</code>，其中 <code>doParse()</code> 尤为重要，如果你不提供实现，怎么来解析自定义标签呢？最后将自定义的解析器：UserDefinitionParser 再次回观。</p>\n<pre><code class=\"java\">public class UserDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\n    @Override\n    protected Class&lt;?&gt; getBeanClass(Element element) {\n        return User.class;\n    }\n    @Override\n    protected void doParse(Element element, BeanDefinitionBuilder builder) {\n        String id = element.getAttribute(&quot;id&quot;);\n        String userName=element.getAttribute(&quot;userName&quot;);\n        String email=element.getAttribute(&quot;email&quot;);\n        if(StringUtils.hasText(id)){\n            builder.addPropertyValue(&quot;id&quot;,id);\n        }\n        if(StringUtils.hasText(userName)){\n            builder.addPropertyValue(&quot;userName&quot;, userName);\n        }\n        if(StringUtils.hasText(email)){\n            builder.addPropertyValue(&quot;email&quot;, email);\n        }\n\n    }\n}\n</code></pre>\n<p>至此，自定义标签的解析过程已经分析完成了。其实整个过程还是较为简单：首先会加载 handlers 文件，将其中内容进行一个解析，形成 <code>&lt;namespaceUri,类路径&gt;</code>这样的一个映射，然后根据获取的 namespaceUri 就可以得到相应的类路径，对其进行初始化等到相应的 Handler 对象，调用 <code>parse()</code> 方法，在该方法中根据标签的 localName 得到相应的 BeanDefinitionParser 实例对象，调用 <code>parse()</code> ，该方法定义在 AbstractBeanDefinitionParser 抽象类中，核心逻辑封装在其 <code>parseInternal()</code> 中，该方法返回一个 AbstractBeanDefinition 实例对象，其主要是在 AbstractSingleBeanDefinitionParser 中实现，对于自定义的 Parser 类，其需要实现 <code>getBeanClass()</code> 或者 <code>getBeanClassName()</code> 和 <code>doParse()</code>。</p>\n<p>另外回顾一下整个自定义标签的处理过程，虽然示例中我们只定义了与我们逻辑相关的工作，类如<code>UserDefinitionParser</code>中我们只定义了getBeanClss和doParse俩个函数。但是其它的工作，类如创建BeanDefinition以及默认标签的设置，对于这些spring已经默认设置过了，为了方便我们实现知识暴露出一些个性化定义的接口，方便我们进行定制。</p>"},{"abbrlink":39,"title":"spring源码解析之 16 开启bean的加载","author":"fengxiutianya","date":"2019-01-14T19:30:00.000Z","_content":"# spring源码解析之 16 开启bean的加载\n\n### 概述\n\n1. spring Ioc功能简介\n2. spring 获取bean流程及源码分析\n\n### spring Ioc功能简介\n\n![upload successful](/images/pasted-12.png)\n\n(此图来自《Spring 揭秘》)\n\nSpring IOC 容器所起的作用如上图所示，它会以某种方式加载 Configuration Metadata，将其解析注册到容器内部，然后回根据这些信息绑定整个系统的对象，最终组装成一个可用的基于轻量级容器的应用系统。\n\nSpring 在实现上述功能中，将整个流程分为两个阶段：容器初始化阶段和加载bean 阶段。\n<!-- more -->\n\n- **容器初始化阶段**：首先通过某种方式加载 Configuration Metadata (主要是依据 Resource、ResourceLoader 两个体系)，然后容器会对加载的 Configuration MetaData 进行解析和分析，并将分析的信息组装成 BeanDefinition，并将其保存注册到相应的 BeanDefinitionRegistry 中。至此，Spring IOC 的初始化工作完成。\n- **加载 bean 阶段**：经过容器初始化阶段后，应用程序中定义的 bean 信息已经全部加载到系统中了，当我们显示或者隐式地调用 `getBean()` 时，则会触发加载 bean 阶段。在这阶段，容器会首先检查所请求的对象是否已经初始化完成了，如果没有，则会根据注册的 bean 信息实例化请求的对象，并为其注册依赖，然后将其返回给请求方。至此第二个阶段也已经完成。\n\n第一个阶段前面已经用了 10 多篇博客深入分析了（总结参考[初始化总结](taolove.top/posts/34/)）。所以从这篇开始分析第二个阶段：加载 bean 阶段。当我们显示或者隐式地调用 `getBean()` 时，则会触发加载 bean 阶段。如下：\n\n```java\n    public Object getBean(String name) throws BeansException {\n        return doGetBean(name, null, null, false);\n    }\n```\n\n内部调用 `doGetBean()` 方法，其接受四个参数：\n\n- name：要获取 bean 的名字\n- requiredType：要获取 bean 的类型\n- args：创建 bean 时传递的参数。这个参数仅限于创建 bean 时使用\n- typeCheckOnly：是否为类型检查\n\n下面我们对doGetBean进行分析\n\n### spring 获取bean流程及源码分析\n\n代码有点长，最好复制到编辑器中查看：\n\n```java\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n                    @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\n   // 转换beanName，前面我们已经说过，bean可以有别名，这里就是讲别名转换为beanName\n   final String beanName = transformedBeanName(name);\n   Object bean;\n   /**\n    * 检查缓存中或者实例工厂中是否有对应的实例\n    * 为什么首先会使用这段代码呢 ？\n    * 因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖\n    * spring创建bean的原则是不等bean创建完成就会创建bean的ObjectFactor提早曝光，\n    * （ObjectFactory用于产生对象，相当于一个创建特定对象的工厂） 也就是将ObjectFactory\n    * 加入到缓存中，一旦下个bean创建时候需要依赖上个bean则直接使用\n    * ObjectFactory：返回对应的object，也就是bean\n    *\n    */\n   // 直接尝试从缓存获取或者singletonFactories中的ObjectFactory中获取\n   // Eagerly check singleton cache for manually registered singletons.\n   Object sharedInstance = getSingleton(beanName);\n\n   if (sharedInstance != null && args == null) {\n      if (logger.isTraceEnabled()) {\n         if (isSingletonCurrentlyInCreation(beanName)) {\n            logger.trace(\"Returning eagerly cached instance of singleton bean '\" \n                         + beanName +\n                  \"' that is not fully initialized yet - \n                         a consequence of a circular reference\");\n         } else {\n            logger.trace(\"Returning cached instance of singleton bean '\" \n                         + beanName + \"'\");\n         }\n      }\n      // 返回对应的实例，有时候存在诸如FactoryBean的情况并不是直接返回实例本身\n      // 而是指定方法返回实例 对应这种情况是自定义了一些FactoryBean，本身就是一个bean\n      // 可以用来创建特定bean的工厂\n      // 还有是工厂bean中定义的factory-method方法返回bean\n      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n   } else {\n      /**\n       * 只有个在单例情况下才会尝试解决循环依赖，原型模式情况下，\n       * 如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，\n       * 就会产生当A还未创建完的时候因为B的创建在此返回创建A，造成\n       * 循环依赖，也就是下面这种情况\n       */\n      if (isPrototypeCurrentlyInCreation(beanName)) {\n         throw new BeanCurrentlyInCreationException(beanName);\n      }\n\n      // 如果beanDefinitionMap中也就是在所有已加载的类中不包括beanName\n      // 则会尝试从parentBeanFactory中检测\n      // Check if bean definition exists in this factory.\n      BeanFactory parentBeanFactory = getParentBeanFactory();\n      if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n         // 递归到BeanFactory中寻找\n         // Not found -> check parent.\n         String nameToLookup = originalBeanName(name);\n         if (parentBeanFactory instanceof AbstractBeanFactory) {\n            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                  nameToLookup, requiredType, args, typeCheckOnly);\n         } else if (args != null) {\n            // Delegation to parent with explicit args.\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n         } else if (requiredType != null) {\n            // No args -> delegate to standard getBean method.\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n         } else {\n            return (T) parentBeanFactory.getBean(nameToLookup);\n         }\n      }\n\n      // 如果不是仅仅做类型检查则是创建bean，这里要进行记录\n      if (!typeCheckOnly) {\n         markBeanAsCreated(beanName);\n      }\n\n      try {\n         // 将存储xml配置文件的GernericBeanDefinition转换为RootBeanDefinition\n         // 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n       \n          // 检查给定的合并的 BeanDefinition\n          checkMergedBeanDefinition(mbd, beanName, args);\n\n         // 若存在依赖则需要递归实例化依赖的bean\n         // Guarantee initialization of beans that the current bean depends on.\n         String[] dependsOn = mbd.getDependsOn();\n         if (dependsOn != null) {\n            for (String dep : dependsOn) {\n               if (isDependent(beanName, dep)) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), \n                                                  beanName,\n                        \"Circular depends-on relationship between '\" \n                                                  + beanName + \"' and '\" + dep + \"'\");\n               }\n               // 缓存依赖调用\n               registerDependentBean(dep, beanName);\n               try {\n                  getBean(dep);\n               } catch (NoSuchBeanDefinitionException ex) {\n                  throw new BeanCreationException(mbd.getResourceDescription(),\n                                                  beanName,\n                        \"'\" + beanName + \"' depends on missing bean '\" + dep + \"'\",\n                                                  ex);\n               }\n            }\n         }\n         // Create bean instance.\n         // 实例化依赖的bean后便可以实例化mbd本身所代表的bean\n         // singleton模式的创建\n         if (mbd.isSingleton()) {\n            sharedInstance = getSingleton(beanName, () -> {\n               try {\n                  return createBean(beanName, mbd, args);\n               } catch (BeansException ex) {\n\t\t\t\t// 显示从单例缓存中删除 bean 实例\n                // 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它\n                  destroySingleton(beanName);\n                  throw ex;\n               }\n            });\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n         } else if (mbd.isPrototype()) { \n             // prototype模式的创建\n\n            Object prototypeInstance = null;\n            try {\n               beforePrototypeCreation(beanName);\n               prototypeInstance = createBean(beanName, mbd, args);\n            } finally {\n               afterPrototypeCreation(beanName);\n            }\n            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n         } else {\n            // 指定的scope上实例化bean\n            String scopeName = mbd.getScope();\n            final Scope scope = this.scopes.get(scopeName);\n            if (scope == null) {\n               throw new IllegalStateException(\"No Scope registered for scope name '\"\n                                               + scopeName + \"'\");\n            }\n            try {\n               // 从指定的 scope 下创建 bean\n               Object scopedInstance = scope.get(beanName, () -> {\n                  beforePrototypeCreation(beanName);\n                  try {\n                     return createBean(beanName, mbd, args);\n                  } finally {\n                     afterPrototypeCreation(beanName);\n                  }\n               });\n               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n            } catch (IllegalStateException ex) {\n               throw new BeanCreationException(beanName,\n                     \"Scope '\" + scopeName + \"' is not active for the current thread;\n                                               consider \" \n                      +  \"defining a scoped proxy for this bean if you intend to refer\n                                               to it from a singleton\",  ex);\n            }\n         }\n      } catch (BeansException ex) {\n         cleanupAfterBeanCreationFailure(beanName);\n         throw ex;\n      }\n   }\n   // 检查需要的类型是否符合bean的实际类型\n   if (requiredType != null && !requiredType.isInstance(bean)) {\n      try {\n         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n         if (convertedBean == null) {\n            throw new BeanNotOfRequiredTypeException(name, requiredType, \n                                                     bean.getClass());\n         }\n         return convertedBean;\n      } catch (TypeMismatchException ex) {\n         if (logger.isTraceEnabled()) {\n            logger.trace(\"Failed to convert bean '\" + name + \"' to required type '\" +\n                  ClassUtils.getQualifiedName(requiredType) + \"'\", ex);\n         }\n         throw new BeanNotOfRequiredTypeException(name, requiredType, \n                                                  bean.getClass());\n      }\n   }\n   return (T) bean;\n}\n```\n\n上面的代码很长、逻辑也挺复杂，但是可以初略的看到spring加载bean的过程，下面对于整个加载过程进行总结。\n\n**1.获取 beanName**\n\n```java\nfinal String beanName = transformedBeanName(name);\n```\n\n这里传递的是 name，不一定就是 beanName，可能是 aliasName，也有可能是 FactoryBean，所以这里需要调用 `transformedBeanName()` 方法对 name 进行一番转换，主要如下：\n\n```java\n    protected String transformedBeanName(String name) {\n        return canonicalName(BeanFactoryUtils.transformedBeanName(name));\n    }\n\n    // 去除 FactoryBean 的修饰符\n    public static String transformedBeanName(String name) {\n        Assert.notNull(name, \"'name' must not be null\");\n        String beanName = name;\n        while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {\n            beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());\n        }\n        return beanName;\n    }\n\n    // 转换 aliasName\n    public String canonicalName(String name) {\n        String canonicalName = name;\n        // Handle aliasing...\n        String resolvedName;\n        do {\n            resolvedName = this.aliasMap.get(canonicalName);\n            if (resolvedName != null) {\n                canonicalName = resolvedName;\n            }\n        }while (resolvedName != null);\n        return canonicalName;\n    }\n```\n\n主要处理过程包括两步：\n\n1. 去除 FactoryBean 的修饰符。如果 name 以 “&” 为前缀，那么会去掉该 “&”，例如，`name = \"&studentService\"`，则会是 `name = \"studentService\"`。\n2. 取指定的 alias 所表示的最终 beanName。主要是一个循环获取 beanName 的过程，例如别名 A 指向名称为 B 的 bean 则返回 B，若 别名 A 指向别名 B，别名 B 指向名称为 C 的 bean，则返回 C。\n\n**2.从单例 bean 缓存中获取 bean**\n\n对应代码段如下：\n\n```java\n        Object sharedInstance = getSingleton(beanName);\n        if (sharedInstance != null && args == null) {\n            if (logger.isDebugEnabled()) {\n                if (isSingletonCurrentlyInCreation(beanName)) {\n                    logger.debug(\"Returning eagerly cached instance of singleton bean '\" + beanName +\n                            \"' that is not fully initialized yet - a consequence of a circular reference\");\n                }\n                else {\n                    logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n                }\n            }\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n        }\n```\n\n我们知道单例模式的 bean 在整个过程中只会被创建一次，第一次创建后会将该 bean 加载到缓存中，后面在获取 bean 就会直接从单例缓存中获取。如果从缓存中得到了 bean，则需要调用 `getObjectForBeanInstance()` 对 bean 进行实例化处理，因为缓存中记录的是最原始的 bean 状态，我们得到的不一定是我们最终想要的 bean。\n\n**3.原型模式依赖检查与 parentBeanFactory**\n\n对应代码段\n\n```java\n            if (isPrototypeCurrentlyInCreation(beanName)) {\n                throw new BeanCurrentlyInCreationException(beanName);\n            }\n\n            // Check if bean definition exists in this factory.\n            BeanFactory parentBeanFactory = getParentBeanFactory();\n            if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n                // Not found -> check parent.\n                String nameToLookup = originalBeanName(name);\n                if (parentBeanFactory instanceof AbstractBeanFactory) {\n                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                            nameToLookup, requiredType, args, typeCheckOnly);\n                }\n                else if (args != null) {\n                    // Delegation to parent with explicit args.\n                    return (T) parentBeanFactory.getBean(nameToLookup, args);\n                }\n                else {\n                    // No args -> delegate to standard getBean method.\n                    return parentBeanFactory.getBean(nameToLookup, requiredType);\n                }\n            }\n```\n\nSpring 只处理单例模式下得循环依赖，对于原型模式的循环依赖直接抛出异常。主要原因还是在于 Spring 解决循环依赖的策略有关。对于单例模式 Spring 在创建 bean 的时候并不是等 bean 完全创建完成后才会将 bean 添加至缓存中，而是不等 bean 创建完成就会将创建 bean 的 ObjectFactory 提早加入到缓存中，这样一旦下一个 bean 创建的时候需要依赖 bean 时则直接使用 ObjectFactroy。但是原型模式我们知道是没法使用缓存的，所以 Spring 对原型模式的循环依赖处理策略则是不处理（关于循环依赖后面会有单独文章说明）。\n\n如果容器缓存中没有相对应的 BeanDefinition 则会尝试从父类工厂（parentBeanFactory）中加载，然后再去递归调用 `getBean()`。\n\n**4. 将存储xml配置文件中的GenericBeanDefinition转换为RootBeanDefinition**\n\n前面也说过，从xml文件中获取读取到的bean信息是存储在GenericBeanDefinition中的，但是所有的bean后续处理都是针对于RootBeanDefinition的，所以这里需要进行一个转换，转的同时如果父类Bean不为空的话，则会合并父类的属性。\n\n**5. 依赖处理**\n\n对应源码如下：\n\n```java\n                String[] dependsOn = mbd.getDependsOn();\n                if (dependsOn != null) {\n                    for (String dep : dependsOn) {\n                        if (isDependent(beanName, dep)) {\n                            throw new \n                                BeanCreationException(mbd.getResourceDescription(), \n                                                            beanName,\n                                    \"Circular depends-on relationship between '\" \n                                       + beanName + \"' and '\" + dep + \"'\");\n                        }\n                        registerDependentBean(dep, beanName);\n                        try {\n                            getBean(dep);\n                        }\n                        catch (NoSuchBeanDefinitionException ex) {\n                            throw new \n                                BeanCreationException(mbd.getResourceDescription(), \n                                  beanName,\"'\" + beanName \n                                + \"' depends on missing bean '\" + dep + \"'\", ex);\n                        }\n                    }\n                }\n```\n\n每个 bean 都不是单独工作的，它会依赖其他 bean，其他 bean 也会依赖它，对于依赖的 bean ，它会优先加载，所以在 Spring 的加载顺序中，在初始化某一个 bean 的时候首先会初始化这个 bean 的依赖。\n\n**6 作用域处理**\n\nSpring bean 的作用域默认为 singleton，当然还有其他作用域，如prototype、request、session 等，不同的作用域会有不同的初始化策略。\n\n**7 类型转换**\n\n在调用 `doGetBean()` 方法时，有一个 requiredType 参数，该参数的功能就是将返回的 bean 转换为 requiredType 类型。当然就一般而言我们是不需要进行类型转换的，也就是 requiredType 为空（比如 `getBean(String name)`），但有可能会存在这种情况，比如我们返回的 bean 类型为 String，我们在使用的时候需要将其转换为 Integer，那么这个时候 requiredType 就有用武之地了。当然我们一般是不需要这样做的。\n\n至此 `getBean()` 过程讲解完了。后续将会对该过程进行拆分，更加详细的说明，弄清楚其中的来龙去脉，所以这篇博客只能算是 Spring bean 加载过程的一个概览。","source":"_posts/spring 源码分析/spring/spring源码解析之 16开启bean的加载.md","raw":"abbrlink: 39\ntitle: spring源码解析之 16 开启bean的加载\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-15 03:30:00\n---\n# spring源码解析之 16 开启bean的加载\n\n### 概述\n\n1. spring Ioc功能简介\n2. spring 获取bean流程及源码分析\n\n### spring Ioc功能简介\n\n![upload successful](/images/pasted-12.png)\n\n(此图来自《Spring 揭秘》)\n\nSpring IOC 容器所起的作用如上图所示，它会以某种方式加载 Configuration Metadata，将其解析注册到容器内部，然后回根据这些信息绑定整个系统的对象，最终组装成一个可用的基于轻量级容器的应用系统。\n\nSpring 在实现上述功能中，将整个流程分为两个阶段：容器初始化阶段和加载bean 阶段。\n<!-- more -->\n\n- **容器初始化阶段**：首先通过某种方式加载 Configuration Metadata (主要是依据 Resource、ResourceLoader 两个体系)，然后容器会对加载的 Configuration MetaData 进行解析和分析，并将分析的信息组装成 BeanDefinition，并将其保存注册到相应的 BeanDefinitionRegistry 中。至此，Spring IOC 的初始化工作完成。\n- **加载 bean 阶段**：经过容器初始化阶段后，应用程序中定义的 bean 信息已经全部加载到系统中了，当我们显示或者隐式地调用 `getBean()` 时，则会触发加载 bean 阶段。在这阶段，容器会首先检查所请求的对象是否已经初始化完成了，如果没有，则会根据注册的 bean 信息实例化请求的对象，并为其注册依赖，然后将其返回给请求方。至此第二个阶段也已经完成。\n\n第一个阶段前面已经用了 10 多篇博客深入分析了（总结参考[初始化总结](taolove.top/posts/34/)）。所以从这篇开始分析第二个阶段：加载 bean 阶段。当我们显示或者隐式地调用 `getBean()` 时，则会触发加载 bean 阶段。如下：\n\n```java\n    public Object getBean(String name) throws BeansException {\n        return doGetBean(name, null, null, false);\n    }\n```\n\n内部调用 `doGetBean()` 方法，其接受四个参数：\n\n- name：要获取 bean 的名字\n- requiredType：要获取 bean 的类型\n- args：创建 bean 时传递的参数。这个参数仅限于创建 bean 时使用\n- typeCheckOnly：是否为类型检查\n\n下面我们对doGetBean进行分析\n\n### spring 获取bean流程及源码分析\n\n代码有点长，最好复制到编辑器中查看：\n\n```java\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n                    @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\n   // 转换beanName，前面我们已经说过，bean可以有别名，这里就是讲别名转换为beanName\n   final String beanName = transformedBeanName(name);\n   Object bean;\n   /**\n    * 检查缓存中或者实例工厂中是否有对应的实例\n    * 为什么首先会使用这段代码呢 ？\n    * 因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖\n    * spring创建bean的原则是不等bean创建完成就会创建bean的ObjectFactor提早曝光，\n    * （ObjectFactory用于产生对象，相当于一个创建特定对象的工厂） 也就是将ObjectFactory\n    * 加入到缓存中，一旦下个bean创建时候需要依赖上个bean则直接使用\n    * ObjectFactory：返回对应的object，也就是bean\n    *\n    */\n   // 直接尝试从缓存获取或者singletonFactories中的ObjectFactory中获取\n   // Eagerly check singleton cache for manually registered singletons.\n   Object sharedInstance = getSingleton(beanName);\n\n   if (sharedInstance != null && args == null) {\n      if (logger.isTraceEnabled()) {\n         if (isSingletonCurrentlyInCreation(beanName)) {\n            logger.trace(\"Returning eagerly cached instance of singleton bean '\" \n                         + beanName +\n                  \"' that is not fully initialized yet - \n                         a consequence of a circular reference\");\n         } else {\n            logger.trace(\"Returning cached instance of singleton bean '\" \n                         + beanName + \"'\");\n         }\n      }\n      // 返回对应的实例，有时候存在诸如FactoryBean的情况并不是直接返回实例本身\n      // 而是指定方法返回实例 对应这种情况是自定义了一些FactoryBean，本身就是一个bean\n      // 可以用来创建特定bean的工厂\n      // 还有是工厂bean中定义的factory-method方法返回bean\n      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n   } else {\n      /**\n       * 只有个在单例情况下才会尝试解决循环依赖，原型模式情况下，\n       * 如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，\n       * 就会产生当A还未创建完的时候因为B的创建在此返回创建A，造成\n       * 循环依赖，也就是下面这种情况\n       */\n      if (isPrototypeCurrentlyInCreation(beanName)) {\n         throw new BeanCurrentlyInCreationException(beanName);\n      }\n\n      // 如果beanDefinitionMap中也就是在所有已加载的类中不包括beanName\n      // 则会尝试从parentBeanFactory中检测\n      // Check if bean definition exists in this factory.\n      BeanFactory parentBeanFactory = getParentBeanFactory();\n      if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n         // 递归到BeanFactory中寻找\n         // Not found -> check parent.\n         String nameToLookup = originalBeanName(name);\n         if (parentBeanFactory instanceof AbstractBeanFactory) {\n            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                  nameToLookup, requiredType, args, typeCheckOnly);\n         } else if (args != null) {\n            // Delegation to parent with explicit args.\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n         } else if (requiredType != null) {\n            // No args -> delegate to standard getBean method.\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n         } else {\n            return (T) parentBeanFactory.getBean(nameToLookup);\n         }\n      }\n\n      // 如果不是仅仅做类型检查则是创建bean，这里要进行记录\n      if (!typeCheckOnly) {\n         markBeanAsCreated(beanName);\n      }\n\n      try {\n         // 将存储xml配置文件的GernericBeanDefinition转换为RootBeanDefinition\n         // 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n       \n          // 检查给定的合并的 BeanDefinition\n          checkMergedBeanDefinition(mbd, beanName, args);\n\n         // 若存在依赖则需要递归实例化依赖的bean\n         // Guarantee initialization of beans that the current bean depends on.\n         String[] dependsOn = mbd.getDependsOn();\n         if (dependsOn != null) {\n            for (String dep : dependsOn) {\n               if (isDependent(beanName, dep)) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), \n                                                  beanName,\n                        \"Circular depends-on relationship between '\" \n                                                  + beanName + \"' and '\" + dep + \"'\");\n               }\n               // 缓存依赖调用\n               registerDependentBean(dep, beanName);\n               try {\n                  getBean(dep);\n               } catch (NoSuchBeanDefinitionException ex) {\n                  throw new BeanCreationException(mbd.getResourceDescription(),\n                                                  beanName,\n                        \"'\" + beanName + \"' depends on missing bean '\" + dep + \"'\",\n                                                  ex);\n               }\n            }\n         }\n         // Create bean instance.\n         // 实例化依赖的bean后便可以实例化mbd本身所代表的bean\n         // singleton模式的创建\n         if (mbd.isSingleton()) {\n            sharedInstance = getSingleton(beanName, () -> {\n               try {\n                  return createBean(beanName, mbd, args);\n               } catch (BeansException ex) {\n\t\t\t\t// 显示从单例缓存中删除 bean 实例\n                // 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它\n                  destroySingleton(beanName);\n                  throw ex;\n               }\n            });\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n         } else if (mbd.isPrototype()) { \n             // prototype模式的创建\n\n            Object prototypeInstance = null;\n            try {\n               beforePrototypeCreation(beanName);\n               prototypeInstance = createBean(beanName, mbd, args);\n            } finally {\n               afterPrototypeCreation(beanName);\n            }\n            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n         } else {\n            // 指定的scope上实例化bean\n            String scopeName = mbd.getScope();\n            final Scope scope = this.scopes.get(scopeName);\n            if (scope == null) {\n               throw new IllegalStateException(\"No Scope registered for scope name '\"\n                                               + scopeName + \"'\");\n            }\n            try {\n               // 从指定的 scope 下创建 bean\n               Object scopedInstance = scope.get(beanName, () -> {\n                  beforePrototypeCreation(beanName);\n                  try {\n                     return createBean(beanName, mbd, args);\n                  } finally {\n                     afterPrototypeCreation(beanName);\n                  }\n               });\n               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n            } catch (IllegalStateException ex) {\n               throw new BeanCreationException(beanName,\n                     \"Scope '\" + scopeName + \"' is not active for the current thread;\n                                               consider \" \n                      +  \"defining a scoped proxy for this bean if you intend to refer\n                                               to it from a singleton\",  ex);\n            }\n         }\n      } catch (BeansException ex) {\n         cleanupAfterBeanCreationFailure(beanName);\n         throw ex;\n      }\n   }\n   // 检查需要的类型是否符合bean的实际类型\n   if (requiredType != null && !requiredType.isInstance(bean)) {\n      try {\n         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n         if (convertedBean == null) {\n            throw new BeanNotOfRequiredTypeException(name, requiredType, \n                                                     bean.getClass());\n         }\n         return convertedBean;\n      } catch (TypeMismatchException ex) {\n         if (logger.isTraceEnabled()) {\n            logger.trace(\"Failed to convert bean '\" + name + \"' to required type '\" +\n                  ClassUtils.getQualifiedName(requiredType) + \"'\", ex);\n         }\n         throw new BeanNotOfRequiredTypeException(name, requiredType, \n                                                  bean.getClass());\n      }\n   }\n   return (T) bean;\n}\n```\n\n上面的代码很长、逻辑也挺复杂，但是可以初略的看到spring加载bean的过程，下面对于整个加载过程进行总结。\n\n**1.获取 beanName**\n\n```java\nfinal String beanName = transformedBeanName(name);\n```\n\n这里传递的是 name，不一定就是 beanName，可能是 aliasName，也有可能是 FactoryBean，所以这里需要调用 `transformedBeanName()` 方法对 name 进行一番转换，主要如下：\n\n```java\n    protected String transformedBeanName(String name) {\n        return canonicalName(BeanFactoryUtils.transformedBeanName(name));\n    }\n\n    // 去除 FactoryBean 的修饰符\n    public static String transformedBeanName(String name) {\n        Assert.notNull(name, \"'name' must not be null\");\n        String beanName = name;\n        while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {\n            beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());\n        }\n        return beanName;\n    }\n\n    // 转换 aliasName\n    public String canonicalName(String name) {\n        String canonicalName = name;\n        // Handle aliasing...\n        String resolvedName;\n        do {\n            resolvedName = this.aliasMap.get(canonicalName);\n            if (resolvedName != null) {\n                canonicalName = resolvedName;\n            }\n        }while (resolvedName != null);\n        return canonicalName;\n    }\n```\n\n主要处理过程包括两步：\n\n1. 去除 FactoryBean 的修饰符。如果 name 以 “&” 为前缀，那么会去掉该 “&”，例如，`name = \"&studentService\"`，则会是 `name = \"studentService\"`。\n2. 取指定的 alias 所表示的最终 beanName。主要是一个循环获取 beanName 的过程，例如别名 A 指向名称为 B 的 bean 则返回 B，若 别名 A 指向别名 B，别名 B 指向名称为 C 的 bean，则返回 C。\n\n**2.从单例 bean 缓存中获取 bean**\n\n对应代码段如下：\n\n```java\n        Object sharedInstance = getSingleton(beanName);\n        if (sharedInstance != null && args == null) {\n            if (logger.isDebugEnabled()) {\n                if (isSingletonCurrentlyInCreation(beanName)) {\n                    logger.debug(\"Returning eagerly cached instance of singleton bean '\" + beanName +\n                            \"' that is not fully initialized yet - a consequence of a circular reference\");\n                }\n                else {\n                    logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n                }\n            }\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n        }\n```\n\n我们知道单例模式的 bean 在整个过程中只会被创建一次，第一次创建后会将该 bean 加载到缓存中，后面在获取 bean 就会直接从单例缓存中获取。如果从缓存中得到了 bean，则需要调用 `getObjectForBeanInstance()` 对 bean 进行实例化处理，因为缓存中记录的是最原始的 bean 状态，我们得到的不一定是我们最终想要的 bean。\n\n**3.原型模式依赖检查与 parentBeanFactory**\n\n对应代码段\n\n```java\n            if (isPrototypeCurrentlyInCreation(beanName)) {\n                throw new BeanCurrentlyInCreationException(beanName);\n            }\n\n            // Check if bean definition exists in this factory.\n            BeanFactory parentBeanFactory = getParentBeanFactory();\n            if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n                // Not found -> check parent.\n                String nameToLookup = originalBeanName(name);\n                if (parentBeanFactory instanceof AbstractBeanFactory) {\n                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                            nameToLookup, requiredType, args, typeCheckOnly);\n                }\n                else if (args != null) {\n                    // Delegation to parent with explicit args.\n                    return (T) parentBeanFactory.getBean(nameToLookup, args);\n                }\n                else {\n                    // No args -> delegate to standard getBean method.\n                    return parentBeanFactory.getBean(nameToLookup, requiredType);\n                }\n            }\n```\n\nSpring 只处理单例模式下得循环依赖，对于原型模式的循环依赖直接抛出异常。主要原因还是在于 Spring 解决循环依赖的策略有关。对于单例模式 Spring 在创建 bean 的时候并不是等 bean 完全创建完成后才会将 bean 添加至缓存中，而是不等 bean 创建完成就会将创建 bean 的 ObjectFactory 提早加入到缓存中，这样一旦下一个 bean 创建的时候需要依赖 bean 时则直接使用 ObjectFactroy。但是原型模式我们知道是没法使用缓存的，所以 Spring 对原型模式的循环依赖处理策略则是不处理（关于循环依赖后面会有单独文章说明）。\n\n如果容器缓存中没有相对应的 BeanDefinition 则会尝试从父类工厂（parentBeanFactory）中加载，然后再去递归调用 `getBean()`。\n\n**4. 将存储xml配置文件中的GenericBeanDefinition转换为RootBeanDefinition**\n\n前面也说过，从xml文件中获取读取到的bean信息是存储在GenericBeanDefinition中的，但是所有的bean后续处理都是针对于RootBeanDefinition的，所以这里需要进行一个转换，转的同时如果父类Bean不为空的话，则会合并父类的属性。\n\n**5. 依赖处理**\n\n对应源码如下：\n\n```java\n                String[] dependsOn = mbd.getDependsOn();\n                if (dependsOn != null) {\n                    for (String dep : dependsOn) {\n                        if (isDependent(beanName, dep)) {\n                            throw new \n                                BeanCreationException(mbd.getResourceDescription(), \n                                                            beanName,\n                                    \"Circular depends-on relationship between '\" \n                                       + beanName + \"' and '\" + dep + \"'\");\n                        }\n                        registerDependentBean(dep, beanName);\n                        try {\n                            getBean(dep);\n                        }\n                        catch (NoSuchBeanDefinitionException ex) {\n                            throw new \n                                BeanCreationException(mbd.getResourceDescription(), \n                                  beanName,\"'\" + beanName \n                                + \"' depends on missing bean '\" + dep + \"'\", ex);\n                        }\n                    }\n                }\n```\n\n每个 bean 都不是单独工作的，它会依赖其他 bean，其他 bean 也会依赖它，对于依赖的 bean ，它会优先加载，所以在 Spring 的加载顺序中，在初始化某一个 bean 的时候首先会初始化这个 bean 的依赖。\n\n**6 作用域处理**\n\nSpring bean 的作用域默认为 singleton，当然还有其他作用域，如prototype、request、session 等，不同的作用域会有不同的初始化策略。\n\n**7 类型转换**\n\n在调用 `doGetBean()` 方法时，有一个 requiredType 参数，该参数的功能就是将返回的 bean 转换为 requiredType 类型。当然就一般而言我们是不需要进行类型转换的，也就是 requiredType 为空（比如 `getBean(String name)`），但有可能会存在这种情况，比如我们返回的 bean 类型为 String，我们在使用的时候需要将其转换为 Integer，那么这个时候 requiredType 就有用武之地了。当然我们一般是不需要这样做的。\n\n至此 `getBean()` 过程讲解完了。后续将会对该过程进行拆分，更加详细的说明，弄清楚其中的来龙去脉，所以这篇博客只能算是 Spring bean 加载过程的一个概览。","slug":"spring 源码分析/spring/spring源码解析之 16开启bean的加载","published":1,"updated":"2019-01-15T03:40:57.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovx7005h9q1u9h42psnh","content":"<h1 id=\"spring源码解析之-16-开启bean的加载\"><a href=\"#spring源码解析之-16-开启bean的加载\" class=\"headerlink\" title=\"spring源码解析之 16 开启bean的加载\"></a>spring源码解析之 16 开启bean的加载</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>spring Ioc功能简介</li>\n<li>spring 获取bean流程及源码分析</li>\n</ol>\n<h3 id=\"spring-Ioc功能简介\"><a href=\"#spring-Ioc功能简介\" class=\"headerlink\" title=\"spring Ioc功能简介\"></a>spring Ioc功能简介</h3><p><img src=\"/images/pasted-12.png\" alt=\"upload successful\"></p>\n<p>(此图来自《Spring 揭秘》)</p>\n<p>Spring IOC 容器所起的作用如上图所示，它会以某种方式加载 Configuration Metadata，将其解析注册到容器内部，然后回根据这些信息绑定整个系统的对象，最终组装成一个可用的基于轻量级容器的应用系统。</p>\n<p>Spring 在实现上述功能中，将整个流程分为两个阶段：容器初始化阶段和加载bean 阶段。<br><a id=\"more\"></a></p>\n<ul>\n<li><strong>容器初始化阶段</strong>：首先通过某种方式加载 Configuration Metadata (主要是依据 Resource、ResourceLoader 两个体系)，然后容器会对加载的 Configuration MetaData 进行解析和分析，并将分析的信息组装成 BeanDefinition，并将其保存注册到相应的 BeanDefinitionRegistry 中。至此，Spring IOC 的初始化工作完成。</li>\n<li><strong>加载 bean 阶段</strong>：经过容器初始化阶段后，应用程序中定义的 bean 信息已经全部加载到系统中了，当我们显示或者隐式地调用 <code>getBean()</code> 时，则会触发加载 bean 阶段。在这阶段，容器会首先检查所请求的对象是否已经初始化完成了，如果没有，则会根据注册的 bean 信息实例化请求的对象，并为其注册依赖，然后将其返回给请求方。至此第二个阶段也已经完成。</li>\n</ul>\n<p>第一个阶段前面已经用了 10 多篇博客深入分析了（总结参考<a href=\"taolove.top/posts/34/\">初始化总结</a>）。所以从这篇开始分析第二个阶段：加载 bean 阶段。当我们显示或者隐式地调用 <code>getBean()</code> 时，则会触发加载 bean 阶段。如下：</p>\n<pre><code class=\"java\">    public Object getBean(String name) throws BeansException {\n        return doGetBean(name, null, null, false);\n    }\n</code></pre>\n<p>内部调用 <code>doGetBean()</code> 方法，其接受四个参数：</p>\n<ul>\n<li>name：要获取 bean 的名字</li>\n<li>requiredType：要获取 bean 的类型</li>\n<li>args：创建 bean 时传递的参数。这个参数仅限于创建 bean 时使用</li>\n<li>typeCheckOnly：是否为类型检查</li>\n</ul>\n<p>下面我们对doGetBean进行分析</p>\n<h3 id=\"spring-获取bean流程及源码分析\"><a href=\"#spring-获取bean流程及源码分析\" class=\"headerlink\" title=\"spring 获取bean流程及源码分析\"></a>spring 获取bean流程及源码分析</h3><p>代码有点长，最好复制到编辑器中查看：</p>\n<pre><code class=\"java\">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,\n                    @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\n   // 转换beanName，前面我们已经说过，bean可以有别名，这里就是讲别名转换为beanName\n   final String beanName = transformedBeanName(name);\n   Object bean;\n   /**\n    * 检查缓存中或者实例工厂中是否有对应的实例\n    * 为什么首先会使用这段代码呢 ？\n    * 因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖\n    * spring创建bean的原则是不等bean创建完成就会创建bean的ObjectFactor提早曝光，\n    * （ObjectFactory用于产生对象，相当于一个创建特定对象的工厂） 也就是将ObjectFactory\n    * 加入到缓存中，一旦下个bean创建时候需要依赖上个bean则直接使用\n    * ObjectFactory：返回对应的object，也就是bean\n    *\n    */\n   // 直接尝试从缓存获取或者singletonFactories中的ObjectFactory中获取\n   // Eagerly check singleton cache for manually registered singletons.\n   Object sharedInstance = getSingleton(beanName);\n\n   if (sharedInstance != null &amp;&amp; args == null) {\n      if (logger.isTraceEnabled()) {\n         if (isSingletonCurrentlyInCreation(beanName)) {\n            logger.trace(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; \n                         + beanName +\n                  &quot;&#39; that is not fully initialized yet - \n                         a consequence of a circular reference&quot;);\n         } else {\n            logger.trace(&quot;Returning cached instance of singleton bean &#39;&quot; \n                         + beanName + &quot;&#39;&quot;);\n         }\n      }\n      // 返回对应的实例，有时候存在诸如FactoryBean的情况并不是直接返回实例本身\n      // 而是指定方法返回实例 对应这种情况是自定义了一些FactoryBean，本身就是一个bean\n      // 可以用来创建特定bean的工厂\n      // 还有是工厂bean中定义的factory-method方法返回bean\n      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n   } else {\n      /**\n       * 只有个在单例情况下才会尝试解决循环依赖，原型模式情况下，\n       * 如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，\n       * 就会产生当A还未创建完的时候因为B的创建在此返回创建A，造成\n       * 循环依赖，也就是下面这种情况\n       */\n      if (isPrototypeCurrentlyInCreation(beanName)) {\n         throw new BeanCurrentlyInCreationException(beanName);\n      }\n\n      // 如果beanDefinitionMap中也就是在所有已加载的类中不包括beanName\n      // 则会尝试从parentBeanFactory中检测\n      // Check if bean definition exists in this factory.\n      BeanFactory parentBeanFactory = getParentBeanFactory();\n      if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n         // 递归到BeanFactory中寻找\n         // Not found -&gt; check parent.\n         String nameToLookup = originalBeanName(name);\n         if (parentBeanFactory instanceof AbstractBeanFactory) {\n            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                  nameToLookup, requiredType, args, typeCheckOnly);\n         } else if (args != null) {\n            // Delegation to parent with explicit args.\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n         } else if (requiredType != null) {\n            // No args -&gt; delegate to standard getBean method.\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n         } else {\n            return (T) parentBeanFactory.getBean(nameToLookup);\n         }\n      }\n\n      // 如果不是仅仅做类型检查则是创建bean，这里要进行记录\n      if (!typeCheckOnly) {\n         markBeanAsCreated(beanName);\n      }\n\n      try {\n         // 将存储xml配置文件的GernericBeanDefinition转换为RootBeanDefinition\n         // 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\n          // 检查给定的合并的 BeanDefinition\n          checkMergedBeanDefinition(mbd, beanName, args);\n\n         // 若存在依赖则需要递归实例化依赖的bean\n         // Guarantee initialization of beans that the current bean depends on.\n         String[] dependsOn = mbd.getDependsOn();\n         if (dependsOn != null) {\n            for (String dep : dependsOn) {\n               if (isDependent(beanName, dep)) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), \n                                                  beanName,\n                        &quot;Circular depends-on relationship between &#39;&quot; \n                                                  + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);\n               }\n               // 缓存依赖调用\n               registerDependentBean(dep, beanName);\n               try {\n                  getBean(dep);\n               } catch (NoSuchBeanDefinitionException ex) {\n                  throw new BeanCreationException(mbd.getResourceDescription(),\n                                                  beanName,\n                        &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;,\n                                                  ex);\n               }\n            }\n         }\n         // Create bean instance.\n         // 实例化依赖的bean后便可以实例化mbd本身所代表的bean\n         // singleton模式的创建\n         if (mbd.isSingleton()) {\n            sharedInstance = getSingleton(beanName, () -&gt; {\n               try {\n                  return createBean(beanName, mbd, args);\n               } catch (BeansException ex) {\n                // 显示从单例缓存中删除 bean 实例\n                // 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它\n                  destroySingleton(beanName);\n                  throw ex;\n               }\n            });\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n         } else if (mbd.isPrototype()) { \n             // prototype模式的创建\n\n            Object prototypeInstance = null;\n            try {\n               beforePrototypeCreation(beanName);\n               prototypeInstance = createBean(beanName, mbd, args);\n            } finally {\n               afterPrototypeCreation(beanName);\n            }\n            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n         } else {\n            // 指定的scope上实例化bean\n            String scopeName = mbd.getScope();\n            final Scope scope = this.scopes.get(scopeName);\n            if (scope == null) {\n               throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot;\n                                               + scopeName + &quot;&#39;&quot;);\n            }\n            try {\n               // 从指定的 scope 下创建 bean\n               Object scopedInstance = scope.get(beanName, () -&gt; {\n                  beforePrototypeCreation(beanName);\n                  try {\n                     return createBean(beanName, mbd, args);\n                  } finally {\n                     afterPrototypeCreation(beanName);\n                  }\n               });\n               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n            } catch (IllegalStateException ex) {\n               throw new BeanCreationException(beanName,\n                     &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread;\n                                               consider &quot; \n                      +  &quot;defining a scoped proxy for this bean if you intend to refer\n                                               to it from a singleton&quot;,  ex);\n            }\n         }\n      } catch (BeansException ex) {\n         cleanupAfterBeanCreationFailure(beanName);\n         throw ex;\n      }\n   }\n   // 检查需要的类型是否符合bean的实际类型\n   if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {\n      try {\n         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n         if (convertedBean == null) {\n            throw new BeanNotOfRequiredTypeException(name, requiredType, \n                                                     bean.getClass());\n         }\n         return convertedBean;\n      } catch (TypeMismatchException ex) {\n         if (logger.isTraceEnabled()) {\n            logger.trace(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +\n                  ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);\n         }\n         throw new BeanNotOfRequiredTypeException(name, requiredType, \n                                                  bean.getClass());\n      }\n   }\n   return (T) bean;\n}\n</code></pre>\n<p>上面的代码很长、逻辑也挺复杂，但是可以初略的看到spring加载bean的过程，下面对于整个加载过程进行总结。</p>\n<p><strong>1.获取 beanName</strong></p>\n<pre><code class=\"java\">final String beanName = transformedBeanName(name);\n</code></pre>\n<p>这里传递的是 name，不一定就是 beanName，可能是 aliasName，也有可能是 FactoryBean，所以这里需要调用 <code>transformedBeanName()</code> 方法对 name 进行一番转换，主要如下：</p>\n<pre><code class=\"java\">    protected String transformedBeanName(String name) {\n        return canonicalName(BeanFactoryUtils.transformedBeanName(name));\n    }\n\n    // 去除 FactoryBean 的修饰符\n    public static String transformedBeanName(String name) {\n        Assert.notNull(name, &quot;&#39;name&#39; must not be null&quot;);\n        String beanName = name;\n        while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {\n            beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());\n        }\n        return beanName;\n    }\n\n    // 转换 aliasName\n    public String canonicalName(String name) {\n        String canonicalName = name;\n        // Handle aliasing...\n        String resolvedName;\n        do {\n            resolvedName = this.aliasMap.get(canonicalName);\n            if (resolvedName != null) {\n                canonicalName = resolvedName;\n            }\n        }while (resolvedName != null);\n        return canonicalName;\n    }\n</code></pre>\n<p>主要处理过程包括两步：</p>\n<ol>\n<li>去除 FactoryBean 的修饰符。如果 name 以 “&amp;” 为前缀，那么会去掉该 “&amp;”，例如，<code>name = &quot;&amp;studentService&quot;</code>，则会是 <code>name = &quot;studentService&quot;</code>。</li>\n<li>取指定的 alias 所表示的最终 beanName。主要是一个循环获取 beanName 的过程，例如别名 A 指向名称为 B 的 bean 则返回 B，若 别名 A 指向别名 B，别名 B 指向名称为 C 的 bean，则返回 C。</li>\n</ol>\n<p><strong>2.从单例 bean 缓存中获取 bean</strong></p>\n<p>对应代码段如下：</p>\n<pre><code class=\"java\">        Object sharedInstance = getSingleton(beanName);\n        if (sharedInstance != null &amp;&amp; args == null) {\n            if (logger.isDebugEnabled()) {\n                if (isSingletonCurrentlyInCreation(beanName)) {\n                    logger.debug(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +\n                            &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);\n                }\n                else {\n                    logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n                }\n            }\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n        }\n</code></pre>\n<p>我们知道单例模式的 bean 在整个过程中只会被创建一次，第一次创建后会将该 bean 加载到缓存中，后面在获取 bean 就会直接从单例缓存中获取。如果从缓存中得到了 bean，则需要调用 <code>getObjectForBeanInstance()</code> 对 bean 进行实例化处理，因为缓存中记录的是最原始的 bean 状态，我们得到的不一定是我们最终想要的 bean。</p>\n<p><strong>3.原型模式依赖检查与 parentBeanFactory</strong></p>\n<p>对应代码段</p>\n<pre><code class=\"java\">            if (isPrototypeCurrentlyInCreation(beanName)) {\n                throw new BeanCurrentlyInCreationException(beanName);\n            }\n\n            // Check if bean definition exists in this factory.\n            BeanFactory parentBeanFactory = getParentBeanFactory();\n            if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n                // Not found -&gt; check parent.\n                String nameToLookup = originalBeanName(name);\n                if (parentBeanFactory instanceof AbstractBeanFactory) {\n                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                            nameToLookup, requiredType, args, typeCheckOnly);\n                }\n                else if (args != null) {\n                    // Delegation to parent with explicit args.\n                    return (T) parentBeanFactory.getBean(nameToLookup, args);\n                }\n                else {\n                    // No args -&gt; delegate to standard getBean method.\n                    return parentBeanFactory.getBean(nameToLookup, requiredType);\n                }\n            }\n</code></pre>\n<p>Spring 只处理单例模式下得循环依赖，对于原型模式的循环依赖直接抛出异常。主要原因还是在于 Spring 解决循环依赖的策略有关。对于单例模式 Spring 在创建 bean 的时候并不是等 bean 完全创建完成后才会将 bean 添加至缓存中，而是不等 bean 创建完成就会将创建 bean 的 ObjectFactory 提早加入到缓存中，这样一旦下一个 bean 创建的时候需要依赖 bean 时则直接使用 ObjectFactroy。但是原型模式我们知道是没法使用缓存的，所以 Spring 对原型模式的循环依赖处理策略则是不处理（关于循环依赖后面会有单独文章说明）。</p>\n<p>如果容器缓存中没有相对应的 BeanDefinition 则会尝试从父类工厂（parentBeanFactory）中加载，然后再去递归调用 <code>getBean()</code>。</p>\n<p><strong>4. 将存储xml配置文件中的GenericBeanDefinition转换为RootBeanDefinition</strong></p>\n<p>前面也说过，从xml文件中获取读取到的bean信息是存储在GenericBeanDefinition中的，但是所有的bean后续处理都是针对于RootBeanDefinition的，所以这里需要进行一个转换，转的同时如果父类Bean不为空的话，则会合并父类的属性。</p>\n<p><strong>5. 依赖处理</strong></p>\n<p>对应源码如下：</p>\n<pre><code class=\"java\">                String[] dependsOn = mbd.getDependsOn();\n                if (dependsOn != null) {\n                    for (String dep : dependsOn) {\n                        if (isDependent(beanName, dep)) {\n                            throw new \n                                BeanCreationException(mbd.getResourceDescription(), \n                                                            beanName,\n                                    &quot;Circular depends-on relationship between &#39;&quot; \n                                       + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);\n                        }\n                        registerDependentBean(dep, beanName);\n                        try {\n                            getBean(dep);\n                        }\n                        catch (NoSuchBeanDefinitionException ex) {\n                            throw new \n                                BeanCreationException(mbd.getResourceDescription(), \n                                  beanName,&quot;&#39;&quot; + beanName \n                                + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);\n                        }\n                    }\n                }\n</code></pre>\n<p>每个 bean 都不是单独工作的，它会依赖其他 bean，其他 bean 也会依赖它，对于依赖的 bean ，它会优先加载，所以在 Spring 的加载顺序中，在初始化某一个 bean 的时候首先会初始化这个 bean 的依赖。</p>\n<p><strong>6 作用域处理</strong></p>\n<p>Spring bean 的作用域默认为 singleton，当然还有其他作用域，如prototype、request、session 等，不同的作用域会有不同的初始化策略。</p>\n<p><strong>7 类型转换</strong></p>\n<p>在调用 <code>doGetBean()</code> 方法时，有一个 requiredType 参数，该参数的功能就是将返回的 bean 转换为 requiredType 类型。当然就一般而言我们是不需要进行类型转换的，也就是 requiredType 为空（比如 <code>getBean(String name)</code>），但有可能会存在这种情况，比如我们返回的 bean 类型为 String，我们在使用的时候需要将其转换为 Integer，那么这个时候 requiredType 就有用武之地了。当然我们一般是不需要这样做的。</p>\n<p>至此 <code>getBean()</code> 过程讲解完了。后续将会对该过程进行拆分，更加详细的说明，弄清楚其中的来龙去脉，所以这篇博客只能算是 Spring bean 加载过程的一个概览。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-16-开启bean的加载\"><a href=\"#spring源码解析之-16-开启bean的加载\" class=\"headerlink\" title=\"spring源码解析之 16 开启bean的加载\"></a>spring源码解析之 16 开启bean的加载</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>spring Ioc功能简介</li>\n<li>spring 获取bean流程及源码分析</li>\n</ol>\n<h3 id=\"spring-Ioc功能简介\"><a href=\"#spring-Ioc功能简介\" class=\"headerlink\" title=\"spring Ioc功能简介\"></a>spring Ioc功能简介</h3><p><img src=\"/images/pasted-12.png\" alt=\"upload successful\"></p>\n<p>(此图来自《Spring 揭秘》)</p>\n<p>Spring IOC 容器所起的作用如上图所示，它会以某种方式加载 Configuration Metadata，将其解析注册到容器内部，然后回根据这些信息绑定整个系统的对象，最终组装成一个可用的基于轻量级容器的应用系统。</p>\n<p>Spring 在实现上述功能中，将整个流程分为两个阶段：容器初始化阶段和加载bean 阶段。<br>","more":"</p>\n<ul>\n<li><strong>容器初始化阶段</strong>：首先通过某种方式加载 Configuration Metadata (主要是依据 Resource、ResourceLoader 两个体系)，然后容器会对加载的 Configuration MetaData 进行解析和分析，并将分析的信息组装成 BeanDefinition，并将其保存注册到相应的 BeanDefinitionRegistry 中。至此，Spring IOC 的初始化工作完成。</li>\n<li><strong>加载 bean 阶段</strong>：经过容器初始化阶段后，应用程序中定义的 bean 信息已经全部加载到系统中了，当我们显示或者隐式地调用 <code>getBean()</code> 时，则会触发加载 bean 阶段。在这阶段，容器会首先检查所请求的对象是否已经初始化完成了，如果没有，则会根据注册的 bean 信息实例化请求的对象，并为其注册依赖，然后将其返回给请求方。至此第二个阶段也已经完成。</li>\n</ul>\n<p>第一个阶段前面已经用了 10 多篇博客深入分析了（总结参考<a href=\"taolove.top/posts/34/\">初始化总结</a>）。所以从这篇开始分析第二个阶段：加载 bean 阶段。当我们显示或者隐式地调用 <code>getBean()</code> 时，则会触发加载 bean 阶段。如下：</p>\n<pre><code class=\"java\">    public Object getBean(String name) throws BeansException {\n        return doGetBean(name, null, null, false);\n    }\n</code></pre>\n<p>内部调用 <code>doGetBean()</code> 方法，其接受四个参数：</p>\n<ul>\n<li>name：要获取 bean 的名字</li>\n<li>requiredType：要获取 bean 的类型</li>\n<li>args：创建 bean 时传递的参数。这个参数仅限于创建 bean 时使用</li>\n<li>typeCheckOnly：是否为类型检查</li>\n</ul>\n<p>下面我们对doGetBean进行分析</p>\n<h3 id=\"spring-获取bean流程及源码分析\"><a href=\"#spring-获取bean流程及源码分析\" class=\"headerlink\" title=\"spring 获取bean流程及源码分析\"></a>spring 获取bean流程及源码分析</h3><p>代码有点长，最好复制到编辑器中查看：</p>\n<pre><code class=\"java\">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,\n                    @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\n   // 转换beanName，前面我们已经说过，bean可以有别名，这里就是讲别名转换为beanName\n   final String beanName = transformedBeanName(name);\n   Object bean;\n   /**\n    * 检查缓存中或者实例工厂中是否有对应的实例\n    * 为什么首先会使用这段代码呢 ？\n    * 因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖\n    * spring创建bean的原则是不等bean创建完成就会创建bean的ObjectFactor提早曝光，\n    * （ObjectFactory用于产生对象，相当于一个创建特定对象的工厂） 也就是将ObjectFactory\n    * 加入到缓存中，一旦下个bean创建时候需要依赖上个bean则直接使用\n    * ObjectFactory：返回对应的object，也就是bean\n    *\n    */\n   // 直接尝试从缓存获取或者singletonFactories中的ObjectFactory中获取\n   // Eagerly check singleton cache for manually registered singletons.\n   Object sharedInstance = getSingleton(beanName);\n\n   if (sharedInstance != null &amp;&amp; args == null) {\n      if (logger.isTraceEnabled()) {\n         if (isSingletonCurrentlyInCreation(beanName)) {\n            logger.trace(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; \n                         + beanName +\n                  &quot;&#39; that is not fully initialized yet - \n                         a consequence of a circular reference&quot;);\n         } else {\n            logger.trace(&quot;Returning cached instance of singleton bean &#39;&quot; \n                         + beanName + &quot;&#39;&quot;);\n         }\n      }\n      // 返回对应的实例，有时候存在诸如FactoryBean的情况并不是直接返回实例本身\n      // 而是指定方法返回实例 对应这种情况是自定义了一些FactoryBean，本身就是一个bean\n      // 可以用来创建特定bean的工厂\n      // 还有是工厂bean中定义的factory-method方法返回bean\n      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n   } else {\n      /**\n       * 只有个在单例情况下才会尝试解决循环依赖，原型模式情况下，\n       * 如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，\n       * 就会产生当A还未创建完的时候因为B的创建在此返回创建A，造成\n       * 循环依赖，也就是下面这种情况\n       */\n      if (isPrototypeCurrentlyInCreation(beanName)) {\n         throw new BeanCurrentlyInCreationException(beanName);\n      }\n\n      // 如果beanDefinitionMap中也就是在所有已加载的类中不包括beanName\n      // 则会尝试从parentBeanFactory中检测\n      // Check if bean definition exists in this factory.\n      BeanFactory parentBeanFactory = getParentBeanFactory();\n      if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n         // 递归到BeanFactory中寻找\n         // Not found -&gt; check parent.\n         String nameToLookup = originalBeanName(name);\n         if (parentBeanFactory instanceof AbstractBeanFactory) {\n            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                  nameToLookup, requiredType, args, typeCheckOnly);\n         } else if (args != null) {\n            // Delegation to parent with explicit args.\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n         } else if (requiredType != null) {\n            // No args -&gt; delegate to standard getBean method.\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n         } else {\n            return (T) parentBeanFactory.getBean(nameToLookup);\n         }\n      }\n\n      // 如果不是仅仅做类型检查则是创建bean，这里要进行记录\n      if (!typeCheckOnly) {\n         markBeanAsCreated(beanName);\n      }\n\n      try {\n         // 将存储xml配置文件的GernericBeanDefinition转换为RootBeanDefinition\n         // 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\n          // 检查给定的合并的 BeanDefinition\n          checkMergedBeanDefinition(mbd, beanName, args);\n\n         // 若存在依赖则需要递归实例化依赖的bean\n         // Guarantee initialization of beans that the current bean depends on.\n         String[] dependsOn = mbd.getDependsOn();\n         if (dependsOn != null) {\n            for (String dep : dependsOn) {\n               if (isDependent(beanName, dep)) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), \n                                                  beanName,\n                        &quot;Circular depends-on relationship between &#39;&quot; \n                                                  + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);\n               }\n               // 缓存依赖调用\n               registerDependentBean(dep, beanName);\n               try {\n                  getBean(dep);\n               } catch (NoSuchBeanDefinitionException ex) {\n                  throw new BeanCreationException(mbd.getResourceDescription(),\n                                                  beanName,\n                        &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;,\n                                                  ex);\n               }\n            }\n         }\n         // Create bean instance.\n         // 实例化依赖的bean后便可以实例化mbd本身所代表的bean\n         // singleton模式的创建\n         if (mbd.isSingleton()) {\n            sharedInstance = getSingleton(beanName, () -&gt; {\n               try {\n                  return createBean(beanName, mbd, args);\n               } catch (BeansException ex) {\n                // 显示从单例缓存中删除 bean 实例\n                // 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它\n                  destroySingleton(beanName);\n                  throw ex;\n               }\n            });\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n         } else if (mbd.isPrototype()) { \n             // prototype模式的创建\n\n            Object prototypeInstance = null;\n            try {\n               beforePrototypeCreation(beanName);\n               prototypeInstance = createBean(beanName, mbd, args);\n            } finally {\n               afterPrototypeCreation(beanName);\n            }\n            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n         } else {\n            // 指定的scope上实例化bean\n            String scopeName = mbd.getScope();\n            final Scope scope = this.scopes.get(scopeName);\n            if (scope == null) {\n               throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot;\n                                               + scopeName + &quot;&#39;&quot;);\n            }\n            try {\n               // 从指定的 scope 下创建 bean\n               Object scopedInstance = scope.get(beanName, () -&gt; {\n                  beforePrototypeCreation(beanName);\n                  try {\n                     return createBean(beanName, mbd, args);\n                  } finally {\n                     afterPrototypeCreation(beanName);\n                  }\n               });\n               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n            } catch (IllegalStateException ex) {\n               throw new BeanCreationException(beanName,\n                     &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread;\n                                               consider &quot; \n                      +  &quot;defining a scoped proxy for this bean if you intend to refer\n                                               to it from a singleton&quot;,  ex);\n            }\n         }\n      } catch (BeansException ex) {\n         cleanupAfterBeanCreationFailure(beanName);\n         throw ex;\n      }\n   }\n   // 检查需要的类型是否符合bean的实际类型\n   if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {\n      try {\n         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n         if (convertedBean == null) {\n            throw new BeanNotOfRequiredTypeException(name, requiredType, \n                                                     bean.getClass());\n         }\n         return convertedBean;\n      } catch (TypeMismatchException ex) {\n         if (logger.isTraceEnabled()) {\n            logger.trace(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +\n                  ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);\n         }\n         throw new BeanNotOfRequiredTypeException(name, requiredType, \n                                                  bean.getClass());\n      }\n   }\n   return (T) bean;\n}\n</code></pre>\n<p>上面的代码很长、逻辑也挺复杂，但是可以初略的看到spring加载bean的过程，下面对于整个加载过程进行总结。</p>\n<p><strong>1.获取 beanName</strong></p>\n<pre><code class=\"java\">final String beanName = transformedBeanName(name);\n</code></pre>\n<p>这里传递的是 name，不一定就是 beanName，可能是 aliasName，也有可能是 FactoryBean，所以这里需要调用 <code>transformedBeanName()</code> 方法对 name 进行一番转换，主要如下：</p>\n<pre><code class=\"java\">    protected String transformedBeanName(String name) {\n        return canonicalName(BeanFactoryUtils.transformedBeanName(name));\n    }\n\n    // 去除 FactoryBean 的修饰符\n    public static String transformedBeanName(String name) {\n        Assert.notNull(name, &quot;&#39;name&#39; must not be null&quot;);\n        String beanName = name;\n        while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {\n            beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());\n        }\n        return beanName;\n    }\n\n    // 转换 aliasName\n    public String canonicalName(String name) {\n        String canonicalName = name;\n        // Handle aliasing...\n        String resolvedName;\n        do {\n            resolvedName = this.aliasMap.get(canonicalName);\n            if (resolvedName != null) {\n                canonicalName = resolvedName;\n            }\n        }while (resolvedName != null);\n        return canonicalName;\n    }\n</code></pre>\n<p>主要处理过程包括两步：</p>\n<ol>\n<li>去除 FactoryBean 的修饰符。如果 name 以 “&amp;” 为前缀，那么会去掉该 “&amp;”，例如，<code>name = &quot;&amp;studentService&quot;</code>，则会是 <code>name = &quot;studentService&quot;</code>。</li>\n<li>取指定的 alias 所表示的最终 beanName。主要是一个循环获取 beanName 的过程，例如别名 A 指向名称为 B 的 bean 则返回 B，若 别名 A 指向别名 B，别名 B 指向名称为 C 的 bean，则返回 C。</li>\n</ol>\n<p><strong>2.从单例 bean 缓存中获取 bean</strong></p>\n<p>对应代码段如下：</p>\n<pre><code class=\"java\">        Object sharedInstance = getSingleton(beanName);\n        if (sharedInstance != null &amp;&amp; args == null) {\n            if (logger.isDebugEnabled()) {\n                if (isSingletonCurrentlyInCreation(beanName)) {\n                    logger.debug(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +\n                            &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);\n                }\n                else {\n                    logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n                }\n            }\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n        }\n</code></pre>\n<p>我们知道单例模式的 bean 在整个过程中只会被创建一次，第一次创建后会将该 bean 加载到缓存中，后面在获取 bean 就会直接从单例缓存中获取。如果从缓存中得到了 bean，则需要调用 <code>getObjectForBeanInstance()</code> 对 bean 进行实例化处理，因为缓存中记录的是最原始的 bean 状态，我们得到的不一定是我们最终想要的 bean。</p>\n<p><strong>3.原型模式依赖检查与 parentBeanFactory</strong></p>\n<p>对应代码段</p>\n<pre><code class=\"java\">            if (isPrototypeCurrentlyInCreation(beanName)) {\n                throw new BeanCurrentlyInCreationException(beanName);\n            }\n\n            // Check if bean definition exists in this factory.\n            BeanFactory parentBeanFactory = getParentBeanFactory();\n            if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n                // Not found -&gt; check parent.\n                String nameToLookup = originalBeanName(name);\n                if (parentBeanFactory instanceof AbstractBeanFactory) {\n                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                            nameToLookup, requiredType, args, typeCheckOnly);\n                }\n                else if (args != null) {\n                    // Delegation to parent with explicit args.\n                    return (T) parentBeanFactory.getBean(nameToLookup, args);\n                }\n                else {\n                    // No args -&gt; delegate to standard getBean method.\n                    return parentBeanFactory.getBean(nameToLookup, requiredType);\n                }\n            }\n</code></pre>\n<p>Spring 只处理单例模式下得循环依赖，对于原型模式的循环依赖直接抛出异常。主要原因还是在于 Spring 解决循环依赖的策略有关。对于单例模式 Spring 在创建 bean 的时候并不是等 bean 完全创建完成后才会将 bean 添加至缓存中，而是不等 bean 创建完成就会将创建 bean 的 ObjectFactory 提早加入到缓存中，这样一旦下一个 bean 创建的时候需要依赖 bean 时则直接使用 ObjectFactroy。但是原型模式我们知道是没法使用缓存的，所以 Spring 对原型模式的循环依赖处理策略则是不处理（关于循环依赖后面会有单独文章说明）。</p>\n<p>如果容器缓存中没有相对应的 BeanDefinition 则会尝试从父类工厂（parentBeanFactory）中加载，然后再去递归调用 <code>getBean()</code>。</p>\n<p><strong>4. 将存储xml配置文件中的GenericBeanDefinition转换为RootBeanDefinition</strong></p>\n<p>前面也说过，从xml文件中获取读取到的bean信息是存储在GenericBeanDefinition中的，但是所有的bean后续处理都是针对于RootBeanDefinition的，所以这里需要进行一个转换，转的同时如果父类Bean不为空的话，则会合并父类的属性。</p>\n<p><strong>5. 依赖处理</strong></p>\n<p>对应源码如下：</p>\n<pre><code class=\"java\">                String[] dependsOn = mbd.getDependsOn();\n                if (dependsOn != null) {\n                    for (String dep : dependsOn) {\n                        if (isDependent(beanName, dep)) {\n                            throw new \n                                BeanCreationException(mbd.getResourceDescription(), \n                                                            beanName,\n                                    &quot;Circular depends-on relationship between &#39;&quot; \n                                       + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);\n                        }\n                        registerDependentBean(dep, beanName);\n                        try {\n                            getBean(dep);\n                        }\n                        catch (NoSuchBeanDefinitionException ex) {\n                            throw new \n                                BeanCreationException(mbd.getResourceDescription(), \n                                  beanName,&quot;&#39;&quot; + beanName \n                                + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);\n                        }\n                    }\n                }\n</code></pre>\n<p>每个 bean 都不是单独工作的，它会依赖其他 bean，其他 bean 也会依赖它，对于依赖的 bean ，它会优先加载，所以在 Spring 的加载顺序中，在初始化某一个 bean 的时候首先会初始化这个 bean 的依赖。</p>\n<p><strong>6 作用域处理</strong></p>\n<p>Spring bean 的作用域默认为 singleton，当然还有其他作用域，如prototype、request、session 等，不同的作用域会有不同的初始化策略。</p>\n<p><strong>7 类型转换</strong></p>\n<p>在调用 <code>doGetBean()</code> 方法时，有一个 requiredType 参数，该参数的功能就是将返回的 bean 转换为 requiredType 类型。当然就一般而言我们是不需要进行类型转换的，也就是 requiredType 为空（比如 <code>getBean(String name)</code>），但有可能会存在这种情况，比如我们返回的 bean 类型为 String，我们在使用的时候需要将其转换为 Integer，那么这个时候 requiredType 就有用武之地了。当然我们一般是不需要这样做的。</p>\n<p>至此 <code>getBean()</code> 过程讲解完了。后续将会对该过程进行拆分，更加详细的说明，弄清楚其中的来龙去脉，所以这篇博客只能算是 Spring bean 加载过程的一个概览。</p>"},{"abbrlink":42,"title":"spring源码解析之 17缓存中获取单例bean","author":"fengxiutianya","date":"2019-01-14T19:31:00.000Z","_content":"#  spring源码解析之 17缓存中获取单例bean\n\n从这篇博客开始我们开始加载 bean 的第一个步骤，从缓存中获取 bean，代码片段如下：\n<!-- more -->\n\n```java\n        Object sharedInstance = getSingleton(beanName);\n        if (sharedInstance != null && args == null) {\n            if (logger.isDebugEnabled()) {\n                if (isSingletonCurrentlyInCreation(beanName)) {\n                    logger.debug(\"Returning eagerly cached instance of singleton \n                                 bean '\" + beanName +\n                            \"' that is not fully initialized yet - \n                                 a consequence of a circular reference\");\n                }\n                else {\n                    logger.debug(\"Returning cached instance of singleton bean '\" \n                                 + beanName + \"'\");\n                }\n            }\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n        }\n```\n\n首先调用 `getSingleton()` 从缓存中获取 bean，在上篇博客提到过，Spring 对单例模式的 bean 只会创建一次，后续如果再获取该 bean 则是直接从单例缓存中获取，该过程就体现在 `getSingleton()` 中。如下：\n\n```java\n    public Object getSingleton(String beanName) {\n        // 参数true设置表示允许早期依赖\n        return getSingleton(beanName, true);\n    }\n\n   @Nullable\n\tprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n\t\t// 检查缓存中是否存在实例\n\t\tObject singletonObject = this.singletonObjects.get(beanName);\n\t\t// 如果为空，并且正在创建这个bean，则锁定全局变量并进行处理\n\t\tif (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t// 锁住已经实例化Bean的全局变量，防止出现线程安全问题，\n\t\t\t// 也就是有另外的线程在创建这个bean，这可以阻塞住当期线程，等待另外一个线程创建完成\n\t\t\tsynchronized (this.singletonObjects) {\n\t\t\t\t// 此处是用来获取正在创建过程中bean，此处可能是没有创建完全的bean，也就是没有\n\t\t\t\t// 进行依赖注入等操作的bean\n\t\t\t\tsingletonObject = this.earlySingletonObjects.get(beanName);\n\t\t\t\t// 如果没有正在创建，并且允许提前引用，则进行创建bean，但没有实例化完整的bean\n\t\t\t\tif (singletonObject == null && allowEarlyReference) {\n\t\t\t\t\t// 当某些方法需要提前初始化的时候会调用addSingletonFactory方法将对应的\n\t\t\t\t\t// ObjectFactory初始化策略存储在singletonFactories\n\t\t\t\t\t// 获取对应的bean的factoryBean,\n\t\t\t\t\tObjectFactory<?> singletonFactory = \n                        this.singletonFactories.get(beanName);\n\t\t\t\t\t// 如果创建bean的ObjectFactory不为空，则创建对应的对象\n\t\t\t\t\tif (singletonFactory != null) {\n\t\t\t\t\t\t// 调用预先设定的getObject方法\n\t\t\t\t\t\tsingletonObject = singletonFactory.getObject();\n\t\t\t\t\t\t//记录在缓存中earlySingletonObjects和singletonFactories互斥\n                        // 这一点可以这样理解如果你用ObjectFactory提前创建了一个对象，\n                        // 而此对象是单例的，因此你应该将创建的这个对象放到单例对象缓存队列中\n                        // 另外删除这个创建对象的工厂，因为不能在创建此对象，否则就不是单例。\n\t\t\t\t\t\tthis.earlySingletonObjects.put(beanName, singletonObject);\n\t\t\t\t\t\tthis.singletonFactories.remove(beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 从上面的过程可以看出此处的bean可能是没有创建完成的bean\n\t\treturn singletonObject;\n\t}\n```\n\n这段代码非常简单，首先从 singletonObjects 中获取，若为空且当前 bean 正在创建中，则从 earlySingletonObjects 中获取，若为空且允许提前创建则从 singletonFactories 中获取相应的 ObjectFactory ，若不为空，则调用其 `getObject()`创建 bean，然后将其加入到 earlySingletonObjects，然后从 singletonFactories 删除。总体逻辑就是根据 beanName 依次检测这三个 Map，若为空，从下一个，否则返回。这三个 Map 存放的都有各自的功能，如下：\n\n- singletonObjects ：存放的是单例 bean，对应关系为 `bean name --> bean instance`\n- earlySingletonObjects：存放的是早期的 bean，对应关系也是 `bean name --> bean instance`。它与 singletonObjects 区别在于 earlySingletonObjects 中存放的 bean 不一定是完整的，从上面过程中我们可以了解，bean 在创建过程中就已经加入到 earlySingletonObjects 中了，所以当在 bean 的创建过程中就可以通过 `getBean()` 方法获取。这个 Map 也是解决循环依赖的关键所在。\n- singletonFactories：存放的是 ObjectFactory，可以理解为创建单例 bean 的 factory，对应关系是 `bean name --> ObjectFactory`\n- registeredSingletons:这个是用于保存所有已经注册的bean，这里先提前讲，后面会用到\n\n在上面代码中还有一个非常重要的检测方法 `isSingletonCurrentlyInCreation(beanName)`，该方法用于判断该 beanName 对应的 bean 是否在创建过程中，注意这个过程讲的是整个工厂中。如下：\n\n```java\n    public boolean isSingletonCurrentlyInCreation(String beanName) {\n        return this.singletonsCurrentlyInCreation.contains(beanName);\n    }\n```\n\n从这段代码中我们可以预测，在 bean 创建过程中都会将其加入到 singletonsCurrentlyInCreation 集合中，具体是在什么时候加的，我们后面分析。\n\n到这里从缓存中获取 bean 的过程已经分析完毕了，我们再看开篇的代码段，从缓存中获取 bean 后，若其不为 null 且 args 为空，则会调用 `getObjectForBeanInstance()` 处理。为什么会有这么一段呢？因为我们从缓存中获取的 bean 是最原始的 bean 并不一定使我们最终想要的 bean，怎么办呢？调用 `getObjectForBeanInstance()` 进行处理，该方法的定义为获取给定 bean 实例的对象，该对象要么是 bean 实例本身，要么就是 FactoryBean 创建的对象，如下：\n\n```java\n   protected Object getObjectForBeanInstance(\n            Object beanInstance, String name, String beanName,\n       \t\t\t@Nullable RootBeanDefinition mbd) {\n\n        // 若为工厂类引用（name 以 & 开头）\n        if (BeanFactoryUtils.isFactoryDereference(name)) {\n            // 如果是 NullBean，则直接返回\n            if (beanInstance instanceof NullBean) {\n                return beanInstance;\n            }\n            // 如果 beanInstance 不是 FactoryBean 类型，则抛出异常\n            if (!(beanInstance instanceof FactoryBean)) {\n                throw new BeanIsNotAFactoryException(transformedBeanName(name), \n                                                     beanInstance.getClass());\n            }\n        }\n\n        // 到这里我们就有了一个 bean 实例，当然该实例可能是会是是\n       // 一个正常的 bean 又或者是一个 FactoryBean\n        // 如果是 FactoryBean，我们则创建该 bean\n        if (!(beanInstance instanceof FactoryBean) || \n            BeanFactoryUtils.isFactoryDereference(name)) {\n            return beanInstance;\n        }\n\n        // 加载 FactoryBean\n        Object object = null;\n        // 若 BeanDefinition 为 null，则从缓存中加载\n        if (mbd == null) {\n            object = getCachedObjectForFactoryBean(beanName);\n        }\n        // 若 object 依然为空，则可以确认，beanInstance 一定是 FactoryBean\n        if (object == null) {\n            // 到这里已经确定beanInstance是FactoryBean类型，强转\n            FactoryBean<?> factory = (FactoryBean<?>) beanInstance;\n            if (mbd == null && containsBeanDefinition(beanName)) {\n                // 将存在XML配置文件的GernericBeanDefinition转换为RootBeanDefinition\n\t\t\t\t// 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n                mbd = getMergedLocalBeanDefinition(beanName);\n            }\n            // 是否是用户定义的而不是应用程序本身定义的\n            boolean synthetic = (mbd != null && mbd.isSynthetic());\n            // 核心处理类\n            object = getObjectFromFactoryBean(factory, beanName, !synthetic);\n        }\n        return object;\n    }\n```\n\n该方法主要是进行检测工作的，主要如下：\n\n- 若 name 为工厂相关的（以 & 开头），且 beanInstance 为 NullBean 类型则直接返回，如果 beanInstance 不为 FactoryBean 类型则抛出 BeanIsNotFactoryException 异常。这里主要是校验 beanInstance 的正确性。\n- 如果 beanInstance 不为 FactoryBean 类型或者 name 也不是与工厂相关的，则直接返回。这里主要是对非 FactoryBean 类型处理。\n- 如果 BeanDefinition 为空，则从 factoryBeanObjectCache 中加载，如果还是空，则可以断定 beanInstance 一定是 FactoryBean 类型，则委托 `getObjectFromFactoryBean()` 方法处理\n\n再继续分析`getObjectFromFactoryBean`之前，我们先介绍一下FactoryBean，感觉很相似，因为我们前面经常说BeanFactory，简单说一下他们的区别。 BeanFactory和FactoryBean其实没有什么比较性的，只是两者的名称特别接近，所以有时候会拿出来比较一番，BeanFactory是提供了IOC容器最基本的形式，给具体的IOC容器的实现提供了规范，FactoryBean可以说为IOC容器中Bean的实现提供了更加灵活的方式，FactoryBean在IOC容器的基础上给Bean的实现加上了一个简单工厂模式和装饰模式，我们可以在getObject()方法中灵活配置。具体的可以看这篇文章[BeanFactory和FactoryBean的区别](https://blog.csdn.net/wangbiao007/article/details/53183764)\n\n从上面可以看出 `getObjectForBeanInstance()` 主要是返回给定的 bean 实例对象，当然该实例对象为非 FactoryBean 类型，对于 FactoryBean 类型的 bean，则是委托 `getObjectFromFactoryBean()` 从 FactoryBean 获取 bean 实例对象。\n\n```java\n   protected Object getObjectFromFactoryBean(FactoryBean<?> factory,\n                                             String beanName,\n                                             boolean shouldPostProcess) {\n       \t// 如果此BeanName对应的FactoryBean是单例bean，\n\t\t// beanName对应的bean是单例对象\n        if (factory.isSingleton() && containsSingleton(beanName)) {\n\n            synchronized (getSingletonMutex()) {\n                // 从缓存中获取指定的 factoryBean\n                Object object = this.factoryBeanObjectCache.get(beanName);\n\n                if (object == null) {\n                    // 为空，则从 FactoryBean 中获取对象\n                    object = doGetObjectFromFactoryBean(factory, beanName);\n\n                    // 从缓存中获取\n                    Object alreadyThere = this.factoryBeanObjectCache.get(beanName);\n                    // 下面这种情况是为了避免由于循环引用导致提前创建了一个一样的bean\n\t\t\t\t\t// 为了一致，则抛弃当前的bean，有点类似于CAS的处理\n                    if (alreadyThere != null) {\n                        object = alreadyThere;\n                    } else {\n                        // 需要后续处理\n                        if (shouldPostProcess) {\n                        // 若该 bean 处于创建中，则直接返回对象，而非继续处理对象，而不是存储它\n                   \n                            if (isSingletonCurrentlyInCreation(beanName)) {\n                                return object;\n                            }\n                            // 前置处理\n                            beforeSingletonCreation(beanName);\n                            try {\n                                // 对从 FactoryBean 获取的对象进行后处理\n                                // 生成的对象将暴露给bean引用\n                                object = postProcessObjectFromFactoryBean(object, \n                                                                          beanName);\n                            }\n                            catch (Throwable ex) {\n                                throw new BeanCreationException(beanName,\n                                        \"Post-processing of FactoryBean's \n                                         singleton object failed\", ex);\n                            }\n                            finally {\n                                // 后置处理\n                                afterSingletonCreation(beanName);\n                            }\n                        }\n                        // 缓存\n                        if (containsSingleton(beanName)) {\n                            this.factoryBeanObjectCache.put(beanName, object);\n                        }\n                    }\n                }\n                return object;\n            }\n        }\n        else {\n            // 非单例\n            Object object = doGetObjectFromFactoryBean(factory, beanName);\n            if (shouldPostProcess) {\n                try {\n                    object = postProcessObjectFromFactoryBean(object, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(beanName, \n                        \"Post-processing of FactoryBean's object failed\", ex);\n                }\n            }\n            return object;\n        }\n    }\n```\n\n主要流程如下：\n\n- 若为单例且单例 bean 缓存中存在 beanName，则进行后续处理（跳转到下一步），否则则从 FactoryBean 中获取 bean 实例对象，如果接受后置处理，则调用 `postProcessObjectFromFactoryBean()` 进行后置处理。\n- 首先获取锁（其实我们在前面篇幅中发现了大量的同步锁，锁住的对象都是 this.singletonObjects， 主要是因为在单例模式中必须要保证全局唯一），然后从 factoryBeanObjectCache 缓存中获取实例对象 object，若 object 为空，则调用 `doGetObjectFromFactoryBean()` 方法从 FactoryBean 获取对象，其实内部就是调用 `FactoryBean.getObject()`。\n- 如果需要后续处理，则进行进一步处理，步骤如下：\n  - 若该 bean 处于创建中（isSingletonCurrentlyInCreation），则返回非处理对象，而不是存储它。这个是因为后面即将讲到的循环依赖所以你的，由于bean之间的依赖，会造成一些bean还没有初始化完成就提前创建出该对象的ObjectFactory对象，然后来生成对应bean，让正在创建的bean创建能继续处理，这里先理解个大概，后面会仔细说。\n  - 调用 `beforeSingletonCreation()` 进行创建之前的处理。默认实现将该 bean 标志为当前创建的。\n  - 调用 `postProcessObjectFromFactoryBean()` 对从 FactoryBean 获取的 bean 实例对象进行后置处理，默认实现是按照原样直接返回，具体实现是在 AbstractAutowireCapableBeanFactory 中实现的，当然子类也可以重写它，比如应用后置处理\n  - 调用 `afterSingletonCreation()` 进行创建 bean 之后的处理，默认实现是将该 bean 标记为不再在创建中。\n- 最后加入到 FactoryBeans 缓存中。\n\n该方法应该就是创建 bean 实例对象中的核心方法之一了。这里我们关注三个方法：`beforeSingletonCreation()` 、 `afterSingletonCreation()` 、 `postProcessObjectFromFactoryBean()`。可能有小伙伴觉得前面两个方法不是很重要，可以肯定告诉你，这两方法是非常重要的操作，因为**他们记录着 bean 的加载状态，是检测当前 bean 是否处于创建中的关键之处，对解决 bean 循环依赖起着关键作用**。before 方法用于标志当前 bean 处于创建中，after 则是移除。其实在这篇博客刚刚开始就已经提到了 `isSingletonCurrentlyInCreation()` 是用于检测当前 bean 是否处于创建之中，如下：\n\n```java\n    public boolean isSingletonCurrentlyInCreation(String beanName) {\n        return this.singletonsCurrentlyInCreation.contains(beanName);\n    }\n```\n\n是根据 singletonsCurrentlyInCreation 集合中是否包含了 beanName，集合的元素则一定是在 `beforeSingletonCreation()` 中添加的，如下：\n\n```java\n    protected void beforeSingletonCreation(String beanName) {\n        if (!this.inCreationCheckExclusions.contains(beanName) && \n            !this.singletonsCurrentlyInCreation.add(beanName)) {\n            throw new BeanCurrentlyInCreationException(beanName);\n        }\n    }\n```\n\n`afterSingletonCreation()` 为移除，则一定就是对 singletonsCurrentlyInCreation 集合 remove 了，如下：\n\n```java\n    protected void afterSingletonCreation(String beanName) {\n        if (!this.inCreationCheckExclusions.contains(beanName) && \n            !this.singletonsCurrentlyInCreation.remove(beanName)) {\n            throw new IllegalStateException(\"Singleton '\" +\n                                            beanName + \"' isn't currently in creation\");\n        }\n    }\n```\n\n`postProcessObjectFromFactoryBean()` 是对从 FactoryBean 处获取的 bean 实例对象进行后置处理，其默认实现是直接返回 object 对象，不做任何处理，子类可以重写，例如应用后处理器。AbstractAutowireCapableBeanFactory 对其提供了实现，如下：\n\n```java\n    protected Object postProcessObjectFromFactoryBean(Object object, String beanName) {\n        return applyBeanPostProcessorsAfterInitialization(object, beanName);\n    }\n```\n\n该方法的定义为：对所有的 postProcessAfterInitialization 进行回调注册 BeanPostProcessors，让他们能够后期处理从 FactoryBean 中获取的对象。下面是具体实现：\n\n```java\n    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, \n                                                             String beanName)\n            throws BeansException {\n\n        Object result = existingBean;\n        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n            Object current = \n                beanProcessor.postProcessAfterInitialization(result, beanName);\n            if (current == null) {\n                return result;\n            }\n            result = current;\n        }\n        return result;\n    }\n```\n\n对于后置处理器，这里我们不做过多阐述，后面会专门的博文进行详细介绍，这里我们只需要记住一点：尽可能保证所有 bean 初始化后都会调用注册的 `BeanPostProcessor.postProcessAfterInitialization()` 方法进行处理，在实际开发过程中大可以针对此特性设计自己的业务逻辑。\n\n至此，从缓存中获取 bean 对象过程已经分析完毕了。","source":"_posts/spring 源码分析/spring/spring源码解析之 17缓存中获取单例bean.md","raw":"abbrlink: 42\ntitle: spring源码解析之 17缓存中获取单例bean\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-15 03:31:00\n---\n#  spring源码解析之 17缓存中获取单例bean\n\n从这篇博客开始我们开始加载 bean 的第一个步骤，从缓存中获取 bean，代码片段如下：\n<!-- more -->\n\n```java\n        Object sharedInstance = getSingleton(beanName);\n        if (sharedInstance != null && args == null) {\n            if (logger.isDebugEnabled()) {\n                if (isSingletonCurrentlyInCreation(beanName)) {\n                    logger.debug(\"Returning eagerly cached instance of singleton \n                                 bean '\" + beanName +\n                            \"' that is not fully initialized yet - \n                                 a consequence of a circular reference\");\n                }\n                else {\n                    logger.debug(\"Returning cached instance of singleton bean '\" \n                                 + beanName + \"'\");\n                }\n            }\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n        }\n```\n\n首先调用 `getSingleton()` 从缓存中获取 bean，在上篇博客提到过，Spring 对单例模式的 bean 只会创建一次，后续如果再获取该 bean 则是直接从单例缓存中获取，该过程就体现在 `getSingleton()` 中。如下：\n\n```java\n    public Object getSingleton(String beanName) {\n        // 参数true设置表示允许早期依赖\n        return getSingleton(beanName, true);\n    }\n\n   @Nullable\n\tprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n\t\t// 检查缓存中是否存在实例\n\t\tObject singletonObject = this.singletonObjects.get(beanName);\n\t\t// 如果为空，并且正在创建这个bean，则锁定全局变量并进行处理\n\t\tif (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t// 锁住已经实例化Bean的全局变量，防止出现线程安全问题，\n\t\t\t// 也就是有另外的线程在创建这个bean，这可以阻塞住当期线程，等待另外一个线程创建完成\n\t\t\tsynchronized (this.singletonObjects) {\n\t\t\t\t// 此处是用来获取正在创建过程中bean，此处可能是没有创建完全的bean，也就是没有\n\t\t\t\t// 进行依赖注入等操作的bean\n\t\t\t\tsingletonObject = this.earlySingletonObjects.get(beanName);\n\t\t\t\t// 如果没有正在创建，并且允许提前引用，则进行创建bean，但没有实例化完整的bean\n\t\t\t\tif (singletonObject == null && allowEarlyReference) {\n\t\t\t\t\t// 当某些方法需要提前初始化的时候会调用addSingletonFactory方法将对应的\n\t\t\t\t\t// ObjectFactory初始化策略存储在singletonFactories\n\t\t\t\t\t// 获取对应的bean的factoryBean,\n\t\t\t\t\tObjectFactory<?> singletonFactory = \n                        this.singletonFactories.get(beanName);\n\t\t\t\t\t// 如果创建bean的ObjectFactory不为空，则创建对应的对象\n\t\t\t\t\tif (singletonFactory != null) {\n\t\t\t\t\t\t// 调用预先设定的getObject方法\n\t\t\t\t\t\tsingletonObject = singletonFactory.getObject();\n\t\t\t\t\t\t//记录在缓存中earlySingletonObjects和singletonFactories互斥\n                        // 这一点可以这样理解如果你用ObjectFactory提前创建了一个对象，\n                        // 而此对象是单例的，因此你应该将创建的这个对象放到单例对象缓存队列中\n                        // 另外删除这个创建对象的工厂，因为不能在创建此对象，否则就不是单例。\n\t\t\t\t\t\tthis.earlySingletonObjects.put(beanName, singletonObject);\n\t\t\t\t\t\tthis.singletonFactories.remove(beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 从上面的过程可以看出此处的bean可能是没有创建完成的bean\n\t\treturn singletonObject;\n\t}\n```\n\n这段代码非常简单，首先从 singletonObjects 中获取，若为空且当前 bean 正在创建中，则从 earlySingletonObjects 中获取，若为空且允许提前创建则从 singletonFactories 中获取相应的 ObjectFactory ，若不为空，则调用其 `getObject()`创建 bean，然后将其加入到 earlySingletonObjects，然后从 singletonFactories 删除。总体逻辑就是根据 beanName 依次检测这三个 Map，若为空，从下一个，否则返回。这三个 Map 存放的都有各自的功能，如下：\n\n- singletonObjects ：存放的是单例 bean，对应关系为 `bean name --> bean instance`\n- earlySingletonObjects：存放的是早期的 bean，对应关系也是 `bean name --> bean instance`。它与 singletonObjects 区别在于 earlySingletonObjects 中存放的 bean 不一定是完整的，从上面过程中我们可以了解，bean 在创建过程中就已经加入到 earlySingletonObjects 中了，所以当在 bean 的创建过程中就可以通过 `getBean()` 方法获取。这个 Map 也是解决循环依赖的关键所在。\n- singletonFactories：存放的是 ObjectFactory，可以理解为创建单例 bean 的 factory，对应关系是 `bean name --> ObjectFactory`\n- registeredSingletons:这个是用于保存所有已经注册的bean，这里先提前讲，后面会用到\n\n在上面代码中还有一个非常重要的检测方法 `isSingletonCurrentlyInCreation(beanName)`，该方法用于判断该 beanName 对应的 bean 是否在创建过程中，注意这个过程讲的是整个工厂中。如下：\n\n```java\n    public boolean isSingletonCurrentlyInCreation(String beanName) {\n        return this.singletonsCurrentlyInCreation.contains(beanName);\n    }\n```\n\n从这段代码中我们可以预测，在 bean 创建过程中都会将其加入到 singletonsCurrentlyInCreation 集合中，具体是在什么时候加的，我们后面分析。\n\n到这里从缓存中获取 bean 的过程已经分析完毕了，我们再看开篇的代码段，从缓存中获取 bean 后，若其不为 null 且 args 为空，则会调用 `getObjectForBeanInstance()` 处理。为什么会有这么一段呢？因为我们从缓存中获取的 bean 是最原始的 bean 并不一定使我们最终想要的 bean，怎么办呢？调用 `getObjectForBeanInstance()` 进行处理，该方法的定义为获取给定 bean 实例的对象，该对象要么是 bean 实例本身，要么就是 FactoryBean 创建的对象，如下：\n\n```java\n   protected Object getObjectForBeanInstance(\n            Object beanInstance, String name, String beanName,\n       \t\t\t@Nullable RootBeanDefinition mbd) {\n\n        // 若为工厂类引用（name 以 & 开头）\n        if (BeanFactoryUtils.isFactoryDereference(name)) {\n            // 如果是 NullBean，则直接返回\n            if (beanInstance instanceof NullBean) {\n                return beanInstance;\n            }\n            // 如果 beanInstance 不是 FactoryBean 类型，则抛出异常\n            if (!(beanInstance instanceof FactoryBean)) {\n                throw new BeanIsNotAFactoryException(transformedBeanName(name), \n                                                     beanInstance.getClass());\n            }\n        }\n\n        // 到这里我们就有了一个 bean 实例，当然该实例可能是会是是\n       // 一个正常的 bean 又或者是一个 FactoryBean\n        // 如果是 FactoryBean，我们则创建该 bean\n        if (!(beanInstance instanceof FactoryBean) || \n            BeanFactoryUtils.isFactoryDereference(name)) {\n            return beanInstance;\n        }\n\n        // 加载 FactoryBean\n        Object object = null;\n        // 若 BeanDefinition 为 null，则从缓存中加载\n        if (mbd == null) {\n            object = getCachedObjectForFactoryBean(beanName);\n        }\n        // 若 object 依然为空，则可以确认，beanInstance 一定是 FactoryBean\n        if (object == null) {\n            // 到这里已经确定beanInstance是FactoryBean类型，强转\n            FactoryBean<?> factory = (FactoryBean<?>) beanInstance;\n            if (mbd == null && containsBeanDefinition(beanName)) {\n                // 将存在XML配置文件的GernericBeanDefinition转换为RootBeanDefinition\n\t\t\t\t// 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n                mbd = getMergedLocalBeanDefinition(beanName);\n            }\n            // 是否是用户定义的而不是应用程序本身定义的\n            boolean synthetic = (mbd != null && mbd.isSynthetic());\n            // 核心处理类\n            object = getObjectFromFactoryBean(factory, beanName, !synthetic);\n        }\n        return object;\n    }\n```\n\n该方法主要是进行检测工作的，主要如下：\n\n- 若 name 为工厂相关的（以 & 开头），且 beanInstance 为 NullBean 类型则直接返回，如果 beanInstance 不为 FactoryBean 类型则抛出 BeanIsNotFactoryException 异常。这里主要是校验 beanInstance 的正确性。\n- 如果 beanInstance 不为 FactoryBean 类型或者 name 也不是与工厂相关的，则直接返回。这里主要是对非 FactoryBean 类型处理。\n- 如果 BeanDefinition 为空，则从 factoryBeanObjectCache 中加载，如果还是空，则可以断定 beanInstance 一定是 FactoryBean 类型，则委托 `getObjectFromFactoryBean()` 方法处理\n\n再继续分析`getObjectFromFactoryBean`之前，我们先介绍一下FactoryBean，感觉很相似，因为我们前面经常说BeanFactory，简单说一下他们的区别。 BeanFactory和FactoryBean其实没有什么比较性的，只是两者的名称特别接近，所以有时候会拿出来比较一番，BeanFactory是提供了IOC容器最基本的形式，给具体的IOC容器的实现提供了规范，FactoryBean可以说为IOC容器中Bean的实现提供了更加灵活的方式，FactoryBean在IOC容器的基础上给Bean的实现加上了一个简单工厂模式和装饰模式，我们可以在getObject()方法中灵活配置。具体的可以看这篇文章[BeanFactory和FactoryBean的区别](https://blog.csdn.net/wangbiao007/article/details/53183764)\n\n从上面可以看出 `getObjectForBeanInstance()` 主要是返回给定的 bean 实例对象，当然该实例对象为非 FactoryBean 类型，对于 FactoryBean 类型的 bean，则是委托 `getObjectFromFactoryBean()` 从 FactoryBean 获取 bean 实例对象。\n\n```java\n   protected Object getObjectFromFactoryBean(FactoryBean<?> factory,\n                                             String beanName,\n                                             boolean shouldPostProcess) {\n       \t// 如果此BeanName对应的FactoryBean是单例bean，\n\t\t// beanName对应的bean是单例对象\n        if (factory.isSingleton() && containsSingleton(beanName)) {\n\n            synchronized (getSingletonMutex()) {\n                // 从缓存中获取指定的 factoryBean\n                Object object = this.factoryBeanObjectCache.get(beanName);\n\n                if (object == null) {\n                    // 为空，则从 FactoryBean 中获取对象\n                    object = doGetObjectFromFactoryBean(factory, beanName);\n\n                    // 从缓存中获取\n                    Object alreadyThere = this.factoryBeanObjectCache.get(beanName);\n                    // 下面这种情况是为了避免由于循环引用导致提前创建了一个一样的bean\n\t\t\t\t\t// 为了一致，则抛弃当前的bean，有点类似于CAS的处理\n                    if (alreadyThere != null) {\n                        object = alreadyThere;\n                    } else {\n                        // 需要后续处理\n                        if (shouldPostProcess) {\n                        // 若该 bean 处于创建中，则直接返回对象，而非继续处理对象，而不是存储它\n                   \n                            if (isSingletonCurrentlyInCreation(beanName)) {\n                                return object;\n                            }\n                            // 前置处理\n                            beforeSingletonCreation(beanName);\n                            try {\n                                // 对从 FactoryBean 获取的对象进行后处理\n                                // 生成的对象将暴露给bean引用\n                                object = postProcessObjectFromFactoryBean(object, \n                                                                          beanName);\n                            }\n                            catch (Throwable ex) {\n                                throw new BeanCreationException(beanName,\n                                        \"Post-processing of FactoryBean's \n                                         singleton object failed\", ex);\n                            }\n                            finally {\n                                // 后置处理\n                                afterSingletonCreation(beanName);\n                            }\n                        }\n                        // 缓存\n                        if (containsSingleton(beanName)) {\n                            this.factoryBeanObjectCache.put(beanName, object);\n                        }\n                    }\n                }\n                return object;\n            }\n        }\n        else {\n            // 非单例\n            Object object = doGetObjectFromFactoryBean(factory, beanName);\n            if (shouldPostProcess) {\n                try {\n                    object = postProcessObjectFromFactoryBean(object, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(beanName, \n                        \"Post-processing of FactoryBean's object failed\", ex);\n                }\n            }\n            return object;\n        }\n    }\n```\n\n主要流程如下：\n\n- 若为单例且单例 bean 缓存中存在 beanName，则进行后续处理（跳转到下一步），否则则从 FactoryBean 中获取 bean 实例对象，如果接受后置处理，则调用 `postProcessObjectFromFactoryBean()` 进行后置处理。\n- 首先获取锁（其实我们在前面篇幅中发现了大量的同步锁，锁住的对象都是 this.singletonObjects， 主要是因为在单例模式中必须要保证全局唯一），然后从 factoryBeanObjectCache 缓存中获取实例对象 object，若 object 为空，则调用 `doGetObjectFromFactoryBean()` 方法从 FactoryBean 获取对象，其实内部就是调用 `FactoryBean.getObject()`。\n- 如果需要后续处理，则进行进一步处理，步骤如下：\n  - 若该 bean 处于创建中（isSingletonCurrentlyInCreation），则返回非处理对象，而不是存储它。这个是因为后面即将讲到的循环依赖所以你的，由于bean之间的依赖，会造成一些bean还没有初始化完成就提前创建出该对象的ObjectFactory对象，然后来生成对应bean，让正在创建的bean创建能继续处理，这里先理解个大概，后面会仔细说。\n  - 调用 `beforeSingletonCreation()` 进行创建之前的处理。默认实现将该 bean 标志为当前创建的。\n  - 调用 `postProcessObjectFromFactoryBean()` 对从 FactoryBean 获取的 bean 实例对象进行后置处理，默认实现是按照原样直接返回，具体实现是在 AbstractAutowireCapableBeanFactory 中实现的，当然子类也可以重写它，比如应用后置处理\n  - 调用 `afterSingletonCreation()` 进行创建 bean 之后的处理，默认实现是将该 bean 标记为不再在创建中。\n- 最后加入到 FactoryBeans 缓存中。\n\n该方法应该就是创建 bean 实例对象中的核心方法之一了。这里我们关注三个方法：`beforeSingletonCreation()` 、 `afterSingletonCreation()` 、 `postProcessObjectFromFactoryBean()`。可能有小伙伴觉得前面两个方法不是很重要，可以肯定告诉你，这两方法是非常重要的操作，因为**他们记录着 bean 的加载状态，是检测当前 bean 是否处于创建中的关键之处，对解决 bean 循环依赖起着关键作用**。before 方法用于标志当前 bean 处于创建中，after 则是移除。其实在这篇博客刚刚开始就已经提到了 `isSingletonCurrentlyInCreation()` 是用于检测当前 bean 是否处于创建之中，如下：\n\n```java\n    public boolean isSingletonCurrentlyInCreation(String beanName) {\n        return this.singletonsCurrentlyInCreation.contains(beanName);\n    }\n```\n\n是根据 singletonsCurrentlyInCreation 集合中是否包含了 beanName，集合的元素则一定是在 `beforeSingletonCreation()` 中添加的，如下：\n\n```java\n    protected void beforeSingletonCreation(String beanName) {\n        if (!this.inCreationCheckExclusions.contains(beanName) && \n            !this.singletonsCurrentlyInCreation.add(beanName)) {\n            throw new BeanCurrentlyInCreationException(beanName);\n        }\n    }\n```\n\n`afterSingletonCreation()` 为移除，则一定就是对 singletonsCurrentlyInCreation 集合 remove 了，如下：\n\n```java\n    protected void afterSingletonCreation(String beanName) {\n        if (!this.inCreationCheckExclusions.contains(beanName) && \n            !this.singletonsCurrentlyInCreation.remove(beanName)) {\n            throw new IllegalStateException(\"Singleton '\" +\n                                            beanName + \"' isn't currently in creation\");\n        }\n    }\n```\n\n`postProcessObjectFromFactoryBean()` 是对从 FactoryBean 处获取的 bean 实例对象进行后置处理，其默认实现是直接返回 object 对象，不做任何处理，子类可以重写，例如应用后处理器。AbstractAutowireCapableBeanFactory 对其提供了实现，如下：\n\n```java\n    protected Object postProcessObjectFromFactoryBean(Object object, String beanName) {\n        return applyBeanPostProcessorsAfterInitialization(object, beanName);\n    }\n```\n\n该方法的定义为：对所有的 postProcessAfterInitialization 进行回调注册 BeanPostProcessors，让他们能够后期处理从 FactoryBean 中获取的对象。下面是具体实现：\n\n```java\n    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, \n                                                             String beanName)\n            throws BeansException {\n\n        Object result = existingBean;\n        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n            Object current = \n                beanProcessor.postProcessAfterInitialization(result, beanName);\n            if (current == null) {\n                return result;\n            }\n            result = current;\n        }\n        return result;\n    }\n```\n\n对于后置处理器，这里我们不做过多阐述，后面会专门的博文进行详细介绍，这里我们只需要记住一点：尽可能保证所有 bean 初始化后都会调用注册的 `BeanPostProcessor.postProcessAfterInitialization()` 方法进行处理，在实际开发过程中大可以针对此特性设计自己的业务逻辑。\n\n至此，从缓存中获取 bean 对象过程已经分析完毕了。","slug":"spring 源码分析/spring/spring源码解析之 17缓存中获取单例bean","published":1,"updated":"2019-01-15T03:39:38.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovx8005k9q1u6dqgnonz","content":"<h1 id=\"spring源码解析之-17缓存中获取单例bean\"><a href=\"#spring源码解析之-17缓存中获取单例bean\" class=\"headerlink\" title=\"spring源码解析之 17缓存中获取单例bean\"></a>spring源码解析之 17缓存中获取单例bean</h1><p>从这篇博客开始我们开始加载 bean 的第一个步骤，从缓存中获取 bean，代码片段如下：<br><a id=\"more\"></a></p>\n<pre><code class=\"java\">        Object sharedInstance = getSingleton(beanName);\n        if (sharedInstance != null &amp;&amp; args == null) {\n            if (logger.isDebugEnabled()) {\n                if (isSingletonCurrentlyInCreation(beanName)) {\n                    logger.debug(&quot;Returning eagerly cached instance of singleton \n                                 bean &#39;&quot; + beanName +\n                            &quot;&#39; that is not fully initialized yet - \n                                 a consequence of a circular reference&quot;);\n                }\n                else {\n                    logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; \n                                 + beanName + &quot;&#39;&quot;);\n                }\n            }\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n        }\n</code></pre>\n<p>首先调用 <code>getSingleton()</code> 从缓存中获取 bean，在上篇博客提到过，Spring 对单例模式的 bean 只会创建一次，后续如果再获取该 bean 则是直接从单例缓存中获取，该过程就体现在 <code>getSingleton()</code> 中。如下：</p>\n<pre><code class=\"java\">    public Object getSingleton(String beanName) {\n        // 参数true设置表示允许早期依赖\n        return getSingleton(beanName, true);\n    }\n\n   @Nullable\n    protected Object getSingleton(String beanName, boolean allowEarlyReference) {\n        // 检查缓存中是否存在实例\n        Object singletonObject = this.singletonObjects.get(beanName);\n        // 如果为空，并且正在创建这个bean，则锁定全局变量并进行处理\n        if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {\n            // 锁住已经实例化Bean的全局变量，防止出现线程安全问题，\n            // 也就是有另外的线程在创建这个bean，这可以阻塞住当期线程，等待另外一个线程创建完成\n            synchronized (this.singletonObjects) {\n                // 此处是用来获取正在创建过程中bean，此处可能是没有创建完全的bean，也就是没有\n                // 进行依赖注入等操作的bean\n                singletonObject = this.earlySingletonObjects.get(beanName);\n                // 如果没有正在创建，并且允许提前引用，则进行创建bean，但没有实例化完整的bean\n                if (singletonObject == null &amp;&amp; allowEarlyReference) {\n                    // 当某些方法需要提前初始化的时候会调用addSingletonFactory方法将对应的\n                    // ObjectFactory初始化策略存储在singletonFactories\n                    // 获取对应的bean的factoryBean,\n                    ObjectFactory&lt;?&gt; singletonFactory = \n                        this.singletonFactories.get(beanName);\n                    // 如果创建bean的ObjectFactory不为空，则创建对应的对象\n                    if (singletonFactory != null) {\n                        // 调用预先设定的getObject方法\n                        singletonObject = singletonFactory.getObject();\n                        //记录在缓存中earlySingletonObjects和singletonFactories互斥\n                        // 这一点可以这样理解如果你用ObjectFactory提前创建了一个对象，\n                        // 而此对象是单例的，因此你应该将创建的这个对象放到单例对象缓存队列中\n                        // 另外删除这个创建对象的工厂，因为不能在创建此对象，否则就不是单例。\n                        this.earlySingletonObjects.put(beanName, singletonObject);\n                        this.singletonFactories.remove(beanName);\n                    }\n                }\n            }\n        }\n        // 从上面的过程可以看出此处的bean可能是没有创建完成的bean\n        return singletonObject;\n    }\n</code></pre>\n<p>这段代码非常简单，首先从 singletonObjects 中获取，若为空且当前 bean 正在创建中，则从 earlySingletonObjects 中获取，若为空且允许提前创建则从 singletonFactories 中获取相应的 ObjectFactory ，若不为空，则调用其 <code>getObject()</code>创建 bean，然后将其加入到 earlySingletonObjects，然后从 singletonFactories 删除。总体逻辑就是根据 beanName 依次检测这三个 Map，若为空，从下一个，否则返回。这三个 Map 存放的都有各自的功能，如下：</p>\n<ul>\n<li>singletonObjects ：存放的是单例 bean，对应关系为 <code>bean name --&gt; bean instance</code></li>\n<li>earlySingletonObjects：存放的是早期的 bean，对应关系也是 <code>bean name --&gt; bean instance</code>。它与 singletonObjects 区别在于 earlySingletonObjects 中存放的 bean 不一定是完整的，从上面过程中我们可以了解，bean 在创建过程中就已经加入到 earlySingletonObjects 中了，所以当在 bean 的创建过程中就可以通过 <code>getBean()</code> 方法获取。这个 Map 也是解决循环依赖的关键所在。</li>\n<li>singletonFactories：存放的是 ObjectFactory，可以理解为创建单例 bean 的 factory，对应关系是 <code>bean name --&gt; ObjectFactory</code></li>\n<li>registeredSingletons:这个是用于保存所有已经注册的bean，这里先提前讲，后面会用到</li>\n</ul>\n<p>在上面代码中还有一个非常重要的检测方法 <code>isSingletonCurrentlyInCreation(beanName)</code>，该方法用于判断该 beanName 对应的 bean 是否在创建过程中，注意这个过程讲的是整个工厂中。如下：</p>\n<pre><code class=\"java\">    public boolean isSingletonCurrentlyInCreation(String beanName) {\n        return this.singletonsCurrentlyInCreation.contains(beanName);\n    }\n</code></pre>\n<p>从这段代码中我们可以预测，在 bean 创建过程中都会将其加入到 singletonsCurrentlyInCreation 集合中，具体是在什么时候加的，我们后面分析。</p>\n<p>到这里从缓存中获取 bean 的过程已经分析完毕了，我们再看开篇的代码段，从缓存中获取 bean 后，若其不为 null 且 args 为空，则会调用 <code>getObjectForBeanInstance()</code> 处理。为什么会有这么一段呢？因为我们从缓存中获取的 bean 是最原始的 bean 并不一定使我们最终想要的 bean，怎么办呢？调用 <code>getObjectForBeanInstance()</code> 进行处理，该方法的定义为获取给定 bean 实例的对象，该对象要么是 bean 实例本身，要么就是 FactoryBean 创建的对象，如下：</p>\n<pre><code class=\"java\">   protected Object getObjectForBeanInstance(\n            Object beanInstance, String name, String beanName,\n                   @Nullable RootBeanDefinition mbd) {\n\n        // 若为工厂类引用（name 以 &amp; 开头）\n        if (BeanFactoryUtils.isFactoryDereference(name)) {\n            // 如果是 NullBean，则直接返回\n            if (beanInstance instanceof NullBean) {\n                return beanInstance;\n            }\n            // 如果 beanInstance 不是 FactoryBean 类型，则抛出异常\n            if (!(beanInstance instanceof FactoryBean)) {\n                throw new BeanIsNotAFactoryException(transformedBeanName(name), \n                                                     beanInstance.getClass());\n            }\n        }\n\n        // 到这里我们就有了一个 bean 实例，当然该实例可能是会是是\n       // 一个正常的 bean 又或者是一个 FactoryBean\n        // 如果是 FactoryBean，我们则创建该 bean\n        if (!(beanInstance instanceof FactoryBean) || \n            BeanFactoryUtils.isFactoryDereference(name)) {\n            return beanInstance;\n        }\n\n        // 加载 FactoryBean\n        Object object = null;\n        // 若 BeanDefinition 为 null，则从缓存中加载\n        if (mbd == null) {\n            object = getCachedObjectForFactoryBean(beanName);\n        }\n        // 若 object 依然为空，则可以确认，beanInstance 一定是 FactoryBean\n        if (object == null) {\n            // 到这里已经确定beanInstance是FactoryBean类型，强转\n            FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;\n            if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) {\n                // 将存在XML配置文件的GernericBeanDefinition转换为RootBeanDefinition\n                // 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n                mbd = getMergedLocalBeanDefinition(beanName);\n            }\n            // 是否是用户定义的而不是应用程序本身定义的\n            boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());\n            // 核心处理类\n            object = getObjectFromFactoryBean(factory, beanName, !synthetic);\n        }\n        return object;\n    }\n</code></pre>\n<p>该方法主要是进行检测工作的，主要如下：</p>\n<ul>\n<li>若 name 为工厂相关的（以 &amp; 开头），且 beanInstance 为 NullBean 类型则直接返回，如果 beanInstance 不为 FactoryBean 类型则抛出 BeanIsNotFactoryException 异常。这里主要是校验 beanInstance 的正确性。</li>\n<li>如果 beanInstance 不为 FactoryBean 类型或者 name 也不是与工厂相关的，则直接返回。这里主要是对非 FactoryBean 类型处理。</li>\n<li>如果 BeanDefinition 为空，则从 factoryBeanObjectCache 中加载，如果还是空，则可以断定 beanInstance 一定是 FactoryBean 类型，则委托 <code>getObjectFromFactoryBean()</code> 方法处理</li>\n</ul>\n<p>再继续分析<code>getObjectFromFactoryBean</code>之前，我们先介绍一下FactoryBean，感觉很相似，因为我们前面经常说BeanFactory，简单说一下他们的区别。 BeanFactory和FactoryBean其实没有什么比较性的，只是两者的名称特别接近，所以有时候会拿出来比较一番，BeanFactory是提供了IOC容器最基本的形式，给具体的IOC容器的实现提供了规范，FactoryBean可以说为IOC容器中Bean的实现提供了更加灵活的方式，FactoryBean在IOC容器的基础上给Bean的实现加上了一个简单工厂模式和装饰模式，我们可以在getObject()方法中灵活配置。具体的可以看这篇文章<a href=\"https://blog.csdn.net/wangbiao007/article/details/53183764\" target=\"_blank\" rel=\"noopener\">BeanFactory和FactoryBean的区别</a></p>\n<p>从上面可以看出 <code>getObjectForBeanInstance()</code> 主要是返回给定的 bean 实例对象，当然该实例对象为非 FactoryBean 类型，对于 FactoryBean 类型的 bean，则是委托 <code>getObjectFromFactoryBean()</code> 从 FactoryBean 获取 bean 实例对象。</p>\n<pre><code class=\"java\">   protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory,\n                                             String beanName,\n                                             boolean shouldPostProcess) {\n           // 如果此BeanName对应的FactoryBean是单例bean，\n        // beanName对应的bean是单例对象\n        if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) {\n\n            synchronized (getSingletonMutex()) {\n                // 从缓存中获取指定的 factoryBean\n                Object object = this.factoryBeanObjectCache.get(beanName);\n\n                if (object == null) {\n                    // 为空，则从 FactoryBean 中获取对象\n                    object = doGetObjectFromFactoryBean(factory, beanName);\n\n                    // 从缓存中获取\n                    Object alreadyThere = this.factoryBeanObjectCache.get(beanName);\n                    // 下面这种情况是为了避免由于循环引用导致提前创建了一个一样的bean\n                    // 为了一致，则抛弃当前的bean，有点类似于CAS的处理\n                    if (alreadyThere != null) {\n                        object = alreadyThere;\n                    } else {\n                        // 需要后续处理\n                        if (shouldPostProcess) {\n                        // 若该 bean 处于创建中，则直接返回对象，而非继续处理对象，而不是存储它\n\n                            if (isSingletonCurrentlyInCreation(beanName)) {\n                                return object;\n                            }\n                            // 前置处理\n                            beforeSingletonCreation(beanName);\n                            try {\n                                // 对从 FactoryBean 获取的对象进行后处理\n                                // 生成的对象将暴露给bean引用\n                                object = postProcessObjectFromFactoryBean(object, \n                                                                          beanName);\n                            }\n                            catch (Throwable ex) {\n                                throw new BeanCreationException(beanName,\n                                        &quot;Post-processing of FactoryBean&#39;s \n                                         singleton object failed&quot;, ex);\n                            }\n                            finally {\n                                // 后置处理\n                                afterSingletonCreation(beanName);\n                            }\n                        }\n                        // 缓存\n                        if (containsSingleton(beanName)) {\n                            this.factoryBeanObjectCache.put(beanName, object);\n                        }\n                    }\n                }\n                return object;\n            }\n        }\n        else {\n            // 非单例\n            Object object = doGetObjectFromFactoryBean(factory, beanName);\n            if (shouldPostProcess) {\n                try {\n                    object = postProcessObjectFromFactoryBean(object, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(beanName, \n                        &quot;Post-processing of FactoryBean&#39;s object failed&quot;, ex);\n                }\n            }\n            return object;\n        }\n    }\n</code></pre>\n<p>主要流程如下：</p>\n<ul>\n<li>若为单例且单例 bean 缓存中存在 beanName，则进行后续处理（跳转到下一步），否则则从 FactoryBean 中获取 bean 实例对象，如果接受后置处理，则调用 <code>postProcessObjectFromFactoryBean()</code> 进行后置处理。</li>\n<li>首先获取锁（其实我们在前面篇幅中发现了大量的同步锁，锁住的对象都是 this.singletonObjects， 主要是因为在单例模式中必须要保证全局唯一），然后从 factoryBeanObjectCache 缓存中获取实例对象 object，若 object 为空，则调用 <code>doGetObjectFromFactoryBean()</code> 方法从 FactoryBean 获取对象，其实内部就是调用 <code>FactoryBean.getObject()</code>。</li>\n<li>如果需要后续处理，则进行进一步处理，步骤如下：<ul>\n<li>若该 bean 处于创建中（isSingletonCurrentlyInCreation），则返回非处理对象，而不是存储它。这个是因为后面即将讲到的循环依赖所以你的，由于bean之间的依赖，会造成一些bean还没有初始化完成就提前创建出该对象的ObjectFactory对象，然后来生成对应bean，让正在创建的bean创建能继续处理，这里先理解个大概，后面会仔细说。</li>\n<li>调用 <code>beforeSingletonCreation()</code> 进行创建之前的处理。默认实现将该 bean 标志为当前创建的。</li>\n<li>调用 <code>postProcessObjectFromFactoryBean()</code> 对从 FactoryBean 获取的 bean 实例对象进行后置处理，默认实现是按照原样直接返回，具体实现是在 AbstractAutowireCapableBeanFactory 中实现的，当然子类也可以重写它，比如应用后置处理</li>\n<li>调用 <code>afterSingletonCreation()</code> 进行创建 bean 之后的处理，默认实现是将该 bean 标记为不再在创建中。</li>\n</ul>\n</li>\n<li>最后加入到 FactoryBeans 缓存中。</li>\n</ul>\n<p>该方法应该就是创建 bean 实例对象中的核心方法之一了。这里我们关注三个方法：<code>beforeSingletonCreation()</code> 、 <code>afterSingletonCreation()</code> 、 <code>postProcessObjectFromFactoryBean()</code>。可能有小伙伴觉得前面两个方法不是很重要，可以肯定告诉你，这两方法是非常重要的操作，因为<strong>他们记录着 bean 的加载状态，是检测当前 bean 是否处于创建中的关键之处，对解决 bean 循环依赖起着关键作用</strong>。before 方法用于标志当前 bean 处于创建中，after 则是移除。其实在这篇博客刚刚开始就已经提到了 <code>isSingletonCurrentlyInCreation()</code> 是用于检测当前 bean 是否处于创建之中，如下：</p>\n<pre><code class=\"java\">    public boolean isSingletonCurrentlyInCreation(String beanName) {\n        return this.singletonsCurrentlyInCreation.contains(beanName);\n    }\n</code></pre>\n<p>是根据 singletonsCurrentlyInCreation 集合中是否包含了 beanName，集合的元素则一定是在 <code>beforeSingletonCreation()</code> 中添加的，如下：</p>\n<pre><code class=\"java\">    protected void beforeSingletonCreation(String beanName) {\n        if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; \n            !this.singletonsCurrentlyInCreation.add(beanName)) {\n            throw new BeanCurrentlyInCreationException(beanName);\n        }\n    }\n</code></pre>\n<p><code>afterSingletonCreation()</code> 为移除，则一定就是对 singletonsCurrentlyInCreation 集合 remove 了，如下：</p>\n<pre><code class=\"java\">    protected void afterSingletonCreation(String beanName) {\n        if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; \n            !this.singletonsCurrentlyInCreation.remove(beanName)) {\n            throw new IllegalStateException(&quot;Singleton &#39;&quot; +\n                                            beanName + &quot;&#39; isn&#39;t currently in creation&quot;);\n        }\n    }\n</code></pre>\n<p><code>postProcessObjectFromFactoryBean()</code> 是对从 FactoryBean 处获取的 bean 实例对象进行后置处理，其默认实现是直接返回 object 对象，不做任何处理，子类可以重写，例如应用后处理器。AbstractAutowireCapableBeanFactory 对其提供了实现，如下：</p>\n<pre><code class=\"java\">    protected Object postProcessObjectFromFactoryBean(Object object, String beanName) {\n        return applyBeanPostProcessorsAfterInitialization(object, beanName);\n    }\n</code></pre>\n<p>该方法的定义为：对所有的 postProcessAfterInitialization 进行回调注册 BeanPostProcessors，让他们能够后期处理从 FactoryBean 中获取的对象。下面是具体实现：</p>\n<pre><code class=\"java\">    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, \n                                                             String beanName)\n            throws BeansException {\n\n        Object result = existingBean;\n        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n            Object current = \n                beanProcessor.postProcessAfterInitialization(result, beanName);\n            if (current == null) {\n                return result;\n            }\n            result = current;\n        }\n        return result;\n    }\n</code></pre>\n<p>对于后置处理器，这里我们不做过多阐述，后面会专门的博文进行详细介绍，这里我们只需要记住一点：尽可能保证所有 bean 初始化后都会调用注册的 <code>BeanPostProcessor.postProcessAfterInitialization()</code> 方法进行处理，在实际开发过程中大可以针对此特性设计自己的业务逻辑。</p>\n<p>至此，从缓存中获取 bean 对象过程已经分析完毕了。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-17缓存中获取单例bean\"><a href=\"#spring源码解析之-17缓存中获取单例bean\" class=\"headerlink\" title=\"spring源码解析之 17缓存中获取单例bean\"></a>spring源码解析之 17缓存中获取单例bean</h1><p>从这篇博客开始我们开始加载 bean 的第一个步骤，从缓存中获取 bean，代码片段如下：<br>","more":"</p>\n<pre><code class=\"java\">        Object sharedInstance = getSingleton(beanName);\n        if (sharedInstance != null &amp;&amp; args == null) {\n            if (logger.isDebugEnabled()) {\n                if (isSingletonCurrentlyInCreation(beanName)) {\n                    logger.debug(&quot;Returning eagerly cached instance of singleton \n                                 bean &#39;&quot; + beanName +\n                            &quot;&#39; that is not fully initialized yet - \n                                 a consequence of a circular reference&quot;);\n                }\n                else {\n                    logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; \n                                 + beanName + &quot;&#39;&quot;);\n                }\n            }\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n        }\n</code></pre>\n<p>首先调用 <code>getSingleton()</code> 从缓存中获取 bean，在上篇博客提到过，Spring 对单例模式的 bean 只会创建一次，后续如果再获取该 bean 则是直接从单例缓存中获取，该过程就体现在 <code>getSingleton()</code> 中。如下：</p>\n<pre><code class=\"java\">    public Object getSingleton(String beanName) {\n        // 参数true设置表示允许早期依赖\n        return getSingleton(beanName, true);\n    }\n\n   @Nullable\n    protected Object getSingleton(String beanName, boolean allowEarlyReference) {\n        // 检查缓存中是否存在实例\n        Object singletonObject = this.singletonObjects.get(beanName);\n        // 如果为空，并且正在创建这个bean，则锁定全局变量并进行处理\n        if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {\n            // 锁住已经实例化Bean的全局变量，防止出现线程安全问题，\n            // 也就是有另外的线程在创建这个bean，这可以阻塞住当期线程，等待另外一个线程创建完成\n            synchronized (this.singletonObjects) {\n                // 此处是用来获取正在创建过程中bean，此处可能是没有创建完全的bean，也就是没有\n                // 进行依赖注入等操作的bean\n                singletonObject = this.earlySingletonObjects.get(beanName);\n                // 如果没有正在创建，并且允许提前引用，则进行创建bean，但没有实例化完整的bean\n                if (singletonObject == null &amp;&amp; allowEarlyReference) {\n                    // 当某些方法需要提前初始化的时候会调用addSingletonFactory方法将对应的\n                    // ObjectFactory初始化策略存储在singletonFactories\n                    // 获取对应的bean的factoryBean,\n                    ObjectFactory&lt;?&gt; singletonFactory = \n                        this.singletonFactories.get(beanName);\n                    // 如果创建bean的ObjectFactory不为空，则创建对应的对象\n                    if (singletonFactory != null) {\n                        // 调用预先设定的getObject方法\n                        singletonObject = singletonFactory.getObject();\n                        //记录在缓存中earlySingletonObjects和singletonFactories互斥\n                        // 这一点可以这样理解如果你用ObjectFactory提前创建了一个对象，\n                        // 而此对象是单例的，因此你应该将创建的这个对象放到单例对象缓存队列中\n                        // 另外删除这个创建对象的工厂，因为不能在创建此对象，否则就不是单例。\n                        this.earlySingletonObjects.put(beanName, singletonObject);\n                        this.singletonFactories.remove(beanName);\n                    }\n                }\n            }\n        }\n        // 从上面的过程可以看出此处的bean可能是没有创建完成的bean\n        return singletonObject;\n    }\n</code></pre>\n<p>这段代码非常简单，首先从 singletonObjects 中获取，若为空且当前 bean 正在创建中，则从 earlySingletonObjects 中获取，若为空且允许提前创建则从 singletonFactories 中获取相应的 ObjectFactory ，若不为空，则调用其 <code>getObject()</code>创建 bean，然后将其加入到 earlySingletonObjects，然后从 singletonFactories 删除。总体逻辑就是根据 beanName 依次检测这三个 Map，若为空，从下一个，否则返回。这三个 Map 存放的都有各自的功能，如下：</p>\n<ul>\n<li>singletonObjects ：存放的是单例 bean，对应关系为 <code>bean name --&gt; bean instance</code></li>\n<li>earlySingletonObjects：存放的是早期的 bean，对应关系也是 <code>bean name --&gt; bean instance</code>。它与 singletonObjects 区别在于 earlySingletonObjects 中存放的 bean 不一定是完整的，从上面过程中我们可以了解，bean 在创建过程中就已经加入到 earlySingletonObjects 中了，所以当在 bean 的创建过程中就可以通过 <code>getBean()</code> 方法获取。这个 Map 也是解决循环依赖的关键所在。</li>\n<li>singletonFactories：存放的是 ObjectFactory，可以理解为创建单例 bean 的 factory，对应关系是 <code>bean name --&gt; ObjectFactory</code></li>\n<li>registeredSingletons:这个是用于保存所有已经注册的bean，这里先提前讲，后面会用到</li>\n</ul>\n<p>在上面代码中还有一个非常重要的检测方法 <code>isSingletonCurrentlyInCreation(beanName)</code>，该方法用于判断该 beanName 对应的 bean 是否在创建过程中，注意这个过程讲的是整个工厂中。如下：</p>\n<pre><code class=\"java\">    public boolean isSingletonCurrentlyInCreation(String beanName) {\n        return this.singletonsCurrentlyInCreation.contains(beanName);\n    }\n</code></pre>\n<p>从这段代码中我们可以预测，在 bean 创建过程中都会将其加入到 singletonsCurrentlyInCreation 集合中，具体是在什么时候加的，我们后面分析。</p>\n<p>到这里从缓存中获取 bean 的过程已经分析完毕了，我们再看开篇的代码段，从缓存中获取 bean 后，若其不为 null 且 args 为空，则会调用 <code>getObjectForBeanInstance()</code> 处理。为什么会有这么一段呢？因为我们从缓存中获取的 bean 是最原始的 bean 并不一定使我们最终想要的 bean，怎么办呢？调用 <code>getObjectForBeanInstance()</code> 进行处理，该方法的定义为获取给定 bean 实例的对象，该对象要么是 bean 实例本身，要么就是 FactoryBean 创建的对象，如下：</p>\n<pre><code class=\"java\">   protected Object getObjectForBeanInstance(\n            Object beanInstance, String name, String beanName,\n                   @Nullable RootBeanDefinition mbd) {\n\n        // 若为工厂类引用（name 以 &amp; 开头）\n        if (BeanFactoryUtils.isFactoryDereference(name)) {\n            // 如果是 NullBean，则直接返回\n            if (beanInstance instanceof NullBean) {\n                return beanInstance;\n            }\n            // 如果 beanInstance 不是 FactoryBean 类型，则抛出异常\n            if (!(beanInstance instanceof FactoryBean)) {\n                throw new BeanIsNotAFactoryException(transformedBeanName(name), \n                                                     beanInstance.getClass());\n            }\n        }\n\n        // 到这里我们就有了一个 bean 实例，当然该实例可能是会是是\n       // 一个正常的 bean 又或者是一个 FactoryBean\n        // 如果是 FactoryBean，我们则创建该 bean\n        if (!(beanInstance instanceof FactoryBean) || \n            BeanFactoryUtils.isFactoryDereference(name)) {\n            return beanInstance;\n        }\n\n        // 加载 FactoryBean\n        Object object = null;\n        // 若 BeanDefinition 为 null，则从缓存中加载\n        if (mbd == null) {\n            object = getCachedObjectForFactoryBean(beanName);\n        }\n        // 若 object 依然为空，则可以确认，beanInstance 一定是 FactoryBean\n        if (object == null) {\n            // 到这里已经确定beanInstance是FactoryBean类型，强转\n            FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;\n            if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) {\n                // 将存在XML配置文件的GernericBeanDefinition转换为RootBeanDefinition\n                // 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n                mbd = getMergedLocalBeanDefinition(beanName);\n            }\n            // 是否是用户定义的而不是应用程序本身定义的\n            boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());\n            // 核心处理类\n            object = getObjectFromFactoryBean(factory, beanName, !synthetic);\n        }\n        return object;\n    }\n</code></pre>\n<p>该方法主要是进行检测工作的，主要如下：</p>\n<ul>\n<li>若 name 为工厂相关的（以 &amp; 开头），且 beanInstance 为 NullBean 类型则直接返回，如果 beanInstance 不为 FactoryBean 类型则抛出 BeanIsNotFactoryException 异常。这里主要是校验 beanInstance 的正确性。</li>\n<li>如果 beanInstance 不为 FactoryBean 类型或者 name 也不是与工厂相关的，则直接返回。这里主要是对非 FactoryBean 类型处理。</li>\n<li>如果 BeanDefinition 为空，则从 factoryBeanObjectCache 中加载，如果还是空，则可以断定 beanInstance 一定是 FactoryBean 类型，则委托 <code>getObjectFromFactoryBean()</code> 方法处理</li>\n</ul>\n<p>再继续分析<code>getObjectFromFactoryBean</code>之前，我们先介绍一下FactoryBean，感觉很相似，因为我们前面经常说BeanFactory，简单说一下他们的区别。 BeanFactory和FactoryBean其实没有什么比较性的，只是两者的名称特别接近，所以有时候会拿出来比较一番，BeanFactory是提供了IOC容器最基本的形式，给具体的IOC容器的实现提供了规范，FactoryBean可以说为IOC容器中Bean的实现提供了更加灵活的方式，FactoryBean在IOC容器的基础上给Bean的实现加上了一个简单工厂模式和装饰模式，我们可以在getObject()方法中灵活配置。具体的可以看这篇文章<a href=\"https://blog.csdn.net/wangbiao007/article/details/53183764\" target=\"_blank\" rel=\"noopener\">BeanFactory和FactoryBean的区别</a></p>\n<p>从上面可以看出 <code>getObjectForBeanInstance()</code> 主要是返回给定的 bean 实例对象，当然该实例对象为非 FactoryBean 类型，对于 FactoryBean 类型的 bean，则是委托 <code>getObjectFromFactoryBean()</code> 从 FactoryBean 获取 bean 实例对象。</p>\n<pre><code class=\"java\">   protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory,\n                                             String beanName,\n                                             boolean shouldPostProcess) {\n           // 如果此BeanName对应的FactoryBean是单例bean，\n        // beanName对应的bean是单例对象\n        if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) {\n\n            synchronized (getSingletonMutex()) {\n                // 从缓存中获取指定的 factoryBean\n                Object object = this.factoryBeanObjectCache.get(beanName);\n\n                if (object == null) {\n                    // 为空，则从 FactoryBean 中获取对象\n                    object = doGetObjectFromFactoryBean(factory, beanName);\n\n                    // 从缓存中获取\n                    Object alreadyThere = this.factoryBeanObjectCache.get(beanName);\n                    // 下面这种情况是为了避免由于循环引用导致提前创建了一个一样的bean\n                    // 为了一致，则抛弃当前的bean，有点类似于CAS的处理\n                    if (alreadyThere != null) {\n                        object = alreadyThere;\n                    } else {\n                        // 需要后续处理\n                        if (shouldPostProcess) {\n                        // 若该 bean 处于创建中，则直接返回对象，而非继续处理对象，而不是存储它\n\n                            if (isSingletonCurrentlyInCreation(beanName)) {\n                                return object;\n                            }\n                            // 前置处理\n                            beforeSingletonCreation(beanName);\n                            try {\n                                // 对从 FactoryBean 获取的对象进行后处理\n                                // 生成的对象将暴露给bean引用\n                                object = postProcessObjectFromFactoryBean(object, \n                                                                          beanName);\n                            }\n                            catch (Throwable ex) {\n                                throw new BeanCreationException(beanName,\n                                        &quot;Post-processing of FactoryBean&#39;s \n                                         singleton object failed&quot;, ex);\n                            }\n                            finally {\n                                // 后置处理\n                                afterSingletonCreation(beanName);\n                            }\n                        }\n                        // 缓存\n                        if (containsSingleton(beanName)) {\n                            this.factoryBeanObjectCache.put(beanName, object);\n                        }\n                    }\n                }\n                return object;\n            }\n        }\n        else {\n            // 非单例\n            Object object = doGetObjectFromFactoryBean(factory, beanName);\n            if (shouldPostProcess) {\n                try {\n                    object = postProcessObjectFromFactoryBean(object, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(beanName, \n                        &quot;Post-processing of FactoryBean&#39;s object failed&quot;, ex);\n                }\n            }\n            return object;\n        }\n    }\n</code></pre>\n<p>主要流程如下：</p>\n<ul>\n<li>若为单例且单例 bean 缓存中存在 beanName，则进行后续处理（跳转到下一步），否则则从 FactoryBean 中获取 bean 实例对象，如果接受后置处理，则调用 <code>postProcessObjectFromFactoryBean()</code> 进行后置处理。</li>\n<li>首先获取锁（其实我们在前面篇幅中发现了大量的同步锁，锁住的对象都是 this.singletonObjects， 主要是因为在单例模式中必须要保证全局唯一），然后从 factoryBeanObjectCache 缓存中获取实例对象 object，若 object 为空，则调用 <code>doGetObjectFromFactoryBean()</code> 方法从 FactoryBean 获取对象，其实内部就是调用 <code>FactoryBean.getObject()</code>。</li>\n<li>如果需要后续处理，则进行进一步处理，步骤如下：<ul>\n<li>若该 bean 处于创建中（isSingletonCurrentlyInCreation），则返回非处理对象，而不是存储它。这个是因为后面即将讲到的循环依赖所以你的，由于bean之间的依赖，会造成一些bean还没有初始化完成就提前创建出该对象的ObjectFactory对象，然后来生成对应bean，让正在创建的bean创建能继续处理，这里先理解个大概，后面会仔细说。</li>\n<li>调用 <code>beforeSingletonCreation()</code> 进行创建之前的处理。默认实现将该 bean 标志为当前创建的。</li>\n<li>调用 <code>postProcessObjectFromFactoryBean()</code> 对从 FactoryBean 获取的 bean 实例对象进行后置处理，默认实现是按照原样直接返回，具体实现是在 AbstractAutowireCapableBeanFactory 中实现的，当然子类也可以重写它，比如应用后置处理</li>\n<li>调用 <code>afterSingletonCreation()</code> 进行创建 bean 之后的处理，默认实现是将该 bean 标记为不再在创建中。</li>\n</ul>\n</li>\n<li>最后加入到 FactoryBeans 缓存中。</li>\n</ul>\n<p>该方法应该就是创建 bean 实例对象中的核心方法之一了。这里我们关注三个方法：<code>beforeSingletonCreation()</code> 、 <code>afterSingletonCreation()</code> 、 <code>postProcessObjectFromFactoryBean()</code>。可能有小伙伴觉得前面两个方法不是很重要，可以肯定告诉你，这两方法是非常重要的操作，因为<strong>他们记录着 bean 的加载状态，是检测当前 bean 是否处于创建中的关键之处，对解决 bean 循环依赖起着关键作用</strong>。before 方法用于标志当前 bean 处于创建中，after 则是移除。其实在这篇博客刚刚开始就已经提到了 <code>isSingletonCurrentlyInCreation()</code> 是用于检测当前 bean 是否处于创建之中，如下：</p>\n<pre><code class=\"java\">    public boolean isSingletonCurrentlyInCreation(String beanName) {\n        return this.singletonsCurrentlyInCreation.contains(beanName);\n    }\n</code></pre>\n<p>是根据 singletonsCurrentlyInCreation 集合中是否包含了 beanName，集合的元素则一定是在 <code>beforeSingletonCreation()</code> 中添加的，如下：</p>\n<pre><code class=\"java\">    protected void beforeSingletonCreation(String beanName) {\n        if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; \n            !this.singletonsCurrentlyInCreation.add(beanName)) {\n            throw new BeanCurrentlyInCreationException(beanName);\n        }\n    }\n</code></pre>\n<p><code>afterSingletonCreation()</code> 为移除，则一定就是对 singletonsCurrentlyInCreation 集合 remove 了，如下：</p>\n<pre><code class=\"java\">    protected void afterSingletonCreation(String beanName) {\n        if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; \n            !this.singletonsCurrentlyInCreation.remove(beanName)) {\n            throw new IllegalStateException(&quot;Singleton &#39;&quot; +\n                                            beanName + &quot;&#39; isn&#39;t currently in creation&quot;);\n        }\n    }\n</code></pre>\n<p><code>postProcessObjectFromFactoryBean()</code> 是对从 FactoryBean 处获取的 bean 实例对象进行后置处理，其默认实现是直接返回 object 对象，不做任何处理，子类可以重写，例如应用后处理器。AbstractAutowireCapableBeanFactory 对其提供了实现，如下：</p>\n<pre><code class=\"java\">    protected Object postProcessObjectFromFactoryBean(Object object, String beanName) {\n        return applyBeanPostProcessorsAfterInitialization(object, beanName);\n    }\n</code></pre>\n<p>该方法的定义为：对所有的 postProcessAfterInitialization 进行回调注册 BeanPostProcessors，让他们能够后期处理从 FactoryBean 中获取的对象。下面是具体实现：</p>\n<pre><code class=\"java\">    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, \n                                                             String beanName)\n            throws BeansException {\n\n        Object result = existingBean;\n        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n            Object current = \n                beanProcessor.postProcessAfterInitialization(result, beanName);\n            if (current == null) {\n                return result;\n            }\n            result = current;\n        }\n        return result;\n    }\n</code></pre>\n<p>对于后置处理器，这里我们不做过多阐述，后面会专门的博文进行详细介绍，这里我们只需要记住一点：尽可能保证所有 bean 初始化后都会调用注册的 <code>BeanPostProcessor.postProcessAfterInitialization()</code> 方法进行处理，在实际开发过程中大可以针对此特性设计自己的业务逻辑。</p>\n<p>至此，从缓存中获取 bean 对象过程已经分析完毕了。</p>"},{"abbrlink":43,"title":"spring源码解析之 20 开启bean的实例化进程","author":"fengxiutianya","date":"2019-01-14T19:34:00.000Z","_content":"# spring源码解析之 20 开启bean的实例化进程\n\n在上篇博客中有一个核心方法没有讲到 `createBean()` ，该方法的如下：\n\n```java\nprotected abstract Object createBean(String beanName, RootBeanDefinition mbd, \n              @Nullable Object[] args) throws BeanCreationException;\n```\n\n该方法定义在 AbstractBeanFactory 中。其含义是根据给定的 BeanDefinition 和 args实例化一个 bean 对象，如果该 BeanDefinition 存在父类，则该 BeanDefinition 已经合并了父类的属性。所有 Bean 实例的创建都会委托给该方法实现。\n<!-- more -->\n\n方法接受三个参数：\n\n- beanName：bean 的名字\n- mbd：已经合并了父类属性的（如果有的话）BeanDefinition\n- args：用于构造函数或者工厂方法创建 bean 实例对象的参数\n\n该抽象方法的默认实现是在类 AbstractAutowireCapableBeanFactory 中实现，如下：\n\n```java\n   protected Object createBean(String beanName, RootBeanDefinition mbd, \n                               @Nullable Object[] args)\n            throws BeanCreationException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Creating instance of bean '\" + beanName + \"'\");\n        }\n        RootBeanDefinition mbdToUse = mbd;\n\n        // 确保此时的 bean 已经被解析了\n        // 如果获取的class 属性不为null，则克隆该 BeanDefinition\n        // 主要是因为该动态解析的 class 无法保存到到共享的 BeanDefinition\n        Class<?> resolvedClass = resolveBeanClass(mbd, beanName);\n        if (resolvedClass != null && !mbd.hasBeanClass() \n            && mbd.getBeanClassName() != null) {\n            mbdToUse = new RootBeanDefinition(mbd);\n            mbdToUse.setBeanClass(resolvedClass);\n        }\n\n        try {\n            // 对override属性进行标记以及验证\n\t\t\t// 这里用来判断一个类中如果存在若干个重载方法，那么在函数调用以及增强的时候\n\t\t\t// 还需要根据参数类型进行匹配，来最终确认当前调用的到底是哪个函数。\n\t\t\t// 但是如果只有一个，那么就设置该方法没有重载，这个后续调用的时候可以直接使用\n\t\t\t// 找到该方法，而不需要进行方法参数匹配。\n            mbdToUse.prepareMethodOverrides();\n        }\n        catch (BeanDefinitionValidationException ex) {\n            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n                    beanName, \"Validation of method overrides failed\", ex);\n        }\n\n        try {\n            // 这个方法的作用是实例化对象之前进行前置处理\n            // AOP 的功能就是基于这个地方\n            Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n            // 如果代理对象不为空，则直接返回代理对象，这一步骤有非常重要的作用，\n\t\t\t// Spring 后续实现 AOP 就是基于这个地方判断的。\n            if (bean != null) {\n                return bean;\n            }\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(mbdToUse.getResourceDescription(), \n                                            beanName,\n                    \"BeanPostProcessor before instantiation of bean failed\", ex);\n        }\n\n        try {\n            // 执行真正创建 bean 的过程\n            Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\");\n            }\n            return beanInstance;\n        }\n        catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {\n            throw ex;\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(\n                    mbdToUse.getResourceDescription(), beanName, \n                \"Unexpected exception during bean creation\", ex);\n        }\n    }\n```\n\n过程如下：\n\n- 根据设置的class属性或者根据className来解析class\n- 处理 override 属性进行标记及验证\n- 应用初始化前的处理，解析指定的bean是否存在初始化钱的短路操作，类如后面要说的aop，就会在这里直接初始化一个bean，这后面的操作就不需要进行\n- 创建 bean\n\n**解析指定 BeanDefinition 的 class**\n\n```java\nClass<?> resolvedClass = resolveBeanClass(mbd, beanName)\n```\n\n这个方法主要是解析 bean definition 的 class 类，并将已经解析的 Class 存储在 beandefinition 中以供后面使用。如果解析的 class 不为空，则会将该 BeanDefinition 进行克隆至 mbdToUse，这样做的主要目的是为动态解析的 class 是无法保存到共享的 BeanDefinition 中。\n\n**处理 override 属性**\n\n大家还记得 lookup-method 和 replace-method 这两个配置功能？在前面博客中已经详细分析了这两个标签的用法和解析过程，知道解析过程其实就是讲这两个配置存放在 BeanDefinition 中的 methodOverrides 属性中，我们知道在 bean 实例化的过程中如果检测到存在 methodOverrides，则会动态地位为当前 bean 生成代理并使用对应的拦截器为 bean 做增强处理。具体的实现我们后续分析，现在先看 `mbdToUse.prepareMethodOverrides()` 都干了些什么事，如下：\n\n```java\n    public void prepareMethodOverrides() throws BeanDefinitionValidationException {\n        if (hasMethodOverrides()) {\n            Set<MethodOverride> overrides = getMethodOverrides().getOverrides();\n            synchronized (overrides) {\n                for (MethodOverride mo : overrides) {\n                    prepareMethodOverride(mo);\n                }\n            }\n        }\n    }\n```\n\n如果存在 methodOverrides 则获取所有的 override method ，然后通过迭代的方法一次调用 `prepareMethodOverride()`，如下：\n\n```java\n    protected void prepareMethodOverride(MethodOverride mo) \n        throws BeanDefinitionValidationException {\n        int count = ClassUtils.getMethodCountForName(getBeanClass(), \n                                                     mo.getMethodName());\n        //说明没有对应的代理方法\n        if (count == 0) {\n            throw new BeanDefinitionValidationException(\n                    \"Invalid method override: no method with name '\"\n                    + mo.getMethodName() +\n                    \"' on class [\" + getBeanClassName() + \"]\");\n        }\n        else if (count == 1) {\n            mo.setOverloaded(false);\n        }\n    }\n```\n\n根据方法名称从 class 中获取该方法名的个数，如果为 0 则抛出异常，如果 为 1 则设置该重载方法没有被重载。若一个类中存在多个重载方法，则在方法调用的时候还需要根据参数类型来判断到底重载的是哪个方法。在设置重载的时候其实这里做了一个小小优化，那就是当 `count == 1` 时，设置 `overloaded = false`，这样表示该方法没有重载，这样在后续调用的时候便可以直接找到方法而不需要进行方法参数的校验。\n\n诚然，其实 `mbdToUse.prepareMethodOverrides()` 并没有做什么实质性的工作，只是对 methodOverrides 属性做了一些简单的校验而已。\n\n**实例化的前置处理**\n\n`resolveBeforeInstantiation()` 的作用是给 BeanPostProcessors 后置处理器返回一个代理对象的机会，其实在调用该方法之前 Spring 一直都没有创建 bean ，那么这里返回一个 bean 的代理类有什么作用呢？作用体现在后面的 `if` 判断：\n\n```java\nif (bean != null) {\n    return bean;\n}\n```\n\n如果代理对象不为空，则直接返回代理对象，这一步骤有非常重要的作用，Spring 后续实现 AOP 就是基于这个地方判断的。\n\n```java\n    protected Object resolveBeforeInstantiation(String beanName,\n                                                RootBeanDefinition mbd) {\n        Object bean = null;\n        if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n            if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n                Class<?> targetType = determineTargetType(beanName, mbd);\n                if (targetType != null) {\n                    bean = applyBeanPostProcessorsBeforeInstantiation\n                        (targetType, beanName);\n                    if (bean != null) {\n                        bean = applyBeanPostProcessorsAfterInitialization\n                            (bean, beanName);\n                    }\n                }\n            }\n            mbd.beforeInstantiationResolved = (bean != null);\n        }\n        return bean;\n    }\n```\n\n这个方法核心就在于 `applyBeanPostProcessorsBeforeInstantiation()` 和 `applyBeanPostProcessorsAfterInitialization()` 两个方法，before 为实例化前的后处理器应用，after 为实例化后的后处理器应用，由于本文的主题是创建 bean，关于 Bean 的增强处理后续会单独出博文来做详细说明。\n\n**创建 bean**\n\n如果没有代理对象，就只能走常规的路线进行 bean 的创建了，该过程有 `doCreateBean()` 实现，如下：\n\n```java\n   protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, \n                                 final @Nullable Object[] args)\n            throws BeanCreationException {\n\n        // BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，\n       // 获取被包装bean的属性描述器\n        BeanWrapper instanceWrapper = null;\n       \n        // 单例模型，则从未完成的 FactoryBean 缓存中删除\n        if (mbd.isSingleton()) {\n            anceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n        }\n\n           // 根据指定bean使用的对应策略创建新的实例，如：工厂方法、构造函数自动注入，简单完成初始化\n\t\t\t// 实例化bean，将BeanDefinition转换为BeanWrapper\n\t\t\t// 转换是一个复杂的过程，主要有以下步骤：\n\t\t\t// 如果存在工厂方法则使用工厂方法进行初始化。\n\t\t\t// 一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数\n       \t\t//锁定构造函数并进行初始化\n\t\t\t// 如果即不存在工厂方法也不存在带有参数的构造函数，\n           // 则使用默认的构造函数进行bean的实例化。\n        if (instanceWrapper == null) {\n            instanceWrapper = createBeanInstance(beanName, mbd, args);\n        }\n\n        // 包装的实例对象\n        final Object bean = instanceWrapper.getWrappedInstance();\n        // 包装的实例对象的类型\n        Class<?> beanType = instanceWrapper.getWrappedClass();\n        if (beanType != NullBean.class) {\n            mbd.resolvedTargetType = beanType;\n        }\n\n        // 检测是否有后置处理\n        // 如果有后置处理，则允许后置处理修改 BeanDefinition\n        synchronized (mbd.postProcessingLock) {\n            if (!mbd.postProcessed) {\n                try {\n                    // applyMergedBeanDefinitionPostProcessors\n                    // 后置处理修改 BeanDefinition\n                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), \n                                                    beanName,\n                            \"Post-processing of merged bean definition failed\", ex);\n                }\n                mbd.postProcessed = true;\n            }\n        }\n\n        // 解决单例模式的循环依赖\n        // 单例模式 & 运行循环依赖&当前单例 bean 是否正在被创建\n        boolean earlySingletonExposure = (mbd.isSingleton()\n                                          && this.allowCircularReferences &&\n                isSingletonCurrentlyInCreation(beanName));\n        if (earlySingletonExposure) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Eagerly caching bean '\" + beanName +\n                        \"' to allow for resolving potential circular references\");\n            }\n           // 为避免后期循环依赖，可以在bean初始化完成前将创建实例的ObjectFactory键入工厂\n\t\t\t// getEarlyBeanReference的作用\n\t\t\t// 对bean再一次依赖引用，主要应用SmartInstantiationAwareBeanPostProcessor\n\t\t// 其中我们熟知的AOP就是在这里将advice动态植入bean中，若没有则直接返回bean不做任何处理\n            addSingletonFactory(beanName, \n                                () -> getEarlyBeanReference(beanName, mbd, bean));\n        }\n\n        /*\n         * 开始初始化 bean 实例对象\n         */\n        Object exposedObject = bean;\n        try {\n            // 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性\n            // 则会递归初始依赖 bean\n            populateBean(beanName, mbd, instanceWrapper);\n            // 调用初始化方法\n            exposedObject = initializeBean(beanName, exposedObject, mbd);\n        }\n        catch (Throwable ex) {\n            if (ex instanceof BeanCreationException && \n                beanName.equals(((BeanCreationException) ex).getBeanName())) {\n                throw (BeanCreationException) ex;\n            }\n            else {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName,\n                    \"Initialization of bean failed\", ex);\n            }\n        }\n\n        /**\n         * 循环依赖处理\n         */\n        if (earlySingletonExposure) {\n            // 获取 earlySingletonReference\n            Object earlySingletonReference = getSingleton(beanName, false);\n            // 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空\n            if (earlySingletonReference != null) {\n                // 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强\n                if (exposedObject == bean) {\n                    exposedObject = earlySingletonReference;\n                }\n                // 处理依赖\n                else if (!this.allowRawInjectionDespiteWrapping && \n                         hasDependentBean(beanName)) {\n                    String[] dependentBeans = getDependentBeans(beanName);\n                    Set<String> actualDependentBeans =\n                        new LinkedHashSet<>(dependentBeans.length);\n                    for (String dependentBean : dependentBeans) {\n                        if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean))\n                        {\n                            actualDependentBeans.add(dependentBean);\n                        }\n                    }\n                    if (!actualDependentBeans.isEmpty()) {\n                     \t// 省略异常处理\n                    }\n                }\n            }\n        }\n        try {\n            // 注册 bean\n            registerDisposableBeanIfNecessary(beanName, bean, mbd);\n        }\n        catch (BeanDefinitionValidationException ex) {\n    \t\t// 省略异常\n        }\n\n        return exposedObject;\n    }\n```\n\n整体的思路：\n\n1. 如果是单例模式，则清除 factoryBeanInstanceCache 缓存，同时返回 BeanWrapper 实例对象，当然如果存在。\n2. 如果缓存中没有 BeanWrapper 或者不是单例模式，则调用 `createBeanInstance()` 实例化 bean，主要是将 BeanDefinition 转换为 BeanWrapper\n   1. 如果存在工厂方法，则使用工厂方法进行初始化\n   2. 一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数锁定构造函数并进行初始化\n   3. 如果既不存在工厂函数也不存在带有参数的构造器函数则使用默认的构造函数进行bean的实例化\n3.  MergedBeanDefinitionPostProcessor 的应用，Autowired注解正式通过此方法实现注入类型解析\n4. 单例模式的循环依赖处理（后面会重点说到）\n5. 调用 `populateBean()` 进行属性填充。将所有属性填充至 bean 的实例中\n6.  调用 `initializeBean()` 初始化 bean\n7.  依赖检查，在SPring中只解决单例的循环依赖，这一步判断是否有循环依赖，如果抛出异常\n8. 注册 DisposableBean，如果配置了destroy-method。这里需要注册以便于在销毁的时候进行调用。\n\n`doCreateBean()` 完成 bean 的创建和初始化工作，内容太多，这里就只列出整体思路，下文开始将该方法进行拆分进行详细讲解，分布从以下几个方面进行阐述：\n\n- `createBeanInstance()` 实例化 bean\n- `populateBean()` 属性填充\n- 循环依赖的处理\n- `initializeBean()` 初始化 bean","source":"_posts/spring 源码分析/spring/spring源码解析之 20开启bean的实例化进程.md","raw":"abbrlink: 43\ntitle: spring源码解析之 20 开启bean的实例化进程\ntags:\n  - spring源码解析\n  - spring\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-15 03:34:00\n---\n# spring源码解析之 20 开启bean的实例化进程\n\n在上篇博客中有一个核心方法没有讲到 `createBean()` ，该方法的如下：\n\n```java\nprotected abstract Object createBean(String beanName, RootBeanDefinition mbd, \n              @Nullable Object[] args) throws BeanCreationException;\n```\n\n该方法定义在 AbstractBeanFactory 中。其含义是根据给定的 BeanDefinition 和 args实例化一个 bean 对象，如果该 BeanDefinition 存在父类，则该 BeanDefinition 已经合并了父类的属性。所有 Bean 实例的创建都会委托给该方法实现。\n<!-- more -->\n\n方法接受三个参数：\n\n- beanName：bean 的名字\n- mbd：已经合并了父类属性的（如果有的话）BeanDefinition\n- args：用于构造函数或者工厂方法创建 bean 实例对象的参数\n\n该抽象方法的默认实现是在类 AbstractAutowireCapableBeanFactory 中实现，如下：\n\n```java\n   protected Object createBean(String beanName, RootBeanDefinition mbd, \n                               @Nullable Object[] args)\n            throws BeanCreationException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Creating instance of bean '\" + beanName + \"'\");\n        }\n        RootBeanDefinition mbdToUse = mbd;\n\n        // 确保此时的 bean 已经被解析了\n        // 如果获取的class 属性不为null，则克隆该 BeanDefinition\n        // 主要是因为该动态解析的 class 无法保存到到共享的 BeanDefinition\n        Class<?> resolvedClass = resolveBeanClass(mbd, beanName);\n        if (resolvedClass != null && !mbd.hasBeanClass() \n            && mbd.getBeanClassName() != null) {\n            mbdToUse = new RootBeanDefinition(mbd);\n            mbdToUse.setBeanClass(resolvedClass);\n        }\n\n        try {\n            // 对override属性进行标记以及验证\n\t\t\t// 这里用来判断一个类中如果存在若干个重载方法，那么在函数调用以及增强的时候\n\t\t\t// 还需要根据参数类型进行匹配，来最终确认当前调用的到底是哪个函数。\n\t\t\t// 但是如果只有一个，那么就设置该方法没有重载，这个后续调用的时候可以直接使用\n\t\t\t// 找到该方法，而不需要进行方法参数匹配。\n            mbdToUse.prepareMethodOverrides();\n        }\n        catch (BeanDefinitionValidationException ex) {\n            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n                    beanName, \"Validation of method overrides failed\", ex);\n        }\n\n        try {\n            // 这个方法的作用是实例化对象之前进行前置处理\n            // AOP 的功能就是基于这个地方\n            Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n            // 如果代理对象不为空，则直接返回代理对象，这一步骤有非常重要的作用，\n\t\t\t// Spring 后续实现 AOP 就是基于这个地方判断的。\n            if (bean != null) {\n                return bean;\n            }\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(mbdToUse.getResourceDescription(), \n                                            beanName,\n                    \"BeanPostProcessor before instantiation of bean failed\", ex);\n        }\n\n        try {\n            // 执行真正创建 bean 的过程\n            Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\");\n            }\n            return beanInstance;\n        }\n        catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {\n            throw ex;\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(\n                    mbdToUse.getResourceDescription(), beanName, \n                \"Unexpected exception during bean creation\", ex);\n        }\n    }\n```\n\n过程如下：\n\n- 根据设置的class属性或者根据className来解析class\n- 处理 override 属性进行标记及验证\n- 应用初始化前的处理，解析指定的bean是否存在初始化钱的短路操作，类如后面要说的aop，就会在这里直接初始化一个bean，这后面的操作就不需要进行\n- 创建 bean\n\n**解析指定 BeanDefinition 的 class**\n\n```java\nClass<?> resolvedClass = resolveBeanClass(mbd, beanName)\n```\n\n这个方法主要是解析 bean definition 的 class 类，并将已经解析的 Class 存储在 beandefinition 中以供后面使用。如果解析的 class 不为空，则会将该 BeanDefinition 进行克隆至 mbdToUse，这样做的主要目的是为动态解析的 class 是无法保存到共享的 BeanDefinition 中。\n\n**处理 override 属性**\n\n大家还记得 lookup-method 和 replace-method 这两个配置功能？在前面博客中已经详细分析了这两个标签的用法和解析过程，知道解析过程其实就是讲这两个配置存放在 BeanDefinition 中的 methodOverrides 属性中，我们知道在 bean 实例化的过程中如果检测到存在 methodOverrides，则会动态地位为当前 bean 生成代理并使用对应的拦截器为 bean 做增强处理。具体的实现我们后续分析，现在先看 `mbdToUse.prepareMethodOverrides()` 都干了些什么事，如下：\n\n```java\n    public void prepareMethodOverrides() throws BeanDefinitionValidationException {\n        if (hasMethodOverrides()) {\n            Set<MethodOverride> overrides = getMethodOverrides().getOverrides();\n            synchronized (overrides) {\n                for (MethodOverride mo : overrides) {\n                    prepareMethodOverride(mo);\n                }\n            }\n        }\n    }\n```\n\n如果存在 methodOverrides 则获取所有的 override method ，然后通过迭代的方法一次调用 `prepareMethodOverride()`，如下：\n\n```java\n    protected void prepareMethodOverride(MethodOverride mo) \n        throws BeanDefinitionValidationException {\n        int count = ClassUtils.getMethodCountForName(getBeanClass(), \n                                                     mo.getMethodName());\n        //说明没有对应的代理方法\n        if (count == 0) {\n            throw new BeanDefinitionValidationException(\n                    \"Invalid method override: no method with name '\"\n                    + mo.getMethodName() +\n                    \"' on class [\" + getBeanClassName() + \"]\");\n        }\n        else if (count == 1) {\n            mo.setOverloaded(false);\n        }\n    }\n```\n\n根据方法名称从 class 中获取该方法名的个数，如果为 0 则抛出异常，如果 为 1 则设置该重载方法没有被重载。若一个类中存在多个重载方法，则在方法调用的时候还需要根据参数类型来判断到底重载的是哪个方法。在设置重载的时候其实这里做了一个小小优化，那就是当 `count == 1` 时，设置 `overloaded = false`，这样表示该方法没有重载，这样在后续调用的时候便可以直接找到方法而不需要进行方法参数的校验。\n\n诚然，其实 `mbdToUse.prepareMethodOverrides()` 并没有做什么实质性的工作，只是对 methodOverrides 属性做了一些简单的校验而已。\n\n**实例化的前置处理**\n\n`resolveBeforeInstantiation()` 的作用是给 BeanPostProcessors 后置处理器返回一个代理对象的机会，其实在调用该方法之前 Spring 一直都没有创建 bean ，那么这里返回一个 bean 的代理类有什么作用呢？作用体现在后面的 `if` 判断：\n\n```java\nif (bean != null) {\n    return bean;\n}\n```\n\n如果代理对象不为空，则直接返回代理对象，这一步骤有非常重要的作用，Spring 后续实现 AOP 就是基于这个地方判断的。\n\n```java\n    protected Object resolveBeforeInstantiation(String beanName,\n                                                RootBeanDefinition mbd) {\n        Object bean = null;\n        if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n            if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n                Class<?> targetType = determineTargetType(beanName, mbd);\n                if (targetType != null) {\n                    bean = applyBeanPostProcessorsBeforeInstantiation\n                        (targetType, beanName);\n                    if (bean != null) {\n                        bean = applyBeanPostProcessorsAfterInitialization\n                            (bean, beanName);\n                    }\n                }\n            }\n            mbd.beforeInstantiationResolved = (bean != null);\n        }\n        return bean;\n    }\n```\n\n这个方法核心就在于 `applyBeanPostProcessorsBeforeInstantiation()` 和 `applyBeanPostProcessorsAfterInitialization()` 两个方法，before 为实例化前的后处理器应用，after 为实例化后的后处理器应用，由于本文的主题是创建 bean，关于 Bean 的增强处理后续会单独出博文来做详细说明。\n\n**创建 bean**\n\n如果没有代理对象，就只能走常规的路线进行 bean 的创建了，该过程有 `doCreateBean()` 实现，如下：\n\n```java\n   protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, \n                                 final @Nullable Object[] args)\n            throws BeanCreationException {\n\n        // BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，\n       // 获取被包装bean的属性描述器\n        BeanWrapper instanceWrapper = null;\n       \n        // 单例模型，则从未完成的 FactoryBean 缓存中删除\n        if (mbd.isSingleton()) {\n            anceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n        }\n\n           // 根据指定bean使用的对应策略创建新的实例，如：工厂方法、构造函数自动注入，简单完成初始化\n\t\t\t// 实例化bean，将BeanDefinition转换为BeanWrapper\n\t\t\t// 转换是一个复杂的过程，主要有以下步骤：\n\t\t\t// 如果存在工厂方法则使用工厂方法进行初始化。\n\t\t\t// 一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数\n       \t\t//锁定构造函数并进行初始化\n\t\t\t// 如果即不存在工厂方法也不存在带有参数的构造函数，\n           // 则使用默认的构造函数进行bean的实例化。\n        if (instanceWrapper == null) {\n            instanceWrapper = createBeanInstance(beanName, mbd, args);\n        }\n\n        // 包装的实例对象\n        final Object bean = instanceWrapper.getWrappedInstance();\n        // 包装的实例对象的类型\n        Class<?> beanType = instanceWrapper.getWrappedClass();\n        if (beanType != NullBean.class) {\n            mbd.resolvedTargetType = beanType;\n        }\n\n        // 检测是否有后置处理\n        // 如果有后置处理，则允许后置处理修改 BeanDefinition\n        synchronized (mbd.postProcessingLock) {\n            if (!mbd.postProcessed) {\n                try {\n                    // applyMergedBeanDefinitionPostProcessors\n                    // 后置处理修改 BeanDefinition\n                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), \n                                                    beanName,\n                            \"Post-processing of merged bean definition failed\", ex);\n                }\n                mbd.postProcessed = true;\n            }\n        }\n\n        // 解决单例模式的循环依赖\n        // 单例模式 & 运行循环依赖&当前单例 bean 是否正在被创建\n        boolean earlySingletonExposure = (mbd.isSingleton()\n                                          && this.allowCircularReferences &&\n                isSingletonCurrentlyInCreation(beanName));\n        if (earlySingletonExposure) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Eagerly caching bean '\" + beanName +\n                        \"' to allow for resolving potential circular references\");\n            }\n           // 为避免后期循环依赖，可以在bean初始化完成前将创建实例的ObjectFactory键入工厂\n\t\t\t// getEarlyBeanReference的作用\n\t\t\t// 对bean再一次依赖引用，主要应用SmartInstantiationAwareBeanPostProcessor\n\t\t// 其中我们熟知的AOP就是在这里将advice动态植入bean中，若没有则直接返回bean不做任何处理\n            addSingletonFactory(beanName, \n                                () -> getEarlyBeanReference(beanName, mbd, bean));\n        }\n\n        /*\n         * 开始初始化 bean 实例对象\n         */\n        Object exposedObject = bean;\n        try {\n            // 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性\n            // 则会递归初始依赖 bean\n            populateBean(beanName, mbd, instanceWrapper);\n            // 调用初始化方法\n            exposedObject = initializeBean(beanName, exposedObject, mbd);\n        }\n        catch (Throwable ex) {\n            if (ex instanceof BeanCreationException && \n                beanName.equals(((BeanCreationException) ex).getBeanName())) {\n                throw (BeanCreationException) ex;\n            }\n            else {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName,\n                    \"Initialization of bean failed\", ex);\n            }\n        }\n\n        /**\n         * 循环依赖处理\n         */\n        if (earlySingletonExposure) {\n            // 获取 earlySingletonReference\n            Object earlySingletonReference = getSingleton(beanName, false);\n            // 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空\n            if (earlySingletonReference != null) {\n                // 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强\n                if (exposedObject == bean) {\n                    exposedObject = earlySingletonReference;\n                }\n                // 处理依赖\n                else if (!this.allowRawInjectionDespiteWrapping && \n                         hasDependentBean(beanName)) {\n                    String[] dependentBeans = getDependentBeans(beanName);\n                    Set<String> actualDependentBeans =\n                        new LinkedHashSet<>(dependentBeans.length);\n                    for (String dependentBean : dependentBeans) {\n                        if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean))\n                        {\n                            actualDependentBeans.add(dependentBean);\n                        }\n                    }\n                    if (!actualDependentBeans.isEmpty()) {\n                     \t// 省略异常处理\n                    }\n                }\n            }\n        }\n        try {\n            // 注册 bean\n            registerDisposableBeanIfNecessary(beanName, bean, mbd);\n        }\n        catch (BeanDefinitionValidationException ex) {\n    \t\t// 省略异常\n        }\n\n        return exposedObject;\n    }\n```\n\n整体的思路：\n\n1. 如果是单例模式，则清除 factoryBeanInstanceCache 缓存，同时返回 BeanWrapper 实例对象，当然如果存在。\n2. 如果缓存中没有 BeanWrapper 或者不是单例模式，则调用 `createBeanInstance()` 实例化 bean，主要是将 BeanDefinition 转换为 BeanWrapper\n   1. 如果存在工厂方法，则使用工厂方法进行初始化\n   2. 一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数锁定构造函数并进行初始化\n   3. 如果既不存在工厂函数也不存在带有参数的构造器函数则使用默认的构造函数进行bean的实例化\n3.  MergedBeanDefinitionPostProcessor 的应用，Autowired注解正式通过此方法实现注入类型解析\n4. 单例模式的循环依赖处理（后面会重点说到）\n5. 调用 `populateBean()` 进行属性填充。将所有属性填充至 bean 的实例中\n6.  调用 `initializeBean()` 初始化 bean\n7.  依赖检查，在SPring中只解决单例的循环依赖，这一步判断是否有循环依赖，如果抛出异常\n8. 注册 DisposableBean，如果配置了destroy-method。这里需要注册以便于在销毁的时候进行调用。\n\n`doCreateBean()` 完成 bean 的创建和初始化工作，内容太多，这里就只列出整体思路，下文开始将该方法进行拆分进行详细讲解，分布从以下几个方面进行阐述：\n\n- `createBeanInstance()` 实例化 bean\n- `populateBean()` 属性填充\n- 循环依赖的处理\n- `initializeBean()` 初始化 bean","slug":"spring 源码分析/spring/spring源码解析之 20开启bean的实例化进程","published":1,"updated":"2019-01-16T08:36:03.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovx9005n9q1uc3ls35go","content":"<h1 id=\"spring源码解析之-20-开启bean的实例化进程\"><a href=\"#spring源码解析之-20-开启bean的实例化进程\" class=\"headerlink\" title=\"spring源码解析之 20 开启bean的实例化进程\"></a>spring源码解析之 20 开启bean的实例化进程</h1><p>在上篇博客中有一个核心方法没有讲到 <code>createBean()</code> ，该方法的如下：</p>\n<pre><code class=\"java\">protected abstract Object createBean(String beanName, RootBeanDefinition mbd, \n              @Nullable Object[] args) throws BeanCreationException;\n</code></pre>\n<p>该方法定义在 AbstractBeanFactory 中。其含义是根据给定的 BeanDefinition 和 args实例化一个 bean 对象，如果该 BeanDefinition 存在父类，则该 BeanDefinition 已经合并了父类的属性。所有 Bean 实例的创建都会委托给该方法实现。<br><a id=\"more\"></a></p>\n<p>方法接受三个参数：</p>\n<ul>\n<li>beanName：bean 的名字</li>\n<li>mbd：已经合并了父类属性的（如果有的话）BeanDefinition</li>\n<li>args：用于构造函数或者工厂方法创建 bean 实例对象的参数</li>\n</ul>\n<p>该抽象方法的默认实现是在类 AbstractAutowireCapableBeanFactory 中实现，如下：</p>\n<pre><code class=\"java\">   protected Object createBean(String beanName, RootBeanDefinition mbd, \n                               @Nullable Object[] args)\n            throws BeanCreationException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n        }\n        RootBeanDefinition mbdToUse = mbd;\n\n        // 确保此时的 bean 已经被解析了\n        // 如果获取的class 属性不为null，则克隆该 BeanDefinition\n        // 主要是因为该动态解析的 class 无法保存到到共享的 BeanDefinition\n        Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);\n        if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() \n            &amp;&amp; mbd.getBeanClassName() != null) {\n            mbdToUse = new RootBeanDefinition(mbd);\n            mbdToUse.setBeanClass(resolvedClass);\n        }\n\n        try {\n            // 对override属性进行标记以及验证\n            // 这里用来判断一个类中如果存在若干个重载方法，那么在函数调用以及增强的时候\n            // 还需要根据参数类型进行匹配，来最终确认当前调用的到底是哪个函数。\n            // 但是如果只有一个，那么就设置该方法没有重载，这个后续调用的时候可以直接使用\n            // 找到该方法，而不需要进行方法参数匹配。\n            mbdToUse.prepareMethodOverrides();\n        }\n        catch (BeanDefinitionValidationException ex) {\n            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n                    beanName, &quot;Validation of method overrides failed&quot;, ex);\n        }\n\n        try {\n            // 这个方法的作用是实例化对象之前进行前置处理\n            // AOP 的功能就是基于这个地方\n            Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n            // 如果代理对象不为空，则直接返回代理对象，这一步骤有非常重要的作用，\n            // Spring 后续实现 AOP 就是基于这个地方判断的。\n            if (bean != null) {\n                return bean;\n            }\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(mbdToUse.getResourceDescription(), \n                                            beanName,\n                    &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);\n        }\n\n        try {\n            // 执行真正创建 bean 的过程\n            Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n            if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n            }\n            return beanInstance;\n        }\n        catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {\n            throw ex;\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(\n                    mbdToUse.getResourceDescription(), beanName, \n                &quot;Unexpected exception during bean creation&quot;, ex);\n        }\n    }\n</code></pre>\n<p>过程如下：</p>\n<ul>\n<li>根据设置的class属性或者根据className来解析class</li>\n<li>处理 override 属性进行标记及验证</li>\n<li>应用初始化前的处理，解析指定的bean是否存在初始化钱的短路操作，类如后面要说的aop，就会在这里直接初始化一个bean，这后面的操作就不需要进行</li>\n<li>创建 bean</li>\n</ul>\n<p><strong>解析指定 BeanDefinition 的 class</strong></p>\n<pre><code class=\"java\">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName)\n</code></pre>\n<p>这个方法主要是解析 bean definition 的 class 类，并将已经解析的 Class 存储在 beandefinition 中以供后面使用。如果解析的 class 不为空，则会将该 BeanDefinition 进行克隆至 mbdToUse，这样做的主要目的是为动态解析的 class 是无法保存到共享的 BeanDefinition 中。</p>\n<p><strong>处理 override 属性</strong></p>\n<p>大家还记得 lookup-method 和 replace-method 这两个配置功能？在前面博客中已经详细分析了这两个标签的用法和解析过程，知道解析过程其实就是讲这两个配置存放在 BeanDefinition 中的 methodOverrides 属性中，我们知道在 bean 实例化的过程中如果检测到存在 methodOverrides，则会动态地位为当前 bean 生成代理并使用对应的拦截器为 bean 做增强处理。具体的实现我们后续分析，现在先看 <code>mbdToUse.prepareMethodOverrides()</code> 都干了些什么事，如下：</p>\n<pre><code class=\"java\">    public void prepareMethodOverrides() throws BeanDefinitionValidationException {\n        if (hasMethodOverrides()) {\n            Set&lt;MethodOverride&gt; overrides = getMethodOverrides().getOverrides();\n            synchronized (overrides) {\n                for (MethodOverride mo : overrides) {\n                    prepareMethodOverride(mo);\n                }\n            }\n        }\n    }\n</code></pre>\n<p>如果存在 methodOverrides 则获取所有的 override method ，然后通过迭代的方法一次调用 <code>prepareMethodOverride()</code>，如下：</p>\n<pre><code class=\"java\">    protected void prepareMethodOverride(MethodOverride mo) \n        throws BeanDefinitionValidationException {\n        int count = ClassUtils.getMethodCountForName(getBeanClass(), \n                                                     mo.getMethodName());\n        //说明没有对应的代理方法\n        if (count == 0) {\n            throw new BeanDefinitionValidationException(\n                    &quot;Invalid method override: no method with name &#39;&quot;\n                    + mo.getMethodName() +\n                    &quot;&#39; on class [&quot; + getBeanClassName() + &quot;]&quot;);\n        }\n        else if (count == 1) {\n            mo.setOverloaded(false);\n        }\n    }\n</code></pre>\n<p>根据方法名称从 class 中获取该方法名的个数，如果为 0 则抛出异常，如果 为 1 则设置该重载方法没有被重载。若一个类中存在多个重载方法，则在方法调用的时候还需要根据参数类型来判断到底重载的是哪个方法。在设置重载的时候其实这里做了一个小小优化，那就是当 <code>count == 1</code> 时，设置 <code>overloaded = false</code>，这样表示该方法没有重载，这样在后续调用的时候便可以直接找到方法而不需要进行方法参数的校验。</p>\n<p>诚然，其实 <code>mbdToUse.prepareMethodOverrides()</code> 并没有做什么实质性的工作，只是对 methodOverrides 属性做了一些简单的校验而已。</p>\n<p><strong>实例化的前置处理</strong></p>\n<p><code>resolveBeforeInstantiation()</code> 的作用是给 BeanPostProcessors 后置处理器返回一个代理对象的机会，其实在调用该方法之前 Spring 一直都没有创建 bean ，那么这里返回一个 bean 的代理类有什么作用呢？作用体现在后面的 <code>if</code> 判断：</p>\n<pre><code class=\"java\">if (bean != null) {\n    return bean;\n}\n</code></pre>\n<p>如果代理对象不为空，则直接返回代理对象，这一步骤有非常重要的作用，Spring 后续实现 AOP 就是基于这个地方判断的。</p>\n<pre><code class=\"java\">    protected Object resolveBeforeInstantiation(String beanName,\n                                                RootBeanDefinition mbd) {\n        Object bean = null;\n        if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n            if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\n                Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);\n                if (targetType != null) {\n                    bean = applyBeanPostProcessorsBeforeInstantiation\n                        (targetType, beanName);\n                    if (bean != null) {\n                        bean = applyBeanPostProcessorsAfterInitialization\n                            (bean, beanName);\n                    }\n                }\n            }\n            mbd.beforeInstantiationResolved = (bean != null);\n        }\n        return bean;\n    }\n</code></pre>\n<p>这个方法核心就在于 <code>applyBeanPostProcessorsBeforeInstantiation()</code> 和 <code>applyBeanPostProcessorsAfterInitialization()</code> 两个方法，before 为实例化前的后处理器应用，after 为实例化后的后处理器应用，由于本文的主题是创建 bean，关于 Bean 的增强处理后续会单独出博文来做详细说明。</p>\n<p><strong>创建 bean</strong></p>\n<p>如果没有代理对象，就只能走常规的路线进行 bean 的创建了，该过程有 <code>doCreateBean()</code> 实现，如下：</p>\n<pre><code class=\"java\">   protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, \n                                 final @Nullable Object[] args)\n            throws BeanCreationException {\n\n        // BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，\n       // 获取被包装bean的属性描述器\n        BeanWrapper instanceWrapper = null;\n\n        // 单例模型，则从未完成的 FactoryBean 缓存中删除\n        if (mbd.isSingleton()) {\n            anceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n        }\n\n           // 根据指定bean使用的对应策略创建新的实例，如：工厂方法、构造函数自动注入，简单完成初始化\n            // 实例化bean，将BeanDefinition转换为BeanWrapper\n            // 转换是一个复杂的过程，主要有以下步骤：\n            // 如果存在工厂方法则使用工厂方法进行初始化。\n            // 一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数\n               //锁定构造函数并进行初始化\n            // 如果即不存在工厂方法也不存在带有参数的构造函数，\n           // 则使用默认的构造函数进行bean的实例化。\n        if (instanceWrapper == null) {\n            instanceWrapper = createBeanInstance(beanName, mbd, args);\n        }\n\n        // 包装的实例对象\n        final Object bean = instanceWrapper.getWrappedInstance();\n        // 包装的实例对象的类型\n        Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();\n        if (beanType != NullBean.class) {\n            mbd.resolvedTargetType = beanType;\n        }\n\n        // 检测是否有后置处理\n        // 如果有后置处理，则允许后置处理修改 BeanDefinition\n        synchronized (mbd.postProcessingLock) {\n            if (!mbd.postProcessed) {\n                try {\n                    // applyMergedBeanDefinitionPostProcessors\n                    // 后置处理修改 BeanDefinition\n                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), \n                                                    beanName,\n                            &quot;Post-processing of merged bean definition failed&quot;, ex);\n                }\n                mbd.postProcessed = true;\n            }\n        }\n\n        // 解决单例模式的循环依赖\n        // 单例模式 &amp; 运行循环依赖&amp;当前单例 bean 是否正在被创建\n        boolean earlySingletonExposure = (mbd.isSingleton()\n                                          &amp;&amp; this.allowCircularReferences &amp;&amp;\n                isSingletonCurrentlyInCreation(beanName));\n        if (earlySingletonExposure) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +\n                        &quot;&#39; to allow for resolving potential circular references&quot;);\n            }\n           // 为避免后期循环依赖，可以在bean初始化完成前将创建实例的ObjectFactory键入工厂\n            // getEarlyBeanReference的作用\n            // 对bean再一次依赖引用，主要应用SmartInstantiationAwareBeanPostProcessor\n        // 其中我们熟知的AOP就是在这里将advice动态植入bean中，若没有则直接返回bean不做任何处理\n            addSingletonFactory(beanName, \n                                () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n        }\n\n        /*\n         * 开始初始化 bean 实例对象\n         */\n        Object exposedObject = bean;\n        try {\n            // 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性\n            // 则会递归初始依赖 bean\n            populateBean(beanName, mbd, instanceWrapper);\n            // 调用初始化方法\n            exposedObject = initializeBean(beanName, exposedObject, mbd);\n        }\n        catch (Throwable ex) {\n            if (ex instanceof BeanCreationException &amp;&amp; \n                beanName.equals(((BeanCreationException) ex).getBeanName())) {\n                throw (BeanCreationException) ex;\n            }\n            else {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName,\n                    &quot;Initialization of bean failed&quot;, ex);\n            }\n        }\n\n        /**\n         * 循环依赖处理\n         */\n        if (earlySingletonExposure) {\n            // 获取 earlySingletonReference\n            Object earlySingletonReference = getSingleton(beanName, false);\n            // 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空\n            if (earlySingletonReference != null) {\n                // 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强\n                if (exposedObject == bean) {\n                    exposedObject = earlySingletonReference;\n                }\n                // 处理依赖\n                else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; \n                         hasDependentBean(beanName)) {\n                    String[] dependentBeans = getDependentBeans(beanName);\n                    Set&lt;String&gt; actualDependentBeans =\n                        new LinkedHashSet&lt;&gt;(dependentBeans.length);\n                    for (String dependentBean : dependentBeans) {\n                        if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean))\n                        {\n                            actualDependentBeans.add(dependentBean);\n                        }\n                    }\n                    if (!actualDependentBeans.isEmpty()) {\n                         // 省略异常处理\n                    }\n                }\n            }\n        }\n        try {\n            // 注册 bean\n            registerDisposableBeanIfNecessary(beanName, bean, mbd);\n        }\n        catch (BeanDefinitionValidationException ex) {\n            // 省略异常\n        }\n\n        return exposedObject;\n    }\n</code></pre>\n<p>整体的思路：</p>\n<ol>\n<li>如果是单例模式，则清除 factoryBeanInstanceCache 缓存，同时返回 BeanWrapper 实例对象，当然如果存在。</li>\n<li>如果缓存中没有 BeanWrapper 或者不是单例模式，则调用 <code>createBeanInstance()</code> 实例化 bean，主要是将 BeanDefinition 转换为 BeanWrapper<ol>\n<li>如果存在工厂方法，则使用工厂方法进行初始化</li>\n<li>一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数锁定构造函数并进行初始化</li>\n<li>如果既不存在工厂函数也不存在带有参数的构造器函数则使用默认的构造函数进行bean的实例化</li>\n</ol>\n</li>\n<li>MergedBeanDefinitionPostProcessor 的应用，Autowired注解正式通过此方法实现注入类型解析</li>\n<li>单例模式的循环依赖处理（后面会重点说到）</li>\n<li>调用 <code>populateBean()</code> 进行属性填充。将所有属性填充至 bean 的实例中</li>\n<li>调用 <code>initializeBean()</code> 初始化 bean</li>\n<li>依赖检查，在SPring中只解决单例的循环依赖，这一步判断是否有循环依赖，如果抛出异常</li>\n<li>注册 DisposableBean，如果配置了destroy-method。这里需要注册以便于在销毁的时候进行调用。</li>\n</ol>\n<p><code>doCreateBean()</code> 完成 bean 的创建和初始化工作，内容太多，这里就只列出整体思路，下文开始将该方法进行拆分进行详细讲解，分布从以下几个方面进行阐述：</p>\n<ul>\n<li><code>createBeanInstance()</code> 实例化 bean</li>\n<li><code>populateBean()</code> 属性填充</li>\n<li>循环依赖的处理</li>\n<li><code>initializeBean()</code> 初始化 bean</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-20-开启bean的实例化进程\"><a href=\"#spring源码解析之-20-开启bean的实例化进程\" class=\"headerlink\" title=\"spring源码解析之 20 开启bean的实例化进程\"></a>spring源码解析之 20 开启bean的实例化进程</h1><p>在上篇博客中有一个核心方法没有讲到 <code>createBean()</code> ，该方法的如下：</p>\n<pre><code class=\"java\">protected abstract Object createBean(String beanName, RootBeanDefinition mbd, \n              @Nullable Object[] args) throws BeanCreationException;\n</code></pre>\n<p>该方法定义在 AbstractBeanFactory 中。其含义是根据给定的 BeanDefinition 和 args实例化一个 bean 对象，如果该 BeanDefinition 存在父类，则该 BeanDefinition 已经合并了父类的属性。所有 Bean 实例的创建都会委托给该方法实现。<br>","more":"</p>\n<p>方法接受三个参数：</p>\n<ul>\n<li>beanName：bean 的名字</li>\n<li>mbd：已经合并了父类属性的（如果有的话）BeanDefinition</li>\n<li>args：用于构造函数或者工厂方法创建 bean 实例对象的参数</li>\n</ul>\n<p>该抽象方法的默认实现是在类 AbstractAutowireCapableBeanFactory 中实现，如下：</p>\n<pre><code class=\"java\">   protected Object createBean(String beanName, RootBeanDefinition mbd, \n                               @Nullable Object[] args)\n            throws BeanCreationException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n        }\n        RootBeanDefinition mbdToUse = mbd;\n\n        // 确保此时的 bean 已经被解析了\n        // 如果获取的class 属性不为null，则克隆该 BeanDefinition\n        // 主要是因为该动态解析的 class 无法保存到到共享的 BeanDefinition\n        Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);\n        if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() \n            &amp;&amp; mbd.getBeanClassName() != null) {\n            mbdToUse = new RootBeanDefinition(mbd);\n            mbdToUse.setBeanClass(resolvedClass);\n        }\n\n        try {\n            // 对override属性进行标记以及验证\n            // 这里用来判断一个类中如果存在若干个重载方法，那么在函数调用以及增强的时候\n            // 还需要根据参数类型进行匹配，来最终确认当前调用的到底是哪个函数。\n            // 但是如果只有一个，那么就设置该方法没有重载，这个后续调用的时候可以直接使用\n            // 找到该方法，而不需要进行方法参数匹配。\n            mbdToUse.prepareMethodOverrides();\n        }\n        catch (BeanDefinitionValidationException ex) {\n            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n                    beanName, &quot;Validation of method overrides failed&quot;, ex);\n        }\n\n        try {\n            // 这个方法的作用是实例化对象之前进行前置处理\n            // AOP 的功能就是基于这个地方\n            Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n            // 如果代理对象不为空，则直接返回代理对象，这一步骤有非常重要的作用，\n            // Spring 后续实现 AOP 就是基于这个地方判断的。\n            if (bean != null) {\n                return bean;\n            }\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(mbdToUse.getResourceDescription(), \n                                            beanName,\n                    &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);\n        }\n\n        try {\n            // 执行真正创建 bean 的过程\n            Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n            if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n            }\n            return beanInstance;\n        }\n        catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {\n            throw ex;\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(\n                    mbdToUse.getResourceDescription(), beanName, \n                &quot;Unexpected exception during bean creation&quot;, ex);\n        }\n    }\n</code></pre>\n<p>过程如下：</p>\n<ul>\n<li>根据设置的class属性或者根据className来解析class</li>\n<li>处理 override 属性进行标记及验证</li>\n<li>应用初始化前的处理，解析指定的bean是否存在初始化钱的短路操作，类如后面要说的aop，就会在这里直接初始化一个bean，这后面的操作就不需要进行</li>\n<li>创建 bean</li>\n</ul>\n<p><strong>解析指定 BeanDefinition 的 class</strong></p>\n<pre><code class=\"java\">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName)\n</code></pre>\n<p>这个方法主要是解析 bean definition 的 class 类，并将已经解析的 Class 存储在 beandefinition 中以供后面使用。如果解析的 class 不为空，则会将该 BeanDefinition 进行克隆至 mbdToUse，这样做的主要目的是为动态解析的 class 是无法保存到共享的 BeanDefinition 中。</p>\n<p><strong>处理 override 属性</strong></p>\n<p>大家还记得 lookup-method 和 replace-method 这两个配置功能？在前面博客中已经详细分析了这两个标签的用法和解析过程，知道解析过程其实就是讲这两个配置存放在 BeanDefinition 中的 methodOverrides 属性中，我们知道在 bean 实例化的过程中如果检测到存在 methodOverrides，则会动态地位为当前 bean 生成代理并使用对应的拦截器为 bean 做增强处理。具体的实现我们后续分析，现在先看 <code>mbdToUse.prepareMethodOverrides()</code> 都干了些什么事，如下：</p>\n<pre><code class=\"java\">    public void prepareMethodOverrides() throws BeanDefinitionValidationException {\n        if (hasMethodOverrides()) {\n            Set&lt;MethodOverride&gt; overrides = getMethodOverrides().getOverrides();\n            synchronized (overrides) {\n                for (MethodOverride mo : overrides) {\n                    prepareMethodOverride(mo);\n                }\n            }\n        }\n    }\n</code></pre>\n<p>如果存在 methodOverrides 则获取所有的 override method ，然后通过迭代的方法一次调用 <code>prepareMethodOverride()</code>，如下：</p>\n<pre><code class=\"java\">    protected void prepareMethodOverride(MethodOverride mo) \n        throws BeanDefinitionValidationException {\n        int count = ClassUtils.getMethodCountForName(getBeanClass(), \n                                                     mo.getMethodName());\n        //说明没有对应的代理方法\n        if (count == 0) {\n            throw new BeanDefinitionValidationException(\n                    &quot;Invalid method override: no method with name &#39;&quot;\n                    + mo.getMethodName() +\n                    &quot;&#39; on class [&quot; + getBeanClassName() + &quot;]&quot;);\n        }\n        else if (count == 1) {\n            mo.setOverloaded(false);\n        }\n    }\n</code></pre>\n<p>根据方法名称从 class 中获取该方法名的个数，如果为 0 则抛出异常，如果 为 1 则设置该重载方法没有被重载。若一个类中存在多个重载方法，则在方法调用的时候还需要根据参数类型来判断到底重载的是哪个方法。在设置重载的时候其实这里做了一个小小优化，那就是当 <code>count == 1</code> 时，设置 <code>overloaded = false</code>，这样表示该方法没有重载，这样在后续调用的时候便可以直接找到方法而不需要进行方法参数的校验。</p>\n<p>诚然，其实 <code>mbdToUse.prepareMethodOverrides()</code> 并没有做什么实质性的工作，只是对 methodOverrides 属性做了一些简单的校验而已。</p>\n<p><strong>实例化的前置处理</strong></p>\n<p><code>resolveBeforeInstantiation()</code> 的作用是给 BeanPostProcessors 后置处理器返回一个代理对象的机会，其实在调用该方法之前 Spring 一直都没有创建 bean ，那么这里返回一个 bean 的代理类有什么作用呢？作用体现在后面的 <code>if</code> 判断：</p>\n<pre><code class=\"java\">if (bean != null) {\n    return bean;\n}\n</code></pre>\n<p>如果代理对象不为空，则直接返回代理对象，这一步骤有非常重要的作用，Spring 后续实现 AOP 就是基于这个地方判断的。</p>\n<pre><code class=\"java\">    protected Object resolveBeforeInstantiation(String beanName,\n                                                RootBeanDefinition mbd) {\n        Object bean = null;\n        if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n            if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\n                Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);\n                if (targetType != null) {\n                    bean = applyBeanPostProcessorsBeforeInstantiation\n                        (targetType, beanName);\n                    if (bean != null) {\n                        bean = applyBeanPostProcessorsAfterInitialization\n                            (bean, beanName);\n                    }\n                }\n            }\n            mbd.beforeInstantiationResolved = (bean != null);\n        }\n        return bean;\n    }\n</code></pre>\n<p>这个方法核心就在于 <code>applyBeanPostProcessorsBeforeInstantiation()</code> 和 <code>applyBeanPostProcessorsAfterInitialization()</code> 两个方法，before 为实例化前的后处理器应用，after 为实例化后的后处理器应用，由于本文的主题是创建 bean，关于 Bean 的增强处理后续会单独出博文来做详细说明。</p>\n<p><strong>创建 bean</strong></p>\n<p>如果没有代理对象，就只能走常规的路线进行 bean 的创建了，该过程有 <code>doCreateBean()</code> 实现，如下：</p>\n<pre><code class=\"java\">   protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, \n                                 final @Nullable Object[] args)\n            throws BeanCreationException {\n\n        // BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，\n       // 获取被包装bean的属性描述器\n        BeanWrapper instanceWrapper = null;\n\n        // 单例模型，则从未完成的 FactoryBean 缓存中删除\n        if (mbd.isSingleton()) {\n            anceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n        }\n\n           // 根据指定bean使用的对应策略创建新的实例，如：工厂方法、构造函数自动注入，简单完成初始化\n            // 实例化bean，将BeanDefinition转换为BeanWrapper\n            // 转换是一个复杂的过程，主要有以下步骤：\n            // 如果存在工厂方法则使用工厂方法进行初始化。\n            // 一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数\n               //锁定构造函数并进行初始化\n            // 如果即不存在工厂方法也不存在带有参数的构造函数，\n           // 则使用默认的构造函数进行bean的实例化。\n        if (instanceWrapper == null) {\n            instanceWrapper = createBeanInstance(beanName, mbd, args);\n        }\n\n        // 包装的实例对象\n        final Object bean = instanceWrapper.getWrappedInstance();\n        // 包装的实例对象的类型\n        Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();\n        if (beanType != NullBean.class) {\n            mbd.resolvedTargetType = beanType;\n        }\n\n        // 检测是否有后置处理\n        // 如果有后置处理，则允许后置处理修改 BeanDefinition\n        synchronized (mbd.postProcessingLock) {\n            if (!mbd.postProcessed) {\n                try {\n                    // applyMergedBeanDefinitionPostProcessors\n                    // 后置处理修改 BeanDefinition\n                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), \n                                                    beanName,\n                            &quot;Post-processing of merged bean definition failed&quot;, ex);\n                }\n                mbd.postProcessed = true;\n            }\n        }\n\n        // 解决单例模式的循环依赖\n        // 单例模式 &amp; 运行循环依赖&amp;当前单例 bean 是否正在被创建\n        boolean earlySingletonExposure = (mbd.isSingleton()\n                                          &amp;&amp; this.allowCircularReferences &amp;&amp;\n                isSingletonCurrentlyInCreation(beanName));\n        if (earlySingletonExposure) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +\n                        &quot;&#39; to allow for resolving potential circular references&quot;);\n            }\n           // 为避免后期循环依赖，可以在bean初始化完成前将创建实例的ObjectFactory键入工厂\n            // getEarlyBeanReference的作用\n            // 对bean再一次依赖引用，主要应用SmartInstantiationAwareBeanPostProcessor\n        // 其中我们熟知的AOP就是在这里将advice动态植入bean中，若没有则直接返回bean不做任何处理\n            addSingletonFactory(beanName, \n                                () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n        }\n\n        /*\n         * 开始初始化 bean 实例对象\n         */\n        Object exposedObject = bean;\n        try {\n            // 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性\n            // 则会递归初始依赖 bean\n            populateBean(beanName, mbd, instanceWrapper);\n            // 调用初始化方法\n            exposedObject = initializeBean(beanName, exposedObject, mbd);\n        }\n        catch (Throwable ex) {\n            if (ex instanceof BeanCreationException &amp;&amp; \n                beanName.equals(((BeanCreationException) ex).getBeanName())) {\n                throw (BeanCreationException) ex;\n            }\n            else {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName,\n                    &quot;Initialization of bean failed&quot;, ex);\n            }\n        }\n\n        /**\n         * 循环依赖处理\n         */\n        if (earlySingletonExposure) {\n            // 获取 earlySingletonReference\n            Object earlySingletonReference = getSingleton(beanName, false);\n            // 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空\n            if (earlySingletonReference != null) {\n                // 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强\n                if (exposedObject == bean) {\n                    exposedObject = earlySingletonReference;\n                }\n                // 处理依赖\n                else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; \n                         hasDependentBean(beanName)) {\n                    String[] dependentBeans = getDependentBeans(beanName);\n                    Set&lt;String&gt; actualDependentBeans =\n                        new LinkedHashSet&lt;&gt;(dependentBeans.length);\n                    for (String dependentBean : dependentBeans) {\n                        if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean))\n                        {\n                            actualDependentBeans.add(dependentBean);\n                        }\n                    }\n                    if (!actualDependentBeans.isEmpty()) {\n                         // 省略异常处理\n                    }\n                }\n            }\n        }\n        try {\n            // 注册 bean\n            registerDisposableBeanIfNecessary(beanName, bean, mbd);\n        }\n        catch (BeanDefinitionValidationException ex) {\n            // 省略异常\n        }\n\n        return exposedObject;\n    }\n</code></pre>\n<p>整体的思路：</p>\n<ol>\n<li>如果是单例模式，则清除 factoryBeanInstanceCache 缓存，同时返回 BeanWrapper 实例对象，当然如果存在。</li>\n<li>如果缓存中没有 BeanWrapper 或者不是单例模式，则调用 <code>createBeanInstance()</code> 实例化 bean，主要是将 BeanDefinition 转换为 BeanWrapper<ol>\n<li>如果存在工厂方法，则使用工厂方法进行初始化</li>\n<li>一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数锁定构造函数并进行初始化</li>\n<li>如果既不存在工厂函数也不存在带有参数的构造器函数则使用默认的构造函数进行bean的实例化</li>\n</ol>\n</li>\n<li>MergedBeanDefinitionPostProcessor 的应用，Autowired注解正式通过此方法实现注入类型解析</li>\n<li>单例模式的循环依赖处理（后面会重点说到）</li>\n<li>调用 <code>populateBean()</code> 进行属性填充。将所有属性填充至 bean 的实例中</li>\n<li>调用 <code>initializeBean()</code> 初始化 bean</li>\n<li>依赖检查，在SPring中只解决单例的循环依赖，这一步判断是否有循环依赖，如果抛出异常</li>\n<li>注册 DisposableBean，如果配置了destroy-method。这里需要注册以便于在销毁的时候进行调用。</li>\n</ol>\n<p><code>doCreateBean()</code> 完成 bean 的创建和初始化工作，内容太多，这里就只列出整体思路，下文开始将该方法进行拆分进行详细讲解，分布从以下几个方面进行阐述：</p>\n<ul>\n<li><code>createBeanInstance()</code> 实例化 bean</li>\n<li><code>populateBean()</code> 属性填充</li>\n<li>循环依赖的处理</li>\n<li><code>initializeBean()</code> 初始化 bean</li>\n</ul>"},{"abbrlink":41,"title":" spring源码解析之 22构造函数实例化","author":"fengxiutianya","date":"2019-01-14T19:36:00.000Z","_content":"# spring源码解析之 22构造函数实例化\n\n## autowireConstructor()\n\n这个初始化方法我们可以简单理解为是带有参数的初始化 bean 。代码段如下：\n<!-- more -->\n\n```java\n  \tpublic BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,\n\t\t\t\t\t\t\t\t\t\t   @Nullable Constructor<?>[] chosenCtors, \n                                           @Nullable Object[] explicitArgs) {\n\t\t// 实例化BeanWrapper对象\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tConstructor<?> constructorToUse = null;\n\t\tArgumentsHolder argsHolderToUse = null;\n\t\tObject[] argsToUse = null;\n\t\t// explicit通过getBean方法传入\n\t\t// 如果getBean方法调用的时候指定方法参数，那么直接使用\n\t\tif (explicitArgs != null) {\n\t\t\targsToUse = explicitArgs;\n\t\t} else {\n\t\t\t// 如果在getBean方法时候没有指定则尝试从配置文件中解析\n\t\t\tObject[] argsToResolve = null;\n\n\t\t\t// 尝试从缓存中获取获取参数\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tconstructorToUse = (Constructor<?>)\n                    mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (constructorToUse != null && mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// 缓存中的构造参数\n\t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse == null) {\n\t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 如果缓存中存在\n\t\t\tif (argsToResolve != null) {\n\t\t\t\t// 解析参数类型，如给定方法的构造函数A(int,int)则通过此方法后就会\n\t\t\t\t// 把配置中(\"1\",\"1\")转换为(1,1)\n\t\t\t\t// 缓存中的值可能是原始值也可能是最终值，在这里做处理\n\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd,\n                                                     bw, constructorToUse, \n                                                     argsToResolve, true);\n\t\t\t}\n\t\t}\n\t\t// 没有缓存也没有明确指定\n\t\tif (constructorToUse == null || argsToUse == null) {\n\t\t\t// Take specified constructors, if any.\n\t\t\tConstructor<?>[] candidates = chosenCtors;\n\n\t\t\t// 如果参数中没有指定构造函数\n\t\t\tif (candidates == null) {\n\t\t\t\t// 获取当前bean对应的class对象\n\t\t\t\tClass<?> beanClass = mbd.getBeanClass();\n\t\t\t\ttry {\n\t\t\t\t\t// 获取所有的构造函数\n\t\t\t\t\tcandidates = (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\tbeanClass.getDeclaredConstructors() : \n                                  beanClass.getConstructors());\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 如果只有默认构造函数并且配置文件中也没有参数配置\n\t\t\tif (candidates.length == 1 && explicitArgs == null \n                && !mbd.hasConstructorArgumentValues()) {\n\t\t\t\tConstructor<?> uniqueCandidate = candidates[0];\n\t\t\t\t// 缓存构造函数\n\t\t\t\tif (uniqueCandidate.getParameterCount() == 0) {\n\t\t\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\t\t\tmbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;\n\t\t\t\t\t\tmbd.constructorArgumentsResolved = true;\n\t\t\t\t\t\tmbd.resolvedConstructorArguments = EMPTY_ARGS;\n\t\t\t\t\t}\n\t\t\t\t\t// 使用默认构造函数初始化对象\n\t\t\t\t\tbw.setBeanInstance(instantiate(beanName, mbd, \n                                                   uniqueCandidate, EMPTY_ARGS));\n\t\t\t\t\treturn bw;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// Need to resolve the constructor.\n\t\t\t// 判断是否需要解析构造函数\n\t\t\tboolean autowiring = (chosenCtors != null ||\n\t\t\t\t\tmbd.getResolvedAutowireMode() == \n                                  AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);\n\n\t\t\t// 用于承载解析后的构造函数的值\n\t\t\tConstructorArgumentValues resolvedValues = null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs != null) {\n\t\t\t\tminNrOfArgs = explicitArgs.length;\n\t\t\t} else {\n\t\t\t\t// 从BeanDefinition中获取构造参数，也就是从配置文件中提取构造函数\n\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n\t\t\t\t// 解析构造函数的参数\n\t\t\t\t// 将该bean的构造函数参数解析为resolvedValues对象，其中会涉及到其它bean\n\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, \n                                                          cargs, resolvedValues);\n\t\t\t}\n\t\t\t// 对构造函数进行排序处理\n\t\t\t// public 构造函数优先参数数量降序，非public 构造函数参数数量降序\n\t\t\tAutowireUtils.sortConstructors(candidates);\n\t\t\t//  最小参数类型权重\n\t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n\t\t\tSet<Constructor<?>> ambiguousConstructors = null;\n\t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n\n\t\t\t// 迭代所有构造函数\n\t\t\tfor (Constructor<?> candidate : candidates) {\n\t\t\t\t// 获取构造函数参数类型\n\t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n\t\t\t\t// 如果已经找到选用的构造函数或者需要的参数个数小于当前的构造函数参数个数，则终止\n\t\t\t\t// 因为已经按照参数个数降序排列了\n\t\t\t\tif (constructorToUse != null && argsToUse != null &&\n                    argsToUse.length > paramTypes.length) {\n\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 参数个数不等，继续\n\t\t\t\tif (paramTypes.length < minNrOfArgs) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// 参数持有者\n\t\t\t\tArgumentsHolder argsHolder;\n\t\t\t\t// 有参数\n\t\t\t\tif (resolvedValues != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// 注解上获取参数名称\n\t\t\t\t\t\tString[] paramNames = \n                            ConstructorPropertiesChecker.evaluate(candidate, \n                                                                  paramTypes.length);\n\n\t\t\t\t\t\tif (paramNames == null) {\n\t\t\t\t\t\t\t// 获取构造函数、方法参数的探测器\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd = \n                                this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd != null) {\n\t\t\t\t\t\t\t\t// 通过探测器获取构造函数的参数名称\n\t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 根据构造函数和构造参数创建参数持有者\n\t\t\t\t\t\targsHolder = createArgumentArray(beanName, mbd, \n                                                         resolvedValues, bw, \n                                                         paramTypes, paramNames,\n\t\t\t\t\t\t\t\tgetUserDeclaredConstructor(candidate), autowiring, \n                                                         candidates.length == 1);\n\t\t\t\t\t} catch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Swallow and try next constructor.\n\t\t\t\t\t\tif (causes == null) {\n\t\t\t\t\t\t\tcauses = new LinkedList<>();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// 构造函数没有参数\n\t\t\t\t\n\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n\t\t\t\t}\n\t\t\t//isLenientConstructorResolution判断解析构造函数的时候是否以宽松模式还是严格模式\n\t\t\t\t// 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常\n\t\t\t\t// 宽松模式：使用具有\"最接近的模式\"进行匹配\n\t\t\t\t// typeDiffWeight：类型差异权重\n\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) :\n                                      argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t// 如果它代表着当前最接近的匹配则选择其作为构造函数\n\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n\t\t\t\t\tconstructorToUse = candidate;\n\t\t\t\t\targsHolderToUse = argsHolder;\n\t\t\t\t\targsToUse = argsHolder.arguments;\n\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n\t\t\t\t\tambiguousConstructors = null;\n\t\t\t\t} else if (constructorToUse != null &&\n                           typeDiffWeight == minTypeDiffWeight) {\n\t\t\t\t\tif (ambiguousConstructors == null) {\n\t\t\t\t\t\tambiguousConstructors = new LinkedHashSet<>();\n\t\t\t\t\t\tambiguousConstructors.add(constructorToUse);\n\t\t\t\t\t}\n\t\t\t\t\tambiguousConstructors.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (constructorToUse == null) {\n\t\t\t\tif (causes != null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\n\t\t\t} else if (ambiguousConstructors != null && \n                       !mbd.isLenientConstructorResolution()) {\n\t\t\t\n\t\t\t}\n\t\t\t// 将构造函数、构造参数保存到缓存中\n\t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, constructorToUse);\n\t\t\t}\n\t\t}\n\n\t\tAssert.state(argsToUse != null, \"Unresolved constructor arguments\");\n\t\t// 实例化bean\n\t\tbw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));\n\t\treturn bw;\n\t}\n\n```\n\n代码与 `instantiateUsingFactoryMethod()` 一样，又长又难懂，但是如果理解了 `instantiateUsingFactoryMethod()` 初始化 bean 的过程，那么 `autowireConstructor()` 也不存在什么难的地方了，一句话概括：首先确定构造函数参数、构造函数，然后调用相应的初始化策略进行 bean 的初始化。关于如何确定构造函数、构造参数，该部分逻辑和 `instantiateUsingFactoryMethod()` 基本一致。所以这里你应该相对会轻松点\n\n1. 构造函数参数的确定\n\n   * 根据explicitArgs参数判断\n\n     如果传入的参数explicitArgs不为空，那边可以直接确定参数，因为explicitArgs参数是在调用bean的时候用户指定的，在BeanFactory类中存在这样的方法：\n\n     ```java\n     Object getBean(String name,Object... args) throws BeansException\n     ```\n\n     在获取bean的时候，用户不但可以指定bean的名称还可以指定bean对应类的构造函数或者工厂方法的方法参数，主要用于静态工厂方法的调用，而这里需要先给定完全匹配的参数，如果传入参数explicitArg不为空，则可以确定构造函数参数就是它。\n\n   * 缓存中获取\n\n     除此之外，确定参数的办法如果之前已经分析过，也就是说构造参数已经记录在缓存中，那么便可以直接拿来使用。而且，这里要提到的是，在魂村中换粗的可能是参数的最终类型也可能是参数的初始类型。如果是初始类型，则需要进行转换。\n\n   * 配置文件中获取\n\n     如果不能根据传入参数explicit·Arg确定构造函数的参数也无法在缓存中得到相关信息，那么只能开始新一轮的分析。分析从配置文件中配置的构造函数信息开始，经过之前的分析，我们知道，spring中配置文件中的信息经过转换都会通过BeanDefinition实例承载，也就是参数mbd中包含，那么可以荣国调用mdb.getCOntructorArgumentValues来获取配置的构造函数信息。有了配置中的信息便可以获取对应的参数值信息。获取参数值的信息包括直接指定值，如：直接指定构造函数中某个值为原始类型String类型，或者是一个队其他bean的引用，这里处理委托给resolveCOnstrucorArguments方法，并返回能解析到的参数的个数\n\n2. 构造函数的确定\n\n   经过了第一步后已经确定了构造函数的参数，接下来的任务就是根据构造函数参数在所有构造函数中锁定对应的构造函数，而匹配的方法就是根据参数个数匹配，所以在匹配之前需要先对构造函数按照public构造函数优先参数量降序、feipublic构造函数参数数量降序，这样可以在遍历的情况下循序判断牌子啊后面的构造函数参数个数是否符合条件。\n\n   由于在配置文件中并不是唯一现在使用参数位置索引的方式去创建，同样还支持指定参数名称进行设定参数值的情况，如`<constructor-arg name=\"aa\">`，那么这种情况就需要首先确定构造函数中的参数名称。\n\n   获取参数名称可以有俩种方式，一种是通过注解的方式直接获取，另一种就是使用spring中提供的工具类ParameterNameDiscover来获取，构造函数、参数名称、参数哦类型、参数值都确定后就可以锁定构造函数以及转换对应的参数类型。\n\n3. 根据确定的构造函数转换对应的参数类型\n\n   主要使用spring中提供的类型转换器或者用户提供的自定义类型转换器进行转换。\n\n4. 根据构造函数不确定性的验证\n\n   当然，有时候即使构造函数，参数名称，参数类型、参数值都确定后也不一定会直接锁定构造函数，不同构造函数的参数为父子类型，所以spring在最后有做了一次验证。\n\n   根据实例化策略以及得到的构造函数即构造函数参数实例化bean。下面我们重点分析初始化策略：\n\n对于初始化策略，首先是获取实例化 bean 的策略，如下：\n\n```java\nfinal InstantiationStrategy strategy = beanFactory.getInstantiationStrategy();\n```\n\n然后是调用其 `instantiate()`方法，该方法在 SimpleInstantiationStrategy 中实现，如下：\n\n```java\n    public Object instantiate(RootBeanDefinition bd, \n                              @Nullable String beanName, BeanFactory owner) {\n        // 没有覆盖\n        // 直接使用反射实例化即可\n        if (!bd.hasMethodOverrides()) {\n            // 重新检测获取下构造函数\n            // 该构造函数是经过前面 N 多复杂过程确认的构造函数\n            Constructor<?> constructorToUse;\n            synchronized (bd.constructorArgumentLock) {\n                // 获取已经解析的构造函数\n                constructorToUse = (Constructor<?>) \n                    bd.resolvedConstructorOrFactoryMethod;\n                // 如果为 null，从 class 中解析获取，并设置\n                if (constructorToUse == null) {\n                    final Class<?> clazz = bd.getBeanClass();\n                    if (clazz.isInterface()) {\n                        throw new BeanInstantiationException(clazz, \n                                    】\"Specified class is an interface\");\n                    }\n                    try {\n                        if (System.getSecurityManager() != null) {\n                            constructorToUse = AccessController.doPrivileged(\n                                    (PrivilegedExceptionAction<Constructor<?>>) \n                                clazz::getDeclaredConstructor);\n                        }\n                        else {\n                            constructorToUse =  clazz.getDeclaredConstructor();\n                        }\n                        bd.resolvedConstructorOrFactoryMethod = constructorToUse;\n                    }\n                    catch (Throwable ex) {\n                        throw new BeanInstantiationException(clazz,\n                                 \"No default constructor found\", ex);\n                    }\n                }\n            }\n\n            // 通过BeanUtils直接使用构造器对象实例化bean\n            return BeanUtils.instantiateClass(constructorToUse);\n        }\n        else {\n            // 生成CGLIB创建的子类对象\n            return instantiateWithMethodInjection(bd, beanName, owner);\n        }\n    }\n```\n\n如果该 bean 没有配置 lookup-method、replaced-method 标签或者 @Lookup 注解，则直接通过反射的方式实例化 bean 即可，方便快捷，但是如果存在需要覆盖的方法或者动态替换的方法则需要使用 CGLIB 进行动态代理，因为可以在创建代理的同时将动态方法织入类中。\n\n**反射**\n\n调用工具类 BeanUtils 的 `instantiateClass()` 方法完成反射工作：\n\n```java\n    public static <T> T instantiateClass(Constructor<T> ctor, Object... args)\n        throws BeanInstantiationException {\n        Assert.notNull(ctor, \"Constructor must not be null\");\n        try {\n            ReflectionUtils.makeAccessible(ctor);\n            return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?\n                    KotlinDelegate.instantiateClass(ctor, args) : \n                    ctor.newInstance(args));\n        }\n        // 省略一些 catch \n    }\n```\n\n**CGLIB**\n\n```java\n    protected Object instantiateWithMethodInjection(RootBeanDefinition bd,\n                      @Nullable String beanName, BeanFactory owner) {\n        throw new UnsupportedOperationException(\"Method Injection not supported in SimpleInstantiationStrategy\");\n    }\n```\n\n方法默认是没有实现的，具体过程由其子类 CglibSubclassingInstantiationStrategy 实现：\n\n```java\n    protected Object instantiateWithMethodInjection(RootBeanDefinition bd, \n                      @Nullable String beanName, BeanFactory owner) {\n        return instantiateWithMethodInjection(bd, beanName, owner, null);\n    }\n\n    protected Object instantiateWithMethodInjection(RootBeanDefinition bd, \n                            @Nullable String beanName, BeanFactory owner,\n            @Nullable Constructor<?> ctor, @Nullable Object... args) {\n\n        // 通过CGLIB生成一个子类对象\n        return new CglibSubclassCreator(bd, owner).instantiate(ctor, args);\n    }\n```\n\n创建一个 CglibSubclassCreator 对象，调用其 `instantiate()` 方法生成其子类对象：\n\n```java\n    public Object instantiate(@Nullable Constructor<?> ctor, @Nullable Object... args) \n    {\n        // 通过 Cglib 创建一个代理类\n        Class<?> subclass = createEnhancedSubclass(this.beanDefinition);\n        Object instance;\n        // 没有构造器，通过 BeanUtils 使用默认构造器创建一个bean实例\n        if (ctor == null) {\n            instance = BeanUtils.instantiateClass(subclass);\n        }\n        else {\n            try {\n                // 获取代理类对应的构造器对象，并实例化 bean\n                Constructor<?> enhancedSubclassConstructor = \n                    subclass.getConstructor(ctor.getParameterTypes());\n                instance = enhancedSubclassConstructor.newInstance(args);\n            }\n            catch (Exception ex) {\n              \n            }\n        }\n\n        // 为了避免memory leaks异常，直接在bean实例上设置回调对象\n        Factory factory = (Factory) instance;\n        factory.setCallbacks(new Callback[] {NoOp.INSTANCE,\n                new CglibSubclassingInstantiationStrategy\n                    .LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),\n                new CglibSubclassingInstantiationStrategy\n                    .ReplaceOverrideMethodInterceptor(this.beanDefinition, \n                                                      this.owner)});\n        return instance;\n    }\n```\n\n到这类 CGLIB 的方式分析完毕了，当然这里还没有具体分析 CGLIB 生成子类的详细过程，具体的过程等后续分析 AOP 的时候再详细地介绍。\n\n## instantiateBean()\n\n```java\n   protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {\n        try {\n            Object beanInstance;\n            final BeanFactory parent = this;\n            if (System.getSecurityManager() != null) {\n                beanInstance = AccessController.doPrivileged(\n                    (PrivilegedAction<Object>) () ->\n                                getInstantiationStrategy().instantiate(mbd,\n                                   beanName, parent),\n                        getAccessControlContext());\n            }\n            else {\n                beanInstance = getInstantiationStrategy()\n                    \t\t.instantiate(mbd, beanName, parent);\n            }\n            BeanWrapper bw = new BeanWrapperImpl(beanInstance);\n            initBeanWrapper(bw);\n            return bw;\n        }\n        catch (Throwable ex) {\n          \t、、。。。\n        }\n    }\n```\n\n这个方法相比于 `instantiateUsingFactoryMethod()` 、 `autowireConstructor()` 方法实在是太简单了，因为它没有参数，所以不需要确认经过复杂的过来来确定构造器、构造参数，所以这里就不过多阐述了。\n\n对于 `createBeanInstance()` 而言，他就是选择合适实例化策略来为 bean 创建实例对象，具体的策略有：Supplier 回调方式、工厂方法初始化、构造函数自动注入初始化、默认构造函数注入。其中工厂方法初始化和构造函数自动注入初始化两种方式最为复杂，主要是因为构造函数和构造参数的不确定性，Spring 需要花大量的精力来确定构造函数和构造参数，如果确定了则好办，直接选择实例化策略即可。当然在实例化的时候会根据是否有需要覆盖或者动态替换掉的方法，因为存在覆盖或者织入的话需要创建动态代理将方法织入，这个时候就只能选择 CGLIB 的方式来实例化，否则直接利用反射的方式即可，方便快捷。\n\n到这里 `createBeanInstance()` 的过程就已经分析完毕了，下篇介绍 `doCreateBean()` 方法中的第二个过程：属性填充。","source":"_posts/spring 源码分析/spring/spring源码解析之 22构造函数实例化.md","raw":"abbrlink: 41\ntitle: ' spring源码解析之 22构造函数实例化'\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-15 03:36:00\n---\n# spring源码解析之 22构造函数实例化\n\n## autowireConstructor()\n\n这个初始化方法我们可以简单理解为是带有参数的初始化 bean 。代码段如下：\n<!-- more -->\n\n```java\n  \tpublic BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,\n\t\t\t\t\t\t\t\t\t\t   @Nullable Constructor<?>[] chosenCtors, \n                                           @Nullable Object[] explicitArgs) {\n\t\t// 实例化BeanWrapper对象\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tConstructor<?> constructorToUse = null;\n\t\tArgumentsHolder argsHolderToUse = null;\n\t\tObject[] argsToUse = null;\n\t\t// explicit通过getBean方法传入\n\t\t// 如果getBean方法调用的时候指定方法参数，那么直接使用\n\t\tif (explicitArgs != null) {\n\t\t\targsToUse = explicitArgs;\n\t\t} else {\n\t\t\t// 如果在getBean方法时候没有指定则尝试从配置文件中解析\n\t\t\tObject[] argsToResolve = null;\n\n\t\t\t// 尝试从缓存中获取获取参数\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tconstructorToUse = (Constructor<?>)\n                    mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (constructorToUse != null && mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// 缓存中的构造参数\n\t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse == null) {\n\t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 如果缓存中存在\n\t\t\tif (argsToResolve != null) {\n\t\t\t\t// 解析参数类型，如给定方法的构造函数A(int,int)则通过此方法后就会\n\t\t\t\t// 把配置中(\"1\",\"1\")转换为(1,1)\n\t\t\t\t// 缓存中的值可能是原始值也可能是最终值，在这里做处理\n\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd,\n                                                     bw, constructorToUse, \n                                                     argsToResolve, true);\n\t\t\t}\n\t\t}\n\t\t// 没有缓存也没有明确指定\n\t\tif (constructorToUse == null || argsToUse == null) {\n\t\t\t// Take specified constructors, if any.\n\t\t\tConstructor<?>[] candidates = chosenCtors;\n\n\t\t\t// 如果参数中没有指定构造函数\n\t\t\tif (candidates == null) {\n\t\t\t\t// 获取当前bean对应的class对象\n\t\t\t\tClass<?> beanClass = mbd.getBeanClass();\n\t\t\t\ttry {\n\t\t\t\t\t// 获取所有的构造函数\n\t\t\t\t\tcandidates = (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\tbeanClass.getDeclaredConstructors() : \n                                  beanClass.getConstructors());\n\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 如果只有默认构造函数并且配置文件中也没有参数配置\n\t\t\tif (candidates.length == 1 && explicitArgs == null \n                && !mbd.hasConstructorArgumentValues()) {\n\t\t\t\tConstructor<?> uniqueCandidate = candidates[0];\n\t\t\t\t// 缓存构造函数\n\t\t\t\tif (uniqueCandidate.getParameterCount() == 0) {\n\t\t\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\t\t\tmbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;\n\t\t\t\t\t\tmbd.constructorArgumentsResolved = true;\n\t\t\t\t\t\tmbd.resolvedConstructorArguments = EMPTY_ARGS;\n\t\t\t\t\t}\n\t\t\t\t\t// 使用默认构造函数初始化对象\n\t\t\t\t\tbw.setBeanInstance(instantiate(beanName, mbd, \n                                                   uniqueCandidate, EMPTY_ARGS));\n\t\t\t\t\treturn bw;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// Need to resolve the constructor.\n\t\t\t// 判断是否需要解析构造函数\n\t\t\tboolean autowiring = (chosenCtors != null ||\n\t\t\t\t\tmbd.getResolvedAutowireMode() == \n                                  AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);\n\n\t\t\t// 用于承载解析后的构造函数的值\n\t\t\tConstructorArgumentValues resolvedValues = null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs != null) {\n\t\t\t\tminNrOfArgs = explicitArgs.length;\n\t\t\t} else {\n\t\t\t\t// 从BeanDefinition中获取构造参数，也就是从配置文件中提取构造函数\n\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n\t\t\t\t// 解析构造函数的参数\n\t\t\t\t// 将该bean的构造函数参数解析为resolvedValues对象，其中会涉及到其它bean\n\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, \n                                                          cargs, resolvedValues);\n\t\t\t}\n\t\t\t// 对构造函数进行排序处理\n\t\t\t// public 构造函数优先参数数量降序，非public 构造函数参数数量降序\n\t\t\tAutowireUtils.sortConstructors(candidates);\n\t\t\t//  最小参数类型权重\n\t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n\t\t\tSet<Constructor<?>> ambiguousConstructors = null;\n\t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n\n\t\t\t// 迭代所有构造函数\n\t\t\tfor (Constructor<?> candidate : candidates) {\n\t\t\t\t// 获取构造函数参数类型\n\t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n\t\t\t\t// 如果已经找到选用的构造函数或者需要的参数个数小于当前的构造函数参数个数，则终止\n\t\t\t\t// 因为已经按照参数个数降序排列了\n\t\t\t\tif (constructorToUse != null && argsToUse != null &&\n                    argsToUse.length > paramTypes.length) {\n\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 参数个数不等，继续\n\t\t\t\tif (paramTypes.length < minNrOfArgs) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// 参数持有者\n\t\t\t\tArgumentsHolder argsHolder;\n\t\t\t\t// 有参数\n\t\t\t\tif (resolvedValues != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// 注解上获取参数名称\n\t\t\t\t\t\tString[] paramNames = \n                            ConstructorPropertiesChecker.evaluate(candidate, \n                                                                  paramTypes.length);\n\n\t\t\t\t\t\tif (paramNames == null) {\n\t\t\t\t\t\t\t// 获取构造函数、方法参数的探测器\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd = \n                                this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd != null) {\n\t\t\t\t\t\t\t\t// 通过探测器获取构造函数的参数名称\n\t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 根据构造函数和构造参数创建参数持有者\n\t\t\t\t\t\targsHolder = createArgumentArray(beanName, mbd, \n                                                         resolvedValues, bw, \n                                                         paramTypes, paramNames,\n\t\t\t\t\t\t\t\tgetUserDeclaredConstructor(candidate), autowiring, \n                                                         candidates.length == 1);\n\t\t\t\t\t} catch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Swallow and try next constructor.\n\t\t\t\t\t\tif (causes == null) {\n\t\t\t\t\t\t\tcauses = new LinkedList<>();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// 构造函数没有参数\n\t\t\t\t\n\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n\t\t\t\t}\n\t\t\t//isLenientConstructorResolution判断解析构造函数的时候是否以宽松模式还是严格模式\n\t\t\t\t// 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常\n\t\t\t\t// 宽松模式：使用具有\"最接近的模式\"进行匹配\n\t\t\t\t// typeDiffWeight：类型差异权重\n\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) :\n                                      argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t// 如果它代表着当前最接近的匹配则选择其作为构造函数\n\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n\t\t\t\t\tconstructorToUse = candidate;\n\t\t\t\t\targsHolderToUse = argsHolder;\n\t\t\t\t\targsToUse = argsHolder.arguments;\n\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n\t\t\t\t\tambiguousConstructors = null;\n\t\t\t\t} else if (constructorToUse != null &&\n                           typeDiffWeight == minTypeDiffWeight) {\n\t\t\t\t\tif (ambiguousConstructors == null) {\n\t\t\t\t\t\tambiguousConstructors = new LinkedHashSet<>();\n\t\t\t\t\t\tambiguousConstructors.add(constructorToUse);\n\t\t\t\t\t}\n\t\t\t\t\tambiguousConstructors.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (constructorToUse == null) {\n\t\t\t\tif (causes != null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\n\t\t\t} else if (ambiguousConstructors != null && \n                       !mbd.isLenientConstructorResolution()) {\n\t\t\t\n\t\t\t}\n\t\t\t// 将构造函数、构造参数保存到缓存中\n\t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, constructorToUse);\n\t\t\t}\n\t\t}\n\n\t\tAssert.state(argsToUse != null, \"Unresolved constructor arguments\");\n\t\t// 实例化bean\n\t\tbw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));\n\t\treturn bw;\n\t}\n\n```\n\n代码与 `instantiateUsingFactoryMethod()` 一样，又长又难懂，但是如果理解了 `instantiateUsingFactoryMethod()` 初始化 bean 的过程，那么 `autowireConstructor()` 也不存在什么难的地方了，一句话概括：首先确定构造函数参数、构造函数，然后调用相应的初始化策略进行 bean 的初始化。关于如何确定构造函数、构造参数，该部分逻辑和 `instantiateUsingFactoryMethod()` 基本一致。所以这里你应该相对会轻松点\n\n1. 构造函数参数的确定\n\n   * 根据explicitArgs参数判断\n\n     如果传入的参数explicitArgs不为空，那边可以直接确定参数，因为explicitArgs参数是在调用bean的时候用户指定的，在BeanFactory类中存在这样的方法：\n\n     ```java\n     Object getBean(String name,Object... args) throws BeansException\n     ```\n\n     在获取bean的时候，用户不但可以指定bean的名称还可以指定bean对应类的构造函数或者工厂方法的方法参数，主要用于静态工厂方法的调用，而这里需要先给定完全匹配的参数，如果传入参数explicitArg不为空，则可以确定构造函数参数就是它。\n\n   * 缓存中获取\n\n     除此之外，确定参数的办法如果之前已经分析过，也就是说构造参数已经记录在缓存中，那么便可以直接拿来使用。而且，这里要提到的是，在魂村中换粗的可能是参数的最终类型也可能是参数的初始类型。如果是初始类型，则需要进行转换。\n\n   * 配置文件中获取\n\n     如果不能根据传入参数explicit·Arg确定构造函数的参数也无法在缓存中得到相关信息，那么只能开始新一轮的分析。分析从配置文件中配置的构造函数信息开始，经过之前的分析，我们知道，spring中配置文件中的信息经过转换都会通过BeanDefinition实例承载，也就是参数mbd中包含，那么可以荣国调用mdb.getCOntructorArgumentValues来获取配置的构造函数信息。有了配置中的信息便可以获取对应的参数值信息。获取参数值的信息包括直接指定值，如：直接指定构造函数中某个值为原始类型String类型，或者是一个队其他bean的引用，这里处理委托给resolveCOnstrucorArguments方法，并返回能解析到的参数的个数\n\n2. 构造函数的确定\n\n   经过了第一步后已经确定了构造函数的参数，接下来的任务就是根据构造函数参数在所有构造函数中锁定对应的构造函数，而匹配的方法就是根据参数个数匹配，所以在匹配之前需要先对构造函数按照public构造函数优先参数量降序、feipublic构造函数参数数量降序，这样可以在遍历的情况下循序判断牌子啊后面的构造函数参数个数是否符合条件。\n\n   由于在配置文件中并不是唯一现在使用参数位置索引的方式去创建，同样还支持指定参数名称进行设定参数值的情况，如`<constructor-arg name=\"aa\">`，那么这种情况就需要首先确定构造函数中的参数名称。\n\n   获取参数名称可以有俩种方式，一种是通过注解的方式直接获取，另一种就是使用spring中提供的工具类ParameterNameDiscover来获取，构造函数、参数名称、参数哦类型、参数值都确定后就可以锁定构造函数以及转换对应的参数类型。\n\n3. 根据确定的构造函数转换对应的参数类型\n\n   主要使用spring中提供的类型转换器或者用户提供的自定义类型转换器进行转换。\n\n4. 根据构造函数不确定性的验证\n\n   当然，有时候即使构造函数，参数名称，参数类型、参数值都确定后也不一定会直接锁定构造函数，不同构造函数的参数为父子类型，所以spring在最后有做了一次验证。\n\n   根据实例化策略以及得到的构造函数即构造函数参数实例化bean。下面我们重点分析初始化策略：\n\n对于初始化策略，首先是获取实例化 bean 的策略，如下：\n\n```java\nfinal InstantiationStrategy strategy = beanFactory.getInstantiationStrategy();\n```\n\n然后是调用其 `instantiate()`方法，该方法在 SimpleInstantiationStrategy 中实现，如下：\n\n```java\n    public Object instantiate(RootBeanDefinition bd, \n                              @Nullable String beanName, BeanFactory owner) {\n        // 没有覆盖\n        // 直接使用反射实例化即可\n        if (!bd.hasMethodOverrides()) {\n            // 重新检测获取下构造函数\n            // 该构造函数是经过前面 N 多复杂过程确认的构造函数\n            Constructor<?> constructorToUse;\n            synchronized (bd.constructorArgumentLock) {\n                // 获取已经解析的构造函数\n                constructorToUse = (Constructor<?>) \n                    bd.resolvedConstructorOrFactoryMethod;\n                // 如果为 null，从 class 中解析获取，并设置\n                if (constructorToUse == null) {\n                    final Class<?> clazz = bd.getBeanClass();\n                    if (clazz.isInterface()) {\n                        throw new BeanInstantiationException(clazz, \n                                    】\"Specified class is an interface\");\n                    }\n                    try {\n                        if (System.getSecurityManager() != null) {\n                            constructorToUse = AccessController.doPrivileged(\n                                    (PrivilegedExceptionAction<Constructor<?>>) \n                                clazz::getDeclaredConstructor);\n                        }\n                        else {\n                            constructorToUse =  clazz.getDeclaredConstructor();\n                        }\n                        bd.resolvedConstructorOrFactoryMethod = constructorToUse;\n                    }\n                    catch (Throwable ex) {\n                        throw new BeanInstantiationException(clazz,\n                                 \"No default constructor found\", ex);\n                    }\n                }\n            }\n\n            // 通过BeanUtils直接使用构造器对象实例化bean\n            return BeanUtils.instantiateClass(constructorToUse);\n        }\n        else {\n            // 生成CGLIB创建的子类对象\n            return instantiateWithMethodInjection(bd, beanName, owner);\n        }\n    }\n```\n\n如果该 bean 没有配置 lookup-method、replaced-method 标签或者 @Lookup 注解，则直接通过反射的方式实例化 bean 即可，方便快捷，但是如果存在需要覆盖的方法或者动态替换的方法则需要使用 CGLIB 进行动态代理，因为可以在创建代理的同时将动态方法织入类中。\n\n**反射**\n\n调用工具类 BeanUtils 的 `instantiateClass()` 方法完成反射工作：\n\n```java\n    public static <T> T instantiateClass(Constructor<T> ctor, Object... args)\n        throws BeanInstantiationException {\n        Assert.notNull(ctor, \"Constructor must not be null\");\n        try {\n            ReflectionUtils.makeAccessible(ctor);\n            return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?\n                    KotlinDelegate.instantiateClass(ctor, args) : \n                    ctor.newInstance(args));\n        }\n        // 省略一些 catch \n    }\n```\n\n**CGLIB**\n\n```java\n    protected Object instantiateWithMethodInjection(RootBeanDefinition bd,\n                      @Nullable String beanName, BeanFactory owner) {\n        throw new UnsupportedOperationException(\"Method Injection not supported in SimpleInstantiationStrategy\");\n    }\n```\n\n方法默认是没有实现的，具体过程由其子类 CglibSubclassingInstantiationStrategy 实现：\n\n```java\n    protected Object instantiateWithMethodInjection(RootBeanDefinition bd, \n                      @Nullable String beanName, BeanFactory owner) {\n        return instantiateWithMethodInjection(bd, beanName, owner, null);\n    }\n\n    protected Object instantiateWithMethodInjection(RootBeanDefinition bd, \n                            @Nullable String beanName, BeanFactory owner,\n            @Nullable Constructor<?> ctor, @Nullable Object... args) {\n\n        // 通过CGLIB生成一个子类对象\n        return new CglibSubclassCreator(bd, owner).instantiate(ctor, args);\n    }\n```\n\n创建一个 CglibSubclassCreator 对象，调用其 `instantiate()` 方法生成其子类对象：\n\n```java\n    public Object instantiate(@Nullable Constructor<?> ctor, @Nullable Object... args) \n    {\n        // 通过 Cglib 创建一个代理类\n        Class<?> subclass = createEnhancedSubclass(this.beanDefinition);\n        Object instance;\n        // 没有构造器，通过 BeanUtils 使用默认构造器创建一个bean实例\n        if (ctor == null) {\n            instance = BeanUtils.instantiateClass(subclass);\n        }\n        else {\n            try {\n                // 获取代理类对应的构造器对象，并实例化 bean\n                Constructor<?> enhancedSubclassConstructor = \n                    subclass.getConstructor(ctor.getParameterTypes());\n                instance = enhancedSubclassConstructor.newInstance(args);\n            }\n            catch (Exception ex) {\n              \n            }\n        }\n\n        // 为了避免memory leaks异常，直接在bean实例上设置回调对象\n        Factory factory = (Factory) instance;\n        factory.setCallbacks(new Callback[] {NoOp.INSTANCE,\n                new CglibSubclassingInstantiationStrategy\n                    .LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),\n                new CglibSubclassingInstantiationStrategy\n                    .ReplaceOverrideMethodInterceptor(this.beanDefinition, \n                                                      this.owner)});\n        return instance;\n    }\n```\n\n到这类 CGLIB 的方式分析完毕了，当然这里还没有具体分析 CGLIB 生成子类的详细过程，具体的过程等后续分析 AOP 的时候再详细地介绍。\n\n## instantiateBean()\n\n```java\n   protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {\n        try {\n            Object beanInstance;\n            final BeanFactory parent = this;\n            if (System.getSecurityManager() != null) {\n                beanInstance = AccessController.doPrivileged(\n                    (PrivilegedAction<Object>) () ->\n                                getInstantiationStrategy().instantiate(mbd,\n                                   beanName, parent),\n                        getAccessControlContext());\n            }\n            else {\n                beanInstance = getInstantiationStrategy()\n                    \t\t.instantiate(mbd, beanName, parent);\n            }\n            BeanWrapper bw = new BeanWrapperImpl(beanInstance);\n            initBeanWrapper(bw);\n            return bw;\n        }\n        catch (Throwable ex) {\n          \t、、。。。\n        }\n    }\n```\n\n这个方法相比于 `instantiateUsingFactoryMethod()` 、 `autowireConstructor()` 方法实在是太简单了，因为它没有参数，所以不需要确认经过复杂的过来来确定构造器、构造参数，所以这里就不过多阐述了。\n\n对于 `createBeanInstance()` 而言，他就是选择合适实例化策略来为 bean 创建实例对象，具体的策略有：Supplier 回调方式、工厂方法初始化、构造函数自动注入初始化、默认构造函数注入。其中工厂方法初始化和构造函数自动注入初始化两种方式最为复杂，主要是因为构造函数和构造参数的不确定性，Spring 需要花大量的精力来确定构造函数和构造参数，如果确定了则好办，直接选择实例化策略即可。当然在实例化的时候会根据是否有需要覆盖或者动态替换掉的方法，因为存在覆盖或者织入的话需要创建动态代理将方法织入，这个时候就只能选择 CGLIB 的方式来实例化，否则直接利用反射的方式即可，方便快捷。\n\n到这里 `createBeanInstance()` 的过程就已经分析完毕了，下篇介绍 `doCreateBean()` 方法中的第二个过程：属性填充。","slug":"spring 源码分析/spring/spring源码解析之 22构造函数实例化","published":1,"updated":"2019-01-16T08:35:24.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovxa005q9q1uqac42tc7","content":"<h1 id=\"spring源码解析之-22构造函数实例化\"><a href=\"#spring源码解析之-22构造函数实例化\" class=\"headerlink\" title=\"spring源码解析之 22构造函数实例化\"></a>spring源码解析之 22构造函数实例化</h1><h2 id=\"autowireConstructor\"><a href=\"#autowireConstructor\" class=\"headerlink\" title=\"autowireConstructor()\"></a>autowireConstructor()</h2><p>这个初始化方法我们可以简单理解为是带有参数的初始化 bean 。代码段如下：<br><a id=\"more\"></a></p>\n<pre><code class=\"java\">      public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,\n                                           @Nullable Constructor&lt;?&gt;[] chosenCtors, \n                                           @Nullable Object[] explicitArgs) {\n        // 实例化BeanWrapper对象\n        BeanWrapperImpl bw = new BeanWrapperImpl();\n        this.beanFactory.initBeanWrapper(bw);\n\n        Constructor&lt;?&gt; constructorToUse = null;\n        ArgumentsHolder argsHolderToUse = null;\n        Object[] argsToUse = null;\n        // explicit通过getBean方法传入\n        // 如果getBean方法调用的时候指定方法参数，那么直接使用\n        if (explicitArgs != null) {\n            argsToUse = explicitArgs;\n        } else {\n            // 如果在getBean方法时候没有指定则尝试从配置文件中解析\n            Object[] argsToResolve = null;\n\n            // 尝试从缓存中获取获取参数\n            synchronized (mbd.constructorArgumentLock) {\n                constructorToUse = (Constructor&lt;?&gt;)\n                    mbd.resolvedConstructorOrFactoryMethod;\n                if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {\n                    // 缓存中的构造参数\n                    argsToUse = mbd.resolvedConstructorArguments;\n                    if (argsToUse == null) {\n                        argsToResolve = mbd.preparedConstructorArguments;\n                    }\n                }\n            }\n            // 如果缓存中存在\n            if (argsToResolve != null) {\n                // 解析参数类型，如给定方法的构造函数A(int,int)则通过此方法后就会\n                // 把配置中(&quot;1&quot;,&quot;1&quot;)转换为(1,1)\n                // 缓存中的值可能是原始值也可能是最终值，在这里做处理\n                argsToUse = resolvePreparedArguments(beanName, mbd,\n                                                     bw, constructorToUse, \n                                                     argsToResolve, true);\n            }\n        }\n        // 没有缓存也没有明确指定\n        if (constructorToUse == null || argsToUse == null) {\n            // Take specified constructors, if any.\n            Constructor&lt;?&gt;[] candidates = chosenCtors;\n\n            // 如果参数中没有指定构造函数\n            if (candidates == null) {\n                // 获取当前bean对应的class对象\n                Class&lt;?&gt; beanClass = mbd.getBeanClass();\n                try {\n                    // 获取所有的构造函数\n                    candidates = (mbd.isNonPublicAccessAllowed() ?\n                            beanClass.getDeclaredConstructors() : \n                                  beanClass.getConstructors());\n                } catch (Throwable ex) {\n\n                }\n            }\n            // 如果只有默认构造函数并且配置文件中也没有参数配置\n            if (candidates.length == 1 &amp;&amp; explicitArgs == null \n                &amp;&amp; !mbd.hasConstructorArgumentValues()) {\n                Constructor&lt;?&gt; uniqueCandidate = candidates[0];\n                // 缓存构造函数\n                if (uniqueCandidate.getParameterCount() == 0) {\n                    synchronized (mbd.constructorArgumentLock) {\n                        mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;\n                        mbd.constructorArgumentsResolved = true;\n                        mbd.resolvedConstructorArguments = EMPTY_ARGS;\n                    }\n                    // 使用默认构造函数初始化对象\n                    bw.setBeanInstance(instantiate(beanName, mbd, \n                                                   uniqueCandidate, EMPTY_ARGS));\n                    return bw;\n                }\n            }\n\n\n            // Need to resolve the constructor.\n            // 判断是否需要解析构造函数\n            boolean autowiring = (chosenCtors != null ||\n                    mbd.getResolvedAutowireMode() == \n                                  AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);\n\n            // 用于承载解析后的构造函数的值\n            ConstructorArgumentValues resolvedValues = null;\n\n            int minNrOfArgs;\n            if (explicitArgs != null) {\n                minNrOfArgs = explicitArgs.length;\n            } else {\n                // 从BeanDefinition中获取构造参数，也就是从配置文件中提取构造函数\n                ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n                resolvedValues = new ConstructorArgumentValues();\n                // 解析构造函数的参数\n                // 将该bean的构造函数参数解析为resolvedValues对象，其中会涉及到其它bean\n                minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, \n                                                          cargs, resolvedValues);\n            }\n            // 对构造函数进行排序处理\n            // public 构造函数优先参数数量降序，非public 构造函数参数数量降序\n            AutowireUtils.sortConstructors(candidates);\n            //  最小参数类型权重\n            int minTypeDiffWeight = Integer.MAX_VALUE;\n            Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = null;\n            LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null;\n\n            // 迭代所有构造函数\n            for (Constructor&lt;?&gt; candidate : candidates) {\n                // 获取构造函数参数类型\n                Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();\n                // 如果已经找到选用的构造函数或者需要的参数个数小于当前的构造函数参数个数，则终止\n                // 因为已经按照参数个数降序排列了\n                if (constructorToUse != null &amp;&amp; argsToUse != null &amp;&amp;\n                    argsToUse.length &gt; paramTypes.length) {\n\n                    break;\n                }\n                // 参数个数不等，继续\n                if (paramTypes.length &lt; minNrOfArgs) {\n                    continue;\n                }\n\n                // 参数持有者\n                ArgumentsHolder argsHolder;\n                // 有参数\n                if (resolvedValues != null) {\n                    try {\n                        // 注解上获取参数名称\n                        String[] paramNames = \n                            ConstructorPropertiesChecker.evaluate(candidate, \n                                                                  paramTypes.length);\n\n                        if (paramNames == null) {\n                            // 获取构造函数、方法参数的探测器\n                            ParameterNameDiscoverer pnd = \n                                this.beanFactory.getParameterNameDiscoverer();\n                            if (pnd != null) {\n                                // 通过探测器获取构造函数的参数名称\n                                paramNames = pnd.getParameterNames(candidate);\n                            }\n                        }\n                        // 根据构造函数和构造参数创建参数持有者\n                        argsHolder = createArgumentArray(beanName, mbd, \n                                                         resolvedValues, bw, \n                                                         paramTypes, paramNames,\n                                getUserDeclaredConstructor(candidate), autowiring, \n                                                         candidates.length == 1);\n                    } catch (UnsatisfiedDependencyException ex) {\n\n                        }\n                        // Swallow and try next constructor.\n                        if (causes == null) {\n                            causes = new LinkedList&lt;&gt;();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    // 构造函数没有参数\n\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n            //isLenientConstructorResolution判断解析构造函数的时候是否以宽松模式还是严格模式\n                // 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常\n                // 宽松模式：使用具有&quot;最接近的模式&quot;进行匹配\n                // typeDiffWeight：类型差异权重\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n                        argsHolder.getTypeDifferenceWeight(paramTypes) :\n                                      argsHolder.getAssignabilityWeight(paramTypes));\n                // Choose this constructor if it represents the closest match.\n                // 如果它代表着当前最接近的匹配则选择其作为构造函数\n                if (typeDiffWeight &lt; minTypeDiffWeight) {\n                    constructorToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousConstructors = null;\n                } else if (constructorToUse != null &amp;&amp;\n                           typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousConstructors == null) {\n                        ambiguousConstructors = new LinkedHashSet&lt;&gt;();\n                        ambiguousConstructors.add(constructorToUse);\n                    }\n                    ambiguousConstructors.add(candidate);\n                }\n            }\n\n            if (constructorToUse == null) {\n                if (causes != null) {\n                    UnsatisfiedDependencyException ex = causes.removeLast();\n                    for (Exception cause : causes) {\n                        this.beanFactory.onSuppressedException(cause);\n                    }\n                    throw ex;\n                }\n\n            } else if (ambiguousConstructors != null &amp;&amp; \n                       !mbd.isLenientConstructorResolution()) {\n\n            }\n            // 将构造函数、构造参数保存到缓存中\n            if (explicitArgs == null &amp;&amp; argsHolderToUse != null) {\n                argsHolderToUse.storeCache(mbd, constructorToUse);\n            }\n        }\n\n        Assert.state(argsToUse != null, &quot;Unresolved constructor arguments&quot;);\n        // 实例化bean\n        bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));\n        return bw;\n    }\n\n</code></pre>\n<p>代码与 <code>instantiateUsingFactoryMethod()</code> 一样，又长又难懂，但是如果理解了 <code>instantiateUsingFactoryMethod()</code> 初始化 bean 的过程，那么 <code>autowireConstructor()</code> 也不存在什么难的地方了，一句话概括：首先确定构造函数参数、构造函数，然后调用相应的初始化策略进行 bean 的初始化。关于如何确定构造函数、构造参数，该部分逻辑和 <code>instantiateUsingFactoryMethod()</code> 基本一致。所以这里你应该相对会轻松点</p>\n<ol>\n<li><p>构造函数参数的确定</p>\n<ul>\n<li><p>根据explicitArgs参数判断</p>\n<p>如果传入的参数explicitArgs不为空，那边可以直接确定参数，因为explicitArgs参数是在调用bean的时候用户指定的，在BeanFactory类中存在这样的方法：</p>\n<pre><code class=\"java\">Object getBean(String name,Object... args) throws BeansException\n</code></pre>\n<p>在获取bean的时候，用户不但可以指定bean的名称还可以指定bean对应类的构造函数或者工厂方法的方法参数，主要用于静态工厂方法的调用，而这里需要先给定完全匹配的参数，如果传入参数explicitArg不为空，则可以确定构造函数参数就是它。</p>\n</li>\n<li><p>缓存中获取</p>\n<p>除此之外，确定参数的办法如果之前已经分析过，也就是说构造参数已经记录在缓存中，那么便可以直接拿来使用。而且，这里要提到的是，在魂村中换粗的可能是参数的最终类型也可能是参数的初始类型。如果是初始类型，则需要进行转换。</p>\n</li>\n<li><p>配置文件中获取</p>\n<p>如果不能根据传入参数explicit·Arg确定构造函数的参数也无法在缓存中得到相关信息，那么只能开始新一轮的分析。分析从配置文件中配置的构造函数信息开始，经过之前的分析，我们知道，spring中配置文件中的信息经过转换都会通过BeanDefinition实例承载，也就是参数mbd中包含，那么可以荣国调用mdb.getCOntructorArgumentValues来获取配置的构造函数信息。有了配置中的信息便可以获取对应的参数值信息。获取参数值的信息包括直接指定值，如：直接指定构造函数中某个值为原始类型String类型，或者是一个队其他bean的引用，这里处理委托给resolveCOnstrucorArguments方法，并返回能解析到的参数的个数</p>\n</li>\n</ul>\n</li>\n<li><p>构造函数的确定</p>\n<p>经过了第一步后已经确定了构造函数的参数，接下来的任务就是根据构造函数参数在所有构造函数中锁定对应的构造函数，而匹配的方法就是根据参数个数匹配，所以在匹配之前需要先对构造函数按照public构造函数优先参数量降序、feipublic构造函数参数数量降序，这样可以在遍历的情况下循序判断牌子啊后面的构造函数参数个数是否符合条件。</p>\n<p>由于在配置文件中并不是唯一现在使用参数位置索引的方式去创建，同样还支持指定参数名称进行设定参数值的情况，如<code>&lt;constructor-arg name=&quot;aa&quot;&gt;</code>，那么这种情况就需要首先确定构造函数中的参数名称。</p>\n<p>获取参数名称可以有俩种方式，一种是通过注解的方式直接获取，另一种就是使用spring中提供的工具类ParameterNameDiscover来获取，构造函数、参数名称、参数哦类型、参数值都确定后就可以锁定构造函数以及转换对应的参数类型。</p>\n</li>\n<li><p>根据确定的构造函数转换对应的参数类型</p>\n<p>主要使用spring中提供的类型转换器或者用户提供的自定义类型转换器进行转换。</p>\n</li>\n<li><p>根据构造函数不确定性的验证</p>\n<p>当然，有时候即使构造函数，参数名称，参数类型、参数值都确定后也不一定会直接锁定构造函数，不同构造函数的参数为父子类型，所以spring在最后有做了一次验证。</p>\n<p>根据实例化策略以及得到的构造函数即构造函数参数实例化bean。下面我们重点分析初始化策略：</p>\n</li>\n</ol>\n<p>对于初始化策略，首先是获取实例化 bean 的策略，如下：</p>\n<pre><code class=\"java\">final InstantiationStrategy strategy = beanFactory.getInstantiationStrategy();\n</code></pre>\n<p>然后是调用其 <code>instantiate()</code>方法，该方法在 SimpleInstantiationStrategy 中实现，如下：</p>\n<pre><code class=\"java\">    public Object instantiate(RootBeanDefinition bd, \n                              @Nullable String beanName, BeanFactory owner) {\n        // 没有覆盖\n        // 直接使用反射实例化即可\n        if (!bd.hasMethodOverrides()) {\n            // 重新检测获取下构造函数\n            // 该构造函数是经过前面 N 多复杂过程确认的构造函数\n            Constructor&lt;?&gt; constructorToUse;\n            synchronized (bd.constructorArgumentLock) {\n                // 获取已经解析的构造函数\n                constructorToUse = (Constructor&lt;?&gt;) \n                    bd.resolvedConstructorOrFactoryMethod;\n                // 如果为 null，从 class 中解析获取，并设置\n                if (constructorToUse == null) {\n                    final Class&lt;?&gt; clazz = bd.getBeanClass();\n                    if (clazz.isInterface()) {\n                        throw new BeanInstantiationException(clazz, \n                                    】&quot;Specified class is an interface&quot;);\n                    }\n                    try {\n                        if (System.getSecurityManager() != null) {\n                            constructorToUse = AccessController.doPrivileged(\n                                    (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) \n                                clazz::getDeclaredConstructor);\n                        }\n                        else {\n                            constructorToUse =  clazz.getDeclaredConstructor();\n                        }\n                        bd.resolvedConstructorOrFactoryMethod = constructorToUse;\n                    }\n                    catch (Throwable ex) {\n                        throw new BeanInstantiationException(clazz,\n                                 &quot;No default constructor found&quot;, ex);\n                    }\n                }\n            }\n\n            // 通过BeanUtils直接使用构造器对象实例化bean\n            return BeanUtils.instantiateClass(constructorToUse);\n        }\n        else {\n            // 生成CGLIB创建的子类对象\n            return instantiateWithMethodInjection(bd, beanName, owner);\n        }\n    }\n</code></pre>\n<p>如果该 bean 没有配置 lookup-method、replaced-method 标签或者 @Lookup 注解，则直接通过反射的方式实例化 bean 即可，方便快捷，但是如果存在需要覆盖的方法或者动态替换的方法则需要使用 CGLIB 进行动态代理，因为可以在创建代理的同时将动态方法织入类中。</p>\n<p><strong>反射</strong></p>\n<p>调用工具类 BeanUtils 的 <code>instantiateClass()</code> 方法完成反射工作：</p>\n<pre><code class=\"java\">    public static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args)\n        throws BeanInstantiationException {\n        Assert.notNull(ctor, &quot;Constructor must not be null&quot;);\n        try {\n            ReflectionUtils.makeAccessible(ctor);\n            return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?\n                    KotlinDelegate.instantiateClass(ctor, args) : \n                    ctor.newInstance(args));\n        }\n        // 省略一些 catch \n    }\n</code></pre>\n<p><strong>CGLIB</strong></p>\n<pre><code class=\"java\">    protected Object instantiateWithMethodInjection(RootBeanDefinition bd,\n                      @Nullable String beanName, BeanFactory owner) {\n        throw new UnsupportedOperationException(&quot;Method Injection not supported in SimpleInstantiationStrategy&quot;);\n    }\n</code></pre>\n<p>方法默认是没有实现的，具体过程由其子类 CglibSubclassingInstantiationStrategy 实现：</p>\n<pre><code class=\"java\">    protected Object instantiateWithMethodInjection(RootBeanDefinition bd, \n                      @Nullable String beanName, BeanFactory owner) {\n        return instantiateWithMethodInjection(bd, beanName, owner, null);\n    }\n\n    protected Object instantiateWithMethodInjection(RootBeanDefinition bd, \n                            @Nullable String beanName, BeanFactory owner,\n            @Nullable Constructor&lt;?&gt; ctor, @Nullable Object... args) {\n\n        // 通过CGLIB生成一个子类对象\n        return new CglibSubclassCreator(bd, owner).instantiate(ctor, args);\n    }\n</code></pre>\n<p>创建一个 CglibSubclassCreator 对象，调用其 <code>instantiate()</code> 方法生成其子类对象：</p>\n<pre><code class=\"java\">    public Object instantiate(@Nullable Constructor&lt;?&gt; ctor, @Nullable Object... args) \n    {\n        // 通过 Cglib 创建一个代理类\n        Class&lt;?&gt; subclass = createEnhancedSubclass(this.beanDefinition);\n        Object instance;\n        // 没有构造器，通过 BeanUtils 使用默认构造器创建一个bean实例\n        if (ctor == null) {\n            instance = BeanUtils.instantiateClass(subclass);\n        }\n        else {\n            try {\n                // 获取代理类对应的构造器对象，并实例化 bean\n                Constructor&lt;?&gt; enhancedSubclassConstructor = \n                    subclass.getConstructor(ctor.getParameterTypes());\n                instance = enhancedSubclassConstructor.newInstance(args);\n            }\n            catch (Exception ex) {\n\n            }\n        }\n\n        // 为了避免memory leaks异常，直接在bean实例上设置回调对象\n        Factory factory = (Factory) instance;\n        factory.setCallbacks(new Callback[] {NoOp.INSTANCE,\n                new CglibSubclassingInstantiationStrategy\n                    .LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),\n                new CglibSubclassingInstantiationStrategy\n                    .ReplaceOverrideMethodInterceptor(this.beanDefinition, \n                                                      this.owner)});\n        return instance;\n    }\n</code></pre>\n<p>到这类 CGLIB 的方式分析完毕了，当然这里还没有具体分析 CGLIB 生成子类的详细过程，具体的过程等后续分析 AOP 的时候再详细地介绍。</p>\n<h2 id=\"instantiateBean\"><a href=\"#instantiateBean\" class=\"headerlink\" title=\"instantiateBean()\"></a>instantiateBean()</h2><pre><code class=\"java\">   protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {\n        try {\n            Object beanInstance;\n            final BeanFactory parent = this;\n            if (System.getSecurityManager() != null) {\n                beanInstance = AccessController.doPrivileged(\n                    (PrivilegedAction&lt;Object&gt;) () -&gt;\n                                getInstantiationStrategy().instantiate(mbd,\n                                   beanName, parent),\n                        getAccessControlContext());\n            }\n            else {\n                beanInstance = getInstantiationStrategy()\n                            .instantiate(mbd, beanName, parent);\n            }\n            BeanWrapper bw = new BeanWrapperImpl(beanInstance);\n            initBeanWrapper(bw);\n            return bw;\n        }\n        catch (Throwable ex) {\n              、、。。。\n        }\n    }\n</code></pre>\n<p>这个方法相比于 <code>instantiateUsingFactoryMethod()</code> 、 <code>autowireConstructor()</code> 方法实在是太简单了，因为它没有参数，所以不需要确认经过复杂的过来来确定构造器、构造参数，所以这里就不过多阐述了。</p>\n<p>对于 <code>createBeanInstance()</code> 而言，他就是选择合适实例化策略来为 bean 创建实例对象，具体的策略有：Supplier 回调方式、工厂方法初始化、构造函数自动注入初始化、默认构造函数注入。其中工厂方法初始化和构造函数自动注入初始化两种方式最为复杂，主要是因为构造函数和构造参数的不确定性，Spring 需要花大量的精力来确定构造函数和构造参数，如果确定了则好办，直接选择实例化策略即可。当然在实例化的时候会根据是否有需要覆盖或者动态替换掉的方法，因为存在覆盖或者织入的话需要创建动态代理将方法织入，这个时候就只能选择 CGLIB 的方式来实例化，否则直接利用反射的方式即可，方便快捷。</p>\n<p>到这里 <code>createBeanInstance()</code> 的过程就已经分析完毕了，下篇介绍 <code>doCreateBean()</code> 方法中的第二个过程：属性填充。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-22构造函数实例化\"><a href=\"#spring源码解析之-22构造函数实例化\" class=\"headerlink\" title=\"spring源码解析之 22构造函数实例化\"></a>spring源码解析之 22构造函数实例化</h1><h2 id=\"autowireConstructor\"><a href=\"#autowireConstructor\" class=\"headerlink\" title=\"autowireConstructor()\"></a>autowireConstructor()</h2><p>这个初始化方法我们可以简单理解为是带有参数的初始化 bean 。代码段如下：<br>","more":"</p>\n<pre><code class=\"java\">      public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,\n                                           @Nullable Constructor&lt;?&gt;[] chosenCtors, \n                                           @Nullable Object[] explicitArgs) {\n        // 实例化BeanWrapper对象\n        BeanWrapperImpl bw = new BeanWrapperImpl();\n        this.beanFactory.initBeanWrapper(bw);\n\n        Constructor&lt;?&gt; constructorToUse = null;\n        ArgumentsHolder argsHolderToUse = null;\n        Object[] argsToUse = null;\n        // explicit通过getBean方法传入\n        // 如果getBean方法调用的时候指定方法参数，那么直接使用\n        if (explicitArgs != null) {\n            argsToUse = explicitArgs;\n        } else {\n            // 如果在getBean方法时候没有指定则尝试从配置文件中解析\n            Object[] argsToResolve = null;\n\n            // 尝试从缓存中获取获取参数\n            synchronized (mbd.constructorArgumentLock) {\n                constructorToUse = (Constructor&lt;?&gt;)\n                    mbd.resolvedConstructorOrFactoryMethod;\n                if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {\n                    // 缓存中的构造参数\n                    argsToUse = mbd.resolvedConstructorArguments;\n                    if (argsToUse == null) {\n                        argsToResolve = mbd.preparedConstructorArguments;\n                    }\n                }\n            }\n            // 如果缓存中存在\n            if (argsToResolve != null) {\n                // 解析参数类型，如给定方法的构造函数A(int,int)则通过此方法后就会\n                // 把配置中(&quot;1&quot;,&quot;1&quot;)转换为(1,1)\n                // 缓存中的值可能是原始值也可能是最终值，在这里做处理\n                argsToUse = resolvePreparedArguments(beanName, mbd,\n                                                     bw, constructorToUse, \n                                                     argsToResolve, true);\n            }\n        }\n        // 没有缓存也没有明确指定\n        if (constructorToUse == null || argsToUse == null) {\n            // Take specified constructors, if any.\n            Constructor&lt;?&gt;[] candidates = chosenCtors;\n\n            // 如果参数中没有指定构造函数\n            if (candidates == null) {\n                // 获取当前bean对应的class对象\n                Class&lt;?&gt; beanClass = mbd.getBeanClass();\n                try {\n                    // 获取所有的构造函数\n                    candidates = (mbd.isNonPublicAccessAllowed() ?\n                            beanClass.getDeclaredConstructors() : \n                                  beanClass.getConstructors());\n                } catch (Throwable ex) {\n\n                }\n            }\n            // 如果只有默认构造函数并且配置文件中也没有参数配置\n            if (candidates.length == 1 &amp;&amp; explicitArgs == null \n                &amp;&amp; !mbd.hasConstructorArgumentValues()) {\n                Constructor&lt;?&gt; uniqueCandidate = candidates[0];\n                // 缓存构造函数\n                if (uniqueCandidate.getParameterCount() == 0) {\n                    synchronized (mbd.constructorArgumentLock) {\n                        mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;\n                        mbd.constructorArgumentsResolved = true;\n                        mbd.resolvedConstructorArguments = EMPTY_ARGS;\n                    }\n                    // 使用默认构造函数初始化对象\n                    bw.setBeanInstance(instantiate(beanName, mbd, \n                                                   uniqueCandidate, EMPTY_ARGS));\n                    return bw;\n                }\n            }\n\n\n            // Need to resolve the constructor.\n            // 判断是否需要解析构造函数\n            boolean autowiring = (chosenCtors != null ||\n                    mbd.getResolvedAutowireMode() == \n                                  AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);\n\n            // 用于承载解析后的构造函数的值\n            ConstructorArgumentValues resolvedValues = null;\n\n            int minNrOfArgs;\n            if (explicitArgs != null) {\n                minNrOfArgs = explicitArgs.length;\n            } else {\n                // 从BeanDefinition中获取构造参数，也就是从配置文件中提取构造函数\n                ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n                resolvedValues = new ConstructorArgumentValues();\n                // 解析构造函数的参数\n                // 将该bean的构造函数参数解析为resolvedValues对象，其中会涉及到其它bean\n                minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, \n                                                          cargs, resolvedValues);\n            }\n            // 对构造函数进行排序处理\n            // public 构造函数优先参数数量降序，非public 构造函数参数数量降序\n            AutowireUtils.sortConstructors(candidates);\n            //  最小参数类型权重\n            int minTypeDiffWeight = Integer.MAX_VALUE;\n            Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = null;\n            LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null;\n\n            // 迭代所有构造函数\n            for (Constructor&lt;?&gt; candidate : candidates) {\n                // 获取构造函数参数类型\n                Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();\n                // 如果已经找到选用的构造函数或者需要的参数个数小于当前的构造函数参数个数，则终止\n                // 因为已经按照参数个数降序排列了\n                if (constructorToUse != null &amp;&amp; argsToUse != null &amp;&amp;\n                    argsToUse.length &gt; paramTypes.length) {\n\n                    break;\n                }\n                // 参数个数不等，继续\n                if (paramTypes.length &lt; minNrOfArgs) {\n                    continue;\n                }\n\n                // 参数持有者\n                ArgumentsHolder argsHolder;\n                // 有参数\n                if (resolvedValues != null) {\n                    try {\n                        // 注解上获取参数名称\n                        String[] paramNames = \n                            ConstructorPropertiesChecker.evaluate(candidate, \n                                                                  paramTypes.length);\n\n                        if (paramNames == null) {\n                            // 获取构造函数、方法参数的探测器\n                            ParameterNameDiscoverer pnd = \n                                this.beanFactory.getParameterNameDiscoverer();\n                            if (pnd != null) {\n                                // 通过探测器获取构造函数的参数名称\n                                paramNames = pnd.getParameterNames(candidate);\n                            }\n                        }\n                        // 根据构造函数和构造参数创建参数持有者\n                        argsHolder = createArgumentArray(beanName, mbd, \n                                                         resolvedValues, bw, \n                                                         paramTypes, paramNames,\n                                getUserDeclaredConstructor(candidate), autowiring, \n                                                         candidates.length == 1);\n                    } catch (UnsatisfiedDependencyException ex) {\n\n                        }\n                        // Swallow and try next constructor.\n                        if (causes == null) {\n                            causes = new LinkedList&lt;&gt;();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    // 构造函数没有参数\n\n                    if (paramTypes.length != explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder = new ArgumentsHolder(explicitArgs);\n                }\n            //isLenientConstructorResolution判断解析构造函数的时候是否以宽松模式还是严格模式\n                // 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常\n                // 宽松模式：使用具有&quot;最接近的模式&quot;进行匹配\n                // typeDiffWeight：类型差异权重\n                int typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n                        argsHolder.getTypeDifferenceWeight(paramTypes) :\n                                      argsHolder.getAssignabilityWeight(paramTypes));\n                // Choose this constructor if it represents the closest match.\n                // 如果它代表着当前最接近的匹配则选择其作为构造函数\n                if (typeDiffWeight &lt; minTypeDiffWeight) {\n                    constructorToUse = candidate;\n                    argsHolderToUse = argsHolder;\n                    argsToUse = argsHolder.arguments;\n                    minTypeDiffWeight = typeDiffWeight;\n                    ambiguousConstructors = null;\n                } else if (constructorToUse != null &amp;&amp;\n                           typeDiffWeight == minTypeDiffWeight) {\n                    if (ambiguousConstructors == null) {\n                        ambiguousConstructors = new LinkedHashSet&lt;&gt;();\n                        ambiguousConstructors.add(constructorToUse);\n                    }\n                    ambiguousConstructors.add(candidate);\n                }\n            }\n\n            if (constructorToUse == null) {\n                if (causes != null) {\n                    UnsatisfiedDependencyException ex = causes.removeLast();\n                    for (Exception cause : causes) {\n                        this.beanFactory.onSuppressedException(cause);\n                    }\n                    throw ex;\n                }\n\n            } else if (ambiguousConstructors != null &amp;&amp; \n                       !mbd.isLenientConstructorResolution()) {\n\n            }\n            // 将构造函数、构造参数保存到缓存中\n            if (explicitArgs == null &amp;&amp; argsHolderToUse != null) {\n                argsHolderToUse.storeCache(mbd, constructorToUse);\n            }\n        }\n\n        Assert.state(argsToUse != null, &quot;Unresolved constructor arguments&quot;);\n        // 实例化bean\n        bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));\n        return bw;\n    }\n\n</code></pre>\n<p>代码与 <code>instantiateUsingFactoryMethod()</code> 一样，又长又难懂，但是如果理解了 <code>instantiateUsingFactoryMethod()</code> 初始化 bean 的过程，那么 <code>autowireConstructor()</code> 也不存在什么难的地方了，一句话概括：首先确定构造函数参数、构造函数，然后调用相应的初始化策略进行 bean 的初始化。关于如何确定构造函数、构造参数，该部分逻辑和 <code>instantiateUsingFactoryMethod()</code> 基本一致。所以这里你应该相对会轻松点</p>\n<ol>\n<li><p>构造函数参数的确定</p>\n<ul>\n<li><p>根据explicitArgs参数判断</p>\n<p>如果传入的参数explicitArgs不为空，那边可以直接确定参数，因为explicitArgs参数是在调用bean的时候用户指定的，在BeanFactory类中存在这样的方法：</p>\n<pre><code class=\"java\">Object getBean(String name,Object... args) throws BeansException\n</code></pre>\n<p>在获取bean的时候，用户不但可以指定bean的名称还可以指定bean对应类的构造函数或者工厂方法的方法参数，主要用于静态工厂方法的调用，而这里需要先给定完全匹配的参数，如果传入参数explicitArg不为空，则可以确定构造函数参数就是它。</p>\n</li>\n<li><p>缓存中获取</p>\n<p>除此之外，确定参数的办法如果之前已经分析过，也就是说构造参数已经记录在缓存中，那么便可以直接拿来使用。而且，这里要提到的是，在魂村中换粗的可能是参数的最终类型也可能是参数的初始类型。如果是初始类型，则需要进行转换。</p>\n</li>\n<li><p>配置文件中获取</p>\n<p>如果不能根据传入参数explicit·Arg确定构造函数的参数也无法在缓存中得到相关信息，那么只能开始新一轮的分析。分析从配置文件中配置的构造函数信息开始，经过之前的分析，我们知道，spring中配置文件中的信息经过转换都会通过BeanDefinition实例承载，也就是参数mbd中包含，那么可以荣国调用mdb.getCOntructorArgumentValues来获取配置的构造函数信息。有了配置中的信息便可以获取对应的参数值信息。获取参数值的信息包括直接指定值，如：直接指定构造函数中某个值为原始类型String类型，或者是一个队其他bean的引用，这里处理委托给resolveCOnstrucorArguments方法，并返回能解析到的参数的个数</p>\n</li>\n</ul>\n</li>\n<li><p>构造函数的确定</p>\n<p>经过了第一步后已经确定了构造函数的参数，接下来的任务就是根据构造函数参数在所有构造函数中锁定对应的构造函数，而匹配的方法就是根据参数个数匹配，所以在匹配之前需要先对构造函数按照public构造函数优先参数量降序、feipublic构造函数参数数量降序，这样可以在遍历的情况下循序判断牌子啊后面的构造函数参数个数是否符合条件。</p>\n<p>由于在配置文件中并不是唯一现在使用参数位置索引的方式去创建，同样还支持指定参数名称进行设定参数值的情况，如<code>&lt;constructor-arg name=&quot;aa&quot;&gt;</code>，那么这种情况就需要首先确定构造函数中的参数名称。</p>\n<p>获取参数名称可以有俩种方式，一种是通过注解的方式直接获取，另一种就是使用spring中提供的工具类ParameterNameDiscover来获取，构造函数、参数名称、参数哦类型、参数值都确定后就可以锁定构造函数以及转换对应的参数类型。</p>\n</li>\n<li><p>根据确定的构造函数转换对应的参数类型</p>\n<p>主要使用spring中提供的类型转换器或者用户提供的自定义类型转换器进行转换。</p>\n</li>\n<li><p>根据构造函数不确定性的验证</p>\n<p>当然，有时候即使构造函数，参数名称，参数类型、参数值都确定后也不一定会直接锁定构造函数，不同构造函数的参数为父子类型，所以spring在最后有做了一次验证。</p>\n<p>根据实例化策略以及得到的构造函数即构造函数参数实例化bean。下面我们重点分析初始化策略：</p>\n</li>\n</ol>\n<p>对于初始化策略，首先是获取实例化 bean 的策略，如下：</p>\n<pre><code class=\"java\">final InstantiationStrategy strategy = beanFactory.getInstantiationStrategy();\n</code></pre>\n<p>然后是调用其 <code>instantiate()</code>方法，该方法在 SimpleInstantiationStrategy 中实现，如下：</p>\n<pre><code class=\"java\">    public Object instantiate(RootBeanDefinition bd, \n                              @Nullable String beanName, BeanFactory owner) {\n        // 没有覆盖\n        // 直接使用反射实例化即可\n        if (!bd.hasMethodOverrides()) {\n            // 重新检测获取下构造函数\n            // 该构造函数是经过前面 N 多复杂过程确认的构造函数\n            Constructor&lt;?&gt; constructorToUse;\n            synchronized (bd.constructorArgumentLock) {\n                // 获取已经解析的构造函数\n                constructorToUse = (Constructor&lt;?&gt;) \n                    bd.resolvedConstructorOrFactoryMethod;\n                // 如果为 null，从 class 中解析获取，并设置\n                if (constructorToUse == null) {\n                    final Class&lt;?&gt; clazz = bd.getBeanClass();\n                    if (clazz.isInterface()) {\n                        throw new BeanInstantiationException(clazz, \n                                    】&quot;Specified class is an interface&quot;);\n                    }\n                    try {\n                        if (System.getSecurityManager() != null) {\n                            constructorToUse = AccessController.doPrivileged(\n                                    (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) \n                                clazz::getDeclaredConstructor);\n                        }\n                        else {\n                            constructorToUse =  clazz.getDeclaredConstructor();\n                        }\n                        bd.resolvedConstructorOrFactoryMethod = constructorToUse;\n                    }\n                    catch (Throwable ex) {\n                        throw new BeanInstantiationException(clazz,\n                                 &quot;No default constructor found&quot;, ex);\n                    }\n                }\n            }\n\n            // 通过BeanUtils直接使用构造器对象实例化bean\n            return BeanUtils.instantiateClass(constructorToUse);\n        }\n        else {\n            // 生成CGLIB创建的子类对象\n            return instantiateWithMethodInjection(bd, beanName, owner);\n        }\n    }\n</code></pre>\n<p>如果该 bean 没有配置 lookup-method、replaced-method 标签或者 @Lookup 注解，则直接通过反射的方式实例化 bean 即可，方便快捷，但是如果存在需要覆盖的方法或者动态替换的方法则需要使用 CGLIB 进行动态代理，因为可以在创建代理的同时将动态方法织入类中。</p>\n<p><strong>反射</strong></p>\n<p>调用工具类 BeanUtils 的 <code>instantiateClass()</code> 方法完成反射工作：</p>\n<pre><code class=\"java\">    public static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args)\n        throws BeanInstantiationException {\n        Assert.notNull(ctor, &quot;Constructor must not be null&quot;);\n        try {\n            ReflectionUtils.makeAccessible(ctor);\n            return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?\n                    KotlinDelegate.instantiateClass(ctor, args) : \n                    ctor.newInstance(args));\n        }\n        // 省略一些 catch \n    }\n</code></pre>\n<p><strong>CGLIB</strong></p>\n<pre><code class=\"java\">    protected Object instantiateWithMethodInjection(RootBeanDefinition bd,\n                      @Nullable String beanName, BeanFactory owner) {\n        throw new UnsupportedOperationException(&quot;Method Injection not supported in SimpleInstantiationStrategy&quot;);\n    }\n</code></pre>\n<p>方法默认是没有实现的，具体过程由其子类 CglibSubclassingInstantiationStrategy 实现：</p>\n<pre><code class=\"java\">    protected Object instantiateWithMethodInjection(RootBeanDefinition bd, \n                      @Nullable String beanName, BeanFactory owner) {\n        return instantiateWithMethodInjection(bd, beanName, owner, null);\n    }\n\n    protected Object instantiateWithMethodInjection(RootBeanDefinition bd, \n                            @Nullable String beanName, BeanFactory owner,\n            @Nullable Constructor&lt;?&gt; ctor, @Nullable Object... args) {\n\n        // 通过CGLIB生成一个子类对象\n        return new CglibSubclassCreator(bd, owner).instantiate(ctor, args);\n    }\n</code></pre>\n<p>创建一个 CglibSubclassCreator 对象，调用其 <code>instantiate()</code> 方法生成其子类对象：</p>\n<pre><code class=\"java\">    public Object instantiate(@Nullable Constructor&lt;?&gt; ctor, @Nullable Object... args) \n    {\n        // 通过 Cglib 创建一个代理类\n        Class&lt;?&gt; subclass = createEnhancedSubclass(this.beanDefinition);\n        Object instance;\n        // 没有构造器，通过 BeanUtils 使用默认构造器创建一个bean实例\n        if (ctor == null) {\n            instance = BeanUtils.instantiateClass(subclass);\n        }\n        else {\n            try {\n                // 获取代理类对应的构造器对象，并实例化 bean\n                Constructor&lt;?&gt; enhancedSubclassConstructor = \n                    subclass.getConstructor(ctor.getParameterTypes());\n                instance = enhancedSubclassConstructor.newInstance(args);\n            }\n            catch (Exception ex) {\n\n            }\n        }\n\n        // 为了避免memory leaks异常，直接在bean实例上设置回调对象\n        Factory factory = (Factory) instance;\n        factory.setCallbacks(new Callback[] {NoOp.INSTANCE,\n                new CglibSubclassingInstantiationStrategy\n                    .LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),\n                new CglibSubclassingInstantiationStrategy\n                    .ReplaceOverrideMethodInterceptor(this.beanDefinition, \n                                                      this.owner)});\n        return instance;\n    }\n</code></pre>\n<p>到这类 CGLIB 的方式分析完毕了，当然这里还没有具体分析 CGLIB 生成子类的详细过程，具体的过程等后续分析 AOP 的时候再详细地介绍。</p>\n<h2 id=\"instantiateBean\"><a href=\"#instantiateBean\" class=\"headerlink\" title=\"instantiateBean()\"></a>instantiateBean()</h2><pre><code class=\"java\">   protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {\n        try {\n            Object beanInstance;\n            final BeanFactory parent = this;\n            if (System.getSecurityManager() != null) {\n                beanInstance = AccessController.doPrivileged(\n                    (PrivilegedAction&lt;Object&gt;) () -&gt;\n                                getInstantiationStrategy().instantiate(mbd,\n                                   beanName, parent),\n                        getAccessControlContext());\n            }\n            else {\n                beanInstance = getInstantiationStrategy()\n                            .instantiate(mbd, beanName, parent);\n            }\n            BeanWrapper bw = new BeanWrapperImpl(beanInstance);\n            initBeanWrapper(bw);\n            return bw;\n        }\n        catch (Throwable ex) {\n              、、。。。\n        }\n    }\n</code></pre>\n<p>这个方法相比于 <code>instantiateUsingFactoryMethod()</code> 、 <code>autowireConstructor()</code> 方法实在是太简单了，因为它没有参数，所以不需要确认经过复杂的过来来确定构造器、构造参数，所以这里就不过多阐述了。</p>\n<p>对于 <code>createBeanInstance()</code> 而言，他就是选择合适实例化策略来为 bean 创建实例对象，具体的策略有：Supplier 回调方式、工厂方法初始化、构造函数自动注入初始化、默认构造函数注入。其中工厂方法初始化和构造函数自动注入初始化两种方式最为复杂，主要是因为构造函数和构造参数的不确定性，Spring 需要花大量的精力来确定构造函数和构造参数，如果确定了则好办，直接选择实例化策略即可。当然在实例化的时候会根据是否有需要覆盖或者动态替换掉的方法，因为存在覆盖或者织入的话需要创建动态代理将方法织入，这个时候就只能选择 CGLIB 的方式来实例化，否则直接利用反射的方式即可，方便快捷。</p>\n<p>到这里 <code>createBeanInstance()</code> 的过程就已经分析完毕了，下篇介绍 <code>doCreateBean()</code> 方法中的第二个过程：属性填充。</p>"},{"abbrlink":11,"author":"zhangke","title":"java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析","date":"2018-07-23T06:35:00.000Z","_content":"# java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析\n\n### 概要\n\n>1. 线程池使用例子\n>2. 线程池状态\n>3. 任务执行流程分析\n\n### 1. 线程池使用例子\n\n>简单例子\n>\n>```\n>import java.util.concurrent.Executors;\n>import java.util.concurrent.ExecutorService;\n>\n>public class ThreadPoolDemo1 {\n>\n>    public static void main(String[] args) {\n>        // 创建一个可重用固定线程数的线程池\n>        ExecutorService pool = Executors.newFixedThreadPool(2);\n>        // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n>        Thread ta = new MyThread();\n>        Thread tb = new MyThread();\n>        Thread tc = new MyThread();\n>        Thread td = new MyThread();\n>        Thread te = new MyThread();\n>        // 将线程放入池中进行执行\n>        pool.execute(ta);\n>        pool.execute(tb);\n>        pool.execute(tc);\n>        pool.execute(td);\n>        pool.execute(te);\n>        // 关闭线程池\n>        pool.shutdown();\n>    }\n>}\n>\n>class MyThread extends Thread {\n>\n>    @Override\n>    public void run() {\n>        System.out.println(Thread.currentThread().getName()+ \" is running.\");\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>```\n>\n>示例中，使用了Excutors工具类来创建线程池，并提交任务到线程池上运行，然后关闭线程池，这是一个简单的实例。接下来我们将进行ThreadPoolExecutor深入分析。\n>\n>\n\n### 2. 线程池状态\n\n>在线程池中使用了一个AtomicInteger对象来表示线程的状态和任务的数量。其中Integer是32位，用高三位来表示线程池的状态，至于怎么计算不是这里的重点，这里我们先讲解任务的状态。\n>\n>线程池中任务的状态有以下5种：\n>\n>```\n>RUNNING   :接收新的任务和处理队列中的任务\n>SHUTDOWN  :不在接收新的任务和但是处理队列中的任务。\n>STOP  \t  :不在接收新的任务，同时不在处理队列中的任务，线程上正在运行的任务也会被打断。\n>TIDYING   :所有的任务已经结束，并且线程的数量为0，线程的状态转换成清理的状态，接下来将会运行\n>\t\t\tterminated()方法。\n>TERMINATED:terminated()执行完成\n>```\n>\n>状态的转换:\n>\n>```\n>* RUNNING -> SHUTDOWN\n>*    On invocation of shutdown(), perhaps implicitly in finalize()\n>* (RUNNING or SHUTDOWN) -> STOP\n>*    On invocation of shutdownNow()\n>* SHUTDOWN -> TIDYING\n>*    When both queue and pool are empty\n>* STOP -> TIDYING\n>*    When pool is empty\n>* TIDYING -> TERMINATED\n>*    When the terminated() hook method has completed\n>```\n>\n>\n>\n>\n\n### 3. 线程池执行任务分析\n\n>在讲解运行过程前，我们先看下`ThreadPoolExecutor`中的几个比较重要的成员变量：\n>\n>```java\n>//线程池状态，和队列中任务数量的表示，高三位表示状态，剩下的表示线程的状态\n>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); \n>//任务缓存队列，用来保存等待中的任务，等待worker线程空闲时执行任务\n>private final BlockingQueue<Runnable> workQueue;\n>//更新 poolSize, corePoolSize,maximumPoolSize, runState, and workers set 时需要持有这个锁\n>private final ReentrantLock mainLock = new ReentrantLock(); \n>//用来保存工作中的执行线程\n>\n>private final HashSet<Worker> workers = new HashSet<Worker>(); \n>private volatile long  keepAliveTime; //超过corePoolSize外的线程空闲存活之间\n>//是否对corePoolSize内的线程设置空闲存活时间\n>private volatile boolean allowCoreThreadTimeOut; \n>private volatile int   corePoolSize; //核心线程数\n>\n>//最大线程数（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）\n>private volatile int   maximumPoolSize; \n>private volatile int   poolSize; //线程池中的当前线程数\n>private volatile RejectedExecutionHandler handler; //任务拒绝策略\n>private volatile ThreadFactory threadFactory; //线程工厂，用来新建线程\n>private int largestPoolSize; //记录线程池中出现过的最大线程数大小\n>private long completedTaskCount; //已经执行完的线程数\n>```\n>\n>这边重点解释下 `corePoolSize`、`maximumPoolSize`、`workQueue`两个变量，这两个变量涉及到线程池中创建线程个数的一个策略。\n>`corePoolSize`： 这个变量我们可以理解为线程池的核心大小，举个例子来说明（corePoolSize假设等于10，maximumPoolSize等于20）：\n>\n>1. 有一个部门，其中有10（corePoolSize）名工人，当有新任务来了后，领导就分配任务给工人去做，每个工人只能做一个任务。\n>2. 当10个工人都在忙时，新来的任务就要放到队列（workQueue）中等待。\n>3. 当任务越积累越多，远远超过工人做任务的速度时，领导就想了一个办法：从其他部门借10个工人来，借的数量有一个公式（maximumPoolSize - corePoolSize）来计算。然后把新来的任务分配给借来的工人来做。\n>4. 但是如果速度还是还不急的话，可能就要采取措施来放弃一些任务了（RejectedExecutionHandler）。\n>   等到一定时间后，任务都完成了，工人比较闲的情况下，就考虑把借来的10个工人还回去（根据keepAliveTime判断）\n>5. 也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。\n>\n>### 任务执行：execute\n>\n>这个方法在ThreadPoolExecutor中的源码如下\n>\n>```java\n> public void execute(Runnable command) {\n>     \t//如果任务是空，则抛出空指针异常\n>        if (command == null)\n>            throw new NullPointerException();\n>     \t//得到当前ctl的值，方便下面计算\t\n>        int c = ctl.get();\n>     \t//计算当前线程池中线程的数量，如果小于核心线程数，则添加线程\n>        if (workerCountOf(c) < corePoolSize) {\n>            // 则通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程\n>            //中；然后，启动该线程从而执行任务。\n>            if (addWorker(command, true))\n>                return;\n>            c = ctl.get();\n>        }\n>         // 当线程池中的任务数量 >= \"核心池大小\"时，\n>    \t // 而且，\"线程池处于运行状态\"时，则尝试将任务添加到阻塞队列中。\n>        if (isRunning(c) && workQueue.offer(command)) {\n>             // 再次确认“线程池状态”，若线程池异常终止了，则删除任务；\n>            //然后通过reject()执行相应的拒绝策略的内容。\n>            int recheck = ctl.get();\n>            if (! isRunning(recheck) && remove(command))\n>                reject(command);\n>            // 否则，如果\"线程池中任务数量\"为0，则通过addWorker(null, false)尝试新建一个线\n>            // 程，新建线程对应的任务为null。防止线程池被关闭\n>            else if (workerCountOf(recheck) == 0)\n>                addWorker(null, false);\n>        }\n>       //这里是启动小于maxpoolSize的线程\n>       //如果添加任务到队列中不成功，则试图通过addWorker(command, false)新建一个线程，\n>       //并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。\n>       // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。\n>        else if (!addWorker(command, false))\n>            reject(command);\n>    }\n>}\n>```\n>\n>**说明**：execute()的作用是将任务添加到线程池中执行。它会分为3种情况进行处理：        \n>\n> **情况1** -- 如果\"线程池中任务数量\" < \"核心池大小\"时，即线程池中少于corePoolSize个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。         \n>\n>**情况2** -- 如果\"线程池中任务数量\" >= \"核心池大小\"，并且\"线程池是允许状态\"；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认\"线程池的状态\"，如果\"第2次读到的线程池状态\"和\"第1次读到的线程池状态\"不同，则从阻塞队列中删除该任务。         \n>\n>**情况3** -- 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过reject()拒绝该任务。\n>\n>到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：\n>\n>1. 首先，要清楚corePoolSize和maximumPoolSize的含义；\n>2. 其次，要知道Worker是用来起到什么作用的；\n>3. 要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：\n>\n>- 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；\n>- 如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；\n>- 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；\n>- 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于 corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。\n>\n>###  **addWorker**\n>\n>源码如下\n>\n>```java\n> private boolean addWorker(Runnable firstTask, boolean core) {\n>        retry:\n>        // 更新\"线程池状态和计数\"标记，即更新ctl。\n>        for (;;) {\n>           // 更新\"线程池状态和计数\"标记，即更新ctl。\n>            int c = ctl.get();\n>             // 获取线程池状态。\n>            int rs = runStateOf(c);\n>\n>            // Check if queue empty only if necessary.\n>            // 有效性检查\n>            if (rs >= SHUTDOWN &&\n>                ! (rs == SHUTDOWN &&\n>                   firstTask == null &&\n>                   ! workQueue.isEmpty()))\n>                return false;\n>\n>            for (;;) {\n>               // 获取线程池中任务的数量。\n>                int wc = workerCountOf(c);\n>                // 如果\"线程池中任务的数量\"超过限制，则返回false。\n>                if (wc >= CAPACITY ||\n>                    wc >= (core ? corePoolSize : maximumPoolSize))\n>                    return false;\n>                // 通过CAS函数将c的值+1。操作失败的话，则退出循环。\n>                if (compareAndIncrementWorkerCount(c))\n>                    break retry;\n>                c = ctl.get();  // Re-read ctl\n>                // 检查\"线程池状态\"，如果与之前的状态不同，则从retry重新开始。\n>                if (runStateOf(c) != rs)\n>                    continue retry;\n>                // else CAS failed due to workerCount change; retry inner loop\n>            }\n>        }\n>\n>    boolean workerStarted = false;\n>    boolean workerAdded = false;\n>    Worker w = null;\n>    // 添加任务到线程池，并启动任务所在的线程。\n>    try {\n>        final ReentrantLock mainLock = this.mainLock;\n>        // 新建Worker，并且指定firstTask为Worker的第一个任务。\n>        w = new Worker(firstTask);\n>        // 获取Worker对应的线程。\n>        final Thread t = w.thread;\n>        if (t != null) {\n>            // 获取锁\n>            mainLock.lock();\n>            try {\n>                int c = ctl.get();\n>                int rs = runStateOf(c);\n>\n>                // 再次确认\"线程池状态\"\n>                if (rs < SHUTDOWN ||\n>                    (rs == SHUTDOWN && firstTask == null)) {\n>                    if (t.isAlive()) // precheck that t is startable\n>                        throw new IllegalThreadStateException();\n>                    // 将Worker对象(w)添加到\"线程池的Worker集合(workers)\"中\n>                    workers.add(w);\n>                    // 更新largestPoolSize\n>                    int s = workers.size();\n>                    if (s > largestPoolSize)\n>                        largestPoolSize = s;\n>                    workerAdded = true;\n>                }\n>            } finally {\n>                // 释放锁\n>                mainLock.unlock();\n>            }\n>            // 如果\"成功将任务添加到线程池\"中，则启动任务所在的线程。 \n>            if (workerAdded) {\n>                t.start();\n>                workerStarted = true;\n>            }\n>        }\n>    } finally {\n>        if (! workerStarted)\n>            addWorkerFailed(w);\n>    }\n>    // 返回任务是否启动。\n>    return workerStarted;\n>}\n>\n>```\n>\n>**说明**：\n>\n>1.  addWorker(Runnable firstTask, boolean core) 的作用是将任务(firstTask)添加到线程池中，并启动该任务。core为true的话，则以corePoolSize为界限，若\"线程池中已有任务数量>=corePoolSize\"，则返回false；core为false的话，则以maximumPoolSize为界限，若\"线程池中已有任务数量>=maximumPoolSize\"，则返回false。\n>\n>2. addWorker()会先通过for循环不断尝试更新ctl状态，ctl记录了\"线程池中任务数量和线程池状态\"。更新成功之后，再通过try模块来将任务添加到线程池中，并启动任务所在的线程。\n>\n>3.  从addWorker()中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的Worker对象；而一个Workder对象包含一个Thread对象。\n>\n>   (01) 通过将Worker对象添加到\"线程的workers集合\"中，从而实现将任务添加到线程池中。\n>\n>   (02) 通过启动Worker对应的Thread线程，则执行该任务。\n>\n>### addWorkerFailed:\n>\n>如果Worker创建成功，但是没有启动，这时我们需要将从线程对象从works上移除，否则会影响线程池的性能，源码如下\n>\n>```java\n>    /**\n>     * Rolls back the worker thread creation.\n>     * - removes worker from workers, if present\n>     * - decrements worker count\n>     * - rechecks for termination, in case the existence of this\n>     *   worker was holding up termination\n>     */\n>    private void addWorkerFailed(Worker w) {\n>        \n>        final ReentrantLock mainLock = this.mainLock;\n>        //获取锁\n>        mainLock.lock();\n>        try {\n>            //从workers上移除线程\n>            if (w != null)\n>                workers.remove(w);\n>            //减少线程的数量\n>            decrementWorkerCount();\n>            //由于线程数量的减少，可能会使得当前线程池上线程的数量变成0，这时有可能进入\n>            //TIDYING状态，所以尝试结束线程池\n>            tryTerminate();\n>        } finally {\n>            mainLock.unlock();\n>        }\n>    }\n>```\n>\n>这时你们会不会有个疑问，一般我们写程序时，如果想让线程一直运行，则会向下面这样写:\n>\n>```\n>public void run(){\n>    while(true){\n>        //doSomething\n>    }\n>}\n>```\n>\n>但是上面执行流程分析完了，但是没看到ThreadPoolExecutor怎么定义线程一直运行，这时我们就要去分析Worker这个内部类的源码，这里面有我们想要的结果：\n>\n>源码如下：\n>\n>```java\n>  private final class Worker\n>        extends AbstractQueuedSynchronizer\n>        implements Runnable {      \n>        private static final long serialVersionUID = 6138294804551838833L;\n>   \t\t//当前woker正在运行的线程\n>        final Thread thread;\n>        //初始化这个工作线程时的第一个任务，可能为null\n>        Runnable firstTask;\n>       \t//每个线程完成任务的数量\n>        volatile long completedTasks;\n>        \n>        Worker(Runnable firstTask) {\n>            setState(-1); // inhibit interrupts until runWorker\n>            this.firstTask = firstTask;       \n>            //使用线程池提供的线程创建工厂来创建线程\n>            this.thread = getThreadFactory().newThread(this);\n>        }\n>        //委派当前线程的run方法到外部类的runWorker上，\n>        public void run() {\n>            runWorker(this);\n>        }\n>        // Lock methods\n>        //\n>        // The value 0 represents the unlocked state.\n>        // The value 1 represents the locked state.\n>        protected boolean isHeldExclusively() {\n>            return getState() != 0;\n>        }\n>\n>        protected boolean tryAcquire(int unused) {\n>            if (compareAndSetState(0, 1)) {\n>                setExclusiveOwnerThread(Thread.currentThread());\n>                return true;\n>            }\n>            return false;\n>        }\n>\n>        protected boolean tryRelease(int unused) {\n>            setExclusiveOwnerThread(null);\n>            setState(0);\n>            return true;\n>        }\n>\n>        public void lock()        { acquire(1); }\n>        public boolean tryLock()  { return tryAcquire(1); }\n>        public void unlock()      { release(1); }\n>        public boolean isLocked() { return isHeldExclusively(); }\n>\n>        void interruptIfStarted() {\n>            Thread t;\n>            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n>                try {\n>                    t.interrupt();\n>                } catch (SecurityException ignore) {\n>                }\n>            }\n>        }\n>    }\n>```\n>\n>分析：\n>\n>1. 从上面我们可以看出，Worker继承AQS，实现Runnable接口，继承AQS实现了一个简单的互斥锁，是不想在Worker运行的时候使用外部类的互斥锁，这样可以减少线程的等待。\n>2. 线程创建时通过外部类的threadFactory来创建的，后面我会讲解这个类，其实很简单\n>\n>从上面可以看出Worker类的run方法实现实际上是外部类的runWorker方法实现的，源码如下：\n>\n>```java\n>final void runWorker(Worker w) {\n>\t\t//获取当前cpu上运行的线程，其实也就是worker中的thread\n>        Thread wt = Thread.currentThread();\n>    \t//获取第一个运行任务，可以为null\n>        Runnable task = w.firstTask;\n>        w.firstTask = null;\n>    \t//释放锁\n>        w.unlock(); // allow interrupts\n>    \t//判断当前线程是否是中断结束 true 不是\n>        boolean completedAbruptly = true;\n>        try {\n>            //当任务不为空，一直运行\n>            while (task != null || (task = getTask()) != null) {\n>                w.lock();\n>                // If pool is stopping, ensure thread is interrupted;\n>                // if not, ensure thread is not interrupted.  This\n>                // requires a recheck in second case to deal with\n>                // shutdownNow race while clearing interrupt\n>                if ((runStateAtLeast(ctl.get(), STOP) ||\n>                     (Thread.interrupted() &&\n>                      runStateAtLeast(ctl.get(), STOP))) &&\n>                    !wt.isInterrupted())\n>                    wt.interrupt();\n>                try {\n>                    //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n>                    //默认什么也不做\n>                    beforeExecute(wt, task);\n>                    Throwable thrown = null;\n>                    try {\n>                        //执行任务\n>                        task.run();\n>                    } catch (RuntimeException x) {\n>                        thrown = x; throw x;\n>                    } catch (Error x) {\n>                        thrown = x; throw x;\n>                    } catch (Throwable x) {\n>                        thrown = x; throw new Error(x);\n>                    } finally {\n>                         //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n>                         //默认什么也不做\n>                        afterExecute(task, thrown);\n>                    }\n>                } finally {\n>                    task = null;\n>                    w.completedTasks++;\n>                    w.unlock();\n>                }\n>            }\n>            completedAbruptly = false;\n>        } finally {\n>            //线程死亡，使用此方法执行后续清理工作，\n>            processWorkerExit(w, completedAbruptly);\n>        }\n>    }\n>```\n>\n>从上面代码可以看到这边在循环获取任务，并执行，直到任务全部执行完毕。除了第一个任务，其他任务都是通过`getTask()`方法去取，这个方法是ThreadPoolExecutor中的一个方法。我们猜一下，整个类中只有任务缓存队列中保存了任务，应该就是去缓存队列中取了。\n>\n>```\n>Runnable getTask() {\n>    for (;;) {\n>        try {\n>            int state = runState;\n>            if (state > SHUTDOWN)\n>                return null;\n>            Runnable r;\n>            if (state == SHUTDOWN)  // Help drain queue\n>                r = workQueue.poll(); //取任务\n>            else if (poolSize > corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，\n>                //则通过poll取任务，若等待一定的时间取不到任务，则返回null\n>                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);\n>            else\n>                r = workQueue.take();\n>            if (r != null)\n>                return r;\n>            if (workerCanExit()) {    //如果没取到任务，即r为null，则判断当前的worker是否可以退出\n>                if (runState >= SHUTDOWN) // Wake up others\n>                    interruptIdleWorkers();   //中断处于空闲状态的worker\n>                return null;\n>            }\n>            // Else retry\n>        } catch (InterruptedException ie) {\n>            // On interruption, re-check runState\n>        }\n>    }\n>}\n>```\n>\n>这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给 空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程Worker去任务缓存队列里面取任务来执行，因为每一个Worker里面都包含了一个线程thread。\n>\n>还需要注意的是，当线程死亡如何处理：\n>\n>源码如下：\n>\n>```\n>\t//处理线程结束时的清理工作\n>    private void processWorkerExit(Worker w, boolean completedAbruptly) {\n>        //如果是中断结束，则线程数量不做调整\n>        if (completedAbruptly) \n>            decrementWorkerCount();\n>\n>        final ReentrantLock mainLock = this.mainLock;\n>        //获取锁\n>        mainLock.lock();\n>        try {\n>            //将当前worker线程上的完成任务数量记录下来\n>            completedTaskCount += w.completedTasks;\n>            //移除当前此worker\n>            workers.remove(w);\n>        } finally {\n>            mainLock.unlock();\n>        }\n>        //尝试关闭线程池\n>        tryTerminate();\n>        int c = ctl.get();\n>        //如果当前线程池状态不是stop，则添加woker线程\n>        if (runStateLessThan(c, STOP)) {\n>            //如果是异常导致线程的中断，则判断当前线程池中线程的\n>            //数量是否大于min，min表示当前线程池最少应该有多少线程\n>            //如果少于，则创建一个新的worker线程\n>            if (!completedAbruptly) {\n>                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n>                if (min == 0 && ! workQueue.isEmpty())\n>                    min = 1;\n>                if (workerCountOf(c) >= min)\n>                    return; // replacement not needed\n>            }\n>            addWorker(null, false);\n>        }\n>    }\n>```\n>\n>\n>\n>### 关闭“线程池”\n>\n>shutdown()的源码如下：\n>\n>```java\n>public void shutdown() {\n>    final ReentrantLock mainLock = this.mainLock;\n>    // 获取锁\n>    mainLock.lock();\n>    try {\n>        // 检查终止线程池的“线程”是否有权限。\n>        checkShutdownAccess();\n>        // 设置线程池的状态为关闭状态。\n>        advanceRunState(SHUTDOWN);\n>        // 中断线程池中空闲的线程。\n>        interruptIdleWorkers();\n>        // 钩子函数，在ThreadPoolExecutor中没有任何动作。\n>        onShutdown(); // hook for ScheduledThreadPoolExecutor\n>    } finally {\n>        // 释放锁\n>        mainLock.unlock();\n>    }\n>    // 尝试终止线程池\n>    tryTerminate();\n>}\n>```\n>\n>**说明**：shutdown()的作用是关闭线程池。\n>\n> shutdownNow()源码如下：\n>\n>```java\n>public List<Runnable> shutdownNow() {\n>        List<Runnable> tasks;\n>        final ReentrantLock mainLock = this.mainLock;\n>        //获取所\n>        mainLock.lock();\n>        try {\n>        \t\n>            checkShutdownAccess();\n>            //设置线程池状态为stop状态\n>            advanceRunState(STOP);\n>            //中断所有线程\n>            interruptWorkers();\n>            //取出队列上还未被执行的任务\n>            tasks = drainQueue();\n>        } finally {\n>            mainLock.unlock();\n>        }\n>        tryTerminate();\n>        //返回队列上的任务\n>        return tasks;\n>    }\n>\n>```\n>\n>\n>\n>\n\n","source":"_posts/juc/threads/java多线程系列-JUC线程池之02 ThreadPoolExecutor源码分析.md","raw":"abbrlink: 11\ntags:\n  - JUC\n  - 线程池\ncategories:\n  - java\nauthor: zhangke\ntitle: java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析\ndate: 2018-07-23 14:35:00\n---\n# java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析\n\n### 概要\n\n>1. 线程池使用例子\n>2. 线程池状态\n>3. 任务执行流程分析\n\n### 1. 线程池使用例子\n\n>简单例子\n>\n>```\n>import java.util.concurrent.Executors;\n>import java.util.concurrent.ExecutorService;\n>\n>public class ThreadPoolDemo1 {\n>\n>    public static void main(String[] args) {\n>        // 创建一个可重用固定线程数的线程池\n>        ExecutorService pool = Executors.newFixedThreadPool(2);\n>        // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n>        Thread ta = new MyThread();\n>        Thread tb = new MyThread();\n>        Thread tc = new MyThread();\n>        Thread td = new MyThread();\n>        Thread te = new MyThread();\n>        // 将线程放入池中进行执行\n>        pool.execute(ta);\n>        pool.execute(tb);\n>        pool.execute(tc);\n>        pool.execute(td);\n>        pool.execute(te);\n>        // 关闭线程池\n>        pool.shutdown();\n>    }\n>}\n>\n>class MyThread extends Thread {\n>\n>    @Override\n>    public void run() {\n>        System.out.println(Thread.currentThread().getName()+ \" is running.\");\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>```\n>\n>示例中，使用了Excutors工具类来创建线程池，并提交任务到线程池上运行，然后关闭线程池，这是一个简单的实例。接下来我们将进行ThreadPoolExecutor深入分析。\n>\n>\n\n### 2. 线程池状态\n\n>在线程池中使用了一个AtomicInteger对象来表示线程的状态和任务的数量。其中Integer是32位，用高三位来表示线程池的状态，至于怎么计算不是这里的重点，这里我们先讲解任务的状态。\n>\n>线程池中任务的状态有以下5种：\n>\n>```\n>RUNNING   :接收新的任务和处理队列中的任务\n>SHUTDOWN  :不在接收新的任务和但是处理队列中的任务。\n>STOP  \t  :不在接收新的任务，同时不在处理队列中的任务，线程上正在运行的任务也会被打断。\n>TIDYING   :所有的任务已经结束，并且线程的数量为0，线程的状态转换成清理的状态，接下来将会运行\n>\t\t\tterminated()方法。\n>TERMINATED:terminated()执行完成\n>```\n>\n>状态的转换:\n>\n>```\n>* RUNNING -> SHUTDOWN\n>*    On invocation of shutdown(), perhaps implicitly in finalize()\n>* (RUNNING or SHUTDOWN) -> STOP\n>*    On invocation of shutdownNow()\n>* SHUTDOWN -> TIDYING\n>*    When both queue and pool are empty\n>* STOP -> TIDYING\n>*    When pool is empty\n>* TIDYING -> TERMINATED\n>*    When the terminated() hook method has completed\n>```\n>\n>\n>\n>\n\n### 3. 线程池执行任务分析\n\n>在讲解运行过程前，我们先看下`ThreadPoolExecutor`中的几个比较重要的成员变量：\n>\n>```java\n>//线程池状态，和队列中任务数量的表示，高三位表示状态，剩下的表示线程的状态\n>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); \n>//任务缓存队列，用来保存等待中的任务，等待worker线程空闲时执行任务\n>private final BlockingQueue<Runnable> workQueue;\n>//更新 poolSize, corePoolSize,maximumPoolSize, runState, and workers set 时需要持有这个锁\n>private final ReentrantLock mainLock = new ReentrantLock(); \n>//用来保存工作中的执行线程\n>\n>private final HashSet<Worker> workers = new HashSet<Worker>(); \n>private volatile long  keepAliveTime; //超过corePoolSize外的线程空闲存活之间\n>//是否对corePoolSize内的线程设置空闲存活时间\n>private volatile boolean allowCoreThreadTimeOut; \n>private volatile int   corePoolSize; //核心线程数\n>\n>//最大线程数（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）\n>private volatile int   maximumPoolSize; \n>private volatile int   poolSize; //线程池中的当前线程数\n>private volatile RejectedExecutionHandler handler; //任务拒绝策略\n>private volatile ThreadFactory threadFactory; //线程工厂，用来新建线程\n>private int largestPoolSize; //记录线程池中出现过的最大线程数大小\n>private long completedTaskCount; //已经执行完的线程数\n>```\n>\n>这边重点解释下 `corePoolSize`、`maximumPoolSize`、`workQueue`两个变量，这两个变量涉及到线程池中创建线程个数的一个策略。\n>`corePoolSize`： 这个变量我们可以理解为线程池的核心大小，举个例子来说明（corePoolSize假设等于10，maximumPoolSize等于20）：\n>\n>1. 有一个部门，其中有10（corePoolSize）名工人，当有新任务来了后，领导就分配任务给工人去做，每个工人只能做一个任务。\n>2. 当10个工人都在忙时，新来的任务就要放到队列（workQueue）中等待。\n>3. 当任务越积累越多，远远超过工人做任务的速度时，领导就想了一个办法：从其他部门借10个工人来，借的数量有一个公式（maximumPoolSize - corePoolSize）来计算。然后把新来的任务分配给借来的工人来做。\n>4. 但是如果速度还是还不急的话，可能就要采取措施来放弃一些任务了（RejectedExecutionHandler）。\n>   等到一定时间后，任务都完成了，工人比较闲的情况下，就考虑把借来的10个工人还回去（根据keepAliveTime判断）\n>5. 也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。\n>\n>### 任务执行：execute\n>\n>这个方法在ThreadPoolExecutor中的源码如下\n>\n>```java\n> public void execute(Runnable command) {\n>     \t//如果任务是空，则抛出空指针异常\n>        if (command == null)\n>            throw new NullPointerException();\n>     \t//得到当前ctl的值，方便下面计算\t\n>        int c = ctl.get();\n>     \t//计算当前线程池中线程的数量，如果小于核心线程数，则添加线程\n>        if (workerCountOf(c) < corePoolSize) {\n>            // 则通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程\n>            //中；然后，启动该线程从而执行任务。\n>            if (addWorker(command, true))\n>                return;\n>            c = ctl.get();\n>        }\n>         // 当线程池中的任务数量 >= \"核心池大小\"时，\n>    \t // 而且，\"线程池处于运行状态\"时，则尝试将任务添加到阻塞队列中。\n>        if (isRunning(c) && workQueue.offer(command)) {\n>             // 再次确认“线程池状态”，若线程池异常终止了，则删除任务；\n>            //然后通过reject()执行相应的拒绝策略的内容。\n>            int recheck = ctl.get();\n>            if (! isRunning(recheck) && remove(command))\n>                reject(command);\n>            // 否则，如果\"线程池中任务数量\"为0，则通过addWorker(null, false)尝试新建一个线\n>            // 程，新建线程对应的任务为null。防止线程池被关闭\n>            else if (workerCountOf(recheck) == 0)\n>                addWorker(null, false);\n>        }\n>       //这里是启动小于maxpoolSize的线程\n>       //如果添加任务到队列中不成功，则试图通过addWorker(command, false)新建一个线程，\n>       //并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。\n>       // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。\n>        else if (!addWorker(command, false))\n>            reject(command);\n>    }\n>}\n>```\n>\n>**说明**：execute()的作用是将任务添加到线程池中执行。它会分为3种情况进行处理：        \n>\n> **情况1** -- 如果\"线程池中任务数量\" < \"核心池大小\"时，即线程池中少于corePoolSize个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。         \n>\n>**情况2** -- 如果\"线程池中任务数量\" >= \"核心池大小\"，并且\"线程池是允许状态\"；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认\"线程池的状态\"，如果\"第2次读到的线程池状态\"和\"第1次读到的线程池状态\"不同，则从阻塞队列中删除该任务。         \n>\n>**情况3** -- 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过reject()拒绝该任务。\n>\n>到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：\n>\n>1. 首先，要清楚corePoolSize和maximumPoolSize的含义；\n>2. 其次，要知道Worker是用来起到什么作用的；\n>3. 要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：\n>\n>- 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；\n>- 如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；\n>- 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；\n>- 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于 corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。\n>\n>###  **addWorker**\n>\n>源码如下\n>\n>```java\n> private boolean addWorker(Runnable firstTask, boolean core) {\n>        retry:\n>        // 更新\"线程池状态和计数\"标记，即更新ctl。\n>        for (;;) {\n>           // 更新\"线程池状态和计数\"标记，即更新ctl。\n>            int c = ctl.get();\n>             // 获取线程池状态。\n>            int rs = runStateOf(c);\n>\n>            // Check if queue empty only if necessary.\n>            // 有效性检查\n>            if (rs >= SHUTDOWN &&\n>                ! (rs == SHUTDOWN &&\n>                   firstTask == null &&\n>                   ! workQueue.isEmpty()))\n>                return false;\n>\n>            for (;;) {\n>               // 获取线程池中任务的数量。\n>                int wc = workerCountOf(c);\n>                // 如果\"线程池中任务的数量\"超过限制，则返回false。\n>                if (wc >= CAPACITY ||\n>                    wc >= (core ? corePoolSize : maximumPoolSize))\n>                    return false;\n>                // 通过CAS函数将c的值+1。操作失败的话，则退出循环。\n>                if (compareAndIncrementWorkerCount(c))\n>                    break retry;\n>                c = ctl.get();  // Re-read ctl\n>                // 检查\"线程池状态\"，如果与之前的状态不同，则从retry重新开始。\n>                if (runStateOf(c) != rs)\n>                    continue retry;\n>                // else CAS failed due to workerCount change; retry inner loop\n>            }\n>        }\n>\n>    boolean workerStarted = false;\n>    boolean workerAdded = false;\n>    Worker w = null;\n>    // 添加任务到线程池，并启动任务所在的线程。\n>    try {\n>        final ReentrantLock mainLock = this.mainLock;\n>        // 新建Worker，并且指定firstTask为Worker的第一个任务。\n>        w = new Worker(firstTask);\n>        // 获取Worker对应的线程。\n>        final Thread t = w.thread;\n>        if (t != null) {\n>            // 获取锁\n>            mainLock.lock();\n>            try {\n>                int c = ctl.get();\n>                int rs = runStateOf(c);\n>\n>                // 再次确认\"线程池状态\"\n>                if (rs < SHUTDOWN ||\n>                    (rs == SHUTDOWN && firstTask == null)) {\n>                    if (t.isAlive()) // precheck that t is startable\n>                        throw new IllegalThreadStateException();\n>                    // 将Worker对象(w)添加到\"线程池的Worker集合(workers)\"中\n>                    workers.add(w);\n>                    // 更新largestPoolSize\n>                    int s = workers.size();\n>                    if (s > largestPoolSize)\n>                        largestPoolSize = s;\n>                    workerAdded = true;\n>                }\n>            } finally {\n>                // 释放锁\n>                mainLock.unlock();\n>            }\n>            // 如果\"成功将任务添加到线程池\"中，则启动任务所在的线程。 \n>            if (workerAdded) {\n>                t.start();\n>                workerStarted = true;\n>            }\n>        }\n>    } finally {\n>        if (! workerStarted)\n>            addWorkerFailed(w);\n>    }\n>    // 返回任务是否启动。\n>    return workerStarted;\n>}\n>\n>```\n>\n>**说明**：\n>\n>1.  addWorker(Runnable firstTask, boolean core) 的作用是将任务(firstTask)添加到线程池中，并启动该任务。core为true的话，则以corePoolSize为界限，若\"线程池中已有任务数量>=corePoolSize\"，则返回false；core为false的话，则以maximumPoolSize为界限，若\"线程池中已有任务数量>=maximumPoolSize\"，则返回false。\n>\n>2. addWorker()会先通过for循环不断尝试更新ctl状态，ctl记录了\"线程池中任务数量和线程池状态\"。更新成功之后，再通过try模块来将任务添加到线程池中，并启动任务所在的线程。\n>\n>3.  从addWorker()中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的Worker对象；而一个Workder对象包含一个Thread对象。\n>\n>   (01) 通过将Worker对象添加到\"线程的workers集合\"中，从而实现将任务添加到线程池中。\n>\n>   (02) 通过启动Worker对应的Thread线程，则执行该任务。\n>\n>### addWorkerFailed:\n>\n>如果Worker创建成功，但是没有启动，这时我们需要将从线程对象从works上移除，否则会影响线程池的性能，源码如下\n>\n>```java\n>    /**\n>     * Rolls back the worker thread creation.\n>     * - removes worker from workers, if present\n>     * - decrements worker count\n>     * - rechecks for termination, in case the existence of this\n>     *   worker was holding up termination\n>     */\n>    private void addWorkerFailed(Worker w) {\n>        \n>        final ReentrantLock mainLock = this.mainLock;\n>        //获取锁\n>        mainLock.lock();\n>        try {\n>            //从workers上移除线程\n>            if (w != null)\n>                workers.remove(w);\n>            //减少线程的数量\n>            decrementWorkerCount();\n>            //由于线程数量的减少，可能会使得当前线程池上线程的数量变成0，这时有可能进入\n>            //TIDYING状态，所以尝试结束线程池\n>            tryTerminate();\n>        } finally {\n>            mainLock.unlock();\n>        }\n>    }\n>```\n>\n>这时你们会不会有个疑问，一般我们写程序时，如果想让线程一直运行，则会向下面这样写:\n>\n>```\n>public void run(){\n>    while(true){\n>        //doSomething\n>    }\n>}\n>```\n>\n>但是上面执行流程分析完了，但是没看到ThreadPoolExecutor怎么定义线程一直运行，这时我们就要去分析Worker这个内部类的源码，这里面有我们想要的结果：\n>\n>源码如下：\n>\n>```java\n>  private final class Worker\n>        extends AbstractQueuedSynchronizer\n>        implements Runnable {      \n>        private static final long serialVersionUID = 6138294804551838833L;\n>   \t\t//当前woker正在运行的线程\n>        final Thread thread;\n>        //初始化这个工作线程时的第一个任务，可能为null\n>        Runnable firstTask;\n>       \t//每个线程完成任务的数量\n>        volatile long completedTasks;\n>        \n>        Worker(Runnable firstTask) {\n>            setState(-1); // inhibit interrupts until runWorker\n>            this.firstTask = firstTask;       \n>            //使用线程池提供的线程创建工厂来创建线程\n>            this.thread = getThreadFactory().newThread(this);\n>        }\n>        //委派当前线程的run方法到外部类的runWorker上，\n>        public void run() {\n>            runWorker(this);\n>        }\n>        // Lock methods\n>        //\n>        // The value 0 represents the unlocked state.\n>        // The value 1 represents the locked state.\n>        protected boolean isHeldExclusively() {\n>            return getState() != 0;\n>        }\n>\n>        protected boolean tryAcquire(int unused) {\n>            if (compareAndSetState(0, 1)) {\n>                setExclusiveOwnerThread(Thread.currentThread());\n>                return true;\n>            }\n>            return false;\n>        }\n>\n>        protected boolean tryRelease(int unused) {\n>            setExclusiveOwnerThread(null);\n>            setState(0);\n>            return true;\n>        }\n>\n>        public void lock()        { acquire(1); }\n>        public boolean tryLock()  { return tryAcquire(1); }\n>        public void unlock()      { release(1); }\n>        public boolean isLocked() { return isHeldExclusively(); }\n>\n>        void interruptIfStarted() {\n>            Thread t;\n>            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n>                try {\n>                    t.interrupt();\n>                } catch (SecurityException ignore) {\n>                }\n>            }\n>        }\n>    }\n>```\n>\n>分析：\n>\n>1. 从上面我们可以看出，Worker继承AQS，实现Runnable接口，继承AQS实现了一个简单的互斥锁，是不想在Worker运行的时候使用外部类的互斥锁，这样可以减少线程的等待。\n>2. 线程创建时通过外部类的threadFactory来创建的，后面我会讲解这个类，其实很简单\n>\n>从上面可以看出Worker类的run方法实现实际上是外部类的runWorker方法实现的，源码如下：\n>\n>```java\n>final void runWorker(Worker w) {\n>\t\t//获取当前cpu上运行的线程，其实也就是worker中的thread\n>        Thread wt = Thread.currentThread();\n>    \t//获取第一个运行任务，可以为null\n>        Runnable task = w.firstTask;\n>        w.firstTask = null;\n>    \t//释放锁\n>        w.unlock(); // allow interrupts\n>    \t//判断当前线程是否是中断结束 true 不是\n>        boolean completedAbruptly = true;\n>        try {\n>            //当任务不为空，一直运行\n>            while (task != null || (task = getTask()) != null) {\n>                w.lock();\n>                // If pool is stopping, ensure thread is interrupted;\n>                // if not, ensure thread is not interrupted.  This\n>                // requires a recheck in second case to deal with\n>                // shutdownNow race while clearing interrupt\n>                if ((runStateAtLeast(ctl.get(), STOP) ||\n>                     (Thread.interrupted() &&\n>                      runStateAtLeast(ctl.get(), STOP))) &&\n>                    !wt.isInterrupted())\n>                    wt.interrupt();\n>                try {\n>                    //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n>                    //默认什么也不做\n>                    beforeExecute(wt, task);\n>                    Throwable thrown = null;\n>                    try {\n>                        //执行任务\n>                        task.run();\n>                    } catch (RuntimeException x) {\n>                        thrown = x; throw x;\n>                    } catch (Error x) {\n>                        thrown = x; throw x;\n>                    } catch (Throwable x) {\n>                        thrown = x; throw new Error(x);\n>                    } finally {\n>                         //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n>                         //默认什么也不做\n>                        afterExecute(task, thrown);\n>                    }\n>                } finally {\n>                    task = null;\n>                    w.completedTasks++;\n>                    w.unlock();\n>                }\n>            }\n>            completedAbruptly = false;\n>        } finally {\n>            //线程死亡，使用此方法执行后续清理工作，\n>            processWorkerExit(w, completedAbruptly);\n>        }\n>    }\n>```\n>\n>从上面代码可以看到这边在循环获取任务，并执行，直到任务全部执行完毕。除了第一个任务，其他任务都是通过`getTask()`方法去取，这个方法是ThreadPoolExecutor中的一个方法。我们猜一下，整个类中只有任务缓存队列中保存了任务，应该就是去缓存队列中取了。\n>\n>```\n>Runnable getTask() {\n>    for (;;) {\n>        try {\n>            int state = runState;\n>            if (state > SHUTDOWN)\n>                return null;\n>            Runnable r;\n>            if (state == SHUTDOWN)  // Help drain queue\n>                r = workQueue.poll(); //取任务\n>            else if (poolSize > corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，\n>                //则通过poll取任务，若等待一定的时间取不到任务，则返回null\n>                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);\n>            else\n>                r = workQueue.take();\n>            if (r != null)\n>                return r;\n>            if (workerCanExit()) {    //如果没取到任务，即r为null，则判断当前的worker是否可以退出\n>                if (runState >= SHUTDOWN) // Wake up others\n>                    interruptIdleWorkers();   //中断处于空闲状态的worker\n>                return null;\n>            }\n>            // Else retry\n>        } catch (InterruptedException ie) {\n>            // On interruption, re-check runState\n>        }\n>    }\n>}\n>```\n>\n>这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给 空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程Worker去任务缓存队列里面取任务来执行，因为每一个Worker里面都包含了一个线程thread。\n>\n>还需要注意的是，当线程死亡如何处理：\n>\n>源码如下：\n>\n>```\n>\t//处理线程结束时的清理工作\n>    private void processWorkerExit(Worker w, boolean completedAbruptly) {\n>        //如果是中断结束，则线程数量不做调整\n>        if (completedAbruptly) \n>            decrementWorkerCount();\n>\n>        final ReentrantLock mainLock = this.mainLock;\n>        //获取锁\n>        mainLock.lock();\n>        try {\n>            //将当前worker线程上的完成任务数量记录下来\n>            completedTaskCount += w.completedTasks;\n>            //移除当前此worker\n>            workers.remove(w);\n>        } finally {\n>            mainLock.unlock();\n>        }\n>        //尝试关闭线程池\n>        tryTerminate();\n>        int c = ctl.get();\n>        //如果当前线程池状态不是stop，则添加woker线程\n>        if (runStateLessThan(c, STOP)) {\n>            //如果是异常导致线程的中断，则判断当前线程池中线程的\n>            //数量是否大于min，min表示当前线程池最少应该有多少线程\n>            //如果少于，则创建一个新的worker线程\n>            if (!completedAbruptly) {\n>                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n>                if (min == 0 && ! workQueue.isEmpty())\n>                    min = 1;\n>                if (workerCountOf(c) >= min)\n>                    return; // replacement not needed\n>            }\n>            addWorker(null, false);\n>        }\n>    }\n>```\n>\n>\n>\n>### 关闭“线程池”\n>\n>shutdown()的源码如下：\n>\n>```java\n>public void shutdown() {\n>    final ReentrantLock mainLock = this.mainLock;\n>    // 获取锁\n>    mainLock.lock();\n>    try {\n>        // 检查终止线程池的“线程”是否有权限。\n>        checkShutdownAccess();\n>        // 设置线程池的状态为关闭状态。\n>        advanceRunState(SHUTDOWN);\n>        // 中断线程池中空闲的线程。\n>        interruptIdleWorkers();\n>        // 钩子函数，在ThreadPoolExecutor中没有任何动作。\n>        onShutdown(); // hook for ScheduledThreadPoolExecutor\n>    } finally {\n>        // 释放锁\n>        mainLock.unlock();\n>    }\n>    // 尝试终止线程池\n>    tryTerminate();\n>}\n>```\n>\n>**说明**：shutdown()的作用是关闭线程池。\n>\n> shutdownNow()源码如下：\n>\n>```java\n>public List<Runnable> shutdownNow() {\n>        List<Runnable> tasks;\n>        final ReentrantLock mainLock = this.mainLock;\n>        //获取所\n>        mainLock.lock();\n>        try {\n>        \t\n>            checkShutdownAccess();\n>            //设置线程池状态为stop状态\n>            advanceRunState(STOP);\n>            //中断所有线程\n>            interruptWorkers();\n>            //取出队列上还未被执行的任务\n>            tasks = drainQueue();\n>        } finally {\n>            mainLock.unlock();\n>        }\n>        tryTerminate();\n>        //返回队列上的任务\n>        return tasks;\n>    }\n>\n>```\n>\n>\n>\n>\n\n","slug":"juc/threads/java多线程系列-JUC线程池之02 ThreadPoolExecutor源码分析","published":1,"updated":"2019-01-04T01:48:59.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovxm005y9q1u88sfe0o8","content":"<h1 id=\"java多线程系列-JUC线程池之02-ThreadPoolExecutor-执行流程分析\"><a href=\"#java多线程系列-JUC线程池之02-ThreadPoolExecutor-执行流程分析\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析\"></a>java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>线程池使用例子</li>\n<li>线程池状态</li>\n<li>任务执行流程分析</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程池使用例子\"><a href=\"#1-线程池使用例子\" class=\"headerlink\" title=\"1. 线程池使用例子\"></a>1. 线程池使用例子</h3><blockquote>\n<p>简单例子</p>\n<pre><code>import java.util.concurrent.Executors;\nimport java.util.concurrent.ExecutorService;\n\npublic class ThreadPoolDemo1 {\n\n   public static void main(String[] args) {\n       // 创建一个可重用固定线程数的线程池\n       ExecutorService pool = Executors.newFixedThreadPool(2);\n       // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n       Thread ta = new MyThread();\n       Thread tb = new MyThread();\n       Thread tc = new MyThread();\n       Thread td = new MyThread();\n       Thread te = new MyThread();\n       // 将线程放入池中进行执行\n       pool.execute(ta);\n       pool.execute(tb);\n       pool.execute(tc);\n       pool.execute(td);\n       pool.execute(te);\n       // 关闭线程池\n       pool.shutdown();\n   }\n}\n\nclass MyThread extends Thread {\n\n   @Override\n   public void run() {\n       System.out.println(Thread.currentThread().getName()+ &quot; is running.&quot;);\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>pool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\n</code></pre><p>示例中，使用了Excutors工具类来创建线程池，并提交任务到线程池上运行，然后关闭线程池，这是一个简单的实例。接下来我们将进行ThreadPoolExecutor深入分析。</p>\n</blockquote>\n<h3 id=\"2-线程池状态\"><a href=\"#2-线程池状态\" class=\"headerlink\" title=\"2. 线程池状态\"></a>2. 线程池状态</h3><blockquote>\n<p>在线程池中使用了一个AtomicInteger对象来表示线程的状态和任务的数量。其中Integer是32位，用高三位来表示线程池的状态，至于怎么计算不是这里的重点，这里我们先讲解任务的状态。</p>\n<p>线程池中任务的状态有以下5种：</p>\n<pre><code>RUNNING   :接收新的任务和处理队列中的任务\nSHUTDOWN  :不在接收新的任务和但是处理队列中的任务。\nSTOP        :不在接收新的任务，同时不在处理队列中的任务，线程上正在运行的任务也会被打断。\nTIDYING   :所有的任务已经结束，并且线程的数量为0，线程的状态转换成清理的状态，接下来将会运行\n           terminated()方法。\nTERMINATED:terminated()执行完成\n</code></pre><p>状态的转换:</p>\n<pre><code>* RUNNING -&gt; SHUTDOWN\n*    On invocation of shutdown(), perhaps implicitly in finalize()\n* (RUNNING or SHUTDOWN) -&gt; STOP\n*    On invocation of shutdownNow()\n* SHUTDOWN -&gt; TIDYING\n*    When both queue and pool are empty\n* STOP -&gt; TIDYING\n*    When pool is empty\n* TIDYING -&gt; TERMINATED\n*    When the terminated() hook method has completed\n</code></pre></blockquote>\n<h3 id=\"3-线程池执行任务分析\"><a href=\"#3-线程池执行任务分析\" class=\"headerlink\" title=\"3. 线程池执行任务分析\"></a>3. 线程池执行任务分析</h3><blockquote>\n<p>在讲解运行过程前，我们先看下<code>ThreadPoolExecutor</code>中的几个比较重要的成员变量：</p>\n<pre><code class=\"java\">//线程池状态，和队列中任务数量的表示，高三位表示状态，剩下的表示线程的状态\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); \n//任务缓存队列，用来保存等待中的任务，等待worker线程空闲时执行任务\nprivate final BlockingQueue&lt;Runnable&gt; workQueue;\n//更新 poolSize, corePoolSize,maximumPoolSize, runState, and workers set 时需要持有这个锁\nprivate final ReentrantLock mainLock = new ReentrantLock(); \n//用来保存工作中的执行线程\n\nprivate final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); \nprivate volatile long  keepAliveTime; //超过corePoolSize外的线程空闲存活之间\n//是否对corePoolSize内的线程设置空闲存活时间\nprivate volatile boolean allowCoreThreadTimeOut; \nprivate volatile int   corePoolSize; //核心线程数\n\n//最大线程数（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）\nprivate volatile int   maximumPoolSize; \nprivate volatile int   poolSize; //线程池中的当前线程数\nprivate volatile RejectedExecutionHandler handler; //任务拒绝策略\nprivate volatile ThreadFactory threadFactory; //线程工厂，用来新建线程\nprivate int largestPoolSize; //记录线程池中出现过的最大线程数大小\nprivate long completedTaskCount; //已经执行完的线程数\n</code></pre>\n<p>这边重点解释下 <code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>两个变量，这两个变量涉及到线程池中创建线程个数的一个策略。<br><code>corePoolSize</code>： 这个变量我们可以理解为线程池的核心大小，举个例子来说明（corePoolSize假设等于10，maximumPoolSize等于20）：</p>\n<ol>\n<li>有一个部门，其中有10（corePoolSize）名工人，当有新任务来了后，领导就分配任务给工人去做，每个工人只能做一个任务。</li>\n<li>当10个工人都在忙时，新来的任务就要放到队列（workQueue）中等待。</li>\n<li>当任务越积累越多，远远超过工人做任务的速度时，领导就想了一个办法：从其他部门借10个工人来，借的数量有一个公式（maximumPoolSize - corePoolSize）来计算。然后把新来的任务分配给借来的工人来做。</li>\n<li>但是如果速度还是还不急的话，可能就要采取措施来放弃一些任务了（RejectedExecutionHandler）。<br>等到一定时间后，任务都完成了，工人比较闲的情况下，就考虑把借来的10个工人还回去（根据keepAliveTime判断）</li>\n<li>也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</li>\n</ol>\n<h3 id=\"任务执行：execute\"><a href=\"#任务执行：execute\" class=\"headerlink\" title=\"任务执行：execute\"></a>任务执行：execute</h3><p>这个方法在ThreadPoolExecutor中的源码如下</p>\n<pre><code class=\"java\">public void execute(Runnable command) {\n        //如果任务是空，则抛出空指针异常\n       if (command == null)\n           throw new NullPointerException();\n        //得到当前ctl的值，方便下面计算    \n       int c = ctl.get();\n        //计算当前线程池中线程的数量，如果小于核心线程数，则添加线程\n       if (workerCountOf(c) &lt; corePoolSize) {\n           // 则通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程\n           //中；然后，启动该线程从而执行任务。\n           if (addWorker(command, true))\n               return;\n           c = ctl.get();\n       }\n        // 当线程池中的任务数量 &gt;= &quot;核心池大小&quot;时，\n        // 而且，&quot;线程池处于运行状态&quot;时，则尝试将任务添加到阻塞队列中。\n       if (isRunning(c) &amp;&amp; workQueue.offer(command)) {\n            // 再次确认“线程池状态”，若线程池异常终止了，则删除任务；\n           //然后通过reject()执行相应的拒绝策略的内容。\n           int recheck = ctl.get();\n           if (! isRunning(recheck) &amp;&amp; remove(command))\n               reject(command);\n           // 否则，如果&quot;线程池中任务数量&quot;为0，则通过addWorker(null, false)尝试新建一个线\n           // 程，新建线程对应的任务为null。防止线程池被关闭\n           else if (workerCountOf(recheck) == 0)\n               addWorker(null, false);\n       }\n      //这里是启动小于maxpoolSize的线程\n      //如果添加任务到队列中不成功，则试图通过addWorker(command, false)新建一个线程，\n      //并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。\n      // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。\n       else if (!addWorker(command, false))\n           reject(command);\n   }\n}\n</code></pre>\n<p><strong>说明</strong>：execute()的作用是将任务添加到线程池中执行。它会分为3种情况进行处理：        </p>\n<p><strong>情况1</strong> – 如果”线程池中任务数量” &lt; “核心池大小”时，即线程池中少于corePoolSize个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。         </p>\n<p><strong>情况2</strong> – 如果”线程池中任务数量” &gt;= “核心池大小”，并且”线程池是允许状态”；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认”线程池的状态”，如果”第2次读到的线程池状态”和”第1次读到的线程池状态”不同，则从阻塞队列中删除该任务。         </p>\n<p><strong>情况3</strong> – 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过reject()拒绝该任务。</p>\n<p>到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：</p>\n<ol>\n<li>首先，要清楚corePoolSize和maximumPoolSize的含义；</li>\n<li>其次，要知道Worker是用来起到什么作用的；</li>\n<li>要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：</li>\n</ol>\n<ul>\n<li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li>\n<li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li>\n<li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li>\n<li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于 corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li>\n</ul>\n<h3 id=\"addWorker\"><a href=\"#addWorker\" class=\"headerlink\" title=\"addWorker\"></a><strong>addWorker</strong></h3><p>源码如下</p>\n<pre><code class=\"java\">private boolean addWorker(Runnable firstTask, boolean core) {\n       retry:\n       // 更新&quot;线程池状态和计数&quot;标记，即更新ctl。\n       for (;;) {\n          // 更新&quot;线程池状态和计数&quot;标记，即更新ctl。\n           int c = ctl.get();\n            // 获取线程池状态。\n           int rs = runStateOf(c);\n\n           // Check if queue empty only if necessary.\n           // 有效性检查\n           if (rs &gt;= SHUTDOWN &amp;&amp;\n               ! (rs == SHUTDOWN &amp;&amp;\n                  firstTask == null &amp;&amp;\n                  ! workQueue.isEmpty()))\n               return false;\n\n           for (;;) {\n              // 获取线程池中任务的数量。\n               int wc = workerCountOf(c);\n               // 如果&quot;线程池中任务的数量&quot;超过限制，则返回false。\n               if (wc &gt;= CAPACITY ||\n                   wc &gt;= (core ? corePoolSize : maximumPoolSize))\n                   return false;\n               // 通过CAS函数将c的值+1。操作失败的话，则退出循环。\n               if (compareAndIncrementWorkerCount(c))\n                   break retry;\n               c = ctl.get();  // Re-read ctl\n               // 检查&quot;线程池状态&quot;，如果与之前的状态不同，则从retry重新开始。\n               if (runStateOf(c) != rs)\n                   continue retry;\n               // else CAS failed due to workerCount change; retry inner loop\n           }\n       }\n\n   boolean workerStarted = false;\n   boolean workerAdded = false;\n   Worker w = null;\n   // 添加任务到线程池，并启动任务所在的线程。\n   try {\n       final ReentrantLock mainLock = this.mainLock;\n       // 新建Worker，并且指定firstTask为Worker的第一个任务。\n       w = new Worker(firstTask);\n       // 获取Worker对应的线程。\n       final Thread t = w.thread;\n       if (t != null) {\n           // 获取锁\n           mainLock.lock();\n           try {\n               int c = ctl.get();\n               int rs = runStateOf(c);\n\n               // 再次确认&quot;线程池状态&quot;\n               if (rs &lt; SHUTDOWN ||\n                   (rs == SHUTDOWN &amp;&amp; firstTask == null)) {\n                   if (t.isAlive()) // precheck that t is startable\n                       throw new IllegalThreadStateException();\n                   // 将Worker对象(w)添加到&quot;线程池的Worker集合(workers)&quot;中\n                   workers.add(w);\n                   // 更新largestPoolSize\n                   int s = workers.size();\n                   if (s &gt; largestPoolSize)\n                       largestPoolSize = s;\n                   workerAdded = true;\n               }\n           } finally {\n               // 释放锁\n               mainLock.unlock();\n           }\n           // 如果&quot;成功将任务添加到线程池&quot;中，则启动任务所在的线程。 \n           if (workerAdded) {\n               t.start();\n               workerStarted = true;\n           }\n       }\n   } finally {\n       if (! workerStarted)\n           addWorkerFailed(w);\n   }\n   // 返回任务是否启动。\n   return workerStarted;\n}\n\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li><p>addWorker(Runnable firstTask, boolean core) 的作用是将任务(firstTask)添加到线程池中，并启动该任务。core为true的话，则以corePoolSize为界限，若”线程池中已有任务数量&gt;=corePoolSize”，则返回false；core为false的话，则以maximumPoolSize为界限，若”线程池中已有任务数量&gt;=maximumPoolSize”，则返回false。</p>\n</li>\n<li><p>addWorker()会先通过for循环不断尝试更新ctl状态，ctl记录了”线程池中任务数量和线程池状态”。更新成功之后，再通过try模块来将任务添加到线程池中，并启动任务所在的线程。</p>\n</li>\n<li><p>从addWorker()中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的Worker对象；而一个Workder对象包含一个Thread对象。</p>\n<p>(01) 通过将Worker对象添加到”线程的workers集合”中，从而实现将任务添加到线程池中。</p>\n<p>(02) 通过启动Worker对应的Thread线程，则执行该任务。</p>\n</li>\n</ol>\n<h3 id=\"addWorkerFailed\"><a href=\"#addWorkerFailed\" class=\"headerlink\" title=\"addWorkerFailed:\"></a>addWorkerFailed:</h3><p>如果Worker创建成功，但是没有启动，这时我们需要将从线程对象从works上移除，否则会影响线程池的性能，源码如下</p>\n<pre><code class=\"java\">   /**\n    * Rolls back the worker thread creation.\n    * - removes worker from workers, if present\n    * - decrements worker count\n    * - rechecks for termination, in case the existence of this\n    *   worker was holding up termination\n    */\n   private void addWorkerFailed(Worker w) {\n\n       final ReentrantLock mainLock = this.mainLock;\n       //获取锁\n       mainLock.lock();\n       try {\n           //从workers上移除线程\n           if (w != null)\n               workers.remove(w);\n           //减少线程的数量\n           decrementWorkerCount();\n           //由于线程数量的减少，可能会使得当前线程池上线程的数量变成0，这时有可能进入\n           //TIDYING状态，所以尝试结束线程池\n           tryTerminate();\n       } finally {\n           mainLock.unlock();\n       }\n   }\n</code></pre>\n<p>这时你们会不会有个疑问，一般我们写程序时，如果想让线程一直运行，则会向下面这样写:</p>\n<pre><code>public void run(){\n   while(true){\n       //doSomething\n   }\n}\n</code></pre><p>但是上面执行流程分析完了，但是没看到ThreadPoolExecutor怎么定义线程一直运行，这时我们就要去分析Worker这个内部类的源码，这里面有我们想要的结果：</p>\n<p>源码如下：</p>\n<pre><code class=\"java\"> private final class Worker\n       extends AbstractQueuedSynchronizer\n       implements Runnable {      \n       private static final long serialVersionUID = 6138294804551838833L;\n          //当前woker正在运行的线程\n       final Thread thread;\n       //初始化这个工作线程时的第一个任务，可能为null\n       Runnable firstTask;\n          //每个线程完成任务的数量\n       volatile long completedTasks;\n\n       Worker(Runnable firstTask) {\n           setState(-1); // inhibit interrupts until runWorker\n           this.firstTask = firstTask;       \n           //使用线程池提供的线程创建工厂来创建线程\n           this.thread = getThreadFactory().newThread(this);\n       }\n       //委派当前线程的run方法到外部类的runWorker上，\n       public void run() {\n           runWorker(this);\n       }\n       // Lock methods\n       //\n       // The value 0 represents the unlocked state.\n       // The value 1 represents the locked state.\n       protected boolean isHeldExclusively() {\n           return getState() != 0;\n       }\n\n       protected boolean tryAcquire(int unused) {\n           if (compareAndSetState(0, 1)) {\n               setExclusiveOwnerThread(Thread.currentThread());\n               return true;\n           }\n           return false;\n       }\n\n       protected boolean tryRelease(int unused) {\n           setExclusiveOwnerThread(null);\n           setState(0);\n           return true;\n       }\n\n       public void lock()        { acquire(1); }\n       public boolean tryLock()  { return tryAcquire(1); }\n       public void unlock()      { release(1); }\n       public boolean isLocked() { return isHeldExclusively(); }\n\n       void interruptIfStarted() {\n           Thread t;\n           if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {\n               try {\n                   t.interrupt();\n               } catch (SecurityException ignore) {\n               }\n           }\n       }\n   }\n</code></pre>\n<p>分析：</p>\n<ol>\n<li>从上面我们可以看出，Worker继承AQS，实现Runnable接口，继承AQS实现了一个简单的互斥锁，是不想在Worker运行的时候使用外部类的互斥锁，这样可以减少线程的等待。</li>\n<li>线程创建时通过外部类的threadFactory来创建的，后面我会讲解这个类，其实很简单</li>\n</ol>\n<p>从上面可以看出Worker类的run方法实现实际上是外部类的runWorker方法实现的，源码如下：</p>\n<pre><code class=\"java\">final void runWorker(Worker w) {\n       //获取当前cpu上运行的线程，其实也就是worker中的thread\n       Thread wt = Thread.currentThread();\n       //获取第一个运行任务，可以为null\n       Runnable task = w.firstTask;\n       w.firstTask = null;\n       //释放锁\n       w.unlock(); // allow interrupts\n       //判断当前线程是否是中断结束 true 不是\n       boolean completedAbruptly = true;\n       try {\n           //当任务不为空，一直运行\n           while (task != null || (task = getTask()) != null) {\n               w.lock();\n               // If pool is stopping, ensure thread is interrupted;\n               // if not, ensure thread is not interrupted.  This\n               // requires a recheck in second case to deal with\n               // shutdownNow race while clearing interrupt\n               if ((runStateAtLeast(ctl.get(), STOP) ||\n                    (Thread.interrupted() &amp;&amp;\n                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;\n                   !wt.isInterrupted())\n                   wt.interrupt();\n               try {\n                   //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n                   //默认什么也不做\n                   beforeExecute(wt, task);\n                   Throwable thrown = null;\n                   try {\n                       //执行任务\n                       task.run();\n                   } catch (RuntimeException x) {\n                       thrown = x; throw x;\n                   } catch (Error x) {\n                       thrown = x; throw x;\n                   } catch (Throwable x) {\n                       thrown = x; throw new Error(x);\n                   } finally {\n                        //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n                        //默认什么也不做\n                       afterExecute(task, thrown);\n                   }\n               } finally {\n                   task = null;\n                   w.completedTasks++;\n                   w.unlock();\n               }\n           }\n           completedAbruptly = false;\n       } finally {\n           //线程死亡，使用此方法执行后续清理工作，\n           processWorkerExit(w, completedAbruptly);\n       }\n   }\n</code></pre>\n<p>从上面代码可以看到这边在循环获取任务，并执行，直到任务全部执行完毕。除了第一个任务，其他任务都是通过<code>getTask()</code>方法去取，这个方法是ThreadPoolExecutor中的一个方法。我们猜一下，整个类中只有任务缓存队列中保存了任务，应该就是去缓存队列中取了。</p>\n<pre><code>Runnable getTask() {\n   for (;;) {\n       try {\n           int state = runState;\n           if (state &gt; SHUTDOWN)\n               return null;\n           Runnable r;\n           if (state == SHUTDOWN)  // Help drain queue\n               r = workQueue.poll(); //取任务\n           else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，\n               //则通过poll取任务，若等待一定的时间取不到任务，则返回null\n               r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);\n           else\n               r = workQueue.take();\n           if (r != null)\n               return r;\n           if (workerCanExit()) {    //如果没取到任务，即r为null，则判断当前的worker是否可以退出\n               if (runState &gt;= SHUTDOWN) // Wake up others\n                   interruptIdleWorkers();   //中断处于空闲状态的worker\n               return null;\n           }\n           // Else retry\n       } catch (InterruptedException ie) {\n           // On interruption, re-check runState\n       }\n   }\n}\n</code></pre><p>这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给 空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程Worker去任务缓存队列里面取任务来执行，因为每一个Worker里面都包含了一个线程thread。</p>\n<p>还需要注意的是，当线程死亡如何处理：</p>\n<p>源码如下：</p>\n<pre><code>   //处理线程结束时的清理工作\n   private void processWorkerExit(Worker w, boolean completedAbruptly) {\n       //如果是中断结束，则线程数量不做调整\n       if (completedAbruptly) \n           decrementWorkerCount();\n\n       final ReentrantLock mainLock = this.mainLock;\n       //获取锁\n       mainLock.lock();\n       try {\n           //将当前worker线程上的完成任务数量记录下来\n           completedTaskCount += w.completedTasks;\n           //移除当前此worker\n           workers.remove(w);\n       } finally {\n           mainLock.unlock();\n       }\n       //尝试关闭线程池\n       tryTerminate();\n       int c = ctl.get();\n       //如果当前线程池状态不是stop，则添加woker线程\n       if (runStateLessThan(c, STOP)) {\n           //如果是异常导致线程的中断，则判断当前线程池中线程的\n           //数量是否大于min，min表示当前线程池最少应该有多少线程\n           //如果少于，则创建一个新的worker线程\n           if (!completedAbruptly) {\n               int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n               if (min == 0 &amp;&amp; ! workQueue.isEmpty())\n                   min = 1;\n               if (workerCountOf(c) &gt;= min)\n                   return; // replacement not needed\n           }\n           addWorker(null, false);\n       }\n   }\n</code></pre><h3 id=\"关闭“线程池”\"><a href=\"#关闭“线程池”\" class=\"headerlink\" title=\"关闭“线程池”\"></a>关闭“线程池”</h3><p>shutdown()的源码如下：</p>\n<pre><code class=\"java\">public void shutdown() {\n   final ReentrantLock mainLock = this.mainLock;\n   // 获取锁\n   mainLock.lock();\n   try {\n       // 检查终止线程池的“线程”是否有权限。\n       checkShutdownAccess();\n       // 设置线程池的状态为关闭状态。\n       advanceRunState(SHUTDOWN);\n       // 中断线程池中空闲的线程。\n       interruptIdleWorkers();\n       // 钩子函数，在ThreadPoolExecutor中没有任何动作。\n       onShutdown(); // hook for ScheduledThreadPoolExecutor\n   } finally {\n       // 释放锁\n       mainLock.unlock();\n   }\n   // 尝试终止线程池\n   tryTerminate();\n}\n</code></pre>\n<p><strong>说明</strong>：shutdown()的作用是关闭线程池。</p>\n<p>shutdownNow()源码如下：</p>\n<pre><code class=\"java\">public List&lt;Runnable&gt; shutdownNow() {\n       List&lt;Runnable&gt; tasks;\n       final ReentrantLock mainLock = this.mainLock;\n       //获取所\n       mainLock.lock();\n       try {\n\n           checkShutdownAccess();\n           //设置线程池状态为stop状态\n           advanceRunState(STOP);\n           //中断所有线程\n           interruptWorkers();\n           //取出队列上还未被执行的任务\n           tasks = drainQueue();\n       } finally {\n           mainLock.unlock();\n       }\n       tryTerminate();\n       //返回队列上的任务\n       return tasks;\n   }\n\n</code></pre>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-JUC线程池之02-ThreadPoolExecutor-执行流程分析\"><a href=\"#java多线程系列-JUC线程池之02-ThreadPoolExecutor-执行流程分析\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析\"></a>java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>线程池使用例子</li>\n<li>线程池状态</li>\n<li>任务执行流程分析</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程池使用例子\"><a href=\"#1-线程池使用例子\" class=\"headerlink\" title=\"1. 线程池使用例子\"></a>1. 线程池使用例子</h3><blockquote>\n<p>简单例子</p>\n<pre><code>import java.util.concurrent.Executors;\nimport java.util.concurrent.ExecutorService;\n\npublic class ThreadPoolDemo1 {\n\n   public static void main(String[] args) {\n       // 创建一个可重用固定线程数的线程池\n       ExecutorService pool = Executors.newFixedThreadPool(2);\n       // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n       Thread ta = new MyThread();\n       Thread tb = new MyThread();\n       Thread tc = new MyThread();\n       Thread td = new MyThread();\n       Thread te = new MyThread();\n       // 将线程放入池中进行执行\n       pool.execute(ta);\n       pool.execute(tb);\n       pool.execute(tc);\n       pool.execute(td);\n       pool.execute(te);\n       // 关闭线程池\n       pool.shutdown();\n   }\n}\n\nclass MyThread extends Thread {\n\n   @Override\n   public void run() {\n       System.out.println(Thread.currentThread().getName()+ &quot; is running.&quot;);\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>pool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\n</code></pre><p>示例中，使用了Excutors工具类来创建线程池，并提交任务到线程池上运行，然后关闭线程池，这是一个简单的实例。接下来我们将进行ThreadPoolExecutor深入分析。</p>\n</blockquote>\n<h3 id=\"2-线程池状态\"><a href=\"#2-线程池状态\" class=\"headerlink\" title=\"2. 线程池状态\"></a>2. 线程池状态</h3><blockquote>\n<p>在线程池中使用了一个AtomicInteger对象来表示线程的状态和任务的数量。其中Integer是32位，用高三位来表示线程池的状态，至于怎么计算不是这里的重点，这里我们先讲解任务的状态。</p>\n<p>线程池中任务的状态有以下5种：</p>\n<pre><code>RUNNING   :接收新的任务和处理队列中的任务\nSHUTDOWN  :不在接收新的任务和但是处理队列中的任务。\nSTOP        :不在接收新的任务，同时不在处理队列中的任务，线程上正在运行的任务也会被打断。\nTIDYING   :所有的任务已经结束，并且线程的数量为0，线程的状态转换成清理的状态，接下来将会运行\n           terminated()方法。\nTERMINATED:terminated()执行完成\n</code></pre><p>状态的转换:</p>\n<pre><code>* RUNNING -&gt; SHUTDOWN\n*    On invocation of shutdown(), perhaps implicitly in finalize()\n* (RUNNING or SHUTDOWN) -&gt; STOP\n*    On invocation of shutdownNow()\n* SHUTDOWN -&gt; TIDYING\n*    When both queue and pool are empty\n* STOP -&gt; TIDYING\n*    When pool is empty\n* TIDYING -&gt; TERMINATED\n*    When the terminated() hook method has completed\n</code></pre></blockquote>\n<h3 id=\"3-线程池执行任务分析\"><a href=\"#3-线程池执行任务分析\" class=\"headerlink\" title=\"3. 线程池执行任务分析\"></a>3. 线程池执行任务分析</h3><blockquote>\n<p>在讲解运行过程前，我们先看下<code>ThreadPoolExecutor</code>中的几个比较重要的成员变量：</p>\n<pre><code class=\"java\">//线程池状态，和队列中任务数量的表示，高三位表示状态，剩下的表示线程的状态\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); \n//任务缓存队列，用来保存等待中的任务，等待worker线程空闲时执行任务\nprivate final BlockingQueue&lt;Runnable&gt; workQueue;\n//更新 poolSize, corePoolSize,maximumPoolSize, runState, and workers set 时需要持有这个锁\nprivate final ReentrantLock mainLock = new ReentrantLock(); \n//用来保存工作中的执行线程\n\nprivate final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); \nprivate volatile long  keepAliveTime; //超过corePoolSize外的线程空闲存活之间\n//是否对corePoolSize内的线程设置空闲存活时间\nprivate volatile boolean allowCoreThreadTimeOut; \nprivate volatile int   corePoolSize; //核心线程数\n\n//最大线程数（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）\nprivate volatile int   maximumPoolSize; \nprivate volatile int   poolSize; //线程池中的当前线程数\nprivate volatile RejectedExecutionHandler handler; //任务拒绝策略\nprivate volatile ThreadFactory threadFactory; //线程工厂，用来新建线程\nprivate int largestPoolSize; //记录线程池中出现过的最大线程数大小\nprivate long completedTaskCount; //已经执行完的线程数\n</code></pre>\n<p>这边重点解释下 <code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>两个变量，这两个变量涉及到线程池中创建线程个数的一个策略。<br><code>corePoolSize</code>： 这个变量我们可以理解为线程池的核心大小，举个例子来说明（corePoolSize假设等于10，maximumPoolSize等于20）：</p>\n<ol>\n<li>有一个部门，其中有10（corePoolSize）名工人，当有新任务来了后，领导就分配任务给工人去做，每个工人只能做一个任务。</li>\n<li>当10个工人都在忙时，新来的任务就要放到队列（workQueue）中等待。</li>\n<li>当任务越积累越多，远远超过工人做任务的速度时，领导就想了一个办法：从其他部门借10个工人来，借的数量有一个公式（maximumPoolSize - corePoolSize）来计算。然后把新来的任务分配给借来的工人来做。</li>\n<li>但是如果速度还是还不急的话，可能就要采取措施来放弃一些任务了（RejectedExecutionHandler）。<br>等到一定时间后，任务都完成了，工人比较闲的情况下，就考虑把借来的10个工人还回去（根据keepAliveTime判断）</li>\n<li>也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</li>\n</ol>\n<h3 id=\"任务执行：execute\"><a href=\"#任务执行：execute\" class=\"headerlink\" title=\"任务执行：execute\"></a>任务执行：execute</h3><p>这个方法在ThreadPoolExecutor中的源码如下</p>\n<pre><code class=\"java\">public void execute(Runnable command) {\n        //如果任务是空，则抛出空指针异常\n       if (command == null)\n           throw new NullPointerException();\n        //得到当前ctl的值，方便下面计算    \n       int c = ctl.get();\n        //计算当前线程池中线程的数量，如果小于核心线程数，则添加线程\n       if (workerCountOf(c) &lt; corePoolSize) {\n           // 则通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程\n           //中；然后，启动该线程从而执行任务。\n           if (addWorker(command, true))\n               return;\n           c = ctl.get();\n       }\n        // 当线程池中的任务数量 &gt;= &quot;核心池大小&quot;时，\n        // 而且，&quot;线程池处于运行状态&quot;时，则尝试将任务添加到阻塞队列中。\n       if (isRunning(c) &amp;&amp; workQueue.offer(command)) {\n            // 再次确认“线程池状态”，若线程池异常终止了，则删除任务；\n           //然后通过reject()执行相应的拒绝策略的内容。\n           int recheck = ctl.get();\n           if (! isRunning(recheck) &amp;&amp; remove(command))\n               reject(command);\n           // 否则，如果&quot;线程池中任务数量&quot;为0，则通过addWorker(null, false)尝试新建一个线\n           // 程，新建线程对应的任务为null。防止线程池被关闭\n           else if (workerCountOf(recheck) == 0)\n               addWorker(null, false);\n       }\n      //这里是启动小于maxpoolSize的线程\n      //如果添加任务到队列中不成功，则试图通过addWorker(command, false)新建一个线程，\n      //并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。\n      // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。\n       else if (!addWorker(command, false))\n           reject(command);\n   }\n}\n</code></pre>\n<p><strong>说明</strong>：execute()的作用是将任务添加到线程池中执行。它会分为3种情况进行处理：        </p>\n<p><strong>情况1</strong> – 如果”线程池中任务数量” &lt; “核心池大小”时，即线程池中少于corePoolSize个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。         </p>\n<p><strong>情况2</strong> – 如果”线程池中任务数量” &gt;= “核心池大小”，并且”线程池是允许状态”；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认”线程池的状态”，如果”第2次读到的线程池状态”和”第1次读到的线程池状态”不同，则从阻塞队列中删除该任务。         </p>\n<p><strong>情况3</strong> – 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过reject()拒绝该任务。</p>\n<p>到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：</p>\n<ol>\n<li>首先，要清楚corePoolSize和maximumPoolSize的含义；</li>\n<li>其次，要知道Worker是用来起到什么作用的；</li>\n<li>要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：</li>\n</ol>\n<ul>\n<li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li>\n<li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li>\n<li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li>\n<li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于 corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li>\n</ul>\n<h3 id=\"addWorker\"><a href=\"#addWorker\" class=\"headerlink\" title=\"addWorker\"></a><strong>addWorker</strong></h3><p>源码如下</p>\n<pre><code class=\"java\">private boolean addWorker(Runnable firstTask, boolean core) {\n       retry:\n       // 更新&quot;线程池状态和计数&quot;标记，即更新ctl。\n       for (;;) {\n          // 更新&quot;线程池状态和计数&quot;标记，即更新ctl。\n           int c = ctl.get();\n            // 获取线程池状态。\n           int rs = runStateOf(c);\n\n           // Check if queue empty only if necessary.\n           // 有效性检查\n           if (rs &gt;= SHUTDOWN &amp;&amp;\n               ! (rs == SHUTDOWN &amp;&amp;\n                  firstTask == null &amp;&amp;\n                  ! workQueue.isEmpty()))\n               return false;\n\n           for (;;) {\n              // 获取线程池中任务的数量。\n               int wc = workerCountOf(c);\n               // 如果&quot;线程池中任务的数量&quot;超过限制，则返回false。\n               if (wc &gt;= CAPACITY ||\n                   wc &gt;= (core ? corePoolSize : maximumPoolSize))\n                   return false;\n               // 通过CAS函数将c的值+1。操作失败的话，则退出循环。\n               if (compareAndIncrementWorkerCount(c))\n                   break retry;\n               c = ctl.get();  // Re-read ctl\n               // 检查&quot;线程池状态&quot;，如果与之前的状态不同，则从retry重新开始。\n               if (runStateOf(c) != rs)\n                   continue retry;\n               // else CAS failed due to workerCount change; retry inner loop\n           }\n       }\n\n   boolean workerStarted = false;\n   boolean workerAdded = false;\n   Worker w = null;\n   // 添加任务到线程池，并启动任务所在的线程。\n   try {\n       final ReentrantLock mainLock = this.mainLock;\n       // 新建Worker，并且指定firstTask为Worker的第一个任务。\n       w = new Worker(firstTask);\n       // 获取Worker对应的线程。\n       final Thread t = w.thread;\n       if (t != null) {\n           // 获取锁\n           mainLock.lock();\n           try {\n               int c = ctl.get();\n               int rs = runStateOf(c);\n\n               // 再次确认&quot;线程池状态&quot;\n               if (rs &lt; SHUTDOWN ||\n                   (rs == SHUTDOWN &amp;&amp; firstTask == null)) {\n                   if (t.isAlive()) // precheck that t is startable\n                       throw new IllegalThreadStateException();\n                   // 将Worker对象(w)添加到&quot;线程池的Worker集合(workers)&quot;中\n                   workers.add(w);\n                   // 更新largestPoolSize\n                   int s = workers.size();\n                   if (s &gt; largestPoolSize)\n                       largestPoolSize = s;\n                   workerAdded = true;\n               }\n           } finally {\n               // 释放锁\n               mainLock.unlock();\n           }\n           // 如果&quot;成功将任务添加到线程池&quot;中，则启动任务所在的线程。 \n           if (workerAdded) {\n               t.start();\n               workerStarted = true;\n           }\n       }\n   } finally {\n       if (! workerStarted)\n           addWorkerFailed(w);\n   }\n   // 返回任务是否启动。\n   return workerStarted;\n}\n\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li><p>addWorker(Runnable firstTask, boolean core) 的作用是将任务(firstTask)添加到线程池中，并启动该任务。core为true的话，则以corePoolSize为界限，若”线程池中已有任务数量&gt;=corePoolSize”，则返回false；core为false的话，则以maximumPoolSize为界限，若”线程池中已有任务数量&gt;=maximumPoolSize”，则返回false。</p>\n</li>\n<li><p>addWorker()会先通过for循环不断尝试更新ctl状态，ctl记录了”线程池中任务数量和线程池状态”。更新成功之后，再通过try模块来将任务添加到线程池中，并启动任务所在的线程。</p>\n</li>\n<li><p>从addWorker()中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的Worker对象；而一个Workder对象包含一个Thread对象。</p>\n<p>(01) 通过将Worker对象添加到”线程的workers集合”中，从而实现将任务添加到线程池中。</p>\n<p>(02) 通过启动Worker对应的Thread线程，则执行该任务。</p>\n</li>\n</ol>\n<h3 id=\"addWorkerFailed\"><a href=\"#addWorkerFailed\" class=\"headerlink\" title=\"addWorkerFailed:\"></a>addWorkerFailed:</h3><p>如果Worker创建成功，但是没有启动，这时我们需要将从线程对象从works上移除，否则会影响线程池的性能，源码如下</p>\n<pre><code class=\"java\">   /**\n    * Rolls back the worker thread creation.\n    * - removes worker from workers, if present\n    * - decrements worker count\n    * - rechecks for termination, in case the existence of this\n    *   worker was holding up termination\n    */\n   private void addWorkerFailed(Worker w) {\n\n       final ReentrantLock mainLock = this.mainLock;\n       //获取锁\n       mainLock.lock();\n       try {\n           //从workers上移除线程\n           if (w != null)\n               workers.remove(w);\n           //减少线程的数量\n           decrementWorkerCount();\n           //由于线程数量的减少，可能会使得当前线程池上线程的数量变成0，这时有可能进入\n           //TIDYING状态，所以尝试结束线程池\n           tryTerminate();\n       } finally {\n           mainLock.unlock();\n       }\n   }\n</code></pre>\n<p>这时你们会不会有个疑问，一般我们写程序时，如果想让线程一直运行，则会向下面这样写:</p>\n<pre><code>public void run(){\n   while(true){\n       //doSomething\n   }\n}\n</code></pre><p>但是上面执行流程分析完了，但是没看到ThreadPoolExecutor怎么定义线程一直运行，这时我们就要去分析Worker这个内部类的源码，这里面有我们想要的结果：</p>\n<p>源码如下：</p>\n<pre><code class=\"java\"> private final class Worker\n       extends AbstractQueuedSynchronizer\n       implements Runnable {      \n       private static final long serialVersionUID = 6138294804551838833L;\n          //当前woker正在运行的线程\n       final Thread thread;\n       //初始化这个工作线程时的第一个任务，可能为null\n       Runnable firstTask;\n          //每个线程完成任务的数量\n       volatile long completedTasks;\n\n       Worker(Runnable firstTask) {\n           setState(-1); // inhibit interrupts until runWorker\n           this.firstTask = firstTask;       \n           //使用线程池提供的线程创建工厂来创建线程\n           this.thread = getThreadFactory().newThread(this);\n       }\n       //委派当前线程的run方法到外部类的runWorker上，\n       public void run() {\n           runWorker(this);\n       }\n       // Lock methods\n       //\n       // The value 0 represents the unlocked state.\n       // The value 1 represents the locked state.\n       protected boolean isHeldExclusively() {\n           return getState() != 0;\n       }\n\n       protected boolean tryAcquire(int unused) {\n           if (compareAndSetState(0, 1)) {\n               setExclusiveOwnerThread(Thread.currentThread());\n               return true;\n           }\n           return false;\n       }\n\n       protected boolean tryRelease(int unused) {\n           setExclusiveOwnerThread(null);\n           setState(0);\n           return true;\n       }\n\n       public void lock()        { acquire(1); }\n       public boolean tryLock()  { return tryAcquire(1); }\n       public void unlock()      { release(1); }\n       public boolean isLocked() { return isHeldExclusively(); }\n\n       void interruptIfStarted() {\n           Thread t;\n           if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {\n               try {\n                   t.interrupt();\n               } catch (SecurityException ignore) {\n               }\n           }\n       }\n   }\n</code></pre>\n<p>分析：</p>\n<ol>\n<li>从上面我们可以看出，Worker继承AQS，实现Runnable接口，继承AQS实现了一个简单的互斥锁，是不想在Worker运行的时候使用外部类的互斥锁，这样可以减少线程的等待。</li>\n<li>线程创建时通过外部类的threadFactory来创建的，后面我会讲解这个类，其实很简单</li>\n</ol>\n<p>从上面可以看出Worker类的run方法实现实际上是外部类的runWorker方法实现的，源码如下：</p>\n<pre><code class=\"java\">final void runWorker(Worker w) {\n       //获取当前cpu上运行的线程，其实也就是worker中的thread\n       Thread wt = Thread.currentThread();\n       //获取第一个运行任务，可以为null\n       Runnable task = w.firstTask;\n       w.firstTask = null;\n       //释放锁\n       w.unlock(); // allow interrupts\n       //判断当前线程是否是中断结束 true 不是\n       boolean completedAbruptly = true;\n       try {\n           //当任务不为空，一直运行\n           while (task != null || (task = getTask()) != null) {\n               w.lock();\n               // If pool is stopping, ensure thread is interrupted;\n               // if not, ensure thread is not interrupted.  This\n               // requires a recheck in second case to deal with\n               // shutdownNow race while clearing interrupt\n               if ((runStateAtLeast(ctl.get(), STOP) ||\n                    (Thread.interrupted() &amp;&amp;\n                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;\n                   !wt.isInterrupted())\n                   wt.interrupt();\n               try {\n                   //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n                   //默认什么也不做\n                   beforeExecute(wt, task);\n                   Throwable thrown = null;\n                   try {\n                       //执行任务\n                       task.run();\n                   } catch (RuntimeException x) {\n                       thrown = x; throw x;\n                   } catch (Error x) {\n                       thrown = x; throw x;\n                   } catch (Throwable x) {\n                       thrown = x; throw new Error(x);\n                   } finally {\n                        //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n                        //默认什么也不做\n                       afterExecute(task, thrown);\n                   }\n               } finally {\n                   task = null;\n                   w.completedTasks++;\n                   w.unlock();\n               }\n           }\n           completedAbruptly = false;\n       } finally {\n           //线程死亡，使用此方法执行后续清理工作，\n           processWorkerExit(w, completedAbruptly);\n       }\n   }\n</code></pre>\n<p>从上面代码可以看到这边在循环获取任务，并执行，直到任务全部执行完毕。除了第一个任务，其他任务都是通过<code>getTask()</code>方法去取，这个方法是ThreadPoolExecutor中的一个方法。我们猜一下，整个类中只有任务缓存队列中保存了任务，应该就是去缓存队列中取了。</p>\n<pre><code>Runnable getTask() {\n   for (;;) {\n       try {\n           int state = runState;\n           if (state &gt; SHUTDOWN)\n               return null;\n           Runnable r;\n           if (state == SHUTDOWN)  // Help drain queue\n               r = workQueue.poll(); //取任务\n           else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，\n               //则通过poll取任务，若等待一定的时间取不到任务，则返回null\n               r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);\n           else\n               r = workQueue.take();\n           if (r != null)\n               return r;\n           if (workerCanExit()) {    //如果没取到任务，即r为null，则判断当前的worker是否可以退出\n               if (runState &gt;= SHUTDOWN) // Wake up others\n                   interruptIdleWorkers();   //中断处于空闲状态的worker\n               return null;\n           }\n           // Else retry\n       } catch (InterruptedException ie) {\n           // On interruption, re-check runState\n       }\n   }\n}\n</code></pre><p>这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给 空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程Worker去任务缓存队列里面取任务来执行，因为每一个Worker里面都包含了一个线程thread。</p>\n<p>还需要注意的是，当线程死亡如何处理：</p>\n<p>源码如下：</p>\n<pre><code>   //处理线程结束时的清理工作\n   private void processWorkerExit(Worker w, boolean completedAbruptly) {\n       //如果是中断结束，则线程数量不做调整\n       if (completedAbruptly) \n           decrementWorkerCount();\n\n       final ReentrantLock mainLock = this.mainLock;\n       //获取锁\n       mainLock.lock();\n       try {\n           //将当前worker线程上的完成任务数量记录下来\n           completedTaskCount += w.completedTasks;\n           //移除当前此worker\n           workers.remove(w);\n       } finally {\n           mainLock.unlock();\n       }\n       //尝试关闭线程池\n       tryTerminate();\n       int c = ctl.get();\n       //如果当前线程池状态不是stop，则添加woker线程\n       if (runStateLessThan(c, STOP)) {\n           //如果是异常导致线程的中断，则判断当前线程池中线程的\n           //数量是否大于min，min表示当前线程池最少应该有多少线程\n           //如果少于，则创建一个新的worker线程\n           if (!completedAbruptly) {\n               int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n               if (min == 0 &amp;&amp; ! workQueue.isEmpty())\n                   min = 1;\n               if (workerCountOf(c) &gt;= min)\n                   return; // replacement not needed\n           }\n           addWorker(null, false);\n       }\n   }\n</code></pre><h3 id=\"关闭“线程池”\"><a href=\"#关闭“线程池”\" class=\"headerlink\" title=\"关闭“线程池”\"></a>关闭“线程池”</h3><p>shutdown()的源码如下：</p>\n<pre><code class=\"java\">public void shutdown() {\n   final ReentrantLock mainLock = this.mainLock;\n   // 获取锁\n   mainLock.lock();\n   try {\n       // 检查终止线程池的“线程”是否有权限。\n       checkShutdownAccess();\n       // 设置线程池的状态为关闭状态。\n       advanceRunState(SHUTDOWN);\n       // 中断线程池中空闲的线程。\n       interruptIdleWorkers();\n       // 钩子函数，在ThreadPoolExecutor中没有任何动作。\n       onShutdown(); // hook for ScheduledThreadPoolExecutor\n   } finally {\n       // 释放锁\n       mainLock.unlock();\n   }\n   // 尝试终止线程池\n   tryTerminate();\n}\n</code></pre>\n<p><strong>说明</strong>：shutdown()的作用是关闭线程池。</p>\n<p>shutdownNow()源码如下：</p>\n<pre><code class=\"java\">public List&lt;Runnable&gt; shutdownNow() {\n       List&lt;Runnable&gt; tasks;\n       final ReentrantLock mainLock = this.mainLock;\n       //获取所\n       mainLock.lock();\n       try {\n\n           checkShutdownAccess();\n           //设置线程池状态为stop状态\n           advanceRunState(STOP);\n           //中断所有线程\n           interruptWorkers();\n           //取出队列上还未被执行的任务\n           tasks = drainQueue();\n       } finally {\n           mainLock.unlock();\n       }\n       tryTerminate();\n       //返回队列上的任务\n       return tasks;\n   }\n\n</code></pre>\n</blockquote>\n"},{"abbrlink":40,"title":"spring源码解析之 21 实例化bean","author":"zhangke","date":"2019-01-14T19:35:00.000Z","_content":"# spring源码解析之 21实例化bean\n\n这篇我们关注创建 bean 过程中的第一个步骤：实例化 bean，对应的方法为：`createBeanInstance()`，如下：\n<!-- more -->\n\n```java\n   protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, \n                                            @Nullable Object[] args) {\n        // 解析 bean，将 bean 类名解析为 class 引用\n        Class<?> beanClass = resolveBeanClass(mbd, beanName);\n\n        if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && \n            !mbd.isNonPublicAccessAllowed()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                    \"Bean class isn't public, and non-public access not allowed: \"\n                                            + beanClass.getName());\n        }\n\n        // 如果存在 Supplier 回调，则使用给定的回调方法初始化策略,这个实在spring5中新添加的\n        Supplier<?> instanceSupplier = mbd.getInstanceSupplier();\n        if (instanceSupplier != null) {\n            return obtainFromSupplier(instanceSupplier, beanName);\n        }\n\n        // 如果工厂方法不为空，则使用工厂方法初始化策略\n        if (mbd.getFactoryMethodName() != null)  {\n            return instantiateUsingFactoryMethod(beanName, mbd, args);\n        }\n\n        boolean resolved = false;\n        boolean autowireNecessary = false;\n        if (args == null) {\n            // constructorArgumentLock 构造函数的常用锁\n            synchronized (mbd.constructorArgumentLock) {\n                // 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析\n                // 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制\n                if (mbd.resolvedConstructorOrFactoryMethod != null) {\n                    resolved = true;\n                    autowireNecessary = mbd.constructorArgumentsResolved;\n                }\n            }\n        }\n       // 对于实例的差UN宫颈癌你spring中分成了俩种情况，一种是通用的实例化，另一种是带有参数\n\t\t// 的实例化。带有参数的实例化过程相当复杂，因为存在着不确定性，所以判断对应参数上做了大量\n\t\t// 工作\n\n       \t// 如果已经解析过则使用构造函数方法不需要再次锁定\n        if (resolved) {\n            // 自动注入，调用构造函数自动注入\n            if (autowireNecessary) {\n                return autowireConstructor(beanName, mbd, null, null);\n            }\n            else {\n                // 使用默认构造函数构造\n                return instantiateBean(beanName, mbd);\n            }\n        }\n\n        // 确定解析的构造函数\n        // 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor\n        Constructor<?>[] ctors = \n            determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n        if (ctors != null ||\n              mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR \n               || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n            // 构造函数自动注入\n            return autowireConstructor(beanName, mbd, ctors, args);\n        }\n        // 选择合适的构造函数来进行初始化\n\t\tctors = mbd.getPreferredConstructors();\n\t\tif (ctors != null) {\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, null);\n\t\t}\n        //使用默认构造函数注入\n        return instantiateBean(beanName, mbd);\n    }\n```\n\n实例化 bean 是一个复杂的过程，其主要的逻辑为：\n\n- 如果存在 Supplier 回调，则调用 `obtainFromSupplier()` 进行初始化\n- 如果存在工厂方法，则使用工厂方法进行初始化\n- 首先判断缓存，如果缓存中存在，即已经解析过了，则直接使用已经解析了的，根据 constructorArgumentsResolved 参数来判断是使用构造函数自动注入还是默认构造函数\n- 如果缓存中没有，则需要先确定到底使用哪个构造函数来完成解析工作，因为一个类有多个构造函数，每个构造函数都有不同的构造参数，所以需要根据参数来锁定构造函数并完成初始化，如果存在参数则使用相应的带有参数的构造函数，否则使用默认构造函数。\n\n下面就上面四种情况做分别说明。\n\n## obtainFromSupplier()\n\n```java\nSupplier<?> instanceSupplier = mbd.getInstanceSupplier();\nif (instanceSupplier != null) {\n    return obtainFromSupplier(instanceSupplier, beanName);\n}\n```\n\n首先从 BeanDefinition 中获取 Supplier，如果不为空，则调用 `obtainFromSupplier()` 。那么 Supplier 是什么呢？在这之前也没有提到过这个字段。\n\n```java\npublic interface Supplier<T> {\n    T get();\n}\n```\n\nSupplier 接口仅有一个功能性的 `get()`，该方法会返回一个 T 类型的对象，有点儿类似工厂方法。这个接口有什么作用？用于指定创建 bean 的回调，如果我们设置了这样的回调，那么其他的构造器或者工厂方法都会没有用。在什么设置该参数呢？Spring 提供了相应的 `setter` 方法，如下：\n\n```java\n    public void setInstanceSupplier(@Nullable Supplier<?> instanceSupplier) {\n        this.instanceSupplier = instanceSupplier;\n    }\n```\n\n在构造 BeanDefinition 的时候设置了该值，如下（以 RootBeanDefinition 为例）：\n\n```java\n    public <T> RootBeanDefinition(@Nullable Class<T> beanClass, String scope, \n                                  @Nullable Supplier<T> instanceSupplier) {\n        super();\n        setBeanClass(beanClass);\n        setScope(scope);\n        setInstanceSupplier(instanceSupplier);\n    }\n```\n\n如果设置了 instanceSupplier 则调用 `obtainFromSupplier()` 完成 bean 的初始化，如下：\n\n```java\n    protected BeanWrapper obtainFromSupplier(Supplier<?> instanceSupplier, \n                                             String beanName) {\n        String outerBean = this.currentlyCreatedBean.get();\n        this.currentlyCreatedBean.set(beanName);\n        Object instance;\n        try {\n          // 调用 Supplier 的 get()，返回一个对象\n            instance = instanceSupplier.get();\n        }\n        finally {\n            if (outerBean != null) {\n                this.currentlyCreatedBean.set(outerBean);\n            }\n            else {\n                this.currentlyCreatedBean.remove();\n            }\n        }\n        // 根据对象构造 BeanWrapper 对象\n        BeanWrapper bw = new BeanWrapperImpl(instance);\n        // 初始化 BeanWrapper\n        initBeanWrapper(bw);\n        return bw;\n    }\n```\n\n代码很简单，调用 调用 Supplier 的 `get()` 方法，获得一个 bean 实例对象，然后根据该实例对象构造一个 BeanWrapper 对象 bw，最后初始化该对象。有关于 BeanWrapper 后面专门出文讲解。\n\n## instantiateUsingFactoryMethod()\n\n如果存在工厂方法，则调用 `instantiateUsingFactoryMethod()` 完成 bean 的初始化工作（方法实现比较长，细节比较复杂，各位就硬着头皮看吧）。\n\n```java\n    protected BeanWrapper instantiateUsingFactoryMethod(\n            String beanName, RootBeanDefinition mbd, \n        @Nullable Object[] explicitArgs) {\n        return new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName,\n                                   mbd, explicitArgs);\n    }\n```\n\n构造一个 ConstructorResolver 对象，然后调用其 `instantiateUsingFactoryMethod()` 方法。ConstructorResolver 是构造方法或者工厂类初始化 bean 的委托类。\n\n```java\n      public BeanWrapper instantiateUsingFactoryMethod(\n            final String beanName, final RootBeanDefinition mbd,\n          @Nullable final Object[] explicitArgs) {\n\n        // 构造 BeanWrapperImpl 对象\n        BeanWrapperImpl bw = new BeanWrapperImpl();\n        // 初始化 BeanWrapperImpl\n        // 向BeanWrapper对象中添加 ConversionService 对象和属性编辑器 PropertyEditor 对象\n        this.beanFactory.initBeanWrapper(bw);\n\n        Object factoryBean;\n        Class<?> factoryClass;\n        boolean isStatic;\n\n        // 工厂名不为空\n        String factoryBeanName = mbd.getFactoryBeanName();\n        if (factoryBeanName != null) {\n            if (factoryBeanName.equals(beanName)) {\n   \t\t\t\t// 抛出异常省略\n            }\n            // 获取工厂实例\n            factoryBean = this.beanFactory.getBean(factoryBeanName);\n            if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n                throw new ImplicitlyAppearedSingletonException();\n            }\n            factoryClass = factoryBean.getClass();\n            isStatic = false;\n        }\n        else {\n            // 工厂名为空，则其可能是一个静态工厂\n            // 静态工厂创建bean，必须要提供工厂的全类名\n            if (!mbd.hasBeanClass()) {\n                \t// 省略抛出异常代码\n            }\n            factoryBean = null;\n            factoryClass = mbd.getBeanClass();\n            isStatic = true;\n        }\n\n        // 工厂方法\n        Method factoryMethodToUse = null;\n        ConstructorResolver.ArgumentsHolder argsHolderToUse = null;\n        // 参数\n        Object[] argsToUse = null;\n\n        // 工厂方法的参数\n        // 如果指定了构造参数则直接使用\n        // 在调用 getBean 方法的时候指定了方法参数\n        if (explicitArgs != null) {\n            argsToUse = explicitArgs;\n        }\n        else {\n            // 没有指定，则尝试从配置文件中解析\n            Object[] argsToResolve = null;\n            // 首先尝试从缓存中获取\n            synchronized (mbd.constructorArgumentLock) {\n                // 获取缓存中的构造函数或者工厂方法\n                factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n                if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                    // 获取缓存中的构造参数\n                    argsToUse = mbd.resolvedConstructorArguments;\n                    if (argsToUse == null) {\n                        // 获取缓存中的构造函数参数的包可见字段\n                        argsToResolve = mbd.preparedConstructorArguments;\n                    }\n                }\n            }\n            // 缓存中存在,则解析存储在 BeanDefinition 中的参数\n            // 如给定方法的构造函数 A(int ,int )，\n            // 则通过此方法后就会把配置文件中的(\"1\",\"1\")转换为 (1,1)\n            // 缓存中的值可能是原始值也有可能是最终值\n            if (argsToResolve != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, \n                                  factoryMethodToUse, argsToResolve);\n            }\n        }\n\n        //\n        if (factoryMethodToUse == null || argsToUse == null) {\n            // 获取工厂方法的类全名称\n            factoryClass = ClassUtils.getUserClass(factoryClass);\n\n            // 获取所有待定方法\n            Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n            // 检索所有方法，这里是对方法进行过滤\n            List<Method> candidateSet = new ArrayList<>();\n            for (Method candidate : rawCandidates) {\n                // 如果有static 且为工厂方法，则添加到 candidateSet 中\n                if (Modifier.isStatic(candidate.getModifiers()) == \n                    isStatic && mbd.isFactoryMethod(candidate)) {\n                    candidateSet.add(candidate);\n                }\n            }\n\n            Method[] candidates = candidateSet.toArray(new Method[0]);\n            // 排序构造函数\n            // public 构造函数优先参数数量降序，非public 构造函数参数数量降序\n            AutowireUtils.sortFactoryMethods(candidates);\n\n            // 用于承载解析后的构造函数参数的值\n            ConstructorArgumentValues resolvedValues = null;\n            boolean autowiring = (mbd.getResolvedAutowireMode() == \n                                  RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n            int minTypeDiffWeight = Integer.MAX_VALUE;\n            Set<Method> ambiguousFactoryMethods = null;\n\n            int minNrOfArgs;\n            if (explicitArgs != null) {\n                minNrOfArgs = explicitArgs.length;\n            }\n            else {\n             // getBean() 没有传递参数，则需要解析保存在 BeanDefinition 构造函数中指定的参数\n                if (mbd.hasConstructorArgumentValues()) {\n                    // 构造函数的参数\n                    ConstructorArgumentValues cargs = \n                        mbd.getConstructorArgumentValues();\n                    resolvedValues = new ConstructorArgumentValues();\n                    // 解析构造函数的参数\n                  // 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean\n                    minNrOfArgs = \n                        resolveConstructorArguments(beanName, mbd, bw, cargs,\n                                                    resolvedValues);\n                }\n                else {\n                    minNrOfArgs = 0;\n                }\n            }\n\n            LinkedList<UnsatisfiedDependencyException> causes = null;\n\n            for (Method candidate : candidates) {\n                // 方法体的参数\n                Class<?>[] paramTypes = candidate.getParameterTypes();\n\n                if (paramTypes.length >= minNrOfArgs) {\n                    // 保存参数的对象\n                    ArgumentsHolder argsHolder;\n\n                    // getBean()传递了参数\n                    if (explicitArgs != null){\n                        // 显示给定参数，参数长度必须完全匹配\n                        if (paramTypes.length != explicitArgs.length) {\n                            continue;\n                        }\n                        // 根据参数创建参数持有者\n                        argsHolder = new ArgumentsHolder(explicitArgs);\n                    }\n                    else {\n                        // 为提供参数，解析构造参数\n                        try {\n                            String[] paramNames = null;\n                            // 获取 ParameterNameDiscoverer 对象\n                            // ParameterNameDiscoverer 是用于解析方法和构造函数的参数名称的接口，为参数名称探测器\n                            ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                            if (pnd != null) {\n                                // 获取指定构造函数的参数名称\n                                paramNames = pnd.getParameterNames(candidate);\n                            }\n\n\n                            // 在已经解析的构造函数参数值的情况下，创建一个参数持有者对象\n                            argsHolder = createArgumentArray(\n                                    beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                        }\n                        catch (UnsatisfiedDependencyException ex) {\n                            if (this.beanFactory.logger.isTraceEnabled()) {\n                                this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n                                        \"] of bean '\" + beanName + \"': \" + ex);\n                            }\n                            if (causes == null) {\n                                causes = new LinkedList<>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n\n                    // isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式\n                    // 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常\n                    // 宽松模式：使用具有\"最接近的模式\"进行匹配\n                    // typeDiffWeight：类型差异权重\n                    int typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n                            argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                    // 代表最接近的类型匹配，则选择作为构造函数\n                    if (typeDiffWeight < minTypeDiffWeight) {\n                        factoryMethodToUse = candidate;\n                        argsHolderToUse = argsHolder;\n                        argsToUse = argsHolder.arguments;\n                        minTypeDiffWeight = typeDiffWeight;\n                        ambiguousFactoryMethods = null;\n                    }\n\n                    // 如果具有相同参数数量的方法具有相同的类型差异权重，则收集此类型选项\n                    // 但是，仅在非宽松构造函数解析模式下执行该检查，并显式忽略重写方法（具有相同的参数签名）\n                    else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n                            !mbd.isLenientConstructorResolution() &&\n                            paramTypes.length == factoryMethodToUse.getParameterCount() &&\n                            !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\n                        // 查找到多个可匹配的方法\n                        if (ambiguousFactoryMethods == null) {\n                            ambiguousFactoryMethods = new LinkedHashSet<>();\n                            ambiguousFactoryMethods.add(factoryMethodToUse);\n                        }\n                        ambiguousFactoryMethods.add(candidate);\n                    }\n                }\n            }\n\n            // 没有可执行的工厂方法，抛出异常\n            if (factoryMethodToUse == null) {\n                if (causes != null) {\n                    UnsatisfiedDependencyException ex = causes.removeLast();\n                    for (Exception cause : causes) {\n                        this.beanFactory.onSuppressedException(cause);\n                    }\n                    throw ex;\n                }\n                List<String> argTypes = new ArrayList<>(minNrOfArgs);\n                if (explicitArgs != null) {\n                    for (Object arg : explicitArgs) {\n                        argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                    }\n                }\n                else if (resolvedValues != null){\n                    Set<ConstructorArgumentValues.ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n                    valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                    valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                    for (ConstructorArgumentValues.ValueHolder value : valueHolders) {\n                        String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n                                (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                        argTypes.add(argType);\n                    }\n                }\n                String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"No matching factory method found: \" +\n                                (mbd.getFactoryBeanName() != null ?\n                                        \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n                                \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n                                \"Check that a method with the specified name \" +\n                                (minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n                                \"exists and that it is \" +\n                                (isStatic ? \"static\" : \"non-static\") + \".\");\n            }\n            else if (void.class == factoryMethodToUse.getReturnType()) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Invalid factory method '\" + mbd.getFactoryMethodName() +\n                                \"': needs to have a non-void return type!\");\n            }\n            else if (ambiguousFactoryMethods != null) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n                                \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n                                ambiguousFactoryMethods);\n            }\n\n            if (explicitArgs == null && argsHolderToUse != null) {\n                // 将解析的构造函数加入缓存\n                argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n            }\n        }\n\n        try {\n            // 实例化 bean\n            Object beanInstance;\n\n            if (System.getSecurityManager() != null) {\n                final Object fb = factoryBean;\n                final Method factoryMethod = factoryMethodToUse;\n                final Object[] args = argsToUse;\n                // 通过执行工厂方法来创建bean示例\n                beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->\n                                beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n                        beanFactory.getAccessControlContext());\n            }\n            else {\n                // 通过执行工厂方法来创建bean示例\n                beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n                        mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n            }\n\n            // 包装为 BeanWraper 对象\n            bw.setBeanInstance(beanInstance);\n            return bw;\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                    \"Bean instantiation via factory method failed\", ex);\n        }\n    }\n```\n\n`instantiateUsingFactoryMethod()` 方法体实在是太大了，处理细节感觉很复杂，硬着头皮看完的，中间断断续续的。吐槽这里的代码风格，完全不符合我们前面看的 Spring 代码风格。Spring 的一贯做法是将一个复杂逻辑进行拆分，分为多个细小的模块进行嵌套，每个模块负责一部分功能，模块与模块之间层层嵌套，上一层一般都是对下一层的总结和概括，这样就会使得每一层的逻辑变得清晰易懂。\n\n回归到上面的方法体，虽然代码体量大，但是总体我们还是可看清楚这个方法要做的事情。一句话概括就是：确定工厂对象，然后获取构造函数和构造参数，最后调用 InstantiationStrategy 对象的 `instantiate()` 来创建 bean 实例。下面我们就这个句概括的话进行拆分并详细说明。\n\n**确定工厂对象**\n\n首先获取工厂方法名，若工厂方法名不为空，则调用 `beanFactory.getBean()` 获取工厂对象，若为空，则可能为一个静态工厂，对于静态工厂则必须提供工厂类的全类名，同时设置 `factoryBean = null`\n\n**构造参数确认**\n\n工厂对象确定后，则是确认构造参数。构造参数的确认主要分为三种情况：explicitArgs 参数、缓存中获取、配置文件中解析。\n\n**explicitArgs 参数**\n\nexplicitArgs 参数是我们调用 `getBean()` 时传递景来，一般该参数，该参数就是用于初始化 bean 时所传递的参数，如果该参数不为空，则可以确定构造函数的参数就是它了。\n\n**缓存中获取**\n\n在该方法的最后，我们会发现这样一段代码：`argsHolderToUse.storeCache(mbd, factoryMethodToUse)` ，这段代码主要是将构造函数、构造参数保存到缓存中，如下：\n\n```java\n        public void storeCache(RootBeanDefinition mbd, Executable constructorOrFactoryMethod) {\n            synchronized (mbd.constructorArgumentLock) {\n                mbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;\n                mbd.constructorArgumentsResolved = true;\n                if (this.resolveNecessary) {\n                    mbd.preparedConstructorArguments = this.preparedArguments;\n                }\n                else {\n                    mbd.resolvedConstructorArguments = this.arguments;\n                }\n            }\n        }\n```\n\n其中涉及到的几个参数 constructorArgumentLock、resolvedConstructorOrFactoryMethod、constructorArgumentsResolved、resolvedConstructorArguments。这些参数都是跟构造函数、构造函数缓存有关的。\n\n- constructorArgumentLock：构造函数的缓存锁\n- resolvedConstructorOrFactoryMethod：缓存已经解析的构造函数或者工厂方法\n- constructorArgumentsResolved：标记字段，标记构造函数、参数已经解析了。默认为false\n- resolvedConstructorArguments：缓存已经解析的构造函数参数，包可见字段\n\n所以从缓存中获取就是提取这几个参数的值，如下：\n\n```java\n            synchronized (mbd.constructorArgumentLock) {\n                // 获取缓存中的构造函数或者工厂方法\n                factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n                if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                    // 获取缓存中的构造参数\n                    argsToUse = mbd.resolvedConstructorArguments;\n                    if (argsToUse == null) {\n                        // 获取缓存中的构造函数参数的包可见字段\n                        argsToResolve = mbd.preparedConstructorArguments;\n                    }\n                }\n            }\n```\n\n如果缓存中存在构造参数，则需要调用 `resolvePreparedArguments()` 方法进行转换，因为缓存中的值有可能是最终值也有可能不是最终值，比如我们构造函数中的类型为 Integer 类型的 1 ，但是原始的参数类型有可能是 String 类型的 1 ，所以即便是从缓存中得到了构造参数也需要经过一番的类型转换确保参数类型完全对应。\n\n**配置文件中解析**\n\n即没有通过传递参数的方式传递构造参数，缓存中也没有，那就只能通过解析配置文件获取构造参数了。\n\n在 bean 解析类的博文中我们了解了，配置文件中的信息都会转换到 BeanDefinition 实例对象中，所以配置文件中的参数可以直接通过 BeanDefinition 对象获取。代码如下：\n\n```java\nif (mbd.hasConstructorArgumentValues()) {\n    // 构造函数的参数\n    ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n    resolvedValues = new ConstructorArgumentValues();\n    // 解析构造函数的参数\n    // 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean\n    minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n}\n```\n\n通过 BeanDefinition 的 `getConstructorArgumentValues()` 就可以获取构造信息了，有了构造信息就可以获取相关的参数值信息了，获取的参数信息包括直接值和引用，这一步骤的处理交由 `resolveConstructorArguments()` 完成，该方法会将构造参数信息解析为 resolvedValues 对象 并返回解析到的参数个数。\n\n**构造函数**\n\n确定构造参数后，下一步则是确定构造函数。第一步则是通过 `getCandidateMethods()` 获取所有的构造方法，同时对构造方法进行刷选，然后在对其进行排序处理（`AutowireUtils.sortFactoryMethods(candidates)`），排序的主要目的是为了能够更加方便的找到匹配的构造函数，因为构造函数的确认是根据参数个数确认的。排序的规则是：public 构造函数优先参数数量降序、非 public 构造参数数量降序。\n\n通过迭代 candidates（包含了所有要匹配的构造函数）的方式，一次比较其参数，如果显示提供了参数（explicitArgs != null），则直接比较两者是否相等，如果相等则表示找到了，否则继续比较。如果没有显示提供参数，则需要获取 ParameterNameDiscoverer 对象，该对象为参数名称探测器，主要用于发现方法和构造函数的参数名称。\n\n将参数包装成 ArgumentsHolder 对象，该对象用于保存参数，我们称之为参数持有者。当将对象包装成 ArgumentsHolder 对象后，我们就可以通过它来进行构造函数匹配，匹配分为严格模式和宽松模式。\n\n- 严格模式：解析构造函数时，必须所有参数都需要匹配，否则抛出异常\n- 宽松模式：使用具有”最接近的模式”进行匹配\n\n判断的依据是根据 BeanDefinition 的 isLenientConstructorResolution 属性（该参数是我们在构造 AbstractBeanDefinition 对象是传递的）来获取类型差异权重（typeDiffWeight） 的。如果 `typeDiffWeight < minTypeDiffWeight` ，则代表“最接近的模式”，选择其作为构造函数，否则只有两者具有相同的参数数量且类型差异权重相等才会纳入考虑范围。\n\n至此，构造函数已经确认了。\n\n**创建 bean 实例**\n\n工厂对象、构造函数、构造参数都已经确认了，则最后一步就是调用 InstantiationStrategy 对象的 `instantiate()` 来创建 bean 实例，如下：\n\n```java\npublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n            @Nullable Object factoryBean, final Method factoryMethod, @Nullable Object... args) {\n\n        try {\n            if (System.getSecurityManager() != null) {\n                AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n                    ReflectionUtils.makeAccessible(factoryMethod);\n                    return null;\n                });\n            }\n            else {\n                ReflectionUtils.makeAccessible(factoryMethod);\n            }\n\n            Method priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();\n            try {\n                currentlyInvokedFactoryMethod.set(factoryMethod);\n                // 执行工厂方法，并返回实例\n                Object result = factoryMethod.invoke(factoryBean, args);\n                if (result == null) {\n                    result = new NullBean();\n                }\n                return result;\n            }\n            finally {\n                if (priorInvokedFactoryMethod != null) {\n                    currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);\n                }\n                else {\n                    currentlyInvokedFactoryMethod.remove();\n                }\n            }\n        }\n        // 省略一波 catch\n    }\n```\n\n`instantiate()` 最核心的部分就是利用 Java 反射执行工厂方法并返回创建好的实例，也就是这段代码：\n\n```null\nObject result = factoryMethod.invoke(factoryBean, args);\n```\n\n到这里 `instantiateUsingFactoryMethod()` 已经分析完毕了。\n\n`createBeanInstance()` 还有两个重要方法 `autowireConstructor()` 和 `instantiateBean()` ,由于篇幅问题，所以将这两个方法放在下篇博客分析。敬请期待!!!","source":"_posts/spring 源码分析/spring/spring源码解析之 21实例化bean.md","raw":"abbrlink: 40\ntitle: spring源码解析之 21 实例化bean\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: zhangke\ndate: 2019-01-15 03:35:00\n---\n# spring源码解析之 21实例化bean\n\n这篇我们关注创建 bean 过程中的第一个步骤：实例化 bean，对应的方法为：`createBeanInstance()`，如下：\n<!-- more -->\n\n```java\n   protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, \n                                            @Nullable Object[] args) {\n        // 解析 bean，将 bean 类名解析为 class 引用\n        Class<?> beanClass = resolveBeanClass(mbd, beanName);\n\n        if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && \n            !mbd.isNonPublicAccessAllowed()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                    \"Bean class isn't public, and non-public access not allowed: \"\n                                            + beanClass.getName());\n        }\n\n        // 如果存在 Supplier 回调，则使用给定的回调方法初始化策略,这个实在spring5中新添加的\n        Supplier<?> instanceSupplier = mbd.getInstanceSupplier();\n        if (instanceSupplier != null) {\n            return obtainFromSupplier(instanceSupplier, beanName);\n        }\n\n        // 如果工厂方法不为空，则使用工厂方法初始化策略\n        if (mbd.getFactoryMethodName() != null)  {\n            return instantiateUsingFactoryMethod(beanName, mbd, args);\n        }\n\n        boolean resolved = false;\n        boolean autowireNecessary = false;\n        if (args == null) {\n            // constructorArgumentLock 构造函数的常用锁\n            synchronized (mbd.constructorArgumentLock) {\n                // 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析\n                // 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制\n                if (mbd.resolvedConstructorOrFactoryMethod != null) {\n                    resolved = true;\n                    autowireNecessary = mbd.constructorArgumentsResolved;\n                }\n            }\n        }\n       // 对于实例的差UN宫颈癌你spring中分成了俩种情况，一种是通用的实例化，另一种是带有参数\n\t\t// 的实例化。带有参数的实例化过程相当复杂，因为存在着不确定性，所以判断对应参数上做了大量\n\t\t// 工作\n\n       \t// 如果已经解析过则使用构造函数方法不需要再次锁定\n        if (resolved) {\n            // 自动注入，调用构造函数自动注入\n            if (autowireNecessary) {\n                return autowireConstructor(beanName, mbd, null, null);\n            }\n            else {\n                // 使用默认构造函数构造\n                return instantiateBean(beanName, mbd);\n            }\n        }\n\n        // 确定解析的构造函数\n        // 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor\n        Constructor<?>[] ctors = \n            determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n        if (ctors != null ||\n              mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR \n               || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n            // 构造函数自动注入\n            return autowireConstructor(beanName, mbd, ctors, args);\n        }\n        // 选择合适的构造函数来进行初始化\n\t\tctors = mbd.getPreferredConstructors();\n\t\tif (ctors != null) {\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, null);\n\t\t}\n        //使用默认构造函数注入\n        return instantiateBean(beanName, mbd);\n    }\n```\n\n实例化 bean 是一个复杂的过程，其主要的逻辑为：\n\n- 如果存在 Supplier 回调，则调用 `obtainFromSupplier()` 进行初始化\n- 如果存在工厂方法，则使用工厂方法进行初始化\n- 首先判断缓存，如果缓存中存在，即已经解析过了，则直接使用已经解析了的，根据 constructorArgumentsResolved 参数来判断是使用构造函数自动注入还是默认构造函数\n- 如果缓存中没有，则需要先确定到底使用哪个构造函数来完成解析工作，因为一个类有多个构造函数，每个构造函数都有不同的构造参数，所以需要根据参数来锁定构造函数并完成初始化，如果存在参数则使用相应的带有参数的构造函数，否则使用默认构造函数。\n\n下面就上面四种情况做分别说明。\n\n## obtainFromSupplier()\n\n```java\nSupplier<?> instanceSupplier = mbd.getInstanceSupplier();\nif (instanceSupplier != null) {\n    return obtainFromSupplier(instanceSupplier, beanName);\n}\n```\n\n首先从 BeanDefinition 中获取 Supplier，如果不为空，则调用 `obtainFromSupplier()` 。那么 Supplier 是什么呢？在这之前也没有提到过这个字段。\n\n```java\npublic interface Supplier<T> {\n    T get();\n}\n```\n\nSupplier 接口仅有一个功能性的 `get()`，该方法会返回一个 T 类型的对象，有点儿类似工厂方法。这个接口有什么作用？用于指定创建 bean 的回调，如果我们设置了这样的回调，那么其他的构造器或者工厂方法都会没有用。在什么设置该参数呢？Spring 提供了相应的 `setter` 方法，如下：\n\n```java\n    public void setInstanceSupplier(@Nullable Supplier<?> instanceSupplier) {\n        this.instanceSupplier = instanceSupplier;\n    }\n```\n\n在构造 BeanDefinition 的时候设置了该值，如下（以 RootBeanDefinition 为例）：\n\n```java\n    public <T> RootBeanDefinition(@Nullable Class<T> beanClass, String scope, \n                                  @Nullable Supplier<T> instanceSupplier) {\n        super();\n        setBeanClass(beanClass);\n        setScope(scope);\n        setInstanceSupplier(instanceSupplier);\n    }\n```\n\n如果设置了 instanceSupplier 则调用 `obtainFromSupplier()` 完成 bean 的初始化，如下：\n\n```java\n    protected BeanWrapper obtainFromSupplier(Supplier<?> instanceSupplier, \n                                             String beanName) {\n        String outerBean = this.currentlyCreatedBean.get();\n        this.currentlyCreatedBean.set(beanName);\n        Object instance;\n        try {\n          // 调用 Supplier 的 get()，返回一个对象\n            instance = instanceSupplier.get();\n        }\n        finally {\n            if (outerBean != null) {\n                this.currentlyCreatedBean.set(outerBean);\n            }\n            else {\n                this.currentlyCreatedBean.remove();\n            }\n        }\n        // 根据对象构造 BeanWrapper 对象\n        BeanWrapper bw = new BeanWrapperImpl(instance);\n        // 初始化 BeanWrapper\n        initBeanWrapper(bw);\n        return bw;\n    }\n```\n\n代码很简单，调用 调用 Supplier 的 `get()` 方法，获得一个 bean 实例对象，然后根据该实例对象构造一个 BeanWrapper 对象 bw，最后初始化该对象。有关于 BeanWrapper 后面专门出文讲解。\n\n## instantiateUsingFactoryMethod()\n\n如果存在工厂方法，则调用 `instantiateUsingFactoryMethod()` 完成 bean 的初始化工作（方法实现比较长，细节比较复杂，各位就硬着头皮看吧）。\n\n```java\n    protected BeanWrapper instantiateUsingFactoryMethod(\n            String beanName, RootBeanDefinition mbd, \n        @Nullable Object[] explicitArgs) {\n        return new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName,\n                                   mbd, explicitArgs);\n    }\n```\n\n构造一个 ConstructorResolver 对象，然后调用其 `instantiateUsingFactoryMethod()` 方法。ConstructorResolver 是构造方法或者工厂类初始化 bean 的委托类。\n\n```java\n      public BeanWrapper instantiateUsingFactoryMethod(\n            final String beanName, final RootBeanDefinition mbd,\n          @Nullable final Object[] explicitArgs) {\n\n        // 构造 BeanWrapperImpl 对象\n        BeanWrapperImpl bw = new BeanWrapperImpl();\n        // 初始化 BeanWrapperImpl\n        // 向BeanWrapper对象中添加 ConversionService 对象和属性编辑器 PropertyEditor 对象\n        this.beanFactory.initBeanWrapper(bw);\n\n        Object factoryBean;\n        Class<?> factoryClass;\n        boolean isStatic;\n\n        // 工厂名不为空\n        String factoryBeanName = mbd.getFactoryBeanName();\n        if (factoryBeanName != null) {\n            if (factoryBeanName.equals(beanName)) {\n   \t\t\t\t// 抛出异常省略\n            }\n            // 获取工厂实例\n            factoryBean = this.beanFactory.getBean(factoryBeanName);\n            if (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n                throw new ImplicitlyAppearedSingletonException();\n            }\n            factoryClass = factoryBean.getClass();\n            isStatic = false;\n        }\n        else {\n            // 工厂名为空，则其可能是一个静态工厂\n            // 静态工厂创建bean，必须要提供工厂的全类名\n            if (!mbd.hasBeanClass()) {\n                \t// 省略抛出异常代码\n            }\n            factoryBean = null;\n            factoryClass = mbd.getBeanClass();\n            isStatic = true;\n        }\n\n        // 工厂方法\n        Method factoryMethodToUse = null;\n        ConstructorResolver.ArgumentsHolder argsHolderToUse = null;\n        // 参数\n        Object[] argsToUse = null;\n\n        // 工厂方法的参数\n        // 如果指定了构造参数则直接使用\n        // 在调用 getBean 方法的时候指定了方法参数\n        if (explicitArgs != null) {\n            argsToUse = explicitArgs;\n        }\n        else {\n            // 没有指定，则尝试从配置文件中解析\n            Object[] argsToResolve = null;\n            // 首先尝试从缓存中获取\n            synchronized (mbd.constructorArgumentLock) {\n                // 获取缓存中的构造函数或者工厂方法\n                factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n                if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                    // 获取缓存中的构造参数\n                    argsToUse = mbd.resolvedConstructorArguments;\n                    if (argsToUse == null) {\n                        // 获取缓存中的构造函数参数的包可见字段\n                        argsToResolve = mbd.preparedConstructorArguments;\n                    }\n                }\n            }\n            // 缓存中存在,则解析存储在 BeanDefinition 中的参数\n            // 如给定方法的构造函数 A(int ,int )，\n            // 则通过此方法后就会把配置文件中的(\"1\",\"1\")转换为 (1,1)\n            // 缓存中的值可能是原始值也有可能是最终值\n            if (argsToResolve != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, \n                                  factoryMethodToUse, argsToResolve);\n            }\n        }\n\n        //\n        if (factoryMethodToUse == null || argsToUse == null) {\n            // 获取工厂方法的类全名称\n            factoryClass = ClassUtils.getUserClass(factoryClass);\n\n            // 获取所有待定方法\n            Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n            // 检索所有方法，这里是对方法进行过滤\n            List<Method> candidateSet = new ArrayList<>();\n            for (Method candidate : rawCandidates) {\n                // 如果有static 且为工厂方法，则添加到 candidateSet 中\n                if (Modifier.isStatic(candidate.getModifiers()) == \n                    isStatic && mbd.isFactoryMethod(candidate)) {\n                    candidateSet.add(candidate);\n                }\n            }\n\n            Method[] candidates = candidateSet.toArray(new Method[0]);\n            // 排序构造函数\n            // public 构造函数优先参数数量降序，非public 构造函数参数数量降序\n            AutowireUtils.sortFactoryMethods(candidates);\n\n            // 用于承载解析后的构造函数参数的值\n            ConstructorArgumentValues resolvedValues = null;\n            boolean autowiring = (mbd.getResolvedAutowireMode() == \n                                  RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n            int minTypeDiffWeight = Integer.MAX_VALUE;\n            Set<Method> ambiguousFactoryMethods = null;\n\n            int minNrOfArgs;\n            if (explicitArgs != null) {\n                minNrOfArgs = explicitArgs.length;\n            }\n            else {\n             // getBean() 没有传递参数，则需要解析保存在 BeanDefinition 构造函数中指定的参数\n                if (mbd.hasConstructorArgumentValues()) {\n                    // 构造函数的参数\n                    ConstructorArgumentValues cargs = \n                        mbd.getConstructorArgumentValues();\n                    resolvedValues = new ConstructorArgumentValues();\n                    // 解析构造函数的参数\n                  // 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean\n                    minNrOfArgs = \n                        resolveConstructorArguments(beanName, mbd, bw, cargs,\n                                                    resolvedValues);\n                }\n                else {\n                    minNrOfArgs = 0;\n                }\n            }\n\n            LinkedList<UnsatisfiedDependencyException> causes = null;\n\n            for (Method candidate : candidates) {\n                // 方法体的参数\n                Class<?>[] paramTypes = candidate.getParameterTypes();\n\n                if (paramTypes.length >= minNrOfArgs) {\n                    // 保存参数的对象\n                    ArgumentsHolder argsHolder;\n\n                    // getBean()传递了参数\n                    if (explicitArgs != null){\n                        // 显示给定参数，参数长度必须完全匹配\n                        if (paramTypes.length != explicitArgs.length) {\n                            continue;\n                        }\n                        // 根据参数创建参数持有者\n                        argsHolder = new ArgumentsHolder(explicitArgs);\n                    }\n                    else {\n                        // 为提供参数，解析构造参数\n                        try {\n                            String[] paramNames = null;\n                            // 获取 ParameterNameDiscoverer 对象\n                            // ParameterNameDiscoverer 是用于解析方法和构造函数的参数名称的接口，为参数名称探测器\n                            ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                            if (pnd != null) {\n                                // 获取指定构造函数的参数名称\n                                paramNames = pnd.getParameterNames(candidate);\n                            }\n\n\n                            // 在已经解析的构造函数参数值的情况下，创建一个参数持有者对象\n                            argsHolder = createArgumentArray(\n                                    beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                        }\n                        catch (UnsatisfiedDependencyException ex) {\n                            if (this.beanFactory.logger.isTraceEnabled()) {\n                                this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n                                        \"] of bean '\" + beanName + \"': \" + ex);\n                            }\n                            if (causes == null) {\n                                causes = new LinkedList<>();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n\n                    // isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式\n                    // 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常\n                    // 宽松模式：使用具有\"最接近的模式\"进行匹配\n                    // typeDiffWeight：类型差异权重\n                    int typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n                            argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                    // 代表最接近的类型匹配，则选择作为构造函数\n                    if (typeDiffWeight < minTypeDiffWeight) {\n                        factoryMethodToUse = candidate;\n                        argsHolderToUse = argsHolder;\n                        argsToUse = argsHolder.arguments;\n                        minTypeDiffWeight = typeDiffWeight;\n                        ambiguousFactoryMethods = null;\n                    }\n\n                    // 如果具有相同参数数量的方法具有相同的类型差异权重，则收集此类型选项\n                    // 但是，仅在非宽松构造函数解析模式下执行该检查，并显式忽略重写方法（具有相同的参数签名）\n                    else if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n                            !mbd.isLenientConstructorResolution() &&\n                            paramTypes.length == factoryMethodToUse.getParameterCount() &&\n                            !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\n                        // 查找到多个可匹配的方法\n                        if (ambiguousFactoryMethods == null) {\n                            ambiguousFactoryMethods = new LinkedHashSet<>();\n                            ambiguousFactoryMethods.add(factoryMethodToUse);\n                        }\n                        ambiguousFactoryMethods.add(candidate);\n                    }\n                }\n            }\n\n            // 没有可执行的工厂方法，抛出异常\n            if (factoryMethodToUse == null) {\n                if (causes != null) {\n                    UnsatisfiedDependencyException ex = causes.removeLast();\n                    for (Exception cause : causes) {\n                        this.beanFactory.onSuppressedException(cause);\n                    }\n                    throw ex;\n                }\n                List<String> argTypes = new ArrayList<>(minNrOfArgs);\n                if (explicitArgs != null) {\n                    for (Object arg : explicitArgs) {\n                        argTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n                    }\n                }\n                else if (resolvedValues != null){\n                    Set<ConstructorArgumentValues.ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n                    valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                    valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                    for (ConstructorArgumentValues.ValueHolder value : valueHolders) {\n                        String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n                                (value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                        argTypes.add(argType);\n                    }\n                }\n                String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"No matching factory method found: \" +\n                                (mbd.getFactoryBeanName() != null ?\n                                        \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n                                \"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n                                \"Check that a method with the specified name \" +\n                                (minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n                                \"exists and that it is \" +\n                                (isStatic ? \"static\" : \"non-static\") + \".\");\n            }\n            else if (void.class == factoryMethodToUse.getReturnType()) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Invalid factory method '\" + mbd.getFactoryMethodName() +\n                                \"': needs to have a non-void return type!\");\n            }\n            else if (ambiguousFactoryMethods != null) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n                                \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n                                ambiguousFactoryMethods);\n            }\n\n            if (explicitArgs == null && argsHolderToUse != null) {\n                // 将解析的构造函数加入缓存\n                argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n            }\n        }\n\n        try {\n            // 实例化 bean\n            Object beanInstance;\n\n            if (System.getSecurityManager() != null) {\n                final Object fb = factoryBean;\n                final Method factoryMethod = factoryMethodToUse;\n                final Object[] args = argsToUse;\n                // 通过执行工厂方法来创建bean示例\n                beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->\n                                beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n                        beanFactory.getAccessControlContext());\n            }\n            else {\n                // 通过执行工厂方法来创建bean示例\n                beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n                        mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n            }\n\n            // 包装为 BeanWraper 对象\n            bw.setBeanInstance(beanInstance);\n            return bw;\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                    \"Bean instantiation via factory method failed\", ex);\n        }\n    }\n```\n\n`instantiateUsingFactoryMethod()` 方法体实在是太大了，处理细节感觉很复杂，硬着头皮看完的，中间断断续续的。吐槽这里的代码风格，完全不符合我们前面看的 Spring 代码风格。Spring 的一贯做法是将一个复杂逻辑进行拆分，分为多个细小的模块进行嵌套，每个模块负责一部分功能，模块与模块之间层层嵌套，上一层一般都是对下一层的总结和概括，这样就会使得每一层的逻辑变得清晰易懂。\n\n回归到上面的方法体，虽然代码体量大，但是总体我们还是可看清楚这个方法要做的事情。一句话概括就是：确定工厂对象，然后获取构造函数和构造参数，最后调用 InstantiationStrategy 对象的 `instantiate()` 来创建 bean 实例。下面我们就这个句概括的话进行拆分并详细说明。\n\n**确定工厂对象**\n\n首先获取工厂方法名，若工厂方法名不为空，则调用 `beanFactory.getBean()` 获取工厂对象，若为空，则可能为一个静态工厂，对于静态工厂则必须提供工厂类的全类名，同时设置 `factoryBean = null`\n\n**构造参数确认**\n\n工厂对象确定后，则是确认构造参数。构造参数的确认主要分为三种情况：explicitArgs 参数、缓存中获取、配置文件中解析。\n\n**explicitArgs 参数**\n\nexplicitArgs 参数是我们调用 `getBean()` 时传递景来，一般该参数，该参数就是用于初始化 bean 时所传递的参数，如果该参数不为空，则可以确定构造函数的参数就是它了。\n\n**缓存中获取**\n\n在该方法的最后，我们会发现这样一段代码：`argsHolderToUse.storeCache(mbd, factoryMethodToUse)` ，这段代码主要是将构造函数、构造参数保存到缓存中，如下：\n\n```java\n        public void storeCache(RootBeanDefinition mbd, Executable constructorOrFactoryMethod) {\n            synchronized (mbd.constructorArgumentLock) {\n                mbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;\n                mbd.constructorArgumentsResolved = true;\n                if (this.resolveNecessary) {\n                    mbd.preparedConstructorArguments = this.preparedArguments;\n                }\n                else {\n                    mbd.resolvedConstructorArguments = this.arguments;\n                }\n            }\n        }\n```\n\n其中涉及到的几个参数 constructorArgumentLock、resolvedConstructorOrFactoryMethod、constructorArgumentsResolved、resolvedConstructorArguments。这些参数都是跟构造函数、构造函数缓存有关的。\n\n- constructorArgumentLock：构造函数的缓存锁\n- resolvedConstructorOrFactoryMethod：缓存已经解析的构造函数或者工厂方法\n- constructorArgumentsResolved：标记字段，标记构造函数、参数已经解析了。默认为false\n- resolvedConstructorArguments：缓存已经解析的构造函数参数，包可见字段\n\n所以从缓存中获取就是提取这几个参数的值，如下：\n\n```java\n            synchronized (mbd.constructorArgumentLock) {\n                // 获取缓存中的构造函数或者工厂方法\n                factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n                if (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n                    // 获取缓存中的构造参数\n                    argsToUse = mbd.resolvedConstructorArguments;\n                    if (argsToUse == null) {\n                        // 获取缓存中的构造函数参数的包可见字段\n                        argsToResolve = mbd.preparedConstructorArguments;\n                    }\n                }\n            }\n```\n\n如果缓存中存在构造参数，则需要调用 `resolvePreparedArguments()` 方法进行转换，因为缓存中的值有可能是最终值也有可能不是最终值，比如我们构造函数中的类型为 Integer 类型的 1 ，但是原始的参数类型有可能是 String 类型的 1 ，所以即便是从缓存中得到了构造参数也需要经过一番的类型转换确保参数类型完全对应。\n\n**配置文件中解析**\n\n即没有通过传递参数的方式传递构造参数，缓存中也没有，那就只能通过解析配置文件获取构造参数了。\n\n在 bean 解析类的博文中我们了解了，配置文件中的信息都会转换到 BeanDefinition 实例对象中，所以配置文件中的参数可以直接通过 BeanDefinition 对象获取。代码如下：\n\n```java\nif (mbd.hasConstructorArgumentValues()) {\n    // 构造函数的参数\n    ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n    resolvedValues = new ConstructorArgumentValues();\n    // 解析构造函数的参数\n    // 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean\n    minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n}\n```\n\n通过 BeanDefinition 的 `getConstructorArgumentValues()` 就可以获取构造信息了，有了构造信息就可以获取相关的参数值信息了，获取的参数信息包括直接值和引用，这一步骤的处理交由 `resolveConstructorArguments()` 完成，该方法会将构造参数信息解析为 resolvedValues 对象 并返回解析到的参数个数。\n\n**构造函数**\n\n确定构造参数后，下一步则是确定构造函数。第一步则是通过 `getCandidateMethods()` 获取所有的构造方法，同时对构造方法进行刷选，然后在对其进行排序处理（`AutowireUtils.sortFactoryMethods(candidates)`），排序的主要目的是为了能够更加方便的找到匹配的构造函数，因为构造函数的确认是根据参数个数确认的。排序的规则是：public 构造函数优先参数数量降序、非 public 构造参数数量降序。\n\n通过迭代 candidates（包含了所有要匹配的构造函数）的方式，一次比较其参数，如果显示提供了参数（explicitArgs != null），则直接比较两者是否相等，如果相等则表示找到了，否则继续比较。如果没有显示提供参数，则需要获取 ParameterNameDiscoverer 对象，该对象为参数名称探测器，主要用于发现方法和构造函数的参数名称。\n\n将参数包装成 ArgumentsHolder 对象，该对象用于保存参数，我们称之为参数持有者。当将对象包装成 ArgumentsHolder 对象后，我们就可以通过它来进行构造函数匹配，匹配分为严格模式和宽松模式。\n\n- 严格模式：解析构造函数时，必须所有参数都需要匹配，否则抛出异常\n- 宽松模式：使用具有”最接近的模式”进行匹配\n\n判断的依据是根据 BeanDefinition 的 isLenientConstructorResolution 属性（该参数是我们在构造 AbstractBeanDefinition 对象是传递的）来获取类型差异权重（typeDiffWeight） 的。如果 `typeDiffWeight < minTypeDiffWeight` ，则代表“最接近的模式”，选择其作为构造函数，否则只有两者具有相同的参数数量且类型差异权重相等才会纳入考虑范围。\n\n至此，构造函数已经确认了。\n\n**创建 bean 实例**\n\n工厂对象、构造函数、构造参数都已经确认了，则最后一步就是调用 InstantiationStrategy 对象的 `instantiate()` 来创建 bean 实例，如下：\n\n```java\npublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n            @Nullable Object factoryBean, final Method factoryMethod, @Nullable Object... args) {\n\n        try {\n            if (System.getSecurityManager() != null) {\n                AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n                    ReflectionUtils.makeAccessible(factoryMethod);\n                    return null;\n                });\n            }\n            else {\n                ReflectionUtils.makeAccessible(factoryMethod);\n            }\n\n            Method priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();\n            try {\n                currentlyInvokedFactoryMethod.set(factoryMethod);\n                // 执行工厂方法，并返回实例\n                Object result = factoryMethod.invoke(factoryBean, args);\n                if (result == null) {\n                    result = new NullBean();\n                }\n                return result;\n            }\n            finally {\n                if (priorInvokedFactoryMethod != null) {\n                    currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);\n                }\n                else {\n                    currentlyInvokedFactoryMethod.remove();\n                }\n            }\n        }\n        // 省略一波 catch\n    }\n```\n\n`instantiate()` 最核心的部分就是利用 Java 反射执行工厂方法并返回创建好的实例，也就是这段代码：\n\n```null\nObject result = factoryMethod.invoke(factoryBean, args);\n```\n\n到这里 `instantiateUsingFactoryMethod()` 已经分析完毕了。\n\n`createBeanInstance()` 还有两个重要方法 `autowireConstructor()` 和 `instantiateBean()` ,由于篇幅问题，所以将这两个方法放在下篇博客分析。敬请期待!!!","slug":"spring 源码分析/spring/spring源码解析之 21实例化bean","published":1,"updated":"2019-01-16T08:35:44.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovxn005z9q1ududtzvuw","content":"<h1 id=\"spring源码解析之-21实例化bean\"><a href=\"#spring源码解析之-21实例化bean\" class=\"headerlink\" title=\"spring源码解析之 21实例化bean\"></a>spring源码解析之 21实例化bean</h1><p>这篇我们关注创建 bean 过程中的第一个步骤：实例化 bean，对应的方法为：<code>createBeanInstance()</code>，如下：<br><a id=\"more\"></a></p>\n<pre><code class=\"java\">   protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, \n                                            @Nullable Object[] args) {\n        // 解析 bean，将 bean 类名解析为 class 引用\n        Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);\n\n        if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; \n            !mbd.isNonPublicAccessAllowed()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                    &quot;Bean class isn&#39;t public, and non-public access not allowed: &quot;\n                                            + beanClass.getName());\n        }\n\n        // 如果存在 Supplier 回调，则使用给定的回调方法初始化策略,这个实在spring5中新添加的\n        Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();\n        if (instanceSupplier != null) {\n            return obtainFromSupplier(instanceSupplier, beanName);\n        }\n\n        // 如果工厂方法不为空，则使用工厂方法初始化策略\n        if (mbd.getFactoryMethodName() != null)  {\n            return instantiateUsingFactoryMethod(beanName, mbd, args);\n        }\n\n        boolean resolved = false;\n        boolean autowireNecessary = false;\n        if (args == null) {\n            // constructorArgumentLock 构造函数的常用锁\n            synchronized (mbd.constructorArgumentLock) {\n                // 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析\n                // 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制\n                if (mbd.resolvedConstructorOrFactoryMethod != null) {\n                    resolved = true;\n                    autowireNecessary = mbd.constructorArgumentsResolved;\n                }\n            }\n        }\n       // 对于实例的差UN宫颈癌你spring中分成了俩种情况，一种是通用的实例化，另一种是带有参数\n        // 的实例化。带有参数的实例化过程相当复杂，因为存在着不确定性，所以判断对应参数上做了大量\n        // 工作\n\n           // 如果已经解析过则使用构造函数方法不需要再次锁定\n        if (resolved) {\n            // 自动注入，调用构造函数自动注入\n            if (autowireNecessary) {\n                return autowireConstructor(beanName, mbd, null, null);\n            }\n            else {\n                // 使用默认构造函数构造\n                return instantiateBean(beanName, mbd);\n            }\n        }\n\n        // 确定解析的构造函数\n        // 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor\n        Constructor&lt;?&gt;[] ctors = \n            determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n        if (ctors != null ||\n              mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR \n               || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n            // 构造函数自动注入\n            return autowireConstructor(beanName, mbd, ctors, args);\n        }\n        // 选择合适的构造函数来进行初始化\n        ctors = mbd.getPreferredConstructors();\n        if (ctors != null) {\n            return autowireConstructor(beanName, mbd, ctors, null);\n        }\n        //使用默认构造函数注入\n        return instantiateBean(beanName, mbd);\n    }\n</code></pre>\n<p>实例化 bean 是一个复杂的过程，其主要的逻辑为：</p>\n<ul>\n<li>如果存在 Supplier 回调，则调用 <code>obtainFromSupplier()</code> 进行初始化</li>\n<li>如果存在工厂方法，则使用工厂方法进行初始化</li>\n<li>首先判断缓存，如果缓存中存在，即已经解析过了，则直接使用已经解析了的，根据 constructorArgumentsResolved 参数来判断是使用构造函数自动注入还是默认构造函数</li>\n<li>如果缓存中没有，则需要先确定到底使用哪个构造函数来完成解析工作，因为一个类有多个构造函数，每个构造函数都有不同的构造参数，所以需要根据参数来锁定构造函数并完成初始化，如果存在参数则使用相应的带有参数的构造函数，否则使用默认构造函数。</li>\n</ul>\n<p>下面就上面四种情况做分别说明。</p>\n<h2 id=\"obtainFromSupplier\"><a href=\"#obtainFromSupplier\" class=\"headerlink\" title=\"obtainFromSupplier()\"></a>obtainFromSupplier()</h2><pre><code class=\"java\">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();\nif (instanceSupplier != null) {\n    return obtainFromSupplier(instanceSupplier, beanName);\n}\n</code></pre>\n<p>首先从 BeanDefinition 中获取 Supplier，如果不为空，则调用 <code>obtainFromSupplier()</code> 。那么 Supplier 是什么呢？在这之前也没有提到过这个字段。</p>\n<pre><code class=\"java\">public interface Supplier&lt;T&gt; {\n    T get();\n}\n</code></pre>\n<p>Supplier 接口仅有一个功能性的 <code>get()</code>，该方法会返回一个 T 类型的对象，有点儿类似工厂方法。这个接口有什么作用？用于指定创建 bean 的回调，如果我们设置了这样的回调，那么其他的构造器或者工厂方法都会没有用。在什么设置该参数呢？Spring 提供了相应的 <code>setter</code> 方法，如下：</p>\n<pre><code class=\"java\">    public void setInstanceSupplier(@Nullable Supplier&lt;?&gt; instanceSupplier) {\n        this.instanceSupplier = instanceSupplier;\n    }\n</code></pre>\n<p>在构造 BeanDefinition 的时候设置了该值，如下（以 RootBeanDefinition 为例）：</p>\n<pre><code class=\"java\">    public &lt;T&gt; RootBeanDefinition(@Nullable Class&lt;T&gt; beanClass, String scope, \n                                  @Nullable Supplier&lt;T&gt; instanceSupplier) {\n        super();\n        setBeanClass(beanClass);\n        setScope(scope);\n        setInstanceSupplier(instanceSupplier);\n    }\n</code></pre>\n<p>如果设置了 instanceSupplier 则调用 <code>obtainFromSupplier()</code> 完成 bean 的初始化，如下：</p>\n<pre><code class=\"java\">    protected BeanWrapper obtainFromSupplier(Supplier&lt;?&gt; instanceSupplier, \n                                             String beanName) {\n        String outerBean = this.currentlyCreatedBean.get();\n        this.currentlyCreatedBean.set(beanName);\n        Object instance;\n        try {\n          // 调用 Supplier 的 get()，返回一个对象\n            instance = instanceSupplier.get();\n        }\n        finally {\n            if (outerBean != null) {\n                this.currentlyCreatedBean.set(outerBean);\n            }\n            else {\n                this.currentlyCreatedBean.remove();\n            }\n        }\n        // 根据对象构造 BeanWrapper 对象\n        BeanWrapper bw = new BeanWrapperImpl(instance);\n        // 初始化 BeanWrapper\n        initBeanWrapper(bw);\n        return bw;\n    }\n</code></pre>\n<p>代码很简单，调用 调用 Supplier 的 <code>get()</code> 方法，获得一个 bean 实例对象，然后根据该实例对象构造一个 BeanWrapper 对象 bw，最后初始化该对象。有关于 BeanWrapper 后面专门出文讲解。</p>\n<h2 id=\"instantiateUsingFactoryMethod\"><a href=\"#instantiateUsingFactoryMethod\" class=\"headerlink\" title=\"instantiateUsingFactoryMethod()\"></a>instantiateUsingFactoryMethod()</h2><p>如果存在工厂方法，则调用 <code>instantiateUsingFactoryMethod()</code> 完成 bean 的初始化工作（方法实现比较长，细节比较复杂，各位就硬着头皮看吧）。</p>\n<pre><code class=\"java\">    protected BeanWrapper instantiateUsingFactoryMethod(\n            String beanName, RootBeanDefinition mbd, \n        @Nullable Object[] explicitArgs) {\n        return new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName,\n                                   mbd, explicitArgs);\n    }\n</code></pre>\n<p>构造一个 ConstructorResolver 对象，然后调用其 <code>instantiateUsingFactoryMethod()</code> 方法。ConstructorResolver 是构造方法或者工厂类初始化 bean 的委托类。</p>\n<pre><code class=\"java\">      public BeanWrapper instantiateUsingFactoryMethod(\n            final String beanName, final RootBeanDefinition mbd,\n          @Nullable final Object[] explicitArgs) {\n\n        // 构造 BeanWrapperImpl 对象\n        BeanWrapperImpl bw = new BeanWrapperImpl();\n        // 初始化 BeanWrapperImpl\n        // 向BeanWrapper对象中添加 ConversionService 对象和属性编辑器 PropertyEditor 对象\n        this.beanFactory.initBeanWrapper(bw);\n\n        Object factoryBean;\n        Class&lt;?&gt; factoryClass;\n        boolean isStatic;\n\n        // 工厂名不为空\n        String factoryBeanName = mbd.getFactoryBeanName();\n        if (factoryBeanName != null) {\n            if (factoryBeanName.equals(beanName)) {\n                   // 抛出异常省略\n            }\n            // 获取工厂实例\n            factoryBean = this.beanFactory.getBean(factoryBeanName);\n            if (mbd.isSingleton() &amp;&amp; this.beanFactory.containsSingleton(beanName)) {\n                throw new ImplicitlyAppearedSingletonException();\n            }\n            factoryClass = factoryBean.getClass();\n            isStatic = false;\n        }\n        else {\n            // 工厂名为空，则其可能是一个静态工厂\n            // 静态工厂创建bean，必须要提供工厂的全类名\n            if (!mbd.hasBeanClass()) {\n                    // 省略抛出异常代码\n            }\n            factoryBean = null;\n            factoryClass = mbd.getBeanClass();\n            isStatic = true;\n        }\n\n        // 工厂方法\n        Method factoryMethodToUse = null;\n        ConstructorResolver.ArgumentsHolder argsHolderToUse = null;\n        // 参数\n        Object[] argsToUse = null;\n\n        // 工厂方法的参数\n        // 如果指定了构造参数则直接使用\n        // 在调用 getBean 方法的时候指定了方法参数\n        if (explicitArgs != null) {\n            argsToUse = explicitArgs;\n        }\n        else {\n            // 没有指定，则尝试从配置文件中解析\n            Object[] argsToResolve = null;\n            // 首先尝试从缓存中获取\n            synchronized (mbd.constructorArgumentLock) {\n                // 获取缓存中的构造函数或者工厂方法\n                factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n                if (factoryMethodToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {\n                    // 获取缓存中的构造参数\n                    argsToUse = mbd.resolvedConstructorArguments;\n                    if (argsToUse == null) {\n                        // 获取缓存中的构造函数参数的包可见字段\n                        argsToResolve = mbd.preparedConstructorArguments;\n                    }\n                }\n            }\n            // 缓存中存在,则解析存储在 BeanDefinition 中的参数\n            // 如给定方法的构造函数 A(int ,int )，\n            // 则通过此方法后就会把配置文件中的(&quot;1&quot;,&quot;1&quot;)转换为 (1,1)\n            // 缓存中的值可能是原始值也有可能是最终值\n            if (argsToResolve != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, \n                                  factoryMethodToUse, argsToResolve);\n            }\n        }\n\n        //\n        if (factoryMethodToUse == null || argsToUse == null) {\n            // 获取工厂方法的类全名称\n            factoryClass = ClassUtils.getUserClass(factoryClass);\n\n            // 获取所有待定方法\n            Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n            // 检索所有方法，这里是对方法进行过滤\n            List&lt;Method&gt; candidateSet = new ArrayList&lt;&gt;();\n            for (Method candidate : rawCandidates) {\n                // 如果有static 且为工厂方法，则添加到 candidateSet 中\n                if (Modifier.isStatic(candidate.getModifiers()) == \n                    isStatic &amp;&amp; mbd.isFactoryMethod(candidate)) {\n                    candidateSet.add(candidate);\n                }\n            }\n\n            Method[] candidates = candidateSet.toArray(new Method[0]);\n            // 排序构造函数\n            // public 构造函数优先参数数量降序，非public 构造函数参数数量降序\n            AutowireUtils.sortFactoryMethods(candidates);\n\n            // 用于承载解析后的构造函数参数的值\n            ConstructorArgumentValues resolvedValues = null;\n            boolean autowiring = (mbd.getResolvedAutowireMode() == \n                                  RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n            int minTypeDiffWeight = Integer.MAX_VALUE;\n            Set&lt;Method&gt; ambiguousFactoryMethods = null;\n\n            int minNrOfArgs;\n            if (explicitArgs != null) {\n                minNrOfArgs = explicitArgs.length;\n            }\n            else {\n             // getBean() 没有传递参数，则需要解析保存在 BeanDefinition 构造函数中指定的参数\n                if (mbd.hasConstructorArgumentValues()) {\n                    // 构造函数的参数\n                    ConstructorArgumentValues cargs = \n                        mbd.getConstructorArgumentValues();\n                    resolvedValues = new ConstructorArgumentValues();\n                    // 解析构造函数的参数\n                  // 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean\n                    minNrOfArgs = \n                        resolveConstructorArguments(beanName, mbd, bw, cargs,\n                                                    resolvedValues);\n                }\n                else {\n                    minNrOfArgs = 0;\n                }\n            }\n\n            LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null;\n\n            for (Method candidate : candidates) {\n                // 方法体的参数\n                Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();\n\n                if (paramTypes.length &gt;= minNrOfArgs) {\n                    // 保存参数的对象\n                    ArgumentsHolder argsHolder;\n\n                    // getBean()传递了参数\n                    if (explicitArgs != null){\n                        // 显示给定参数，参数长度必须完全匹配\n                        if (paramTypes.length != explicitArgs.length) {\n                            continue;\n                        }\n                        // 根据参数创建参数持有者\n                        argsHolder = new ArgumentsHolder(explicitArgs);\n                    }\n                    else {\n                        // 为提供参数，解析构造参数\n                        try {\n                            String[] paramNames = null;\n                            // 获取 ParameterNameDiscoverer 对象\n                            // ParameterNameDiscoverer 是用于解析方法和构造函数的参数名称的接口，为参数名称探测器\n                            ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                            if (pnd != null) {\n                                // 获取指定构造函数的参数名称\n                                paramNames = pnd.getParameterNames(candidate);\n                            }\n\n\n                            // 在已经解析的构造函数参数值的情况下，创建一个参数持有者对象\n                            argsHolder = createArgumentArray(\n                                    beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                        }\n                        catch (UnsatisfiedDependencyException ex) {\n                            if (this.beanFactory.logger.isTraceEnabled()) {\n                                this.beanFactory.logger.trace(&quot;Ignoring factory method [&quot; + candidate +\n                                        &quot;] of bean &#39;&quot; + beanName + &quot;&#39;: &quot; + ex);\n                            }\n                            if (causes == null) {\n                                causes = new LinkedList&lt;&gt;();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n\n                    // isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式\n                    // 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常\n                    // 宽松模式：使用具有&quot;最接近的模式&quot;进行匹配\n                    // typeDiffWeight：类型差异权重\n                    int typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n                            argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                    // 代表最接近的类型匹配，则选择作为构造函数\n                    if (typeDiffWeight &lt; minTypeDiffWeight) {\n                        factoryMethodToUse = candidate;\n                        argsHolderToUse = argsHolder;\n                        argsToUse = argsHolder.arguments;\n                        minTypeDiffWeight = typeDiffWeight;\n                        ambiguousFactoryMethods = null;\n                    }\n\n                    // 如果具有相同参数数量的方法具有相同的类型差异权重，则收集此类型选项\n                    // 但是，仅在非宽松构造函数解析模式下执行该检查，并显式忽略重写方法（具有相同的参数签名）\n                    else if (factoryMethodToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp;\n                            !mbd.isLenientConstructorResolution() &amp;&amp;\n                            paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp;\n                            !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\n                        // 查找到多个可匹配的方法\n                        if (ambiguousFactoryMethods == null) {\n                            ambiguousFactoryMethods = new LinkedHashSet&lt;&gt;();\n                            ambiguousFactoryMethods.add(factoryMethodToUse);\n                        }\n                        ambiguousFactoryMethods.add(candidate);\n                    }\n                }\n            }\n\n            // 没有可执行的工厂方法，抛出异常\n            if (factoryMethodToUse == null) {\n                if (causes != null) {\n                    UnsatisfiedDependencyException ex = causes.removeLast();\n                    for (Exception cause : causes) {\n                        this.beanFactory.onSuppressedException(cause);\n                    }\n                    throw ex;\n                }\n                List&lt;String&gt; argTypes = new ArrayList&lt;&gt;(minNrOfArgs);\n                if (explicitArgs != null) {\n                    for (Object arg : explicitArgs) {\n                        argTypes.add(arg != null ? arg.getClass().getSimpleName() : &quot;null&quot;);\n                    }\n                }\n                else if (resolvedValues != null){\n                    Set&lt;ConstructorArgumentValues.ValueHolder&gt; valueHolders = new LinkedHashSet&lt;&gt;(resolvedValues.getArgumentCount());\n                    valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                    valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                    for (ConstructorArgumentValues.ValueHolder value : valueHolders) {\n                        String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n                                (value.getValue() != null ? value.getValue().getClass().getSimpleName() : &quot;null&quot;));\n                        argTypes.add(argType);\n                    }\n                }\n                String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        &quot;No matching factory method found: &quot; +\n                                (mbd.getFactoryBeanName() != null ?\n                                        &quot;factory bean &#39;&quot; + mbd.getFactoryBeanName() + &quot;&#39;; &quot; : &quot;&quot;) +\n                                &quot;factory method &#39;&quot; + mbd.getFactoryMethodName() + &quot;(&quot; + argDesc + &quot;)&#39;. &quot; +\n                                &quot;Check that a method with the specified name &quot; +\n                                (minNrOfArgs &gt; 0 ? &quot;and arguments &quot; : &quot;&quot;) +\n                                &quot;exists and that it is &quot; +\n                                (isStatic ? &quot;static&quot; : &quot;non-static&quot;) + &quot;.&quot;);\n            }\n            else if (void.class == factoryMethodToUse.getReturnType()) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        &quot;Invalid factory method &#39;&quot; + mbd.getFactoryMethodName() +\n                                &quot;&#39;: needs to have a non-void return type!&quot;);\n            }\n            else if (ambiguousFactoryMethods != null) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        &quot;Ambiguous factory method matches found in bean &#39;&quot; + beanName + &quot;&#39; &quot; +\n                                &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot; +\n                                ambiguousFactoryMethods);\n            }\n\n            if (explicitArgs == null &amp;&amp; argsHolderToUse != null) {\n                // 将解析的构造函数加入缓存\n                argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n            }\n        }\n\n        try {\n            // 实例化 bean\n            Object beanInstance;\n\n            if (System.getSecurityManager() != null) {\n                final Object fb = factoryBean;\n                final Method factoryMethod = factoryMethodToUse;\n                final Object[] args = argsToUse;\n                // 通过执行工厂方法来创建bean示例\n                beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;\n                                beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n                        beanFactory.getAccessControlContext());\n            }\n            else {\n                // 通过执行工厂方法来创建bean示例\n                beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n                        mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n            }\n\n            // 包装为 BeanWraper 对象\n            bw.setBeanInstance(beanInstance);\n            return bw;\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                    &quot;Bean instantiation via factory method failed&quot;, ex);\n        }\n    }\n</code></pre>\n<p><code>instantiateUsingFactoryMethod()</code> 方法体实在是太大了，处理细节感觉很复杂，硬着头皮看完的，中间断断续续的。吐槽这里的代码风格，完全不符合我们前面看的 Spring 代码风格。Spring 的一贯做法是将一个复杂逻辑进行拆分，分为多个细小的模块进行嵌套，每个模块负责一部分功能，模块与模块之间层层嵌套，上一层一般都是对下一层的总结和概括，这样就会使得每一层的逻辑变得清晰易懂。</p>\n<p>回归到上面的方法体，虽然代码体量大，但是总体我们还是可看清楚这个方法要做的事情。一句话概括就是：确定工厂对象，然后获取构造函数和构造参数，最后调用 InstantiationStrategy 对象的 <code>instantiate()</code> 来创建 bean 实例。下面我们就这个句概括的话进行拆分并详细说明。</p>\n<p><strong>确定工厂对象</strong></p>\n<p>首先获取工厂方法名，若工厂方法名不为空，则调用 <code>beanFactory.getBean()</code> 获取工厂对象，若为空，则可能为一个静态工厂，对于静态工厂则必须提供工厂类的全类名，同时设置 <code>factoryBean = null</code></p>\n<p><strong>构造参数确认</strong></p>\n<p>工厂对象确定后，则是确认构造参数。构造参数的确认主要分为三种情况：explicitArgs 参数、缓存中获取、配置文件中解析。</p>\n<p><strong>explicitArgs 参数</strong></p>\n<p>explicitArgs 参数是我们调用 <code>getBean()</code> 时传递景来，一般该参数，该参数就是用于初始化 bean 时所传递的参数，如果该参数不为空，则可以确定构造函数的参数就是它了。</p>\n<p><strong>缓存中获取</strong></p>\n<p>在该方法的最后，我们会发现这样一段代码：<code>argsHolderToUse.storeCache(mbd, factoryMethodToUse)</code> ，这段代码主要是将构造函数、构造参数保存到缓存中，如下：</p>\n<pre><code class=\"java\">        public void storeCache(RootBeanDefinition mbd, Executable constructorOrFactoryMethod) {\n            synchronized (mbd.constructorArgumentLock) {\n                mbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;\n                mbd.constructorArgumentsResolved = true;\n                if (this.resolveNecessary) {\n                    mbd.preparedConstructorArguments = this.preparedArguments;\n                }\n                else {\n                    mbd.resolvedConstructorArguments = this.arguments;\n                }\n            }\n        }\n</code></pre>\n<p>其中涉及到的几个参数 constructorArgumentLock、resolvedConstructorOrFactoryMethod、constructorArgumentsResolved、resolvedConstructorArguments。这些参数都是跟构造函数、构造函数缓存有关的。</p>\n<ul>\n<li>constructorArgumentLock：构造函数的缓存锁</li>\n<li>resolvedConstructorOrFactoryMethod：缓存已经解析的构造函数或者工厂方法</li>\n<li>constructorArgumentsResolved：标记字段，标记构造函数、参数已经解析了。默认为false</li>\n<li>resolvedConstructorArguments：缓存已经解析的构造函数参数，包可见字段</li>\n</ul>\n<p>所以从缓存中获取就是提取这几个参数的值，如下：</p>\n<pre><code class=\"java\">            synchronized (mbd.constructorArgumentLock) {\n                // 获取缓存中的构造函数或者工厂方法\n                factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n                if (factoryMethodToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {\n                    // 获取缓存中的构造参数\n                    argsToUse = mbd.resolvedConstructorArguments;\n                    if (argsToUse == null) {\n                        // 获取缓存中的构造函数参数的包可见字段\n                        argsToResolve = mbd.preparedConstructorArguments;\n                    }\n                }\n            }\n</code></pre>\n<p>如果缓存中存在构造参数，则需要调用 <code>resolvePreparedArguments()</code> 方法进行转换，因为缓存中的值有可能是最终值也有可能不是最终值，比如我们构造函数中的类型为 Integer 类型的 1 ，但是原始的参数类型有可能是 String 类型的 1 ，所以即便是从缓存中得到了构造参数也需要经过一番的类型转换确保参数类型完全对应。</p>\n<p><strong>配置文件中解析</strong></p>\n<p>即没有通过传递参数的方式传递构造参数，缓存中也没有，那就只能通过解析配置文件获取构造参数了。</p>\n<p>在 bean 解析类的博文中我们了解了，配置文件中的信息都会转换到 BeanDefinition 实例对象中，所以配置文件中的参数可以直接通过 BeanDefinition 对象获取。代码如下：</p>\n<pre><code class=\"java\">if (mbd.hasConstructorArgumentValues()) {\n    // 构造函数的参数\n    ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n    resolvedValues = new ConstructorArgumentValues();\n    // 解析构造函数的参数\n    // 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean\n    minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n}\n</code></pre>\n<p>通过 BeanDefinition 的 <code>getConstructorArgumentValues()</code> 就可以获取构造信息了，有了构造信息就可以获取相关的参数值信息了，获取的参数信息包括直接值和引用，这一步骤的处理交由 <code>resolveConstructorArguments()</code> 完成，该方法会将构造参数信息解析为 resolvedValues 对象 并返回解析到的参数个数。</p>\n<p><strong>构造函数</strong></p>\n<p>确定构造参数后，下一步则是确定构造函数。第一步则是通过 <code>getCandidateMethods()</code> 获取所有的构造方法，同时对构造方法进行刷选，然后在对其进行排序处理（<code>AutowireUtils.sortFactoryMethods(candidates)</code>），排序的主要目的是为了能够更加方便的找到匹配的构造函数，因为构造函数的确认是根据参数个数确认的。排序的规则是：public 构造函数优先参数数量降序、非 public 构造参数数量降序。</p>\n<p>通过迭代 candidates（包含了所有要匹配的构造函数）的方式，一次比较其参数，如果显示提供了参数（explicitArgs != null），则直接比较两者是否相等，如果相等则表示找到了，否则继续比较。如果没有显示提供参数，则需要获取 ParameterNameDiscoverer 对象，该对象为参数名称探测器，主要用于发现方法和构造函数的参数名称。</p>\n<p>将参数包装成 ArgumentsHolder 对象，该对象用于保存参数，我们称之为参数持有者。当将对象包装成 ArgumentsHolder 对象后，我们就可以通过它来进行构造函数匹配，匹配分为严格模式和宽松模式。</p>\n<ul>\n<li>严格模式：解析构造函数时，必须所有参数都需要匹配，否则抛出异常</li>\n<li>宽松模式：使用具有”最接近的模式”进行匹配</li>\n</ul>\n<p>判断的依据是根据 BeanDefinition 的 isLenientConstructorResolution 属性（该参数是我们在构造 AbstractBeanDefinition 对象是传递的）来获取类型差异权重（typeDiffWeight） 的。如果 <code>typeDiffWeight &lt; minTypeDiffWeight</code> ，则代表“最接近的模式”，选择其作为构造函数，否则只有两者具有相同的参数数量且类型差异权重相等才会纳入考虑范围。</p>\n<p>至此，构造函数已经确认了。</p>\n<p><strong>创建 bean 实例</strong></p>\n<p>工厂对象、构造函数、构造参数都已经确认了，则最后一步就是调用 InstantiationStrategy 对象的 <code>instantiate()</code> 来创建 bean 实例，如下：</p>\n<pre><code class=\"java\">public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n            @Nullable Object factoryBean, final Method factoryMethod, @Nullable Object... args) {\n\n        try {\n            if (System.getSecurityManager() != null) {\n                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {\n                    ReflectionUtils.makeAccessible(factoryMethod);\n                    return null;\n                });\n            }\n            else {\n                ReflectionUtils.makeAccessible(factoryMethod);\n            }\n\n            Method priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();\n            try {\n                currentlyInvokedFactoryMethod.set(factoryMethod);\n                // 执行工厂方法，并返回实例\n                Object result = factoryMethod.invoke(factoryBean, args);\n                if (result == null) {\n                    result = new NullBean();\n                }\n                return result;\n            }\n            finally {\n                if (priorInvokedFactoryMethod != null) {\n                    currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);\n                }\n                else {\n                    currentlyInvokedFactoryMethod.remove();\n                }\n            }\n        }\n        // 省略一波 catch\n    }\n</code></pre>\n<p><code>instantiate()</code> 最核心的部分就是利用 Java 反射执行工厂方法并返回创建好的实例，也就是这段代码：</p>\n<pre><code class=\"null\">Object result = factoryMethod.invoke(factoryBean, args);\n</code></pre>\n<p>到这里 <code>instantiateUsingFactoryMethod()</code> 已经分析完毕了。</p>\n<p><code>createBeanInstance()</code> 还有两个重要方法 <code>autowireConstructor()</code> 和 <code>instantiateBean()</code> ,由于篇幅问题，所以将这两个方法放在下篇博客分析。敬请期待!!!</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-21实例化bean\"><a href=\"#spring源码解析之-21实例化bean\" class=\"headerlink\" title=\"spring源码解析之 21实例化bean\"></a>spring源码解析之 21实例化bean</h1><p>这篇我们关注创建 bean 过程中的第一个步骤：实例化 bean，对应的方法为：<code>createBeanInstance()</code>，如下：<br>","more":"</p>\n<pre><code class=\"java\">   protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, \n                                            @Nullable Object[] args) {\n        // 解析 bean，将 bean 类名解析为 class 引用\n        Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);\n\n        if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; \n            !mbd.isNonPublicAccessAllowed()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                    &quot;Bean class isn&#39;t public, and non-public access not allowed: &quot;\n                                            + beanClass.getName());\n        }\n\n        // 如果存在 Supplier 回调，则使用给定的回调方法初始化策略,这个实在spring5中新添加的\n        Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();\n        if (instanceSupplier != null) {\n            return obtainFromSupplier(instanceSupplier, beanName);\n        }\n\n        // 如果工厂方法不为空，则使用工厂方法初始化策略\n        if (mbd.getFactoryMethodName() != null)  {\n            return instantiateUsingFactoryMethod(beanName, mbd, args);\n        }\n\n        boolean resolved = false;\n        boolean autowireNecessary = false;\n        if (args == null) {\n            // constructorArgumentLock 构造函数的常用锁\n            synchronized (mbd.constructorArgumentLock) {\n                // 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析\n                // 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制\n                if (mbd.resolvedConstructorOrFactoryMethod != null) {\n                    resolved = true;\n                    autowireNecessary = mbd.constructorArgumentsResolved;\n                }\n            }\n        }\n       // 对于实例的差UN宫颈癌你spring中分成了俩种情况，一种是通用的实例化，另一种是带有参数\n        // 的实例化。带有参数的实例化过程相当复杂，因为存在着不确定性，所以判断对应参数上做了大量\n        // 工作\n\n           // 如果已经解析过则使用构造函数方法不需要再次锁定\n        if (resolved) {\n            // 自动注入，调用构造函数自动注入\n            if (autowireNecessary) {\n                return autowireConstructor(beanName, mbd, null, null);\n            }\n            else {\n                // 使用默认构造函数构造\n                return instantiateBean(beanName, mbd);\n            }\n        }\n\n        // 确定解析的构造函数\n        // 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor\n        Constructor&lt;?&gt;[] ctors = \n            determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n        if (ctors != null ||\n              mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR \n               || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n            // 构造函数自动注入\n            return autowireConstructor(beanName, mbd, ctors, args);\n        }\n        // 选择合适的构造函数来进行初始化\n        ctors = mbd.getPreferredConstructors();\n        if (ctors != null) {\n            return autowireConstructor(beanName, mbd, ctors, null);\n        }\n        //使用默认构造函数注入\n        return instantiateBean(beanName, mbd);\n    }\n</code></pre>\n<p>实例化 bean 是一个复杂的过程，其主要的逻辑为：</p>\n<ul>\n<li>如果存在 Supplier 回调，则调用 <code>obtainFromSupplier()</code> 进行初始化</li>\n<li>如果存在工厂方法，则使用工厂方法进行初始化</li>\n<li>首先判断缓存，如果缓存中存在，即已经解析过了，则直接使用已经解析了的，根据 constructorArgumentsResolved 参数来判断是使用构造函数自动注入还是默认构造函数</li>\n<li>如果缓存中没有，则需要先确定到底使用哪个构造函数来完成解析工作，因为一个类有多个构造函数，每个构造函数都有不同的构造参数，所以需要根据参数来锁定构造函数并完成初始化，如果存在参数则使用相应的带有参数的构造函数，否则使用默认构造函数。</li>\n</ul>\n<p>下面就上面四种情况做分别说明。</p>\n<h2 id=\"obtainFromSupplier\"><a href=\"#obtainFromSupplier\" class=\"headerlink\" title=\"obtainFromSupplier()\"></a>obtainFromSupplier()</h2><pre><code class=\"java\">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();\nif (instanceSupplier != null) {\n    return obtainFromSupplier(instanceSupplier, beanName);\n}\n</code></pre>\n<p>首先从 BeanDefinition 中获取 Supplier，如果不为空，则调用 <code>obtainFromSupplier()</code> 。那么 Supplier 是什么呢？在这之前也没有提到过这个字段。</p>\n<pre><code class=\"java\">public interface Supplier&lt;T&gt; {\n    T get();\n}\n</code></pre>\n<p>Supplier 接口仅有一个功能性的 <code>get()</code>，该方法会返回一个 T 类型的对象，有点儿类似工厂方法。这个接口有什么作用？用于指定创建 bean 的回调，如果我们设置了这样的回调，那么其他的构造器或者工厂方法都会没有用。在什么设置该参数呢？Spring 提供了相应的 <code>setter</code> 方法，如下：</p>\n<pre><code class=\"java\">    public void setInstanceSupplier(@Nullable Supplier&lt;?&gt; instanceSupplier) {\n        this.instanceSupplier = instanceSupplier;\n    }\n</code></pre>\n<p>在构造 BeanDefinition 的时候设置了该值，如下（以 RootBeanDefinition 为例）：</p>\n<pre><code class=\"java\">    public &lt;T&gt; RootBeanDefinition(@Nullable Class&lt;T&gt; beanClass, String scope, \n                                  @Nullable Supplier&lt;T&gt; instanceSupplier) {\n        super();\n        setBeanClass(beanClass);\n        setScope(scope);\n        setInstanceSupplier(instanceSupplier);\n    }\n</code></pre>\n<p>如果设置了 instanceSupplier 则调用 <code>obtainFromSupplier()</code> 完成 bean 的初始化，如下：</p>\n<pre><code class=\"java\">    protected BeanWrapper obtainFromSupplier(Supplier&lt;?&gt; instanceSupplier, \n                                             String beanName) {\n        String outerBean = this.currentlyCreatedBean.get();\n        this.currentlyCreatedBean.set(beanName);\n        Object instance;\n        try {\n          // 调用 Supplier 的 get()，返回一个对象\n            instance = instanceSupplier.get();\n        }\n        finally {\n            if (outerBean != null) {\n                this.currentlyCreatedBean.set(outerBean);\n            }\n            else {\n                this.currentlyCreatedBean.remove();\n            }\n        }\n        // 根据对象构造 BeanWrapper 对象\n        BeanWrapper bw = new BeanWrapperImpl(instance);\n        // 初始化 BeanWrapper\n        initBeanWrapper(bw);\n        return bw;\n    }\n</code></pre>\n<p>代码很简单，调用 调用 Supplier 的 <code>get()</code> 方法，获得一个 bean 实例对象，然后根据该实例对象构造一个 BeanWrapper 对象 bw，最后初始化该对象。有关于 BeanWrapper 后面专门出文讲解。</p>\n<h2 id=\"instantiateUsingFactoryMethod\"><a href=\"#instantiateUsingFactoryMethod\" class=\"headerlink\" title=\"instantiateUsingFactoryMethod()\"></a>instantiateUsingFactoryMethod()</h2><p>如果存在工厂方法，则调用 <code>instantiateUsingFactoryMethod()</code> 完成 bean 的初始化工作（方法实现比较长，细节比较复杂，各位就硬着头皮看吧）。</p>\n<pre><code class=\"java\">    protected BeanWrapper instantiateUsingFactoryMethod(\n            String beanName, RootBeanDefinition mbd, \n        @Nullable Object[] explicitArgs) {\n        return new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName,\n                                   mbd, explicitArgs);\n    }\n</code></pre>\n<p>构造一个 ConstructorResolver 对象，然后调用其 <code>instantiateUsingFactoryMethod()</code> 方法。ConstructorResolver 是构造方法或者工厂类初始化 bean 的委托类。</p>\n<pre><code class=\"java\">      public BeanWrapper instantiateUsingFactoryMethod(\n            final String beanName, final RootBeanDefinition mbd,\n          @Nullable final Object[] explicitArgs) {\n\n        // 构造 BeanWrapperImpl 对象\n        BeanWrapperImpl bw = new BeanWrapperImpl();\n        // 初始化 BeanWrapperImpl\n        // 向BeanWrapper对象中添加 ConversionService 对象和属性编辑器 PropertyEditor 对象\n        this.beanFactory.initBeanWrapper(bw);\n\n        Object factoryBean;\n        Class&lt;?&gt; factoryClass;\n        boolean isStatic;\n\n        // 工厂名不为空\n        String factoryBeanName = mbd.getFactoryBeanName();\n        if (factoryBeanName != null) {\n            if (factoryBeanName.equals(beanName)) {\n                   // 抛出异常省略\n            }\n            // 获取工厂实例\n            factoryBean = this.beanFactory.getBean(factoryBeanName);\n            if (mbd.isSingleton() &amp;&amp; this.beanFactory.containsSingleton(beanName)) {\n                throw new ImplicitlyAppearedSingletonException();\n            }\n            factoryClass = factoryBean.getClass();\n            isStatic = false;\n        }\n        else {\n            // 工厂名为空，则其可能是一个静态工厂\n            // 静态工厂创建bean，必须要提供工厂的全类名\n            if (!mbd.hasBeanClass()) {\n                    // 省略抛出异常代码\n            }\n            factoryBean = null;\n            factoryClass = mbd.getBeanClass();\n            isStatic = true;\n        }\n\n        // 工厂方法\n        Method factoryMethodToUse = null;\n        ConstructorResolver.ArgumentsHolder argsHolderToUse = null;\n        // 参数\n        Object[] argsToUse = null;\n\n        // 工厂方法的参数\n        // 如果指定了构造参数则直接使用\n        // 在调用 getBean 方法的时候指定了方法参数\n        if (explicitArgs != null) {\n            argsToUse = explicitArgs;\n        }\n        else {\n            // 没有指定，则尝试从配置文件中解析\n            Object[] argsToResolve = null;\n            // 首先尝试从缓存中获取\n            synchronized (mbd.constructorArgumentLock) {\n                // 获取缓存中的构造函数或者工厂方法\n                factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n                if (factoryMethodToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {\n                    // 获取缓存中的构造参数\n                    argsToUse = mbd.resolvedConstructorArguments;\n                    if (argsToUse == null) {\n                        // 获取缓存中的构造函数参数的包可见字段\n                        argsToResolve = mbd.preparedConstructorArguments;\n                    }\n                }\n            }\n            // 缓存中存在,则解析存储在 BeanDefinition 中的参数\n            // 如给定方法的构造函数 A(int ,int )，\n            // 则通过此方法后就会把配置文件中的(&quot;1&quot;,&quot;1&quot;)转换为 (1,1)\n            // 缓存中的值可能是原始值也有可能是最终值\n            if (argsToResolve != null) {\n                argsToUse = resolvePreparedArguments(beanName, mbd, bw, \n                                  factoryMethodToUse, argsToResolve);\n            }\n        }\n\n        //\n        if (factoryMethodToUse == null || argsToUse == null) {\n            // 获取工厂方法的类全名称\n            factoryClass = ClassUtils.getUserClass(factoryClass);\n\n            // 获取所有待定方法\n            Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n            // 检索所有方法，这里是对方法进行过滤\n            List&lt;Method&gt; candidateSet = new ArrayList&lt;&gt;();\n            for (Method candidate : rawCandidates) {\n                // 如果有static 且为工厂方法，则添加到 candidateSet 中\n                if (Modifier.isStatic(candidate.getModifiers()) == \n                    isStatic &amp;&amp; mbd.isFactoryMethod(candidate)) {\n                    candidateSet.add(candidate);\n                }\n            }\n\n            Method[] candidates = candidateSet.toArray(new Method[0]);\n            // 排序构造函数\n            // public 构造函数优先参数数量降序，非public 构造函数参数数量降序\n            AutowireUtils.sortFactoryMethods(candidates);\n\n            // 用于承载解析后的构造函数参数的值\n            ConstructorArgumentValues resolvedValues = null;\n            boolean autowiring = (mbd.getResolvedAutowireMode() == \n                                  RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n            int minTypeDiffWeight = Integer.MAX_VALUE;\n            Set&lt;Method&gt; ambiguousFactoryMethods = null;\n\n            int minNrOfArgs;\n            if (explicitArgs != null) {\n                minNrOfArgs = explicitArgs.length;\n            }\n            else {\n             // getBean() 没有传递参数，则需要解析保存在 BeanDefinition 构造函数中指定的参数\n                if (mbd.hasConstructorArgumentValues()) {\n                    // 构造函数的参数\n                    ConstructorArgumentValues cargs = \n                        mbd.getConstructorArgumentValues();\n                    resolvedValues = new ConstructorArgumentValues();\n                    // 解析构造函数的参数\n                  // 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean\n                    minNrOfArgs = \n                        resolveConstructorArguments(beanName, mbd, bw, cargs,\n                                                    resolvedValues);\n                }\n                else {\n                    minNrOfArgs = 0;\n                }\n            }\n\n            LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null;\n\n            for (Method candidate : candidates) {\n                // 方法体的参数\n                Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();\n\n                if (paramTypes.length &gt;= minNrOfArgs) {\n                    // 保存参数的对象\n                    ArgumentsHolder argsHolder;\n\n                    // getBean()传递了参数\n                    if (explicitArgs != null){\n                        // 显示给定参数，参数长度必须完全匹配\n                        if (paramTypes.length != explicitArgs.length) {\n                            continue;\n                        }\n                        // 根据参数创建参数持有者\n                        argsHolder = new ArgumentsHolder(explicitArgs);\n                    }\n                    else {\n                        // 为提供参数，解析构造参数\n                        try {\n                            String[] paramNames = null;\n                            // 获取 ParameterNameDiscoverer 对象\n                            // ParameterNameDiscoverer 是用于解析方法和构造函数的参数名称的接口，为参数名称探测器\n                            ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n                            if (pnd != null) {\n                                // 获取指定构造函数的参数名称\n                                paramNames = pnd.getParameterNames(candidate);\n                            }\n\n\n                            // 在已经解析的构造函数参数值的情况下，创建一个参数持有者对象\n                            argsHolder = createArgumentArray(\n                                    beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                        }\n                        catch (UnsatisfiedDependencyException ex) {\n                            if (this.beanFactory.logger.isTraceEnabled()) {\n                                this.beanFactory.logger.trace(&quot;Ignoring factory method [&quot; + candidate +\n                                        &quot;] of bean &#39;&quot; + beanName + &quot;&#39;: &quot; + ex);\n                            }\n                            if (causes == null) {\n                                causes = new LinkedList&lt;&gt;();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n\n                    // isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式\n                    // 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常\n                    // 宽松模式：使用具有&quot;最接近的模式&quot;进行匹配\n                    // typeDiffWeight：类型差异权重\n                    int typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n                            argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                    // 代表最接近的类型匹配，则选择作为构造函数\n                    if (typeDiffWeight &lt; minTypeDiffWeight) {\n                        factoryMethodToUse = candidate;\n                        argsHolderToUse = argsHolder;\n                        argsToUse = argsHolder.arguments;\n                        minTypeDiffWeight = typeDiffWeight;\n                        ambiguousFactoryMethods = null;\n                    }\n\n                    // 如果具有相同参数数量的方法具有相同的类型差异权重，则收集此类型选项\n                    // 但是，仅在非宽松构造函数解析模式下执行该检查，并显式忽略重写方法（具有相同的参数签名）\n                    else if (factoryMethodToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp;\n                            !mbd.isLenientConstructorResolution() &amp;&amp;\n                            paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp;\n                            !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\n                        // 查找到多个可匹配的方法\n                        if (ambiguousFactoryMethods == null) {\n                            ambiguousFactoryMethods = new LinkedHashSet&lt;&gt;();\n                            ambiguousFactoryMethods.add(factoryMethodToUse);\n                        }\n                        ambiguousFactoryMethods.add(candidate);\n                    }\n                }\n            }\n\n            // 没有可执行的工厂方法，抛出异常\n            if (factoryMethodToUse == null) {\n                if (causes != null) {\n                    UnsatisfiedDependencyException ex = causes.removeLast();\n                    for (Exception cause : causes) {\n                        this.beanFactory.onSuppressedException(cause);\n                    }\n                    throw ex;\n                }\n                List&lt;String&gt; argTypes = new ArrayList&lt;&gt;(minNrOfArgs);\n                if (explicitArgs != null) {\n                    for (Object arg : explicitArgs) {\n                        argTypes.add(arg != null ? arg.getClass().getSimpleName() : &quot;null&quot;);\n                    }\n                }\n                else if (resolvedValues != null){\n                    Set&lt;ConstructorArgumentValues.ValueHolder&gt; valueHolders = new LinkedHashSet&lt;&gt;(resolvedValues.getArgumentCount());\n                    valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                    valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                    for (ConstructorArgumentValues.ValueHolder value : valueHolders) {\n                        String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n                                (value.getValue() != null ? value.getValue().getClass().getSimpleName() : &quot;null&quot;));\n                        argTypes.add(argType);\n                    }\n                }\n                String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        &quot;No matching factory method found: &quot; +\n                                (mbd.getFactoryBeanName() != null ?\n                                        &quot;factory bean &#39;&quot; + mbd.getFactoryBeanName() + &quot;&#39;; &quot; : &quot;&quot;) +\n                                &quot;factory method &#39;&quot; + mbd.getFactoryMethodName() + &quot;(&quot; + argDesc + &quot;)&#39;. &quot; +\n                                &quot;Check that a method with the specified name &quot; +\n                                (minNrOfArgs &gt; 0 ? &quot;and arguments &quot; : &quot;&quot;) +\n                                &quot;exists and that it is &quot; +\n                                (isStatic ? &quot;static&quot; : &quot;non-static&quot;) + &quot;.&quot;);\n            }\n            else if (void.class == factoryMethodToUse.getReturnType()) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        &quot;Invalid factory method &#39;&quot; + mbd.getFactoryMethodName() +\n                                &quot;&#39;: needs to have a non-void return type!&quot;);\n            }\n            else if (ambiguousFactoryMethods != null) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        &quot;Ambiguous factory method matches found in bean &#39;&quot; + beanName + &quot;&#39; &quot; +\n                                &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot; +\n                                ambiguousFactoryMethods);\n            }\n\n            if (explicitArgs == null &amp;&amp; argsHolderToUse != null) {\n                // 将解析的构造函数加入缓存\n                argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n            }\n        }\n\n        try {\n            // 实例化 bean\n            Object beanInstance;\n\n            if (System.getSecurityManager() != null) {\n                final Object fb = factoryBean;\n                final Method factoryMethod = factoryMethodToUse;\n                final Object[] args = argsToUse;\n                // 通过执行工厂方法来创建bean示例\n                beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;\n                                beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n                        beanFactory.getAccessControlContext());\n            }\n            else {\n                // 通过执行工厂方法来创建bean示例\n                beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n                        mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n            }\n\n            // 包装为 BeanWraper 对象\n            bw.setBeanInstance(beanInstance);\n            return bw;\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                    &quot;Bean instantiation via factory method failed&quot;, ex);\n        }\n    }\n</code></pre>\n<p><code>instantiateUsingFactoryMethod()</code> 方法体实在是太大了，处理细节感觉很复杂，硬着头皮看完的，中间断断续续的。吐槽这里的代码风格，完全不符合我们前面看的 Spring 代码风格。Spring 的一贯做法是将一个复杂逻辑进行拆分，分为多个细小的模块进行嵌套，每个模块负责一部分功能，模块与模块之间层层嵌套，上一层一般都是对下一层的总结和概括，这样就会使得每一层的逻辑变得清晰易懂。</p>\n<p>回归到上面的方法体，虽然代码体量大，但是总体我们还是可看清楚这个方法要做的事情。一句话概括就是：确定工厂对象，然后获取构造函数和构造参数，最后调用 InstantiationStrategy 对象的 <code>instantiate()</code> 来创建 bean 实例。下面我们就这个句概括的话进行拆分并详细说明。</p>\n<p><strong>确定工厂对象</strong></p>\n<p>首先获取工厂方法名，若工厂方法名不为空，则调用 <code>beanFactory.getBean()</code> 获取工厂对象，若为空，则可能为一个静态工厂，对于静态工厂则必须提供工厂类的全类名，同时设置 <code>factoryBean = null</code></p>\n<p><strong>构造参数确认</strong></p>\n<p>工厂对象确定后，则是确认构造参数。构造参数的确认主要分为三种情况：explicitArgs 参数、缓存中获取、配置文件中解析。</p>\n<p><strong>explicitArgs 参数</strong></p>\n<p>explicitArgs 参数是我们调用 <code>getBean()</code> 时传递景来，一般该参数，该参数就是用于初始化 bean 时所传递的参数，如果该参数不为空，则可以确定构造函数的参数就是它了。</p>\n<p><strong>缓存中获取</strong></p>\n<p>在该方法的最后，我们会发现这样一段代码：<code>argsHolderToUse.storeCache(mbd, factoryMethodToUse)</code> ，这段代码主要是将构造函数、构造参数保存到缓存中，如下：</p>\n<pre><code class=\"java\">        public void storeCache(RootBeanDefinition mbd, Executable constructorOrFactoryMethod) {\n            synchronized (mbd.constructorArgumentLock) {\n                mbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;\n                mbd.constructorArgumentsResolved = true;\n                if (this.resolveNecessary) {\n                    mbd.preparedConstructorArguments = this.preparedArguments;\n                }\n                else {\n                    mbd.resolvedConstructorArguments = this.arguments;\n                }\n            }\n        }\n</code></pre>\n<p>其中涉及到的几个参数 constructorArgumentLock、resolvedConstructorOrFactoryMethod、constructorArgumentsResolved、resolvedConstructorArguments。这些参数都是跟构造函数、构造函数缓存有关的。</p>\n<ul>\n<li>constructorArgumentLock：构造函数的缓存锁</li>\n<li>resolvedConstructorOrFactoryMethod：缓存已经解析的构造函数或者工厂方法</li>\n<li>constructorArgumentsResolved：标记字段，标记构造函数、参数已经解析了。默认为false</li>\n<li>resolvedConstructorArguments：缓存已经解析的构造函数参数，包可见字段</li>\n</ul>\n<p>所以从缓存中获取就是提取这几个参数的值，如下：</p>\n<pre><code class=\"java\">            synchronized (mbd.constructorArgumentLock) {\n                // 获取缓存中的构造函数或者工厂方法\n                factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n                if (factoryMethodToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {\n                    // 获取缓存中的构造参数\n                    argsToUse = mbd.resolvedConstructorArguments;\n                    if (argsToUse == null) {\n                        // 获取缓存中的构造函数参数的包可见字段\n                        argsToResolve = mbd.preparedConstructorArguments;\n                    }\n                }\n            }\n</code></pre>\n<p>如果缓存中存在构造参数，则需要调用 <code>resolvePreparedArguments()</code> 方法进行转换，因为缓存中的值有可能是最终值也有可能不是最终值，比如我们构造函数中的类型为 Integer 类型的 1 ，但是原始的参数类型有可能是 String 类型的 1 ，所以即便是从缓存中得到了构造参数也需要经过一番的类型转换确保参数类型完全对应。</p>\n<p><strong>配置文件中解析</strong></p>\n<p>即没有通过传递参数的方式传递构造参数，缓存中也没有，那就只能通过解析配置文件获取构造参数了。</p>\n<p>在 bean 解析类的博文中我们了解了，配置文件中的信息都会转换到 BeanDefinition 实例对象中，所以配置文件中的参数可以直接通过 BeanDefinition 对象获取。代码如下：</p>\n<pre><code class=\"java\">if (mbd.hasConstructorArgumentValues()) {\n    // 构造函数的参数\n    ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n    resolvedValues = new ConstructorArgumentValues();\n    // 解析构造函数的参数\n    // 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean\n    minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n}\n</code></pre>\n<p>通过 BeanDefinition 的 <code>getConstructorArgumentValues()</code> 就可以获取构造信息了，有了构造信息就可以获取相关的参数值信息了，获取的参数信息包括直接值和引用，这一步骤的处理交由 <code>resolveConstructorArguments()</code> 完成，该方法会将构造参数信息解析为 resolvedValues 对象 并返回解析到的参数个数。</p>\n<p><strong>构造函数</strong></p>\n<p>确定构造参数后，下一步则是确定构造函数。第一步则是通过 <code>getCandidateMethods()</code> 获取所有的构造方法，同时对构造方法进行刷选，然后在对其进行排序处理（<code>AutowireUtils.sortFactoryMethods(candidates)</code>），排序的主要目的是为了能够更加方便的找到匹配的构造函数，因为构造函数的确认是根据参数个数确认的。排序的规则是：public 构造函数优先参数数量降序、非 public 构造参数数量降序。</p>\n<p>通过迭代 candidates（包含了所有要匹配的构造函数）的方式，一次比较其参数，如果显示提供了参数（explicitArgs != null），则直接比较两者是否相等，如果相等则表示找到了，否则继续比较。如果没有显示提供参数，则需要获取 ParameterNameDiscoverer 对象，该对象为参数名称探测器，主要用于发现方法和构造函数的参数名称。</p>\n<p>将参数包装成 ArgumentsHolder 对象，该对象用于保存参数，我们称之为参数持有者。当将对象包装成 ArgumentsHolder 对象后，我们就可以通过它来进行构造函数匹配，匹配分为严格模式和宽松模式。</p>\n<ul>\n<li>严格模式：解析构造函数时，必须所有参数都需要匹配，否则抛出异常</li>\n<li>宽松模式：使用具有”最接近的模式”进行匹配</li>\n</ul>\n<p>判断的依据是根据 BeanDefinition 的 isLenientConstructorResolution 属性（该参数是我们在构造 AbstractBeanDefinition 对象是传递的）来获取类型差异权重（typeDiffWeight） 的。如果 <code>typeDiffWeight &lt; minTypeDiffWeight</code> ，则代表“最接近的模式”，选择其作为构造函数，否则只有两者具有相同的参数数量且类型差异权重相等才会纳入考虑范围。</p>\n<p>至此，构造函数已经确认了。</p>\n<p><strong>创建 bean 实例</strong></p>\n<p>工厂对象、构造函数、构造参数都已经确认了，则最后一步就是调用 InstantiationStrategy 对象的 <code>instantiate()</code> 来创建 bean 实例，如下：</p>\n<pre><code class=\"java\">public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n            @Nullable Object factoryBean, final Method factoryMethod, @Nullable Object... args) {\n\n        try {\n            if (System.getSecurityManager() != null) {\n                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {\n                    ReflectionUtils.makeAccessible(factoryMethod);\n                    return null;\n                });\n            }\n            else {\n                ReflectionUtils.makeAccessible(factoryMethod);\n            }\n\n            Method priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();\n            try {\n                currentlyInvokedFactoryMethod.set(factoryMethod);\n                // 执行工厂方法，并返回实例\n                Object result = factoryMethod.invoke(factoryBean, args);\n                if (result == null) {\n                    result = new NullBean();\n                }\n                return result;\n            }\n            finally {\n                if (priorInvokedFactoryMethod != null) {\n                    currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);\n                }\n                else {\n                    currentlyInvokedFactoryMethod.remove();\n                }\n            }\n        }\n        // 省略一波 catch\n    }\n</code></pre>\n<p><code>instantiate()</code> 最核心的部分就是利用 Java 反射执行工厂方法并返回创建好的实例，也就是这段代码：</p>\n<pre><code class=\"null\">Object result = factoryMethod.invoke(factoryBean, args);\n</code></pre>\n<p>到这里 <code>instantiateUsingFactoryMethod()</code> 已经分析完毕了。</p>\n<p><code>createBeanInstance()</code> 还有两个重要方法 <code>autowireConstructor()</code> 和 <code>instantiateBean()</code> ,由于篇幅问题，所以将这两个方法放在下篇博客分析。敬请期待!!!</p>"},{"abbrlink":44,"title":"spring源码解析之 23属性填充","author":"fengxiutianya","date":"2019-01-14T19:37:00.000Z","_content":"# spring源码解析之 23属性填充\n\n`doCreateBean()` 主要用于完成 bean 的创建和初始化工作，我们可以将其分为四个过程：\n\n- `createBeanInstance()` 实例化 bean\n- `populateBean()` 属性填充\n- 循环依赖的处理\n- `initializeBean()` 初始化 bean\n\n第一个过程实例化 bean 已经在前面两篇博客分析完毕了，这篇博客开始分析属性填充，也就是 `populateBean()`，该函数的作用是将 BeanDefinition 中的属性值赋值给 BeanWrapper 实例对象(对于 BeanWrapper 我们后续专门写文分析)。\n<!-- more -->\n\n```java\n    protected void populateBean(String beanName, RootBeanDefinition mbd,\n                                @Nullable BeanWrapper bw) {\n        // 没有实例化对象\n        if (bw == null) {\n            // 有属性抛出异常\n            if (mbd.hasPropertyValues()) {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, \n                    \"Cannot apply property values to null instance\");\n            }\n            else {\n                // 没有属性直接返回\n                return;\n            }\n        }\n\n        // 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会\n        boolean continueWithPropertyPopulation = true;\n\n        // bena 不是\"合成\"的，即未由应用程序本身定义\n        // 是否持有 InstantiationAwareBeanPostProcessor\n        if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n            // 迭代所有的 BeanPostProcessors\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                // 如果为 InstantiationAwareBeanPostProcessor\n                if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                    InstantiationAwareBeanPostProcessor ibp = \n                        (InstantiationAwareBeanPostProcessor) bp;\n                    // 返回值为是否继续填充 bean\n                    // postProcessAfterInstantiation：\n                    // 如果应该在 bean上面设置属性则返回true，否则返回false\n                    // 一般情况下，应该是返回true，返回 false 的话，\n                    // 将会阻止在此 Bean 实例上调用任何后续的 \n                    // InstantiationAwareBeanPostProcessor 实例。\n                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), \n                                                           beanName)) {\n                        continueWithPropertyPopulation = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // 如果后续处理器发出停止填充命令，则终止后续操作\n        if (!continueWithPropertyPopulation) {\n            return;\n        }\n\n        // bean 的属性值，记录在bean标签中property\n        PropertyValues pvs = (mbd.hasPropertyValues() ?\n                              mbd.getPropertyValues() : null);\n\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) \n        {\n\n            // 将 PropertyValues 封装成 MutablePropertyValues 对象\n            // MutablePropertyValues 允许对属性进行简单的操作，\n            // 并提供构造函数以支持Map的深度复制和构造。\n            MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n            // 根据名称自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) \n            {\n                autowireByName(beanName, mbd, bw, newPvs);\n            }\n\n            // 根据类型自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE)\n            {\n                autowireByType(beanName, mbd, bw, newPvs);\n            }\n\n            pvs = newPvs;\n        }\n\n        // 是否已经注册了 InstantiationAwareBeanPostProcessors\n        boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n        // 是否需要进行依赖检查\n        boolean needsDepCheck = (mbd.getDependencyCheck() != \n                                 RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n        if (hasInstAwareBpps || needsDepCheck) {\n            if (pvs == null) {\n                pvs = mbd.getPropertyValues();\n            }\n\n            // 从 bw 对象中提取 PropertyDescriptor 结果集\n            // PropertyDescriptor：可以通过一对存取方法提取一个属性\n            PropertyDescriptor[] filteredPds = \n                filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n            if (hasInstAwareBpps) {\n                for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                    if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                        InstantiationAwareBeanPostProcessor ibp = \n                            (InstantiationAwareBeanPostProcessor) bp;\n                        // 对所有需要依赖检查的属性进行后处理\n                        pvs = ibp.postProcessPropertyValues(pvs, filteredPds, \n                                         bw.getWrappedInstance(), beanName);\n                        if (pvs == null) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if (needsDepCheck) {\n                // 依赖检查，对应 depends-on 属性\n                checkDependencies(beanName, mbd, filteredPds, pvs);\n            }\n        }\n\n        if (pvs != null) {\n            // 将属性应用到 bean 中\n            applyPropertyValues(beanName, mbd, bw, pvs);\n        }\n    }\n```\n\n处理流程如下：\n\n1. 根据 hasInstantiationAwareBeanPostProcessors 属性来判断是否需要在注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会，此过程可以控制 Spring 是否继续进行属性填充。\n2. 根据注入类型的不同来判断是根据名称来自动注入（`autowireByName()`）还是根据类型来自动注入（`autowireByType()`），统一存入到 PropertyValues 中，PropertyValues 用于描述 bean 的属性。\n3. 判断是否需要进行 BeanPostProcessor 和 依赖检测。\n4. 将所有 PropertyValues 中的属性填充到 BeanWrapper 中。\n\n## 自动注入\n\nSpring 会根据注入类型（ byName / byType ）的不同，调用不同的方法（`autowireByName()` / `autowireByType()`）来注入属性值。\n\n**autowireByName()**\n\n方法 `autowireByName()` 是根据属性名称完成自动依赖注入的，代码如下：\n\n```java\n    protected void autowireByName(\n            String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, \n        MutablePropertyValues pvs) {\n\n        // 获取Bean 对象中非简单属性\n        String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n        for (String propertyName : propertyNames) {\n            // 如果容器中包含指定名称的 bean，则将该 bean 注入到 bean中\n            if (containsBean(propertyName)) {\n                // 递归初始化相关 bean\n                Object bean = getBean(propertyName);\n                // 为指定名称的属性赋予属性值  \n                pvs.add(propertyName, bean);\n                // 属性依赖注入\n                registerDependentBean(propertyName, beanName);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Added autowiring by name from bean name '\" \n                                 + beanName +\n                            \"' via property '\" + propertyName \n                                 + \"' to bean named '\" + propertyName + \"'\");\n                }\n            }\n            else {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Not autowiring property '\" \n                                 + propertyName + \"' of bean '\" + beanName +\n                            \"' by name: no matching bean found\");\n                }\n            }\n        }\n    }\n```\n\n该方法逻辑很简单，获取该 bean 的非简单属性，什么叫做非简单属性呢？就是类型为对象类型的属性，但是这里并不是将所有的对象类型都都会找到，比如 8 个原始类型，String 类型 ，Number类型、Date类型、URL类型、URI类型等都会被忽略，如下：\n\n```java\n    protected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, \n                                                      BeanWrapper bw) {\n        Set<String> result = new TreeSet<>();\n        // 获取属性集合\n        PropertyValues pvs = mbd.getPropertyValues();\n        // 获取属性描述操作符的集合，也就是对属性的get/set方法包装\n        PropertyDescriptor[] pds = bw.getPropertyDescriptors();\n        // 依次进行判断，该属性是否满足有可写方法，依赖检测中没有被忽略，不是简单属性\n        for (PropertyDescriptor pd : pds) {\n            // 对\n            if (pd.getWriteMethod() != null \n                && !isExcludedFromDependencyCheck(pd) \n                && !pvs.contains(pd.getName()) \n                && !BeanUtils.isSimpleProperty(pd.getPropertyType())) {\n                result.add(pd.getName());\n            }\n        }\n        return StringUtils.toStringArray(result);\n    }\n```\n\n过滤条件为：有可写方法、依赖检测中没有被忽略、不是简单属性类型。其实这里获取的就是需要依赖注入的属性。\n\n获取需要依赖注入的属性后，通过迭代、递归的方式初始化相关的 bean，然后调用 `registerDependentBean()` 完成注册依赖，这里前面文章中已经说过，如下：\n\n```java\n    public void registerDependentBean(String beanName, String dependentBeanName) {\n        String canonicalName = canonicalName(beanName);\n\n        synchronized (this.dependentBeanMap) {\n            Set<String> dependentBeans =\n                    this.dependentBeanMap.computeIfAbsent(canonicalName, \n                                                          k -> new LinkedHashSet<>(8));\n            if (!dependentBeans.add(dependentBeanName)) {\n                return;\n            }\n        }\n\n        synchronized (this.dependenciesForBeanMap) {\n            Set<String> dependenciesForBean =\n                    this.dependenciesForBeanMap.computeIfAbsent(dependentBeanName,\n                                   k -> new LinkedHashSet<>(8));\n            dependenciesForBean.add(canonicalName);\n        }\n    }\n```\n\n**autowireByType()**\n\n```java\n protected void autowireByType(\n            String beanName, AbstractBeanDefinition mbd, \n     \t\tBeanWrapper bw, MutablePropertyValues pvs) {\n\n        // 获取 TypeConverter 实例\n        // 使用自定义的 TypeConverter，用于取代默认的 PropertyEditor 机制\n        TypeConverter converter = getCustomTypeConverter();\n        if (converter == null) {\n            converter = bw;\n        }\n\n        Set<String> autowiredBeanNames = new LinkedHashSet<>(4);\n        // 获取非简单属性\n        String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\n        for (String propertyName : propertyNames) {\n            try {\n                // 获取 PropertyDescriptor 实例\n                PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);\n\n                // 不要尝试按类型\n                if (Object.class != pd.getPropertyType()) {\n                    \n                    // 探测指定属性的 set 方法\n                    MethodParameter methodParam = \n                        BeanUtils.getWriteMethodParameter(pd);\n\n                    boolean eager = \n                        !PriorityOrdered.class.isInstance(bw.getWrappedInstance());\n                    \n                    DependencyDescriptor desc = \n                        \tnew AbstractAutowireCapableBeanFactory\n                      \t\t  .AutowireByTypeDependencyDescriptor(methodParam, eager);\n\n                    // 解析指定 beanName 的属性所匹配的值，并把解析到的属性名称存储在 \n                    // autowiredBeanNames 中\n                    // 当属性存在过个封装 bean 时将会找到所有匹配的 bean 并将其注入\n                    Object autowiredArgument = resolveDependency(desc, beanName, \n                                       autowiredBeanNames, converter);\n\n                    if (autowiredArgument != null) {\n                        pvs.add(propertyName, autowiredArgument);\n                    }\n\n                    // 迭代方式注入 bean \n                    for (String autowiredBeanName : autowibeanredBeanNames) {\n                        registerDependentBean(autowiredBeanName, beanName);\n                        if (logger.isDebugEnabled()) {\n                            // 省略日志\n                        }\n                    }\n                    autowiredBeanNames.clear();\n                }\n            }\n            catch (BeansException ex) {\n           \t\t// 省略异常\n            }\n        }\n    }\n```\n\n其实主要过程和根据名称自动注入差不多都是找到需要依赖注入的属性，然后通过迭代的方式寻找所匹配的 bean，最后调用 `registerDependentBean()` 注册依赖。不过相对于 `autowireByName()` 而言，根据类型寻找相匹配的 bean 过程比较复杂，下面我们就分析这个复杂的过程，如下：\n\n```java\n    public Object resolveDependency(DependencyDescriptor descriptor, \n                                    @Nullable String requestingBeanName,\n                                    @Nullable Set<String> autowiredBeanNames, \n                                    @Nullable TypeConverter typeConverter) \n        throws BeansException {\n\n        // 初始化参数名称发现器，该方法并不会在这个时候尝试检索参数名称\n        // getParameterNameDiscoverer 返回 parameterNameDiscoverer 实例，\n        // parameterNameDiscoverer 方法参数名称的解析器\n        descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\n\n        // 依赖类型为 Optional 类型\n        if (Optional.class == descriptor.getDependencyType()) {\n            // 创建 Optional 实例依赖类型\n            return createOptionalDependency(descriptor, requestingBeanName);\n        }\n\n        // 依赖类型为ObjectFactory、ObjectProvider\n        else if (ObjectFactory.class == descriptor.getDependencyType() ||\n                ObjectProvider.class == descriptor.getDependencyType()) {\n            // ObjectFactory、ObjectProvider 用于 用于延迟解析依赖项\n            return new DefaultListableBeanFactory.DependencyObjectProvider(descriptor, \n            \t\t\t\t\t\t\t\t\t\t\trequestingBeanName);\n        }\n\n        else if (javaxInjectProviderClass == descriptor.getDependencyType()) {\n            // javaxInjectProviderClass 类注入的特殊处理\n            return new DefaultListableBeanFactory.Jsr330ProviderFactory()\n                .createDependencyProvider(descriptor, requestingBeanName);\n        }\n        else {\n            // 为实际依赖关系目标的延迟解析构建代理\n            // 默认实现返回 null\n            Object result = getAutowireCandidateResolver()\n                .getLazyResolutionProxyIfNecessary(\n                    descriptor, requestingBeanName);\n            if (result == null) {\n                // 通用处理逻辑\n                result = doResolveDependency(descriptor, requestingBeanName, \n                                             autowiredBeanNames, typeConverter);\n            }\n            return result;\n        }\n    }\n```\n\n这里我们关注通用处理逻辑：`doResolveDependency()`，如下：\n\n```java\n    public Object doResolveDependency(DependencyDescriptor descriptor, \n                                      @Nullable String beanName,\n                                      @Nullable Set<String> autowiredBeanNames,\n                                      @Nullable TypeConverter typeConverter) \n        \t\t\t\tthrows BeansException {\n\n        // 注入点\n        InjectionPoint previousInjectionPoint = \n            ConstructorResolver.setCurrentInjectionPoint(descriptor);\n        try {\n            // 针对给定的工厂给定一个快捷实现的方式，例如考虑一些预先解析的信息\n            // 在进入所有bean的常规类型匹配算法之前，解析算法将首先尝试通过此方法解析快捷方式。\n            // 子类可以覆盖此方法\n            Object shortcut = descriptor.resolveShortcut(this);\n            if (shortcut != null) {\n                // 返回快捷的解析信息\n                return shortcut;\n            }\n\n            // 依赖的类型\n            Class<?> type = descriptor.getDependencyType();\n            // 支持 Spring 的注解 @value\n            Object value = \n                getAutowireCandidateResolver().getSuggestedValue(descriptor);\n            if (value != null) {\n                if (value instanceof String) {\n                    String strVal = resolveEmbeddedValue((String) value);\n                    BeanDefinition bd = (beanName != null && containsBean(beanName) ? \n                                         getMergedBeanDefinition(beanName) : null);\n                    value = evaluateBeanDefinitionString(strVal, bd);\n                }\n                TypeConverter converter = (typeConverter != null ? typeConverter : \n                                           getTypeConverter());\n                return (descriptor.getField() != null ?\n                        converter.convertIfNecessary(value, type, \n                                                     descriptor.getField()) :\n                        converter.convertIfNecessary(value, type, \n                                                    descriptor.getMethodParameter()));\n            }\n\n            // 解析复合 bean，其实就是对 bean 的属性进行解析\n            // 包括：数组、Collection 、Map 类型\n            Object multipleBeans = resolveMultipleBeans(descriptor, beanName, \n                              autowiredBeanNames, typeConverter);\n            if (multipleBeans != null) {\n                return multipleBeans;\n            }\n\n            // 查找与类型相匹配的 bean\n            // 返回值构成为：key = 匹配的 beanName，value = beanName 对应的实例化 bean\n            Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, \n                                                                       descriptor);\n            // 没有找到，检验 @autowire  的 require 是否为 true\n            if (matchingBeans.isEmpty()) {\n                // 如果 @autowire 的 require 属性为 true 但是没有找到相应的匹配项，则抛出异常\n                if (isRequired(descriptor)) {\n                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(),\n                                             descriptor);\n                }\n                return null;\n            }\n\n            String autowiredBeanName;\n            Object instanceCandidate;\n\n            if (matchingBeans.size() > 1) {\n                //  确认给定 bean autowire 的候选者\n                // 按照 @Primary 和 @Priority 的顺序\n                autowiredBeanName = determineAutowireCandidate(matchingBeans, \n                                                               descriptor);\n                if (autowiredBeanName == null) {\n                    if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {\n                        // 唯一性处理\n                        return descriptor.resolveNotUnique(type, matchingBeans);\n                    } else {\n                        // 在可选的Collection / Map的情况下，默默地忽略一个非唯一的情况：\n                        // 可能它是一个多个常规bean的空集合\n                        return null;\n                    }\n                }\n                instanceCandidate = matchingBeans.get(autowiredBeanName);\n            } else {\n                // We have exactly one match.\n                Map.Entry<Staring, Object> entry = \n                    matchingBeans.entrySet().iterator().next();\n                autowiredBeanName = entry.getKey();\n                instanceCandidate = entry.getValue();\n            }\n\n            if (autowiredBeanNames != null) {\n                autowiredBeanNames.add(autowiredBeanName);\n            }\n            if (instanceCandidate instanceof Class) {\n                instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, \n                                                                type, this);\n            }\n            Object result = instanceCandidate;\n            if (result instanceof NullBean) {\n                if (isRequired(descriptor)) {\n                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), \n                                             descriptor);\n                }\n                result = null;\n            }\n            if (!ClassUtils.isAssignableValue(type, result)) {\n                throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, \n                                                        instanceCandidate.getClass());\n            }\n            return result;\n        } finally {\n            ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n        }\n    }\n```\n\n到这里就已经完成了所有注入属性的获取。`populateBean()` 该方法就已经完成了一大半工作了，下一步则是对依赖 bean 的检测和 PostProcessor 处理，这个我们后面分析，下面分析该方法的最后一步：`applyPropertyValues()`\n\n## applyPropertyValues\n\n其实上面只是完成了所有注入属性的获取，将获取的属性封装在 PropertyValues 的实例对象 pvs 中，并没有应用到已经实例化的 bean 中，而 `applyPropertyValues()` 则是完成这一步骤的。\n\n```java\n   protected void applyPropertyValues(String beanName, BeanDefinition mbd, \n                                      BeanWrapper bw, PropertyValues pvs) {\n        if (pvs.isEmpty()) {\n            return;\n        }\n\n        if (System.getSecurityManager() != null && bw instanceof BeanWrapperImpl) {\n            ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());\n        }\n\n        // MutablePropertyValues 类型属性\n        MutablePropertyValues mpvs = null;\n        // 原始类型\n        List<PropertyValue> original;\n\n\n        if (pvs instanceof MutablePropertyValues) {\n            mpvs = (MutablePropertyValues) pvs;\n            if (mpvs.isConverted()) {\n                try {\n                    // 设置到 BeanWrapper 中去\n                    bw.setPropertyValues(mpvs);\n                    return;\n                }\n                catch (BeansException ex) {\n                    throw new BeanCreationException(\n                            mbd.getResourceDescription(), beanName, \n                        \"Error setting property values\", ex);\n                }\n            }\n            original = mpvs.getPropertyValueList();\n        }\n        else {\n            // 如果 pvs 不是 MutablePropertyValues 类型，则直接使用原始类型\n            original = Arrays.asList(pvs.getPropertyValues());\n        }\n\n        // 获取 TypeConverter\n        TypeConverter converter = getCustomTypeConverter();\n        if (converter == null) {\n            converter = bw;\n        }\n\n        // 获取对应的解析器\n        BeanDefinitionValueResolver valueResolver = new \n            BeanDefinitionValueResolver(this, beanName, mbd, converter);\n\n        // Create a deep copy, resolving any references for values.\n        List<PropertyValue> deepCopy = new ArrayList<>(original.size());\n        boolean resolveNecessary = false;\n        // 遍历属性，将属性转换为对应类的对应属性的类型\n        for (PropertyValue pv : original) {\n            if (pv.isConverted()) {\n                deepCopy.add(pv);\n            }\n            else {\n                String propertyName = pv.getName();\n                Object originalValue = pv.getValue();\n                Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, \n`\t\t\t\t\t\t\toriginalValue);\n                Object convertedValue = resolvedValue;\n                boolean convertible = bw.isWritableProperty(propertyName) \n                    &&!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);\n                if (convertible) {\n                    convertedValue = convertForProperty(resolvedValue, propertyName, \n                                                        bw, converter);\n                }\n                // Possibly store converted value in merged bean definition,\n                // in order to avoid re-conversion for every created bean instance.\n                if (resolvedValue == originalValue) {\n                    if (convertible) {\n                        pv.setConvertedValue(convertedValue);\n                    }\n                    deepCopy.add(pv);\n                }\n                else if (convertible && originalValue instanceof TypedStringValue &&\n                        !((TypedStringValue) originalValue).isDynamic() &&\n                        !(convertedValue instanceof Collection || \n                          ObjectUtils.isArray(convertedValue))) {\n                    pv.setConvertedValue(convertedValue);\n                    deepCopy.add(pv);\n                }\n                else {\n                    resolveNecessary = true;\n                    deepCopy.add(new PropertyValue(pv, convertedValue));\n                }\n            }\n        }\n        if (mpvs != null && !resolveNecessary) {\n            mpvs.setConverted();\n        }\n\n        // Set our (possibly massaged) deep copy.\n        try {\n            bw.setPropertyValues(new MutablePropertyValues(deepCopy));\n        }\n        catch (BeansException ex) {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, \n                \"Error setting property values\", ex);\n        }\n    }\n```\n\n至此，`doCreateBean()` 第二个过程：属性填充 已经分析完成了，下篇分析第三个过程：循环依赖的处理，其实循环依赖并不仅仅只是在 `doCreateBean()` 中处理，其实在整个加载 bean 的过程中都有涉及，所以下篇内容并不仅仅只局限于 `doCreateBean()`。","source":"_posts/spring 源码分析/spring/spring源码解析之 23属性填充.md","raw":"abbrlink: 44\ntitle: spring源码解析之 23属性填充\ntags:\n  - spring源码解析\n  - spring\ncategories:\n  - spring\nauthor: fengxiutianya\ndate: 2019-01-15 03:37:00\n---\n# spring源码解析之 23属性填充\n\n`doCreateBean()` 主要用于完成 bean 的创建和初始化工作，我们可以将其分为四个过程：\n\n- `createBeanInstance()` 实例化 bean\n- `populateBean()` 属性填充\n- 循环依赖的处理\n- `initializeBean()` 初始化 bean\n\n第一个过程实例化 bean 已经在前面两篇博客分析完毕了，这篇博客开始分析属性填充，也就是 `populateBean()`，该函数的作用是将 BeanDefinition 中的属性值赋值给 BeanWrapper 实例对象(对于 BeanWrapper 我们后续专门写文分析)。\n<!-- more -->\n\n```java\n    protected void populateBean(String beanName, RootBeanDefinition mbd,\n                                @Nullable BeanWrapper bw) {\n        // 没有实例化对象\n        if (bw == null) {\n            // 有属性抛出异常\n            if (mbd.hasPropertyValues()) {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, \n                    \"Cannot apply property values to null instance\");\n            }\n            else {\n                // 没有属性直接返回\n                return;\n            }\n        }\n\n        // 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会\n        boolean continueWithPropertyPopulation = true;\n\n        // bena 不是\"合成\"的，即未由应用程序本身定义\n        // 是否持有 InstantiationAwareBeanPostProcessor\n        if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n            // 迭代所有的 BeanPostProcessors\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                // 如果为 InstantiationAwareBeanPostProcessor\n                if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                    InstantiationAwareBeanPostProcessor ibp = \n                        (InstantiationAwareBeanPostProcessor) bp;\n                    // 返回值为是否继续填充 bean\n                    // postProcessAfterInstantiation：\n                    // 如果应该在 bean上面设置属性则返回true，否则返回false\n                    // 一般情况下，应该是返回true，返回 false 的话，\n                    // 将会阻止在此 Bean 实例上调用任何后续的 \n                    // InstantiationAwareBeanPostProcessor 实例。\n                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), \n                                                           beanName)) {\n                        continueWithPropertyPopulation = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // 如果后续处理器发出停止填充命令，则终止后续操作\n        if (!continueWithPropertyPopulation) {\n            return;\n        }\n\n        // bean 的属性值，记录在bean标签中property\n        PropertyValues pvs = (mbd.hasPropertyValues() ?\n                              mbd.getPropertyValues() : null);\n\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) \n        {\n\n            // 将 PropertyValues 封装成 MutablePropertyValues 对象\n            // MutablePropertyValues 允许对属性进行简单的操作，\n            // 并提供构造函数以支持Map的深度复制和构造。\n            MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n            // 根据名称自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) \n            {\n                autowireByName(beanName, mbd, bw, newPvs);\n            }\n\n            // 根据类型自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE)\n            {\n                autowireByType(beanName, mbd, bw, newPvs);\n            }\n\n            pvs = newPvs;\n        }\n\n        // 是否已经注册了 InstantiationAwareBeanPostProcessors\n        boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n        // 是否需要进行依赖检查\n        boolean needsDepCheck = (mbd.getDependencyCheck() != \n                                 RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n        if (hasInstAwareBpps || needsDepCheck) {\n            if (pvs == null) {\n                pvs = mbd.getPropertyValues();\n            }\n\n            // 从 bw 对象中提取 PropertyDescriptor 结果集\n            // PropertyDescriptor：可以通过一对存取方法提取一个属性\n            PropertyDescriptor[] filteredPds = \n                filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n            if (hasInstAwareBpps) {\n                for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                    if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                        InstantiationAwareBeanPostProcessor ibp = \n                            (InstantiationAwareBeanPostProcessor) bp;\n                        // 对所有需要依赖检查的属性进行后处理\n                        pvs = ibp.postProcessPropertyValues(pvs, filteredPds, \n                                         bw.getWrappedInstance(), beanName);\n                        if (pvs == null) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if (needsDepCheck) {\n                // 依赖检查，对应 depends-on 属性\n                checkDependencies(beanName, mbd, filteredPds, pvs);\n            }\n        }\n\n        if (pvs != null) {\n            // 将属性应用到 bean 中\n            applyPropertyValues(beanName, mbd, bw, pvs);\n        }\n    }\n```\n\n处理流程如下：\n\n1. 根据 hasInstantiationAwareBeanPostProcessors 属性来判断是否需要在注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会，此过程可以控制 Spring 是否继续进行属性填充。\n2. 根据注入类型的不同来判断是根据名称来自动注入（`autowireByName()`）还是根据类型来自动注入（`autowireByType()`），统一存入到 PropertyValues 中，PropertyValues 用于描述 bean 的属性。\n3. 判断是否需要进行 BeanPostProcessor 和 依赖检测。\n4. 将所有 PropertyValues 中的属性填充到 BeanWrapper 中。\n\n## 自动注入\n\nSpring 会根据注入类型（ byName / byType ）的不同，调用不同的方法（`autowireByName()` / `autowireByType()`）来注入属性值。\n\n**autowireByName()**\n\n方法 `autowireByName()` 是根据属性名称完成自动依赖注入的，代码如下：\n\n```java\n    protected void autowireByName(\n            String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, \n        MutablePropertyValues pvs) {\n\n        // 获取Bean 对象中非简单属性\n        String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n        for (String propertyName : propertyNames) {\n            // 如果容器中包含指定名称的 bean，则将该 bean 注入到 bean中\n            if (containsBean(propertyName)) {\n                // 递归初始化相关 bean\n                Object bean = getBean(propertyName);\n                // 为指定名称的属性赋予属性值  \n                pvs.add(propertyName, bean);\n                // 属性依赖注入\n                registerDependentBean(propertyName, beanName);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Added autowiring by name from bean name '\" \n                                 + beanName +\n                            \"' via property '\" + propertyName \n                                 + \"' to bean named '\" + propertyName + \"'\");\n                }\n            }\n            else {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Not autowiring property '\" \n                                 + propertyName + \"' of bean '\" + beanName +\n                            \"' by name: no matching bean found\");\n                }\n            }\n        }\n    }\n```\n\n该方法逻辑很简单，获取该 bean 的非简单属性，什么叫做非简单属性呢？就是类型为对象类型的属性，但是这里并不是将所有的对象类型都都会找到，比如 8 个原始类型，String 类型 ，Number类型、Date类型、URL类型、URI类型等都会被忽略，如下：\n\n```java\n    protected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, \n                                                      BeanWrapper bw) {\n        Set<String> result = new TreeSet<>();\n        // 获取属性集合\n        PropertyValues pvs = mbd.getPropertyValues();\n        // 获取属性描述操作符的集合，也就是对属性的get/set方法包装\n        PropertyDescriptor[] pds = bw.getPropertyDescriptors();\n        // 依次进行判断，该属性是否满足有可写方法，依赖检测中没有被忽略，不是简单属性\n        for (PropertyDescriptor pd : pds) {\n            // 对\n            if (pd.getWriteMethod() != null \n                && !isExcludedFromDependencyCheck(pd) \n                && !pvs.contains(pd.getName()) \n                && !BeanUtils.isSimpleProperty(pd.getPropertyType())) {\n                result.add(pd.getName());\n            }\n        }\n        return StringUtils.toStringArray(result);\n    }\n```\n\n过滤条件为：有可写方法、依赖检测中没有被忽略、不是简单属性类型。其实这里获取的就是需要依赖注入的属性。\n\n获取需要依赖注入的属性后，通过迭代、递归的方式初始化相关的 bean，然后调用 `registerDependentBean()` 完成注册依赖，这里前面文章中已经说过，如下：\n\n```java\n    public void registerDependentBean(String beanName, String dependentBeanName) {\n        String canonicalName = canonicalName(beanName);\n\n        synchronized (this.dependentBeanMap) {\n            Set<String> dependentBeans =\n                    this.dependentBeanMap.computeIfAbsent(canonicalName, \n                                                          k -> new LinkedHashSet<>(8));\n            if (!dependentBeans.add(dependentBeanName)) {\n                return;\n            }\n        }\n\n        synchronized (this.dependenciesForBeanMap) {\n            Set<String> dependenciesForBean =\n                    this.dependenciesForBeanMap.computeIfAbsent(dependentBeanName,\n                                   k -> new LinkedHashSet<>(8));\n            dependenciesForBean.add(canonicalName);\n        }\n    }\n```\n\n**autowireByType()**\n\n```java\n protected void autowireByType(\n            String beanName, AbstractBeanDefinition mbd, \n     \t\tBeanWrapper bw, MutablePropertyValues pvs) {\n\n        // 获取 TypeConverter 实例\n        // 使用自定义的 TypeConverter，用于取代默认的 PropertyEditor 机制\n        TypeConverter converter = getCustomTypeConverter();\n        if (converter == null) {\n            converter = bw;\n        }\n\n        Set<String> autowiredBeanNames = new LinkedHashSet<>(4);\n        // 获取非简单属性\n        String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\n        for (String propertyName : propertyNames) {\n            try {\n                // 获取 PropertyDescriptor 实例\n                PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);\n\n                // 不要尝试按类型\n                if (Object.class != pd.getPropertyType()) {\n                    \n                    // 探测指定属性的 set 方法\n                    MethodParameter methodParam = \n                        BeanUtils.getWriteMethodParameter(pd);\n\n                    boolean eager = \n                        !PriorityOrdered.class.isInstance(bw.getWrappedInstance());\n                    \n                    DependencyDescriptor desc = \n                        \tnew AbstractAutowireCapableBeanFactory\n                      \t\t  .AutowireByTypeDependencyDescriptor(methodParam, eager);\n\n                    // 解析指定 beanName 的属性所匹配的值，并把解析到的属性名称存储在 \n                    // autowiredBeanNames 中\n                    // 当属性存在过个封装 bean 时将会找到所有匹配的 bean 并将其注入\n                    Object autowiredArgument = resolveDependency(desc, beanName, \n                                       autowiredBeanNames, converter);\n\n                    if (autowiredArgument != null) {\n                        pvs.add(propertyName, autowiredArgument);\n                    }\n\n                    // 迭代方式注入 bean \n                    for (String autowiredBeanName : autowibeanredBeanNames) {\n                        registerDependentBean(autowiredBeanName, beanName);\n                        if (logger.isDebugEnabled()) {\n                            // 省略日志\n                        }\n                    }\n                    autowiredBeanNames.clear();\n                }\n            }\n            catch (BeansException ex) {\n           \t\t// 省略异常\n            }\n        }\n    }\n```\n\n其实主要过程和根据名称自动注入差不多都是找到需要依赖注入的属性，然后通过迭代的方式寻找所匹配的 bean，最后调用 `registerDependentBean()` 注册依赖。不过相对于 `autowireByName()` 而言，根据类型寻找相匹配的 bean 过程比较复杂，下面我们就分析这个复杂的过程，如下：\n\n```java\n    public Object resolveDependency(DependencyDescriptor descriptor, \n                                    @Nullable String requestingBeanName,\n                                    @Nullable Set<String> autowiredBeanNames, \n                                    @Nullable TypeConverter typeConverter) \n        throws BeansException {\n\n        // 初始化参数名称发现器，该方法并不会在这个时候尝试检索参数名称\n        // getParameterNameDiscoverer 返回 parameterNameDiscoverer 实例，\n        // parameterNameDiscoverer 方法参数名称的解析器\n        descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\n\n        // 依赖类型为 Optional 类型\n        if (Optional.class == descriptor.getDependencyType()) {\n            // 创建 Optional 实例依赖类型\n            return createOptionalDependency(descriptor, requestingBeanName);\n        }\n\n        // 依赖类型为ObjectFactory、ObjectProvider\n        else if (ObjectFactory.class == descriptor.getDependencyType() ||\n                ObjectProvider.class == descriptor.getDependencyType()) {\n            // ObjectFactory、ObjectProvider 用于 用于延迟解析依赖项\n            return new DefaultListableBeanFactory.DependencyObjectProvider(descriptor, \n            \t\t\t\t\t\t\t\t\t\t\trequestingBeanName);\n        }\n\n        else if (javaxInjectProviderClass == descriptor.getDependencyType()) {\n            // javaxInjectProviderClass 类注入的特殊处理\n            return new DefaultListableBeanFactory.Jsr330ProviderFactory()\n                .createDependencyProvider(descriptor, requestingBeanName);\n        }\n        else {\n            // 为实际依赖关系目标的延迟解析构建代理\n            // 默认实现返回 null\n            Object result = getAutowireCandidateResolver()\n                .getLazyResolutionProxyIfNecessary(\n                    descriptor, requestingBeanName);\n            if (result == null) {\n                // 通用处理逻辑\n                result = doResolveDependency(descriptor, requestingBeanName, \n                                             autowiredBeanNames, typeConverter);\n            }\n            return result;\n        }\n    }\n```\n\n这里我们关注通用处理逻辑：`doResolveDependency()`，如下：\n\n```java\n    public Object doResolveDependency(DependencyDescriptor descriptor, \n                                      @Nullable String beanName,\n                                      @Nullable Set<String> autowiredBeanNames,\n                                      @Nullable TypeConverter typeConverter) \n        \t\t\t\tthrows BeansException {\n\n        // 注入点\n        InjectionPoint previousInjectionPoint = \n            ConstructorResolver.setCurrentInjectionPoint(descriptor);\n        try {\n            // 针对给定的工厂给定一个快捷实现的方式，例如考虑一些预先解析的信息\n            // 在进入所有bean的常规类型匹配算法之前，解析算法将首先尝试通过此方法解析快捷方式。\n            // 子类可以覆盖此方法\n            Object shortcut = descriptor.resolveShortcut(this);\n            if (shortcut != null) {\n                // 返回快捷的解析信息\n                return shortcut;\n            }\n\n            // 依赖的类型\n            Class<?> type = descriptor.getDependencyType();\n            // 支持 Spring 的注解 @value\n            Object value = \n                getAutowireCandidateResolver().getSuggestedValue(descriptor);\n            if (value != null) {\n                if (value instanceof String) {\n                    String strVal = resolveEmbeddedValue((String) value);\n                    BeanDefinition bd = (beanName != null && containsBean(beanName) ? \n                                         getMergedBeanDefinition(beanName) : null);\n                    value = evaluateBeanDefinitionString(strVal, bd);\n                }\n                TypeConverter converter = (typeConverter != null ? typeConverter : \n                                           getTypeConverter());\n                return (descriptor.getField() != null ?\n                        converter.convertIfNecessary(value, type, \n                                                     descriptor.getField()) :\n                        converter.convertIfNecessary(value, type, \n                                                    descriptor.getMethodParameter()));\n            }\n\n            // 解析复合 bean，其实就是对 bean 的属性进行解析\n            // 包括：数组、Collection 、Map 类型\n            Object multipleBeans = resolveMultipleBeans(descriptor, beanName, \n                              autowiredBeanNames, typeConverter);\n            if (multipleBeans != null) {\n                return multipleBeans;\n            }\n\n            // 查找与类型相匹配的 bean\n            // 返回值构成为：key = 匹配的 beanName，value = beanName 对应的实例化 bean\n            Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, \n                                                                       descriptor);\n            // 没有找到，检验 @autowire  的 require 是否为 true\n            if (matchingBeans.isEmpty()) {\n                // 如果 @autowire 的 require 属性为 true 但是没有找到相应的匹配项，则抛出异常\n                if (isRequired(descriptor)) {\n                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(),\n                                             descriptor);\n                }\n                return null;\n            }\n\n            String autowiredBeanName;\n            Object instanceCandidate;\n\n            if (matchingBeans.size() > 1) {\n                //  确认给定 bean autowire 的候选者\n                // 按照 @Primary 和 @Priority 的顺序\n                autowiredBeanName = determineAutowireCandidate(matchingBeans, \n                                                               descriptor);\n                if (autowiredBeanName == null) {\n                    if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {\n                        // 唯一性处理\n                        return descriptor.resolveNotUnique(type, matchingBeans);\n                    } else {\n                        // 在可选的Collection / Map的情况下，默默地忽略一个非唯一的情况：\n                        // 可能它是一个多个常规bean的空集合\n                        return null;\n                    }\n                }\n                instanceCandidate = matchingBeans.get(autowiredBeanName);\n            } else {\n                // We have exactly one match.\n                Map.Entry<Staring, Object> entry = \n                    matchingBeans.entrySet().iterator().next();\n                autowiredBeanName = entry.getKey();\n                instanceCandidate = entry.getValue();\n            }\n\n            if (autowiredBeanNames != null) {\n                autowiredBeanNames.add(autowiredBeanName);\n            }\n            if (instanceCandidate instanceof Class) {\n                instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, \n                                                                type, this);\n            }\n            Object result = instanceCandidate;\n            if (result instanceof NullBean) {\n                if (isRequired(descriptor)) {\n                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), \n                                             descriptor);\n                }\n                result = null;\n            }\n            if (!ClassUtils.isAssignableValue(type, result)) {\n                throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, \n                                                        instanceCandidate.getClass());\n            }\n            return result;\n        } finally {\n            ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n        }\n    }\n```\n\n到这里就已经完成了所有注入属性的获取。`populateBean()` 该方法就已经完成了一大半工作了，下一步则是对依赖 bean 的检测和 PostProcessor 处理，这个我们后面分析，下面分析该方法的最后一步：`applyPropertyValues()`\n\n## applyPropertyValues\n\n其实上面只是完成了所有注入属性的获取，将获取的属性封装在 PropertyValues 的实例对象 pvs 中，并没有应用到已经实例化的 bean 中，而 `applyPropertyValues()` 则是完成这一步骤的。\n\n```java\n   protected void applyPropertyValues(String beanName, BeanDefinition mbd, \n                                      BeanWrapper bw, PropertyValues pvs) {\n        if (pvs.isEmpty()) {\n            return;\n        }\n\n        if (System.getSecurityManager() != null && bw instanceof BeanWrapperImpl) {\n            ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());\n        }\n\n        // MutablePropertyValues 类型属性\n        MutablePropertyValues mpvs = null;\n        // 原始类型\n        List<PropertyValue> original;\n\n\n        if (pvs instanceof MutablePropertyValues) {\n            mpvs = (MutablePropertyValues) pvs;\n            if (mpvs.isConverted()) {\n                try {\n                    // 设置到 BeanWrapper 中去\n                    bw.setPropertyValues(mpvs);\n                    return;\n                }\n                catch (BeansException ex) {\n                    throw new BeanCreationException(\n                            mbd.getResourceDescription(), beanName, \n                        \"Error setting property values\", ex);\n                }\n            }\n            original = mpvs.getPropertyValueList();\n        }\n        else {\n            // 如果 pvs 不是 MutablePropertyValues 类型，则直接使用原始类型\n            original = Arrays.asList(pvs.getPropertyValues());\n        }\n\n        // 获取 TypeConverter\n        TypeConverter converter = getCustomTypeConverter();\n        if (converter == null) {\n            converter = bw;\n        }\n\n        // 获取对应的解析器\n        BeanDefinitionValueResolver valueResolver = new \n            BeanDefinitionValueResolver(this, beanName, mbd, converter);\n\n        // Create a deep copy, resolving any references for values.\n        List<PropertyValue> deepCopy = new ArrayList<>(original.size());\n        boolean resolveNecessary = false;\n        // 遍历属性，将属性转换为对应类的对应属性的类型\n        for (PropertyValue pv : original) {\n            if (pv.isConverted()) {\n                deepCopy.add(pv);\n            }\n            else {\n                String propertyName = pv.getName();\n                Object originalValue = pv.getValue();\n                Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, \n`\t\t\t\t\t\t\toriginalValue);\n                Object convertedValue = resolvedValue;\n                boolean convertible = bw.isWritableProperty(propertyName) \n                    &&!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);\n                if (convertible) {\n                    convertedValue = convertForProperty(resolvedValue, propertyName, \n                                                        bw, converter);\n                }\n                // Possibly store converted value in merged bean definition,\n                // in order to avoid re-conversion for every created bean instance.\n                if (resolvedValue == originalValue) {\n                    if (convertible) {\n                        pv.setConvertedValue(convertedValue);\n                    }\n                    deepCopy.add(pv);\n                }\n                else if (convertible && originalValue instanceof TypedStringValue &&\n                        !((TypedStringValue) originalValue).isDynamic() &&\n                        !(convertedValue instanceof Collection || \n                          ObjectUtils.isArray(convertedValue))) {\n                    pv.setConvertedValue(convertedValue);\n                    deepCopy.add(pv);\n                }\n                else {\n                    resolveNecessary = true;\n                    deepCopy.add(new PropertyValue(pv, convertedValue));\n                }\n            }\n        }\n        if (mpvs != null && !resolveNecessary) {\n            mpvs.setConverted();\n        }\n\n        // Set our (possibly massaged) deep copy.\n        try {\n            bw.setPropertyValues(new MutablePropertyValues(deepCopy));\n        }\n        catch (BeansException ex) {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, \n                \"Error setting property values\", ex);\n        }\n    }\n```\n\n至此，`doCreateBean()` 第二个过程：属性填充 已经分析完成了，下篇分析第三个过程：循环依赖的处理，其实循环依赖并不仅仅只是在 `doCreateBean()` 中处理，其实在整个加载 bean 的过程中都有涉及，所以下篇内容并不仅仅只局限于 `doCreateBean()`。","slug":"spring 源码分析/spring/spring源码解析之 23属性填充","published":1,"updated":"2019-01-16T08:35:01.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovxo00619q1ug64acwy8","content":"<h1 id=\"spring源码解析之-23属性填充\"><a href=\"#spring源码解析之-23属性填充\" class=\"headerlink\" title=\"spring源码解析之 23属性填充\"></a>spring源码解析之 23属性填充</h1><p><code>doCreateBean()</code> 主要用于完成 bean 的创建和初始化工作，我们可以将其分为四个过程：</p>\n<ul>\n<li><code>createBeanInstance()</code> 实例化 bean</li>\n<li><code>populateBean()</code> 属性填充</li>\n<li>循环依赖的处理</li>\n<li><code>initializeBean()</code> 初始化 bean</li>\n</ul>\n<p>第一个过程实例化 bean 已经在前面两篇博客分析完毕了，这篇博客开始分析属性填充，也就是 <code>populateBean()</code>，该函数的作用是将 BeanDefinition 中的属性值赋值给 BeanWrapper 实例对象(对于 BeanWrapper 我们后续专门写文分析)。<br><a id=\"more\"></a></p>\n<pre><code class=\"java\">    protected void populateBean(String beanName, RootBeanDefinition mbd,\n                                @Nullable BeanWrapper bw) {\n        // 没有实例化对象\n        if (bw == null) {\n            // 有属性抛出异常\n            if (mbd.hasPropertyValues()) {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, \n                    &quot;Cannot apply property values to null instance&quot;);\n            }\n            else {\n                // 没有属性直接返回\n                return;\n            }\n        }\n\n        // 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会\n        boolean continueWithPropertyPopulation = true;\n\n        // bena 不是&quot;合成&quot;的，即未由应用程序本身定义\n        // 是否持有 InstantiationAwareBeanPostProcessor\n        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\n            // 迭代所有的 BeanPostProcessors\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                // 如果为 InstantiationAwareBeanPostProcessor\n                if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                    InstantiationAwareBeanPostProcessor ibp = \n                        (InstantiationAwareBeanPostProcessor) bp;\n                    // 返回值为是否继续填充 bean\n                    // postProcessAfterInstantiation：\n                    // 如果应该在 bean上面设置属性则返回true，否则返回false\n                    // 一般情况下，应该是返回true，返回 false 的话，\n                    // 将会阻止在此 Bean 实例上调用任何后续的 \n                    // InstantiationAwareBeanPostProcessor 实例。\n                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), \n                                                           beanName)) {\n                        continueWithPropertyPopulation = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // 如果后续处理器发出停止填充命令，则终止后续操作\n        if (!continueWithPropertyPopulation) {\n            return;\n        }\n\n        // bean 的属性值，记录在bean标签中property\n        PropertyValues pvs = (mbd.hasPropertyValues() ?\n                              mbd.getPropertyValues() : null);\n\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) \n        {\n\n            // 将 PropertyValues 封装成 MutablePropertyValues 对象\n            // MutablePropertyValues 允许对属性进行简单的操作，\n            // 并提供构造函数以支持Map的深度复制和构造。\n            MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n            // 根据名称自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) \n            {\n                autowireByName(beanName, mbd, bw, newPvs);\n            }\n\n            // 根据类型自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE)\n            {\n                autowireByType(beanName, mbd, bw, newPvs);\n            }\n\n            pvs = newPvs;\n        }\n\n        // 是否已经注册了 InstantiationAwareBeanPostProcessors\n        boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n        // 是否需要进行依赖检查\n        boolean needsDepCheck = (mbd.getDependencyCheck() != \n                                 RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n        if (hasInstAwareBpps || needsDepCheck) {\n            if (pvs == null) {\n                pvs = mbd.getPropertyValues();\n            }\n\n            // 从 bw 对象中提取 PropertyDescriptor 结果集\n            // PropertyDescriptor：可以通过一对存取方法提取一个属性\n            PropertyDescriptor[] filteredPds = \n                filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n            if (hasInstAwareBpps) {\n                for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                    if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                        InstantiationAwareBeanPostProcessor ibp = \n                            (InstantiationAwareBeanPostProcessor) bp;\n                        // 对所有需要依赖检查的属性进行后处理\n                        pvs = ibp.postProcessPropertyValues(pvs, filteredPds, \n                                         bw.getWrappedInstance(), beanName);\n                        if (pvs == null) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if (needsDepCheck) {\n                // 依赖检查，对应 depends-on 属性\n                checkDependencies(beanName, mbd, filteredPds, pvs);\n            }\n        }\n\n        if (pvs != null) {\n            // 将属性应用到 bean 中\n            applyPropertyValues(beanName, mbd, bw, pvs);\n        }\n    }\n</code></pre>\n<p>处理流程如下：</p>\n<ol>\n<li>根据 hasInstantiationAwareBeanPostProcessors 属性来判断是否需要在注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会，此过程可以控制 Spring 是否继续进行属性填充。</li>\n<li>根据注入类型的不同来判断是根据名称来自动注入（<code>autowireByName()</code>）还是根据类型来自动注入（<code>autowireByType()</code>），统一存入到 PropertyValues 中，PropertyValues 用于描述 bean 的属性。</li>\n<li>判断是否需要进行 BeanPostProcessor 和 依赖检测。</li>\n<li>将所有 PropertyValues 中的属性填充到 BeanWrapper 中。</li>\n</ol>\n<h2 id=\"自动注入\"><a href=\"#自动注入\" class=\"headerlink\" title=\"自动注入\"></a>自动注入</h2><p>Spring 会根据注入类型（ byName / byType ）的不同，调用不同的方法（<code>autowireByName()</code> / <code>autowireByType()</code>）来注入属性值。</p>\n<p><strong>autowireByName()</strong></p>\n<p>方法 <code>autowireByName()</code> 是根据属性名称完成自动依赖注入的，代码如下：</p>\n<pre><code class=\"java\">    protected void autowireByName(\n            String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, \n        MutablePropertyValues pvs) {\n\n        // 获取Bean 对象中非简单属性\n        String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n        for (String propertyName : propertyNames) {\n            // 如果容器中包含指定名称的 bean，则将该 bean 注入到 bean中\n            if (containsBean(propertyName)) {\n                // 递归初始化相关 bean\n                Object bean = getBean(propertyName);\n                // 为指定名称的属性赋予属性值  \n                pvs.add(propertyName, bean);\n                // 属性依赖注入\n                registerDependentBean(propertyName, beanName);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(&quot;Added autowiring by name from bean name &#39;&quot; \n                                 + beanName +\n                            &quot;&#39; via property &#39;&quot; + propertyName \n                                 + &quot;&#39; to bean named &#39;&quot; + propertyName + &quot;&#39;&quot;);\n                }\n            }\n            else {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(&quot;Not autowiring property &#39;&quot; \n                                 + propertyName + &quot;&#39; of bean &#39;&quot; + beanName +\n                            &quot;&#39; by name: no matching bean found&quot;);\n                }\n            }\n        }\n    }\n</code></pre>\n<p>该方法逻辑很简单，获取该 bean 的非简单属性，什么叫做非简单属性呢？就是类型为对象类型的属性，但是这里并不是将所有的对象类型都都会找到，比如 8 个原始类型，String 类型 ，Number类型、Date类型、URL类型、URI类型等都会被忽略，如下：</p>\n<pre><code class=\"java\">    protected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, \n                                                      BeanWrapper bw) {\n        Set&lt;String&gt; result = new TreeSet&lt;&gt;();\n        // 获取属性集合\n        PropertyValues pvs = mbd.getPropertyValues();\n        // 获取属性描述操作符的集合，也就是对属性的get/set方法包装\n        PropertyDescriptor[] pds = bw.getPropertyDescriptors();\n        // 依次进行判断，该属性是否满足有可写方法，依赖检测中没有被忽略，不是简单属性\n        for (PropertyDescriptor pd : pds) {\n            // 对\n            if (pd.getWriteMethod() != null \n                &amp;&amp; !isExcludedFromDependencyCheck(pd) \n                &amp;&amp; !pvs.contains(pd.getName()) \n                &amp;&amp; !BeanUtils.isSimpleProperty(pd.getPropertyType())) {\n                result.add(pd.getName());\n            }\n        }\n        return StringUtils.toStringArray(result);\n    }\n</code></pre>\n<p>过滤条件为：有可写方法、依赖检测中没有被忽略、不是简单属性类型。其实这里获取的就是需要依赖注入的属性。</p>\n<p>获取需要依赖注入的属性后，通过迭代、递归的方式初始化相关的 bean，然后调用 <code>registerDependentBean()</code> 完成注册依赖，这里前面文章中已经说过，如下：</p>\n<pre><code class=\"java\">    public void registerDependentBean(String beanName, String dependentBeanName) {\n        String canonicalName = canonicalName(beanName);\n\n        synchronized (this.dependentBeanMap) {\n            Set&lt;String&gt; dependentBeans =\n                    this.dependentBeanMap.computeIfAbsent(canonicalName, \n                                                          k -&gt; new LinkedHashSet&lt;&gt;(8));\n            if (!dependentBeans.add(dependentBeanName)) {\n                return;\n            }\n        }\n\n        synchronized (this.dependenciesForBeanMap) {\n            Set&lt;String&gt; dependenciesForBean =\n                    this.dependenciesForBeanMap.computeIfAbsent(dependentBeanName,\n                                   k -&gt; new LinkedHashSet&lt;&gt;(8));\n            dependenciesForBean.add(canonicalName);\n        }\n    }\n</code></pre>\n<p><strong>autowireByType()</strong></p>\n<pre><code class=\"java\"> protected void autowireByType(\n            String beanName, AbstractBeanDefinition mbd, \n             BeanWrapper bw, MutablePropertyValues pvs) {\n\n        // 获取 TypeConverter 实例\n        // 使用自定义的 TypeConverter，用于取代默认的 PropertyEditor 机制\n        TypeConverter converter = getCustomTypeConverter();\n        if (converter == null) {\n            converter = bw;\n        }\n\n        Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;&gt;(4);\n        // 获取非简单属性\n        String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\n        for (String propertyName : propertyNames) {\n            try {\n                // 获取 PropertyDescriptor 实例\n                PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);\n\n                // 不要尝试按类型\n                if (Object.class != pd.getPropertyType()) {\n\n                    // 探测指定属性的 set 方法\n                    MethodParameter methodParam = \n                        BeanUtils.getWriteMethodParameter(pd);\n\n                    boolean eager = \n                        !PriorityOrdered.class.isInstance(bw.getWrappedInstance());\n\n                    DependencyDescriptor desc = \n                            new AbstractAutowireCapableBeanFactory\n                                .AutowireByTypeDependencyDescriptor(methodParam, eager);\n\n                    // 解析指定 beanName 的属性所匹配的值，并把解析到的属性名称存储在 \n                    // autowiredBeanNames 中\n                    // 当属性存在过个封装 bean 时将会找到所有匹配的 bean 并将其注入\n                    Object autowiredArgument = resolveDependency(desc, beanName, \n                                       autowiredBeanNames, converter);\n\n                    if (autowiredArgument != null) {\n                        pvs.add(propertyName, autowiredArgument);\n                    }\n\n                    // 迭代方式注入 bean \n                    for (String autowiredBeanName : autowibeanredBeanNames) {\n                        registerDependentBean(autowiredBeanName, beanName);\n                        if (logger.isDebugEnabled()) {\n                            // 省略日志\n                        }\n                    }\n                    autowiredBeanNames.clear();\n                }\n            }\n            catch (BeansException ex) {\n                   // 省略异常\n            }\n        }\n    }\n</code></pre>\n<p>其实主要过程和根据名称自动注入差不多都是找到需要依赖注入的属性，然后通过迭代的方式寻找所匹配的 bean，最后调用 <code>registerDependentBean()</code> 注册依赖。不过相对于 <code>autowireByName()</code> 而言，根据类型寻找相匹配的 bean 过程比较复杂，下面我们就分析这个复杂的过程，如下：</p>\n<pre><code class=\"java\">    public Object resolveDependency(DependencyDescriptor descriptor, \n                                    @Nullable String requestingBeanName,\n                                    @Nullable Set&lt;String&gt; autowiredBeanNames, \n                                    @Nullable TypeConverter typeConverter) \n        throws BeansException {\n\n        // 初始化参数名称发现器，该方法并不会在这个时候尝试检索参数名称\n        // getParameterNameDiscoverer 返回 parameterNameDiscoverer 实例，\n        // parameterNameDiscoverer 方法参数名称的解析器\n        descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\n\n        // 依赖类型为 Optional 类型\n        if (Optional.class == descriptor.getDependencyType()) {\n            // 创建 Optional 实例依赖类型\n            return createOptionalDependency(descriptor, requestingBeanName);\n        }\n\n        // 依赖类型为ObjectFactory、ObjectProvider\n        else if (ObjectFactory.class == descriptor.getDependencyType() ||\n                ObjectProvider.class == descriptor.getDependencyType()) {\n            // ObjectFactory、ObjectProvider 用于 用于延迟解析依赖项\n            return new DefaultListableBeanFactory.DependencyObjectProvider(descriptor, \n                                                        requestingBeanName);\n        }\n\n        else if (javaxInjectProviderClass == descriptor.getDependencyType()) {\n            // javaxInjectProviderClass 类注入的特殊处理\n            return new DefaultListableBeanFactory.Jsr330ProviderFactory()\n                .createDependencyProvider(descriptor, requestingBeanName);\n        }\n        else {\n            // 为实际依赖关系目标的延迟解析构建代理\n            // 默认实现返回 null\n            Object result = getAutowireCandidateResolver()\n                .getLazyResolutionProxyIfNecessary(\n                    descriptor, requestingBeanName);\n            if (result == null) {\n                // 通用处理逻辑\n                result = doResolveDependency(descriptor, requestingBeanName, \n                                             autowiredBeanNames, typeConverter);\n            }\n            return result;\n        }\n    }\n</code></pre>\n<p>这里我们关注通用处理逻辑：<code>doResolveDependency()</code>，如下：</p>\n<pre><code class=\"java\">    public Object doResolveDependency(DependencyDescriptor descriptor, \n                                      @Nullable String beanName,\n                                      @Nullable Set&lt;String&gt; autowiredBeanNames,\n                                      @Nullable TypeConverter typeConverter) \n                        throws BeansException {\n\n        // 注入点\n        InjectionPoint previousInjectionPoint = \n            ConstructorResolver.setCurrentInjectionPoint(descriptor);\n        try {\n            // 针对给定的工厂给定一个快捷实现的方式，例如考虑一些预先解析的信息\n            // 在进入所有bean的常规类型匹配算法之前，解析算法将首先尝试通过此方法解析快捷方式。\n            // 子类可以覆盖此方法\n            Object shortcut = descriptor.resolveShortcut(this);\n            if (shortcut != null) {\n                // 返回快捷的解析信息\n                return shortcut;\n            }\n\n            // 依赖的类型\n            Class&lt;?&gt; type = descriptor.getDependencyType();\n            // 支持 Spring 的注解 @value\n            Object value = \n                getAutowireCandidateResolver().getSuggestedValue(descriptor);\n            if (value != null) {\n                if (value instanceof String) {\n                    String strVal = resolveEmbeddedValue((String) value);\n                    BeanDefinition bd = (beanName != null &amp;&amp; containsBean(beanName) ? \n                                         getMergedBeanDefinition(beanName) : null);\n                    value = evaluateBeanDefinitionString(strVal, bd);\n                }\n                TypeConverter converter = (typeConverter != null ? typeConverter : \n                                           getTypeConverter());\n                return (descriptor.getField() != null ?\n                        converter.convertIfNecessary(value, type, \n                                                     descriptor.getField()) :\n                        converter.convertIfNecessary(value, type, \n                                                    descriptor.getMethodParameter()));\n            }\n\n            // 解析复合 bean，其实就是对 bean 的属性进行解析\n            // 包括：数组、Collection 、Map 类型\n            Object multipleBeans = resolveMultipleBeans(descriptor, beanName, \n                              autowiredBeanNames, typeConverter);\n            if (multipleBeans != null) {\n                return multipleBeans;\n            }\n\n            // 查找与类型相匹配的 bean\n            // 返回值构成为：key = 匹配的 beanName，value = beanName 对应的实例化 bean\n            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, \n                                                                       descriptor);\n            // 没有找到，检验 @autowire  的 require 是否为 true\n            if (matchingBeans.isEmpty()) {\n                // 如果 @autowire 的 require 属性为 true 但是没有找到相应的匹配项，则抛出异常\n                if (isRequired(descriptor)) {\n                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(),\n                                             descriptor);\n                }\n                return null;\n            }\n\n            String autowiredBeanName;\n            Object instanceCandidate;\n\n            if (matchingBeans.size() &gt; 1) {\n                //  确认给定 bean autowire 的候选者\n                // 按照 @Primary 和 @Priority 的顺序\n                autowiredBeanName = determineAutowireCandidate(matchingBeans, \n                                                               descriptor);\n                if (autowiredBeanName == null) {\n                    if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {\n                        // 唯一性处理\n                        return descriptor.resolveNotUnique(type, matchingBeans);\n                    } else {\n                        // 在可选的Collection / Map的情况下，默默地忽略一个非唯一的情况：\n                        // 可能它是一个多个常规bean的空集合\n                        return null;\n                    }\n                }\n                instanceCandidate = matchingBeans.get(autowiredBeanName);\n            } else {\n                // We have exactly one match.\n                Map.Entry&lt;Staring, Object&gt; entry = \n                    matchingBeans.entrySet().iterator().next();\n                autowiredBeanName = entry.getKey();\n                instanceCandidate = entry.getValue();\n            }\n\n            if (autowiredBeanNames != null) {\n                autowiredBeanNames.add(autowiredBeanName);\n            }\n            if (instanceCandidate instanceof Class) {\n                instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, \n                                                                type, this);\n            }\n            Object result = instanceCandidate;\n            if (result instanceof NullBean) {\n                if (isRequired(descriptor)) {\n                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), \n                                             descriptor);\n                }\n                result = null;\n            }\n            if (!ClassUtils.isAssignableValue(type, result)) {\n                throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, \n                                                        instanceCandidate.getClass());\n            }\n            return result;\n        } finally {\n            ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n        }\n    }\n</code></pre>\n<p>到这里就已经完成了所有注入属性的获取。<code>populateBean()</code> 该方法就已经完成了一大半工作了，下一步则是对依赖 bean 的检测和 PostProcessor 处理，这个我们后面分析，下面分析该方法的最后一步：<code>applyPropertyValues()</code></p>\n<h2 id=\"applyPropertyValues\"><a href=\"#applyPropertyValues\" class=\"headerlink\" title=\"applyPropertyValues\"></a>applyPropertyValues</h2><p>其实上面只是完成了所有注入属性的获取，将获取的属性封装在 PropertyValues 的实例对象 pvs 中，并没有应用到已经实例化的 bean 中，而 <code>applyPropertyValues()</code> 则是完成这一步骤的。</p>\n<pre><code class=\"java\">   protected void applyPropertyValues(String beanName, BeanDefinition mbd, \n                                      BeanWrapper bw, PropertyValues pvs) {\n        if (pvs.isEmpty()) {\n            return;\n        }\n\n        if (System.getSecurityManager() != null &amp;&amp; bw instanceof BeanWrapperImpl) {\n            ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());\n        }\n\n        // MutablePropertyValues 类型属性\n        MutablePropertyValues mpvs = null;\n        // 原始类型\n        List&lt;PropertyValue&gt; original;\n\n\n        if (pvs instanceof MutablePropertyValues) {\n            mpvs = (MutablePropertyValues) pvs;\n            if (mpvs.isConverted()) {\n                try {\n                    // 设置到 BeanWrapper 中去\n                    bw.setPropertyValues(mpvs);\n                    return;\n                }\n                catch (BeansException ex) {\n                    throw new BeanCreationException(\n                            mbd.getResourceDescription(), beanName, \n                        &quot;Error setting property values&quot;, ex);\n                }\n            }\n            original = mpvs.getPropertyValueList();\n        }\n        else {\n            // 如果 pvs 不是 MutablePropertyValues 类型，则直接使用原始类型\n            original = Arrays.asList(pvs.getPropertyValues());\n        }\n\n        // 获取 TypeConverter\n        TypeConverter converter = getCustomTypeConverter();\n        if (converter == null) {\n            converter = bw;\n        }\n\n        // 获取对应的解析器\n        BeanDefinitionValueResolver valueResolver = new \n            BeanDefinitionValueResolver(this, beanName, mbd, converter);\n\n        // Create a deep copy, resolving any references for values.\n        List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;&gt;(original.size());\n        boolean resolveNecessary = false;\n        // 遍历属性，将属性转换为对应类的对应属性的类型\n        for (PropertyValue pv : original) {\n            if (pv.isConverted()) {\n                deepCopy.add(pv);\n            }\n            else {\n                String propertyName = pv.getName();\n                Object originalValue = pv.getValue();\n                Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, \n`                            originalValue);\n                Object convertedValue = resolvedValue;\n                boolean convertible = bw.isWritableProperty(propertyName) \n                    &amp;&amp;!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);\n                if (convertible) {\n                    convertedValue = convertForProperty(resolvedValue, propertyName, \n                                                        bw, converter);\n                }\n                // Possibly store converted value in merged bean definition,\n                // in order to avoid re-conversion for every created bean instance.\n                if (resolvedValue == originalValue) {\n                    if (convertible) {\n                        pv.setConvertedValue(convertedValue);\n                    }\n                    deepCopy.add(pv);\n                }\n                else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp;\n                        !((TypedStringValue) originalValue).isDynamic() &amp;&amp;\n                        !(convertedValue instanceof Collection || \n                          ObjectUtils.isArray(convertedValue))) {\n                    pv.setConvertedValue(convertedValue);\n                    deepCopy.add(pv);\n                }\n                else {\n                    resolveNecessary = true;\n                    deepCopy.add(new PropertyValue(pv, convertedValue));\n                }\n            }\n        }\n        if (mpvs != null &amp;&amp; !resolveNecessary) {\n            mpvs.setConverted();\n        }\n\n        // Set our (possibly massaged) deep copy.\n        try {\n            bw.setPropertyValues(new MutablePropertyValues(deepCopy));\n        }\n        catch (BeansException ex) {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, \n                &quot;Error setting property values&quot;, ex);\n        }\n    }\n</code></pre>\n<p>至此，<code>doCreateBean()</code> 第二个过程：属性填充 已经分析完成了，下篇分析第三个过程：循环依赖的处理，其实循环依赖并不仅仅只是在 <code>doCreateBean()</code> 中处理，其实在整个加载 bean 的过程中都有涉及，所以下篇内容并不仅仅只局限于 <code>doCreateBean()</code>。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-23属性填充\"><a href=\"#spring源码解析之-23属性填充\" class=\"headerlink\" title=\"spring源码解析之 23属性填充\"></a>spring源码解析之 23属性填充</h1><p><code>doCreateBean()</code> 主要用于完成 bean 的创建和初始化工作，我们可以将其分为四个过程：</p>\n<ul>\n<li><code>createBeanInstance()</code> 实例化 bean</li>\n<li><code>populateBean()</code> 属性填充</li>\n<li>循环依赖的处理</li>\n<li><code>initializeBean()</code> 初始化 bean</li>\n</ul>\n<p>第一个过程实例化 bean 已经在前面两篇博客分析完毕了，这篇博客开始分析属性填充，也就是 <code>populateBean()</code>，该函数的作用是将 BeanDefinition 中的属性值赋值给 BeanWrapper 实例对象(对于 BeanWrapper 我们后续专门写文分析)。<br>","more":"</p>\n<pre><code class=\"java\">    protected void populateBean(String beanName, RootBeanDefinition mbd,\n                                @Nullable BeanWrapper bw) {\n        // 没有实例化对象\n        if (bw == null) {\n            // 有属性抛出异常\n            if (mbd.hasPropertyValues()) {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, \n                    &quot;Cannot apply property values to null instance&quot;);\n            }\n            else {\n                // 没有属性直接返回\n                return;\n            }\n        }\n\n        // 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会\n        boolean continueWithPropertyPopulation = true;\n\n        // bena 不是&quot;合成&quot;的，即未由应用程序本身定义\n        // 是否持有 InstantiationAwareBeanPostProcessor\n        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\n            // 迭代所有的 BeanPostProcessors\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                // 如果为 InstantiationAwareBeanPostProcessor\n                if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                    InstantiationAwareBeanPostProcessor ibp = \n                        (InstantiationAwareBeanPostProcessor) bp;\n                    // 返回值为是否继续填充 bean\n                    // postProcessAfterInstantiation：\n                    // 如果应该在 bean上面设置属性则返回true，否则返回false\n                    // 一般情况下，应该是返回true，返回 false 的话，\n                    // 将会阻止在此 Bean 实例上调用任何后续的 \n                    // InstantiationAwareBeanPostProcessor 实例。\n                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), \n                                                           beanName)) {\n                        continueWithPropertyPopulation = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // 如果后续处理器发出停止填充命令，则终止后续操作\n        if (!continueWithPropertyPopulation) {\n            return;\n        }\n\n        // bean 的属性值，记录在bean标签中property\n        PropertyValues pvs = (mbd.hasPropertyValues() ?\n                              mbd.getPropertyValues() : null);\n\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) \n        {\n\n            // 将 PropertyValues 封装成 MutablePropertyValues 对象\n            // MutablePropertyValues 允许对属性进行简单的操作，\n            // 并提供构造函数以支持Map的深度复制和构造。\n            MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n            // 根据名称自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) \n            {\n                autowireByName(beanName, mbd, bw, newPvs);\n            }\n\n            // 根据类型自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE)\n            {\n                autowireByType(beanName, mbd, bw, newPvs);\n            }\n\n            pvs = newPvs;\n        }\n\n        // 是否已经注册了 InstantiationAwareBeanPostProcessors\n        boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n        // 是否需要进行依赖检查\n        boolean needsDepCheck = (mbd.getDependencyCheck() != \n                                 RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n        if (hasInstAwareBpps || needsDepCheck) {\n            if (pvs == null) {\n                pvs = mbd.getPropertyValues();\n            }\n\n            // 从 bw 对象中提取 PropertyDescriptor 结果集\n            // PropertyDescriptor：可以通过一对存取方法提取一个属性\n            PropertyDescriptor[] filteredPds = \n                filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n            if (hasInstAwareBpps) {\n                for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                    if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                        InstantiationAwareBeanPostProcessor ibp = \n                            (InstantiationAwareBeanPostProcessor) bp;\n                        // 对所有需要依赖检查的属性进行后处理\n                        pvs = ibp.postProcessPropertyValues(pvs, filteredPds, \n                                         bw.getWrappedInstance(), beanName);\n                        if (pvs == null) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if (needsDepCheck) {\n                // 依赖检查，对应 depends-on 属性\n                checkDependencies(beanName, mbd, filteredPds, pvs);\n            }\n        }\n\n        if (pvs != null) {\n            // 将属性应用到 bean 中\n            applyPropertyValues(beanName, mbd, bw, pvs);\n        }\n    }\n</code></pre>\n<p>处理流程如下：</p>\n<ol>\n<li>根据 hasInstantiationAwareBeanPostProcessors 属性来判断是否需要在注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会，此过程可以控制 Spring 是否继续进行属性填充。</li>\n<li>根据注入类型的不同来判断是根据名称来自动注入（<code>autowireByName()</code>）还是根据类型来自动注入（<code>autowireByType()</code>），统一存入到 PropertyValues 中，PropertyValues 用于描述 bean 的属性。</li>\n<li>判断是否需要进行 BeanPostProcessor 和 依赖检测。</li>\n<li>将所有 PropertyValues 中的属性填充到 BeanWrapper 中。</li>\n</ol>\n<h2 id=\"自动注入\"><a href=\"#自动注入\" class=\"headerlink\" title=\"自动注入\"></a>自动注入</h2><p>Spring 会根据注入类型（ byName / byType ）的不同，调用不同的方法（<code>autowireByName()</code> / <code>autowireByType()</code>）来注入属性值。</p>\n<p><strong>autowireByName()</strong></p>\n<p>方法 <code>autowireByName()</code> 是根据属性名称完成自动依赖注入的，代码如下：</p>\n<pre><code class=\"java\">    protected void autowireByName(\n            String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, \n        MutablePropertyValues pvs) {\n\n        // 获取Bean 对象中非简单属性\n        String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n        for (String propertyName : propertyNames) {\n            // 如果容器中包含指定名称的 bean，则将该 bean 注入到 bean中\n            if (containsBean(propertyName)) {\n                // 递归初始化相关 bean\n                Object bean = getBean(propertyName);\n                // 为指定名称的属性赋予属性值  \n                pvs.add(propertyName, bean);\n                // 属性依赖注入\n                registerDependentBean(propertyName, beanName);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(&quot;Added autowiring by name from bean name &#39;&quot; \n                                 + beanName +\n                            &quot;&#39; via property &#39;&quot; + propertyName \n                                 + &quot;&#39; to bean named &#39;&quot; + propertyName + &quot;&#39;&quot;);\n                }\n            }\n            else {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(&quot;Not autowiring property &#39;&quot; \n                                 + propertyName + &quot;&#39; of bean &#39;&quot; + beanName +\n                            &quot;&#39; by name: no matching bean found&quot;);\n                }\n            }\n        }\n    }\n</code></pre>\n<p>该方法逻辑很简单，获取该 bean 的非简单属性，什么叫做非简单属性呢？就是类型为对象类型的属性，但是这里并不是将所有的对象类型都都会找到，比如 8 个原始类型，String 类型 ，Number类型、Date类型、URL类型、URI类型等都会被忽略，如下：</p>\n<pre><code class=\"java\">    protected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, \n                                                      BeanWrapper bw) {\n        Set&lt;String&gt; result = new TreeSet&lt;&gt;();\n        // 获取属性集合\n        PropertyValues pvs = mbd.getPropertyValues();\n        // 获取属性描述操作符的集合，也就是对属性的get/set方法包装\n        PropertyDescriptor[] pds = bw.getPropertyDescriptors();\n        // 依次进行判断，该属性是否满足有可写方法，依赖检测中没有被忽略，不是简单属性\n        for (PropertyDescriptor pd : pds) {\n            // 对\n            if (pd.getWriteMethod() != null \n                &amp;&amp; !isExcludedFromDependencyCheck(pd) \n                &amp;&amp; !pvs.contains(pd.getName()) \n                &amp;&amp; !BeanUtils.isSimpleProperty(pd.getPropertyType())) {\n                result.add(pd.getName());\n            }\n        }\n        return StringUtils.toStringArray(result);\n    }\n</code></pre>\n<p>过滤条件为：有可写方法、依赖检测中没有被忽略、不是简单属性类型。其实这里获取的就是需要依赖注入的属性。</p>\n<p>获取需要依赖注入的属性后，通过迭代、递归的方式初始化相关的 bean，然后调用 <code>registerDependentBean()</code> 完成注册依赖，这里前面文章中已经说过，如下：</p>\n<pre><code class=\"java\">    public void registerDependentBean(String beanName, String dependentBeanName) {\n        String canonicalName = canonicalName(beanName);\n\n        synchronized (this.dependentBeanMap) {\n            Set&lt;String&gt; dependentBeans =\n                    this.dependentBeanMap.computeIfAbsent(canonicalName, \n                                                          k -&gt; new LinkedHashSet&lt;&gt;(8));\n            if (!dependentBeans.add(dependentBeanName)) {\n                return;\n            }\n        }\n\n        synchronized (this.dependenciesForBeanMap) {\n            Set&lt;String&gt; dependenciesForBean =\n                    this.dependenciesForBeanMap.computeIfAbsent(dependentBeanName,\n                                   k -&gt; new LinkedHashSet&lt;&gt;(8));\n            dependenciesForBean.add(canonicalName);\n        }\n    }\n</code></pre>\n<p><strong>autowireByType()</strong></p>\n<pre><code class=\"java\"> protected void autowireByType(\n            String beanName, AbstractBeanDefinition mbd, \n             BeanWrapper bw, MutablePropertyValues pvs) {\n\n        // 获取 TypeConverter 实例\n        // 使用自定义的 TypeConverter，用于取代默认的 PropertyEditor 机制\n        TypeConverter converter = getCustomTypeConverter();\n        if (converter == null) {\n            converter = bw;\n        }\n\n        Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;&gt;(4);\n        // 获取非简单属性\n        String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\n        for (String propertyName : propertyNames) {\n            try {\n                // 获取 PropertyDescriptor 实例\n                PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);\n\n                // 不要尝试按类型\n                if (Object.class != pd.getPropertyType()) {\n\n                    // 探测指定属性的 set 方法\n                    MethodParameter methodParam = \n                        BeanUtils.getWriteMethodParameter(pd);\n\n                    boolean eager = \n                        !PriorityOrdered.class.isInstance(bw.getWrappedInstance());\n\n                    DependencyDescriptor desc = \n                            new AbstractAutowireCapableBeanFactory\n                                .AutowireByTypeDependencyDescriptor(methodParam, eager);\n\n                    // 解析指定 beanName 的属性所匹配的值，并把解析到的属性名称存储在 \n                    // autowiredBeanNames 中\n                    // 当属性存在过个封装 bean 时将会找到所有匹配的 bean 并将其注入\n                    Object autowiredArgument = resolveDependency(desc, beanName, \n                                       autowiredBeanNames, converter);\n\n                    if (autowiredArgument != null) {\n                        pvs.add(propertyName, autowiredArgument);\n                    }\n\n                    // 迭代方式注入 bean \n                    for (String autowiredBeanName : autowibeanredBeanNames) {\n                        registerDependentBean(autowiredBeanName, beanName);\n                        if (logger.isDebugEnabled()) {\n                            // 省略日志\n                        }\n                    }\n                    autowiredBeanNames.clear();\n                }\n            }\n            catch (BeansException ex) {\n                   // 省略异常\n            }\n        }\n    }\n</code></pre>\n<p>其实主要过程和根据名称自动注入差不多都是找到需要依赖注入的属性，然后通过迭代的方式寻找所匹配的 bean，最后调用 <code>registerDependentBean()</code> 注册依赖。不过相对于 <code>autowireByName()</code> 而言，根据类型寻找相匹配的 bean 过程比较复杂，下面我们就分析这个复杂的过程，如下：</p>\n<pre><code class=\"java\">    public Object resolveDependency(DependencyDescriptor descriptor, \n                                    @Nullable String requestingBeanName,\n                                    @Nullable Set&lt;String&gt; autowiredBeanNames, \n                                    @Nullable TypeConverter typeConverter) \n        throws BeansException {\n\n        // 初始化参数名称发现器，该方法并不会在这个时候尝试检索参数名称\n        // getParameterNameDiscoverer 返回 parameterNameDiscoverer 实例，\n        // parameterNameDiscoverer 方法参数名称的解析器\n        descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\n\n        // 依赖类型为 Optional 类型\n        if (Optional.class == descriptor.getDependencyType()) {\n            // 创建 Optional 实例依赖类型\n            return createOptionalDependency(descriptor, requestingBeanName);\n        }\n\n        // 依赖类型为ObjectFactory、ObjectProvider\n        else if (ObjectFactory.class == descriptor.getDependencyType() ||\n                ObjectProvider.class == descriptor.getDependencyType()) {\n            // ObjectFactory、ObjectProvider 用于 用于延迟解析依赖项\n            return new DefaultListableBeanFactory.DependencyObjectProvider(descriptor, \n                                                        requestingBeanName);\n        }\n\n        else if (javaxInjectProviderClass == descriptor.getDependencyType()) {\n            // javaxInjectProviderClass 类注入的特殊处理\n            return new DefaultListableBeanFactory.Jsr330ProviderFactory()\n                .createDependencyProvider(descriptor, requestingBeanName);\n        }\n        else {\n            // 为实际依赖关系目标的延迟解析构建代理\n            // 默认实现返回 null\n            Object result = getAutowireCandidateResolver()\n                .getLazyResolutionProxyIfNecessary(\n                    descriptor, requestingBeanName);\n            if (result == null) {\n                // 通用处理逻辑\n                result = doResolveDependency(descriptor, requestingBeanName, \n                                             autowiredBeanNames, typeConverter);\n            }\n            return result;\n        }\n    }\n</code></pre>\n<p>这里我们关注通用处理逻辑：<code>doResolveDependency()</code>，如下：</p>\n<pre><code class=\"java\">    public Object doResolveDependency(DependencyDescriptor descriptor, \n                                      @Nullable String beanName,\n                                      @Nullable Set&lt;String&gt; autowiredBeanNames,\n                                      @Nullable TypeConverter typeConverter) \n                        throws BeansException {\n\n        // 注入点\n        InjectionPoint previousInjectionPoint = \n            ConstructorResolver.setCurrentInjectionPoint(descriptor);\n        try {\n            // 针对给定的工厂给定一个快捷实现的方式，例如考虑一些预先解析的信息\n            // 在进入所有bean的常规类型匹配算法之前，解析算法将首先尝试通过此方法解析快捷方式。\n            // 子类可以覆盖此方法\n            Object shortcut = descriptor.resolveShortcut(this);\n            if (shortcut != null) {\n                // 返回快捷的解析信息\n                return shortcut;\n            }\n\n            // 依赖的类型\n            Class&lt;?&gt; type = descriptor.getDependencyType();\n            // 支持 Spring 的注解 @value\n            Object value = \n                getAutowireCandidateResolver().getSuggestedValue(descriptor);\n            if (value != null) {\n                if (value instanceof String) {\n                    String strVal = resolveEmbeddedValue((String) value);\n                    BeanDefinition bd = (beanName != null &amp;&amp; containsBean(beanName) ? \n                                         getMergedBeanDefinition(beanName) : null);\n                    value = evaluateBeanDefinitionString(strVal, bd);\n                }\n                TypeConverter converter = (typeConverter != null ? typeConverter : \n                                           getTypeConverter());\n                return (descriptor.getField() != null ?\n                        converter.convertIfNecessary(value, type, \n                                                     descriptor.getField()) :\n                        converter.convertIfNecessary(value, type, \n                                                    descriptor.getMethodParameter()));\n            }\n\n            // 解析复合 bean，其实就是对 bean 的属性进行解析\n            // 包括：数组、Collection 、Map 类型\n            Object multipleBeans = resolveMultipleBeans(descriptor, beanName, \n                              autowiredBeanNames, typeConverter);\n            if (multipleBeans != null) {\n                return multipleBeans;\n            }\n\n            // 查找与类型相匹配的 bean\n            // 返回值构成为：key = 匹配的 beanName，value = beanName 对应的实例化 bean\n            Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, \n                                                                       descriptor);\n            // 没有找到，检验 @autowire  的 require 是否为 true\n            if (matchingBeans.isEmpty()) {\n                // 如果 @autowire 的 require 属性为 true 但是没有找到相应的匹配项，则抛出异常\n                if (isRequired(descriptor)) {\n                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(),\n                                             descriptor);\n                }\n                return null;\n            }\n\n            String autowiredBeanName;\n            Object instanceCandidate;\n\n            if (matchingBeans.size() &gt; 1) {\n                //  确认给定 bean autowire 的候选者\n                // 按照 @Primary 和 @Priority 的顺序\n                autowiredBeanName = determineAutowireCandidate(matchingBeans, \n                                                               descriptor);\n                if (autowiredBeanName == null) {\n                    if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {\n                        // 唯一性处理\n                        return descriptor.resolveNotUnique(type, matchingBeans);\n                    } else {\n                        // 在可选的Collection / Map的情况下，默默地忽略一个非唯一的情况：\n                        // 可能它是一个多个常规bean的空集合\n                        return null;\n                    }\n                }\n                instanceCandidate = matchingBeans.get(autowiredBeanName);\n            } else {\n                // We have exactly one match.\n                Map.Entry&lt;Staring, Object&gt; entry = \n                    matchingBeans.entrySet().iterator().next();\n                autowiredBeanName = entry.getKey();\n                instanceCandidate = entry.getValue();\n            }\n\n            if (autowiredBeanNames != null) {\n                autowiredBeanNames.add(autowiredBeanName);\n            }\n            if (instanceCandidate instanceof Class) {\n                instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, \n                                                                type, this);\n            }\n            Object result = instanceCandidate;\n            if (result instanceof NullBean) {\n                if (isRequired(descriptor)) {\n                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), \n                                             descriptor);\n                }\n                result = null;\n            }\n            if (!ClassUtils.isAssignableValue(type, result)) {\n                throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, \n                                                        instanceCandidate.getClass());\n            }\n            return result;\n        } finally {\n            ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n        }\n    }\n</code></pre>\n<p>到这里就已经完成了所有注入属性的获取。<code>populateBean()</code> 该方法就已经完成了一大半工作了，下一步则是对依赖 bean 的检测和 PostProcessor 处理，这个我们后面分析，下面分析该方法的最后一步：<code>applyPropertyValues()</code></p>\n<h2 id=\"applyPropertyValues\"><a href=\"#applyPropertyValues\" class=\"headerlink\" title=\"applyPropertyValues\"></a>applyPropertyValues</h2><p>其实上面只是完成了所有注入属性的获取，将获取的属性封装在 PropertyValues 的实例对象 pvs 中，并没有应用到已经实例化的 bean 中，而 <code>applyPropertyValues()</code> 则是完成这一步骤的。</p>\n<pre><code class=\"java\">   protected void applyPropertyValues(String beanName, BeanDefinition mbd, \n                                      BeanWrapper bw, PropertyValues pvs) {\n        if (pvs.isEmpty()) {\n            return;\n        }\n\n        if (System.getSecurityManager() != null &amp;&amp; bw instanceof BeanWrapperImpl) {\n            ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());\n        }\n\n        // MutablePropertyValues 类型属性\n        MutablePropertyValues mpvs = null;\n        // 原始类型\n        List&lt;PropertyValue&gt; original;\n\n\n        if (pvs instanceof MutablePropertyValues) {\n            mpvs = (MutablePropertyValues) pvs;\n            if (mpvs.isConverted()) {\n                try {\n                    // 设置到 BeanWrapper 中去\n                    bw.setPropertyValues(mpvs);\n                    return;\n                }\n                catch (BeansException ex) {\n                    throw new BeanCreationException(\n                            mbd.getResourceDescription(), beanName, \n                        &quot;Error setting property values&quot;, ex);\n                }\n            }\n            original = mpvs.getPropertyValueList();\n        }\n        else {\n            // 如果 pvs 不是 MutablePropertyValues 类型，则直接使用原始类型\n            original = Arrays.asList(pvs.getPropertyValues());\n        }\n\n        // 获取 TypeConverter\n        TypeConverter converter = getCustomTypeConverter();\n        if (converter == null) {\n            converter = bw;\n        }\n\n        // 获取对应的解析器\n        BeanDefinitionValueResolver valueResolver = new \n            BeanDefinitionValueResolver(this, beanName, mbd, converter);\n\n        // Create a deep copy, resolving any references for values.\n        List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;&gt;(original.size());\n        boolean resolveNecessary = false;\n        // 遍历属性，将属性转换为对应类的对应属性的类型\n        for (PropertyValue pv : original) {\n            if (pv.isConverted()) {\n                deepCopy.add(pv);\n            }\n            else {\n                String propertyName = pv.getName();\n                Object originalValue = pv.getValue();\n                Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, \n`                            originalValue);\n                Object convertedValue = resolvedValue;\n                boolean convertible = bw.isWritableProperty(propertyName) \n                    &amp;&amp;!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);\n                if (convertible) {\n                    convertedValue = convertForProperty(resolvedValue, propertyName, \n                                                        bw, converter);\n                }\n                // Possibly store converted value in merged bean definition,\n                // in order to avoid re-conversion for every created bean instance.\n                if (resolvedValue == originalValue) {\n                    if (convertible) {\n                        pv.setConvertedValue(convertedValue);\n                    }\n                    deepCopy.add(pv);\n                }\n                else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp;\n                        !((TypedStringValue) originalValue).isDynamic() &amp;&amp;\n                        !(convertedValue instanceof Collection || \n                          ObjectUtils.isArray(convertedValue))) {\n                    pv.setConvertedValue(convertedValue);\n                    deepCopy.add(pv);\n                }\n                else {\n                    resolveNecessary = true;\n                    deepCopy.add(new PropertyValue(pv, convertedValue));\n                }\n            }\n        }\n        if (mpvs != null &amp;&amp; !resolveNecessary) {\n            mpvs.setConverted();\n        }\n\n        // Set our (possibly massaged) deep copy.\n        try {\n            bw.setPropertyValues(new MutablePropertyValues(deepCopy));\n        }\n        catch (BeansException ex) {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, \n                &quot;Error setting property values&quot;, ex);\n        }\n    }\n</code></pre>\n<p>至此，<code>doCreateBean()</code> 第二个过程：属性填充 已经分析完成了，下篇分析第三个过程：循环依赖的处理，其实循环依赖并不仅仅只是在 <code>doCreateBean()</code> 中处理，其实在整个加载 bean 的过程中都有涉及，所以下篇内容并不仅仅只局限于 <code>doCreateBean()</code>。</p>"},{"abbrlink":22,"title":"spring源码解析之 03统一资源加载","author":"fenxiutianya","date":"2019-01-13T19:39:00.000Z","_content":"# spring源码解析之 03统一资源加载\n\n### 概述\n\n1. 统一资源Resource\n2. 统一资源定位ResourceLoader\n\n### 1. 统一资源Resource\n\njava se中有一个标准类 `java.net.URL`，该类在 Java SE 中的定位为统一资源定位器（Uniform Resource Locator），但是我们知道它的实现基本只限于网络形式发布的资源的查找和定位。虽然可以通过注册特定的处理器来扩展处理不同的地址前缀，但是这通常比较麻烦。而且不易于使用。另外，实际上资源的定义比较广泛，除了网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等。而且它可以存在于任何场所，比如网络、文件系统、应用程序中。所以 `java.net.URL` 的局限性迫使 Spring 必须实现自己的资源加载策略，该资源加载策略需要满足如下要求：\n\n1. 职能划分清楚：资源的定义和资源的加载应该要有一个清晰的界限；\n2. 统一的抽象：统一的资源定义和资源加载策略。资源加载后要返回统一的抽象给客户端，客户端要对资源进行怎样的处理，应该由抽象资源接口来界定。\n\n<!-- more -->\n\n`org.springframework.core.io.Resource` 为 Spring 框架所有资源的抽象和访问接口，它继承 `org.springframework.core.io.InputStreamSource`接口。作为所有资源的统一抽象，Source 定义了一些通用的方法，由子类 `AbstractResource` 提供统一的默认实现。定义如下：\n\n```java\npublic interface Resource extends InputStreamSource {\n\n    /**\n     * 资源是否存在\n     */\n    boolean exists();\n\n    /**\n     * 资源是否可读\n     */\n    default boolean isReadable() {\n        return true;\n    }\n\n    /**\n     * 资源所代表的句柄是否被一个stream打开了\n     */\n    default boolean isOpen() {\n        return false;\n    }\n\n    /**\n     * 是否为 File\n     */\n    default boolean isFile() {\n        return false;\n    }\n\n    /**\n     * 返回资源的URL的句柄\n     */\n    URL getURL() throws IOException;\n\n    /**\n     * 返回资源的URI的句柄\n     */\n    URI getURI() throws IOException;\n\n    /**\n     * 返回资源的File的句柄\n     */\n    File getFile() throws IOException;\n\n    /**\n     * 返回 ReadableByteChannel\n     */\n    default ReadableByteChannel readableChannel() throws IOException {\n        return Channels.newChannel(getInputStream());\n    }\n\n    /**\n     * 资源内容的长度\n     */\n    long contentLength() throws IOException;\n\n    /**\n     * 资源最后的修改时间\n     */\n    long lastModified() throws IOException;\n\n    /**\n     * 根据资源的相对路径创建新资源\n     */\n    Resource createRelative(String relativePath) throws IOException;\n\n    /**\n     * 资源的文件名\n     */\n    @Nullable\n    String getFilename();\n\n    /**\n     * 资源的描述\n     */\n    String getDescription();\n\n}\n```\n\n![resource](/images/pasted-6.png)\n\n从上图可以看到，Resource 根据资源的不同类型提供不同的具体实现，如下：\n\n- FileSystemResource：对 `java.io.File` 类型资源的封装，只要是跟 File 打交道的，基本上与 FileSystemResource 也可以打交道。支持文件和 URL 的形式，实现 WritableResource 接口，且从 Spring Framework 5.0 开始，FileSystemResource 使用NIO.2 API进行读/写交互\n- ByteArrayResource：对字节数组提供的数据的封装。如果通过 InputStream 形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的 ByteArrayInputStream。\n- UrlResource：对 `java.net.URL`类型资源的封装。内部委派 URL 进行具体的资源操作。\n- ClassPathResource：class path 类型资源的实现。使用给定的 ClassLoader 或者给定的 Class 来加载资源。\n- InputStreamResource：将给定的 InputStream 作为一种资源的 Resource 的实现类。\n\nAbstractResource 为 Resource 接口的默认实现，它实现了 Resource 接口的大部分的公共实现，作为 Resource 接口中的重中之重，其定义如下：\n\n```java\npublic abstract class AbstractResource implements Resource {\n\n    /**\n     * 判断文件是否存在，若判断过程产生异常（因为会调用SecurityManager来判断），就关闭对应的流\n     */\n    @Override\n    public boolean exists() {\n        try {\n            return getFile().exists();\n        }\n        catch (IOException ex) {\n            // Fall back to stream existence: can we open the stream?\n            try {\n                InputStream is = getInputStream();\n                is.close();\n                return true;\n            }\n            catch (Throwable isEx) {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * 直接返回true，表示可读\n     */\n    @Override\n    public boolean isReadable() {\n        return true;\n    }\n\n    /**\n     * 直接返回 false，表示未被打开\n     */\n    @Override\n    public boolean isOpen() {\n        return false;\n    }\n\n    /**\n     *  直接返回false，表示不为 File\n     */\n    @Override\n    public boolean isFile() {\n        return false;\n    }\n\n    /**\n     * 抛出 FileNotFoundException 异常，交给子类实现\n     */\n    @Override\n    public URL getURL() throws IOException {\n        throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL\");\n    }\n\n    /**\n     * 基于 getURL() 返回的 URL 构建 URI\n     */\n    @Override\n    public URI getURI() throws IOException {\n        URL url = getURL();\n        try {\n            return ResourceUtils.toURI(url);\n        }\n        catch (URISyntaxException ex) {\n            throw new NestedIOException(\"Invalid URI [\" + url + \"]\", ex);\n        }\n    }\n\n    /**\n     * 抛出 FileNotFoundException 异常，交给子类实现\n     */\n    @Override\n    public File getFile() throws IOException {\n        throw new FileNotFoundException(getDescription() + \" cannot be resolved to absolute file path\");\n    }\n\n    /**\n     * 根据 getInputStream() 的返回结果构建 ReadableByteChannel\n     */\n    @Override\n    public ReadableByteChannel readableChannel() throws IOException {\n        return Channels.newChannel(getInputStream());\n    }\n\n    /**\n     * 获取资源的长度\n     *\n     * 这个资源内容长度实际就是资源的字节长度，通过全部读取一遍来判断\n     */\n    @Override\n    public long contentLength() throws IOException {\n        InputStream is = getInputStream();\n        try {\n            long size = 0;\n            byte[] buf = new byte[255];\n            int read;\n            while ((read = is.read(buf)) != -1) {\n                size += read;\n            }\n            return size;\n        }\n        finally {\n            try {\n                is.close();\n            }\n            catch (IOException ex) {\n            }\n        }\n    }\n\n    /**\n     * 返回资源最后的修改时间\n     */\n    @Override\n    public long lastModified() throws IOException {\n        long lastModified = getFileForLastModifiedCheck().lastModified();\n        if (lastModified == 0L) {\n            throw new FileNotFoundException(getDescription() +\n                    \" cannot be resolved in the file system for resolving its last-modified timestamp\");\n        }\n        return lastModified;\n    }\n\n\n    protected File getFileForLastModifiedCheck() throws IOException {\n        return getFile();\n    }\n\n    /**\n     * 交给子类实现\n     */\n    @Override\n    public Resource createRelative(String relativePath) throws IOException {\n        throw new FileNotFoundException(\"Cannot create a relative resource for \" + getDescription());\n    }\n\n    /**\n     * 获取资源名称，默认返回 null\n     */\n    @Override\n    @Nullable\n    public String getFilename() {\n        return null;\n    }\n\n\n    /**\n     * 返回资源的描述\n     */\n    @Override\n    public String toString() {\n        return getDescription();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        return (obj == this ||\n            (obj instanceof Resource && ((Resource) obj).getDescription().equals(getDescription())));\n    }\n\n    @Override\n    public int hashCode() {\n        return getDescription().hashCode();\n    }\n\n}\n```\n\n如果我们想要实现自定义的 Resource，记住不要实现 Resource 接口，而应该继承 AbstractResource 抽象类，然后根据当前的具体资源特性覆盖相应的方法即可。\n\n### 2. 统一资源定位：ResourceLoader\n\n一开始就说了 Spring 将资源的定义和资源的加载区分开了，Resource 定义了统一的资源，那资源的加载则由 ResourceLoader 来统一定义。\n\n`org.springframework.core.io.ResourceLoader` 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器。其定义如下：\n\n```java\npublic interface ResourceLoader {\n    String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;\n\n    Resource getResource(String location);\n\n    ClassLoader getClassLoader();\n}\n```\n\nResourceLoader 接口提供两个方法：`getResource()`、`getClassLoader()`。\n\n`getResource()`根据所提供资源的路径 location 返回 Resource 实例，但是它不确保该 Resource 一定存在，需要调用 `Resource.exist()`方法判断。该方法支持以下模式的资源加载：\n\n- URL位置资源，如”file:C:/test.dat”\n- ClassPath位置资源，如”classpath:test.dat”\n- 相对路径资源，如”WEB-INF/test.dat”，此时返回的Resource实例根据实现不同而不同\n\n该方法的主要实现是在其子类 DefaultResourceLoader 中实现，具体过程我们在分析 DefaultResourceLoader 时做详细说明。\n\n对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用 `getClassLoader()` 方法获得。在分析 Resource 时，提到了一个类 ClassPathResource ，这个类是可以根据指定的 ClassLoader 来加载资源的。\n\n作为 Spring 统一的资源加载器，它提供了统一的抽象，具体的实现则由相应的子类来负责实现，其类的类结构图如下：\n![resourceloader](/images/pasted-6.png)\n\n#### DefaultResourceLoader\n\n与 AbstractResource 相似，DefaultResourceLoader 是 ResourceLoader 的默认实现，它接收 ClassLoader 作为构造函数的参数或者使用不带参数的构造函数，在使用不带参数的构造函数时，使用的 ClassLoader 为默认的 ClassLoader（一般为`Thread.currentThread().getContextClassLoader()`），可以通过 `ClassUtils.getDefaultClassLoader()`获取。当然也可以调用 `setClassLoader()`方法进行后续设置。如下\n\n```java\n public DefaultResourceLoader() {\n        this.classLoader = ClassUtils.getDefaultClassLoader();\n    }\n\n    public DefaultResourceLoader(@Nullable ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    public void setClassLoader(@Nullable ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    @Override\n    @Nullable\n    public ClassLoader getClassLoader() {\n        return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());\n    }\n```\n\nResourceLoader 中最核心的方法为 `getResource()`,它根据提供的 location 返回相应的 Resource，而 DefaultResourceLoader 对该方法提供了核心实现(它的两个子类都没有提供覆盖该方法，所以可以断定ResourceLoader 的资源加载策略就封装 DefaultResourceLoader中)，如下：\n\n```java\n    public Resource getResource(String location) {\n        Assert.notNull(location, \"Location must not be null\");\n\n        for (ProtocolResolver protocolResolver : this.protocolResolvers) {\n            Resource resource = protocolResolver.resolve(location, this);\n            if (resource != null) {\n                return resource;\n            }\n        }\n\n        if (location.startsWith(\"/\")) {\n            return getResourceByPath(location);\n        }\n        else if (location.startsWith(CLASSPATH_URL_PREFIX)) {\n            return new \n                ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), \n                                         getClassLoader());\n        }\n        else {\n            try {\n                // Try to parse the location as a URL...\n                URL url = new URL(location);\n                return (ResourceUtils.isFileURL(url) ? \n                        new FileUrlResource(url) : new UrlResource(url));\n            }\n            catch (MalformedURLException ex) {\n                // No URL -> resolve as resource path.\n                return getResourceByPath(location);\n            }\n        }\n    }\n```\n\n首先通过 ProtocolResolver 来加载资源，成功返回 Resource，否则调用如下逻辑：\n\n- 若 location 以 / 开头，则调用 `getResourceByPath()`构造 ClassPathContextResource 类型资源并返回。\n- 若 location 以 classpath: 开头，则构造 ClassPathResource 类型资源并返回，在构造该资源时，通过 `getClassLoader()`获取当前的 ClassLoader。\n- 构造 URL ，尝试通过它进行资源定位，若没有抛出 MalformedURLException 异常，则判断是否为 FileURL , 如果是则构造 FileUrlResource 类型资源，否则构造 UrlResource。若在加载过程中抛出 MalformedURLException 异常，则委派 `getResourceByPath()` 实现资源定位加载。\n\n这里有一点要注意的是，返回了resource不代表这个资源存在，和前面介绍resource一样，需要通过exitsts来确认文件的存在。\n\nProtocolResolver ，用户自定义协议资源解决策略，作为 DefaultResourceLoader 的 SPI，它允许用户自定义资源加载协议，而不需要继承 ResourceLoader 的子类。在介绍 Resource 时，提到如果要实现自定义 Resource，我们只需要继承 DefaultResource 即可，但是有了 ProtocolResolver 后，我们不需要直接继承 DefaultResourceLoader，改为实现 ProtocolResolver 接口也可以实现自定义的 ResourceLoader。\nProtocolResolver 接口，仅有一个方法 `Resource resolve(String location, ResourceLoader resourceLoader)`，该方法接收两个参数：资源路径location，指定的加载器 ResourceLoader，返回为相应的 Resource 。在 Spring 中你会发现该接口并没有实现类，它需要用户自定义，自定义的 Resolver 如何加入 Spring 体系呢？调用 `DefaultResourceLoader.addProtocolResolver()` 即可，如下：\n\n```java\n    public void addProtocolResolver(ProtocolResolver resolver) {\n        Assert.notNull(resolver, \"ProtocolResolver must not be null\");\n        this.protocolResolvers.add(resolver);\n    }\n```\n\n下面是我写的一个简单ProtocolResolver的demo，演示了使用方式，如果你希望添加自定义的文件格式解析，可以向下面这样添加。\n\n```java\n   /**\n\t * 测试ProtocolResolver\n\t */\n\tpublic static void main(String[] args) {\n\t\tDefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader();\n\t\tdefaultResourceLoader.getProtocolResolvers().forEach(System.out::println);\n\n\t\tdefaultResourceLoader.addProtocolResolver(new \n\t\t\t\tCustomerResourceProtocolResolver());\n\t\tSystem.out.println(defaultResourceLoader.getResource(\"/Users/zhangke/HTTP请求.jmx\").exists());\n\t}\n\n\tstatic class CustomerResourceProtocolResolver implements ProtocolResolver {\n\n\t\t@Override\n\t\tpublic Resource resolve(String location, ResourceLoader resourceLoader) {\n\t\t\tFileSystemResource fileSystemResource = new FileSystemResource(location);\n\t\t\treturn fileSystemResource;\n\t\t}\n\t}\n```\n\n下面示例是演示 DefaultResourceLoader 加载资源的具体策略，代码如下（该示例参考《Spring 解密》 P89）：\n\n```java\n        ResourceLoader resourceLoader = new DefaultResourceLoader();\n\n        Resource fileResource1 = resourceLoader.getResource(\"D:/Users/chenming673/Documents/spark.txt\");\n        System.out.println(\"fileResource1 is FileSystemResource:\" + (fileResource1 instanceof FileSystemResource));\n\n        Resource fileResource2 = resourceLoader.getResource(\"/Users/chenming673/Documents/spark.txt\");\n        System.out.println(\"fileResource2 is ClassPathResource:\" + (fileResource2 instanceof ClassPathResource));\n\n        Resource urlResource1 = resourceLoader.getResource(\"file:/Users/chenming673/Documents/spark.txt\");\n        System.out.println(\"urlResource1 is UrlResource:\" + (urlResource1 instanceof UrlResource));\n\n        Resource urlResource2 = resourceLoader.getResource(\"http://www.baidu.com\");\n        System.out.println(\"urlResource1 is urlResource:\" + (urlResource2 instanceof  UrlResource));\n```\n\n运行结果：\n\n```\nfileResource1 is FileSystemResource:false\nfileResource2 is ClassPathResource:true\nurlResource1 is UrlResource:true\nurlResource1 is urlResource:true\n```\n\n其实对于 fileResource1 我们更加希望是 FileSystemResource 资源类型，但是事与愿违，它是 ClassPathResource 类型。在`getResource()`资源加载策略中，我们知道 `D:/Users/chenming673/Documents/spark.txt`资源其实在该方法中没有相应的资源类型，那么它就会在抛出 MalformedURLException 异常时通过 `getResourceByPath()` 构造一个 ClassPathResource 类型的资源。而指定有协议前缀的资源路径，则通过 URL 就可以定义，所以返回的都是UrlResource类型。\n\n####  FileSystemResourceLoader\n\n从上面的示例我们看到，其实 DefaultResourceLoader 对`getResourceByPath(String)`方法处理其实不是很恰当，这个时候我们可以使用 FileSystemResourceLoader ，它继承 DefaultResourceLoader 且覆写了 `getResourceByPath(String)`，使之从文件系统加载资源并以 FileSystemResource 类型返回，这样我们就可以得到想要的资源类型，如下：\n\n```java\n    @Override\n    protected Resource getResourceByPath(String path) {\n        if (path.startsWith(\"/\")) {\n            path = path.substring(1);\n        }\n        return new FileSystemContextResource(path);\n    }\n```\n\nFileSystemContextResource 为 FileSystemResourceLoader 的内部类，它继承 FileSystemResource。\n\n```java\n    private static class FileSystemContextResource extends FileSystemResource implements ContextResource {\n\n        public FileSystemContextResource(String path) {\n            super(path);\n        }\n\n        @Override\n        public String getPathWithinContext() {\n            return getPath();\n        }\n    }\n```\n\n在构造器中也是调用 FileSystemResource 的构造方法来构造 FileSystemResource 的。\n\n如果将上面的示例将 DefaultResourceLoader 改为 FileSystemContextResource ，则 fileResource1 则为 FileSystemResource。\n\n#### ResourcePatternResolver\n\nResourceLoader 的 `Resource getResource(String location)` 每次只能根据 location 返回一个 Resource，当需要加载多个资源时，我们除了多次调用 `getResource()` 外别无他法。ResourcePatternResolver 是 ResourceLoader 的扩展，它支持根据指定的资源路径匹配模式每次返回多个 Resource 实例，其定义如下：\n\n```java\npublic interface ResourcePatternResolver extends ResourceLoader {\n    String CLASSPATH_ALL_URL_PREFIX = \"classpath*:\";\n\n    Resource[] getResources(String locationPattern) throws IOException;\n}\n```\n\nResourcePatternResolver 在 ResourceLoader 的基础上增加了 `getResources(String locationPattern)`，以支持根据路径匹配模式返回多个 Resource 实例，同时也新增了一种新的协议前缀 `classpath*:`，该协议前缀由其子类负责实现。\n\nPathMatchingResourcePatternResolver 为 ResourcePatternResolver 最常用的子类，它除了支持 ResourceLoader 和 ResourcePatternResolver 新增的 classpath*: 前缀外，还支持 Ant 风格的路径匹配模式。\n\n这里先介绍什么是Ant风格的路径匹配模式，主要由以下规则，\n\n* ？匹配一个字符\n* `*`匹配0个或多个字符\n* ** 在路径中匹配0个或多个文件夹\n* {spring;[a-z]+}，匹配正则表达式`[a-z]+`并将结果存在名为“spring”变量中。\n\n例子\n\n- `com/t?st.jsp` —匹配 `com/test.jsp` 、 `com/tast.jsp` 、`com/txst.jsp`\n- `com/*.jsp` — 匹配com目录线面所有的l `.jsp` 文件\n- `com/**/test.jsp` —匹配com目录还有子目录下所有的 `test.jsp`\n- `org/springframework/**/*.jsp` — 匹配 `org/springframework` 目录和子目录下所有的 `.jsp` \n- `org/**/servlet/bla.jsp` — 匹配`org/springframework/servlet/bla.jsp` 、`org/springframework/testing/servlet/bla.jsp` 、 `org/servlet/bla.jsp`\n- `com/{filename:\\\\w+}.jsp` 匹配 `com/test.jsp` 并且将值 `test` 付给 `filename`变量\n\n在spring经常使用`AntPathMatcher`来进行操作这些ant风格的路径匹配模式\n\n小案例如下\n\n```java\n/**************************************\n *      Author : zhangke\n *      Date   : 2019-01-08 17:44\n *      email  : 398757724@qq.com\n *      Desc   : ant 风格小案例\n ***************************************/\npublic class AntPathMatcherStudy {\n\tpublic static void main(String[] args) {\n\t\tAntPathMatcher antPathMatcher = new AntPathMatcher();\n\n\n\t\t// com/t?st.jsp — matches com/test.jsp but also com/tast.jsp or com/txst.jsp\n\t\tSystem.out.println(antPathMatcher.match(\"com/t?st.jsp\", \"com/test.jsp\"));\n\t\tSystem.out.println(antPathMatcher.match(\"com/t?st.jsp\", \"com/tast.jsp\"));\n\t\tSystem.out.println(antPathMatcher.match(\"com/t?st.jsp\", \"com/txst.jsp\"));\n\n\n\t\t// com/*.jsp — matches all .jsp files in the com directory\n\t\tSystem.out.println(antPathMatcher.match(\"com/*.jsp\", \"com/test.jsp\"));\n\t\tSystem.out.println(antPathMatcher.match(\"com/*.jsp\", \"com/tast.jsp\"));\n\t\tSystem.out.println(antPathMatcher.match(\"com/*.jsp\", \"com/txst.jsp\"));\n\n\n\t\t//org/springframework/**/*.jsp — matches all .jsp files underneath the org/springframework path\n\t\tSystem.out.println(antPathMatcher.match(\"org/springframework/**/*.jsp\", \"org/springframework/com/test.jsp\"));\n\t\tSystem.out.println(antPathMatcher.match(\"org/springframework/**/*.jsp\", \"org/springframework/test/com/tast.jsp\"));\n\t\tSystem.out.println(antPathMatcher.match(\"org/springframework/**/*.jsp\", \"org/springframework/ddd/txst.jsp\"));\n\n\t\t// com/{filename:\\\\w+}.jsp will match com/test.jsp and assign the value test to the filename variable\n\t\tSystem.out.println(antPathMatcher.extractUriTemplateVariables(\"/test/{spring:[a-z]+}/test.jsp\", \"/test/test/test.jsp\"));\n\n\t}\n```\n\n运行结果\n\n```java\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\n{spring=test}\n```\n\nPathMatchingResourcePatternResolver 提供了三个构造方法，如下：\n\n```java\n    public PathMatchingResourcePatternResolver() {\n        this.resourceLoader = new DefaultResourceLoader();\n    }\n\n    public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {\n        Assert.notNull(resourceLoader, \"ResourceLoader must not be null\");\n        this.resourceLoader = resourceLoader;\n    }\n\n    public PathMatchingResourcePatternResolver(@Nullable ClassLoader classLoader) {\n        this.resourceLoader = new DefaultResourceLoader(classLoader);\n    }\n```\n\nPathMatchingResourcePatternResolver 在实例化的时候，可以指定一个 ResourceLoader，如果不指定的话，它会在内部构造一个 DefaultResourceLoader。\n\n**Resource getResource(String location)**\n\n```java\n    @Override\n    public Resource getResource(String location) {\n        return getResourceLoader().getResource(location);\n    }\n```\n\n`getResource()` 方法直接委托给相应的 ResourceLoader 来实现，所以如果我们在实例化的 PathMatchingResourcePatternResolver 的时候，如果不知道 ResourceLoader ，那么在加载资源时，其实就是 DefaultResourceLoader 的过程。其实在下面介绍的 `Resource[] getResources(String locationPattern)` 也相同，只不过返回的资源时多个而已。\n\n```java\n public Resource[] getResources(String locationPattern) throws IOException {\n        Assert.notNull(locationPattern, \"Location pattern must not be null\");\n\n        // 以 classpath*: 开头\n        if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {\n            // 路径包含通配符，PathMatcher默认是AntPathMatcher\n            if (getPathMatcher().isPattern(\n                locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {\n                return findPathMatchingResources(locationPattern);\n            } else {\n                // 路径不包含通配符\n                return findAllClassPathResources(\n                    locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));\n            }\n        } else {\n            int prefixEnd = (locationPattern.startsWith(\"war:\") ?\n              locationPattern.indexOf(\"*/\") + 1 : locationPattern.indexOf(':') + 1);\n            // 路径包含通配符\n            if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {\n                return findPathMatchingResources(locationPattern);\n            }else {\n                // 不包含通配符也不是以Classpath*：开头，返回指定resource\n                return new Resource[{getResourceLoader().getResource(locationPattern)};\n            }\n        }\n    }\n```\n\n处理逻辑如下\n![pathResourceLoader 逻辑图](/images/pasted-8.png)\n\n下面就 `findAllClassPathResources()`、`findAllClassPathResources()` 做详细分析。\n\n**findAllClassPathResources()**\n\n当 locationPattern 以 classpath*: 开头但是不包含通配符，则调用`findAllClassPathResources()` 方法加载资源。该方法返回 classes 路径下和所有 jar 包中的所有相匹配的资源。\n\n```java\n protected Resource[] findAllClassPathResources(String location) throws IOException {\n        String path = location;\n        if (path.startsWith(\"/\")) {\n            path = path.substring(1);\n        }\n        Set<Resource> result = doFindAllClassPathResources(path);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Resolved classpath location \n                         \t\t[\" + location + \"] to resources \" + result);\n        }\n        return result.toArray(new Resource[0]);\n    }\n```\n\n真正执行加载的是在 `doFindAllClassPathResources()`方法，如下：\n\n```java\n    protected Set<Resource> doFindAllClassPathResources(String path) throws IOException {\n        Set<Resource> result = new LinkedHashSet<>(16);\n        ClassLoader cl = getClassLoader();\n        Enumeration<URL> resourceUrls = (cl != null ? cl.getResources(path) : \n                                         ClassLoader.getSystemResources(path));\n        while (resourceUrls.hasMoreElements()) {\n            URL url = resourceUrls.nextElement();\n            result.add(convertClassLoaderURL(url));\n        }\n        if (\"\".equals(path)) {\n            addAllClassLoaderJarRoots(cl, result);\n        }\n        return result;\n    }\n```\n\n`doFindAllClassPathResources()` 根据 ClassLoader 加载路径下的所有资源。在加载资源过程中如果，在构造 PathMatchingResourcePatternResolver 实例的时候如果传入了 ClassLoader，则调用其 `getResources()`，否则调用`ClassLoader.getSystemResources(path)`。 `ClassLoader.getResources()`如下:\n\n```java\n    public Enumeration<URL> getResources(String name) throws IOException {\n        @SuppressWarnings(\"unchecked\")\n        Enumeration<URL>[] tmp = (Enumeration<URL>[]) new Enumeration<?>[2];\n        if (parent != null) {\n            tmp[0] = parent.getResources(name);\n        } else {\n            tmp[0] = getBootstrapResources(name);\n        }\n        tmp[1] = findResources(name);\n\n        return new CompoundEnumeration<>(tmp);\n    }\n```\n\n看到这里是不是就已经一目了然了？如果当前父类加载器不为 null，则通过父类向上迭代获取资源，否则调用 `getBootstrapResources()`。这里是不是特别熟悉。\n\n若 path 为 空（“”）时，则调用 `addAllClassLoaderJarRoots()`方法。该方法主要是加载路径下得所有 jar 包，方法较长也没有什么实际意义就不贴出来了。不过最后结果在每个jar后面都添加**!/**的原因是java官方规定的，可以看这个连接[jar 中出现!/的原因](https://docs.oracle.com/javase/tutorial/deployment/jar/apiindex.html)\n\n通过上面的分析，我们知道 `findAllClassPathResources()` 其实就是利用 ClassLoader 来加载指定路径下的资源，不过它是在 class 路径下还是在 jar 包中。如果我们传入的路径为空或者 `/`，则会调用 `addAllClassLoaderJarRoots()` 方法加载所有的 jar 包。\n\n**findAllClassPathResources()**\n\n当 locationPattern 以 classpath*: 开头且当中包含了通配符，则调用该方法进行资源加载。如下：\n\n```java\nprotected Resource[] findPathMatchingResources(String locationPattern) throws IOException {\n        // 确定跟路径\n        String rootDirPath = determineRootDir(locationPattern);\n        String subPattern = locationPattern.substring(rootDirPath.length());\n\n        // 获取根据路径下得资源\n        Resource[] rootDirResources = getResources(rootDirPath);\n\n        Set<Resource> result = new LinkedHashSet<>(16);\n        for (Resource rootDirResource : rootDirResources) {\n            rootDirResource = resolveRootDirResource(rootDirResource);\n            URL rootDirUrl = rootDirResource.getURL();\n            // bundle 资源类型\n            if (equinoxResolveMethod != null && \n                \t\trootDirUrl.getProtocol().startsWith(\"bundle\")) {\n                URL resolvedUrl = (URL)ReflectionUtils.invokeMethod(\n                    equinoxResolveMethod, null, rootDirUrl);\n                if (resolvedUrl != null) {\n                    rootDirUrl = resolvedUrl;\n                }\n                rootDirResource = new UrlResource(rootDirUrl);\n            }\n\n            // VFS 资源\n            if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\n                result.addAll(\n                    VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, \n                                                  subPattern, getPathMatcher()));\n            }\n\n            // Jar\n            else if (ResourceUtils.isJarURL(rootDirUrl) || \n                     isJarResource(rootDirResource)) {\n                result.addAll(doFindPathMatchingJarResources(rootDirResource, \n                                                             rootDirUrl, subPattern));\n            }\n            else {\n                result.addAll(doFindPathMatchingFileResources(rootDirResource, \n                                                              subPattern));\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Resolved location pattern [\" + locationPattern + \"] to \n                         resources \" + result);\n        }\n        return result.toArray(new Resource[0]);\n    }\n```\n\n方法有点儿长，但是思路还是很清晰的，主要分两步：\n\n1. 确定目录，获取该目录下得所有资源\n2. 在所获得的所有资源中进行迭代匹配获取我们想要的资源。\n\n在这个方法里面我们要关注两个方法，一个是 `determineRootDir()`,一个是 `doFindPathMatchingFileResources()`。\n\n`determineRootDir()`主要是用于确定根路径，如下：\n\n```java\n    protected String determineRootDir(String location) {\n        int prefixEnd = location.indexOf(':') + 1;\n        int rootDirEnd = location.length();\n        while (rootDirEnd > prefixEnd && getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) {\n            rootDirEnd = location.lastIndexOf('/', rootDirEnd - 2) + 1;\n        }\n        if (rootDirEnd == 0) {\n            rootDirEnd = prefixEnd;\n        }\n        return location.substring(0, rootDirEnd);\n    }\n```\n\n该方法一定要给出一个确定的根目录。该根目录用于确定文件的匹配的起始点，将根目录位置的资源解析为 `java.io.File`并将其传递到 `retrieveMatchingFiles()`，其余为知用于模式匹配，找出我们所需要的资源。\n\n确定根路径如下:\n\n| 原路径                             | 确定根路径            |\n| ---------------------------------- | --------------------- |\n| `classpath*:test/cc*/spring-*.xml` | `classpath*:test/`    |\n| `classpath*:test/aa/spring-*.xml`  | `classpath*:test/aa/` |\n\n确定根路径后，则调用 `getResources()` 方法获取该路径下得所有资源，然后迭代资源获取符合条件的资源。\n\n至此 Spring 整个资源记载过程已经分析完毕。下面简要总结下：\n\n- Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。\n- AbstractResource 为 Resource 的默认实现，它对 Resource 接口做了一个统一的实现，子类继承该类后只需要覆盖相应的方法即可，同时对于自定义的 Resource 我们也是继承该类。\n- DefaultResourceLoader 同样也是 ResourceLoader 的默认实现，在自定 ResourceLoader 的时候我们除了可以继承该类外还可以实现 ProtocolResolver 接口来实现自定资源加载协议。\n- DefaultResourceLoader 每次只能返回单一的资源，所以 Spring 针对这个提供了另外一个接口 ResourcePatternResolver ，该接口提供了根据指定的 locationPattern 返回多个资源的策略。其子类 PathMatchingResourcePatternResolver 是一个集大成者的 ResourceLoader ，因为它即实现了 `Resource getResource(String location)` 也实现了 `Resource[] getResources(String locationPattern)`。","source":"_posts/spring 源码分析/spring/spring源码解析之  03统一资源加载.md","raw":"abbrlink: 22\ntitle: spring源码解析之 03统一资源加载\ntags:\n  - spring源码解析\ncategories:\n  - spring\nauthor: fenxiutianya\ndate: 2019-01-14 03:39:00\n---\n# spring源码解析之 03统一资源加载\n\n### 概述\n\n1. 统一资源Resource\n2. 统一资源定位ResourceLoader\n\n### 1. 统一资源Resource\n\njava se中有一个标准类 `java.net.URL`，该类在 Java SE 中的定位为统一资源定位器（Uniform Resource Locator），但是我们知道它的实现基本只限于网络形式发布的资源的查找和定位。虽然可以通过注册特定的处理器来扩展处理不同的地址前缀，但是这通常比较麻烦。而且不易于使用。另外，实际上资源的定义比较广泛，除了网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等。而且它可以存在于任何场所，比如网络、文件系统、应用程序中。所以 `java.net.URL` 的局限性迫使 Spring 必须实现自己的资源加载策略，该资源加载策略需要满足如下要求：\n\n1. 职能划分清楚：资源的定义和资源的加载应该要有一个清晰的界限；\n2. 统一的抽象：统一的资源定义和资源加载策略。资源加载后要返回统一的抽象给客户端，客户端要对资源进行怎样的处理，应该由抽象资源接口来界定。\n\n<!-- more -->\n\n`org.springframework.core.io.Resource` 为 Spring 框架所有资源的抽象和访问接口，它继承 `org.springframework.core.io.InputStreamSource`接口。作为所有资源的统一抽象，Source 定义了一些通用的方法，由子类 `AbstractResource` 提供统一的默认实现。定义如下：\n\n```java\npublic interface Resource extends InputStreamSource {\n\n    /**\n     * 资源是否存在\n     */\n    boolean exists();\n\n    /**\n     * 资源是否可读\n     */\n    default boolean isReadable() {\n        return true;\n    }\n\n    /**\n     * 资源所代表的句柄是否被一个stream打开了\n     */\n    default boolean isOpen() {\n        return false;\n    }\n\n    /**\n     * 是否为 File\n     */\n    default boolean isFile() {\n        return false;\n    }\n\n    /**\n     * 返回资源的URL的句柄\n     */\n    URL getURL() throws IOException;\n\n    /**\n     * 返回资源的URI的句柄\n     */\n    URI getURI() throws IOException;\n\n    /**\n     * 返回资源的File的句柄\n     */\n    File getFile() throws IOException;\n\n    /**\n     * 返回 ReadableByteChannel\n     */\n    default ReadableByteChannel readableChannel() throws IOException {\n        return Channels.newChannel(getInputStream());\n    }\n\n    /**\n     * 资源内容的长度\n     */\n    long contentLength() throws IOException;\n\n    /**\n     * 资源最后的修改时间\n     */\n    long lastModified() throws IOException;\n\n    /**\n     * 根据资源的相对路径创建新资源\n     */\n    Resource createRelative(String relativePath) throws IOException;\n\n    /**\n     * 资源的文件名\n     */\n    @Nullable\n    String getFilename();\n\n    /**\n     * 资源的描述\n     */\n    String getDescription();\n\n}\n```\n\n![resource](/images/pasted-6.png)\n\n从上图可以看到，Resource 根据资源的不同类型提供不同的具体实现，如下：\n\n- FileSystemResource：对 `java.io.File` 类型资源的封装，只要是跟 File 打交道的，基本上与 FileSystemResource 也可以打交道。支持文件和 URL 的形式，实现 WritableResource 接口，且从 Spring Framework 5.0 开始，FileSystemResource 使用NIO.2 API进行读/写交互\n- ByteArrayResource：对字节数组提供的数据的封装。如果通过 InputStream 形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的 ByteArrayInputStream。\n- UrlResource：对 `java.net.URL`类型资源的封装。内部委派 URL 进行具体的资源操作。\n- ClassPathResource：class path 类型资源的实现。使用给定的 ClassLoader 或者给定的 Class 来加载资源。\n- InputStreamResource：将给定的 InputStream 作为一种资源的 Resource 的实现类。\n\nAbstractResource 为 Resource 接口的默认实现，它实现了 Resource 接口的大部分的公共实现，作为 Resource 接口中的重中之重，其定义如下：\n\n```java\npublic abstract class AbstractResource implements Resource {\n\n    /**\n     * 判断文件是否存在，若判断过程产生异常（因为会调用SecurityManager来判断），就关闭对应的流\n     */\n    @Override\n    public boolean exists() {\n        try {\n            return getFile().exists();\n        }\n        catch (IOException ex) {\n            // Fall back to stream existence: can we open the stream?\n            try {\n                InputStream is = getInputStream();\n                is.close();\n                return true;\n            }\n            catch (Throwable isEx) {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * 直接返回true，表示可读\n     */\n    @Override\n    public boolean isReadable() {\n        return true;\n    }\n\n    /**\n     * 直接返回 false，表示未被打开\n     */\n    @Override\n    public boolean isOpen() {\n        return false;\n    }\n\n    /**\n     *  直接返回false，表示不为 File\n     */\n    @Override\n    public boolean isFile() {\n        return false;\n    }\n\n    /**\n     * 抛出 FileNotFoundException 异常，交给子类实现\n     */\n    @Override\n    public URL getURL() throws IOException {\n        throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL\");\n    }\n\n    /**\n     * 基于 getURL() 返回的 URL 构建 URI\n     */\n    @Override\n    public URI getURI() throws IOException {\n        URL url = getURL();\n        try {\n            return ResourceUtils.toURI(url);\n        }\n        catch (URISyntaxException ex) {\n            throw new NestedIOException(\"Invalid URI [\" + url + \"]\", ex);\n        }\n    }\n\n    /**\n     * 抛出 FileNotFoundException 异常，交给子类实现\n     */\n    @Override\n    public File getFile() throws IOException {\n        throw new FileNotFoundException(getDescription() + \" cannot be resolved to absolute file path\");\n    }\n\n    /**\n     * 根据 getInputStream() 的返回结果构建 ReadableByteChannel\n     */\n    @Override\n    public ReadableByteChannel readableChannel() throws IOException {\n        return Channels.newChannel(getInputStream());\n    }\n\n    /**\n     * 获取资源的长度\n     *\n     * 这个资源内容长度实际就是资源的字节长度，通过全部读取一遍来判断\n     */\n    @Override\n    public long contentLength() throws IOException {\n        InputStream is = getInputStream();\n        try {\n            long size = 0;\n            byte[] buf = new byte[255];\n            int read;\n            while ((read = is.read(buf)) != -1) {\n                size += read;\n            }\n            return size;\n        }\n        finally {\n            try {\n                is.close();\n            }\n            catch (IOException ex) {\n            }\n        }\n    }\n\n    /**\n     * 返回资源最后的修改时间\n     */\n    @Override\n    public long lastModified() throws IOException {\n        long lastModified = getFileForLastModifiedCheck().lastModified();\n        if (lastModified == 0L) {\n            throw new FileNotFoundException(getDescription() +\n                    \" cannot be resolved in the file system for resolving its last-modified timestamp\");\n        }\n        return lastModified;\n    }\n\n\n    protected File getFileForLastModifiedCheck() throws IOException {\n        return getFile();\n    }\n\n    /**\n     * 交给子类实现\n     */\n    @Override\n    public Resource createRelative(String relativePath) throws IOException {\n        throw new FileNotFoundException(\"Cannot create a relative resource for \" + getDescription());\n    }\n\n    /**\n     * 获取资源名称，默认返回 null\n     */\n    @Override\n    @Nullable\n    public String getFilename() {\n        return null;\n    }\n\n\n    /**\n     * 返回资源的描述\n     */\n    @Override\n    public String toString() {\n        return getDescription();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        return (obj == this ||\n            (obj instanceof Resource && ((Resource) obj).getDescription().equals(getDescription())));\n    }\n\n    @Override\n    public int hashCode() {\n        return getDescription().hashCode();\n    }\n\n}\n```\n\n如果我们想要实现自定义的 Resource，记住不要实现 Resource 接口，而应该继承 AbstractResource 抽象类，然后根据当前的具体资源特性覆盖相应的方法即可。\n\n### 2. 统一资源定位：ResourceLoader\n\n一开始就说了 Spring 将资源的定义和资源的加载区分开了，Resource 定义了统一的资源，那资源的加载则由 ResourceLoader 来统一定义。\n\n`org.springframework.core.io.ResourceLoader` 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器。其定义如下：\n\n```java\npublic interface ResourceLoader {\n    String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;\n\n    Resource getResource(String location);\n\n    ClassLoader getClassLoader();\n}\n```\n\nResourceLoader 接口提供两个方法：`getResource()`、`getClassLoader()`。\n\n`getResource()`根据所提供资源的路径 location 返回 Resource 实例，但是它不确保该 Resource 一定存在，需要调用 `Resource.exist()`方法判断。该方法支持以下模式的资源加载：\n\n- URL位置资源，如”file:C:/test.dat”\n- ClassPath位置资源，如”classpath:test.dat”\n- 相对路径资源，如”WEB-INF/test.dat”，此时返回的Resource实例根据实现不同而不同\n\n该方法的主要实现是在其子类 DefaultResourceLoader 中实现，具体过程我们在分析 DefaultResourceLoader 时做详细说明。\n\n对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用 `getClassLoader()` 方法获得。在分析 Resource 时，提到了一个类 ClassPathResource ，这个类是可以根据指定的 ClassLoader 来加载资源的。\n\n作为 Spring 统一的资源加载器，它提供了统一的抽象，具体的实现则由相应的子类来负责实现，其类的类结构图如下：\n![resourceloader](/images/pasted-6.png)\n\n#### DefaultResourceLoader\n\n与 AbstractResource 相似，DefaultResourceLoader 是 ResourceLoader 的默认实现，它接收 ClassLoader 作为构造函数的参数或者使用不带参数的构造函数，在使用不带参数的构造函数时，使用的 ClassLoader 为默认的 ClassLoader（一般为`Thread.currentThread().getContextClassLoader()`），可以通过 `ClassUtils.getDefaultClassLoader()`获取。当然也可以调用 `setClassLoader()`方法进行后续设置。如下\n\n```java\n public DefaultResourceLoader() {\n        this.classLoader = ClassUtils.getDefaultClassLoader();\n    }\n\n    public DefaultResourceLoader(@Nullable ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    public void setClassLoader(@Nullable ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    @Override\n    @Nullable\n    public ClassLoader getClassLoader() {\n        return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());\n    }\n```\n\nResourceLoader 中最核心的方法为 `getResource()`,它根据提供的 location 返回相应的 Resource，而 DefaultResourceLoader 对该方法提供了核心实现(它的两个子类都没有提供覆盖该方法，所以可以断定ResourceLoader 的资源加载策略就封装 DefaultResourceLoader中)，如下：\n\n```java\n    public Resource getResource(String location) {\n        Assert.notNull(location, \"Location must not be null\");\n\n        for (ProtocolResolver protocolResolver : this.protocolResolvers) {\n            Resource resource = protocolResolver.resolve(location, this);\n            if (resource != null) {\n                return resource;\n            }\n        }\n\n        if (location.startsWith(\"/\")) {\n            return getResourceByPath(location);\n        }\n        else if (location.startsWith(CLASSPATH_URL_PREFIX)) {\n            return new \n                ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), \n                                         getClassLoader());\n        }\n        else {\n            try {\n                // Try to parse the location as a URL...\n                URL url = new URL(location);\n                return (ResourceUtils.isFileURL(url) ? \n                        new FileUrlResource(url) : new UrlResource(url));\n            }\n            catch (MalformedURLException ex) {\n                // No URL -> resolve as resource path.\n                return getResourceByPath(location);\n            }\n        }\n    }\n```\n\n首先通过 ProtocolResolver 来加载资源，成功返回 Resource，否则调用如下逻辑：\n\n- 若 location 以 / 开头，则调用 `getResourceByPath()`构造 ClassPathContextResource 类型资源并返回。\n- 若 location 以 classpath: 开头，则构造 ClassPathResource 类型资源并返回，在构造该资源时，通过 `getClassLoader()`获取当前的 ClassLoader。\n- 构造 URL ，尝试通过它进行资源定位，若没有抛出 MalformedURLException 异常，则判断是否为 FileURL , 如果是则构造 FileUrlResource 类型资源，否则构造 UrlResource。若在加载过程中抛出 MalformedURLException 异常，则委派 `getResourceByPath()` 实现资源定位加载。\n\n这里有一点要注意的是，返回了resource不代表这个资源存在，和前面介绍resource一样，需要通过exitsts来确认文件的存在。\n\nProtocolResolver ，用户自定义协议资源解决策略，作为 DefaultResourceLoader 的 SPI，它允许用户自定义资源加载协议，而不需要继承 ResourceLoader 的子类。在介绍 Resource 时，提到如果要实现自定义 Resource，我们只需要继承 DefaultResource 即可，但是有了 ProtocolResolver 后，我们不需要直接继承 DefaultResourceLoader，改为实现 ProtocolResolver 接口也可以实现自定义的 ResourceLoader。\nProtocolResolver 接口，仅有一个方法 `Resource resolve(String location, ResourceLoader resourceLoader)`，该方法接收两个参数：资源路径location，指定的加载器 ResourceLoader，返回为相应的 Resource 。在 Spring 中你会发现该接口并没有实现类，它需要用户自定义，自定义的 Resolver 如何加入 Spring 体系呢？调用 `DefaultResourceLoader.addProtocolResolver()` 即可，如下：\n\n```java\n    public void addProtocolResolver(ProtocolResolver resolver) {\n        Assert.notNull(resolver, \"ProtocolResolver must not be null\");\n        this.protocolResolvers.add(resolver);\n    }\n```\n\n下面是我写的一个简单ProtocolResolver的demo，演示了使用方式，如果你希望添加自定义的文件格式解析，可以向下面这样添加。\n\n```java\n   /**\n\t * 测试ProtocolResolver\n\t */\n\tpublic static void main(String[] args) {\n\t\tDefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader();\n\t\tdefaultResourceLoader.getProtocolResolvers().forEach(System.out::println);\n\n\t\tdefaultResourceLoader.addProtocolResolver(new \n\t\t\t\tCustomerResourceProtocolResolver());\n\t\tSystem.out.println(defaultResourceLoader.getResource(\"/Users/zhangke/HTTP请求.jmx\").exists());\n\t}\n\n\tstatic class CustomerResourceProtocolResolver implements ProtocolResolver {\n\n\t\t@Override\n\t\tpublic Resource resolve(String location, ResourceLoader resourceLoader) {\n\t\t\tFileSystemResource fileSystemResource = new FileSystemResource(location);\n\t\t\treturn fileSystemResource;\n\t\t}\n\t}\n```\n\n下面示例是演示 DefaultResourceLoader 加载资源的具体策略，代码如下（该示例参考《Spring 解密》 P89）：\n\n```java\n        ResourceLoader resourceLoader = new DefaultResourceLoader();\n\n        Resource fileResource1 = resourceLoader.getResource(\"D:/Users/chenming673/Documents/spark.txt\");\n        System.out.println(\"fileResource1 is FileSystemResource:\" + (fileResource1 instanceof FileSystemResource));\n\n        Resource fileResource2 = resourceLoader.getResource(\"/Users/chenming673/Documents/spark.txt\");\n        System.out.println(\"fileResource2 is ClassPathResource:\" + (fileResource2 instanceof ClassPathResource));\n\n        Resource urlResource1 = resourceLoader.getResource(\"file:/Users/chenming673/Documents/spark.txt\");\n        System.out.println(\"urlResource1 is UrlResource:\" + (urlResource1 instanceof UrlResource));\n\n        Resource urlResource2 = resourceLoader.getResource(\"http://www.baidu.com\");\n        System.out.println(\"urlResource1 is urlResource:\" + (urlResource2 instanceof  UrlResource));\n```\n\n运行结果：\n\n```\nfileResource1 is FileSystemResource:false\nfileResource2 is ClassPathResource:true\nurlResource1 is UrlResource:true\nurlResource1 is urlResource:true\n```\n\n其实对于 fileResource1 我们更加希望是 FileSystemResource 资源类型，但是事与愿违，它是 ClassPathResource 类型。在`getResource()`资源加载策略中，我们知道 `D:/Users/chenming673/Documents/spark.txt`资源其实在该方法中没有相应的资源类型，那么它就会在抛出 MalformedURLException 异常时通过 `getResourceByPath()` 构造一个 ClassPathResource 类型的资源。而指定有协议前缀的资源路径，则通过 URL 就可以定义，所以返回的都是UrlResource类型。\n\n####  FileSystemResourceLoader\n\n从上面的示例我们看到，其实 DefaultResourceLoader 对`getResourceByPath(String)`方法处理其实不是很恰当，这个时候我们可以使用 FileSystemResourceLoader ，它继承 DefaultResourceLoader 且覆写了 `getResourceByPath(String)`，使之从文件系统加载资源并以 FileSystemResource 类型返回，这样我们就可以得到想要的资源类型，如下：\n\n```java\n    @Override\n    protected Resource getResourceByPath(String path) {\n        if (path.startsWith(\"/\")) {\n            path = path.substring(1);\n        }\n        return new FileSystemContextResource(path);\n    }\n```\n\nFileSystemContextResource 为 FileSystemResourceLoader 的内部类，它继承 FileSystemResource。\n\n```java\n    private static class FileSystemContextResource extends FileSystemResource implements ContextResource {\n\n        public FileSystemContextResource(String path) {\n            super(path);\n        }\n\n        @Override\n        public String getPathWithinContext() {\n            return getPath();\n        }\n    }\n```\n\n在构造器中也是调用 FileSystemResource 的构造方法来构造 FileSystemResource 的。\n\n如果将上面的示例将 DefaultResourceLoader 改为 FileSystemContextResource ，则 fileResource1 则为 FileSystemResource。\n\n#### ResourcePatternResolver\n\nResourceLoader 的 `Resource getResource(String location)` 每次只能根据 location 返回一个 Resource，当需要加载多个资源时，我们除了多次调用 `getResource()` 外别无他法。ResourcePatternResolver 是 ResourceLoader 的扩展，它支持根据指定的资源路径匹配模式每次返回多个 Resource 实例，其定义如下：\n\n```java\npublic interface ResourcePatternResolver extends ResourceLoader {\n    String CLASSPATH_ALL_URL_PREFIX = \"classpath*:\";\n\n    Resource[] getResources(String locationPattern) throws IOException;\n}\n```\n\nResourcePatternResolver 在 ResourceLoader 的基础上增加了 `getResources(String locationPattern)`，以支持根据路径匹配模式返回多个 Resource 实例，同时也新增了一种新的协议前缀 `classpath*:`，该协议前缀由其子类负责实现。\n\nPathMatchingResourcePatternResolver 为 ResourcePatternResolver 最常用的子类，它除了支持 ResourceLoader 和 ResourcePatternResolver 新增的 classpath*: 前缀外，还支持 Ant 风格的路径匹配模式。\n\n这里先介绍什么是Ant风格的路径匹配模式，主要由以下规则，\n\n* ？匹配一个字符\n* `*`匹配0个或多个字符\n* ** 在路径中匹配0个或多个文件夹\n* {spring;[a-z]+}，匹配正则表达式`[a-z]+`并将结果存在名为“spring”变量中。\n\n例子\n\n- `com/t?st.jsp` —匹配 `com/test.jsp` 、 `com/tast.jsp` 、`com/txst.jsp`\n- `com/*.jsp` — 匹配com目录线面所有的l `.jsp` 文件\n- `com/**/test.jsp` —匹配com目录还有子目录下所有的 `test.jsp`\n- `org/springframework/**/*.jsp` — 匹配 `org/springframework` 目录和子目录下所有的 `.jsp` \n- `org/**/servlet/bla.jsp` — 匹配`org/springframework/servlet/bla.jsp` 、`org/springframework/testing/servlet/bla.jsp` 、 `org/servlet/bla.jsp`\n- `com/{filename:\\\\w+}.jsp` 匹配 `com/test.jsp` 并且将值 `test` 付给 `filename`变量\n\n在spring经常使用`AntPathMatcher`来进行操作这些ant风格的路径匹配模式\n\n小案例如下\n\n```java\n/**************************************\n *      Author : zhangke\n *      Date   : 2019-01-08 17:44\n *      email  : 398757724@qq.com\n *      Desc   : ant 风格小案例\n ***************************************/\npublic class AntPathMatcherStudy {\n\tpublic static void main(String[] args) {\n\t\tAntPathMatcher antPathMatcher = new AntPathMatcher();\n\n\n\t\t// com/t?st.jsp — matches com/test.jsp but also com/tast.jsp or com/txst.jsp\n\t\tSystem.out.println(antPathMatcher.match(\"com/t?st.jsp\", \"com/test.jsp\"));\n\t\tSystem.out.println(antPathMatcher.match(\"com/t?st.jsp\", \"com/tast.jsp\"));\n\t\tSystem.out.println(antPathMatcher.match(\"com/t?st.jsp\", \"com/txst.jsp\"));\n\n\n\t\t// com/*.jsp — matches all .jsp files in the com directory\n\t\tSystem.out.println(antPathMatcher.match(\"com/*.jsp\", \"com/test.jsp\"));\n\t\tSystem.out.println(antPathMatcher.match(\"com/*.jsp\", \"com/tast.jsp\"));\n\t\tSystem.out.println(antPathMatcher.match(\"com/*.jsp\", \"com/txst.jsp\"));\n\n\n\t\t//org/springframework/**/*.jsp — matches all .jsp files underneath the org/springframework path\n\t\tSystem.out.println(antPathMatcher.match(\"org/springframework/**/*.jsp\", \"org/springframework/com/test.jsp\"));\n\t\tSystem.out.println(antPathMatcher.match(\"org/springframework/**/*.jsp\", \"org/springframework/test/com/tast.jsp\"));\n\t\tSystem.out.println(antPathMatcher.match(\"org/springframework/**/*.jsp\", \"org/springframework/ddd/txst.jsp\"));\n\n\t\t// com/{filename:\\\\w+}.jsp will match com/test.jsp and assign the value test to the filename variable\n\t\tSystem.out.println(antPathMatcher.extractUriTemplateVariables(\"/test/{spring:[a-z]+}/test.jsp\", \"/test/test/test.jsp\"));\n\n\t}\n```\n\n运行结果\n\n```java\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\n{spring=test}\n```\n\nPathMatchingResourcePatternResolver 提供了三个构造方法，如下：\n\n```java\n    public PathMatchingResourcePatternResolver() {\n        this.resourceLoader = new DefaultResourceLoader();\n    }\n\n    public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {\n        Assert.notNull(resourceLoader, \"ResourceLoader must not be null\");\n        this.resourceLoader = resourceLoader;\n    }\n\n    public PathMatchingResourcePatternResolver(@Nullable ClassLoader classLoader) {\n        this.resourceLoader = new DefaultResourceLoader(classLoader);\n    }\n```\n\nPathMatchingResourcePatternResolver 在实例化的时候，可以指定一个 ResourceLoader，如果不指定的话，它会在内部构造一个 DefaultResourceLoader。\n\n**Resource getResource(String location)**\n\n```java\n    @Override\n    public Resource getResource(String location) {\n        return getResourceLoader().getResource(location);\n    }\n```\n\n`getResource()` 方法直接委托给相应的 ResourceLoader 来实现，所以如果我们在实例化的 PathMatchingResourcePatternResolver 的时候，如果不知道 ResourceLoader ，那么在加载资源时，其实就是 DefaultResourceLoader 的过程。其实在下面介绍的 `Resource[] getResources(String locationPattern)` 也相同，只不过返回的资源时多个而已。\n\n```java\n public Resource[] getResources(String locationPattern) throws IOException {\n        Assert.notNull(locationPattern, \"Location pattern must not be null\");\n\n        // 以 classpath*: 开头\n        if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {\n            // 路径包含通配符，PathMatcher默认是AntPathMatcher\n            if (getPathMatcher().isPattern(\n                locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {\n                return findPathMatchingResources(locationPattern);\n            } else {\n                // 路径不包含通配符\n                return findAllClassPathResources(\n                    locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));\n            }\n        } else {\n            int prefixEnd = (locationPattern.startsWith(\"war:\") ?\n              locationPattern.indexOf(\"*/\") + 1 : locationPattern.indexOf(':') + 1);\n            // 路径包含通配符\n            if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {\n                return findPathMatchingResources(locationPattern);\n            }else {\n                // 不包含通配符也不是以Classpath*：开头，返回指定resource\n                return new Resource[{getResourceLoader().getResource(locationPattern)};\n            }\n        }\n    }\n```\n\n处理逻辑如下\n![pathResourceLoader 逻辑图](/images/pasted-8.png)\n\n下面就 `findAllClassPathResources()`、`findAllClassPathResources()` 做详细分析。\n\n**findAllClassPathResources()**\n\n当 locationPattern 以 classpath*: 开头但是不包含通配符，则调用`findAllClassPathResources()` 方法加载资源。该方法返回 classes 路径下和所有 jar 包中的所有相匹配的资源。\n\n```java\n protected Resource[] findAllClassPathResources(String location) throws IOException {\n        String path = location;\n        if (path.startsWith(\"/\")) {\n            path = path.substring(1);\n        }\n        Set<Resource> result = doFindAllClassPathResources(path);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Resolved classpath location \n                         \t\t[\" + location + \"] to resources \" + result);\n        }\n        return result.toArray(new Resource[0]);\n    }\n```\n\n真正执行加载的是在 `doFindAllClassPathResources()`方法，如下：\n\n```java\n    protected Set<Resource> doFindAllClassPathResources(String path) throws IOException {\n        Set<Resource> result = new LinkedHashSet<>(16);\n        ClassLoader cl = getClassLoader();\n        Enumeration<URL> resourceUrls = (cl != null ? cl.getResources(path) : \n                                         ClassLoader.getSystemResources(path));\n        while (resourceUrls.hasMoreElements()) {\n            URL url = resourceUrls.nextElement();\n            result.add(convertClassLoaderURL(url));\n        }\n        if (\"\".equals(path)) {\n            addAllClassLoaderJarRoots(cl, result);\n        }\n        return result;\n    }\n```\n\n`doFindAllClassPathResources()` 根据 ClassLoader 加载路径下的所有资源。在加载资源过程中如果，在构造 PathMatchingResourcePatternResolver 实例的时候如果传入了 ClassLoader，则调用其 `getResources()`，否则调用`ClassLoader.getSystemResources(path)`。 `ClassLoader.getResources()`如下:\n\n```java\n    public Enumeration<URL> getResources(String name) throws IOException {\n        @SuppressWarnings(\"unchecked\")\n        Enumeration<URL>[] tmp = (Enumeration<URL>[]) new Enumeration<?>[2];\n        if (parent != null) {\n            tmp[0] = parent.getResources(name);\n        } else {\n            tmp[0] = getBootstrapResources(name);\n        }\n        tmp[1] = findResources(name);\n\n        return new CompoundEnumeration<>(tmp);\n    }\n```\n\n看到这里是不是就已经一目了然了？如果当前父类加载器不为 null，则通过父类向上迭代获取资源，否则调用 `getBootstrapResources()`。这里是不是特别熟悉。\n\n若 path 为 空（“”）时，则调用 `addAllClassLoaderJarRoots()`方法。该方法主要是加载路径下得所有 jar 包，方法较长也没有什么实际意义就不贴出来了。不过最后结果在每个jar后面都添加**!/**的原因是java官方规定的，可以看这个连接[jar 中出现!/的原因](https://docs.oracle.com/javase/tutorial/deployment/jar/apiindex.html)\n\n通过上面的分析，我们知道 `findAllClassPathResources()` 其实就是利用 ClassLoader 来加载指定路径下的资源，不过它是在 class 路径下还是在 jar 包中。如果我们传入的路径为空或者 `/`，则会调用 `addAllClassLoaderJarRoots()` 方法加载所有的 jar 包。\n\n**findAllClassPathResources()**\n\n当 locationPattern 以 classpath*: 开头且当中包含了通配符，则调用该方法进行资源加载。如下：\n\n```java\nprotected Resource[] findPathMatchingResources(String locationPattern) throws IOException {\n        // 确定跟路径\n        String rootDirPath = determineRootDir(locationPattern);\n        String subPattern = locationPattern.substring(rootDirPath.length());\n\n        // 获取根据路径下得资源\n        Resource[] rootDirResources = getResources(rootDirPath);\n\n        Set<Resource> result = new LinkedHashSet<>(16);\n        for (Resource rootDirResource : rootDirResources) {\n            rootDirResource = resolveRootDirResource(rootDirResource);\n            URL rootDirUrl = rootDirResource.getURL();\n            // bundle 资源类型\n            if (equinoxResolveMethod != null && \n                \t\trootDirUrl.getProtocol().startsWith(\"bundle\")) {\n                URL resolvedUrl = (URL)ReflectionUtils.invokeMethod(\n                    equinoxResolveMethod, null, rootDirUrl);\n                if (resolvedUrl != null) {\n                    rootDirUrl = resolvedUrl;\n                }\n                rootDirResource = new UrlResource(rootDirUrl);\n            }\n\n            // VFS 资源\n            if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\n                result.addAll(\n                    VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, \n                                                  subPattern, getPathMatcher()));\n            }\n\n            // Jar\n            else if (ResourceUtils.isJarURL(rootDirUrl) || \n                     isJarResource(rootDirResource)) {\n                result.addAll(doFindPathMatchingJarResources(rootDirResource, \n                                                             rootDirUrl, subPattern));\n            }\n            else {\n                result.addAll(doFindPathMatchingFileResources(rootDirResource, \n                                                              subPattern));\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Resolved location pattern [\" + locationPattern + \"] to \n                         resources \" + result);\n        }\n        return result.toArray(new Resource[0]);\n    }\n```\n\n方法有点儿长，但是思路还是很清晰的，主要分两步：\n\n1. 确定目录，获取该目录下得所有资源\n2. 在所获得的所有资源中进行迭代匹配获取我们想要的资源。\n\n在这个方法里面我们要关注两个方法，一个是 `determineRootDir()`,一个是 `doFindPathMatchingFileResources()`。\n\n`determineRootDir()`主要是用于确定根路径，如下：\n\n```java\n    protected String determineRootDir(String location) {\n        int prefixEnd = location.indexOf(':') + 1;\n        int rootDirEnd = location.length();\n        while (rootDirEnd > prefixEnd && getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) {\n            rootDirEnd = location.lastIndexOf('/', rootDirEnd - 2) + 1;\n        }\n        if (rootDirEnd == 0) {\n            rootDirEnd = prefixEnd;\n        }\n        return location.substring(0, rootDirEnd);\n    }\n```\n\n该方法一定要给出一个确定的根目录。该根目录用于确定文件的匹配的起始点，将根目录位置的资源解析为 `java.io.File`并将其传递到 `retrieveMatchingFiles()`，其余为知用于模式匹配，找出我们所需要的资源。\n\n确定根路径如下:\n\n| 原路径                             | 确定根路径            |\n| ---------------------------------- | --------------------- |\n| `classpath*:test/cc*/spring-*.xml` | `classpath*:test/`    |\n| `classpath*:test/aa/spring-*.xml`  | `classpath*:test/aa/` |\n\n确定根路径后，则调用 `getResources()` 方法获取该路径下得所有资源，然后迭代资源获取符合条件的资源。\n\n至此 Spring 整个资源记载过程已经分析完毕。下面简要总结下：\n\n- Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。\n- AbstractResource 为 Resource 的默认实现，它对 Resource 接口做了一个统一的实现，子类继承该类后只需要覆盖相应的方法即可，同时对于自定义的 Resource 我们也是继承该类。\n- DefaultResourceLoader 同样也是 ResourceLoader 的默认实现，在自定 ResourceLoader 的时候我们除了可以继承该类外还可以实现 ProtocolResolver 接口来实现自定资源加载协议。\n- DefaultResourceLoader 每次只能返回单一的资源，所以 Spring 针对这个提供了另外一个接口 ResourcePatternResolver ，该接口提供了根据指定的 locationPattern 返回多个资源的策略。其子类 PathMatchingResourcePatternResolver 是一个集大成者的 ResourceLoader ，因为它即实现了 `Resource getResource(String location)` 也实现了 `Resource[] getResources(String locationPattern)`。","slug":"spring 源码分析/spring/spring源码解析之  03统一资源加载","published":1,"updated":"2019-01-14T04:47:19.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovy100699q1u0wlzfd53","content":"<h1 id=\"spring源码解析之-03统一资源加载\"><a href=\"#spring源码解析之-03统一资源加载\" class=\"headerlink\" title=\"spring源码解析之 03统一资源加载\"></a>spring源码解析之 03统一资源加载</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>统一资源Resource</li>\n<li>统一资源定位ResourceLoader</li>\n</ol>\n<h3 id=\"1-统一资源Resource\"><a href=\"#1-统一资源Resource\" class=\"headerlink\" title=\"1. 统一资源Resource\"></a>1. 统一资源Resource</h3><p>java se中有一个标准类 <code>java.net.URL</code>，该类在 Java SE 中的定位为统一资源定位器（Uniform Resource Locator），但是我们知道它的实现基本只限于网络形式发布的资源的查找和定位。虽然可以通过注册特定的处理器来扩展处理不同的地址前缀，但是这通常比较麻烦。而且不易于使用。另外，实际上资源的定义比较广泛，除了网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等。而且它可以存在于任何场所，比如网络、文件系统、应用程序中。所以 <code>java.net.URL</code> 的局限性迫使 Spring 必须实现自己的资源加载策略，该资源加载策略需要满足如下要求：</p>\n<ol>\n<li>职能划分清楚：资源的定义和资源的加载应该要有一个清晰的界限；</li>\n<li>统一的抽象：统一的资源定义和资源加载策略。资源加载后要返回统一的抽象给客户端，客户端要对资源进行怎样的处理，应该由抽象资源接口来界定。</li>\n</ol>\n<a id=\"more\"></a>\n<p><code>org.springframework.core.io.Resource</code> 为 Spring 框架所有资源的抽象和访问接口，它继承 <code>org.springframework.core.io.InputStreamSource</code>接口。作为所有资源的统一抽象，Source 定义了一些通用的方法，由子类 <code>AbstractResource</code> 提供统一的默认实现。定义如下：</p>\n<pre><code class=\"java\">public interface Resource extends InputStreamSource {\n\n    /**\n     * 资源是否存在\n     */\n    boolean exists();\n\n    /**\n     * 资源是否可读\n     */\n    default boolean isReadable() {\n        return true;\n    }\n\n    /**\n     * 资源所代表的句柄是否被一个stream打开了\n     */\n    default boolean isOpen() {\n        return false;\n    }\n\n    /**\n     * 是否为 File\n     */\n    default boolean isFile() {\n        return false;\n    }\n\n    /**\n     * 返回资源的URL的句柄\n     */\n    URL getURL() throws IOException;\n\n    /**\n     * 返回资源的URI的句柄\n     */\n    URI getURI() throws IOException;\n\n    /**\n     * 返回资源的File的句柄\n     */\n    File getFile() throws IOException;\n\n    /**\n     * 返回 ReadableByteChannel\n     */\n    default ReadableByteChannel readableChannel() throws IOException {\n        return Channels.newChannel(getInputStream());\n    }\n\n    /**\n     * 资源内容的长度\n     */\n    long contentLength() throws IOException;\n\n    /**\n     * 资源最后的修改时间\n     */\n    long lastModified() throws IOException;\n\n    /**\n     * 根据资源的相对路径创建新资源\n     */\n    Resource createRelative(String relativePath) throws IOException;\n\n    /**\n     * 资源的文件名\n     */\n    @Nullable\n    String getFilename();\n\n    /**\n     * 资源的描述\n     */\n    String getDescription();\n\n}\n</code></pre>\n<p><img src=\"/images/pasted-6.png\" alt=\"resource\"></p>\n<p>从上图可以看到，Resource 根据资源的不同类型提供不同的具体实现，如下：</p>\n<ul>\n<li>FileSystemResource：对 <code>java.io.File</code> 类型资源的封装，只要是跟 File 打交道的，基本上与 FileSystemResource 也可以打交道。支持文件和 URL 的形式，实现 WritableResource 接口，且从 Spring Framework 5.0 开始，FileSystemResource 使用NIO.2 API进行读/写交互</li>\n<li>ByteArrayResource：对字节数组提供的数据的封装。如果通过 InputStream 形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的 ByteArrayInputStream。</li>\n<li>UrlResource：对 <code>java.net.URL</code>类型资源的封装。内部委派 URL 进行具体的资源操作。</li>\n<li>ClassPathResource：class path 类型资源的实现。使用给定的 ClassLoader 或者给定的 Class 来加载资源。</li>\n<li>InputStreamResource：将给定的 InputStream 作为一种资源的 Resource 的实现类。</li>\n</ul>\n<p>AbstractResource 为 Resource 接口的默认实现，它实现了 Resource 接口的大部分的公共实现，作为 Resource 接口中的重中之重，其定义如下：</p>\n<pre><code class=\"java\">public abstract class AbstractResource implements Resource {\n\n    /**\n     * 判断文件是否存在，若判断过程产生异常（因为会调用SecurityManager来判断），就关闭对应的流\n     */\n    @Override\n    public boolean exists() {\n        try {\n            return getFile().exists();\n        }\n        catch (IOException ex) {\n            // Fall back to stream existence: can we open the stream?\n            try {\n                InputStream is = getInputStream();\n                is.close();\n                return true;\n            }\n            catch (Throwable isEx) {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * 直接返回true，表示可读\n     */\n    @Override\n    public boolean isReadable() {\n        return true;\n    }\n\n    /**\n     * 直接返回 false，表示未被打开\n     */\n    @Override\n    public boolean isOpen() {\n        return false;\n    }\n\n    /**\n     *  直接返回false，表示不为 File\n     */\n    @Override\n    public boolean isFile() {\n        return false;\n    }\n\n    /**\n     * 抛出 FileNotFoundException 异常，交给子类实现\n     */\n    @Override\n    public URL getURL() throws IOException {\n        throw new FileNotFoundException(getDescription() + &quot; cannot be resolved to URL&quot;);\n    }\n\n    /**\n     * 基于 getURL() 返回的 URL 构建 URI\n     */\n    @Override\n    public URI getURI() throws IOException {\n        URL url = getURL();\n        try {\n            return ResourceUtils.toURI(url);\n        }\n        catch (URISyntaxException ex) {\n            throw new NestedIOException(&quot;Invalid URI [&quot; + url + &quot;]&quot;, ex);\n        }\n    }\n\n    /**\n     * 抛出 FileNotFoundException 异常，交给子类实现\n     */\n    @Override\n    public File getFile() throws IOException {\n        throw new FileNotFoundException(getDescription() + &quot; cannot be resolved to absolute file path&quot;);\n    }\n\n    /**\n     * 根据 getInputStream() 的返回结果构建 ReadableByteChannel\n     */\n    @Override\n    public ReadableByteChannel readableChannel() throws IOException {\n        return Channels.newChannel(getInputStream());\n    }\n\n    /**\n     * 获取资源的长度\n     *\n     * 这个资源内容长度实际就是资源的字节长度，通过全部读取一遍来判断\n     */\n    @Override\n    public long contentLength() throws IOException {\n        InputStream is = getInputStream();\n        try {\n            long size = 0;\n            byte[] buf = new byte[255];\n            int read;\n            while ((read = is.read(buf)) != -1) {\n                size += read;\n            }\n            return size;\n        }\n        finally {\n            try {\n                is.close();\n            }\n            catch (IOException ex) {\n            }\n        }\n    }\n\n    /**\n     * 返回资源最后的修改时间\n     */\n    @Override\n    public long lastModified() throws IOException {\n        long lastModified = getFileForLastModifiedCheck().lastModified();\n        if (lastModified == 0L) {\n            throw new FileNotFoundException(getDescription() +\n                    &quot; cannot be resolved in the file system for resolving its last-modified timestamp&quot;);\n        }\n        return lastModified;\n    }\n\n\n    protected File getFileForLastModifiedCheck() throws IOException {\n        return getFile();\n    }\n\n    /**\n     * 交给子类实现\n     */\n    @Override\n    public Resource createRelative(String relativePath) throws IOException {\n        throw new FileNotFoundException(&quot;Cannot create a relative resource for &quot; + getDescription());\n    }\n\n    /**\n     * 获取资源名称，默认返回 null\n     */\n    @Override\n    @Nullable\n    public String getFilename() {\n        return null;\n    }\n\n\n    /**\n     * 返回资源的描述\n     */\n    @Override\n    public String toString() {\n        return getDescription();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        return (obj == this ||\n            (obj instanceof Resource &amp;&amp; ((Resource) obj).getDescription().equals(getDescription())));\n    }\n\n    @Override\n    public int hashCode() {\n        return getDescription().hashCode();\n    }\n\n}\n</code></pre>\n<p>如果我们想要实现自定义的 Resource，记住不要实现 Resource 接口，而应该继承 AbstractResource 抽象类，然后根据当前的具体资源特性覆盖相应的方法即可。</p>\n<h3 id=\"2-统一资源定位：ResourceLoader\"><a href=\"#2-统一资源定位：ResourceLoader\" class=\"headerlink\" title=\"2. 统一资源定位：ResourceLoader\"></a>2. 统一资源定位：ResourceLoader</h3><p>一开始就说了 Spring 将资源的定义和资源的加载区分开了，Resource 定义了统一的资源，那资源的加载则由 ResourceLoader 来统一定义。</p>\n<p><code>org.springframework.core.io.ResourceLoader</code> 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器。其定义如下：</p>\n<pre><code class=\"java\">public interface ResourceLoader {\n    String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;\n\n    Resource getResource(String location);\n\n    ClassLoader getClassLoader();\n}\n</code></pre>\n<p>ResourceLoader 接口提供两个方法：<code>getResource()</code>、<code>getClassLoader()</code>。</p>\n<p><code>getResource()</code>根据所提供资源的路径 location 返回 Resource 实例，但是它不确保该 Resource 一定存在，需要调用 <code>Resource.exist()</code>方法判断。该方法支持以下模式的资源加载：</p>\n<ul>\n<li>URL位置资源，如”file:C:/test.dat”</li>\n<li>ClassPath位置资源，如”classpath:test.dat”</li>\n<li>相对路径资源，如”WEB-INF/test.dat”，此时返回的Resource实例根据实现不同而不同</li>\n</ul>\n<p>该方法的主要实现是在其子类 DefaultResourceLoader 中实现，具体过程我们在分析 DefaultResourceLoader 时做详细说明。</p>\n<p>对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用 <code>getClassLoader()</code> 方法获得。在分析 Resource 时，提到了一个类 ClassPathResource ，这个类是可以根据指定的 ClassLoader 来加载资源的。</p>\n<p>作为 Spring 统一的资源加载器，它提供了统一的抽象，具体的实现则由相应的子类来负责实现，其类的类结构图如下：<br><img src=\"/images/pasted-6.png\" alt=\"resourceloader\"></p>\n<h4 id=\"DefaultResourceLoader\"><a href=\"#DefaultResourceLoader\" class=\"headerlink\" title=\"DefaultResourceLoader\"></a>DefaultResourceLoader</h4><p>与 AbstractResource 相似，DefaultResourceLoader 是 ResourceLoader 的默认实现，它接收 ClassLoader 作为构造函数的参数或者使用不带参数的构造函数，在使用不带参数的构造函数时，使用的 ClassLoader 为默认的 ClassLoader（一般为<code>Thread.currentThread().getContextClassLoader()</code>），可以通过 <code>ClassUtils.getDefaultClassLoader()</code>获取。当然也可以调用 <code>setClassLoader()</code>方法进行后续设置。如下</p>\n<pre><code class=\"java\"> public DefaultResourceLoader() {\n        this.classLoader = ClassUtils.getDefaultClassLoader();\n    }\n\n    public DefaultResourceLoader(@Nullable ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    public void setClassLoader(@Nullable ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    @Override\n    @Nullable\n    public ClassLoader getClassLoader() {\n        return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());\n    }\n</code></pre>\n<p>ResourceLoader 中最核心的方法为 <code>getResource()</code>,它根据提供的 location 返回相应的 Resource，而 DefaultResourceLoader 对该方法提供了核心实现(它的两个子类都没有提供覆盖该方法，所以可以断定ResourceLoader 的资源加载策略就封装 DefaultResourceLoader中)，如下：</p>\n<pre><code class=\"java\">    public Resource getResource(String location) {\n        Assert.notNull(location, &quot;Location must not be null&quot;);\n\n        for (ProtocolResolver protocolResolver : this.protocolResolvers) {\n            Resource resource = protocolResolver.resolve(location, this);\n            if (resource != null) {\n                return resource;\n            }\n        }\n\n        if (location.startsWith(&quot;/&quot;)) {\n            return getResourceByPath(location);\n        }\n        else if (location.startsWith(CLASSPATH_URL_PREFIX)) {\n            return new \n                ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), \n                                         getClassLoader());\n        }\n        else {\n            try {\n                // Try to parse the location as a URL...\n                URL url = new URL(location);\n                return (ResourceUtils.isFileURL(url) ? \n                        new FileUrlResource(url) : new UrlResource(url));\n            }\n            catch (MalformedURLException ex) {\n                // No URL -&gt; resolve as resource path.\n                return getResourceByPath(location);\n            }\n        }\n    }\n</code></pre>\n<p>首先通过 ProtocolResolver 来加载资源，成功返回 Resource，否则调用如下逻辑：</p>\n<ul>\n<li>若 location 以 / 开头，则调用 <code>getResourceByPath()</code>构造 ClassPathContextResource 类型资源并返回。</li>\n<li>若 location 以 classpath: 开头，则构造 ClassPathResource 类型资源并返回，在构造该资源时，通过 <code>getClassLoader()</code>获取当前的 ClassLoader。</li>\n<li>构造 URL ，尝试通过它进行资源定位，若没有抛出 MalformedURLException 异常，则判断是否为 FileURL , 如果是则构造 FileUrlResource 类型资源，否则构造 UrlResource。若在加载过程中抛出 MalformedURLException 异常，则委派 <code>getResourceByPath()</code> 实现资源定位加载。</li>\n</ul>\n<p>这里有一点要注意的是，返回了resource不代表这个资源存在，和前面介绍resource一样，需要通过exitsts来确认文件的存在。</p>\n<p>ProtocolResolver ，用户自定义协议资源解决策略，作为 DefaultResourceLoader 的 SPI，它允许用户自定义资源加载协议，而不需要继承 ResourceLoader 的子类。在介绍 Resource 时，提到如果要实现自定义 Resource，我们只需要继承 DefaultResource 即可，但是有了 ProtocolResolver 后，我们不需要直接继承 DefaultResourceLoader，改为实现 ProtocolResolver 接口也可以实现自定义的 ResourceLoader。<br>ProtocolResolver 接口，仅有一个方法 <code>Resource resolve(String location, ResourceLoader resourceLoader)</code>，该方法接收两个参数：资源路径location，指定的加载器 ResourceLoader，返回为相应的 Resource 。在 Spring 中你会发现该接口并没有实现类，它需要用户自定义，自定义的 Resolver 如何加入 Spring 体系呢？调用 <code>DefaultResourceLoader.addProtocolResolver()</code> 即可，如下：</p>\n<pre><code class=\"java\">    public void addProtocolResolver(ProtocolResolver resolver) {\n        Assert.notNull(resolver, &quot;ProtocolResolver must not be null&quot;);\n        this.protocolResolvers.add(resolver);\n    }\n</code></pre>\n<p>下面是我写的一个简单ProtocolResolver的demo，演示了使用方式，如果你希望添加自定义的文件格式解析，可以向下面这样添加。</p>\n<pre><code class=\"java\">   /**\n     * 测试ProtocolResolver\n     */\n    public static void main(String[] args) {\n        DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader();\n        defaultResourceLoader.getProtocolResolvers().forEach(System.out::println);\n\n        defaultResourceLoader.addProtocolResolver(new \n                CustomerResourceProtocolResolver());\n        System.out.println(defaultResourceLoader.getResource(&quot;/Users/zhangke/HTTP请求.jmx&quot;).exists());\n    }\n\n    static class CustomerResourceProtocolResolver implements ProtocolResolver {\n\n        @Override\n        public Resource resolve(String location, ResourceLoader resourceLoader) {\n            FileSystemResource fileSystemResource = new FileSystemResource(location);\n            return fileSystemResource;\n        }\n    }\n</code></pre>\n<p>下面示例是演示 DefaultResourceLoader 加载资源的具体策略，代码如下（该示例参考《Spring 解密》 P89）：</p>\n<pre><code class=\"java\">        ResourceLoader resourceLoader = new DefaultResourceLoader();\n\n        Resource fileResource1 = resourceLoader.getResource(&quot;D:/Users/chenming673/Documents/spark.txt&quot;);\n        System.out.println(&quot;fileResource1 is FileSystemResource:&quot; + (fileResource1 instanceof FileSystemResource));\n\n        Resource fileResource2 = resourceLoader.getResource(&quot;/Users/chenming673/Documents/spark.txt&quot;);\n        System.out.println(&quot;fileResource2 is ClassPathResource:&quot; + (fileResource2 instanceof ClassPathResource));\n\n        Resource urlResource1 = resourceLoader.getResource(&quot;file:/Users/chenming673/Documents/spark.txt&quot;);\n        System.out.println(&quot;urlResource1 is UrlResource:&quot; + (urlResource1 instanceof UrlResource));\n\n        Resource urlResource2 = resourceLoader.getResource(&quot;http://www.baidu.com&quot;);\n        System.out.println(&quot;urlResource1 is urlResource:&quot; + (urlResource2 instanceof  UrlResource));\n</code></pre>\n<p>运行结果：</p>\n<pre><code>fileResource1 is FileSystemResource:false\nfileResource2 is ClassPathResource:true\nurlResource1 is UrlResource:true\nurlResource1 is urlResource:true\n</code></pre><p>其实对于 fileResource1 我们更加希望是 FileSystemResource 资源类型，但是事与愿违，它是 ClassPathResource 类型。在<code>getResource()</code>资源加载策略中，我们知道 <code>D:/Users/chenming673/Documents/spark.txt</code>资源其实在该方法中没有相应的资源类型，那么它就会在抛出 MalformedURLException 异常时通过 <code>getResourceByPath()</code> 构造一个 ClassPathResource 类型的资源。而指定有协议前缀的资源路径，则通过 URL 就可以定义，所以返回的都是UrlResource类型。</p>\n<h4 id=\"FileSystemResourceLoader\"><a href=\"#FileSystemResourceLoader\" class=\"headerlink\" title=\"FileSystemResourceLoader\"></a>FileSystemResourceLoader</h4><p>从上面的示例我们看到，其实 DefaultResourceLoader 对<code>getResourceByPath(String)</code>方法处理其实不是很恰当，这个时候我们可以使用 FileSystemResourceLoader ，它继承 DefaultResourceLoader 且覆写了 <code>getResourceByPath(String)</code>，使之从文件系统加载资源并以 FileSystemResource 类型返回，这样我们就可以得到想要的资源类型，如下：</p>\n<pre><code class=\"java\">    @Override\n    protected Resource getResourceByPath(String path) {\n        if (path.startsWith(&quot;/&quot;)) {\n            path = path.substring(1);\n        }\n        return new FileSystemContextResource(path);\n    }\n</code></pre>\n<p>FileSystemContextResource 为 FileSystemResourceLoader 的内部类，它继承 FileSystemResource。</p>\n<pre><code class=\"java\">    private static class FileSystemContextResource extends FileSystemResource implements ContextResource {\n\n        public FileSystemContextResource(String path) {\n            super(path);\n        }\n\n        @Override\n        public String getPathWithinContext() {\n            return getPath();\n        }\n    }\n</code></pre>\n<p>在构造器中也是调用 FileSystemResource 的构造方法来构造 FileSystemResource 的。</p>\n<p>如果将上面的示例将 DefaultResourceLoader 改为 FileSystemContextResource ，则 fileResource1 则为 FileSystemResource。</p>\n<h4 id=\"ResourcePatternResolver\"><a href=\"#ResourcePatternResolver\" class=\"headerlink\" title=\"ResourcePatternResolver\"></a>ResourcePatternResolver</h4><p>ResourceLoader 的 <code>Resource getResource(String location)</code> 每次只能根据 location 返回一个 Resource，当需要加载多个资源时，我们除了多次调用 <code>getResource()</code> 外别无他法。ResourcePatternResolver 是 ResourceLoader 的扩展，它支持根据指定的资源路径匹配模式每次返回多个 Resource 实例，其定义如下：</p>\n<pre><code class=\"java\">public interface ResourcePatternResolver extends ResourceLoader {\n    String CLASSPATH_ALL_URL_PREFIX = &quot;classpath*:&quot;;\n\n    Resource[] getResources(String locationPattern) throws IOException;\n}\n</code></pre>\n<p>ResourcePatternResolver 在 ResourceLoader 的基础上增加了 <code>getResources(String locationPattern)</code>，以支持根据路径匹配模式返回多个 Resource 实例，同时也新增了一种新的协议前缀 <code>classpath*:</code>，该协议前缀由其子类负责实现。</p>\n<p>PathMatchingResourcePatternResolver 为 ResourcePatternResolver 最常用的子类，它除了支持 ResourceLoader 和 ResourcePatternResolver 新增的 classpath*: 前缀外，还支持 Ant 风格的路径匹配模式。</p>\n<p>这里先介绍什么是Ant风格的路径匹配模式，主要由以下规则，</p>\n<ul>\n<li>？匹配一个字符</li>\n<li><code>*</code>匹配0个或多个字符</li>\n<li>** 在路径中匹配0个或多个文件夹</li>\n<li>{spring;[a-z]+}，匹配正则表达式<code>[a-z]+</code>并将结果存在名为“spring”变量中。</li>\n</ul>\n<p>例子</p>\n<ul>\n<li><code>com/t?st.jsp</code> —匹配 <code>com/test.jsp</code> 、 <code>com/tast.jsp</code> 、<code>com/txst.jsp</code></li>\n<li><code>com/*.jsp</code> — 匹配com目录线面所有的l <code>.jsp</code> 文件</li>\n<li><code>com/**/test.jsp</code> —匹配com目录还有子目录下所有的 <code>test.jsp</code></li>\n<li><code>org/springframework/**/*.jsp</code> — 匹配 <code>org/springframework</code> 目录和子目录下所有的 <code>.jsp</code> </li>\n<li><code>org/**/servlet/bla.jsp</code> — 匹配<code>org/springframework/servlet/bla.jsp</code> 、<code>org/springframework/testing/servlet/bla.jsp</code> 、 <code>org/servlet/bla.jsp</code></li>\n<li><code>com/{filename:\\\\w+}.jsp</code> 匹配 <code>com/test.jsp</code> 并且将值 <code>test</code> 付给 <code>filename</code>变量</li>\n</ul>\n<p>在spring经常使用<code>AntPathMatcher</code>来进行操作这些ant风格的路径匹配模式</p>\n<p>小案例如下</p>\n<pre><code class=\"java\">/**************************************\n *      Author : zhangke\n *      Date   : 2019-01-08 17:44\n *      email  : 398757724@qq.com\n *      Desc   : ant 风格小案例\n ***************************************/\npublic class AntPathMatcherStudy {\n    public static void main(String[] args) {\n        AntPathMatcher antPathMatcher = new AntPathMatcher();\n\n\n        // com/t?st.jsp — matches com/test.jsp but also com/tast.jsp or com/txst.jsp\n        System.out.println(antPathMatcher.match(&quot;com/t?st.jsp&quot;, &quot;com/test.jsp&quot;));\n        System.out.println(antPathMatcher.match(&quot;com/t?st.jsp&quot;, &quot;com/tast.jsp&quot;));\n        System.out.println(antPathMatcher.match(&quot;com/t?st.jsp&quot;, &quot;com/txst.jsp&quot;));\n\n\n        // com/*.jsp — matches all .jsp files in the com directory\n        System.out.println(antPathMatcher.match(&quot;com/*.jsp&quot;, &quot;com/test.jsp&quot;));\n        System.out.println(antPathMatcher.match(&quot;com/*.jsp&quot;, &quot;com/tast.jsp&quot;));\n        System.out.println(antPathMatcher.match(&quot;com/*.jsp&quot;, &quot;com/txst.jsp&quot;));\n\n\n        //org/springframework/**/*.jsp — matches all .jsp files underneath the org/springframework path\n        System.out.println(antPathMatcher.match(&quot;org/springframework/**/*.jsp&quot;, &quot;org/springframework/com/test.jsp&quot;));\n        System.out.println(antPathMatcher.match(&quot;org/springframework/**/*.jsp&quot;, &quot;org/springframework/test/com/tast.jsp&quot;));\n        System.out.println(antPathMatcher.match(&quot;org/springframework/**/*.jsp&quot;, &quot;org/springframework/ddd/txst.jsp&quot;));\n\n        // com/{filename:\\\\w+}.jsp will match com/test.jsp and assign the value test to the filename variable\n        System.out.println(antPathMatcher.extractUriTemplateVariables(&quot;/test/{spring:[a-z]+}/test.jsp&quot;, &quot;/test/test/test.jsp&quot;));\n\n    }\n</code></pre>\n<p>运行结果</p>\n<pre><code class=\"java\">true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\n{spring=test}\n</code></pre>\n<p>PathMatchingResourcePatternResolver 提供了三个构造方法，如下：</p>\n<pre><code class=\"java\">    public PathMatchingResourcePatternResolver() {\n        this.resourceLoader = new DefaultResourceLoader();\n    }\n\n    public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {\n        Assert.notNull(resourceLoader, &quot;ResourceLoader must not be null&quot;);\n        this.resourceLoader = resourceLoader;\n    }\n\n    public PathMatchingResourcePatternResolver(@Nullable ClassLoader classLoader) {\n        this.resourceLoader = new DefaultResourceLoader(classLoader);\n    }\n</code></pre>\n<p>PathMatchingResourcePatternResolver 在实例化的时候，可以指定一个 ResourceLoader，如果不指定的话，它会在内部构造一个 DefaultResourceLoader。</p>\n<p><strong>Resource getResource(String location)</strong></p>\n<pre><code class=\"java\">    @Override\n    public Resource getResource(String location) {\n        return getResourceLoader().getResource(location);\n    }\n</code></pre>\n<p><code>getResource()</code> 方法直接委托给相应的 ResourceLoader 来实现，所以如果我们在实例化的 PathMatchingResourcePatternResolver 的时候，如果不知道 ResourceLoader ，那么在加载资源时，其实就是 DefaultResourceLoader 的过程。其实在下面介绍的 <code>Resource[] getResources(String locationPattern)</code> 也相同，只不过返回的资源时多个而已。</p>\n<pre><code class=\"java\"> public Resource[] getResources(String locationPattern) throws IOException {\n        Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;);\n\n        // 以 classpath*: 开头\n        if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {\n            // 路径包含通配符，PathMatcher默认是AntPathMatcher\n            if (getPathMatcher().isPattern(\n                locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {\n                return findPathMatchingResources(locationPattern);\n            } else {\n                // 路径不包含通配符\n                return findAllClassPathResources(\n                    locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));\n            }\n        } else {\n            int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ?\n              locationPattern.indexOf(&quot;*/&quot;) + 1 : locationPattern.indexOf(&#39;:&#39;) + 1);\n            // 路径包含通配符\n            if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {\n                return findPathMatchingResources(locationPattern);\n            }else {\n                // 不包含通配符也不是以Classpath*：开头，返回指定resource\n                return new Resource[{getResourceLoader().getResource(locationPattern)};\n            }\n        }\n    }\n</code></pre>\n<p>处理逻辑如下<br><img src=\"/images/pasted-8.png\" alt=\"pathResourceLoader 逻辑图\"></p>\n<p>下面就 <code>findAllClassPathResources()</code>、<code>findAllClassPathResources()</code> 做详细分析。</p>\n<p><strong>findAllClassPathResources()</strong></p>\n<p>当 locationPattern 以 classpath*: 开头但是不包含通配符，则调用<code>findAllClassPathResources()</code> 方法加载资源。该方法返回 classes 路径下和所有 jar 包中的所有相匹配的资源。</p>\n<pre><code class=\"java\"> protected Resource[] findAllClassPathResources(String location) throws IOException {\n        String path = location;\n        if (path.startsWith(&quot;/&quot;)) {\n            path = path.substring(1);\n        }\n        Set&lt;Resource&gt; result = doFindAllClassPathResources(path);\n        if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Resolved classpath location \n                                 [&quot; + location + &quot;] to resources &quot; + result);\n        }\n        return result.toArray(new Resource[0]);\n    }\n</code></pre>\n<p>真正执行加载的是在 <code>doFindAllClassPathResources()</code>方法，如下：</p>\n<pre><code class=\"java\">    protected Set&lt;Resource&gt; doFindAllClassPathResources(String path) throws IOException {\n        Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16);\n        ClassLoader cl = getClassLoader();\n        Enumeration&lt;URL&gt; resourceUrls = (cl != null ? cl.getResources(path) : \n                                         ClassLoader.getSystemResources(path));\n        while (resourceUrls.hasMoreElements()) {\n            URL url = resourceUrls.nextElement();\n            result.add(convertClassLoaderURL(url));\n        }\n        if (&quot;&quot;.equals(path)) {\n            addAllClassLoaderJarRoots(cl, result);\n        }\n        return result;\n    }\n</code></pre>\n<p><code>doFindAllClassPathResources()</code> 根据 ClassLoader 加载路径下的所有资源。在加载资源过程中如果，在构造 PathMatchingResourcePatternResolver 实例的时候如果传入了 ClassLoader，则调用其 <code>getResources()</code>，否则调用<code>ClassLoader.getSystemResources(path)</code>。 <code>ClassLoader.getResources()</code>如下:</p>\n<pre><code class=\"java\">    public Enumeration&lt;URL&gt; getResources(String name) throws IOException {\n        @SuppressWarnings(&quot;unchecked&quot;)\n        Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) new Enumeration&lt;?&gt;[2];\n        if (parent != null) {\n            tmp[0] = parent.getResources(name);\n        } else {\n            tmp[0] = getBootstrapResources(name);\n        }\n        tmp[1] = findResources(name);\n\n        return new CompoundEnumeration&lt;&gt;(tmp);\n    }\n</code></pre>\n<p>看到这里是不是就已经一目了然了？如果当前父类加载器不为 null，则通过父类向上迭代获取资源，否则调用 <code>getBootstrapResources()</code>。这里是不是特别熟悉。</p>\n<p>若 path 为 空（“”）时，则调用 <code>addAllClassLoaderJarRoots()</code>方法。该方法主要是加载路径下得所有 jar 包，方法较长也没有什么实际意义就不贴出来了。不过最后结果在每个jar后面都添加<strong>!/</strong>的原因是java官方规定的，可以看这个连接<a href=\"https://docs.oracle.com/javase/tutorial/deployment/jar/apiindex.html\" target=\"_blank\" rel=\"noopener\">jar 中出现!/的原因</a></p>\n<p>通过上面的分析，我们知道 <code>findAllClassPathResources()</code> 其实就是利用 ClassLoader 来加载指定路径下的资源，不过它是在 class 路径下还是在 jar 包中。如果我们传入的路径为空或者 <code>/</code>，则会调用 <code>addAllClassLoaderJarRoots()</code> 方法加载所有的 jar 包。</p>\n<p><strong>findAllClassPathResources()</strong></p>\n<p>当 locationPattern 以 classpath*: 开头且当中包含了通配符，则调用该方法进行资源加载。如下：</p>\n<pre><code class=\"java\">protected Resource[] findPathMatchingResources(String locationPattern) throws IOException {\n        // 确定跟路径\n        String rootDirPath = determineRootDir(locationPattern);\n        String subPattern = locationPattern.substring(rootDirPath.length());\n\n        // 获取根据路径下得资源\n        Resource[] rootDirResources = getResources(rootDirPath);\n\n        Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16);\n        for (Resource rootDirResource : rootDirResources) {\n            rootDirResource = resolveRootDirResource(rootDirResource);\n            URL rootDirUrl = rootDirResource.getURL();\n            // bundle 资源类型\n            if (equinoxResolveMethod != null &amp;&amp; \n                        rootDirUrl.getProtocol().startsWith(&quot;bundle&quot;)) {\n                URL resolvedUrl = (URL)ReflectionUtils.invokeMethod(\n                    equinoxResolveMethod, null, rootDirUrl);\n                if (resolvedUrl != null) {\n                    rootDirUrl = resolvedUrl;\n                }\n                rootDirResource = new UrlResource(rootDirUrl);\n            }\n\n            // VFS 资源\n            if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\n                result.addAll(\n                    VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, \n                                                  subPattern, getPathMatcher()));\n            }\n\n            // Jar\n            else if (ResourceUtils.isJarURL(rootDirUrl) || \n                     isJarResource(rootDirResource)) {\n                result.addAll(doFindPathMatchingJarResources(rootDirResource, \n                                                             rootDirUrl, subPattern));\n            }\n            else {\n                result.addAll(doFindPathMatchingFileResources(rootDirResource, \n                                                              subPattern));\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Resolved location pattern [&quot; + locationPattern + &quot;] to \n                         resources &quot; + result);\n        }\n        return result.toArray(new Resource[0]);\n    }\n</code></pre>\n<p>方法有点儿长，但是思路还是很清晰的，主要分两步：</p>\n<ol>\n<li>确定目录，获取该目录下得所有资源</li>\n<li>在所获得的所有资源中进行迭代匹配获取我们想要的资源。</li>\n</ol>\n<p>在这个方法里面我们要关注两个方法，一个是 <code>determineRootDir()</code>,一个是 <code>doFindPathMatchingFileResources()</code>。</p>\n<p><code>determineRootDir()</code>主要是用于确定根路径，如下：</p>\n<pre><code class=\"java\">    protected String determineRootDir(String location) {\n        int prefixEnd = location.indexOf(&#39;:&#39;) + 1;\n        int rootDirEnd = location.length();\n        while (rootDirEnd &gt; prefixEnd &amp;&amp; getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) {\n            rootDirEnd = location.lastIndexOf(&#39;/&#39;, rootDirEnd - 2) + 1;\n        }\n        if (rootDirEnd == 0) {\n            rootDirEnd = prefixEnd;\n        }\n        return location.substring(0, rootDirEnd);\n    }\n</code></pre>\n<p>该方法一定要给出一个确定的根目录。该根目录用于确定文件的匹配的起始点，将根目录位置的资源解析为 <code>java.io.File</code>并将其传递到 <code>retrieveMatchingFiles()</code>，其余为知用于模式匹配，找出我们所需要的资源。</p>\n<p>确定根路径如下:</p>\n<table>\n<thead>\n<tr>\n<th>原路径</th>\n<th>确定根路径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>classpath*:test/cc*/spring-*.xml</code></td>\n<td><code>classpath*:test/</code></td>\n</tr>\n<tr>\n<td><code>classpath*:test/aa/spring-*.xml</code></td>\n<td><code>classpath*:test/aa/</code></td>\n</tr>\n</tbody>\n</table>\n<p>确定根路径后，则调用 <code>getResources()</code> 方法获取该路径下得所有资源，然后迭代资源获取符合条件的资源。</p>\n<p>至此 Spring 整个资源记载过程已经分析完毕。下面简要总结下：</p>\n<ul>\n<li>Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。</li>\n<li>AbstractResource 为 Resource 的默认实现，它对 Resource 接口做了一个统一的实现，子类继承该类后只需要覆盖相应的方法即可，同时对于自定义的 Resource 我们也是继承该类。</li>\n<li>DefaultResourceLoader 同样也是 ResourceLoader 的默认实现，在自定 ResourceLoader 的时候我们除了可以继承该类外还可以实现 ProtocolResolver 接口来实现自定资源加载协议。</li>\n<li>DefaultResourceLoader 每次只能返回单一的资源，所以 Spring 针对这个提供了另外一个接口 ResourcePatternResolver ，该接口提供了根据指定的 locationPattern 返回多个资源的策略。其子类 PathMatchingResourcePatternResolver 是一个集大成者的 ResourceLoader ，因为它即实现了 <code>Resource getResource(String location)</code> 也实现了 <code>Resource[] getResources(String locationPattern)</code>。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"spring源码解析之-03统一资源加载\"><a href=\"#spring源码解析之-03统一资源加载\" class=\"headerlink\" title=\"spring源码解析之 03统一资源加载\"></a>spring源码解析之 03统一资源加载</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>统一资源Resource</li>\n<li>统一资源定位ResourceLoader</li>\n</ol>\n<h3 id=\"1-统一资源Resource\"><a href=\"#1-统一资源Resource\" class=\"headerlink\" title=\"1. 统一资源Resource\"></a>1. 统一资源Resource</h3><p>java se中有一个标准类 <code>java.net.URL</code>，该类在 Java SE 中的定位为统一资源定位器（Uniform Resource Locator），但是我们知道它的实现基本只限于网络形式发布的资源的查找和定位。虽然可以通过注册特定的处理器来扩展处理不同的地址前缀，但是这通常比较麻烦。而且不易于使用。另外，实际上资源的定义比较广泛，除了网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等。而且它可以存在于任何场所，比如网络、文件系统、应用程序中。所以 <code>java.net.URL</code> 的局限性迫使 Spring 必须实现自己的资源加载策略，该资源加载策略需要满足如下要求：</p>\n<ol>\n<li>职能划分清楚：资源的定义和资源的加载应该要有一个清晰的界限；</li>\n<li>统一的抽象：统一的资源定义和资源加载策略。资源加载后要返回统一的抽象给客户端，客户端要对资源进行怎样的处理，应该由抽象资源接口来界定。</li>\n</ol>","more":"<p><code>org.springframework.core.io.Resource</code> 为 Spring 框架所有资源的抽象和访问接口，它继承 <code>org.springframework.core.io.InputStreamSource</code>接口。作为所有资源的统一抽象，Source 定义了一些通用的方法，由子类 <code>AbstractResource</code> 提供统一的默认实现。定义如下：</p>\n<pre><code class=\"java\">public interface Resource extends InputStreamSource {\n\n    /**\n     * 资源是否存在\n     */\n    boolean exists();\n\n    /**\n     * 资源是否可读\n     */\n    default boolean isReadable() {\n        return true;\n    }\n\n    /**\n     * 资源所代表的句柄是否被一个stream打开了\n     */\n    default boolean isOpen() {\n        return false;\n    }\n\n    /**\n     * 是否为 File\n     */\n    default boolean isFile() {\n        return false;\n    }\n\n    /**\n     * 返回资源的URL的句柄\n     */\n    URL getURL() throws IOException;\n\n    /**\n     * 返回资源的URI的句柄\n     */\n    URI getURI() throws IOException;\n\n    /**\n     * 返回资源的File的句柄\n     */\n    File getFile() throws IOException;\n\n    /**\n     * 返回 ReadableByteChannel\n     */\n    default ReadableByteChannel readableChannel() throws IOException {\n        return Channels.newChannel(getInputStream());\n    }\n\n    /**\n     * 资源内容的长度\n     */\n    long contentLength() throws IOException;\n\n    /**\n     * 资源最后的修改时间\n     */\n    long lastModified() throws IOException;\n\n    /**\n     * 根据资源的相对路径创建新资源\n     */\n    Resource createRelative(String relativePath) throws IOException;\n\n    /**\n     * 资源的文件名\n     */\n    @Nullable\n    String getFilename();\n\n    /**\n     * 资源的描述\n     */\n    String getDescription();\n\n}\n</code></pre>\n<p><img src=\"/images/pasted-6.png\" alt=\"resource\"></p>\n<p>从上图可以看到，Resource 根据资源的不同类型提供不同的具体实现，如下：</p>\n<ul>\n<li>FileSystemResource：对 <code>java.io.File</code> 类型资源的封装，只要是跟 File 打交道的，基本上与 FileSystemResource 也可以打交道。支持文件和 URL 的形式，实现 WritableResource 接口，且从 Spring Framework 5.0 开始，FileSystemResource 使用NIO.2 API进行读/写交互</li>\n<li>ByteArrayResource：对字节数组提供的数据的封装。如果通过 InputStream 形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的 ByteArrayInputStream。</li>\n<li>UrlResource：对 <code>java.net.URL</code>类型资源的封装。内部委派 URL 进行具体的资源操作。</li>\n<li>ClassPathResource：class path 类型资源的实现。使用给定的 ClassLoader 或者给定的 Class 来加载资源。</li>\n<li>InputStreamResource：将给定的 InputStream 作为一种资源的 Resource 的实现类。</li>\n</ul>\n<p>AbstractResource 为 Resource 接口的默认实现，它实现了 Resource 接口的大部分的公共实现，作为 Resource 接口中的重中之重，其定义如下：</p>\n<pre><code class=\"java\">public abstract class AbstractResource implements Resource {\n\n    /**\n     * 判断文件是否存在，若判断过程产生异常（因为会调用SecurityManager来判断），就关闭对应的流\n     */\n    @Override\n    public boolean exists() {\n        try {\n            return getFile().exists();\n        }\n        catch (IOException ex) {\n            // Fall back to stream existence: can we open the stream?\n            try {\n                InputStream is = getInputStream();\n                is.close();\n                return true;\n            }\n            catch (Throwable isEx) {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * 直接返回true，表示可读\n     */\n    @Override\n    public boolean isReadable() {\n        return true;\n    }\n\n    /**\n     * 直接返回 false，表示未被打开\n     */\n    @Override\n    public boolean isOpen() {\n        return false;\n    }\n\n    /**\n     *  直接返回false，表示不为 File\n     */\n    @Override\n    public boolean isFile() {\n        return false;\n    }\n\n    /**\n     * 抛出 FileNotFoundException 异常，交给子类实现\n     */\n    @Override\n    public URL getURL() throws IOException {\n        throw new FileNotFoundException(getDescription() + &quot; cannot be resolved to URL&quot;);\n    }\n\n    /**\n     * 基于 getURL() 返回的 URL 构建 URI\n     */\n    @Override\n    public URI getURI() throws IOException {\n        URL url = getURL();\n        try {\n            return ResourceUtils.toURI(url);\n        }\n        catch (URISyntaxException ex) {\n            throw new NestedIOException(&quot;Invalid URI [&quot; + url + &quot;]&quot;, ex);\n        }\n    }\n\n    /**\n     * 抛出 FileNotFoundException 异常，交给子类实现\n     */\n    @Override\n    public File getFile() throws IOException {\n        throw new FileNotFoundException(getDescription() + &quot; cannot be resolved to absolute file path&quot;);\n    }\n\n    /**\n     * 根据 getInputStream() 的返回结果构建 ReadableByteChannel\n     */\n    @Override\n    public ReadableByteChannel readableChannel() throws IOException {\n        return Channels.newChannel(getInputStream());\n    }\n\n    /**\n     * 获取资源的长度\n     *\n     * 这个资源内容长度实际就是资源的字节长度，通过全部读取一遍来判断\n     */\n    @Override\n    public long contentLength() throws IOException {\n        InputStream is = getInputStream();\n        try {\n            long size = 0;\n            byte[] buf = new byte[255];\n            int read;\n            while ((read = is.read(buf)) != -1) {\n                size += read;\n            }\n            return size;\n        }\n        finally {\n            try {\n                is.close();\n            }\n            catch (IOException ex) {\n            }\n        }\n    }\n\n    /**\n     * 返回资源最后的修改时间\n     */\n    @Override\n    public long lastModified() throws IOException {\n        long lastModified = getFileForLastModifiedCheck().lastModified();\n        if (lastModified == 0L) {\n            throw new FileNotFoundException(getDescription() +\n                    &quot; cannot be resolved in the file system for resolving its last-modified timestamp&quot;);\n        }\n        return lastModified;\n    }\n\n\n    protected File getFileForLastModifiedCheck() throws IOException {\n        return getFile();\n    }\n\n    /**\n     * 交给子类实现\n     */\n    @Override\n    public Resource createRelative(String relativePath) throws IOException {\n        throw new FileNotFoundException(&quot;Cannot create a relative resource for &quot; + getDescription());\n    }\n\n    /**\n     * 获取资源名称，默认返回 null\n     */\n    @Override\n    @Nullable\n    public String getFilename() {\n        return null;\n    }\n\n\n    /**\n     * 返回资源的描述\n     */\n    @Override\n    public String toString() {\n        return getDescription();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        return (obj == this ||\n            (obj instanceof Resource &amp;&amp; ((Resource) obj).getDescription().equals(getDescription())));\n    }\n\n    @Override\n    public int hashCode() {\n        return getDescription().hashCode();\n    }\n\n}\n</code></pre>\n<p>如果我们想要实现自定义的 Resource，记住不要实现 Resource 接口，而应该继承 AbstractResource 抽象类，然后根据当前的具体资源特性覆盖相应的方法即可。</p>\n<h3 id=\"2-统一资源定位：ResourceLoader\"><a href=\"#2-统一资源定位：ResourceLoader\" class=\"headerlink\" title=\"2. 统一资源定位：ResourceLoader\"></a>2. 统一资源定位：ResourceLoader</h3><p>一开始就说了 Spring 将资源的定义和资源的加载区分开了，Resource 定义了统一的资源，那资源的加载则由 ResourceLoader 来统一定义。</p>\n<p><code>org.springframework.core.io.ResourceLoader</code> 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器。其定义如下：</p>\n<pre><code class=\"java\">public interface ResourceLoader {\n    String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;\n\n    Resource getResource(String location);\n\n    ClassLoader getClassLoader();\n}\n</code></pre>\n<p>ResourceLoader 接口提供两个方法：<code>getResource()</code>、<code>getClassLoader()</code>。</p>\n<p><code>getResource()</code>根据所提供资源的路径 location 返回 Resource 实例，但是它不确保该 Resource 一定存在，需要调用 <code>Resource.exist()</code>方法判断。该方法支持以下模式的资源加载：</p>\n<ul>\n<li>URL位置资源，如”file:C:/test.dat”</li>\n<li>ClassPath位置资源，如”classpath:test.dat”</li>\n<li>相对路径资源，如”WEB-INF/test.dat”，此时返回的Resource实例根据实现不同而不同</li>\n</ul>\n<p>该方法的主要实现是在其子类 DefaultResourceLoader 中实现，具体过程我们在分析 DefaultResourceLoader 时做详细说明。</p>\n<p>对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用 <code>getClassLoader()</code> 方法获得。在分析 Resource 时，提到了一个类 ClassPathResource ，这个类是可以根据指定的 ClassLoader 来加载资源的。</p>\n<p>作为 Spring 统一的资源加载器，它提供了统一的抽象，具体的实现则由相应的子类来负责实现，其类的类结构图如下：<br><img src=\"/images/pasted-6.png\" alt=\"resourceloader\"></p>\n<h4 id=\"DefaultResourceLoader\"><a href=\"#DefaultResourceLoader\" class=\"headerlink\" title=\"DefaultResourceLoader\"></a>DefaultResourceLoader</h4><p>与 AbstractResource 相似，DefaultResourceLoader 是 ResourceLoader 的默认实现，它接收 ClassLoader 作为构造函数的参数或者使用不带参数的构造函数，在使用不带参数的构造函数时，使用的 ClassLoader 为默认的 ClassLoader（一般为<code>Thread.currentThread().getContextClassLoader()</code>），可以通过 <code>ClassUtils.getDefaultClassLoader()</code>获取。当然也可以调用 <code>setClassLoader()</code>方法进行后续设置。如下</p>\n<pre><code class=\"java\"> public DefaultResourceLoader() {\n        this.classLoader = ClassUtils.getDefaultClassLoader();\n    }\n\n    public DefaultResourceLoader(@Nullable ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    public void setClassLoader(@Nullable ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    @Override\n    @Nullable\n    public ClassLoader getClassLoader() {\n        return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());\n    }\n</code></pre>\n<p>ResourceLoader 中最核心的方法为 <code>getResource()</code>,它根据提供的 location 返回相应的 Resource，而 DefaultResourceLoader 对该方法提供了核心实现(它的两个子类都没有提供覆盖该方法，所以可以断定ResourceLoader 的资源加载策略就封装 DefaultResourceLoader中)，如下：</p>\n<pre><code class=\"java\">    public Resource getResource(String location) {\n        Assert.notNull(location, &quot;Location must not be null&quot;);\n\n        for (ProtocolResolver protocolResolver : this.protocolResolvers) {\n            Resource resource = protocolResolver.resolve(location, this);\n            if (resource != null) {\n                return resource;\n            }\n        }\n\n        if (location.startsWith(&quot;/&quot;)) {\n            return getResourceByPath(location);\n        }\n        else if (location.startsWith(CLASSPATH_URL_PREFIX)) {\n            return new \n                ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), \n                                         getClassLoader());\n        }\n        else {\n            try {\n                // Try to parse the location as a URL...\n                URL url = new URL(location);\n                return (ResourceUtils.isFileURL(url) ? \n                        new FileUrlResource(url) : new UrlResource(url));\n            }\n            catch (MalformedURLException ex) {\n                // No URL -&gt; resolve as resource path.\n                return getResourceByPath(location);\n            }\n        }\n    }\n</code></pre>\n<p>首先通过 ProtocolResolver 来加载资源，成功返回 Resource，否则调用如下逻辑：</p>\n<ul>\n<li>若 location 以 / 开头，则调用 <code>getResourceByPath()</code>构造 ClassPathContextResource 类型资源并返回。</li>\n<li>若 location 以 classpath: 开头，则构造 ClassPathResource 类型资源并返回，在构造该资源时，通过 <code>getClassLoader()</code>获取当前的 ClassLoader。</li>\n<li>构造 URL ，尝试通过它进行资源定位，若没有抛出 MalformedURLException 异常，则判断是否为 FileURL , 如果是则构造 FileUrlResource 类型资源，否则构造 UrlResource。若在加载过程中抛出 MalformedURLException 异常，则委派 <code>getResourceByPath()</code> 实现资源定位加载。</li>\n</ul>\n<p>这里有一点要注意的是，返回了resource不代表这个资源存在，和前面介绍resource一样，需要通过exitsts来确认文件的存在。</p>\n<p>ProtocolResolver ，用户自定义协议资源解决策略，作为 DefaultResourceLoader 的 SPI，它允许用户自定义资源加载协议，而不需要继承 ResourceLoader 的子类。在介绍 Resource 时，提到如果要实现自定义 Resource，我们只需要继承 DefaultResource 即可，但是有了 ProtocolResolver 后，我们不需要直接继承 DefaultResourceLoader，改为实现 ProtocolResolver 接口也可以实现自定义的 ResourceLoader。<br>ProtocolResolver 接口，仅有一个方法 <code>Resource resolve(String location, ResourceLoader resourceLoader)</code>，该方法接收两个参数：资源路径location，指定的加载器 ResourceLoader，返回为相应的 Resource 。在 Spring 中你会发现该接口并没有实现类，它需要用户自定义，自定义的 Resolver 如何加入 Spring 体系呢？调用 <code>DefaultResourceLoader.addProtocolResolver()</code> 即可，如下：</p>\n<pre><code class=\"java\">    public void addProtocolResolver(ProtocolResolver resolver) {\n        Assert.notNull(resolver, &quot;ProtocolResolver must not be null&quot;);\n        this.protocolResolvers.add(resolver);\n    }\n</code></pre>\n<p>下面是我写的一个简单ProtocolResolver的demo，演示了使用方式，如果你希望添加自定义的文件格式解析，可以向下面这样添加。</p>\n<pre><code class=\"java\">   /**\n     * 测试ProtocolResolver\n     */\n    public static void main(String[] args) {\n        DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader();\n        defaultResourceLoader.getProtocolResolvers().forEach(System.out::println);\n\n        defaultResourceLoader.addProtocolResolver(new \n                CustomerResourceProtocolResolver());\n        System.out.println(defaultResourceLoader.getResource(&quot;/Users/zhangke/HTTP请求.jmx&quot;).exists());\n    }\n\n    static class CustomerResourceProtocolResolver implements ProtocolResolver {\n\n        @Override\n        public Resource resolve(String location, ResourceLoader resourceLoader) {\n            FileSystemResource fileSystemResource = new FileSystemResource(location);\n            return fileSystemResource;\n        }\n    }\n</code></pre>\n<p>下面示例是演示 DefaultResourceLoader 加载资源的具体策略，代码如下（该示例参考《Spring 解密》 P89）：</p>\n<pre><code class=\"java\">        ResourceLoader resourceLoader = new DefaultResourceLoader();\n\n        Resource fileResource1 = resourceLoader.getResource(&quot;D:/Users/chenming673/Documents/spark.txt&quot;);\n        System.out.println(&quot;fileResource1 is FileSystemResource:&quot; + (fileResource1 instanceof FileSystemResource));\n\n        Resource fileResource2 = resourceLoader.getResource(&quot;/Users/chenming673/Documents/spark.txt&quot;);\n        System.out.println(&quot;fileResource2 is ClassPathResource:&quot; + (fileResource2 instanceof ClassPathResource));\n\n        Resource urlResource1 = resourceLoader.getResource(&quot;file:/Users/chenming673/Documents/spark.txt&quot;);\n        System.out.println(&quot;urlResource1 is UrlResource:&quot; + (urlResource1 instanceof UrlResource));\n\n        Resource urlResource2 = resourceLoader.getResource(&quot;http://www.baidu.com&quot;);\n        System.out.println(&quot;urlResource1 is urlResource:&quot; + (urlResource2 instanceof  UrlResource));\n</code></pre>\n<p>运行结果：</p>\n<pre><code>fileResource1 is FileSystemResource:false\nfileResource2 is ClassPathResource:true\nurlResource1 is UrlResource:true\nurlResource1 is urlResource:true\n</code></pre><p>其实对于 fileResource1 我们更加希望是 FileSystemResource 资源类型，但是事与愿违，它是 ClassPathResource 类型。在<code>getResource()</code>资源加载策略中，我们知道 <code>D:/Users/chenming673/Documents/spark.txt</code>资源其实在该方法中没有相应的资源类型，那么它就会在抛出 MalformedURLException 异常时通过 <code>getResourceByPath()</code> 构造一个 ClassPathResource 类型的资源。而指定有协议前缀的资源路径，则通过 URL 就可以定义，所以返回的都是UrlResource类型。</p>\n<h4 id=\"FileSystemResourceLoader\"><a href=\"#FileSystemResourceLoader\" class=\"headerlink\" title=\"FileSystemResourceLoader\"></a>FileSystemResourceLoader</h4><p>从上面的示例我们看到，其实 DefaultResourceLoader 对<code>getResourceByPath(String)</code>方法处理其实不是很恰当，这个时候我们可以使用 FileSystemResourceLoader ，它继承 DefaultResourceLoader 且覆写了 <code>getResourceByPath(String)</code>，使之从文件系统加载资源并以 FileSystemResource 类型返回，这样我们就可以得到想要的资源类型，如下：</p>\n<pre><code class=\"java\">    @Override\n    protected Resource getResourceByPath(String path) {\n        if (path.startsWith(&quot;/&quot;)) {\n            path = path.substring(1);\n        }\n        return new FileSystemContextResource(path);\n    }\n</code></pre>\n<p>FileSystemContextResource 为 FileSystemResourceLoader 的内部类，它继承 FileSystemResource。</p>\n<pre><code class=\"java\">    private static class FileSystemContextResource extends FileSystemResource implements ContextResource {\n\n        public FileSystemContextResource(String path) {\n            super(path);\n        }\n\n        @Override\n        public String getPathWithinContext() {\n            return getPath();\n        }\n    }\n</code></pre>\n<p>在构造器中也是调用 FileSystemResource 的构造方法来构造 FileSystemResource 的。</p>\n<p>如果将上面的示例将 DefaultResourceLoader 改为 FileSystemContextResource ，则 fileResource1 则为 FileSystemResource。</p>\n<h4 id=\"ResourcePatternResolver\"><a href=\"#ResourcePatternResolver\" class=\"headerlink\" title=\"ResourcePatternResolver\"></a>ResourcePatternResolver</h4><p>ResourceLoader 的 <code>Resource getResource(String location)</code> 每次只能根据 location 返回一个 Resource，当需要加载多个资源时，我们除了多次调用 <code>getResource()</code> 外别无他法。ResourcePatternResolver 是 ResourceLoader 的扩展，它支持根据指定的资源路径匹配模式每次返回多个 Resource 实例，其定义如下：</p>\n<pre><code class=\"java\">public interface ResourcePatternResolver extends ResourceLoader {\n    String CLASSPATH_ALL_URL_PREFIX = &quot;classpath*:&quot;;\n\n    Resource[] getResources(String locationPattern) throws IOException;\n}\n</code></pre>\n<p>ResourcePatternResolver 在 ResourceLoader 的基础上增加了 <code>getResources(String locationPattern)</code>，以支持根据路径匹配模式返回多个 Resource 实例，同时也新增了一种新的协议前缀 <code>classpath*:</code>，该协议前缀由其子类负责实现。</p>\n<p>PathMatchingResourcePatternResolver 为 ResourcePatternResolver 最常用的子类，它除了支持 ResourceLoader 和 ResourcePatternResolver 新增的 classpath*: 前缀外，还支持 Ant 风格的路径匹配模式。</p>\n<p>这里先介绍什么是Ant风格的路径匹配模式，主要由以下规则，</p>\n<ul>\n<li>？匹配一个字符</li>\n<li><code>*</code>匹配0个或多个字符</li>\n<li>** 在路径中匹配0个或多个文件夹</li>\n<li>{spring;[a-z]+}，匹配正则表达式<code>[a-z]+</code>并将结果存在名为“spring”变量中。</li>\n</ul>\n<p>例子</p>\n<ul>\n<li><code>com/t?st.jsp</code> —匹配 <code>com/test.jsp</code> 、 <code>com/tast.jsp</code> 、<code>com/txst.jsp</code></li>\n<li><code>com/*.jsp</code> — 匹配com目录线面所有的l <code>.jsp</code> 文件</li>\n<li><code>com/**/test.jsp</code> —匹配com目录还有子目录下所有的 <code>test.jsp</code></li>\n<li><code>org/springframework/**/*.jsp</code> — 匹配 <code>org/springframework</code> 目录和子目录下所有的 <code>.jsp</code> </li>\n<li><code>org/**/servlet/bla.jsp</code> — 匹配<code>org/springframework/servlet/bla.jsp</code> 、<code>org/springframework/testing/servlet/bla.jsp</code> 、 <code>org/servlet/bla.jsp</code></li>\n<li><code>com/{filename:\\\\w+}.jsp</code> 匹配 <code>com/test.jsp</code> 并且将值 <code>test</code> 付给 <code>filename</code>变量</li>\n</ul>\n<p>在spring经常使用<code>AntPathMatcher</code>来进行操作这些ant风格的路径匹配模式</p>\n<p>小案例如下</p>\n<pre><code class=\"java\">/**************************************\n *      Author : zhangke\n *      Date   : 2019-01-08 17:44\n *      email  : 398757724@qq.com\n *      Desc   : ant 风格小案例\n ***************************************/\npublic class AntPathMatcherStudy {\n    public static void main(String[] args) {\n        AntPathMatcher antPathMatcher = new AntPathMatcher();\n\n\n        // com/t?st.jsp — matches com/test.jsp but also com/tast.jsp or com/txst.jsp\n        System.out.println(antPathMatcher.match(&quot;com/t?st.jsp&quot;, &quot;com/test.jsp&quot;));\n        System.out.println(antPathMatcher.match(&quot;com/t?st.jsp&quot;, &quot;com/tast.jsp&quot;));\n        System.out.println(antPathMatcher.match(&quot;com/t?st.jsp&quot;, &quot;com/txst.jsp&quot;));\n\n\n        // com/*.jsp — matches all .jsp files in the com directory\n        System.out.println(antPathMatcher.match(&quot;com/*.jsp&quot;, &quot;com/test.jsp&quot;));\n        System.out.println(antPathMatcher.match(&quot;com/*.jsp&quot;, &quot;com/tast.jsp&quot;));\n        System.out.println(antPathMatcher.match(&quot;com/*.jsp&quot;, &quot;com/txst.jsp&quot;));\n\n\n        //org/springframework/**/*.jsp — matches all .jsp files underneath the org/springframework path\n        System.out.println(antPathMatcher.match(&quot;org/springframework/**/*.jsp&quot;, &quot;org/springframework/com/test.jsp&quot;));\n        System.out.println(antPathMatcher.match(&quot;org/springframework/**/*.jsp&quot;, &quot;org/springframework/test/com/tast.jsp&quot;));\n        System.out.println(antPathMatcher.match(&quot;org/springframework/**/*.jsp&quot;, &quot;org/springframework/ddd/txst.jsp&quot;));\n\n        // com/{filename:\\\\w+}.jsp will match com/test.jsp and assign the value test to the filename variable\n        System.out.println(antPathMatcher.extractUriTemplateVariables(&quot;/test/{spring:[a-z]+}/test.jsp&quot;, &quot;/test/test/test.jsp&quot;));\n\n    }\n</code></pre>\n<p>运行结果</p>\n<pre><code class=\"java\">true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\n{spring=test}\n</code></pre>\n<p>PathMatchingResourcePatternResolver 提供了三个构造方法，如下：</p>\n<pre><code class=\"java\">    public PathMatchingResourcePatternResolver() {\n        this.resourceLoader = new DefaultResourceLoader();\n    }\n\n    public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {\n        Assert.notNull(resourceLoader, &quot;ResourceLoader must not be null&quot;);\n        this.resourceLoader = resourceLoader;\n    }\n\n    public PathMatchingResourcePatternResolver(@Nullable ClassLoader classLoader) {\n        this.resourceLoader = new DefaultResourceLoader(classLoader);\n    }\n</code></pre>\n<p>PathMatchingResourcePatternResolver 在实例化的时候，可以指定一个 ResourceLoader，如果不指定的话，它会在内部构造一个 DefaultResourceLoader。</p>\n<p><strong>Resource getResource(String location)</strong></p>\n<pre><code class=\"java\">    @Override\n    public Resource getResource(String location) {\n        return getResourceLoader().getResource(location);\n    }\n</code></pre>\n<p><code>getResource()</code> 方法直接委托给相应的 ResourceLoader 来实现，所以如果我们在实例化的 PathMatchingResourcePatternResolver 的时候，如果不知道 ResourceLoader ，那么在加载资源时，其实就是 DefaultResourceLoader 的过程。其实在下面介绍的 <code>Resource[] getResources(String locationPattern)</code> 也相同，只不过返回的资源时多个而已。</p>\n<pre><code class=\"java\"> public Resource[] getResources(String locationPattern) throws IOException {\n        Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;);\n\n        // 以 classpath*: 开头\n        if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {\n            // 路径包含通配符，PathMatcher默认是AntPathMatcher\n            if (getPathMatcher().isPattern(\n                locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {\n                return findPathMatchingResources(locationPattern);\n            } else {\n                // 路径不包含通配符\n                return findAllClassPathResources(\n                    locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));\n            }\n        } else {\n            int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ?\n              locationPattern.indexOf(&quot;*/&quot;) + 1 : locationPattern.indexOf(&#39;:&#39;) + 1);\n            // 路径包含通配符\n            if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {\n                return findPathMatchingResources(locationPattern);\n            }else {\n                // 不包含通配符也不是以Classpath*：开头，返回指定resource\n                return new Resource[{getResourceLoader().getResource(locationPattern)};\n            }\n        }\n    }\n</code></pre>\n<p>处理逻辑如下<br><img src=\"/images/pasted-8.png\" alt=\"pathResourceLoader 逻辑图\"></p>\n<p>下面就 <code>findAllClassPathResources()</code>、<code>findAllClassPathResources()</code> 做详细分析。</p>\n<p><strong>findAllClassPathResources()</strong></p>\n<p>当 locationPattern 以 classpath*: 开头但是不包含通配符，则调用<code>findAllClassPathResources()</code> 方法加载资源。该方法返回 classes 路径下和所有 jar 包中的所有相匹配的资源。</p>\n<pre><code class=\"java\"> protected Resource[] findAllClassPathResources(String location) throws IOException {\n        String path = location;\n        if (path.startsWith(&quot;/&quot;)) {\n            path = path.substring(1);\n        }\n        Set&lt;Resource&gt; result = doFindAllClassPathResources(path);\n        if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Resolved classpath location \n                                 [&quot; + location + &quot;] to resources &quot; + result);\n        }\n        return result.toArray(new Resource[0]);\n    }\n</code></pre>\n<p>真正执行加载的是在 <code>doFindAllClassPathResources()</code>方法，如下：</p>\n<pre><code class=\"java\">    protected Set&lt;Resource&gt; doFindAllClassPathResources(String path) throws IOException {\n        Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16);\n        ClassLoader cl = getClassLoader();\n        Enumeration&lt;URL&gt; resourceUrls = (cl != null ? cl.getResources(path) : \n                                         ClassLoader.getSystemResources(path));\n        while (resourceUrls.hasMoreElements()) {\n            URL url = resourceUrls.nextElement();\n            result.add(convertClassLoaderURL(url));\n        }\n        if (&quot;&quot;.equals(path)) {\n            addAllClassLoaderJarRoots(cl, result);\n        }\n        return result;\n    }\n</code></pre>\n<p><code>doFindAllClassPathResources()</code> 根据 ClassLoader 加载路径下的所有资源。在加载资源过程中如果，在构造 PathMatchingResourcePatternResolver 实例的时候如果传入了 ClassLoader，则调用其 <code>getResources()</code>，否则调用<code>ClassLoader.getSystemResources(path)</code>。 <code>ClassLoader.getResources()</code>如下:</p>\n<pre><code class=\"java\">    public Enumeration&lt;URL&gt; getResources(String name) throws IOException {\n        @SuppressWarnings(&quot;unchecked&quot;)\n        Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) new Enumeration&lt;?&gt;[2];\n        if (parent != null) {\n            tmp[0] = parent.getResources(name);\n        } else {\n            tmp[0] = getBootstrapResources(name);\n        }\n        tmp[1] = findResources(name);\n\n        return new CompoundEnumeration&lt;&gt;(tmp);\n    }\n</code></pre>\n<p>看到这里是不是就已经一目了然了？如果当前父类加载器不为 null，则通过父类向上迭代获取资源，否则调用 <code>getBootstrapResources()</code>。这里是不是特别熟悉。</p>\n<p>若 path 为 空（“”）时，则调用 <code>addAllClassLoaderJarRoots()</code>方法。该方法主要是加载路径下得所有 jar 包，方法较长也没有什么实际意义就不贴出来了。不过最后结果在每个jar后面都添加<strong>!/</strong>的原因是java官方规定的，可以看这个连接<a href=\"https://docs.oracle.com/javase/tutorial/deployment/jar/apiindex.html\" target=\"_blank\" rel=\"noopener\">jar 中出现!/的原因</a></p>\n<p>通过上面的分析，我们知道 <code>findAllClassPathResources()</code> 其实就是利用 ClassLoader 来加载指定路径下的资源，不过它是在 class 路径下还是在 jar 包中。如果我们传入的路径为空或者 <code>/</code>，则会调用 <code>addAllClassLoaderJarRoots()</code> 方法加载所有的 jar 包。</p>\n<p><strong>findAllClassPathResources()</strong></p>\n<p>当 locationPattern 以 classpath*: 开头且当中包含了通配符，则调用该方法进行资源加载。如下：</p>\n<pre><code class=\"java\">protected Resource[] findPathMatchingResources(String locationPattern) throws IOException {\n        // 确定跟路径\n        String rootDirPath = determineRootDir(locationPattern);\n        String subPattern = locationPattern.substring(rootDirPath.length());\n\n        // 获取根据路径下得资源\n        Resource[] rootDirResources = getResources(rootDirPath);\n\n        Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16);\n        for (Resource rootDirResource : rootDirResources) {\n            rootDirResource = resolveRootDirResource(rootDirResource);\n            URL rootDirUrl = rootDirResource.getURL();\n            // bundle 资源类型\n            if (equinoxResolveMethod != null &amp;&amp; \n                        rootDirUrl.getProtocol().startsWith(&quot;bundle&quot;)) {\n                URL resolvedUrl = (URL)ReflectionUtils.invokeMethod(\n                    equinoxResolveMethod, null, rootDirUrl);\n                if (resolvedUrl != null) {\n                    rootDirUrl = resolvedUrl;\n                }\n                rootDirResource = new UrlResource(rootDirUrl);\n            }\n\n            // VFS 资源\n            if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\n                result.addAll(\n                    VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, \n                                                  subPattern, getPathMatcher()));\n            }\n\n            // Jar\n            else if (ResourceUtils.isJarURL(rootDirUrl) || \n                     isJarResource(rootDirResource)) {\n                result.addAll(doFindPathMatchingJarResources(rootDirResource, \n                                                             rootDirUrl, subPattern));\n            }\n            else {\n                result.addAll(doFindPathMatchingFileResources(rootDirResource, \n                                                              subPattern));\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Resolved location pattern [&quot; + locationPattern + &quot;] to \n                         resources &quot; + result);\n        }\n        return result.toArray(new Resource[0]);\n    }\n</code></pre>\n<p>方法有点儿长，但是思路还是很清晰的，主要分两步：</p>\n<ol>\n<li>确定目录，获取该目录下得所有资源</li>\n<li>在所获得的所有资源中进行迭代匹配获取我们想要的资源。</li>\n</ol>\n<p>在这个方法里面我们要关注两个方法，一个是 <code>determineRootDir()</code>,一个是 <code>doFindPathMatchingFileResources()</code>。</p>\n<p><code>determineRootDir()</code>主要是用于确定根路径，如下：</p>\n<pre><code class=\"java\">    protected String determineRootDir(String location) {\n        int prefixEnd = location.indexOf(&#39;:&#39;) + 1;\n        int rootDirEnd = location.length();\n        while (rootDirEnd &gt; prefixEnd &amp;&amp; getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) {\n            rootDirEnd = location.lastIndexOf(&#39;/&#39;, rootDirEnd - 2) + 1;\n        }\n        if (rootDirEnd == 0) {\n            rootDirEnd = prefixEnd;\n        }\n        return location.substring(0, rootDirEnd);\n    }\n</code></pre>\n<p>该方法一定要给出一个确定的根目录。该根目录用于确定文件的匹配的起始点，将根目录位置的资源解析为 <code>java.io.File</code>并将其传递到 <code>retrieveMatchingFiles()</code>，其余为知用于模式匹配，找出我们所需要的资源。</p>\n<p>确定根路径如下:</p>\n<table>\n<thead>\n<tr>\n<th>原路径</th>\n<th>确定根路径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>classpath*:test/cc*/spring-*.xml</code></td>\n<td><code>classpath*:test/</code></td>\n</tr>\n<tr>\n<td><code>classpath*:test/aa/spring-*.xml</code></td>\n<td><code>classpath*:test/aa/</code></td>\n</tr>\n</tbody>\n</table>\n<p>确定根路径后，则调用 <code>getResources()</code> 方法获取该路径下得所有资源，然后迭代资源获取符合条件的资源。</p>\n<p>至此 Spring 整个资源记载过程已经分析完毕。下面简要总结下：</p>\n<ul>\n<li>Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。</li>\n<li>AbstractResource 为 Resource 的默认实现，它对 Resource 接口做了一个统一的实现，子类继承该类后只需要覆盖相应的方法即可，同时对于自定义的 Resource 我们也是继承该类。</li>\n<li>DefaultResourceLoader 同样也是 ResourceLoader 的默认实现，在自定 ResourceLoader 的时候我们除了可以继承该类外还可以实现 ProtocolResolver 接口来实现自定资源加载协议。</li>\n<li>DefaultResourceLoader 每次只能返回单一的资源，所以 Spring 针对这个提供了另外一个接口 ResourcePatternResolver ，该接口提供了根据指定的 locationPattern 返回多个资源的策略。其子类 PathMatchingResourcePatternResolver 是一个集大成者的 ResourceLoader ，因为它即实现了 <code>Resource getResource(String location)</code> 也实现了 <code>Resource[] getResources(String locationPattern)</code>。</li>\n</ul>"},{"title":"spring源码解析之 29实例化bean总结","author":"fengxiutianya","abbrlink":40140,"date":"2019-01-14T22:54:00.000Z","_content":"在 Spring bean 解析篇深入分析了一个配置文件经历了哪些过程转变成了 BeanDefinition，但是这个 BeanDefinition 并不是我们真正想要的想要的 bean，因为它还仅仅只是承载了我们需要的目标 bean 的信息，从 BeanDefinition 到我们需要的目标还需要一个漫长的 bean 的初始化阶段，在Spring bean 实例化阶段已经详细分析了初始化 bean 的过程，所以这里做一个概括性的总结。\n\nbean 的初始化节点由第一次调用 `getBean()`(显式或者隐式)开启，所以我们从这个方法开始。\n<!-- more -->\n```java\n    public Object getBean(String name) throws BeansException {\n        return doGetBean(name, null, null, false);\n    }\n\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n                              @Nullable final Object[] args, boolean typeCheckOnly)\n \t\t\t throws BeansException {\n\n        // 获取 beanName，这里是一个转换动作，将 name 转换Wie beanName\n        final String beanName = transformedBeanName(name);\n        Object bean;\n\n        // 从缓存中或者实例工厂中获取 bean\n        // *** 这里会涉及到解决循环依赖 bean 的问题\n        Object sharedInstance = getSingleton(beanName);\n        if (sharedInstance != null && args == null) {\n            if (logger.isDebugEnabled()) {\n                if (isSingletonCurrentlyInCreation(beanName)) {\n                  。。。。日志\n                }\n                else {\n                  。。。 日志\n                }\n            }\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n        }\n\n        else {\n\n            // 因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常\n            // **关于循环依赖后续会单独出文详细说明**\n            if (isPrototypeCurrentlyInCreation(beanName)) {\n                throw new BeanCurrentlyInCreationException(beanName);\n            }\n\n            // 如果容器中没有找到，则从父类容器中加载\n            BeanFactory parentBeanFactory = getParentBeanFactory();\n            if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n                String nameToLookup = originalBeanName(name);\n                if (parentBeanFactory instanceof AbstractBeanFactory) {\n                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                            nameToLookup, requiredType, args, typeCheckOnly);\n                }\n                else if (args != null) {\n                    return (T) parentBeanFactory.getBean(nameToLookup, args);\n                }\n                else {\n                    return parentBeanFactory.getBean(nameToLookup, requiredType);\n                }\n            }\n\n            // 如果不是仅仅做类型检查则是创建bean，这里需要记录\n            if (!typeCheckOnly) {\n                markBeanAsCreated(beanName);\n            }\n\n            try {\n    // 从容器中获取 beanName 相应的 GenericBeanDefinition，并将其转换为 RootBeanDefinition\n                final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\n                // 检查给定的合并的 BeanDefinition\n                checkMergedBeanDefinition(mbd, beanName, args);\n\n                // 处理所依赖的 bean\n                String[] dependsOn = mbd.getDependsOn();\n                if (dependsOn != null) {\n                    for (String dep : dependsOn) {\n                        // 若给定的依赖 bean 已经注册为依赖给定的b ean\n                        // 循环依赖的情况\n                        if (isDependent(beanName, dep)) {\n                         \t。。。异常\n                        }\n                        // 缓存依赖调用\n                        registerDependentBean(dep, beanName);\n                        try {\n                            getBean(dep);\n                        }\n                        catch (NoSuchBeanDefinitionException ex) {\n                           \t。。。异常\n                        }\n                    }\n                }\n\n                // bean 实例化\n                // 单例模式\n                if (mbd.isSingleton()) {\n                    sharedInstance = getSingleton(beanName, () -> {\n                        try {\n                            return createBean(beanName, mbd, args);\n                        }\n                        catch (BeansException ex) {\n                            // 显示从单利缓存中删除 bean 实例\n                            // 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它\n                            destroySingleton(beanName);\n                            throw ex;\n                        }\n                    });\n             bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n                }\n\n                // 原型模式\n                else if (mbd.isPrototype()) {\n                    // It's a prototype -> create a new instance.\n                    Object prototypeInstance = null;\n                    try {\n                        beforePrototypeCreation(beanName);\n                        prototypeInstance = createBean(beanName, mbd, args);\n                    }\n                    finally {\n                        afterPrototypeCreation(beanName);\n                    }\n             bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n                }\n\n                else {\n                    // 从指定的 scope 下创建 bean\n                    String scopeName = mbd.getScope();\n                    final Scope scope = this.scopes.get(scopeName);\n                    if (scope == null) {\n                       。。。异常\n                    }\n                    try {\n                        Object scopedInstance = scope.get(beanName, () -> {\n                            beforePrototypeCreation(beanName);\n                            try {\n                                return createBean(beanName, mbd, args);\n                            }\n                            finally {\n                                afterPrototypeCreation(beanName);\n                            }\n                        });\n         bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n                    }\n                    catch (IllegalStateException ex) {\n                       。。。。异常\n                    }\n                }\n            }\n            catch (BeansException ex) {\n                cleanupAfterBeanCreationFailure(beanName);\n                throw ex;\n            }\n        }\n\n        // 检查需要的类型是否符合 bean 的实际类型\n        if (requiredType != null && !requiredType.isInstance(bean)) {\n            try {\n          T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n                if (convertedBean == null) {\n                  。。。异常\n                }\n                return convertedBean;\n            }\n            catch (TypeMismatchException ex) {\n                if (logger.isDebugEnabled()) {\n                   。。日志\n                }\n               。。。异常\n            }\n        }\n        return (T) bean;\n    }\n```\n\n内部调用 `doGetBean()` 方法，`doGetBean()` 的代码量比较多，从这里就可以看出 bean 的加载过程是一个非常复杂的过程，会涉及到各种各样的情况处理。`doGetBean()` 可以分为以下几个过程。\n\n1. 转换 beanName。因为我们调用 `getBean()` 方法传入的 name 并不一定就是 beanName，可以传入 aliasName，FactoryBean，所以这里需要进行简单的转换过程。\n2. 尝试从缓存中加载单例 bean。\n3. bean 的实例化。\n4. 原型模式的依赖检查。因为 Spring 只会解决单例模式的循环依赖，对于原型模式的循环依赖都是直接抛出 BeanCurrentlyInCreationException 异常。\n5. 尝试从 parentBeanFactory 获取 bean 实例。如果 `parentBeanFactory != null && !containsBeanDefinition(beanName)` 则尝试从 parentBeanFactory 中获取 bean 实例对象，因为 `!containsBeanDefinition(beanName)` 就意味着定义的 xml 文件中没有 beanName 相应的配置，这个时候就只能从 parentBeanFactory 中获取。\n6. 获取 RootBeanDefinition，并对其进行合并检查。从缓存中获取已经解析的 RootBeanDefinition，同时如果父类不为 null 的话，则会合并父类的属性。\n7. 依赖检查。某个 bean 依赖其他 bean ，则需要先加载依赖的 bean。\n8. 对不同的 scope 进行处理。\n9. 类型转换处理。如果传递的 requiredType 不为 null，则需要检测所得到 bean 的类型是否与该 requiredType 一致，如果不一致则尝试转换，当然也要能够转换成功，否则抛出 BeanNotOfRequiredTypeException 异常。\n\n下面就以下几个方面进行阐述，说明 Spring bean 的加载过程。\n\n1. 从缓存中获取 bean\n2. 创建 bean 实例对象\n3. 从 bean 实例中获取对象\n\n## 从缓存中获取 bean\n\nSpring 中根据 scope 可以将 bean 分为以下几类：singleton、prototype 和 其他，这样分的原因在于 Spring 在对不同 scope 处理的时候是这么处理的。\n\n- singleton：在 Spring 的 IoC 容器中只存在一个对象实例，所有该对象的引用都共享这个实例。Spring 容器只会创建该 bean 定义的唯一实例，这个实例会被保存到缓存中，并且对该bean的所有后续请求和引用都将返回该缓存中的对象实例。\n- prototype：每次对该bean的请求都会创建一个新的实例\n- 其他：其他包括 request、session、global session：\n  - request：每次 http 请求将会有各自的 bean 实例。\n  - session：在一个 http session 中，一个 bean 定义对应一个 bean 实例。\n  - global session：在一个全局的 http session 中，一个 bean 定义对应一个 bean 实例。\n\n所以从缓存中获取的 bean 一定是 singleton bean，这也是 Spring 为何只解决 singleton bean 的循环依赖。调用 `getSingleton()` 从缓存中获取 singleton bean。\n\n```java\npublic Object getSingleton(String beanName) {\n    return getSingleton(beanName, true);\n}\n\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    Object singletonObject = this.singletonObjects.get(beanName);\n    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n        synchronized (this.singletonObjects) {\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null && allowEarlyReference) {\n                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    singletonObject = singletonFactory.getObject();\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return singletonObject;\n}\n```\n\n`getSingleton()` 就是从 singletonObjects、earlySingletonObjects、 singletonFactories 三个缓存中获取，这里也是 Spring 解决 bean 循环依赖的关键之处。\n\n## 创建 bean 实例对象\n\n如果缓存中没有，也没有 parentBeanFactory ，则会调用 `createBean()` 创建 bean 实例，该方法主要是在处理不同 scope 的 bean 的时候进行调用。\n\n```java\nprotected abstract Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n            throws BeanCreationException\n```\n\n该方法是定义在 AbstractBeanFactory 中的虚拟方法，其含义是根据给定的 BeanDefinition 和 args实例化一个 bean 对象，如果该 BeanDefinition 存在父类，则该 BeanDefinition 已经合并了父类的属性。所有 Bean 实例的创建都会委托给该方法实现。\n\n方法接受三个参数：\n\n- beanName：bean 的名字\n- mbd：已经合并了父类属性的（如果有的话）BeanDefinition\n- args：用于构造函数或者工厂方法创建 bean 实例对象的参数\n\n该抽象方法的默认实现是在类 AbstractAutowireCapableBeanFactory 中实现，该方法其实只是做一些检查和验证工作，真正的初始化工作是由 `doCreateBean()` 实现，如下：\n\n```java\n   protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n            throws BeanCreationException {\n\n        // BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装bean的属性描述器\n        BeanWrapper instanceWrapper = null;\n        // 单例模型，则从未完成的 FactoryBean 缓存中删除\n        if (mbd.isSingleton()) {anceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n        }\n\n        // 使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化\n        if (instanceWrapper == null) {\n            instanceWrapper = createBeanInstance(beanName, mbd, args);\n        }\n\n        // 包装的实例对象\n        final Object bean = instanceWrapper.getWrappedInstance();\n        // 包装的实例对象的类型\n        Class<?> beanType = instanceWrapper.getWrappedClass();\n        if (beanType != NullBean.class) {\n            mbd.resolvedTargetType = beanType;\n        }\n\n        // 检测是否有后置处理\n        // 如果有后置处理，则允许后置处理修改 BeanDefinition\n        synchronized (mbd.postProcessingLock) {\n            if (!mbd.postProcessed) {\n                try {\n                    // applyMergedBeanDefinitionPostProcessors\n                    // 后置处理修改 BeanDefinition\n                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                            \"Post-processing of merged bean definition failed\", ex);\n                }\n                mbd.postProcessed = true;\n            }\n        }\n\n        // 解决单例模式的循环依赖\n        // 单例模式 & 运行循环依赖&当前单例 bean 是否正在被创建\n        boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n                isSingletonCurrentlyInCreation(beanName));\n        if (earlySingletonExposure) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Eagerly caching bean '\" + beanName +\n                        \"' to allow for resolving potential circular references\");\n            }\n            // 提前将创建的 bean 实例加入到ectFactory 中\n            // 这里是为了后期避免循环依赖\n            addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n        }\n\n        /*\n         * 开始初始化 bean 实例对象\n         */\n        Object exposedObject = bean;\n        try {\n            // 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性\n            // 则会递归初始依赖 bean\n            populateBean(beanName, mbd, instanceWrapper);\n            // 调用初始化方法\n            exposedObject = initializeBean(beanName, exposedObject, mbd);\n        }\n        catch (Throwable ex) {\n            if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n                throw (BeanCreationException) ex;\n            }\n            else {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex);\n            }\n        }\n\n        /**\n         * 循环依赖处理\n         */\n        if (earlySingletonExposure) {\n            // 获取 earlySingletonReference\n            Object earlySingletonReference = getSingleton(beanName, false);\n            // 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空\n            if (earlySingletonReference != null) {\n                // 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强\n                if (exposedObject == bean) {\n                    exposedObject = earlySingletonReference;\n                }\n                // 处理依赖\n                else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n                    String[] dependentBeans = getDependentBeans(beanName);\n                    Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);\n                    for (String dependentBean : dependentBeans) {\n                        if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                            actualDependentBeans.add(dependentBean);\n                        }\n                    }\n                    if (!actualDependentBeans.isEmpty()) {\n                       。。。异常\n                    }\n                }\n            }\n        }\n        try {\n            // 注册 bean\n            registerDisposableBeanIfNecessary(beanName, bean, mbd);\n        }\n        catch (BeanDefinitionValidationException ex) {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n        }\n\n        return exposedObject;\n    }\n```\n\n`doCreateBean()` 是创建 bean 实例的核心方法，它的整体思路是：\n\n1. 如果是单例模式，则清除 factoryBeanInstanceCache 缓存，同时返回 BeanWrapper 实例对象，当然如果存在。\n2. 如果缓存中没有 BeanWrapper 或者不是单例模式，则调用 `createBeanInstance()` 实例化 bean，主要是将 BeanDefinition 转换为 BeanWrapper\n3. MergedBeanDefinitionPostProcessor 的应用\n4. 单例模式的循环依赖处理\n5. 调用 `populateBean()` 进行属性填充。将所有属性填充至 bean 的实例中\n6. 调用 `initializeBean()` 初始化 bean\n7. 依赖检查\n8. 注册 DisposableBean\n\n### 实例化 bean\n\n如果缓存中没有 BeanWrapper 实例对象或者该 bean 不是 singleton，则调用 `createBeanInstance()` 创建 bean 实例。该方法主要是根据参数 BeanDefinition、args[] 来调用构造函数实例化 bean 对象。过程较为复杂，如下：\n\n```java\n   protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, \n                                            @Nullable Object[] args) {\n        // 解析 bean，将 bean 类名解析为 class 引用\n        Class<?> beanClass = resolveBeanClass(mbd, beanName);\n\n        if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) \n            && !mbd.isNonPublicAccessAllowed()) {\n        。。。。异常\n        }\n\n        // 如果存在 Supplier 回调，则使用给定的回调方法初始化策略\n        Supplier<?> instanceSupplier = mbd.getInstanceSupplier();\n        if (instanceSupplier != null) {\n            return obtainFromSupplier(instanceSupplier, beanName);\n        }\n\n        // 如果工厂方法不为空，则使用工厂方法初始化策略\n        if (mbd.getFactoryMethodName() != null)  {\n            return instantiateUsingFactoryMethod(beanName, mbd, args);\n        }\n\n        boolean resolved = false;\n        boolean autowireNecessary = false;\n        if (args == null) {\n            // constructorArgumentLock 构造函数的常用锁\n            synchronized (mbd.constructorArgumentLock) {\n                // 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析\n                // 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制\n                if (mbd.resolvedConstructorOrFactoryMethod != null) {\n                    resolved = true;\n                    autowireNecessary = mbd.constructorArgumentsResolved;\n                }\n            }\n        }\n        // 已经解析好了，直接注入即可\n        if (resolved) {\n            // 自动注入，调用构造函数自动注入\n            if (autowireNecessary) {\n                return autowireConstructor(beanName, mbd, null, null);\n            }\n            else {\n                // 使用默认构造函数构造\n                return instantiateBean(beanName, mbd);\n            }\n        }\n\n        // 确定解析的构造函数\n        // 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor\n        Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n        if (ctors != null ||\n                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n                mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n            // 构造函数自动注入\n            return autowireConstructor(beanName, mbd, ctors, args);\n        }\n\n        //使用默认构造函数注入\n        return instantiateBean(beanName, mbd);\n    }\n```\n\n实例化 bean 是一个复杂的过程，其主要的逻辑为：\n\n- 如果存在 Supplier 回调，则调用 `obtainFromSupplier()` 进行初始化\n- 如果存在工厂方法，则使用工厂方法进行初始化\n- 首先判断缓存，如果缓存中存在，即已经解析过了，则直接使用已经解析了的，根据 constructorArgumentsResolved 参数来判断是使用构造函数自动注入还是默认构造函数\n- 如果缓存中没有，则需要先确定到底使用哪个构造函数来完成解析工作，因为一个类有多个构造函数，每个构造函数都有不同的构造参数，所以需要根据参数来锁定构造函数并完成初始化，如果存在参数则使用相应的带有参数的构造函数，否则使用默认构造函数。\n\n其实核心思想还是在于根据不同的情况执行不同的实例化策略，主要是包括如下四种策略：\n\n1. Supplier 回调\n2. `instantiateUsingFactoryMethod()` 工厂方法初始化\n3. `autowireConstructor()`，构造函数自动注入初始化\n4. `instantiateBean()`，默认构造函数注入\n\n其实无论哪种策略，他们的实现逻辑都差不多：确定构造函数和构造方法，然后实例化。只不过相对于 Supplier 回调和默认构造函数注入而言，工厂方法初始化和构造函数自动注入初始化会比较复杂，因为他们构造函数和构造参数的不确定性，Spring 需要花大量的精力来确定构造函数和构造参数，如果确定了则好办，直接选择实例化策略即可。当然在实例化的时候会根据是否有需要覆盖或者动态替换掉的方法，因为存在覆盖或者织入的话需要创建动态代理将方法织入，这个时候就只能选择 CGLIB 的方式来实例化，否则直接利用反射的方式即可。\n\n### 属性填充\n\n属性填充其实就是将 BeanDefinition 的属性值赋值给 BeanWrapper 实例对象的过程。在填充的过程需要根据注入的类型不同来区分是根据类型注入还是名字注入，当然在这个过程还会涉及循环依赖的问题的。\n\n```java\n    protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n        // 没有实例化对象\n        if (bw == null) {\n            // 有属性抛出异常\n            if (mbd.hasPropertyValues()) {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n            }\n            else {\n                // 没有属性直接返回\n                return;\n            }\n        }\n\n        // 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会\n        boolean continueWithPropertyPopulation = true;\n\n        // bena 不是\"合成\"的，即未由应用程序本身定义\n        // 是否持有 InstantiationAwareBeanPostProcessor\n        if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n            // 迭代所有的 BeanPostProcessors\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                // 如果为 InstantiationAwareBeanPostProcessor\n                if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                    // 返回值为是否继续填充 bean\n                    // postProcessAfterInstantiation：如果应该在 bean上面设置属性则返回true，否则返回false\n                    // 一般情况下，应该是返回true，返回 false 的话，\n                    // 将会阻止在此 Bean 实例上调用任何后续的 InstantiationAwareBeanPostProcessor 实例。\n                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n                        continueWithPropertyPopulation = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // 如果后续处理器发出停止填充命令，则终止后续操作\n        if (!continueWithPropertyPopulation) {\n            return;\n        }\n\n        // bean 的属性值\n        PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n\n            // 将 PropertyValues 封装成 MutablePropertyValues 对象\n            // MutablePropertyValues 允许对属性进行简单的操作，\n            // 并提供构造函数以支持Map的深度复制和构造。\n            MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n            // 根据名称自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n                autowireByName(beanName, mbd, bw, newPvs);\n            }\n\n            // 根据类型自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n                autowireByType(beanName, mbd, bw, newPvs);\n            }\n\n            pvs = newPvs;\n        }\n\n        // 是否已经注册了 InstantiationAwareBeanPostProcessors\n        boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n        // 是否需要进行依赖检查\n        boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n        if (hasInstAwareBpps || needsDepCheck) {\n            if (pvs == null) {\n                pvs = mbd.getPropertyValues();\n            }\n\n            // 从 bw 对象中提取 PropertyDescriptor 结果集\n            // PropertyDescriptor：可以通过一对存取方法提取一个属性\n            PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n            if (hasInstAwareBpps) {\n                for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                    if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                        // 对所有需要依赖检查的属性进行后处理\n                        pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n                        if (pvs == null) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if (needsDepCheck) {\n                // 依赖检查，对应 depends-on 属性\n                checkDependencies(beanName, mbd, filteredPds, pvs);\n            }\n        }\n\n        if (pvs != null) {\n            // 将属性应用到 bean 中\n            applyPropertyValues(beanName, mbd, bw, pvs);\n        }\n    }\n```\n\n处理流程如下：\n\n1. 根据 hasInstantiationAwareBeanPostProcessors 属性来判断是否需要在注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会，此过程可以控制 Spring 是否继续进行属性填充。\n2. 根据注入类型的不同来判断是根据名称来自动注入（`autowireByName()`）还是根据类型来自动注入（`autowireByType()`），统一存入到 PropertyValues 中，PropertyValues 用于描述 bean 的属性。\n3. 判断是否需要进行 BeanPostProcessor 和 依赖检测。\n4. 将所有 PropertyValues 中的属性填充到 BeanWrapper 中。\n\n### 初始化 bean\n\n初始化 bean 为 `createBean()` 的最后一个过程，该过程主要做三件事情：\n\n1. 激活 Aware 方法\n2. 后置处理器的应用\n3. 激活自定义的 init 方法\n\n```java\n    protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {\n        if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n                // 激活 Aware 方法\n                invokeAwareMethods(beanName, bean);\n                return null;\n            }, getAccessControlContext());\n        }\n        else {\n            // 对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware\n            invokeAwareMethods(beanName, bean);\n        }\n\n        Object wrappedBean = bean;\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 后处理器\n            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n        }\n\n        try {\n            // 激活用户自定义的 init 方法\n            invokeInitMethods(beanName, wrappedBean, mbd);\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(\n                    (mbd != null ? mbd.getResourceDescription() : null),\n                    beanName, \"Invocation of init method failed\", ex);\n        }\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 后处理器\n            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n        }\n        return wrappedBean;\n    }\n```\n\n## 从 bean 实例中获取对象\n\n无论是从单例缓存中获取的 bean 实例 还是通过 `createBean()` 创建的 bean 实例，最终都会调用 `getObjectForBeanInstance()` ，该方法是根据传入的 bean 实例获取对象，按照 Spring 的传统，该方法也只是做一些检测工作，真正的实现逻辑是委托给 `getObjectFromFactoryBean()` 实现。\n\n```java\n   protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {\n        // 为单例模式且缓存中存在\n        if (factory.isSingleton() && containsSingleton(beanName)) {\n\n            synchronized (getSingletonMutex()) {\n                // 从缓存中获取指定的 factoryBean\n                Object object = this.factoryBeanObjectCache.get(beanName);\n\n                if (object == null) {\n                    // 为空，则从 FactoryBean 中获取对象\n                    object = doGetObjectFromFactoryBean(factory, beanName);\n\n                    // 从缓存中获取\n                    Object alreadyThere = this.factoryBeanObjectCache.get(beanName);\n                    // **我实在是不明白这里这么做的原因，这里是干嘛？？？**\n                    if (alreadyThere != null) {\n                        object = alreadyThere;\n                    }\n                    else {\n                        // 需要后续处理\n                        if (shouldPostProcess) {\n                            // 若该 bean 处于创建中，则返回非处理对象，而不是存储它\n                            if (isSingletonCurrentlyInCreation(beanName)) {\n                                return object;\n                            }\n                            // 前置处理\n                            beforeSingletonCreation(beanName);\n                            try {\n                                // 对从 FactoryBean 获取的对象进行后处理\n                                // 生成的对象将暴露给bean引用\n                                object = postProcessObjectFromFactoryBean(object, beanName);\n                            }\n                            catch (Throwable ex) {\n                                throw new BeanCreationException(beanName,\n                                        \"Post-processing of FactoryBean's singleton object failed\", ex);\n                            }\n                            finally {\n                                // 后置处理\n                                afterSingletonCreation(beanName);\n                            }\n                        }\n                        // 缓存\n                        if (containsSingleton(beanName)) {\n                            this.factoryBeanObjectCache.put(beanName, object);\n                        }\n                    }\n                }\n                return object;\n            }\n        }\n        else {\n            // 非单例\n            Object object = doGetObjectFromFactoryBean(factory, beanName);\n            if (shouldPostProcess) {\n                try {\n                    object = postProcessObjectFromFactoryBean(object, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(beanName, \"Post-processing of FactoryBean's object failed\", ex);\n                }\n            }\n            return object;\n        }\n    }\n```\n\n主要流程如下：\n\n- 若为单例且单例 bean 缓存中存在 beanName，则进行后续处理（跳转到下一步），否则则从 FactoryBean 中获取 bean 实例对象，如果接受后置处理，则调用 `postProcessObjectFromFactoryBean()` 进行后置处理。\n- 首先获取锁（其实我们在前面篇幅中发现了大量的同步锁，锁住的对象都是 this.singletonObjects， 主要是因为在单例模式中必须要保证全局唯一），然后从 factoryBeanObjectCache 缓存中获取实例对象 object，若 object 为空，则调用 `doGetObjectFromFactoryBean()` 方法从 FactoryBean 获取对象，其实内部就是调用 `FactoryBean.getObject()`。\n- 如果需要后续处理，则进行进一步处理，步骤如下：\n  - 若该 bean 处于创建中（isSingletonCurrentlyInCreation），则返回非处理对象，而不是存储它\n  - 调用 `beforeSingletonCreation()` 进行创建之前的处理。默认实现将该 bean 标志为当前创建的。\n  - 调用 `postProcessObjectFromFactoryBean()` 对从 FactoryBean 获取的 bean 实例对象进行后置处理，默认实现是按照原样直接返回，具体实现是在 AbstractAutowireCapableBeanFactory 中实现的，当然子类也可以重写它，比如应用后置处理\n  - 调用 `afterSingletonCreation()` 进行创建 bean 之后的处理，默认实现是将该 bean 标记为不再在创建中。\n- 最后加入到 FactoryBeans 缓存中。\n\nEnd!!!\n\n到这里，Spring 加载 bean 的整体过程都已经分析完毕了，详情请给位移步到以下链接：\n\n1.  [spring源码解析之 16 开启bean的加载](https://taolove.top/posts/39/)\n2.  [spring源码解析之 17缓存中获取单例bean](https://taolove.top/posts/42/)\n3.  [spring源码解析之 18parentBeanFactory 与依赖处理](https://taolove.top/posts/37/)\n4.  [spring源码解析之 19 各Scope的创建](https://taolove.top/posts/38/)\n5.  [spring源码解析之 20 开启bean的实例化进程](https://taolove.top/posts/43/)\n6.   [spring源码解析之 21 实例化bean](https://taolove.top/posts/40/)\n7.  [spring源码解析之 22构造函数实例化](https://taolove.top/posts/41/)\n8.  [spring源码解析之 23属性填充](https://taolove.top/posts/44/)\n9.  [spring源码解析之 24循环依赖处理](https://taolove.top/posts/45/)\n10.  [spring源码解析之 25bean的初始化](https://taolove.top/posts/46/)\n11.  [spring源码解析之 26深入分析Aware接口](https://taolove.top/posts/49/)\n12.  [spring源码解析之 27深入分析BeanPostProcessor接口](https://taolove.top/posts/48/)\n13.  [spring源码解析之 28深入分析InitializingBean 接口和 init-method](https://taolove.top/posts/47/)","source":"_posts/spring 源码分析/spring/spring源码解析之 29实例化bean总结.md","raw":"title: spring源码解析之 29实例化bean总结\nauthor: fengxiutianya\nabbrlink: 40140\ntags:\n  - spring源码解析\ncategories:\n  - spring\ndate: 2019-01-15 06:54:00\n---\n在 Spring bean 解析篇深入分析了一个配置文件经历了哪些过程转变成了 BeanDefinition，但是这个 BeanDefinition 并不是我们真正想要的想要的 bean，因为它还仅仅只是承载了我们需要的目标 bean 的信息，从 BeanDefinition 到我们需要的目标还需要一个漫长的 bean 的初始化阶段，在Spring bean 实例化阶段已经详细分析了初始化 bean 的过程，所以这里做一个概括性的总结。\n\nbean 的初始化节点由第一次调用 `getBean()`(显式或者隐式)开启，所以我们从这个方法开始。\n<!-- more -->\n```java\n    public Object getBean(String name) throws BeansException {\n        return doGetBean(name, null, null, false);\n    }\n\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n                              @Nullable final Object[] args, boolean typeCheckOnly)\n \t\t\t throws BeansException {\n\n        // 获取 beanName，这里是一个转换动作，将 name 转换Wie beanName\n        final String beanName = transformedBeanName(name);\n        Object bean;\n\n        // 从缓存中或者实例工厂中获取 bean\n        // *** 这里会涉及到解决循环依赖 bean 的问题\n        Object sharedInstance = getSingleton(beanName);\n        if (sharedInstance != null && args == null) {\n            if (logger.isDebugEnabled()) {\n                if (isSingletonCurrentlyInCreation(beanName)) {\n                  。。。。日志\n                }\n                else {\n                  。。。 日志\n                }\n            }\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n        }\n\n        else {\n\n            // 因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常\n            // **关于循环依赖后续会单独出文详细说明**\n            if (isPrototypeCurrentlyInCreation(beanName)) {\n                throw new BeanCurrentlyInCreationException(beanName);\n            }\n\n            // 如果容器中没有找到，则从父类容器中加载\n            BeanFactory parentBeanFactory = getParentBeanFactory();\n            if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n                String nameToLookup = originalBeanName(name);\n                if (parentBeanFactory instanceof AbstractBeanFactory) {\n                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                            nameToLookup, requiredType, args, typeCheckOnly);\n                }\n                else if (args != null) {\n                    return (T) parentBeanFactory.getBean(nameToLookup, args);\n                }\n                else {\n                    return parentBeanFactory.getBean(nameToLookup, requiredType);\n                }\n            }\n\n            // 如果不是仅仅做类型检查则是创建bean，这里需要记录\n            if (!typeCheckOnly) {\n                markBeanAsCreated(beanName);\n            }\n\n            try {\n    // 从容器中获取 beanName 相应的 GenericBeanDefinition，并将其转换为 RootBeanDefinition\n                final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\n                // 检查给定的合并的 BeanDefinition\n                checkMergedBeanDefinition(mbd, beanName, args);\n\n                // 处理所依赖的 bean\n                String[] dependsOn = mbd.getDependsOn();\n                if (dependsOn != null) {\n                    for (String dep : dependsOn) {\n                        // 若给定的依赖 bean 已经注册为依赖给定的b ean\n                        // 循环依赖的情况\n                        if (isDependent(beanName, dep)) {\n                         \t。。。异常\n                        }\n                        // 缓存依赖调用\n                        registerDependentBean(dep, beanName);\n                        try {\n                            getBean(dep);\n                        }\n                        catch (NoSuchBeanDefinitionException ex) {\n                           \t。。。异常\n                        }\n                    }\n                }\n\n                // bean 实例化\n                // 单例模式\n                if (mbd.isSingleton()) {\n                    sharedInstance = getSingleton(beanName, () -> {\n                        try {\n                            return createBean(beanName, mbd, args);\n                        }\n                        catch (BeansException ex) {\n                            // 显示从单利缓存中删除 bean 实例\n                            // 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它\n                            destroySingleton(beanName);\n                            throw ex;\n                        }\n                    });\n             bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n                }\n\n                // 原型模式\n                else if (mbd.isPrototype()) {\n                    // It's a prototype -> create a new instance.\n                    Object prototypeInstance = null;\n                    try {\n                        beforePrototypeCreation(beanName);\n                        prototypeInstance = createBean(beanName, mbd, args);\n                    }\n                    finally {\n                        afterPrototypeCreation(beanName);\n                    }\n             bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n                }\n\n                else {\n                    // 从指定的 scope 下创建 bean\n                    String scopeName = mbd.getScope();\n                    final Scope scope = this.scopes.get(scopeName);\n                    if (scope == null) {\n                       。。。异常\n                    }\n                    try {\n                        Object scopedInstance = scope.get(beanName, () -> {\n                            beforePrototypeCreation(beanName);\n                            try {\n                                return createBean(beanName, mbd, args);\n                            }\n                            finally {\n                                afterPrototypeCreation(beanName);\n                            }\n                        });\n         bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n                    }\n                    catch (IllegalStateException ex) {\n                       。。。。异常\n                    }\n                }\n            }\n            catch (BeansException ex) {\n                cleanupAfterBeanCreationFailure(beanName);\n                throw ex;\n            }\n        }\n\n        // 检查需要的类型是否符合 bean 的实际类型\n        if (requiredType != null && !requiredType.isInstance(bean)) {\n            try {\n          T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n                if (convertedBean == null) {\n                  。。。异常\n                }\n                return convertedBean;\n            }\n            catch (TypeMismatchException ex) {\n                if (logger.isDebugEnabled()) {\n                   。。日志\n                }\n               。。。异常\n            }\n        }\n        return (T) bean;\n    }\n```\n\n内部调用 `doGetBean()` 方法，`doGetBean()` 的代码量比较多，从这里就可以看出 bean 的加载过程是一个非常复杂的过程，会涉及到各种各样的情况处理。`doGetBean()` 可以分为以下几个过程。\n\n1. 转换 beanName。因为我们调用 `getBean()` 方法传入的 name 并不一定就是 beanName，可以传入 aliasName，FactoryBean，所以这里需要进行简单的转换过程。\n2. 尝试从缓存中加载单例 bean。\n3. bean 的实例化。\n4. 原型模式的依赖检查。因为 Spring 只会解决单例模式的循环依赖，对于原型模式的循环依赖都是直接抛出 BeanCurrentlyInCreationException 异常。\n5. 尝试从 parentBeanFactory 获取 bean 实例。如果 `parentBeanFactory != null && !containsBeanDefinition(beanName)` 则尝试从 parentBeanFactory 中获取 bean 实例对象，因为 `!containsBeanDefinition(beanName)` 就意味着定义的 xml 文件中没有 beanName 相应的配置，这个时候就只能从 parentBeanFactory 中获取。\n6. 获取 RootBeanDefinition，并对其进行合并检查。从缓存中获取已经解析的 RootBeanDefinition，同时如果父类不为 null 的话，则会合并父类的属性。\n7. 依赖检查。某个 bean 依赖其他 bean ，则需要先加载依赖的 bean。\n8. 对不同的 scope 进行处理。\n9. 类型转换处理。如果传递的 requiredType 不为 null，则需要检测所得到 bean 的类型是否与该 requiredType 一致，如果不一致则尝试转换，当然也要能够转换成功，否则抛出 BeanNotOfRequiredTypeException 异常。\n\n下面就以下几个方面进行阐述，说明 Spring bean 的加载过程。\n\n1. 从缓存中获取 bean\n2. 创建 bean 实例对象\n3. 从 bean 实例中获取对象\n\n## 从缓存中获取 bean\n\nSpring 中根据 scope 可以将 bean 分为以下几类：singleton、prototype 和 其他，这样分的原因在于 Spring 在对不同 scope 处理的时候是这么处理的。\n\n- singleton：在 Spring 的 IoC 容器中只存在一个对象实例，所有该对象的引用都共享这个实例。Spring 容器只会创建该 bean 定义的唯一实例，这个实例会被保存到缓存中，并且对该bean的所有后续请求和引用都将返回该缓存中的对象实例。\n- prototype：每次对该bean的请求都会创建一个新的实例\n- 其他：其他包括 request、session、global session：\n  - request：每次 http 请求将会有各自的 bean 实例。\n  - session：在一个 http session 中，一个 bean 定义对应一个 bean 实例。\n  - global session：在一个全局的 http session 中，一个 bean 定义对应一个 bean 实例。\n\n所以从缓存中获取的 bean 一定是 singleton bean，这也是 Spring 为何只解决 singleton bean 的循环依赖。调用 `getSingleton()` 从缓存中获取 singleton bean。\n\n```java\npublic Object getSingleton(String beanName) {\n    return getSingleton(beanName, true);\n}\n\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    Object singletonObject = this.singletonObjects.get(beanName);\n    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n        synchronized (this.singletonObjects) {\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null && allowEarlyReference) {\n                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    singletonObject = singletonFactory.getObject();\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return singletonObject;\n}\n```\n\n`getSingleton()` 就是从 singletonObjects、earlySingletonObjects、 singletonFactories 三个缓存中获取，这里也是 Spring 解决 bean 循环依赖的关键之处。\n\n## 创建 bean 实例对象\n\n如果缓存中没有，也没有 parentBeanFactory ，则会调用 `createBean()` 创建 bean 实例，该方法主要是在处理不同 scope 的 bean 的时候进行调用。\n\n```java\nprotected abstract Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n            throws BeanCreationException\n```\n\n该方法是定义在 AbstractBeanFactory 中的虚拟方法，其含义是根据给定的 BeanDefinition 和 args实例化一个 bean 对象，如果该 BeanDefinition 存在父类，则该 BeanDefinition 已经合并了父类的属性。所有 Bean 实例的创建都会委托给该方法实现。\n\n方法接受三个参数：\n\n- beanName：bean 的名字\n- mbd：已经合并了父类属性的（如果有的话）BeanDefinition\n- args：用于构造函数或者工厂方法创建 bean 实例对象的参数\n\n该抽象方法的默认实现是在类 AbstractAutowireCapableBeanFactory 中实现，该方法其实只是做一些检查和验证工作，真正的初始化工作是由 `doCreateBean()` 实现，如下：\n\n```java\n   protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n            throws BeanCreationException {\n\n        // BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装bean的属性描述器\n        BeanWrapper instanceWrapper = null;\n        // 单例模型，则从未完成的 FactoryBean 缓存中删除\n        if (mbd.isSingleton()) {anceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n        }\n\n        // 使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化\n        if (instanceWrapper == null) {\n            instanceWrapper = createBeanInstance(beanName, mbd, args);\n        }\n\n        // 包装的实例对象\n        final Object bean = instanceWrapper.getWrappedInstance();\n        // 包装的实例对象的类型\n        Class<?> beanType = instanceWrapper.getWrappedClass();\n        if (beanType != NullBean.class) {\n            mbd.resolvedTargetType = beanType;\n        }\n\n        // 检测是否有后置处理\n        // 如果有后置处理，则允许后置处理修改 BeanDefinition\n        synchronized (mbd.postProcessingLock) {\n            if (!mbd.postProcessed) {\n                try {\n                    // applyMergedBeanDefinitionPostProcessors\n                    // 后置处理修改 BeanDefinition\n                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                            \"Post-processing of merged bean definition failed\", ex);\n                }\n                mbd.postProcessed = true;\n            }\n        }\n\n        // 解决单例模式的循环依赖\n        // 单例模式 & 运行循环依赖&当前单例 bean 是否正在被创建\n        boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n                isSingletonCurrentlyInCreation(beanName));\n        if (earlySingletonExposure) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Eagerly caching bean '\" + beanName +\n                        \"' to allow for resolving potential circular references\");\n            }\n            // 提前将创建的 bean 实例加入到ectFactory 中\n            // 这里是为了后期避免循环依赖\n            addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n        }\n\n        /*\n         * 开始初始化 bean 实例对象\n         */\n        Object exposedObject = bean;\n        try {\n            // 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性\n            // 则会递归初始依赖 bean\n            populateBean(beanName, mbd, instanceWrapper);\n            // 调用初始化方法\n            exposedObject = initializeBean(beanName, exposedObject, mbd);\n        }\n        catch (Throwable ex) {\n            if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n                throw (BeanCreationException) ex;\n            }\n            else {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex);\n            }\n        }\n\n        /**\n         * 循环依赖处理\n         */\n        if (earlySingletonExposure) {\n            // 获取 earlySingletonReference\n            Object earlySingletonReference = getSingleton(beanName, false);\n            // 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空\n            if (earlySingletonReference != null) {\n                // 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强\n                if (exposedObject == bean) {\n                    exposedObject = earlySingletonReference;\n                }\n                // 处理依赖\n                else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n                    String[] dependentBeans = getDependentBeans(beanName);\n                    Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);\n                    for (String dependentBean : dependentBeans) {\n                        if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                            actualDependentBeans.add(dependentBean);\n                        }\n                    }\n                    if (!actualDependentBeans.isEmpty()) {\n                       。。。异常\n                    }\n                }\n            }\n        }\n        try {\n            // 注册 bean\n            registerDisposableBeanIfNecessary(beanName, bean, mbd);\n        }\n        catch (BeanDefinitionValidationException ex) {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n        }\n\n        return exposedObject;\n    }\n```\n\n`doCreateBean()` 是创建 bean 实例的核心方法，它的整体思路是：\n\n1. 如果是单例模式，则清除 factoryBeanInstanceCache 缓存，同时返回 BeanWrapper 实例对象，当然如果存在。\n2. 如果缓存中没有 BeanWrapper 或者不是单例模式，则调用 `createBeanInstance()` 实例化 bean，主要是将 BeanDefinition 转换为 BeanWrapper\n3. MergedBeanDefinitionPostProcessor 的应用\n4. 单例模式的循环依赖处理\n5. 调用 `populateBean()` 进行属性填充。将所有属性填充至 bean 的实例中\n6. 调用 `initializeBean()` 初始化 bean\n7. 依赖检查\n8. 注册 DisposableBean\n\n### 实例化 bean\n\n如果缓存中没有 BeanWrapper 实例对象或者该 bean 不是 singleton，则调用 `createBeanInstance()` 创建 bean 实例。该方法主要是根据参数 BeanDefinition、args[] 来调用构造函数实例化 bean 对象。过程较为复杂，如下：\n\n```java\n   protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, \n                                            @Nullable Object[] args) {\n        // 解析 bean，将 bean 类名解析为 class 引用\n        Class<?> beanClass = resolveBeanClass(mbd, beanName);\n\n        if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) \n            && !mbd.isNonPublicAccessAllowed()) {\n        。。。。异常\n        }\n\n        // 如果存在 Supplier 回调，则使用给定的回调方法初始化策略\n        Supplier<?> instanceSupplier = mbd.getInstanceSupplier();\n        if (instanceSupplier != null) {\n            return obtainFromSupplier(instanceSupplier, beanName);\n        }\n\n        // 如果工厂方法不为空，则使用工厂方法初始化策略\n        if (mbd.getFactoryMethodName() != null)  {\n            return instantiateUsingFactoryMethod(beanName, mbd, args);\n        }\n\n        boolean resolved = false;\n        boolean autowireNecessary = false;\n        if (args == null) {\n            // constructorArgumentLock 构造函数的常用锁\n            synchronized (mbd.constructorArgumentLock) {\n                // 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析\n                // 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制\n                if (mbd.resolvedConstructorOrFactoryMethod != null) {\n                    resolved = true;\n                    autowireNecessary = mbd.constructorArgumentsResolved;\n                }\n            }\n        }\n        // 已经解析好了，直接注入即可\n        if (resolved) {\n            // 自动注入，调用构造函数自动注入\n            if (autowireNecessary) {\n                return autowireConstructor(beanName, mbd, null, null);\n            }\n            else {\n                // 使用默认构造函数构造\n                return instantiateBean(beanName, mbd);\n            }\n        }\n\n        // 确定解析的构造函数\n        // 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor\n        Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n        if (ctors != null ||\n                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n                mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n            // 构造函数自动注入\n            return autowireConstructor(beanName, mbd, ctors, args);\n        }\n\n        //使用默认构造函数注入\n        return instantiateBean(beanName, mbd);\n    }\n```\n\n实例化 bean 是一个复杂的过程，其主要的逻辑为：\n\n- 如果存在 Supplier 回调，则调用 `obtainFromSupplier()` 进行初始化\n- 如果存在工厂方法，则使用工厂方法进行初始化\n- 首先判断缓存，如果缓存中存在，即已经解析过了，则直接使用已经解析了的，根据 constructorArgumentsResolved 参数来判断是使用构造函数自动注入还是默认构造函数\n- 如果缓存中没有，则需要先确定到底使用哪个构造函数来完成解析工作，因为一个类有多个构造函数，每个构造函数都有不同的构造参数，所以需要根据参数来锁定构造函数并完成初始化，如果存在参数则使用相应的带有参数的构造函数，否则使用默认构造函数。\n\n其实核心思想还是在于根据不同的情况执行不同的实例化策略，主要是包括如下四种策略：\n\n1. Supplier 回调\n2. `instantiateUsingFactoryMethod()` 工厂方法初始化\n3. `autowireConstructor()`，构造函数自动注入初始化\n4. `instantiateBean()`，默认构造函数注入\n\n其实无论哪种策略，他们的实现逻辑都差不多：确定构造函数和构造方法，然后实例化。只不过相对于 Supplier 回调和默认构造函数注入而言，工厂方法初始化和构造函数自动注入初始化会比较复杂，因为他们构造函数和构造参数的不确定性，Spring 需要花大量的精力来确定构造函数和构造参数，如果确定了则好办，直接选择实例化策略即可。当然在实例化的时候会根据是否有需要覆盖或者动态替换掉的方法，因为存在覆盖或者织入的话需要创建动态代理将方法织入，这个时候就只能选择 CGLIB 的方式来实例化，否则直接利用反射的方式即可。\n\n### 属性填充\n\n属性填充其实就是将 BeanDefinition 的属性值赋值给 BeanWrapper 实例对象的过程。在填充的过程需要根据注入的类型不同来区分是根据类型注入还是名字注入，当然在这个过程还会涉及循环依赖的问题的。\n\n```java\n    protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n        // 没有实例化对象\n        if (bw == null) {\n            // 有属性抛出异常\n            if (mbd.hasPropertyValues()) {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n            }\n            else {\n                // 没有属性直接返回\n                return;\n            }\n        }\n\n        // 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会\n        boolean continueWithPropertyPopulation = true;\n\n        // bena 不是\"合成\"的，即未由应用程序本身定义\n        // 是否持有 InstantiationAwareBeanPostProcessor\n        if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n            // 迭代所有的 BeanPostProcessors\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                // 如果为 InstantiationAwareBeanPostProcessor\n                if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                    // 返回值为是否继续填充 bean\n                    // postProcessAfterInstantiation：如果应该在 bean上面设置属性则返回true，否则返回false\n                    // 一般情况下，应该是返回true，返回 false 的话，\n                    // 将会阻止在此 Bean 实例上调用任何后续的 InstantiationAwareBeanPostProcessor 实例。\n                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n                        continueWithPropertyPopulation = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // 如果后续处理器发出停止填充命令，则终止后续操作\n        if (!continueWithPropertyPopulation) {\n            return;\n        }\n\n        // bean 的属性值\n        PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n\n            // 将 PropertyValues 封装成 MutablePropertyValues 对象\n            // MutablePropertyValues 允许对属性进行简单的操作，\n            // 并提供构造函数以支持Map的深度复制和构造。\n            MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n            // 根据名称自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n                autowireByName(beanName, mbd, bw, newPvs);\n            }\n\n            // 根据类型自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n                autowireByType(beanName, mbd, bw, newPvs);\n            }\n\n            pvs = newPvs;\n        }\n\n        // 是否已经注册了 InstantiationAwareBeanPostProcessors\n        boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n        // 是否需要进行依赖检查\n        boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n        if (hasInstAwareBpps || needsDepCheck) {\n            if (pvs == null) {\n                pvs = mbd.getPropertyValues();\n            }\n\n            // 从 bw 对象中提取 PropertyDescriptor 结果集\n            // PropertyDescriptor：可以通过一对存取方法提取一个属性\n            PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n            if (hasInstAwareBpps) {\n                for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                    if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                        // 对所有需要依赖检查的属性进行后处理\n                        pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n                        if (pvs == null) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if (needsDepCheck) {\n                // 依赖检查，对应 depends-on 属性\n                checkDependencies(beanName, mbd, filteredPds, pvs);\n            }\n        }\n\n        if (pvs != null) {\n            // 将属性应用到 bean 中\n            applyPropertyValues(beanName, mbd, bw, pvs);\n        }\n    }\n```\n\n处理流程如下：\n\n1. 根据 hasInstantiationAwareBeanPostProcessors 属性来判断是否需要在注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会，此过程可以控制 Spring 是否继续进行属性填充。\n2. 根据注入类型的不同来判断是根据名称来自动注入（`autowireByName()`）还是根据类型来自动注入（`autowireByType()`），统一存入到 PropertyValues 中，PropertyValues 用于描述 bean 的属性。\n3. 判断是否需要进行 BeanPostProcessor 和 依赖检测。\n4. 将所有 PropertyValues 中的属性填充到 BeanWrapper 中。\n\n### 初始化 bean\n\n初始化 bean 为 `createBean()` 的最后一个过程，该过程主要做三件事情：\n\n1. 激活 Aware 方法\n2. 后置处理器的应用\n3. 激活自定义的 init 方法\n\n```java\n    protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {\n        if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n                // 激活 Aware 方法\n                invokeAwareMethods(beanName, bean);\n                return null;\n            }, getAccessControlContext());\n        }\n        else {\n            // 对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware\n            invokeAwareMethods(beanName, bean);\n        }\n\n        Object wrappedBean = bean;\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 后处理器\n            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n        }\n\n        try {\n            // 激活用户自定义的 init 方法\n            invokeInitMethods(beanName, wrappedBean, mbd);\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(\n                    (mbd != null ? mbd.getResourceDescription() : null),\n                    beanName, \"Invocation of init method failed\", ex);\n        }\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 后处理器\n            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n        }\n        return wrappedBean;\n    }\n```\n\n## 从 bean 实例中获取对象\n\n无论是从单例缓存中获取的 bean 实例 还是通过 `createBean()` 创建的 bean 实例，最终都会调用 `getObjectForBeanInstance()` ，该方法是根据传入的 bean 实例获取对象，按照 Spring 的传统，该方法也只是做一些检测工作，真正的实现逻辑是委托给 `getObjectFromFactoryBean()` 实现。\n\n```java\n   protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {\n        // 为单例模式且缓存中存在\n        if (factory.isSingleton() && containsSingleton(beanName)) {\n\n            synchronized (getSingletonMutex()) {\n                // 从缓存中获取指定的 factoryBean\n                Object object = this.factoryBeanObjectCache.get(beanName);\n\n                if (object == null) {\n                    // 为空，则从 FactoryBean 中获取对象\n                    object = doGetObjectFromFactoryBean(factory, beanName);\n\n                    // 从缓存中获取\n                    Object alreadyThere = this.factoryBeanObjectCache.get(beanName);\n                    // **我实在是不明白这里这么做的原因，这里是干嘛？？？**\n                    if (alreadyThere != null) {\n                        object = alreadyThere;\n                    }\n                    else {\n                        // 需要后续处理\n                        if (shouldPostProcess) {\n                            // 若该 bean 处于创建中，则返回非处理对象，而不是存储它\n                            if (isSingletonCurrentlyInCreation(beanName)) {\n                                return object;\n                            }\n                            // 前置处理\n                            beforeSingletonCreation(beanName);\n                            try {\n                                // 对从 FactoryBean 获取的对象进行后处理\n                                // 生成的对象将暴露给bean引用\n                                object = postProcessObjectFromFactoryBean(object, beanName);\n                            }\n                            catch (Throwable ex) {\n                                throw new BeanCreationException(beanName,\n                                        \"Post-processing of FactoryBean's singleton object failed\", ex);\n                            }\n                            finally {\n                                // 后置处理\n                                afterSingletonCreation(beanName);\n                            }\n                        }\n                        // 缓存\n                        if (containsSingleton(beanName)) {\n                            this.factoryBeanObjectCache.put(beanName, object);\n                        }\n                    }\n                }\n                return object;\n            }\n        }\n        else {\n            // 非单例\n            Object object = doGetObjectFromFactoryBean(factory, beanName);\n            if (shouldPostProcess) {\n                try {\n                    object = postProcessObjectFromFactoryBean(object, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(beanName, \"Post-processing of FactoryBean's object failed\", ex);\n                }\n            }\n            return object;\n        }\n    }\n```\n\n主要流程如下：\n\n- 若为单例且单例 bean 缓存中存在 beanName，则进行后续处理（跳转到下一步），否则则从 FactoryBean 中获取 bean 实例对象，如果接受后置处理，则调用 `postProcessObjectFromFactoryBean()` 进行后置处理。\n- 首先获取锁（其实我们在前面篇幅中发现了大量的同步锁，锁住的对象都是 this.singletonObjects， 主要是因为在单例模式中必须要保证全局唯一），然后从 factoryBeanObjectCache 缓存中获取实例对象 object，若 object 为空，则调用 `doGetObjectFromFactoryBean()` 方法从 FactoryBean 获取对象，其实内部就是调用 `FactoryBean.getObject()`。\n- 如果需要后续处理，则进行进一步处理，步骤如下：\n  - 若该 bean 处于创建中（isSingletonCurrentlyInCreation），则返回非处理对象，而不是存储它\n  - 调用 `beforeSingletonCreation()` 进行创建之前的处理。默认实现将该 bean 标志为当前创建的。\n  - 调用 `postProcessObjectFromFactoryBean()` 对从 FactoryBean 获取的 bean 实例对象进行后置处理，默认实现是按照原样直接返回，具体实现是在 AbstractAutowireCapableBeanFactory 中实现的，当然子类也可以重写它，比如应用后置处理\n  - 调用 `afterSingletonCreation()` 进行创建 bean 之后的处理，默认实现是将该 bean 标记为不再在创建中。\n- 最后加入到 FactoryBeans 缓存中。\n\nEnd!!!\n\n到这里，Spring 加载 bean 的整体过程都已经分析完毕了，详情请给位移步到以下链接：\n\n1.  [spring源码解析之 16 开启bean的加载](https://taolove.top/posts/39/)\n2.  [spring源码解析之 17缓存中获取单例bean](https://taolove.top/posts/42/)\n3.  [spring源码解析之 18parentBeanFactory 与依赖处理](https://taolove.top/posts/37/)\n4.  [spring源码解析之 19 各Scope的创建](https://taolove.top/posts/38/)\n5.  [spring源码解析之 20 开启bean的实例化进程](https://taolove.top/posts/43/)\n6.   [spring源码解析之 21 实例化bean](https://taolove.top/posts/40/)\n7.  [spring源码解析之 22构造函数实例化](https://taolove.top/posts/41/)\n8.  [spring源码解析之 23属性填充](https://taolove.top/posts/44/)\n9.  [spring源码解析之 24循环依赖处理](https://taolove.top/posts/45/)\n10.  [spring源码解析之 25bean的初始化](https://taolove.top/posts/46/)\n11.  [spring源码解析之 26深入分析Aware接口](https://taolove.top/posts/49/)\n12.  [spring源码解析之 27深入分析BeanPostProcessor接口](https://taolove.top/posts/48/)\n13.  [spring源码解析之 28深入分析InitializingBean 接口和 init-method](https://taolove.top/posts/47/)","slug":"spring 源码分析/spring/spring源码解析之 29实例化bean总结","published":1,"updated":"2019-01-16T08:33:46.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs9qovy8006a9q1uaqkzdamh","content":"<p>在 Spring bean 解析篇深入分析了一个配置文件经历了哪些过程转变成了 BeanDefinition，但是这个 BeanDefinition 并不是我们真正想要的想要的 bean，因为它还仅仅只是承载了我们需要的目标 bean 的信息，从 BeanDefinition 到我们需要的目标还需要一个漫长的 bean 的初始化阶段，在Spring bean 实例化阶段已经详细分析了初始化 bean 的过程，所以这里做一个概括性的总结。</p>\n<p>bean 的初始化节点由第一次调用 <code>getBean()</code>(显式或者隐式)开启，所以我们从这个方法开始。<br><a id=\"more\"></a></p>\n<pre><code class=\"java\">    public Object getBean(String name) throws BeansException {\n        return doGetBean(name, null, null, false);\n    }\n\nprotected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,\n                              @Nullable final Object[] args, boolean typeCheckOnly)\n              throws BeansException {\n\n        // 获取 beanName，这里是一个转换动作，将 name 转换Wie beanName\n        final String beanName = transformedBeanName(name);\n        Object bean;\n\n        // 从缓存中或者实例工厂中获取 bean\n        // *** 这里会涉及到解决循环依赖 bean 的问题\n        Object sharedInstance = getSingleton(beanName);\n        if (sharedInstance != null &amp;&amp; args == null) {\n            if (logger.isDebugEnabled()) {\n                if (isSingletonCurrentlyInCreation(beanName)) {\n                  。。。。日志\n                }\n                else {\n                  。。。 日志\n                }\n            }\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n        }\n\n        else {\n\n            // 因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常\n            // **关于循环依赖后续会单独出文详细说明**\n            if (isPrototypeCurrentlyInCreation(beanName)) {\n                throw new BeanCurrentlyInCreationException(beanName);\n            }\n\n            // 如果容器中没有找到，则从父类容器中加载\n            BeanFactory parentBeanFactory = getParentBeanFactory();\n            if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n                String nameToLookup = originalBeanName(name);\n                if (parentBeanFactory instanceof AbstractBeanFactory) {\n                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                            nameToLookup, requiredType, args, typeCheckOnly);\n                }\n                else if (args != null) {\n                    return (T) parentBeanFactory.getBean(nameToLookup, args);\n                }\n                else {\n                    return parentBeanFactory.getBean(nameToLookup, requiredType);\n                }\n            }\n\n            // 如果不是仅仅做类型检查则是创建bean，这里需要记录\n            if (!typeCheckOnly) {\n                markBeanAsCreated(beanName);\n            }\n\n            try {\n    // 从容器中获取 beanName 相应的 GenericBeanDefinition，并将其转换为 RootBeanDefinition\n                final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\n                // 检查给定的合并的 BeanDefinition\n                checkMergedBeanDefinition(mbd, beanName, args);\n\n                // 处理所依赖的 bean\n                String[] dependsOn = mbd.getDependsOn();\n                if (dependsOn != null) {\n                    for (String dep : dependsOn) {\n                        // 若给定的依赖 bean 已经注册为依赖给定的b ean\n                        // 循环依赖的情况\n                        if (isDependent(beanName, dep)) {\n                             。。。异常\n                        }\n                        // 缓存依赖调用\n                        registerDependentBean(dep, beanName);\n                        try {\n                            getBean(dep);\n                        }\n                        catch (NoSuchBeanDefinitionException ex) {\n                               。。。异常\n                        }\n                    }\n                }\n\n                // bean 实例化\n                // 单例模式\n                if (mbd.isSingleton()) {\n                    sharedInstance = getSingleton(beanName, () -&gt; {\n                        try {\n                            return createBean(beanName, mbd, args);\n                        }\n                        catch (BeansException ex) {\n                            // 显示从单利缓存中删除 bean 实例\n                            // 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它\n                            destroySingleton(beanName);\n                            throw ex;\n                        }\n                    });\n             bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n                }\n\n                // 原型模式\n                else if (mbd.isPrototype()) {\n                    // It&#39;s a prototype -&gt; create a new instance.\n                    Object prototypeInstance = null;\n                    try {\n                        beforePrototypeCreation(beanName);\n                        prototypeInstance = createBean(beanName, mbd, args);\n                    }\n                    finally {\n                        afterPrototypeCreation(beanName);\n                    }\n             bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n                }\n\n                else {\n                    // 从指定的 scope 下创建 bean\n                    String scopeName = mbd.getScope();\n                    final Scope scope = this.scopes.get(scopeName);\n                    if (scope == null) {\n                       。。。异常\n                    }\n                    try {\n                        Object scopedInstance = scope.get(beanName, () -&gt; {\n                            beforePrototypeCreation(beanName);\n                            try {\n                                return createBean(beanName, mbd, args);\n                            }\n                            finally {\n                                afterPrototypeCreation(beanName);\n                            }\n                        });\n         bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n                    }\n                    catch (IllegalStateException ex) {\n                       。。。。异常\n                    }\n                }\n            }\n            catch (BeansException ex) {\n                cleanupAfterBeanCreationFailure(beanName);\n                throw ex;\n            }\n        }\n\n        // 检查需要的类型是否符合 bean 的实际类型\n        if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {\n            try {\n          T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n                if (convertedBean == null) {\n                  。。。异常\n                }\n                return convertedBean;\n            }\n            catch (TypeMismatchException ex) {\n                if (logger.isDebugEnabled()) {\n                   。。日志\n                }\n               。。。异常\n            }\n        }\n        return (T) bean;\n    }\n</code></pre>\n<p>内部调用 <code>doGetBean()</code> 方法，<code>doGetBean()</code> 的代码量比较多，从这里就可以看出 bean 的加载过程是一个非常复杂的过程，会涉及到各种各样的情况处理。<code>doGetBean()</code> 可以分为以下几个过程。</p>\n<ol>\n<li>转换 beanName。因为我们调用 <code>getBean()</code> 方法传入的 name 并不一定就是 beanName，可以传入 aliasName，FactoryBean，所以这里需要进行简单的转换过程。</li>\n<li>尝试从缓存中加载单例 bean。</li>\n<li>bean 的实例化。</li>\n<li>原型模式的依赖检查。因为 Spring 只会解决单例模式的循环依赖，对于原型模式的循环依赖都是直接抛出 BeanCurrentlyInCreationException 异常。</li>\n<li>尝试从 parentBeanFactory 获取 bean 实例。如果 <code>parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)</code> 则尝试从 parentBeanFactory 中获取 bean 实例对象，因为 <code>!containsBeanDefinition(beanName)</code> 就意味着定义的 xml 文件中没有 beanName 相应的配置，这个时候就只能从 parentBeanFactory 中获取。</li>\n<li>获取 RootBeanDefinition，并对其进行合并检查。从缓存中获取已经解析的 RootBeanDefinition，同时如果父类不为 null 的话，则会合并父类的属性。</li>\n<li>依赖检查。某个 bean 依赖其他 bean ，则需要先加载依赖的 bean。</li>\n<li>对不同的 scope 进行处理。</li>\n<li>类型转换处理。如果传递的 requiredType 不为 null，则需要检测所得到 bean 的类型是否与该 requiredType 一致，如果不一致则尝试转换，当然也要能够转换成功，否则抛出 BeanNotOfRequiredTypeException 异常。</li>\n</ol>\n<p>下面就以下几个方面进行阐述，说明 Spring bean 的加载过程。</p>\n<ol>\n<li>从缓存中获取 bean</li>\n<li>创建 bean 实例对象</li>\n<li>从 bean 实例中获取对象</li>\n</ol>\n<h2 id=\"从缓存中获取-bean\"><a href=\"#从缓存中获取-bean\" class=\"headerlink\" title=\"从缓存中获取 bean\"></a>从缓存中获取 bean</h2><p>Spring 中根据 scope 可以将 bean 分为以下几类：singleton、prototype 和 其他，这样分的原因在于 Spring 在对不同 scope 处理的时候是这么处理的。</p>\n<ul>\n<li>singleton：在 Spring 的 IoC 容器中只存在一个对象实例，所有该对象的引用都共享这个实例。Spring 容器只会创建该 bean 定义的唯一实例，这个实例会被保存到缓存中，并且对该bean的所有后续请求和引用都将返回该缓存中的对象实例。</li>\n<li>prototype：每次对该bean的请求都会创建一个新的实例</li>\n<li>其他：其他包括 request、session、global session：<ul>\n<li>request：每次 http 请求将会有各自的 bean 实例。</li>\n<li>session：在一个 http session 中，一个 bean 定义对应一个 bean 实例。</li>\n<li>global session：在一个全局的 http session 中，一个 bean 定义对应一个 bean 实例。</li>\n</ul>\n</li>\n</ul>\n<p>所以从缓存中获取的 bean 一定是 singleton bean，这也是 Spring 为何只解决 singleton bean 的循环依赖。调用 <code>getSingleton()</code> 从缓存中获取 singleton bean。</p>\n<pre><code class=\"java\">public Object getSingleton(String beanName) {\n    return getSingleton(beanName, true);\n}\n\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    Object singletonObject = this.singletonObjects.get(beanName);\n    if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {\n        synchronized (this.singletonObjects) {\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null &amp;&amp; allowEarlyReference) {\n                ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    singletonObject = singletonFactory.getObject();\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return singletonObject;\n}\n</code></pre>\n<p><code>getSingleton()</code> 就是从 singletonObjects、earlySingletonObjects、 singletonFactories 三个缓存中获取，这里也是 Spring 解决 bean 循环依赖的关键之处。</p>\n<h2 id=\"创建-bean-实例对象\"><a href=\"#创建-bean-实例对象\" class=\"headerlink\" title=\"创建 bean 实例对象\"></a>创建 bean 实例对象</h2><p>如果缓存中没有，也没有 parentBeanFactory ，则会调用 <code>createBean()</code> 创建 bean 实例，该方法主要是在处理不同 scope 的 bean 的时候进行调用。</p>\n<pre><code class=\"java\">protected abstract Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n            throws BeanCreationException\n</code></pre>\n<p>该方法是定义在 AbstractBeanFactory 中的虚拟方法，其含义是根据给定的 BeanDefinition 和 args实例化一个 bean 对象，如果该 BeanDefinition 存在父类，则该 BeanDefinition 已经合并了父类的属性。所有 Bean 实例的创建都会委托给该方法实现。</p>\n<p>方法接受三个参数：</p>\n<ul>\n<li>beanName：bean 的名字</li>\n<li>mbd：已经合并了父类属性的（如果有的话）BeanDefinition</li>\n<li>args：用于构造函数或者工厂方法创建 bean 实例对象的参数</li>\n</ul>\n<p>该抽象方法的默认实现是在类 AbstractAutowireCapableBeanFactory 中实现，该方法其实只是做一些检查和验证工作，真正的初始化工作是由 <code>doCreateBean()</code> 实现，如下：</p>\n<pre><code class=\"java\">   protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n            throws BeanCreationException {\n\n        // BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装bean的属性描述器\n        BeanWrapper instanceWrapper = null;\n        // 单例模型，则从未完成的 FactoryBean 缓存中删除\n        if (mbd.isSingleton()) {anceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n        }\n\n        // 使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化\n        if (instanceWrapper == null) {\n            instanceWrapper = createBeanInstance(beanName, mbd, args);\n        }\n\n        // 包装的实例对象\n        final Object bean = instanceWrapper.getWrappedInstance();\n        // 包装的实例对象的类型\n        Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();\n        if (beanType != NullBean.class) {\n            mbd.resolvedTargetType = beanType;\n        }\n\n        // 检测是否有后置处理\n        // 如果有后置处理，则允许后置处理修改 BeanDefinition\n        synchronized (mbd.postProcessingLock) {\n            if (!mbd.postProcessed) {\n                try {\n                    // applyMergedBeanDefinitionPostProcessors\n                    // 后置处理修改 BeanDefinition\n                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                            &quot;Post-processing of merged bean definition failed&quot;, ex);\n                }\n                mbd.postProcessed = true;\n            }\n        }\n\n        // 解决单例模式的循环依赖\n        // 单例模式 &amp; 运行循环依赖&amp;当前单例 bean 是否正在被创建\n        boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;\n                isSingletonCurrentlyInCreation(beanName));\n        if (earlySingletonExposure) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +\n                        &quot;&#39; to allow for resolving potential circular references&quot;);\n            }\n            // 提前将创建的 bean 实例加入到ectFactory 中\n            // 这里是为了后期避免循环依赖\n            addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n        }\n\n        /*\n         * 开始初始化 bean 实例对象\n         */\n        Object exposedObject = bean;\n        try {\n            // 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性\n            // 则会递归初始依赖 bean\n            populateBean(beanName, mbd, instanceWrapper);\n            // 调用初始化方法\n            exposedObject = initializeBean(beanName, exposedObject, mbd);\n        }\n        catch (Throwable ex) {\n            if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {\n                throw (BeanCreationException) ex;\n            }\n            else {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);\n            }\n        }\n\n        /**\n         * 循环依赖处理\n         */\n        if (earlySingletonExposure) {\n            // 获取 earlySingletonReference\n            Object earlySingletonReference = getSingleton(beanName, false);\n            // 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空\n            if (earlySingletonReference != null) {\n                // 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强\n                if (exposedObject == bean) {\n                    exposedObject = earlySingletonReference;\n                }\n                // 处理依赖\n                else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {\n                    String[] dependentBeans = getDependentBeans(beanName);\n                    Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);\n                    for (String dependentBean : dependentBeans) {\n                        if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                            actualDependentBeans.add(dependentBean);\n                        }\n                    }\n                    if (!actualDependentBeans.isEmpty()) {\n                       。。。异常\n                    }\n                }\n            }\n        }\n        try {\n            // 注册 bean\n            registerDisposableBeanIfNecessary(beanName, bean, mbd);\n        }\n        catch (BeanDefinitionValidationException ex) {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);\n        }\n\n        return exposedObject;\n    }\n</code></pre>\n<p><code>doCreateBean()</code> 是创建 bean 实例的核心方法，它的整体思路是：</p>\n<ol>\n<li>如果是单例模式，则清除 factoryBeanInstanceCache 缓存，同时返回 BeanWrapper 实例对象，当然如果存在。</li>\n<li>如果缓存中没有 BeanWrapper 或者不是单例模式，则调用 <code>createBeanInstance()</code> 实例化 bean，主要是将 BeanDefinition 转换为 BeanWrapper</li>\n<li>MergedBeanDefinitionPostProcessor 的应用</li>\n<li>单例模式的循环依赖处理</li>\n<li>调用 <code>populateBean()</code> 进行属性填充。将所有属性填充至 bean 的实例中</li>\n<li>调用 <code>initializeBean()</code> 初始化 bean</li>\n<li>依赖检查</li>\n<li>注册 DisposableBean</li>\n</ol>\n<h3 id=\"实例化-bean\"><a href=\"#实例化-bean\" class=\"headerlink\" title=\"实例化 bean\"></a>实例化 bean</h3><p>如果缓存中没有 BeanWrapper 实例对象或者该 bean 不是 singleton，则调用 <code>createBeanInstance()</code> 创建 bean 实例。该方法主要是根据参数 BeanDefinition、args[] 来调用构造函数实例化 bean 对象。过程较为复杂，如下：</p>\n<pre><code class=\"java\">   protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, \n                                            @Nullable Object[] args) {\n        // 解析 bean，将 bean 类名解析为 class 引用\n        Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);\n\n        if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) \n            &amp;&amp; !mbd.isNonPublicAccessAllowed()) {\n        。。。。异常\n        }\n\n        // 如果存在 Supplier 回调，则使用给定的回调方法初始化策略\n        Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();\n        if (instanceSupplier != null) {\n            return obtainFromSupplier(instanceSupplier, beanName);\n        }\n\n        // 如果工厂方法不为空，则使用工厂方法初始化策略\n        if (mbd.getFactoryMethodName() != null)  {\n            return instantiateUsingFactoryMethod(beanName, mbd, args);\n        }\n\n        boolean resolved = false;\n        boolean autowireNecessary = false;\n        if (args == null) {\n            // constructorArgumentLock 构造函数的常用锁\n            synchronized (mbd.constructorArgumentLock) {\n                // 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析\n                // 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制\n                if (mbd.resolvedConstructorOrFactoryMethod != null) {\n                    resolved = true;\n                    autowireNecessary = mbd.constructorArgumentsResolved;\n                }\n            }\n        }\n        // 已经解析好了，直接注入即可\n        if (resolved) {\n            // 自动注入，调用构造函数自动注入\n            if (autowireNecessary) {\n                return autowireConstructor(beanName, mbd, null, null);\n            }\n            else {\n                // 使用默认构造函数构造\n                return instantiateBean(beanName, mbd);\n            }\n        }\n\n        // 确定解析的构造函数\n        // 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor\n        Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n        if (ctors != null ||\n                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n                mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n            // 构造函数自动注入\n            return autowireConstructor(beanName, mbd, ctors, args);\n        }\n\n        //使用默认构造函数注入\n        return instantiateBean(beanName, mbd);\n    }\n</code></pre>\n<p>实例化 bean 是一个复杂的过程，其主要的逻辑为：</p>\n<ul>\n<li>如果存在 Supplier 回调，则调用 <code>obtainFromSupplier()</code> 进行初始化</li>\n<li>如果存在工厂方法，则使用工厂方法进行初始化</li>\n<li>首先判断缓存，如果缓存中存在，即已经解析过了，则直接使用已经解析了的，根据 constructorArgumentsResolved 参数来判断是使用构造函数自动注入还是默认构造函数</li>\n<li>如果缓存中没有，则需要先确定到底使用哪个构造函数来完成解析工作，因为一个类有多个构造函数，每个构造函数都有不同的构造参数，所以需要根据参数来锁定构造函数并完成初始化，如果存在参数则使用相应的带有参数的构造函数，否则使用默认构造函数。</li>\n</ul>\n<p>其实核心思想还是在于根据不同的情况执行不同的实例化策略，主要是包括如下四种策略：</p>\n<ol>\n<li>Supplier 回调</li>\n<li><code>instantiateUsingFactoryMethod()</code> 工厂方法初始化</li>\n<li><code>autowireConstructor()</code>，构造函数自动注入初始化</li>\n<li><code>instantiateBean()</code>，默认构造函数注入</li>\n</ol>\n<p>其实无论哪种策略，他们的实现逻辑都差不多：确定构造函数和构造方法，然后实例化。只不过相对于 Supplier 回调和默认构造函数注入而言，工厂方法初始化和构造函数自动注入初始化会比较复杂，因为他们构造函数和构造参数的不确定性，Spring 需要花大量的精力来确定构造函数和构造参数，如果确定了则好办，直接选择实例化策略即可。当然在实例化的时候会根据是否有需要覆盖或者动态替换掉的方法，因为存在覆盖或者织入的话需要创建动态代理将方法织入，这个时候就只能选择 CGLIB 的方式来实例化，否则直接利用反射的方式即可。</p>\n<h3 id=\"属性填充\"><a href=\"#属性填充\" class=\"headerlink\" title=\"属性填充\"></a>属性填充</h3><p>属性填充其实就是将 BeanDefinition 的属性值赋值给 BeanWrapper 实例对象的过程。在填充的过程需要根据注入的类型不同来区分是根据类型注入还是名字注入，当然在这个过程还会涉及循环依赖的问题的。</p>\n<pre><code class=\"java\">    protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n        // 没有实例化对象\n        if (bw == null) {\n            // 有属性抛出异常\n            if (mbd.hasPropertyValues()) {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);\n            }\n            else {\n                // 没有属性直接返回\n                return;\n            }\n        }\n\n        // 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会\n        boolean continueWithPropertyPopulation = true;\n\n        // bena 不是&quot;合成&quot;的，即未由应用程序本身定义\n        // 是否持有 InstantiationAwareBeanPostProcessor\n        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\n            // 迭代所有的 BeanPostProcessors\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                // 如果为 InstantiationAwareBeanPostProcessor\n                if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                    // 返回值为是否继续填充 bean\n                    // postProcessAfterInstantiation：如果应该在 bean上面设置属性则返回true，否则返回false\n                    // 一般情况下，应该是返回true，返回 false 的话，\n                    // 将会阻止在此 Bean 实例上调用任何后续的 InstantiationAwareBeanPostProcessor 实例。\n                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n                        continueWithPropertyPopulation = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // 如果后续处理器发出停止填充命令，则终止后续操作\n        if (!continueWithPropertyPopulation) {\n            return;\n        }\n\n        // bean 的属性值\n        PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n\n            // 将 PropertyValues 封装成 MutablePropertyValues 对象\n            // MutablePropertyValues 允许对属性进行简单的操作，\n            // 并提供构造函数以支持Map的深度复制和构造。\n            MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n            // 根据名称自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n                autowireByName(beanName, mbd, bw, newPvs);\n            }\n\n            // 根据类型自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n                autowireByType(beanName, mbd, bw, newPvs);\n            }\n\n            pvs = newPvs;\n        }\n\n        // 是否已经注册了 InstantiationAwareBeanPostProcessors\n        boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n        // 是否需要进行依赖检查\n        boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n        if (hasInstAwareBpps || needsDepCheck) {\n            if (pvs == null) {\n                pvs = mbd.getPropertyValues();\n            }\n\n            // 从 bw 对象中提取 PropertyDescriptor 结果集\n            // PropertyDescriptor：可以通过一对存取方法提取一个属性\n            PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n            if (hasInstAwareBpps) {\n                for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                    if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                        // 对所有需要依赖检查的属性进行后处理\n                        pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n                        if (pvs == null) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if (needsDepCheck) {\n                // 依赖检查，对应 depends-on 属性\n                checkDependencies(beanName, mbd, filteredPds, pvs);\n            }\n        }\n\n        if (pvs != null) {\n            // 将属性应用到 bean 中\n            applyPropertyValues(beanName, mbd, bw, pvs);\n        }\n    }\n</code></pre>\n<p>处理流程如下：</p>\n<ol>\n<li>根据 hasInstantiationAwareBeanPostProcessors 属性来判断是否需要在注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会，此过程可以控制 Spring 是否继续进行属性填充。</li>\n<li>根据注入类型的不同来判断是根据名称来自动注入（<code>autowireByName()</code>）还是根据类型来自动注入（<code>autowireByType()</code>），统一存入到 PropertyValues 中，PropertyValues 用于描述 bean 的属性。</li>\n<li>判断是否需要进行 BeanPostProcessor 和 依赖检测。</li>\n<li>将所有 PropertyValues 中的属性填充到 BeanWrapper 中。</li>\n</ol>\n<h3 id=\"初始化-bean\"><a href=\"#初始化-bean\" class=\"headerlink\" title=\"初始化 bean\"></a>初始化 bean</h3><p>初始化 bean 为 <code>createBean()</code> 的最后一个过程，该过程主要做三件事情：</p>\n<ol>\n<li>激活 Aware 方法</li>\n<li>后置处理器的应用</li>\n<li>激活自定义的 init 方法</li>\n</ol>\n<pre><code class=\"java\">    protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {\n        if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {\n                // 激活 Aware 方法\n                invokeAwareMethods(beanName, bean);\n                return null;\n            }, getAccessControlContext());\n        }\n        else {\n            // 对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware\n            invokeAwareMethods(beanName, bean);\n        }\n\n        Object wrappedBean = bean;\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 后处理器\n            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n        }\n\n        try {\n            // 激活用户自定义的 init 方法\n            invokeInitMethods(beanName, wrappedBean, mbd);\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(\n                    (mbd != null ? mbd.getResourceDescription() : null),\n                    beanName, &quot;Invocation of init method failed&quot;, ex);\n        }\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 后处理器\n            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n        }\n        return wrappedBean;\n    }\n</code></pre>\n<h2 id=\"从-bean-实例中获取对象\"><a href=\"#从-bean-实例中获取对象\" class=\"headerlink\" title=\"从 bean 实例中获取对象\"></a>从 bean 实例中获取对象</h2><p>无论是从单例缓存中获取的 bean 实例 还是通过 <code>createBean()</code> 创建的 bean 实例，最终都会调用 <code>getObjectForBeanInstance()</code> ，该方法是根据传入的 bean 实例获取对象，按照 Spring 的传统，该方法也只是做一些检测工作，真正的实现逻辑是委托给 <code>getObjectFromFactoryBean()</code> 实现。</p>\n<pre><code class=\"java\">   protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) {\n        // 为单例模式且缓存中存在\n        if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) {\n\n            synchronized (getSingletonMutex()) {\n                // 从缓存中获取指定的 factoryBean\n                Object object = this.factoryBeanObjectCache.get(beanName);\n\n                if (object == null) {\n                    // 为空，则从 FactoryBean 中获取对象\n                    object = doGetObjectFromFactoryBean(factory, beanName);\n\n                    // 从缓存中获取\n                    Object alreadyThere = this.factoryBeanObjectCache.get(beanName);\n                    // **我实在是不明白这里这么做的原因，这里是干嘛？？？**\n                    if (alreadyThere != null) {\n                        object = alreadyThere;\n                    }\n                    else {\n                        // 需要后续处理\n                        if (shouldPostProcess) {\n                            // 若该 bean 处于创建中，则返回非处理对象，而不是存储它\n                            if (isSingletonCurrentlyInCreation(beanName)) {\n                                return object;\n                            }\n                            // 前置处理\n                            beforeSingletonCreation(beanName);\n                            try {\n                                // 对从 FactoryBean 获取的对象进行后处理\n                                // 生成的对象将暴露给bean引用\n                                object = postProcessObjectFromFactoryBean(object, beanName);\n                            }\n                            catch (Throwable ex) {\n                                throw new BeanCreationException(beanName,\n                                        &quot;Post-processing of FactoryBean&#39;s singleton object failed&quot;, ex);\n                            }\n                            finally {\n                                // 后置处理\n                                afterSingletonCreation(beanName);\n                            }\n                        }\n                        // 缓存\n                        if (containsSingleton(beanName)) {\n                            this.factoryBeanObjectCache.put(beanName, object);\n                        }\n                    }\n                }\n                return object;\n            }\n        }\n        else {\n            // 非单例\n            Object object = doGetObjectFromFactoryBean(factory, beanName);\n            if (shouldPostProcess) {\n                try {\n                    object = postProcessObjectFromFactoryBean(object, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean&#39;s object failed&quot;, ex);\n                }\n            }\n            return object;\n        }\n    }\n</code></pre>\n<p>主要流程如下：</p>\n<ul>\n<li>若为单例且单例 bean 缓存中存在 beanName，则进行后续处理（跳转到下一步），否则则从 FactoryBean 中获取 bean 实例对象，如果接受后置处理，则调用 <code>postProcessObjectFromFactoryBean()</code> 进行后置处理。</li>\n<li>首先获取锁（其实我们在前面篇幅中发现了大量的同步锁，锁住的对象都是 this.singletonObjects， 主要是因为在单例模式中必须要保证全局唯一），然后从 factoryBeanObjectCache 缓存中获取实例对象 object，若 object 为空，则调用 <code>doGetObjectFromFactoryBean()</code> 方法从 FactoryBean 获取对象，其实内部就是调用 <code>FactoryBean.getObject()</code>。</li>\n<li>如果需要后续处理，则进行进一步处理，步骤如下：<ul>\n<li>若该 bean 处于创建中（isSingletonCurrentlyInCreation），则返回非处理对象，而不是存储它</li>\n<li>调用 <code>beforeSingletonCreation()</code> 进行创建之前的处理。默认实现将该 bean 标志为当前创建的。</li>\n<li>调用 <code>postProcessObjectFromFactoryBean()</code> 对从 FactoryBean 获取的 bean 实例对象进行后置处理，默认实现是按照原样直接返回，具体实现是在 AbstractAutowireCapableBeanFactory 中实现的，当然子类也可以重写它，比如应用后置处理</li>\n<li>调用 <code>afterSingletonCreation()</code> 进行创建 bean 之后的处理，默认实现是将该 bean 标记为不再在创建中。</li>\n</ul>\n</li>\n<li>最后加入到 FactoryBeans 缓存中。</li>\n</ul>\n<p>End!!!</p>\n<p>到这里，Spring 加载 bean 的整体过程都已经分析完毕了，详情请给位移步到以下链接：</p>\n<ol>\n<li><a href=\"https://taolove.top/posts/39/\">spring源码解析之 16 开启bean的加载</a></li>\n<li><a href=\"https://taolove.top/posts/42/\">spring源码解析之 17缓存中获取单例bean</a></li>\n<li><a href=\"https://taolove.top/posts/37/\">spring源码解析之 18parentBeanFactory 与依赖处理</a></li>\n<li><a href=\"https://taolove.top/posts/38/\">spring源码解析之 19 各Scope的创建</a></li>\n<li><a href=\"https://taolove.top/posts/43/\">spring源码解析之 20 开启bean的实例化进程</a></li>\n<li><a href=\"https://taolove.top/posts/40/\">spring源码解析之 21 实例化bean</a></li>\n<li><a href=\"https://taolove.top/posts/41/\">spring源码解析之 22构造函数实例化</a></li>\n<li><a href=\"https://taolove.top/posts/44/\">spring源码解析之 23属性填充</a></li>\n<li><a href=\"https://taolove.top/posts/45/\">spring源码解析之 24循环依赖处理</a></li>\n<li><a href=\"https://taolove.top/posts/46/\">spring源码解析之 25bean的初始化</a></li>\n<li><a href=\"https://taolove.top/posts/49/\">spring源码解析之 26深入分析Aware接口</a></li>\n<li><a href=\"https://taolove.top/posts/48/\">spring源码解析之 27深入分析BeanPostProcessor接口</a></li>\n<li><a href=\"https://taolove.top/posts/47/\">spring源码解析之 28深入分析InitializingBean 接口和 init-method</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在 Spring bean 解析篇深入分析了一个配置文件经历了哪些过程转变成了 BeanDefinition，但是这个 BeanDefinition 并不是我们真正想要的想要的 bean，因为它还仅仅只是承载了我们需要的目标 bean 的信息，从 BeanDefinition 到我们需要的目标还需要一个漫长的 bean 的初始化阶段，在Spring bean 实例化阶段已经详细分析了初始化 bean 的过程，所以这里做一个概括性的总结。</p>\n<p>bean 的初始化节点由第一次调用 <code>getBean()</code>(显式或者隐式)开启，所以我们从这个方法开始。<br>","more":"</p>\n<pre><code class=\"java\">    public Object getBean(String name) throws BeansException {\n        return doGetBean(name, null, null, false);\n    }\n\nprotected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,\n                              @Nullable final Object[] args, boolean typeCheckOnly)\n              throws BeansException {\n\n        // 获取 beanName，这里是一个转换动作，将 name 转换Wie beanName\n        final String beanName = transformedBeanName(name);\n        Object bean;\n\n        // 从缓存中或者实例工厂中获取 bean\n        // *** 这里会涉及到解决循环依赖 bean 的问题\n        Object sharedInstance = getSingleton(beanName);\n        if (sharedInstance != null &amp;&amp; args == null) {\n            if (logger.isDebugEnabled()) {\n                if (isSingletonCurrentlyInCreation(beanName)) {\n                  。。。。日志\n                }\n                else {\n                  。。。 日志\n                }\n            }\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n        }\n\n        else {\n\n            // 因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常\n            // **关于循环依赖后续会单独出文详细说明**\n            if (isPrototypeCurrentlyInCreation(beanName)) {\n                throw new BeanCurrentlyInCreationException(beanName);\n            }\n\n            // 如果容器中没有找到，则从父类容器中加载\n            BeanFactory parentBeanFactory = getParentBeanFactory();\n            if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n                String nameToLookup = originalBeanName(name);\n                if (parentBeanFactory instanceof AbstractBeanFactory) {\n                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                            nameToLookup, requiredType, args, typeCheckOnly);\n                }\n                else if (args != null) {\n                    return (T) parentBeanFactory.getBean(nameToLookup, args);\n                }\n                else {\n                    return parentBeanFactory.getBean(nameToLookup, requiredType);\n                }\n            }\n\n            // 如果不是仅仅做类型检查则是创建bean，这里需要记录\n            if (!typeCheckOnly) {\n                markBeanAsCreated(beanName);\n            }\n\n            try {\n    // 从容器中获取 beanName 相应的 GenericBeanDefinition，并将其转换为 RootBeanDefinition\n                final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\n                // 检查给定的合并的 BeanDefinition\n                checkMergedBeanDefinition(mbd, beanName, args);\n\n                // 处理所依赖的 bean\n                String[] dependsOn = mbd.getDependsOn();\n                if (dependsOn != null) {\n                    for (String dep : dependsOn) {\n                        // 若给定的依赖 bean 已经注册为依赖给定的b ean\n                        // 循环依赖的情况\n                        if (isDependent(beanName, dep)) {\n                             。。。异常\n                        }\n                        // 缓存依赖调用\n                        registerDependentBean(dep, beanName);\n                        try {\n                            getBean(dep);\n                        }\n                        catch (NoSuchBeanDefinitionException ex) {\n                               。。。异常\n                        }\n                    }\n                }\n\n                // bean 实例化\n                // 单例模式\n                if (mbd.isSingleton()) {\n                    sharedInstance = getSingleton(beanName, () -&gt; {\n                        try {\n                            return createBean(beanName, mbd, args);\n                        }\n                        catch (BeansException ex) {\n                            // 显示从单利缓存中删除 bean 实例\n                            // 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它\n                            destroySingleton(beanName);\n                            throw ex;\n                        }\n                    });\n             bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n                }\n\n                // 原型模式\n                else if (mbd.isPrototype()) {\n                    // It&#39;s a prototype -&gt; create a new instance.\n                    Object prototypeInstance = null;\n                    try {\n                        beforePrototypeCreation(beanName);\n                        prototypeInstance = createBean(beanName, mbd, args);\n                    }\n                    finally {\n                        afterPrototypeCreation(beanName);\n                    }\n             bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n                }\n\n                else {\n                    // 从指定的 scope 下创建 bean\n                    String scopeName = mbd.getScope();\n                    final Scope scope = this.scopes.get(scopeName);\n                    if (scope == null) {\n                       。。。异常\n                    }\n                    try {\n                        Object scopedInstance = scope.get(beanName, () -&gt; {\n                            beforePrototypeCreation(beanName);\n                            try {\n                                return createBean(beanName, mbd, args);\n                            }\n                            finally {\n                                afterPrototypeCreation(beanName);\n                            }\n                        });\n         bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n                    }\n                    catch (IllegalStateException ex) {\n                       。。。。异常\n                    }\n                }\n            }\n            catch (BeansException ex) {\n                cleanupAfterBeanCreationFailure(beanName);\n                throw ex;\n            }\n        }\n\n        // 检查需要的类型是否符合 bean 的实际类型\n        if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {\n            try {\n          T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n                if (convertedBean == null) {\n                  。。。异常\n                }\n                return convertedBean;\n            }\n            catch (TypeMismatchException ex) {\n                if (logger.isDebugEnabled()) {\n                   。。日志\n                }\n               。。。异常\n            }\n        }\n        return (T) bean;\n    }\n</code></pre>\n<p>内部调用 <code>doGetBean()</code> 方法，<code>doGetBean()</code> 的代码量比较多，从这里就可以看出 bean 的加载过程是一个非常复杂的过程，会涉及到各种各样的情况处理。<code>doGetBean()</code> 可以分为以下几个过程。</p>\n<ol>\n<li>转换 beanName。因为我们调用 <code>getBean()</code> 方法传入的 name 并不一定就是 beanName，可以传入 aliasName，FactoryBean，所以这里需要进行简单的转换过程。</li>\n<li>尝试从缓存中加载单例 bean。</li>\n<li>bean 的实例化。</li>\n<li>原型模式的依赖检查。因为 Spring 只会解决单例模式的循环依赖，对于原型模式的循环依赖都是直接抛出 BeanCurrentlyInCreationException 异常。</li>\n<li>尝试从 parentBeanFactory 获取 bean 实例。如果 <code>parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)</code> 则尝试从 parentBeanFactory 中获取 bean 实例对象，因为 <code>!containsBeanDefinition(beanName)</code> 就意味着定义的 xml 文件中没有 beanName 相应的配置，这个时候就只能从 parentBeanFactory 中获取。</li>\n<li>获取 RootBeanDefinition，并对其进行合并检查。从缓存中获取已经解析的 RootBeanDefinition，同时如果父类不为 null 的话，则会合并父类的属性。</li>\n<li>依赖检查。某个 bean 依赖其他 bean ，则需要先加载依赖的 bean。</li>\n<li>对不同的 scope 进行处理。</li>\n<li>类型转换处理。如果传递的 requiredType 不为 null，则需要检测所得到 bean 的类型是否与该 requiredType 一致，如果不一致则尝试转换，当然也要能够转换成功，否则抛出 BeanNotOfRequiredTypeException 异常。</li>\n</ol>\n<p>下面就以下几个方面进行阐述，说明 Spring bean 的加载过程。</p>\n<ol>\n<li>从缓存中获取 bean</li>\n<li>创建 bean 实例对象</li>\n<li>从 bean 实例中获取对象</li>\n</ol>\n<h2 id=\"从缓存中获取-bean\"><a href=\"#从缓存中获取-bean\" class=\"headerlink\" title=\"从缓存中获取 bean\"></a>从缓存中获取 bean</h2><p>Spring 中根据 scope 可以将 bean 分为以下几类：singleton、prototype 和 其他，这样分的原因在于 Spring 在对不同 scope 处理的时候是这么处理的。</p>\n<ul>\n<li>singleton：在 Spring 的 IoC 容器中只存在一个对象实例，所有该对象的引用都共享这个实例。Spring 容器只会创建该 bean 定义的唯一实例，这个实例会被保存到缓存中，并且对该bean的所有后续请求和引用都将返回该缓存中的对象实例。</li>\n<li>prototype：每次对该bean的请求都会创建一个新的实例</li>\n<li>其他：其他包括 request、session、global session：<ul>\n<li>request：每次 http 请求将会有各自的 bean 实例。</li>\n<li>session：在一个 http session 中，一个 bean 定义对应一个 bean 实例。</li>\n<li>global session：在一个全局的 http session 中，一个 bean 定义对应一个 bean 实例。</li>\n</ul>\n</li>\n</ul>\n<p>所以从缓存中获取的 bean 一定是 singleton bean，这也是 Spring 为何只解决 singleton bean 的循环依赖。调用 <code>getSingleton()</code> 从缓存中获取 singleton bean。</p>\n<pre><code class=\"java\">public Object getSingleton(String beanName) {\n    return getSingleton(beanName, true);\n}\n\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    Object singletonObject = this.singletonObjects.get(beanName);\n    if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {\n        synchronized (this.singletonObjects) {\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null &amp;&amp; allowEarlyReference) {\n                ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    singletonObject = singletonFactory.getObject();\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return singletonObject;\n}\n</code></pre>\n<p><code>getSingleton()</code> 就是从 singletonObjects、earlySingletonObjects、 singletonFactories 三个缓存中获取，这里也是 Spring 解决 bean 循环依赖的关键之处。</p>\n<h2 id=\"创建-bean-实例对象\"><a href=\"#创建-bean-实例对象\" class=\"headerlink\" title=\"创建 bean 实例对象\"></a>创建 bean 实例对象</h2><p>如果缓存中没有，也没有 parentBeanFactory ，则会调用 <code>createBean()</code> 创建 bean 实例，该方法主要是在处理不同 scope 的 bean 的时候进行调用。</p>\n<pre><code class=\"java\">protected abstract Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n            throws BeanCreationException\n</code></pre>\n<p>该方法是定义在 AbstractBeanFactory 中的虚拟方法，其含义是根据给定的 BeanDefinition 和 args实例化一个 bean 对象，如果该 BeanDefinition 存在父类，则该 BeanDefinition 已经合并了父类的属性。所有 Bean 实例的创建都会委托给该方法实现。</p>\n<p>方法接受三个参数：</p>\n<ul>\n<li>beanName：bean 的名字</li>\n<li>mbd：已经合并了父类属性的（如果有的话）BeanDefinition</li>\n<li>args：用于构造函数或者工厂方法创建 bean 实例对象的参数</li>\n</ul>\n<p>该抽象方法的默认实现是在类 AbstractAutowireCapableBeanFactory 中实现，该方法其实只是做一些检查和验证工作，真正的初始化工作是由 <code>doCreateBean()</code> 实现，如下：</p>\n<pre><code class=\"java\">   protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n            throws BeanCreationException {\n\n        // BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装bean的属性描述器\n        BeanWrapper instanceWrapper = null;\n        // 单例模型，则从未完成的 FactoryBean 缓存中删除\n        if (mbd.isSingleton()) {anceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n        }\n\n        // 使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化\n        if (instanceWrapper == null) {\n            instanceWrapper = createBeanInstance(beanName, mbd, args);\n        }\n\n        // 包装的实例对象\n        final Object bean = instanceWrapper.getWrappedInstance();\n        // 包装的实例对象的类型\n        Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();\n        if (beanType != NullBean.class) {\n            mbd.resolvedTargetType = beanType;\n        }\n\n        // 检测是否有后置处理\n        // 如果有后置处理，则允许后置处理修改 BeanDefinition\n        synchronized (mbd.postProcessingLock) {\n            if (!mbd.postProcessed) {\n                try {\n                    // applyMergedBeanDefinitionPostProcessors\n                    // 后置处理修改 BeanDefinition\n                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                            &quot;Post-processing of merged bean definition failed&quot;, ex);\n                }\n                mbd.postProcessed = true;\n            }\n        }\n\n        // 解决单例模式的循环依赖\n        // 单例模式 &amp; 运行循环依赖&amp;当前单例 bean 是否正在被创建\n        boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;\n                isSingletonCurrentlyInCreation(beanName));\n        if (earlySingletonExposure) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +\n                        &quot;&#39; to allow for resolving potential circular references&quot;);\n            }\n            // 提前将创建的 bean 实例加入到ectFactory 中\n            // 这里是为了后期避免循环依赖\n            addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n        }\n\n        /*\n         * 开始初始化 bean 实例对象\n         */\n        Object exposedObject = bean;\n        try {\n            // 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性\n            // 则会递归初始依赖 bean\n            populateBean(beanName, mbd, instanceWrapper);\n            // 调用初始化方法\n            exposedObject = initializeBean(beanName, exposedObject, mbd);\n        }\n        catch (Throwable ex) {\n            if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {\n                throw (BeanCreationException) ex;\n            }\n            else {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);\n            }\n        }\n\n        /**\n         * 循环依赖处理\n         */\n        if (earlySingletonExposure) {\n            // 获取 earlySingletonReference\n            Object earlySingletonReference = getSingleton(beanName, false);\n            // 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空\n            if (earlySingletonReference != null) {\n                // 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强\n                if (exposedObject == bean) {\n                    exposedObject = earlySingletonReference;\n                }\n                // 处理依赖\n                else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {\n                    String[] dependentBeans = getDependentBeans(beanName);\n                    Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);\n                    for (String dependentBean : dependentBeans) {\n                        if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                            actualDependentBeans.add(dependentBean);\n                        }\n                    }\n                    if (!actualDependentBeans.isEmpty()) {\n                       。。。异常\n                    }\n                }\n            }\n        }\n        try {\n            // 注册 bean\n            registerDisposableBeanIfNecessary(beanName, bean, mbd);\n        }\n        catch (BeanDefinitionValidationException ex) {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);\n        }\n\n        return exposedObject;\n    }\n</code></pre>\n<p><code>doCreateBean()</code> 是创建 bean 实例的核心方法，它的整体思路是：</p>\n<ol>\n<li>如果是单例模式，则清除 factoryBeanInstanceCache 缓存，同时返回 BeanWrapper 实例对象，当然如果存在。</li>\n<li>如果缓存中没有 BeanWrapper 或者不是单例模式，则调用 <code>createBeanInstance()</code> 实例化 bean，主要是将 BeanDefinition 转换为 BeanWrapper</li>\n<li>MergedBeanDefinitionPostProcessor 的应用</li>\n<li>单例模式的循环依赖处理</li>\n<li>调用 <code>populateBean()</code> 进行属性填充。将所有属性填充至 bean 的实例中</li>\n<li>调用 <code>initializeBean()</code> 初始化 bean</li>\n<li>依赖检查</li>\n<li>注册 DisposableBean</li>\n</ol>\n<h3 id=\"实例化-bean\"><a href=\"#实例化-bean\" class=\"headerlink\" title=\"实例化 bean\"></a>实例化 bean</h3><p>如果缓存中没有 BeanWrapper 实例对象或者该 bean 不是 singleton，则调用 <code>createBeanInstance()</code> 创建 bean 实例。该方法主要是根据参数 BeanDefinition、args[] 来调用构造函数实例化 bean 对象。过程较为复杂，如下：</p>\n<pre><code class=\"java\">   protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, \n                                            @Nullable Object[] args) {\n        // 解析 bean，将 bean 类名解析为 class 引用\n        Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);\n\n        if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) \n            &amp;&amp; !mbd.isNonPublicAccessAllowed()) {\n        。。。。异常\n        }\n\n        // 如果存在 Supplier 回调，则使用给定的回调方法初始化策略\n        Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();\n        if (instanceSupplier != null) {\n            return obtainFromSupplier(instanceSupplier, beanName);\n        }\n\n        // 如果工厂方法不为空，则使用工厂方法初始化策略\n        if (mbd.getFactoryMethodName() != null)  {\n            return instantiateUsingFactoryMethod(beanName, mbd, args);\n        }\n\n        boolean resolved = false;\n        boolean autowireNecessary = false;\n        if (args == null) {\n            // constructorArgumentLock 构造函数的常用锁\n            synchronized (mbd.constructorArgumentLock) {\n                // 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析\n                // 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制\n                if (mbd.resolvedConstructorOrFactoryMethod != null) {\n                    resolved = true;\n                    autowireNecessary = mbd.constructorArgumentsResolved;\n                }\n            }\n        }\n        // 已经解析好了，直接注入即可\n        if (resolved) {\n            // 自动注入，调用构造函数自动注入\n            if (autowireNecessary) {\n                return autowireConstructor(beanName, mbd, null, null);\n            }\n            else {\n                // 使用默认构造函数构造\n                return instantiateBean(beanName, mbd);\n            }\n        }\n\n        // 确定解析的构造函数\n        // 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor\n        Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n        if (ctors != null ||\n                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n                mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n            // 构造函数自动注入\n            return autowireConstructor(beanName, mbd, ctors, args);\n        }\n\n        //使用默认构造函数注入\n        return instantiateBean(beanName, mbd);\n    }\n</code></pre>\n<p>实例化 bean 是一个复杂的过程，其主要的逻辑为：</p>\n<ul>\n<li>如果存在 Supplier 回调，则调用 <code>obtainFromSupplier()</code> 进行初始化</li>\n<li>如果存在工厂方法，则使用工厂方法进行初始化</li>\n<li>首先判断缓存，如果缓存中存在，即已经解析过了，则直接使用已经解析了的，根据 constructorArgumentsResolved 参数来判断是使用构造函数自动注入还是默认构造函数</li>\n<li>如果缓存中没有，则需要先确定到底使用哪个构造函数来完成解析工作，因为一个类有多个构造函数，每个构造函数都有不同的构造参数，所以需要根据参数来锁定构造函数并完成初始化，如果存在参数则使用相应的带有参数的构造函数，否则使用默认构造函数。</li>\n</ul>\n<p>其实核心思想还是在于根据不同的情况执行不同的实例化策略，主要是包括如下四种策略：</p>\n<ol>\n<li>Supplier 回调</li>\n<li><code>instantiateUsingFactoryMethod()</code> 工厂方法初始化</li>\n<li><code>autowireConstructor()</code>，构造函数自动注入初始化</li>\n<li><code>instantiateBean()</code>，默认构造函数注入</li>\n</ol>\n<p>其实无论哪种策略，他们的实现逻辑都差不多：确定构造函数和构造方法，然后实例化。只不过相对于 Supplier 回调和默认构造函数注入而言，工厂方法初始化和构造函数自动注入初始化会比较复杂，因为他们构造函数和构造参数的不确定性，Spring 需要花大量的精力来确定构造函数和构造参数，如果确定了则好办，直接选择实例化策略即可。当然在实例化的时候会根据是否有需要覆盖或者动态替换掉的方法，因为存在覆盖或者织入的话需要创建动态代理将方法织入，这个时候就只能选择 CGLIB 的方式来实例化，否则直接利用反射的方式即可。</p>\n<h3 id=\"属性填充\"><a href=\"#属性填充\" class=\"headerlink\" title=\"属性填充\"></a>属性填充</h3><p>属性填充其实就是将 BeanDefinition 的属性值赋值给 BeanWrapper 实例对象的过程。在填充的过程需要根据注入的类型不同来区分是根据类型注入还是名字注入，当然在这个过程还会涉及循环依赖的问题的。</p>\n<pre><code class=\"java\">    protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n        // 没有实例化对象\n        if (bw == null) {\n            // 有属性抛出异常\n            if (mbd.hasPropertyValues()) {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);\n            }\n            else {\n                // 没有属性直接返回\n                return;\n            }\n        }\n\n        // 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会\n        boolean continueWithPropertyPopulation = true;\n\n        // bena 不是&quot;合成&quot;的，即未由应用程序本身定义\n        // 是否持有 InstantiationAwareBeanPostProcessor\n        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\n            // 迭代所有的 BeanPostProcessors\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                // 如果为 InstantiationAwareBeanPostProcessor\n                if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                    // 返回值为是否继续填充 bean\n                    // postProcessAfterInstantiation：如果应该在 bean上面设置属性则返回true，否则返回false\n                    // 一般情况下，应该是返回true，返回 false 的话，\n                    // 将会阻止在此 Bean 实例上调用任何后续的 InstantiationAwareBeanPostProcessor 实例。\n                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n                        continueWithPropertyPopulation = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // 如果后续处理器发出停止填充命令，则终止后续操作\n        if (!continueWithPropertyPopulation) {\n            return;\n        }\n\n        // bean 的属性值\n        PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n\n            // 将 PropertyValues 封装成 MutablePropertyValues 对象\n            // MutablePropertyValues 允许对属性进行简单的操作，\n            // 并提供构造函数以支持Map的深度复制和构造。\n            MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n            // 根据名称自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n                autowireByName(beanName, mbd, bw, newPvs);\n            }\n\n            // 根据类型自动注入\n            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n                autowireByType(beanName, mbd, bw, newPvs);\n            }\n\n            pvs = newPvs;\n        }\n\n        // 是否已经注册了 InstantiationAwareBeanPostProcessors\n        boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n        // 是否需要进行依赖检查\n        boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n        if (hasInstAwareBpps || needsDepCheck) {\n            if (pvs == null) {\n                pvs = mbd.getPropertyValues();\n            }\n\n            // 从 bw 对象中提取 PropertyDescriptor 结果集\n            // PropertyDescriptor：可以通过一对存取方法提取一个属性\n            PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n            if (hasInstAwareBpps) {\n                for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                    if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                        // 对所有需要依赖检查的属性进行后处理\n                        pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n                        if (pvs == null) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if (needsDepCheck) {\n                // 依赖检查，对应 depends-on 属性\n                checkDependencies(beanName, mbd, filteredPds, pvs);\n            }\n        }\n\n        if (pvs != null) {\n            // 将属性应用到 bean 中\n            applyPropertyValues(beanName, mbd, bw, pvs);\n        }\n    }\n</code></pre>\n<p>处理流程如下：</p>\n<ol>\n<li>根据 hasInstantiationAwareBeanPostProcessors 属性来判断是否需要在注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会，此过程可以控制 Spring 是否继续进行属性填充。</li>\n<li>根据注入类型的不同来判断是根据名称来自动注入（<code>autowireByName()</code>）还是根据类型来自动注入（<code>autowireByType()</code>），统一存入到 PropertyValues 中，PropertyValues 用于描述 bean 的属性。</li>\n<li>判断是否需要进行 BeanPostProcessor 和 依赖检测。</li>\n<li>将所有 PropertyValues 中的属性填充到 BeanWrapper 中。</li>\n</ol>\n<h3 id=\"初始化-bean\"><a href=\"#初始化-bean\" class=\"headerlink\" title=\"初始化 bean\"></a>初始化 bean</h3><p>初始化 bean 为 <code>createBean()</code> 的最后一个过程，该过程主要做三件事情：</p>\n<ol>\n<li>激活 Aware 方法</li>\n<li>后置处理器的应用</li>\n<li>激活自定义的 init 方法</li>\n</ol>\n<pre><code class=\"java\">    protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {\n        if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {\n                // 激活 Aware 方法\n                invokeAwareMethods(beanName, bean);\n                return null;\n            }, getAccessControlContext());\n        }\n        else {\n            // 对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware\n            invokeAwareMethods(beanName, bean);\n        }\n\n        Object wrappedBean = bean;\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 后处理器\n            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n        }\n\n        try {\n            // 激活用户自定义的 init 方法\n            invokeInitMethods(beanName, wrappedBean, mbd);\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(\n                    (mbd != null ? mbd.getResourceDescription() : null),\n                    beanName, &quot;Invocation of init method failed&quot;, ex);\n        }\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 后处理器\n            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n        }\n        return wrappedBean;\n    }\n</code></pre>\n<h2 id=\"从-bean-实例中获取对象\"><a href=\"#从-bean-实例中获取对象\" class=\"headerlink\" title=\"从 bean 实例中获取对象\"></a>从 bean 实例中获取对象</h2><p>无论是从单例缓存中获取的 bean 实例 还是通过 <code>createBean()</code> 创建的 bean 实例，最终都会调用 <code>getObjectForBeanInstance()</code> ，该方法是根据传入的 bean 实例获取对象，按照 Spring 的传统，该方法也只是做一些检测工作，真正的实现逻辑是委托给 <code>getObjectFromFactoryBean()</code> 实现。</p>\n<pre><code class=\"java\">   protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) {\n        // 为单例模式且缓存中存在\n        if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) {\n\n            synchronized (getSingletonMutex()) {\n                // 从缓存中获取指定的 factoryBean\n                Object object = this.factoryBeanObjectCache.get(beanName);\n\n                if (object == null) {\n                    // 为空，则从 FactoryBean 中获取对象\n                    object = doGetObjectFromFactoryBean(factory, beanName);\n\n                    // 从缓存中获取\n                    Object alreadyThere = this.factoryBeanObjectCache.get(beanName);\n                    // **我实在是不明白这里这么做的原因，这里是干嘛？？？**\n                    if (alreadyThere != null) {\n                        object = alreadyThere;\n                    }\n                    else {\n                        // 需要后续处理\n                        if (shouldPostProcess) {\n                            // 若该 bean 处于创建中，则返回非处理对象，而不是存储它\n                            if (isSingletonCurrentlyInCreation(beanName)) {\n                                return object;\n                            }\n                            // 前置处理\n                            beforeSingletonCreation(beanName);\n                            try {\n                                // 对从 FactoryBean 获取的对象进行后处理\n                                // 生成的对象将暴露给bean引用\n                                object = postProcessObjectFromFactoryBean(object, beanName);\n                            }\n                            catch (Throwable ex) {\n                                throw new BeanCreationException(beanName,\n                                        &quot;Post-processing of FactoryBean&#39;s singleton object failed&quot;, ex);\n                            }\n                            finally {\n                                // 后置处理\n                                afterSingletonCreation(beanName);\n                            }\n                        }\n                        // 缓存\n                        if (containsSingleton(beanName)) {\n                            this.factoryBeanObjectCache.put(beanName, object);\n                        }\n                    }\n                }\n                return object;\n            }\n        }\n        else {\n            // 非单例\n            Object object = doGetObjectFromFactoryBean(factory, beanName);\n            if (shouldPostProcess) {\n                try {\n                    object = postProcessObjectFromFactoryBean(object, beanName);\n                }\n                catch (Throwable ex) {\n                    throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean&#39;s object failed&quot;, ex);\n                }\n            }\n            return object;\n        }\n    }\n</code></pre>\n<p>主要流程如下：</p>\n<ul>\n<li>若为单例且单例 bean 缓存中存在 beanName，则进行后续处理（跳转到下一步），否则则从 FactoryBean 中获取 bean 实例对象，如果接受后置处理，则调用 <code>postProcessObjectFromFactoryBean()</code> 进行后置处理。</li>\n<li>首先获取锁（其实我们在前面篇幅中发现了大量的同步锁，锁住的对象都是 this.singletonObjects， 主要是因为在单例模式中必须要保证全局唯一），然后从 factoryBeanObjectCache 缓存中获取实例对象 object，若 object 为空，则调用 <code>doGetObjectFromFactoryBean()</code> 方法从 FactoryBean 获取对象，其实内部就是调用 <code>FactoryBean.getObject()</code>。</li>\n<li>如果需要后续处理，则进行进一步处理，步骤如下：<ul>\n<li>若该 bean 处于创建中（isSingletonCurrentlyInCreation），则返回非处理对象，而不是存储它</li>\n<li>调用 <code>beforeSingletonCreation()</code> 进行创建之前的处理。默认实现将该 bean 标志为当前创建的。</li>\n<li>调用 <code>postProcessObjectFromFactoryBean()</code> 对从 FactoryBean 获取的 bean 实例对象进行后置处理，默认实现是按照原样直接返回，具体实现是在 AbstractAutowireCapableBeanFactory 中实现的，当然子类也可以重写它，比如应用后置处理</li>\n<li>调用 <code>afterSingletonCreation()</code> 进行创建 bean 之后的处理，默认实现是将该 bean 标记为不再在创建中。</li>\n</ul>\n</li>\n<li>最后加入到 FactoryBeans 缓存中。</li>\n</ul>\n<p>End!!!</p>\n<p>到这里，Spring 加载 bean 的整体过程都已经分析完毕了，详情请给位移步到以下链接：</p>\n<ol>\n<li><a href=\"https://taolove.top/posts/39/\">spring源码解析之 16 开启bean的加载</a></li>\n<li><a href=\"https://taolove.top/posts/42/\">spring源码解析之 17缓存中获取单例bean</a></li>\n<li><a href=\"https://taolove.top/posts/37/\">spring源码解析之 18parentBeanFactory 与依赖处理</a></li>\n<li><a href=\"https://taolove.top/posts/38/\">spring源码解析之 19 各Scope的创建</a></li>\n<li><a href=\"https://taolove.top/posts/43/\">spring源码解析之 20 开启bean的实例化进程</a></li>\n<li><a href=\"https://taolove.top/posts/40/\">spring源码解析之 21 实例化bean</a></li>\n<li><a href=\"https://taolove.top/posts/41/\">spring源码解析之 22构造函数实例化</a></li>\n<li><a href=\"https://taolove.top/posts/44/\">spring源码解析之 23属性填充</a></li>\n<li><a href=\"https://taolove.top/posts/45/\">spring源码解析之 24循环依赖处理</a></li>\n<li><a href=\"https://taolove.top/posts/46/\">spring源码解析之 25bean的初始化</a></li>\n<li><a href=\"https://taolove.top/posts/49/\">spring源码解析之 26深入分析Aware接口</a></li>\n<li><a href=\"https://taolove.top/posts/48/\">spring源码解析之 27深入分析BeanPostProcessor接口</a></li>\n<li><a href=\"https://taolove.top/posts/47/\">spring源码解析之 28深入分析InitializingBean 接口和 init-method</a></li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjs9qovja00029q1u5lf1hmt9","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovjj000b9q1upnhaw355"},{"post_id":"cjs9qovjd00049q1uudgb33ld","category_id":"cjs9qovji00089q1uxzffgpo6","_id":"cjs9qovjk000f9q1u8cfk5h14"},{"post_id":"cjs9qovjh00079q1umfu8cn21","category_id":"cjs9qovjj000c9q1uck9ppukv","_id":"cjs9qovjl000h9q1uatq8m5vv"},{"post_id":"cjs9qovp0000i9q1u6ps2l31f","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovp8000o9q1umi3cpi0l"},{"post_id":"cjs9qovp3000k9q1utu61m7dk","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovp9000r9q1url84ryuo"},{"post_id":"cjs9qovp6000m9q1ulocdchqo","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovpa000u9q1u2zlg0fn6"},{"post_id":"cjs9qovp7000n9q1uxhhtw6ug","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovpb000x9q1u4yoghg8c"},{"post_id":"cjs9qovp8000q9q1uaoxnrewp","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovpc00109q1upqm31dqh"},{"post_id":"cjs9qovp9000t9q1usbhuj4dj","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovpd00129q1upr4q3j09"},{"post_id":"cjs9qovpa000w9q1ud6jt5mt2","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovpg00159q1ujqb7n16l"},{"post_id":"cjs9qovpb000z9q1u83nnpp1i","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovpg00179q1u9uk0euzy"},{"post_id":"cjs9qovpc00119q1uryousl6k","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovph001a9q1uwapf8uou"},{"post_id":"cjs9qovpf00149q1uiyfpsjmy","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovpi001c9q1u8jru16dk"},{"post_id":"cjs9qovqk00219q1uh2oiu2s0","category_id":"cjs9qovjj000c9q1uck9ppukv","_id":"cjs9qovqz00279q1ub5xvo2ut"},{"post_id":"cjs9qovqv00229q1uglyyn02q","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovr1002a9q1u164uilk5"},{"post_id":"cjs9qovqw00249q1uanngac00","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovr2002c9q1ucfy00lsg"},{"post_id":"cjs9qovqy00269q1uqj249d33","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovr3002e9q1uxswnfr73"},{"post_id":"cjs9qovr000299q1u3pczvjg6","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovr3002f9q1upphqapz8"},{"post_id":"cjs9qovs9002g9q1uc52mtywo","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovsc002k9q1uslkpxb34"},{"post_id":"cjs9qovsa002h9q1u35kwbys4","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovsc002m9q1um4owov5f"},{"post_id":"cjs9qovsb002j9q1u95ohgy15","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovsd002p9q1ulh9310jr"},{"post_id":"cjs9qovt9002v9q1uc7dvaoga","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovtd00319q1up9yha3f1"},{"post_id":"cjs9qovta002w9q1uk0r6ke8v","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovte00349q1ugquvyc9v"},{"post_id":"cjs9qovtb002y9q1uu17i2h5f","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovtg00379q1uhz1ectjx"},{"post_id":"cjs9qovtc00309q1uuqlj4dj7","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovth003a9q1ucx9ww0n8"},{"post_id":"cjs9qovti003b9q1ubqy0rfte","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovtm003l9q1utmz0p1kz"},{"post_id":"cjs9qovte00339q1u2r3zzccj","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovtm003o9q1ue6a782w1"},{"post_id":"cjs9qovtj003e9q1uy2aoawld","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovtn003r9q1usxbawq5f"},{"post_id":"cjs9qovtk003h9q1uhdojyvrn","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovtn003t9q1unlgsdkxc"},{"post_id":"cjs9qovtf00369q1ul5dxxcpn","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovtn003w9q1u2u0lyi7n"},{"post_id":"cjs9qovtl003k9q1uok7akxoo","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovto003y9q1uzo2w4d6r"},{"post_id":"cjs9qovtg00399q1u2p1kncf8","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovto003z9q1uhwdmkor9"},{"post_id":"cjs9qovvx00419q1uh19q5o3b","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovw400479q1u9xzc31nt"},{"post_id":"cjs9qovvz00429q1uddpjad3l","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovw5004a9q1uaqoy9ia9"},{"post_id":"cjs9qovw100449q1u66tro3gy","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovw6004d9q1umvbpfpdk"},{"post_id":"cjs9qovw300469q1u1jxniz5i","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovw7004g9q1uo4412kul"},{"post_id":"cjs9qovw500499q1u2dveea58","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovw8004j9q1up6s09mie"},{"post_id":"cjs9qovw6004c9q1uib6n08f4","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovwb004m9q1upcc8pgc6"},{"post_id":"cjs9qovw7004f9q1uxlh3qtap","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovwd004p9q1u31iutnb2"},{"post_id":"cjs9qovw8004i9q1uj27dtyhr","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovwe004s9q1uz5loxvr0"},{"post_id":"cjs9qovw9004l9q1uy52mps1j","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovwg004w9q1uwgb1ewus"},{"post_id":"cjs9qovwb004o9q1u7trrvn1x","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovwi004z9q1ud4rtuw71"},{"post_id":"cjs9qovwd004r9q1ukh2nabpc","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovwj00529q1ucivnsacz"},{"post_id":"cjs9qovwf004v9q1u108ke3gp","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovwk00549q1ujq3dafll"},{"post_id":"cjs9qovwh004y9q1urb81arbd","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovwk00569q1ur67dbn4p"},{"post_id":"cjs9qovwi00519q1um6z576mb","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovwk00589q1ucsvecaw2"},{"post_id":"cjs9qovx2005c9q1ubqg5hnsr","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovx7005i9q1uigg62y6t"},{"post_id":"cjs9qovx3005d9q1u4n3rn4ca","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovx8005l9q1ubqfj0ne5"},{"post_id":"cjs9qovx5005f9q1up1xlvc80","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovx9005o9q1u6nbotbnq"},{"post_id":"cjs9qovx7005h9q1u9h42psnh","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovxa005r9q1uybhxyrhe"},{"post_id":"cjs9qovx8005k9q1u6dqgnonz","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovxb005t9q1uw19uwn9d"},{"post_id":"cjs9qovx9005n9q1uc3ls35go","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovxb005v9q1u7jtf83p2"},{"post_id":"cjs9qovxa005q9q1uqac42tc7","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovxc005x9q1uhobu99bd"},{"post_id":"cjs9qovxm005y9q1u88sfe0o8","category_id":"cjs9qovje00059q1u27yk1w4z","_id":"cjs9qovxp00639q1uv9yevjkh"},{"post_id":"cjs9qovxn005z9q1ududtzvuw","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovxp00659q1uh4qdp4cz"},{"post_id":"cjs9qovxo00619q1ug64acwy8","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovxr00679q1u29nyqef1"},{"post_id":"cjs9qovy100699q1u0wlzfd53","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovyb006d9q1u12ofn6se"},{"post_id":"cjs9qovy8006a9q1uaqkzdamh","category_id":"cjs9qovtg00389q1u632wr7rs","_id":"cjs9qovyb006e9q1uooive1er"}],"PostTag":[{"post_id":"cjs9qovja00029q1u5lf1hmt9","tag_id":"cjs9qovjg00069q1u2hbu73yp","_id":"cjs9qovjj000a9q1uu392sroj"},{"post_id":"cjs9qovjd00049q1uudgb33ld","tag_id":"cjs9qovji00099q1uwlydzqm5","_id":"cjs9qovjk000e9q1us5ai26zb"},{"post_id":"cjs9qovjh00079q1umfu8cn21","tag_id":"cjs9qovjk000d9q1umiu9guns","_id":"cjs9qovjk000g9q1u051estbx"},{"post_id":"cjs9qovp6000m9q1ulocdchqo","tag_id":"cjs9qovjg00069q1u2hbu73yp","_id":"cjs9qovp8000p9q1umuz59ihw"},{"post_id":"cjs9qovp8000q9q1uaoxnrewp","tag_id":"cjs9qovp5000l9q1ugfdk3nit","_id":"cjs9qovpa000v9q1un6gbjj1g"},{"post_id":"cjs9qovp0000i9q1u6ps2l31f","tag_id":"cjs9qovp5000l9q1ugfdk3nit","_id":"cjs9qovpg00169q1u8j6ofpl9"},{"post_id":"cjs9qovp0000i9q1u6ps2l31f","tag_id":"cjs9qovp9000s9q1ugjf31ih6","_id":"cjs9qovph00189q1u28n16zc0"},{"post_id":"cjs9qovp0000i9q1u6ps2l31f","tag_id":"cjs9qovpb000y9q1up66zwrjn","_id":"cjs9qovpi001b9q1ugtd2x5io"},{"post_id":"cjs9qovp3000k9q1utu61m7dk","tag_id":"cjs9qovp5000l9q1ugfdk3nit","_id":"cjs9qovpi001e9q1u0ho7bf4u"},{"post_id":"cjs9qovp3000k9q1utu61m7dk","tag_id":"cjs9qovp9000s9q1ugjf31ih6","_id":"cjs9qovpi001f9q1u4ixenxgt"},{"post_id":"cjs9qovp7000n9q1uxhhtw6ug","tag_id":"cjs9qovp5000l9q1ugfdk3nit","_id":"cjs9qovpj001i9q1uvm6wpcy1"},{"post_id":"cjs9qovp7000n9q1uxhhtw6ug","tag_id":"cjs9qovpi001d9q1ueo2197y6","_id":"cjs9qovpk001j9q1uxmrmj4ut"},{"post_id":"cjs9qovp7000n9q1uxhhtw6ug","tag_id":"cjs9qovpj001g9q1uwb69avt6","_id":"cjs9qovpk001l9q1u3lg0nhyk"},{"post_id":"cjs9qovp9000t9q1usbhuj4dj","tag_id":"cjs9qovpj001h9q1uamoynfm0","_id":"cjs9qovpk001m9q1u4d79t1go"},{"post_id":"cjs9qovpa000w9q1ud6jt5mt2","tag_id":"cjs9qovp5000l9q1ugfdk3nit","_id":"cjs9qovpl001o9q1u1gov3fa6"},{"post_id":"cjs9qovpa000w9q1ud6jt5mt2","tag_id":"cjs9qovpk001k9q1uxfmlx47v","_id":"cjs9qovpl001p9q1u82g9aeap"},{"post_id":"cjs9qovpb000z9q1u83nnpp1i","tag_id":"cjs9qovp5000l9q1ugfdk3nit","_id":"cjs9qovpm001r9q1uy0e3qrn8"},{"post_id":"cjs9qovpb000z9q1u83nnpp1i","tag_id":"cjs9qovpl001n9q1unoijnvjp","_id":"cjs9qovpn001s9q1u0efwy05m"},{"post_id":"cjs9qovpc00119q1uryousl6k","tag_id":"cjs9qovpi001d9q1ueo2197y6","_id":"cjs9qovpn001u9q1u8fsp3vqp"},{"post_id":"cjs9qovpf00149q1uiyfpsjmy","tag_id":"cjs9qovp5000l9q1ugfdk3nit","_id":"cjs9qovpo001x9q1u4hszpt7b"},{"post_id":"cjs9qovpf00149q1uiyfpsjmy","tag_id":"cjs9qovpn001t9q1uewa2sq93","_id":"cjs9qovpp001y9q1ul1o187fz"},{"post_id":"cjs9qovpf00149q1uiyfpsjmy","tag_id":"cjs9qovpo001v9q1uxt59hicc","_id":"cjs9qovpp001z9q1uumzvhbh2"},{"post_id":"cjs9qovpf00149q1uiyfpsjmy","tag_id":"cjs9qovpo001w9q1ukkfs6jef","_id":"cjs9qovpp00209q1u3kmkrlqx"},{"post_id":"cjs9qovqk00219q1uh2oiu2s0","tag_id":"cjs9qovjk000d9q1umiu9guns","_id":"cjs9qovqw00239q1u785lrluj"},{"post_id":"cjs9qovqv00229q1uglyyn02q","tag_id":"cjs9qovpi001d9q1ueo2197y6","_id":"cjs9qovqx00259q1ule1r5827"},{"post_id":"cjs9qovqw00249q1uanngac00","tag_id":"cjs9qovpj001h9q1uamoynfm0","_id":"cjs9qovqz00289q1uu49m6ld7"},{"post_id":"cjs9qovqy00269q1uqj249d33","tag_id":"cjs9qovpj001h9q1uamoynfm0","_id":"cjs9qovr2002b9q1u2pbsar3e"},{"post_id":"cjs9qovr000299q1u3pczvjg6","tag_id":"cjs9qovpj001h9q1uamoynfm0","_id":"cjs9qovr3002d9q1ubylv07qy"},{"post_id":"cjs9qovsb002j9q1u95ohgy15","tag_id":"cjs9qovpj001h9q1uamoynfm0","_id":"cjs9qovsc002l9q1ujt3ru6nw"},{"post_id":"cjs9qovs9002g9q1uc52mtywo","tag_id":"cjs9qovjg00069q1u2hbu73yp","_id":"cjs9qovsd002o9q1u23h5xxz0"},{"post_id":"cjs9qovs9002g9q1uc52mtywo","tag_id":"cjs9qovsb002i9q1uu2kg6768","_id":"cjs9qovsd002q9q1u5ft0nuaq"},{"post_id":"cjs9qovsa002h9q1u35kwbys4","tag_id":"cjs9qovjk000d9q1umiu9guns","_id":"cjs9qovsd002r9q1uvi9s53mp"},{"post_id":"cjs9qovsa002h9q1u35kwbys4","tag_id":"cjs9qovsc002n9q1u7krh19wk","_id":"cjs9qovsd002s9q1uo1u0ymcr"},{"post_id":"cjs9qovsa002h9q1u35kwbys4","tag_id":"cjs9qovjg00069q1u2hbu73yp","_id":"cjs9qovsd002t9q1u1k8c75ym"},{"post_id":"cjs9qovt9002v9q1uc7dvaoga","tag_id":"cjs9qovpj001h9q1uamoynfm0","_id":"cjs9qovtb002x9q1utdfr7u21"},{"post_id":"cjs9qovta002w9q1uk0r6ke8v","tag_id":"cjs9qovpj001h9q1uamoynfm0","_id":"cjs9qovtc002z9q1ucowxuihn"},{"post_id":"cjs9qovtb002y9q1uu17i2h5f","tag_id":"cjs9qovpj001h9q1uamoynfm0","_id":"cjs9qovte00329q1um6s91c2f"},{"post_id":"cjs9qovtc00309q1uuqlj4dj7","tag_id":"cjs9qovjg00069q1u2hbu73yp","_id":"cjs9qovtj003d9q1uk7o22xun"},{"post_id":"cjs9qovtc00309q1uuqlj4dj7","tag_id":"cjs9qovtf00359q1uhue3pxkn","_id":"cjs9qovtk003g9q1uzg4sfmrr"},{"post_id":"cjs9qovtj003e9q1uy2aoawld","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovtl003j9q1usf49cl79"},{"post_id":"cjs9qovte00339q1u2r3zzccj","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovtm003n9q1uql77as1u"},{"post_id":"cjs9qovtk003h9q1uhdojyvrn","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovtn003q9q1uptrto9uy"},{"post_id":"cjs9qovtl003k9q1uok7akxoo","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovtn003s9q1ulcdap7xu"},{"post_id":"cjs9qovtf00369q1ul5dxxcpn","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovtn003v9q1u947vqzaw"},{"post_id":"cjs9qovtg00399q1u2p1kncf8","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovto003x9q1ugaftnxxt"},{"post_id":"cjs9qovti003b9q1ubqy0rfte","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovto00409q1us45twhki"},{"post_id":"cjs9qovvx00419q1uh19q5o3b","tag_id":"cjs9qovjg00069q1u2hbu73yp","_id":"cjs9qovw100439q1u3xv8ik06"},{"post_id":"cjs9qovvx00419q1uh19q5o3b","tag_id":"cjs9qovtf00359q1uhue3pxkn","_id":"cjs9qovw300459q1u8bup96eh"},{"post_id":"cjs9qovvz00429q1uddpjad3l","tag_id":"cjs9qovtf00359q1uhue3pxkn","_id":"cjs9qovw500489q1u360jtdtn"},{"post_id":"cjs9qovvz00429q1uddpjad3l","tag_id":"cjs9qovjg00069q1u2hbu73yp","_id":"cjs9qovw6004b9q1unx476fqy"},{"post_id":"cjs9qovw100449q1u66tro3gy","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovw7004e9q1uy413q33o"},{"post_id":"cjs9qovw300469q1u1jxniz5i","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovw8004h9q1u3iptn3kt"},{"post_id":"cjs9qovw500499q1u2dveea58","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovw9004k9q1u8jupmst1"},{"post_id":"cjs9qovw6004c9q1uib6n08f4","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovwb004n9q1uigrzgf3l"},{"post_id":"cjs9qovw7004f9q1uxlh3qtap","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovwd004q9q1u87lt0rbm"},{"post_id":"cjs9qovw8004i9q1uj27dtyhr","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovwf004u9q1uuw16p612"},{"post_id":"cjs9qovw9004l9q1uy52mps1j","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovwh004x9q1u3qdmrqmm"},{"post_id":"cjs9qovwd004r9q1ukh2nabpc","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovwi00509q1uhdmhl5wg"},{"post_id":"cjs9qovwf004v9q1u108ke3gp","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovwj00539q1uaabrx7yk"},{"post_id":"cjs9qovwh004y9q1urb81arbd","tag_id":"cjs9qovwf004t9q1u81kbwcgk","_id":"cjs9qovwk00559q1u2as1a2z9"},{"post_id":"cjs9qovwh004y9q1urb81arbd","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovwk00579q1unp2ehto8"},{"post_id":"cjs9qovwb004o9q1u7trrvn1x","tag_id":"cjs9qovwf004t9q1u81kbwcgk","_id":"cjs9qovwk00599q1u4cts7xpb"},{"post_id":"cjs9qovwb004o9q1u7trrvn1x","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovwk005a9q1upya9d1ks"},{"post_id":"cjs9qovwi00519q1um6z576mb","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovwk005b9q1unr2y0rb6"},{"post_id":"cjs9qovx2005c9q1ubqg5hnsr","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovx5005e9q1ui014kl4q"},{"post_id":"cjs9qovx3005d9q1u4n3rn4ca","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovx6005g9q1usorx9a1a"},{"post_id":"cjs9qovx5005f9q1up1xlvc80","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovx8005j9q1u7fykhy3n"},{"post_id":"cjs9qovx7005h9q1u9h42psnh","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovx9005m9q1ugkhenl82"},{"post_id":"cjs9qovx8005k9q1u6dqgnonz","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovxa005p9q1uow9jvghl"},{"post_id":"cjs9qovx9005n9q1uc3ls35go","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovxb005s9q1umtw3bpic"},{"post_id":"cjs9qovx9005n9q1uc3ls35go","tag_id":"cjs9qovwf004t9q1u81kbwcgk","_id":"cjs9qovxb005u9q1ur65ggwds"},{"post_id":"cjs9qovxa005q9q1uqac42tc7","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovxb005w9q1ur8g9l9m5"},{"post_id":"cjs9qovxm005y9q1u88sfe0o8","tag_id":"cjs9qovjg00069q1u2hbu73yp","_id":"cjs9qovxo00609q1um2o44dob"},{"post_id":"cjs9qovxm005y9q1u88sfe0o8","tag_id":"cjs9qovtf00359q1uhue3pxkn","_id":"cjs9qovxp00629q1uic6q1oj5"},{"post_id":"cjs9qovxn005z9q1ududtzvuw","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovxp00649q1ulqkbf3ea"},{"post_id":"cjs9qovxo00619q1ug64acwy8","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovxq00669q1umzcjazom"},{"post_id":"cjs9qovxo00619q1ug64acwy8","tag_id":"cjs9qovwf004t9q1u81kbwcgk","_id":"cjs9qovxr00689q1u5a20o698"},{"post_id":"cjs9qovy100699q1u0wlzfd53","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovya006b9q1uky3ivfiq"},{"post_id":"cjs9qovy8006a9q1uaqkzdamh","tag_id":"cjs9qovti003c9q1udyqm1t20","_id":"cjs9qovyb006c9q1ue6xamoor"}],"Tag":[{"name":"JUC","_id":"cjs9qovjg00069q1u2hbu73yp"},{"name":"博客建站","_id":"cjs9qovji00099q1uwlydzqm5"},{"name":"操作系统","_id":"cjs9qovjk000d9q1umiu9guns"},{"name":"java","_id":"cjs9qovp5000l9q1ugfdk3nit"},{"name":"java引用","_id":"cjs9qovp9000s9q1ugjf31ih6"},{"name":"JVM","_id":"cjs9qovpb000y9q1up66zwrjn"},{"name":"java基础","_id":"cjs9qovpi001d9q1ueo2197y6"},{"name":"String","_id":"cjs9qovpj001g9q1uwb69avt6"},{"name":"多线程","_id":"cjs9qovpj001h9q1uamoynfm0"},{"name":"jar","_id":"cjs9qovpk001k9q1uxfmlx47v"},{"name":"泛型","_id":"cjs9qovpl001n9q1unoijnvjp"},{"name":"并发","_id":"cjs9qovpn001t9q1uewa2sq93"},{"name":"线程","_id":"cjs9qovpo001v9q1uxt59hicc"},{"name":"thread","_id":"cjs9qovpo001w9q1ukkfs6jef"},{"name":"Future","_id":"cjs9qovsb002i9q1uu2kg6768"},{"name":"自旋锁","_id":"cjs9qovsc002n9q1u7krh19wk"},{"name":"线程池","_id":"cjs9qovtf00359q1uhue3pxkn"},{"name":"spring源码解析","_id":"cjs9qovti003c9q1udyqm1t20"},{"name":"spring","_id":"cjs9qovwf004t9q1u81kbwcgk"}]}}