{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-apollo.js","path":"plugins/prettify/lang-apollo.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-clj.js","path":"plugins/prettify/lang-clj.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-dart.js","path":"plugins/prettify/lang-dart.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-css.js","path":"plugins/prettify/lang-css.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-go.js","path":"plugins/prettify/lang-go.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-ex.js","path":"plugins/prettify/lang-ex.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-kotlin.js","path":"plugins/prettify/lang-kotlin.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-hs.js","path":"plugins/prettify/lang-hs.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-lasso.js","path":"plugins/prettify/lang-lasso.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-lisp.js","path":"plugins/prettify/lang-lisp.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-llvm.js","path":"plugins/prettify/lang-llvm.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-logtalk.js","path":"plugins/prettify/lang-logtalk.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-lua.js","path":"plugins/prettify/lang-lua.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-matlab.js","path":"plugins/prettify/lang-matlab.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-ml.js","path":"plugins/prettify/lang-ml.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-mumps.js","path":"plugins/prettify/lang-mumps.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-n.js","path":"plugins/prettify/lang-n.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-pascal.js","path":"plugins/prettify/lang-pascal.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-proto.js","path":"plugins/prettify/lang-proto.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-r.js","path":"plugins/prettify/lang-r.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-rd.js","path":"plugins/prettify/lang-rd.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-rust.js","path":"plugins/prettify/lang-rust.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-scala.js","path":"plugins/prettify/lang-scala.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-sql.js","path":"plugins/prettify/lang-sql.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-swift.js","path":"plugins/prettify/lang-swift.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-tex.js","path":"plugins/prettify/lang-tex.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-tcl.js","path":"plugins/prettify/lang-tcl.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-vb.js","path":"plugins/prettify/lang-vb.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-vhdl.js","path":"plugins/prettify/lang-vhdl.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-wiki.js","path":"plugins/prettify/lang-wiki.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-yaml.js","path":"plugins/prettify/lang-yaml.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-xq.js","path":"plugins/prettify/lang-xq.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/prettify.css","path":"plugins/prettify/prettify.css","modified":0,"renderable":0},{"_id":"source/plugins/prettify/node_prettify.js","path":"plugins/prettify/node_prettify.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/prettify.js","path":"plugins/prettify/prettify.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-erlang.js","path":"plugins/prettify/lang-erlang.js","modified":0,"renderable":0},{"_id":"source/plugins/prettify/lang-basic.js","path":"plugins/prettify/lang-basic.js","modified":0,"renderable":0},{"_id":"source/uploads/img/avatar.jpg","path":"uploads/img/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"source/images/pasted-0.png","path":"images/pasted-0.png","modified":0,"renderable":0},{"_id":"source/plugins/prettify/run_prettify.js","path":"plugins/prettify/run_prettify.js","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"67eace04f455693e83d285fe828a7d08f67e5e0b","modified":1546583262575},{"_id":"themes/next/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1545973610843},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1545966551750},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1545966551751},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1545966551752},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1545966551752},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1545966606782},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1545966551752},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1545966551752},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1545966646627},{"_id":"themes/next/README.md","hash":"898213e66d34a46c3cf8446bf693bd50db0d3269","modified":1545966646628},{"_id":"themes/next/_config.yml","hash":"827a5d9da717140b2e22eae0f3190c538691471f","modified":1545986082688},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1545966606784},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1545966551753},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1545966606795},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1545966551750},{"_id":"source/CNAME","hash":"c3ddb78d56d8afb1de43766a962b58378cd300c2","modified":1545966351620},{"_id":"source/_discarded/String、StringBuffer和StringBuilder对比.md","hash":"1b11dc203cdda7a8b1683e485fde9c17a947447d","modified":1546407478760},{"_id":"source/_discarded/测试视频.md","hash":"7dac0e72398556690c1f694c6589b22e06111a78","modified":1546407478761},{"_id":"source/_discarded/hello-world.md","hash":"202a20f1ba49668b3709f06599583a8d017be807","modified":1545980330760},{"_id":"source/_posts/ java多线程系列-JUC线程池之02 ThreadPoolExecutor 线程池的创建.md","hash":"50e3cd94f6e9d97fc049a7dacb61f52868162de6","modified":1546566539313},{"_id":"source/_posts/.DS_Store","hash":"712350a80ef9fb11b59ac4ded928b87bb0fc84fd","modified":1546568643206},{"_id":"source/_posts/JVM源码分析之-FinalReference完全解读.md","hash":"47b4be00797b9f2174ee7561177a83d337872f08","modified":1546583698463},{"_id":"source/_posts/JAVA NIO之浅谈内存映射文件原理与DirectBuffer.md","hash":"593910a1bbea31317c457c938fa13391becca2d5","modified":1546566539314},{"_id":"source/_posts/Java-Reference详解.md","hash":"565f0ae5fba426cf0b6499ceb836ec37b7d93f16","modified":1546581730666},{"_id":"source/_posts/LockSupport.md","hash":"d0b36bacc3daf04a11ff03d094778022fa60a545","modified":1546566539316},{"_id":"source/_posts/Random 与 ThreadLocalRandom 对比.md","hash":"5dfe46698a86596894a91866bdd84509a806d9fb","modified":1546567138210},{"_id":"source/_posts/java 多线系列之 04 线程让步和join.md","hash":"139e07004fddbb1529b76bce342b80182e4090c1","modified":1546566539318},{"_id":"source/_posts/String、StringBuffer和StringBuilder对比.md","hash":"4d98b5de2adc7c15400ec28b78a6b8fa2a1f164e","modified":1546408219800},{"_id":"source/_posts/java多线程系列 01基本概念以及实现方式.md","hash":"56486ee9797cd0cd41e2501a77a53b708fdab160","modified":1546566539319},{"_id":"source/_posts/java多线程系列 02 synchronized 关键字.md","hash":"a5621376d58d8f4439eca366bbf092ae17b90626","modified":1546566539319},{"_id":"source/_posts/java多线程系列 03 线程等待与唤醒，线程休眠.md","hash":"cfa3f6809c9ddfbba436dff4e6140f168f2977a3","modified":1546566539320},{"_id":"source/_posts/java多线程系列 06  线程优先级和守护线程.md","hash":"adab1c73be57112e4ad4a588b7113e3b3dbd84c9","modified":1546566539321},{"_id":"source/_posts/java多线程系列 05 interrupt()和线程终止方式.md","hash":"faa7f0842b19076d00db49626c9de8093a1e7422","modified":1546566539320},{"_id":"source/_posts/java多线程系列 07 ThreadGroup.md","hash":"c2e4db8af80f755cee4d9be51fa4360cc98c5446","modified":1546566539321},{"_id":"source/_posts/java多线程系列-JUC线程池之 01 线程池架构.md","hash":"22d3b60fb526cb88fe29427393881c57c77d201b","modified":1546568307930},{"_id":"source/_posts/java多线程系列-JUC线程池之02 ThreadPoolExecutor源码分析.md","hash":"9cd2a0d4178233bd854429467952b8ecbcf52356","modified":1546566539322},{"_id":"source/_posts/java多线程系列之 08 ThreadLocal.md","hash":"f43f7fbad98b1953aef7351ab38c59a0dcd72a20","modified":1546566539323},{"_id":"source/_posts/java多线程系列-JUC线程池之04 Future 和Callable.md","hash":"4aca500f42aa1d5914c8269629d8f7d9460d47df","modified":1546566539323},{"_id":"source/_posts/伪缓存.md","hash":"f4989799c66406b17281669213a73763d60461cc","modified":1546566539324},{"_id":"source/_posts/super 和 extends.md","hash":"ef4e3b8819bc6df90919b8a0306437ca03147548","modified":1546566539323},{"_id":"source/_posts/使用-Travis-CI-自动更新-GitHub-Pages.md","hash":"2b2d6c9e1fc85df1e37c545fc1ca453df54205f9","modified":1546408219800},{"_id":"source/_posts/内部类.md","hash":"f5cdb480428dee2d28f0a60ceb2d4f784f65531d","modified":1546566539324},{"_id":"source/_posts/枚举初探.md","hash":"d3ec01acfad646892338f9a65f5e11b5225aad80","modified":1546566539324},{"_id":"source/_posts/深入分析ThreadLocal.md","hash":"ed44507140a354073aa885a8c6ddc887e37c159e","modified":1546407478763},{"_id":"source/_posts/自旋锁.md","hash":"ec8828c5884a7d672f8219f01d1d6a2402c4cf2f","modified":1546408219801},{"_id":"source/_posts/虚拟内存.md","hash":"5ffdc674283cdab3b00b425203f4b35b57d05686","modified":1546566539325},{"_id":"source/about/index.html","hash":"3da0683d9fac971c9072a727a6d6623b12890669","modified":1546407478764},{"_id":"source/categories/index.md","hash":"79cd584ef9d28b5afbd1836b345ab5648d6f7fed","modified":1545980134150},{"_id":"source/tags/index.md","hash":"de2c4bea11d42170dabebd5ecfc7551e86759c4b","modified":1545980134151},{"_id":"source/_discarded/test.md","hash":"5f80c6aa2e6352ee670d73cf2e422320f0555223","modified":1546408219798},{"_id":"source/_posts/java 中 Iterator 和 Iterable 区别.md","hash":"331874f7332733ce0ccf7c782e14508d1c091509","modified":1546566539318},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1545966606785},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1545966606785},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1545966606785},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1545966606786},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1545966606785},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1545966606786},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1545966606786},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1545966606787},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1545966606787},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1545966606787},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1545966606788},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1545966606788},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1545966606788},{"_id":"themes/next/languages/zh-Hans.yml","hash":"abd5fa390c921edeee4040efd67dcc44ed6611c9","modified":1545980134152},{"_id":"themes/next/layout/_layout.swig","hash":"7b85148217a7842bef981c89f540af5cedaee713","modified":1546583585978},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1545966551770},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1545966606794},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1545966606794},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1545966606794},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1545966606795},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1545966551771},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1545966606795},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1545966551771},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1545966551772},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1545966551846},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1545966551846},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1545966551846},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1545966606786},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1545966606787},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551798},{"_id":"source/plugins/prettify/lang-apollo.js","hash":"e19c633557b10eab4daad0c2586b3ecb44937ba3","modified":1546581093403},{"_id":"source/plugins/prettify/lang-clj.js","hash":"fff2857ba9919e7a2e8b61b08f1b87be41ed3a46","modified":1546581093404},{"_id":"source/plugins/prettify/lang-dart.js","hash":"34c6c4897cf7d22e230ff9db55f2821c5eddbca8","modified":1546581093404},{"_id":"source/plugins/prettify/lang-css.js","hash":"9df3f79343a2104339e5c3ab9d94a39c0291b37b","modified":1546581093404},{"_id":"source/plugins/prettify/lang-go.js","hash":"9cfcf1a3e4f9884b369910d7ed2cd67f644ac284","modified":1546581093405},{"_id":"source/plugins/prettify/lang-ex.js","hash":"4a73c2a674799327a2dbe2691aff72d909034b7a","modified":1546581093404},{"_id":"source/plugins/prettify/lang-kotlin.js","hash":"4aa66901437d588ccaf669d40a91a5cf36f2ffaa","modified":1546581093405},{"_id":"source/plugins/prettify/lang-hs.js","hash":"602e2ff0c97f814773d3895f08c07b5efa8a63d5","modified":1546581093405},{"_id":"source/plugins/prettify/lang-lasso.js","hash":"ba0b1a3ac1ad041a1adf6b90154713d1248391e1","modified":1546581093405},{"_id":"source/plugins/prettify/lang-lisp.js","hash":"48d79c12e1915e1166c3cb8cb1798f8ec2443cc9","modified":1546581093405},{"_id":"source/plugins/prettify/lang-llvm.js","hash":"5138b9a56f063688205157703c629fefdb8ed4d0","modified":1546581093406},{"_id":"source/plugins/prettify/lang-logtalk.js","hash":"7836eccb85957e1dae2ca02a9530cf0c7369f949","modified":1546581093406},{"_id":"source/plugins/prettify/lang-lua.js","hash":"d907fa9f1e43aa6f86530d9803b6150b0852140b","modified":1546581093406},{"_id":"source/plugins/prettify/lang-matlab.js","hash":"b71302c9a2aa5ed2b31a75ff364ec6270ac52b1b","modified":1546581093406},{"_id":"source/plugins/prettify/lang-ml.js","hash":"968bdc15137ae94b206e485b5bdfa5c96eff5857","modified":1546581093406},{"_id":"source/plugins/prettify/lang-mumps.js","hash":"9a1cae257b9b028b22ac2c4c9e4c3d2873898566","modified":1546581093407},{"_id":"source/plugins/prettify/lang-n.js","hash":"c2c992ba29d96410a93109ec2505b8e7a96782b9","modified":1546581093407},{"_id":"source/plugins/prettify/lang-pascal.js","hash":"17d60d30e6a73b3a8657baba733bb04ecbd53039","modified":1546581093407},{"_id":"source/plugins/prettify/lang-proto.js","hash":"8dc02debbff302b7d75df5728888abea01d885ae","modified":1546581093407},{"_id":"source/plugins/prettify/lang-r.js","hash":"0c6b75d79b64f603b5e66e4824e51b01df7dc841","modified":1546581093407},{"_id":"source/plugins/prettify/lang-rd.js","hash":"5421a7fe15ddf2b5ea4ab37805e7b7df9784cb34","modified":1546581093407},{"_id":"source/plugins/prettify/lang-rust.js","hash":"d5320b7d04fa87634729120062047b4843d62e04","modified":1546581093408},{"_id":"source/plugins/prettify/lang-scala.js","hash":"74e6aef0b3c6ee2208d0ee3a4887766271724763","modified":1546581093408},{"_id":"source/plugins/prettify/lang-sql.js","hash":"75c9fcd8145b0312c103841ba4fa80bcb76c01e7","modified":1546581093408},{"_id":"source/plugins/prettify/lang-swift.js","hash":"0b12cb29773ac59b3e86a709982c06d1fb903e21","modified":1546581093408},{"_id":"source/plugins/prettify/lang-tex.js","hash":"c30f64b85d576afbb7586a85bcfb471c4dace462","modified":1546581093408},{"_id":"source/plugins/prettify/lang-tcl.js","hash":"2270ce056e525578c4fdff32947fa44baeb3475a","modified":1546581093408},{"_id":"source/plugins/prettify/lang-vb.js","hash":"ba5046fe3caa09c7e2b7e1b3a643b710285a1efa","modified":1546581093409},{"_id":"source/plugins/prettify/lang-vhdl.js","hash":"d19fd1f281d3f7b9583bbf446790d8c7f0022d9c","modified":1546581093409},{"_id":"source/plugins/prettify/lang-wiki.js","hash":"197ed2adc974afa9eba86f6eec4dbb864a8649c7","modified":1546581093409},{"_id":"source/plugins/prettify/lang-yaml.js","hash":"a3a509eb7a2298b962d8b132bd19d093c5e75b25","modified":1546581093410},{"_id":"source/plugins/prettify/lang-xq.js","hash":"dd0c434083a0fd01b144eb506caedf481abc4052","modified":1546581093409},{"_id":"source/plugins/prettify/prettify.css","hash":"3f5dc3139f7385092d5dd567bb273c4585dee82d","modified":1546581093411},{"_id":"source/plugins/prettify/node_prettify.js","hash":"a3b9a2e9b334ffd6fd1b59534b260a270c96c5c1","modified":1546581093410},{"_id":"source/plugins/prettify/prettify.js","hash":"eec92d79f0678b390289981b01866ea5dd36c090","modified":1546581093411},{"_id":"source/plugins/prettify/lang-erlang.js","hash":"6cb9234429b62d55ff078346668725d6c08efea9","modified":1546581093404},{"_id":"source/plugins/prettify/lang-basic.js","hash":"565276ee5ea2f117e07a8997d792b7d734e4063c","modified":1546581093403},{"_id":"source/uploads/img/avatar.jpg","hash":"8f378705739f7611db358b2b61c7986c7223c2f8","modified":1545980134151},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1545966606789},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1545966551757},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1545966606790},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1545966606790},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1545966606790},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1545966606790},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1545966606791},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1545966551758},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1545966606791},{"_id":"themes/next/layout/_partials/head.swig","hash":"80769fbf4a511e96217edb0d5781714a8901c737","modified":1546582898048},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1545966551759},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1545966551760},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1545966551760},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1545966551761},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1545966551761},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1545966606792},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1545966551767},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1545966551767},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1545966551767},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1545966551767},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1545966606794},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1545966551767},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1545966551768},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1545966606796},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1545966551772},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1545966551773},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1545966551773},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1545966551773},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1545966551773},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1545966551773},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1545966551774},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1545966551798},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1545966551798},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1545966606805},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1545966551798},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1545966551799},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1545966551799},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1545966551799},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1545966551800},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1545966551800},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1545966551800},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1545966551801},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1545966606805},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1545966606805},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545966551801},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545966551801},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1545966606806},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1545966551801},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1545966551801},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1545966551801},{"_id":"source/images/pasted-0.png","hash":"98ebd524cc955564f59ecdb44d9ea65a349792cc","modified":1546408219801},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1545966551756},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1545966551757},{"_id":"source/plugins/prettify/run_prettify.js","hash":"b029f610e84bf11d705927d92b0df4f376973a67","modified":1546581093412},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551762},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551762},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1545966551773},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551789},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551789},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551790},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551797},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551797},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1545966551759},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1545966551759},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1545966551760},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1545966551760},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1545966551760},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1545966551761},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1545966551761},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1545966606792},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1545966551762},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1545966551762},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1545966606792},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1545966551763},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1545966551763},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1545966551763},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1545966551764},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1545966551764},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1545966551764},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1545966606793},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1545966551765},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1545966551765},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1545966551765},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1545966551765},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1545966551765},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1545966551765},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1545966551766},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1545966606793},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1545966551766},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1545966606793},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1545966551766},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1545966606793},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1545966551766},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1545966551768},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1545966551769},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1545966551769},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1545966551769},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1545966551788},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1545966606803},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1545966551789},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1545966551790},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1545966606804},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1545966606804},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1545966606804},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1545966606805},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1545966551802},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1545966551802},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1545966606806},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1545966551802},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1545966551803},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1545966606806},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1545966606807},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1545966551804},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1545966551804},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1545966606807},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1545966551803},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1545966551808},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1545966551811},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1545966606808},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1545966551812},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1545966551812},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1545966551818},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1545966551818},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1545966551819},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1545966551818},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1545966551820},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1545966551820},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1545966551820},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1545966551820},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1545966551820},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1545966551832},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1545966551833},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1545966551833},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1545966551833},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1545966551833},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1545966551834},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1545966551834},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1545966606809},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1545966606808},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1545966606809},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1545966551834},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1545966551834},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1545966551835},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1545966551835},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1545966551835},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1545966551835},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1545966551835},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1545966551836},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1545966551836},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1545966551836},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1545966551836},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1545966551836},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1545966551836},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1545966551837},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1545966551837},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1545966551838},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1545966551838},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1545966551842},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1545966551842},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1545966551844},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1545966551845},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1545966551845},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1545966551761},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1545966551760},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1545966606792},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1545966551833},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1545966551768},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1545966551768},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1545966606796},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1545966551774},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1545966606796},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1545966551774},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1545966551775},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1545966606797},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1545966551783},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1545966606802},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1545966606802},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1545966551787},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1545966551788},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1545966551787},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1545966551788},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1545966551788},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1545966606803},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1545966551791},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1545966551792},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1545966606803},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1545966551792},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1545966551792},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1545966551793},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1545966551793},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1545966646628},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1545966551794},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1545966551795},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1545966551796},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1545966551796},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1545966551796},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1545966551796},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1545966606804},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1545966551796},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1545966606807},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1545966551806},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1545966551807},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1545966551808},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1545966551813},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1545966551813},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1545966551814},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1545966551813},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1545966551814},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1545966551814},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1545966551816},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1545966551817},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1545966551817},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1545966551819},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1545966551819},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1545966551821},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1545966551821},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1545966551791},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1545966551791},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1545966551841},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1545966551842},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1545966551807},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1545966551831},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1545966551831},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1545966551844},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1545966551822},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1545966551775},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1545966606796},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1545966551776},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1545966551776},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1545966551776},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1545966606797},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1545966551777},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1545966606797},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1545966551777},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1545966551777},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1545966551778},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1545966551778},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1545966606798},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1545966551778},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1545966551779},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1545966551779},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1545966606798},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1545966551779},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1545966606798},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1545966551780},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1545966606799},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1545966551780},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1545966551780},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1545966606799},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1545966551780},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1545966606799},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1545966606800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1545966606800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1545966551781},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1545966606800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1545966551782},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1545966551782},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1545966551782},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1545966606800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1545966551782},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1545966606801},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1545966551783},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1545966551783},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1545966551784},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1545966606801},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1545966551784},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1545966551784},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1545966606801},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1545966551785},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1545966551785},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1545966551785},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1545966551785},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1545966551785},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1545966551786},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1545966551786},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1545966606801},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1545966551786},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1545966551786},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1545966551786},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1545966606802},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1545966606802},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1545966551793},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1545966551793},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1545966551795},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1545966551805},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1545966551805},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1545966551805},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1545966551806},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1545966606807},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1545966551814},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1545966551815},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1545966551815},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1545966551816},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1545966551816},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1545966551816},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1545966551775},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1545966551775},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1545966551823},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1545966551825},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1545966551830},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1545966551811},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1545966551841},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1545966551828}],"Category":[{"name":"java","_id":"cjqhnxwtt0004eb1uq2ze45b3"},{"name":"其他","_id":"cjqhnxwub000keb1uhwt61kec"},{"name":"操作系统","_id":"cjqhnxwud000qeb1ui8roqaax"}],"Data":[],"Page":[{"title":"简介","date":"2019-01-02T05:30:52.000Z","_content":"---\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    <strong>TODO<strong>\n</body>\n\n</html>","source":"about/index.html","raw":"title: 简介\ndate: 2019-01-02 13:30:52\n---\n---\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    <strong>TODO<strong>\n</body>\n\n</html>","updated":"2019-01-02T05:37:58.764Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjqhnxwto0001eb1u7mf7ubsg","content":"---\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    <strong>TODO<strong>\n</strong></strong></body>\n\n</html>","site":{"data":{}},"excerpt":"","more":"---\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    <strong>TODO<strong>\n</strong></strong></body>\n\n</html>"},{"title":"文章分类","date":"2018-12-28T06:31:10.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2018-12-28 14:31:10\ntype: \"categories\"\n---\n","updated":"2018-12-28T06:55:34.150Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjqhnxwts0003eb1uldyat7pt","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-12-28T06:30:54.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-12-28 14:30:54\ntype: \"tags\"\n---\n","updated":"2018-12-28T06:55:34.151Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjqhnxwtw0007eb1u3g7qda6g","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"abbrlink":12,"title":"java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建","author":"zhangke","date":"2018-07-24T05:58:00.000Z","_content":"#  java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建\n\n### 概要\n\n>1. 线程池的创建\n>2. ThreadFactory：线程创建工厂\n>3. RejectedExecutionHandler：任务拒绝策略\n\n###  1. 线程池的创建\n\n>ThreadPoolExecutor提供了四个创建线程池的构造函数，源码如下\n>\n>```\n>//构造函数\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)\n>\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler)\n>\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory)\n>\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n>\n>```\n>\n>虽然其提供了四个构造函数，但是前三个都是在调用最后一个来创建。\n>\n>threadFactory：如果不指定的话。默认是Executors.DefaultThreadFactory\n>\n>RejectedExecutionHandler：如果不指定默认是AbortPolicy\n>\n>下面是一个小的demo，创建线程池\n>\n>```\n>ArrayBlockingQueue<Runnable> queue = new ArrayBlockingQueue(4);\n>\n>//使用默认的threadFatory，和ArrayBlockingQueue，DiscardOldestPolicy来创建线程池\n>ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4,\n>       60, TimeUnit.SECONDS, queue, new ThreadPoolExecutor.DiscardOldestPolicy());\n>```\n>\n>\n\n### 2. ThreadFactory:线程创建工厂\n\n>在JUC中定义了线程创建工厂接口，也就是ThreadFactory接口，源码如下\n>\n>```\n>public interface ThreadFactory {\n>    Thread newThread(Runnable r);\n>}\n>```\n>\n>接口定义很简单，传递一个实现了Runnable接口的类，然后返回一个Thread对象，这和我们平常使用的new Thread其实没设么区别，只是在这里换成了工厂模式。\n>\n>ThreadPoolExecutor默认使用的是Executors.DefaultThreadFactory这个类，源码如下\n>\n>```\n>    static class DefaultThreadFactory implements ThreadFactory {\n>        private static final AtomicInteger poolNumber = new AtomicInteger(1);\n>        private final ThreadGroup group;\n>        private final AtomicInteger threadNumber = new AtomicInteger(1);\n>        private final String namePrefix;\n>\n>        DefaultThreadFactory() {\n>            SecurityManager s = System.getSecurityManager();\n>            //\n>            group = (s != null) ? s.getThreadGroup() :\n>                                  Thread.currentThread().getThreadGroup();\n>            //所有后面创建的线程，都都以这个下面这个字符串为前缀\n>            namePrefix = \"pool-\" +\n>                          poolNumber.getAndIncrement() +\n>                         \"-thread-\";\n>        }\n>\n>        public Thread newThread(Runnable r) {\n>        \t//创建线程\n>            Thread t = new Thread(group, r,\n>                                  namePrefix + threadNumber.getAndIncrement(),\n>                                  0);\n>            //设置线程的优先级和线程不是daemon线程\n>            if (t.isDaemon())\n>                t.setDaemon(false);\n>            if (t.getPriority() != Thread.NORM_PRIORITY)\n>                t.setPriority(Thread.NORM_PRIORITY);\n>            return t;\n>        }\n>    }\n>```\n>\n>分析：\n>\n>是在Executors内部实现的一个内部静态类，这个类的定义很简单，就是创建一个ThreadGroup，将后面使用newThread创建的线程放到这个group中，然后设置所有的线程都不是daemon线程，并且设置线程优先级为\n>\n>NORM_PRIORITY。\n\n### 3. RejectedExecutionHandler：任务拒绝策略\n\n>线程池堵塞队列容量满之后，将会直接新建线程，数量等于 `maximumPoolSize` 后，将会执行任务拒绝策略不在接受任务，有以下四种拒绝策略：\n>\n>1. ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。\n>2. ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。\n>3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\n>4. ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务,也就是放在当前线程上运行，知道执行完成。\n\n","source":"_posts/ java多线程系列-JUC线程池之02 ThreadPoolExecutor 线程池的创建.md","raw":"abbrlink: 12\ntitle: java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建\ntags:\n  - JUC\n  - 线程池\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-24 13:58:00\n---\n#  java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建\n\n### 概要\n\n>1. 线程池的创建\n>2. ThreadFactory：线程创建工厂\n>3. RejectedExecutionHandler：任务拒绝策略\n\n###  1. 线程池的创建\n\n>ThreadPoolExecutor提供了四个创建线程池的构造函数，源码如下\n>\n>```\n>//构造函数\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)\n>\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler)\n>\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory)\n>\n>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n>\n>```\n>\n>虽然其提供了四个构造函数，但是前三个都是在调用最后一个来创建。\n>\n>threadFactory：如果不指定的话。默认是Executors.DefaultThreadFactory\n>\n>RejectedExecutionHandler：如果不指定默认是AbortPolicy\n>\n>下面是一个小的demo，创建线程池\n>\n>```\n>ArrayBlockingQueue<Runnable> queue = new ArrayBlockingQueue(4);\n>\n>//使用默认的threadFatory，和ArrayBlockingQueue，DiscardOldestPolicy来创建线程池\n>ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4,\n>       60, TimeUnit.SECONDS, queue, new ThreadPoolExecutor.DiscardOldestPolicy());\n>```\n>\n>\n\n### 2. ThreadFactory:线程创建工厂\n\n>在JUC中定义了线程创建工厂接口，也就是ThreadFactory接口，源码如下\n>\n>```\n>public interface ThreadFactory {\n>    Thread newThread(Runnable r);\n>}\n>```\n>\n>接口定义很简单，传递一个实现了Runnable接口的类，然后返回一个Thread对象，这和我们平常使用的new Thread其实没设么区别，只是在这里换成了工厂模式。\n>\n>ThreadPoolExecutor默认使用的是Executors.DefaultThreadFactory这个类，源码如下\n>\n>```\n>    static class DefaultThreadFactory implements ThreadFactory {\n>        private static final AtomicInteger poolNumber = new AtomicInteger(1);\n>        private final ThreadGroup group;\n>        private final AtomicInteger threadNumber = new AtomicInteger(1);\n>        private final String namePrefix;\n>\n>        DefaultThreadFactory() {\n>            SecurityManager s = System.getSecurityManager();\n>            //\n>            group = (s != null) ? s.getThreadGroup() :\n>                                  Thread.currentThread().getThreadGroup();\n>            //所有后面创建的线程，都都以这个下面这个字符串为前缀\n>            namePrefix = \"pool-\" +\n>                          poolNumber.getAndIncrement() +\n>                         \"-thread-\";\n>        }\n>\n>        public Thread newThread(Runnable r) {\n>        \t//创建线程\n>            Thread t = new Thread(group, r,\n>                                  namePrefix + threadNumber.getAndIncrement(),\n>                                  0);\n>            //设置线程的优先级和线程不是daemon线程\n>            if (t.isDaemon())\n>                t.setDaemon(false);\n>            if (t.getPriority() != Thread.NORM_PRIORITY)\n>                t.setPriority(Thread.NORM_PRIORITY);\n>            return t;\n>        }\n>    }\n>```\n>\n>分析：\n>\n>是在Executors内部实现的一个内部静态类，这个类的定义很简单，就是创建一个ThreadGroup，将后面使用newThread创建的线程放到这个group中，然后设置所有的线程都不是daemon线程，并且设置线程优先级为\n>\n>NORM_PRIORITY。\n\n### 3. RejectedExecutionHandler：任务拒绝策略\n\n>线程池堵塞队列容量满之后，将会直接新建线程，数量等于 `maximumPoolSize` 后，将会执行任务拒绝策略不在接受任务，有以下四种拒绝策略：\n>\n>1. ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。\n>2. ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。\n>3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\n>4. ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务,也就是放在当前线程上运行，知道执行完成。\n\n","slug":" java多线程系列-JUC线程池之02 ThreadPoolExecutor 线程池的创建","published":1,"updated":"2019-01-04T01:48:59.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxwtj0000eb1udh29d65g","content":"<h1 id=\"java多线程系列-JUC线程池之03-ThreadPoolExecutor-线程池的创建\"><a href=\"#java多线程系列-JUC线程池之03-ThreadPoolExecutor-线程池的创建\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建\"></a>java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>线程池的创建</li>\n<li>ThreadFactory：线程创建工厂</li>\n<li>RejectedExecutionHandler：任务拒绝策略</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程池的创建\"><a href=\"#1-线程池的创建\" class=\"headerlink\" title=\"1. 线程池的创建\"></a>1. 线程池的创建</h3><blockquote>\n<p>ThreadPoolExecutor提供了四个创建线程池的构造函数，源码如下</p>\n<pre><code>//构造函数\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)\n\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)\n\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)\n\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n\n</code></pre><p>虽然其提供了四个构造函数，但是前三个都是在调用最后一个来创建。</p>\n<p>threadFactory：如果不指定的话。默认是Executors.DefaultThreadFactory</p>\n<p>RejectedExecutionHandler：如果不指定默认是AbortPolicy</p>\n<p>下面是一个小的demo，创建线程池</p>\n<pre><code>ArrayBlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue(4);\n\n//使用默认的threadFatory，和ArrayBlockingQueue，DiscardOldestPolicy来创建线程池\nThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4,\n      60, TimeUnit.SECONDS, queue, new ThreadPoolExecutor.DiscardOldestPolicy());\n</code></pre></blockquote>\n<h3 id=\"2-ThreadFactory-线程创建工厂\"><a href=\"#2-ThreadFactory-线程创建工厂\" class=\"headerlink\" title=\"2. ThreadFactory:线程创建工厂\"></a>2. ThreadFactory:线程创建工厂</h3><blockquote>\n<p>在JUC中定义了线程创建工厂接口，也就是ThreadFactory接口，源码如下</p>\n<pre><code>public interface ThreadFactory {\n   Thread newThread(Runnable r);\n}\n</code></pre><p>接口定义很简单，传递一个实现了Runnable接口的类，然后返回一个Thread对象，这和我们平常使用的new Thread其实没设么区别，只是在这里换成了工厂模式。</p>\n<p>ThreadPoolExecutor默认使用的是Executors.DefaultThreadFactory这个类，源码如下</p>\n<pre><code>   static class DefaultThreadFactory implements ThreadFactory {\n       private static final AtomicInteger poolNumber = new AtomicInteger(1);\n       private final ThreadGroup group;\n       private final AtomicInteger threadNumber = new AtomicInteger(1);\n       private final String namePrefix;\n\n       DefaultThreadFactory() {\n           SecurityManager s = System.getSecurityManager();\n           //\n           group = (s != null) ? s.getThreadGroup() :\n                                 Thread.currentThread().getThreadGroup();\n           //所有后面创建的线程，都都以这个下面这个字符串为前缀\n           namePrefix = &quot;pool-&quot; +\n                         poolNumber.getAndIncrement() +\n                        &quot;-thread-&quot;;\n       }\n\n       public Thread newThread(Runnable r) {\n           //创建线程\n           Thread t = new Thread(group, r,\n                                 namePrefix + threadNumber.getAndIncrement(),\n                                 0);\n           //设置线程的优先级和线程不是daemon线程\n           if (t.isDaemon())\n               t.setDaemon(false);\n           if (t.getPriority() != Thread.NORM_PRIORITY)\n               t.setPriority(Thread.NORM_PRIORITY);\n           return t;\n       }\n   }\n</code></pre><p>分析：</p>\n<p>是在Executors内部实现的一个内部静态类，这个类的定义很简单，就是创建一个ThreadGroup，将后面使用newThread创建的线程放到这个group中，然后设置所有的线程都不是daemon线程，并且设置线程优先级为</p>\n<p>NORM_PRIORITY。</p>\n</blockquote>\n<h3 id=\"3-RejectedExecutionHandler：任务拒绝策略\"><a href=\"#3-RejectedExecutionHandler：任务拒绝策略\" class=\"headerlink\" title=\"3. RejectedExecutionHandler：任务拒绝策略\"></a>3. RejectedExecutionHandler：任务拒绝策略</h3><blockquote>\n<p>线程池堵塞队列容量满之后，将会直接新建线程，数量等于 <code>maximumPoolSize</code> 后，将会执行任务拒绝策略不在接受任务，有以下四种拒绝策略：</p>\n<ol>\n<li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</li>\n<li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务,也就是放在当前线程上运行，知道执行完成。</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-JUC线程池之03-ThreadPoolExecutor-线程池的创建\"><a href=\"#java多线程系列-JUC线程池之03-ThreadPoolExecutor-线程池的创建\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建\"></a>java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>线程池的创建</li>\n<li>ThreadFactory：线程创建工厂</li>\n<li>RejectedExecutionHandler：任务拒绝策略</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程池的创建\"><a href=\"#1-线程池的创建\" class=\"headerlink\" title=\"1. 线程池的创建\"></a>1. 线程池的创建</h3><blockquote>\n<p>ThreadPoolExecutor提供了四个创建线程池的构造函数，源码如下</p>\n<pre><code>//构造函数\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)\n\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)\n\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)\n\nThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n\n</code></pre><p>虽然其提供了四个构造函数，但是前三个都是在调用最后一个来创建。</p>\n<p>threadFactory：如果不指定的话。默认是Executors.DefaultThreadFactory</p>\n<p>RejectedExecutionHandler：如果不指定默认是AbortPolicy</p>\n<p>下面是一个小的demo，创建线程池</p>\n<pre><code>ArrayBlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue(4);\n\n//使用默认的threadFatory，和ArrayBlockingQueue，DiscardOldestPolicy来创建线程池\nThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4,\n      60, TimeUnit.SECONDS, queue, new ThreadPoolExecutor.DiscardOldestPolicy());\n</code></pre></blockquote>\n<h3 id=\"2-ThreadFactory-线程创建工厂\"><a href=\"#2-ThreadFactory-线程创建工厂\" class=\"headerlink\" title=\"2. ThreadFactory:线程创建工厂\"></a>2. ThreadFactory:线程创建工厂</h3><blockquote>\n<p>在JUC中定义了线程创建工厂接口，也就是ThreadFactory接口，源码如下</p>\n<pre><code>public interface ThreadFactory {\n   Thread newThread(Runnable r);\n}\n</code></pre><p>接口定义很简单，传递一个实现了Runnable接口的类，然后返回一个Thread对象，这和我们平常使用的new Thread其实没设么区别，只是在这里换成了工厂模式。</p>\n<p>ThreadPoolExecutor默认使用的是Executors.DefaultThreadFactory这个类，源码如下</p>\n<pre><code>   static class DefaultThreadFactory implements ThreadFactory {\n       private static final AtomicInteger poolNumber = new AtomicInteger(1);\n       private final ThreadGroup group;\n       private final AtomicInteger threadNumber = new AtomicInteger(1);\n       private final String namePrefix;\n\n       DefaultThreadFactory() {\n           SecurityManager s = System.getSecurityManager();\n           //\n           group = (s != null) ? s.getThreadGroup() :\n                                 Thread.currentThread().getThreadGroup();\n           //所有后面创建的线程，都都以这个下面这个字符串为前缀\n           namePrefix = &quot;pool-&quot; +\n                         poolNumber.getAndIncrement() +\n                        &quot;-thread-&quot;;\n       }\n\n       public Thread newThread(Runnable r) {\n           //创建线程\n           Thread t = new Thread(group, r,\n                                 namePrefix + threadNumber.getAndIncrement(),\n                                 0);\n           //设置线程的优先级和线程不是daemon线程\n           if (t.isDaemon())\n               t.setDaemon(false);\n           if (t.getPriority() != Thread.NORM_PRIORITY)\n               t.setPriority(Thread.NORM_PRIORITY);\n           return t;\n       }\n   }\n</code></pre><p>分析：</p>\n<p>是在Executors内部实现的一个内部静态类，这个类的定义很简单，就是创建一个ThreadGroup，将后面使用newThread创建的线程放到这个group中，然后设置所有的线程都不是daemon线程，并且设置线程优先级为</p>\n<p>NORM_PRIORITY。</p>\n</blockquote>\n<h3 id=\"3-RejectedExecutionHandler：任务拒绝策略\"><a href=\"#3-RejectedExecutionHandler：任务拒绝策略\" class=\"headerlink\" title=\"3. RejectedExecutionHandler：任务拒绝策略\"></a>3. RejectedExecutionHandler：任务拒绝策略</h3><blockquote>\n<p>线程池堵塞队列容量满之后，将会直接新建线程，数量等于 <code>maximumPoolSize</code> 后，将会执行任务拒绝策略不在接受任务，有以下四种拒绝策略：</p>\n<ol>\n<li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</li>\n<li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务,也就是放在当前线程上运行，知道执行完成。</li>\n</ol>\n</blockquote>\n"},{"title":"Random 与 ThreadLocalRandom 对比","author":"zhangke","abbrlink":26181,"date":"2018-12-12T07:42:00.000Z","_content":"---\n# Random 与 ThreadLocalRandom 对比\n\n1. 简介\n2. 测试结果与分析\n3. 补充\n\n### 1. 简介\n\n首先，如果你看到这篇文章相信对这俩个类有一定的了解，所以我就不再这里介绍具体的用法。简单的介绍一下这个类，Random，ThreadLocalRandom是Java中的随机数生成器，Random是我们比较常用的随机数生成器，他是线程安全的。ThreadLocalRandom是jdk7才出现的，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，同时也能保证线程安全和提高性能。\n\n由于本人能力有限，如果你的英文比较好，可以看看StackOverFlow上的这个讨论[https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom](https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom)\n<!--  more -->\n\n### 2. 测试结果与分析\n\n我使用的JMH来进行的压测，这篇文章可以帮助你[入门 JMH](https://www.cnkirito.moe/java-jmh/)。具体代码如下\n\n```java\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 11:44\n *      email  : 398757724@qq.com\n *      Desc   : ThreadRandom 和 Random性能对比\n ***************************************/\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 5)\n@Measurement(iterations = 3, time = 5)\n@Threads(10)\n@Fork(1)\n@State(Scope.Benchmark)\npublic class Randombenchmark {\n    Random random = new Random();\n\n    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n\n\n    @Benchmark\n    public int random() {\n        return random.nextInt();\n    }\n\n\n    @Benchmark\n    public int threadLocalRandom() {\n        return threadLocalRandom.nextInt();\n    }\n\n\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(Randombenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n\n```\n\n测试结果\n\n```\n··· 前面一部分省略，主要内容如下\nBenchmark                          Mode  Cnt    Score     Error  Units\nRandombenchmark.random             avgt    3  349.952 ± 115.007  ns/op\nRandombenchmark.threadLocalRandom  avgt    3   26.393 ±  11.538  ns/op\n```\n\n从上面结果可以看出，结果验证确实ThreadLocalRandom在多线程环境情况下更快，ThreadLocalRandom比Random快了将近13倍之多。\n\n至于为什么ThreadLocalRandom更快呢，这个要从源码来分析。\n\nRandom的实现也比较简单，初始化的时候用当前的事件来初始化一个随机数种子，然后每次取值的时候用这个种子与有些MagicNumber运算，并更新种子。最核心的就是这个next的函数，不管你是调用了nextDouble还是nextInt还是nextBoolean，Random底层都是调这个next(int bits)。\n\n```java\n    protected int next(int bits) {\n        long oldseed, nextseed;\n        AtomicLong seed = this.seed;\n        do {\n            oldseed = seed.get();\n            nextseed = (oldseed * multiplier + addend) & mask;\n        } while (!seed.compareAndSet(oldseed, nextseed));\n        return (int)(nextseed >>> (48 - bits));\n    }\n```\n\n　　为了保证多线程下每次生成随机数都是用的不同，next()得保证seed的更新是原子操作，所以用了AtomicLong的compareAndSet()，该方法底层调用了sum.misc.Unsafe的compareAndSwapLong()，也就是大家常听到的CAS， 这是一个native方法，它能保证原子更新一个数。\n\n既然Random是线程安全的，又能满足我们大多说的要求，为什么concurrent包里还要实现一个ThreadLocalRandom。在oracle的jdk文档里发现这样一句话\n\n> use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.\n\n大意就是用ThreadLocalRandom更适合用在多线程下，能大幅减少多线程并行下的性能开销和资源争抢。\n\n　既然ThreadLocalRandom在多线程下表现这么牛逼，它究竟是如何做到的？我们来看下源码，它的核心代码是这个（在看源码时需要注意一点，虽然ThreadLocalRandom也实现了next函数，但是在这个函数上面有一句，定义了这个方法，但绝不使用，你也可以从next*方法里面看出，使用的都是mix32(nextSeed)或者mix64(nextSeed)来获取随机数）\n\n```java\n    final long nextSeed() {\n        Thread t; long r; // read and update per-thread seed\n        UNSAFE.putLong(t = Thread.currentThread(), SEED,\n                       r = UNSAFE.getLong(t, SEED) + GAMMA);\n        return r;\n    }\n```\n\n上面虽然使用了UNSAFE对象，但是没有调用CAS方法，只是简单的替换Thread对象中的threadLocalRandomSeed属性，所以不要一看到UNSAFE这个类，就当成要调用CAS方法，我刚开始阅读的时候就有这个疑惑，自己太菜了。\n\n在创建ThreadLocalRandom对象时，ThreadLocalRandom是对每个线程都设置了单独的随机数种子，这样就不会发生多线程同时更新一个数时产生的资源争抢了，用空间换时间。\n\n### 3. 补充\n\n在生成验证码的情况下，不要使用Random，因为它是线性可预测的。所以在安全性要求比较高的场合，应当使用SecureRandom。从理论上来说计算机产生的随机数都是伪随机数，要想**产生高强度的随机数，有两个重要的因素：种子和算法。当然算法是可以有很多的，但是如何选择种子是非常关键的因素。如Random，它的种子是System.currentTimeMillis()，所以它的随机数都是可预测的。那么如何得到一个近似随机的种子？这里有一个很别致的思路：收集计算机的各种信息，如键盘输入时间，CPU时钟，内存使用状态，硬盘空闲空间，IO延时，进程数量，线程数量等信息，来得到一个近似随机的种子。这样的话，除了理论上有破解的可能，实际上基本没有被破解的可能。而事实上，现在的高强度的随机数生成器都是这样实现的。**\n\n\n\n### 参考\n\n1. [java.util.Random和concurrent.ThreadLocalRandom对比](https://xindoo.me/article/1400)\n2. [C 位操作 左移32位 错误](https://blog.csdn.net/huqinweI987/article/details/70941199) 这个是我在进行源码研究时，发先自己int类型的说移动32位还是原数子，从这篇文章找到了答案\n3. [Java随机数探秘](https://www.cnkirito.moe/java-random/)","source":"_posts/Random 与 ThreadLocalRandom 对比.md","raw":"title: Random 与 ThreadLocalRandom 对比\ntags:\n  - JUC\ncategories:\n  - java\nauthor: zhangke\nabbrlink: 26181\ndate: 2018-12-12 15:42:00\n---\n---\n# Random 与 ThreadLocalRandom 对比\n\n1. 简介\n2. 测试结果与分析\n3. 补充\n\n### 1. 简介\n\n首先，如果你看到这篇文章相信对这俩个类有一定的了解，所以我就不再这里介绍具体的用法。简单的介绍一下这个类，Random，ThreadLocalRandom是Java中的随机数生成器，Random是我们比较常用的随机数生成器，他是线程安全的。ThreadLocalRandom是jdk7才出现的，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，同时也能保证线程安全和提高性能。\n\n由于本人能力有限，如果你的英文比较好，可以看看StackOverFlow上的这个讨论[https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom](https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom)\n<!--  more -->\n\n### 2. 测试结果与分析\n\n我使用的JMH来进行的压测，这篇文章可以帮助你[入门 JMH](https://www.cnkirito.moe/java-jmh/)。具体代码如下\n\n```java\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 11:44\n *      email  : 398757724@qq.com\n *      Desc   : ThreadRandom 和 Random性能对比\n ***************************************/\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 5)\n@Measurement(iterations = 3, time = 5)\n@Threads(10)\n@Fork(1)\n@State(Scope.Benchmark)\npublic class Randombenchmark {\n    Random random = new Random();\n\n    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n\n\n    @Benchmark\n    public int random() {\n        return random.nextInt();\n    }\n\n\n    @Benchmark\n    public int threadLocalRandom() {\n        return threadLocalRandom.nextInt();\n    }\n\n\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(Randombenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n\n```\n\n测试结果\n\n```\n··· 前面一部分省略，主要内容如下\nBenchmark                          Mode  Cnt    Score     Error  Units\nRandombenchmark.random             avgt    3  349.952 ± 115.007  ns/op\nRandombenchmark.threadLocalRandom  avgt    3   26.393 ±  11.538  ns/op\n```\n\n从上面结果可以看出，结果验证确实ThreadLocalRandom在多线程环境情况下更快，ThreadLocalRandom比Random快了将近13倍之多。\n\n至于为什么ThreadLocalRandom更快呢，这个要从源码来分析。\n\nRandom的实现也比较简单，初始化的时候用当前的事件来初始化一个随机数种子，然后每次取值的时候用这个种子与有些MagicNumber运算，并更新种子。最核心的就是这个next的函数，不管你是调用了nextDouble还是nextInt还是nextBoolean，Random底层都是调这个next(int bits)。\n\n```java\n    protected int next(int bits) {\n        long oldseed, nextseed;\n        AtomicLong seed = this.seed;\n        do {\n            oldseed = seed.get();\n            nextseed = (oldseed * multiplier + addend) & mask;\n        } while (!seed.compareAndSet(oldseed, nextseed));\n        return (int)(nextseed >>> (48 - bits));\n    }\n```\n\n　　为了保证多线程下每次生成随机数都是用的不同，next()得保证seed的更新是原子操作，所以用了AtomicLong的compareAndSet()，该方法底层调用了sum.misc.Unsafe的compareAndSwapLong()，也就是大家常听到的CAS， 这是一个native方法，它能保证原子更新一个数。\n\n既然Random是线程安全的，又能满足我们大多说的要求，为什么concurrent包里还要实现一个ThreadLocalRandom。在oracle的jdk文档里发现这样一句话\n\n> use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.\n\n大意就是用ThreadLocalRandom更适合用在多线程下，能大幅减少多线程并行下的性能开销和资源争抢。\n\n　既然ThreadLocalRandom在多线程下表现这么牛逼，它究竟是如何做到的？我们来看下源码，它的核心代码是这个（在看源码时需要注意一点，虽然ThreadLocalRandom也实现了next函数，但是在这个函数上面有一句，定义了这个方法，但绝不使用，你也可以从next*方法里面看出，使用的都是mix32(nextSeed)或者mix64(nextSeed)来获取随机数）\n\n```java\n    final long nextSeed() {\n        Thread t; long r; // read and update per-thread seed\n        UNSAFE.putLong(t = Thread.currentThread(), SEED,\n                       r = UNSAFE.getLong(t, SEED) + GAMMA);\n        return r;\n    }\n```\n\n上面虽然使用了UNSAFE对象，但是没有调用CAS方法，只是简单的替换Thread对象中的threadLocalRandomSeed属性，所以不要一看到UNSAFE这个类，就当成要调用CAS方法，我刚开始阅读的时候就有这个疑惑，自己太菜了。\n\n在创建ThreadLocalRandom对象时，ThreadLocalRandom是对每个线程都设置了单独的随机数种子，这样就不会发生多线程同时更新一个数时产生的资源争抢了，用空间换时间。\n\n### 3. 补充\n\n在生成验证码的情况下，不要使用Random，因为它是线性可预测的。所以在安全性要求比较高的场合，应当使用SecureRandom。从理论上来说计算机产生的随机数都是伪随机数，要想**产生高强度的随机数，有两个重要的因素：种子和算法。当然算法是可以有很多的，但是如何选择种子是非常关键的因素。如Random，它的种子是System.currentTimeMillis()，所以它的随机数都是可预测的。那么如何得到一个近似随机的种子？这里有一个很别致的思路：收集计算机的各种信息，如键盘输入时间，CPU时钟，内存使用状态，硬盘空闲空间，IO延时，进程数量，线程数量等信息，来得到一个近似随机的种子。这样的话，除了理论上有破解的可能，实际上基本没有被破解的可能。而事实上，现在的高强度的随机数生成器都是这样实现的。**\n\n\n\n### 参考\n\n1. [java.util.Random和concurrent.ThreadLocalRandom对比](https://xindoo.me/article/1400)\n2. [C 位操作 左移32位 错误](https://blog.csdn.net/huqinweI987/article/details/70941199) 这个是我在进行源码研究时，发先自己int类型的说移动32位还是原数子，从这篇文章找到了答案\n3. [Java随机数探秘](https://www.cnkirito.moe/java-random/)","slug":"Random 与 ThreadLocalRandom 对比","published":1,"updated":"2019-01-04T01:58:58.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxwtp0002eb1u2enxtjsg","content":"<hr>\n<h1 id=\"Random-与-ThreadLocalRandom-对比\"><a href=\"#Random-与-ThreadLocalRandom-对比\" class=\"headerlink\" title=\"Random 与 ThreadLocalRandom 对比\"></a>Random 与 ThreadLocalRandom 对比</h1><ol>\n<li>简介</li>\n<li>测试结果与分析</li>\n<li>补充</li>\n</ol>\n<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>首先，如果你看到这篇文章相信对这俩个类有一定的了解，所以我就不再这里介绍具体的用法。简单的介绍一下这个类，Random，ThreadLocalRandom是Java中的随机数生成器，Random是我们比较常用的随机数生成器，他是线程安全的。ThreadLocalRandom是jdk7才出现的，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，同时也能保证线程安全和提高性能。</p>\n<p>由于本人能力有限，如果你的英文比较好，可以看看StackOverFlow上的这个讨论<a href=\"https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom</a><br><a id=\"more\"></a></p>\n<h3 id=\"2-测试结果与分析\"><a href=\"#2-测试结果与分析\" class=\"headerlink\" title=\"2. 测试结果与分析\"></a>2. 测试结果与分析</h3><p>我使用的JMH来进行的压测，这篇文章可以帮助你<a href=\"https://www.cnkirito.moe/java-jmh/\" target=\"_blank\" rel=\"noopener\">入门 JMH</a>。具体代码如下</p>\n<pre><code class=\"java\">/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 11:44\n *      email  : 398757724@qq.com\n *      Desc   : ThreadRandom 和 Random性能对比\n ***************************************/\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 5)\n@Measurement(iterations = 3, time = 5)\n@Threads(10)\n@Fork(1)\n@State(Scope.Benchmark)\npublic class Randombenchmark {\n    Random random = new Random();\n\n    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n\n\n    @Benchmark\n    public int random() {\n        return random.nextInt();\n    }\n\n\n    @Benchmark\n    public int threadLocalRandom() {\n        return threadLocalRandom.nextInt();\n    }\n\n\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(Randombenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n\n</code></pre>\n<p>测试结果</p>\n<pre><code>··· 前面一部分省略，主要内容如下\nBenchmark                          Mode  Cnt    Score     Error  Units\nRandombenchmark.random             avgt    3  349.952 ± 115.007  ns/op\nRandombenchmark.threadLocalRandom  avgt    3   26.393 ±  11.538  ns/op\n</code></pre><p>从上面结果可以看出，结果验证确实ThreadLocalRandom在多线程环境情况下更快，ThreadLocalRandom比Random快了将近13倍之多。</p>\n<p>至于为什么ThreadLocalRandom更快呢，这个要从源码来分析。</p>\n<p>Random的实现也比较简单，初始化的时候用当前的事件来初始化一个随机数种子，然后每次取值的时候用这个种子与有些MagicNumber运算，并更新种子。最核心的就是这个next的函数，不管你是调用了nextDouble还是nextInt还是nextBoolean，Random底层都是调这个next(int bits)。</p>\n<pre><code class=\"java\">    protected int next(int bits) {\n        long oldseed, nextseed;\n        AtomicLong seed = this.seed;\n        do {\n            oldseed = seed.get();\n            nextseed = (oldseed * multiplier + addend) &amp; mask;\n        } while (!seed.compareAndSet(oldseed, nextseed));\n        return (int)(nextseed &gt;&gt;&gt; (48 - bits));\n    }\n</code></pre>\n<p>　　为了保证多线程下每次生成随机数都是用的不同，next()得保证seed的更新是原子操作，所以用了AtomicLong的compareAndSet()，该方法底层调用了sum.misc.Unsafe的compareAndSwapLong()，也就是大家常听到的CAS， 这是一个native方法，它能保证原子更新一个数。</p>\n<p>既然Random是线程安全的，又能满足我们大多说的要求，为什么concurrent包里还要实现一个ThreadLocalRandom。在oracle的jdk文档里发现这样一句话</p>\n<blockquote>\n<p>use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.</p>\n</blockquote>\n<p>大意就是用ThreadLocalRandom更适合用在多线程下，能大幅减少多线程并行下的性能开销和资源争抢。</p>\n<p>　既然ThreadLocalRandom在多线程下表现这么牛逼，它究竟是如何做到的？我们来看下源码，它的核心代码是这个（在看源码时需要注意一点，虽然ThreadLocalRandom也实现了next函数，但是在这个函数上面有一句，定义了这个方法，但绝不使用，你也可以从next*方法里面看出，使用的都是mix32(nextSeed)或者mix64(nextSeed)来获取随机数）</p>\n<pre><code class=\"java\">    final long nextSeed() {\n        Thread t; long r; // read and update per-thread seed\n        UNSAFE.putLong(t = Thread.currentThread(), SEED,\n                       r = UNSAFE.getLong(t, SEED) + GAMMA);\n        return r;\n    }\n</code></pre>\n<p>上面虽然使用了UNSAFE对象，但是没有调用CAS方法，只是简单的替换Thread对象中的threadLocalRandomSeed属性，所以不要一看到UNSAFE这个类，就当成要调用CAS方法，我刚开始阅读的时候就有这个疑惑，自己太菜了。</p>\n<p>在创建ThreadLocalRandom对象时，ThreadLocalRandom是对每个线程都设置了单独的随机数种子，这样就不会发生多线程同时更新一个数时产生的资源争抢了，用空间换时间。</p>\n<h3 id=\"3-补充\"><a href=\"#3-补充\" class=\"headerlink\" title=\"3. 补充\"></a>3. 补充</h3><p>在生成验证码的情况下，不要使用Random，因为它是线性可预测的。所以在安全性要求比较高的场合，应当使用SecureRandom。从理论上来说计算机产生的随机数都是伪随机数，要想<strong>产生高强度的随机数，有两个重要的因素：种子和算法。当然算法是可以有很多的，但是如何选择种子是非常关键的因素。如Random，它的种子是System.currentTimeMillis()，所以它的随机数都是可预测的。那么如何得到一个近似随机的种子？这里有一个很别致的思路：收集计算机的各种信息，如键盘输入时间，CPU时钟，内存使用状态，硬盘空闲空间，IO延时，进程数量，线程数量等信息，来得到一个近似随机的种子。这样的话，除了理论上有破解的可能，实际上基本没有被破解的可能。而事实上，现在的高强度的随机数生成器都是这样实现的。</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://xindoo.me/article/1400\" target=\"_blank\" rel=\"noopener\">java.util.Random和concurrent.ThreadLocalRandom对比</a></li>\n<li><a href=\"https://blog.csdn.net/huqinweI987/article/details/70941199\" target=\"_blank\" rel=\"noopener\">C 位操作 左移32位 错误</a> 这个是我在进行源码研究时，发先自己int类型的说移动32位还是原数子，从这篇文章找到了答案</li>\n<li><a href=\"https://www.cnkirito.moe/java-random/\" target=\"_blank\" rel=\"noopener\">Java随机数探秘</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<hr>\n<h1 id=\"Random-与-ThreadLocalRandom-对比\"><a href=\"#Random-与-ThreadLocalRandom-对比\" class=\"headerlink\" title=\"Random 与 ThreadLocalRandom 对比\"></a>Random 与 ThreadLocalRandom 对比</h1><ol>\n<li>简介</li>\n<li>测试结果与分析</li>\n<li>补充</li>\n</ol>\n<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>首先，如果你看到这篇文章相信对这俩个类有一定的了解，所以我就不再这里介绍具体的用法。简单的介绍一下这个类，Random，ThreadLocalRandom是Java中的随机数生成器，Random是我们比较常用的随机数生成器，他是线程安全的。ThreadLocalRandom是jdk7才出现的，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，同时也能保证线程安全和提高性能。</p>\n<p>由于本人能力有限，如果你的英文比较好，可以看看StackOverFlow上的这个讨论<a href=\"https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom</a><br>","more":"</p>\n<h3 id=\"2-测试结果与分析\"><a href=\"#2-测试结果与分析\" class=\"headerlink\" title=\"2. 测试结果与分析\"></a>2. 测试结果与分析</h3><p>我使用的JMH来进行的压测，这篇文章可以帮助你<a href=\"https://www.cnkirito.moe/java-jmh/\" target=\"_blank\" rel=\"noopener\">入门 JMH</a>。具体代码如下</p>\n<pre><code class=\"java\">/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 11:44\n *      email  : 398757724@qq.com\n *      Desc   : ThreadRandom 和 Random性能对比\n ***************************************/\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 5)\n@Measurement(iterations = 3, time = 5)\n@Threads(10)\n@Fork(1)\n@State(Scope.Benchmark)\npublic class Randombenchmark {\n    Random random = new Random();\n\n    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n\n\n    @Benchmark\n    public int random() {\n        return random.nextInt();\n    }\n\n\n    @Benchmark\n    public int threadLocalRandom() {\n        return threadLocalRandom.nextInt();\n    }\n\n\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(Randombenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n\n</code></pre>\n<p>测试结果</p>\n<pre><code>··· 前面一部分省略，主要内容如下\nBenchmark                          Mode  Cnt    Score     Error  Units\nRandombenchmark.random             avgt    3  349.952 ± 115.007  ns/op\nRandombenchmark.threadLocalRandom  avgt    3   26.393 ±  11.538  ns/op\n</code></pre><p>从上面结果可以看出，结果验证确实ThreadLocalRandom在多线程环境情况下更快，ThreadLocalRandom比Random快了将近13倍之多。</p>\n<p>至于为什么ThreadLocalRandom更快呢，这个要从源码来分析。</p>\n<p>Random的实现也比较简单，初始化的时候用当前的事件来初始化一个随机数种子，然后每次取值的时候用这个种子与有些MagicNumber运算，并更新种子。最核心的就是这个next的函数，不管你是调用了nextDouble还是nextInt还是nextBoolean，Random底层都是调这个next(int bits)。</p>\n<pre><code class=\"java\">    protected int next(int bits) {\n        long oldseed, nextseed;\n        AtomicLong seed = this.seed;\n        do {\n            oldseed = seed.get();\n            nextseed = (oldseed * multiplier + addend) &amp; mask;\n        } while (!seed.compareAndSet(oldseed, nextseed));\n        return (int)(nextseed &gt;&gt;&gt; (48 - bits));\n    }\n</code></pre>\n<p>　　为了保证多线程下每次生成随机数都是用的不同，next()得保证seed的更新是原子操作，所以用了AtomicLong的compareAndSet()，该方法底层调用了sum.misc.Unsafe的compareAndSwapLong()，也就是大家常听到的CAS， 这是一个native方法，它能保证原子更新一个数。</p>\n<p>既然Random是线程安全的，又能满足我们大多说的要求，为什么concurrent包里还要实现一个ThreadLocalRandom。在oracle的jdk文档里发现这样一句话</p>\n<blockquote>\n<p>use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.</p>\n</blockquote>\n<p>大意就是用ThreadLocalRandom更适合用在多线程下，能大幅减少多线程并行下的性能开销和资源争抢。</p>\n<p>　既然ThreadLocalRandom在多线程下表现这么牛逼，它究竟是如何做到的？我们来看下源码，它的核心代码是这个（在看源码时需要注意一点，虽然ThreadLocalRandom也实现了next函数，但是在这个函数上面有一句，定义了这个方法，但绝不使用，你也可以从next*方法里面看出，使用的都是mix32(nextSeed)或者mix64(nextSeed)来获取随机数）</p>\n<pre><code class=\"java\">    final long nextSeed() {\n        Thread t; long r; // read and update per-thread seed\n        UNSAFE.putLong(t = Thread.currentThread(), SEED,\n                       r = UNSAFE.getLong(t, SEED) + GAMMA);\n        return r;\n    }\n</code></pre>\n<p>上面虽然使用了UNSAFE对象，但是没有调用CAS方法，只是简单的替换Thread对象中的threadLocalRandomSeed属性，所以不要一看到UNSAFE这个类，就当成要调用CAS方法，我刚开始阅读的时候就有这个疑惑，自己太菜了。</p>\n<p>在创建ThreadLocalRandom对象时，ThreadLocalRandom是对每个线程都设置了单独的随机数种子，这样就不会发生多线程同时更新一个数时产生的资源争抢了，用空间换时间。</p>\n<h3 id=\"3-补充\"><a href=\"#3-补充\" class=\"headerlink\" title=\"3. 补充\"></a>3. 补充</h3><p>在生成验证码的情况下，不要使用Random，因为它是线性可预测的。所以在安全性要求比较高的场合，应当使用SecureRandom。从理论上来说计算机产生的随机数都是伪随机数，要想<strong>产生高强度的随机数，有两个重要的因素：种子和算法。当然算法是可以有很多的，但是如何选择种子是非常关键的因素。如Random，它的种子是System.currentTimeMillis()，所以它的随机数都是可预测的。那么如何得到一个近似随机的种子？这里有一个很别致的思路：收集计算机的各种信息，如键盘输入时间，CPU时钟，内存使用状态，硬盘空闲空间，IO延时，进程数量，线程数量等信息，来得到一个近似随机的种子。这样的话，除了理论上有破解的可能，实际上基本没有被破解的可能。而事实上，现在的高强度的随机数生成器都是这样实现的。</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://xindoo.me/article/1400\" target=\"_blank\" rel=\"noopener\">java.util.Random和concurrent.ThreadLocalRandom对比</a></li>\n<li><a href=\"https://blog.csdn.net/huqinweI987/article/details/70941199\" target=\"_blank\" rel=\"noopener\">C 位操作 左移32位 错误</a> 这个是我在进行源码研究时，发先自己int类型的说移动32位还是原数子，从这篇文章找到了答案</li>\n<li><a href=\"https://www.cnkirito.moe/java-random/\" target=\"_blank\" rel=\"noopener\">Java随机数探秘</a></li>\n</ol>"},{"abbrlink":1,"title":"java多线程系列 01 基本概念以及实现方式","author":"zhangke","date":"2018-07-11T08:12:00.000Z","_content":"# java 多线程的基本概念以及实现方式\n\n### 概要\n\n1. 线程的基本概念\n2. 常用的实现多线程的方式\n3. Thread中start()和run()的区别\n\n###  1. 线程的基本概念\n\n线程状态图\n\n![](https://images0.cnblogs.com/blog/497634/201312/18152411-a974ea82ebc04e72bd874c3921f8bfec.jpg)\n\n**说明**：\n线程共包括以下5种状态。\n\n1. **新建状态(New)**         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。\n2. **就绪状态(Runnable)**: 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。\n3. **运行状态(Running)** : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。\n4. **阻塞状态(Blocked)**  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：\n   1. 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。\n   2.  同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。\n   3.  其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\n5. **死亡状态(Dead)**    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。需要注意的是，**线程一旦进入死亡状态就不能在调用start()方法来让线程恢复运行。**\n这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。这些内容我们会在后面的章节中逐个进行学习。\n\n**Object类**，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。\n**Thread类**，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。\n**synchronized**，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。\n在后面详细介绍wait(),notify()等方法时，我们会分析为什么**wait(), notify()等方法要定义在Object类，而不是Thread类中**。\n\n### 2. 常用的实现多线程的方式\n\n常用的主要有俩种：Thread类 和Runnable接口\n### **Thread和Runnable简介**\n\n**Runnable** 是一个接口，该接口中只包含了一个run()方法。它的定义如下：\n\n```\npublic interface Runnable {\n    public abstract void run();\n}\n```\n\nRunnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；\n\n然后，通过``new Thread(new A())``等方式新建线程。\n\n**Thread** 是一个类。Thread本身就实现了Runnable接口。它的声明如下：\n\n```\npublic class Thread implements Runnable {\n    \n}\n```\n\nThread的作用，实现多线程。\n\n### **Thread和Runnable的异同点**\n\n**Thread 和 Runnable 的相同点**：都是“多线程的实现方式”。\n\n **Thread 和 Runnable 的不同点**： Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。\n\n 此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。 \n\n通常，建议通过“Runnable”实现多线程！\n\n### **Thread和Runnable的多线程示例**\n\n\n\n#### Thread的多线程示例\n\n```\nclass MyThread extends Thread{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i<20;i++){ \n            if(this.ticket>0){\n                System.out.println(this.getName()+\" 卖票：ticket\"+this.ticket--);\n            }\n        }\n    } \n};\n\npublic class ThreadTest {  \n    public static void main(String[] args) {  \n        // 创建3个线程,每个线程各卖10张票！\n        MyThread t1=new MyThread();\n        MyThread t2=new MyThread();\n        MyThread t3=new MyThread();\n        //启动线程，开始运行\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n```\n\n#### **Runnable的多线程示例**\n\n```\n// 实现Runnable接口\nclass MyThread implements Runnable{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i<20;i++){ \n            if(this.ticket>0){\n                System.out.println(Thread.currentThread().getName()\n                 +\" 卖票：ticket\"+this.ticket--);\n            }\n        }\n    } \n}; \n\npublic class RunnableTest {  \n    public static void main(String[] args) {  \n    \n        //创建实现了Runnable接口的对象\n        MyThread mt=new MyThread();\n\n        // 创建3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！\n        Thread t1=new Thread(mt);\n        Thread t2=new Thread(mt);\n        Thread t3=new Thread(mt);\n        //启动3个线程\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n```\n\n**结果说明**： \n\n1.  和上面“MyThread继承于Thread”不同；这里的MyThread实现了Runnable接口。 \n\n2.  主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。\n\n#### 注意的是:上面不是线程安全的操作\n\n### 3. Thread中start()和run()的区别\n\n**start()** : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。\n\n **run()**   : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！\n\n后面会将Thread类的源码拿出来单独解析说明。这里只是简单的提一下。","source":"_posts/java多线程系列 01基本概念以及实现方式.md","raw":"abbrlink: 1\ntitle: java多线程系列 01 基本概念以及实现方式\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-11 16:12:00\n---\n# java 多线程的基本概念以及实现方式\n\n### 概要\n\n1. 线程的基本概念\n2. 常用的实现多线程的方式\n3. Thread中start()和run()的区别\n\n###  1. 线程的基本概念\n\n线程状态图\n\n![](https://images0.cnblogs.com/blog/497634/201312/18152411-a974ea82ebc04e72bd874c3921f8bfec.jpg)\n\n**说明**：\n线程共包括以下5种状态。\n\n1. **新建状态(New)**         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。\n2. **就绪状态(Runnable)**: 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。\n3. **运行状态(Running)** : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。\n4. **阻塞状态(Blocked)**  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：\n   1. 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。\n   2.  同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。\n   3.  其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\n5. **死亡状态(Dead)**    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。需要注意的是，**线程一旦进入死亡状态就不能在调用start()方法来让线程恢复运行。**\n这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。这些内容我们会在后面的章节中逐个进行学习。\n\n**Object类**，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。\n**Thread类**，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。\n**synchronized**，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。\n在后面详细介绍wait(),notify()等方法时，我们会分析为什么**wait(), notify()等方法要定义在Object类，而不是Thread类中**。\n\n### 2. 常用的实现多线程的方式\n\n常用的主要有俩种：Thread类 和Runnable接口\n### **Thread和Runnable简介**\n\n**Runnable** 是一个接口，该接口中只包含了一个run()方法。它的定义如下：\n\n```\npublic interface Runnable {\n    public abstract void run();\n}\n```\n\nRunnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；\n\n然后，通过``new Thread(new A())``等方式新建线程。\n\n**Thread** 是一个类。Thread本身就实现了Runnable接口。它的声明如下：\n\n```\npublic class Thread implements Runnable {\n    \n}\n```\n\nThread的作用，实现多线程。\n\n### **Thread和Runnable的异同点**\n\n**Thread 和 Runnable 的相同点**：都是“多线程的实现方式”。\n\n **Thread 和 Runnable 的不同点**： Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。\n\n 此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。 \n\n通常，建议通过“Runnable”实现多线程！\n\n### **Thread和Runnable的多线程示例**\n\n\n\n#### Thread的多线程示例\n\n```\nclass MyThread extends Thread{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i<20;i++){ \n            if(this.ticket>0){\n                System.out.println(this.getName()+\" 卖票：ticket\"+this.ticket--);\n            }\n        }\n    } \n};\n\npublic class ThreadTest {  \n    public static void main(String[] args) {  \n        // 创建3个线程,每个线程各卖10张票！\n        MyThread t1=new MyThread();\n        MyThread t2=new MyThread();\n        MyThread t3=new MyThread();\n        //启动线程，开始运行\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n```\n\n#### **Runnable的多线程示例**\n\n```\n// 实现Runnable接口\nclass MyThread implements Runnable{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i<20;i++){ \n            if(this.ticket>0){\n                System.out.println(Thread.currentThread().getName()\n                 +\" 卖票：ticket\"+this.ticket--);\n            }\n        }\n    } \n}; \n\npublic class RunnableTest {  \n    public static void main(String[] args) {  \n    \n        //创建实现了Runnable接口的对象\n        MyThread mt=new MyThread();\n\n        // 创建3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！\n        Thread t1=new Thread(mt);\n        Thread t2=new Thread(mt);\n        Thread t3=new Thread(mt);\n        //启动3个线程\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n```\n\n**结果说明**： \n\n1.  和上面“MyThread继承于Thread”不同；这里的MyThread实现了Runnable接口。 \n\n2.  主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。\n\n#### 注意的是:上面不是线程安全的操作\n\n### 3. Thread中start()和run()的区别\n\n**start()** : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。\n\n **run()**   : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！\n\n后面会将Thread类的源码拿出来单独解析说明。这里只是简单的提一下。","slug":"java多线程系列 01基本概念以及实现方式","published":1,"updated":"2019-01-04T01:48:59.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxwtv0006eb1uxmbju8jc","content":"<h1 id=\"java-多线程的基本概念以及实现方式\"><a href=\"#java-多线程的基本概念以及实现方式\" class=\"headerlink\" title=\"java 多线程的基本概念以及实现方式\"></a>java 多线程的基本概念以及实现方式</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><ol>\n<li>线程的基本概念</li>\n<li>常用的实现多线程的方式</li>\n<li>Thread中start()和run()的区别</li>\n</ol>\n<h3 id=\"1-线程的基本概念\"><a href=\"#1-线程的基本概念\" class=\"headerlink\" title=\"1. 线程的基本概念\"></a>1. 线程的基本概念</h3><p>线程状态图</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18152411-a974ea82ebc04e72bd874c3921f8bfec.jpg\" alt=\"\"></p>\n<p><strong>说明</strong>：<br>线程共包括以下5种状态。</p>\n<ol>\n<li><strong>新建状态(New)</strong>         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</li>\n<li><strong>就绪状态(Runnable)</strong>: 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li>\n<li><strong>运行状态(Running)</strong> : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li>\n<li><strong>阻塞状态(Blocked)</strong>  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ol>\n<li>等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li>\n<li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li>\n<li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>\n</ol>\n</li>\n<li><strong>死亡状态(Dead)</strong>    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。需要注意的是，<strong>线程一旦进入死亡状态就不能在调用start()方法来让线程恢复运行。</strong><br>这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。这些内容我们会在后面的章节中逐个进行学习。</li>\n</ol>\n<p><strong>Object类</strong>，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。<br><strong>Thread类</strong>，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。<br><strong>synchronized</strong>，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。<br>在后面详细介绍wait(),notify()等方法时，我们会分析为什么<strong>wait(), notify()等方法要定义在Object类，而不是Thread类中</strong>。</p>\n<h3 id=\"2-常用的实现多线程的方式\"><a href=\"#2-常用的实现多线程的方式\" class=\"headerlink\" title=\"2. 常用的实现多线程的方式\"></a>2. 常用的实现多线程的方式</h3><p>常用的主要有俩种：Thread类 和Runnable接口</p>\n<h3 id=\"Thread和Runnable简介\"><a href=\"#Thread和Runnable简介\" class=\"headerlink\" title=\"Thread和Runnable简介\"></a><strong>Thread和Runnable简介</strong></h3><p><strong>Runnable</strong> 是一个接口，该接口中只包含了一个run()方法。它的定义如下：</p>\n<pre><code>public interface Runnable {\n    public abstract void run();\n}\n</code></pre><p>Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；</p>\n<p>然后，通过<code>new Thread(new A())</code>等方式新建线程。</p>\n<p><strong>Thread</strong> 是一个类。Thread本身就实现了Runnable接口。它的声明如下：</p>\n<pre><code>public class Thread implements Runnable {\n\n}\n</code></pre><p>Thread的作用，实现多线程。</p>\n<h3 id=\"Thread和Runnable的异同点\"><a href=\"#Thread和Runnable的异同点\" class=\"headerlink\" title=\"Thread和Runnable的异同点\"></a><strong>Thread和Runnable的异同点</strong></h3><p><strong>Thread 和 Runnable 的相同点</strong>：都是“多线程的实现方式”。</p>\n<p> <strong>Thread 和 Runnable 的不同点</strong>： Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。</p>\n<p> 此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。 </p>\n<p>通常，建议通过“Runnable”实现多线程！</p>\n<h3 id=\"Thread和Runnable的多线程示例\"><a href=\"#Thread和Runnable的多线程示例\" class=\"headerlink\" title=\"Thread和Runnable的多线程示例\"></a><strong>Thread和Runnable的多线程示例</strong></h3><h4 id=\"Thread的多线程示例\"><a href=\"#Thread的多线程示例\" class=\"headerlink\" title=\"Thread的多线程示例\"></a>Thread的多线程示例</h4><pre><code>class MyThread extends Thread{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i&lt;20;i++){ \n            if(this.ticket&gt;0){\n                System.out.println(this.getName()+&quot; 卖票：ticket&quot;+this.ticket--);\n            }\n        }\n    } \n};\n\npublic class ThreadTest {  \n    public static void main(String[] args) {  \n        // 创建3个线程,每个线程各卖10张票！\n        MyThread t1=new MyThread();\n        MyThread t2=new MyThread();\n        MyThread t3=new MyThread();\n        //启动线程，开始运行\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n</code></pre><h4 id=\"Runnable的多线程示例\"><a href=\"#Runnable的多线程示例\" class=\"headerlink\" title=\"Runnable的多线程示例\"></a><strong>Runnable的多线程示例</strong></h4><pre><code>// 实现Runnable接口\nclass MyThread implements Runnable{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i&lt;20;i++){ \n            if(this.ticket&gt;0){\n                System.out.println(Thread.currentThread().getName()\n                 +&quot; 卖票：ticket&quot;+this.ticket--);\n            }\n        }\n    } \n}; \n\npublic class RunnableTest {  \n    public static void main(String[] args) {  \n\n        //创建实现了Runnable接口的对象\n        MyThread mt=new MyThread();\n\n        // 创建3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！\n        Thread t1=new Thread(mt);\n        Thread t2=new Thread(mt);\n        Thread t3=new Thread(mt);\n        //启动3个线程\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n</code></pre><p><strong>结果说明</strong>： </p>\n<ol>\n<li><p>和上面“MyThread继承于Thread”不同；这里的MyThread实现了Runnable接口。 </p>\n</li>\n<li><p>主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。</p>\n</li>\n</ol>\n<h4 id=\"注意的是-上面不是线程安全的操作\"><a href=\"#注意的是-上面不是线程安全的操作\" class=\"headerlink\" title=\"注意的是:上面不是线程安全的操作\"></a>注意的是:上面不是线程安全的操作</h4><h3 id=\"3-Thread中start-和run-的区别\"><a href=\"#3-Thread中start-和run-的区别\" class=\"headerlink\" title=\"3. Thread中start()和run()的区别\"></a>3. Thread中start()和run()的区别</h3><p><strong>start()</strong> : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。</p>\n<p> <strong>run()</strong>   : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！</p>\n<p>后面会将Thread类的源码拿出来单独解析说明。这里只是简单的提一下。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java-多线程的基本概念以及实现方式\"><a href=\"#java-多线程的基本概念以及实现方式\" class=\"headerlink\" title=\"java 多线程的基本概念以及实现方式\"></a>java 多线程的基本概念以及实现方式</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><ol>\n<li>线程的基本概念</li>\n<li>常用的实现多线程的方式</li>\n<li>Thread中start()和run()的区别</li>\n</ol>\n<h3 id=\"1-线程的基本概念\"><a href=\"#1-线程的基本概念\" class=\"headerlink\" title=\"1. 线程的基本概念\"></a>1. 线程的基本概念</h3><p>线程状态图</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18152411-a974ea82ebc04e72bd874c3921f8bfec.jpg\" alt=\"\"></p>\n<p><strong>说明</strong>：<br>线程共包括以下5种状态。</p>\n<ol>\n<li><strong>新建状态(New)</strong>         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</li>\n<li><strong>就绪状态(Runnable)</strong>: 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li>\n<li><strong>运行状态(Running)</strong> : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li>\n<li><strong>阻塞状态(Blocked)</strong>  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ol>\n<li>等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li>\n<li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li>\n<li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>\n</ol>\n</li>\n<li><strong>死亡状态(Dead)</strong>    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。需要注意的是，<strong>线程一旦进入死亡状态就不能在调用start()方法来让线程恢复运行。</strong><br>这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。这些内容我们会在后面的章节中逐个进行学习。</li>\n</ol>\n<p><strong>Object类</strong>，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。<br><strong>Thread类</strong>，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。<br><strong>synchronized</strong>，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。<br>在后面详细介绍wait(),notify()等方法时，我们会分析为什么<strong>wait(), notify()等方法要定义在Object类，而不是Thread类中</strong>。</p>\n<h3 id=\"2-常用的实现多线程的方式\"><a href=\"#2-常用的实现多线程的方式\" class=\"headerlink\" title=\"2. 常用的实现多线程的方式\"></a>2. 常用的实现多线程的方式</h3><p>常用的主要有俩种：Thread类 和Runnable接口</p>\n<h3 id=\"Thread和Runnable简介\"><a href=\"#Thread和Runnable简介\" class=\"headerlink\" title=\"Thread和Runnable简介\"></a><strong>Thread和Runnable简介</strong></h3><p><strong>Runnable</strong> 是一个接口，该接口中只包含了一个run()方法。它的定义如下：</p>\n<pre><code>public interface Runnable {\n    public abstract void run();\n}\n</code></pre><p>Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；</p>\n<p>然后，通过<code>new Thread(new A())</code>等方式新建线程。</p>\n<p><strong>Thread</strong> 是一个类。Thread本身就实现了Runnable接口。它的声明如下：</p>\n<pre><code>public class Thread implements Runnable {\n\n}\n</code></pre><p>Thread的作用，实现多线程。</p>\n<h3 id=\"Thread和Runnable的异同点\"><a href=\"#Thread和Runnable的异同点\" class=\"headerlink\" title=\"Thread和Runnable的异同点\"></a><strong>Thread和Runnable的异同点</strong></h3><p><strong>Thread 和 Runnable 的相同点</strong>：都是“多线程的实现方式”。</p>\n<p> <strong>Thread 和 Runnable 的不同点</strong>： Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。</p>\n<p> 此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。 </p>\n<p>通常，建议通过“Runnable”实现多线程！</p>\n<h3 id=\"Thread和Runnable的多线程示例\"><a href=\"#Thread和Runnable的多线程示例\" class=\"headerlink\" title=\"Thread和Runnable的多线程示例\"></a><strong>Thread和Runnable的多线程示例</strong></h3><h4 id=\"Thread的多线程示例\"><a href=\"#Thread的多线程示例\" class=\"headerlink\" title=\"Thread的多线程示例\"></a>Thread的多线程示例</h4><pre><code>class MyThread extends Thread{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i&lt;20;i++){ \n            if(this.ticket&gt;0){\n                System.out.println(this.getName()+&quot; 卖票：ticket&quot;+this.ticket--);\n            }\n        }\n    } \n};\n\npublic class ThreadTest {  \n    public static void main(String[] args) {  \n        // 创建3个线程,每个线程各卖10张票！\n        MyThread t1=new MyThread();\n        MyThread t2=new MyThread();\n        MyThread t3=new MyThread();\n        //启动线程，开始运行\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n</code></pre><h4 id=\"Runnable的多线程示例\"><a href=\"#Runnable的多线程示例\" class=\"headerlink\" title=\"Runnable的多线程示例\"></a><strong>Runnable的多线程示例</strong></h4><pre><code>// 实现Runnable接口\nclass MyThread implements Runnable{  \n    private int ticket=10;  \n    public void run(){\n        for(int i=0;i&lt;20;i++){ \n            if(this.ticket&gt;0){\n                System.out.println(Thread.currentThread().getName()\n                 +&quot; 卖票：ticket&quot;+this.ticket--);\n            }\n        }\n    } \n}; \n\npublic class RunnableTest {  \n    public static void main(String[] args) {  \n\n        //创建实现了Runnable接口的对象\n        MyThread mt=new MyThread();\n\n        // 创建3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！\n        Thread t1=new Thread(mt);\n        Thread t2=new Thread(mt);\n        Thread t3=new Thread(mt);\n        //启动3个线程\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n</code></pre><p><strong>结果说明</strong>： </p>\n<ol>\n<li><p>和上面“MyThread继承于Thread”不同；这里的MyThread实现了Runnable接口。 </p>\n</li>\n<li><p>主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。</p>\n</li>\n</ol>\n<h4 id=\"注意的是-上面不是线程安全的操作\"><a href=\"#注意的是-上面不是线程安全的操作\" class=\"headerlink\" title=\"注意的是:上面不是线程安全的操作\"></a>注意的是:上面不是线程安全的操作</h4><h3 id=\"3-Thread中start-和run-的区别\"><a href=\"#3-Thread中start-和run-的区别\" class=\"headerlink\" title=\"3. Thread中start()和run()的区别\"></a>3. Thread中start()和run()的区别</h3><p><strong>start()</strong> : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。</p>\n<p> <strong>run()</strong>   : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！</p>\n<p>后面会将Thread类的源码拿出来单独解析说明。这里只是简单的提一下。</p>\n"},{"abbrlink":3,"title":"java多线程系列 06  线程优先级和守护线程","author":"zhangke","date":"2018-07-13T03:16:00.000Z","_content":"# java多线程系列 06  线程优先级和守护线程\n\n### **概要**\n\n> 1. 线程优先级的介绍\n> 2. 线程优先级的示例\n> 3. 守护线程的示例\n\n### **1. 线程优先级的介绍**\n\n> java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。\n>\n> java 中有两种线程：**用户线程**和**守护线程**。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。\n> 用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。\n>\n> JDK 中关于线程优先级和守护线程的介绍如下：\n>\n> ```\n> Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.\n> \n> When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:\n> \n> The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.\n> All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. \n> Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.\n> ```\n>\n> 大致意思是：\n>\n> ```\n> 每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。\n> \n> 当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：\n> (01) 调用了exit()方法，并且exit()有权限被正常执行。\n> (02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。\n> \n> 每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。\n> ```\n>\n> \n>\n>  \n\n### **2. 线程优先级的示例**\n\n我们先看看优先级的示例 \n\n```\nclass MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        for (int i=0; i<5; i++) {\n            System.out.println(Thread.currentThread().getName()\n                    +\"(\"+Thread.currentThread().getPriority()+ \")\"\n                    +\", loop \"+i);\n        }\n    } \n}; \n\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +\"(\"+Thread.currentThread().getPriority()+ \")\");\n\n        Thread t1=new MyThread(\"t1\");    // 新建t1\n        Thread t2=new MyThread(\"t2\");    // 新建t2\n        t1.setPriority(1);                // 设置t1的优先级为1\n        t2.setPriority(10);                // 设置t2的优先级为10\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}\n```\n\n**运行结果**：\n\n```\nmain(5)\nt1(1), loop 0\nt2(10), loop 0\nt1(1), loop 1\nt2(10), loop 1\nt1(1), loop 2\nt2(10), loop 2\nt1(1), loop 3\nt2(10), loop 3\nt1(1), loop 4\nt2(10), loop 4\n```\n\n**结果说明**：\n(01) 主线程main的优先级是5。\n(02) t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。\n\n### **3. 守护线程的示例**\n\n下面是守护线程的示例。\n\n```\n// Demo.java\nclass MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i<5; i++) {\n                Thread.sleep(3);\n                System.out.println(this.getName() \n                \t\t\t+\"(isDaemon=\"+this.isDaemon()+ \")\" \n                \t\t\t+\", loop \"+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}; \n\nclass MyDaemon extends Thread{  \n    public MyDaemon(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i<10000; i++) {\n                Thread.sleep(1);\n                System.out.println(this.getName() +\"(isDaemon=\"+this.isDaemon()+\n                \t\t\")\" +\", loop \"+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +\"(isDaemon=\"+Thread.currentThread().isDaemon()+ \")\");\n\n        Thread t1=new MyThread(\"t1\");    // 新建t1\n        Thread t2=new MyDaemon(\"t2\");    // 新建t2\n        t2.setDaemon(true);                // 设置t2为守护线程\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}=\n```\n\n**运行结果**：\n\n```\nmain(isDaemon=false)\nt2(isDaemon=true), loop 0\nt2(isDaemon=true), loop 1\nt1(isDaemon=false), loop 0\nt2(isDaemon=true), loop 2\nt2(isDaemon=true), loop 3\nt1(isDaemon=false), loop 1\nt2(isDaemon=true), loop 4\nt2(isDaemon=true), loop 5\nt2(isDaemon=true), loop 6\nt1(isDaemon=false), loop 2\nt2(isDaemon=true), loop 7\nt2(isDaemon=true), loop 8\nt2(isDaemon=true), loop 9\nt1(isDaemon=false), loop 3\nt2(isDaemon=true), loop 10\nt2(isDaemon=true), loop 11\nt1(isDaemon=false), loop 4\nt2(isDaemon=true), loop 12\n```\n\n**结果说明**：\n(01) 主线程main是用户线程，它创建的子线程t1也是用户线程。\n(02) t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。\n\n ","source":"_posts/java多线程系列 06  线程优先级和守护线程.md","raw":"abbrlink: 3\ntitle: java多线程系列 06  线程优先级和守护线程\ntags:\n\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-13 11:16:00\n---\n# java多线程系列 06  线程优先级和守护线程\n\n### **概要**\n\n> 1. 线程优先级的介绍\n> 2. 线程优先级的示例\n> 3. 守护线程的示例\n\n### **1. 线程优先级的介绍**\n\n> java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。\n>\n> java 中有两种线程：**用户线程**和**守护线程**。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。\n> 用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。\n>\n> JDK 中关于线程优先级和守护线程的介绍如下：\n>\n> ```\n> Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.\n> \n> When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:\n> \n> The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.\n> All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. \n> Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.\n> ```\n>\n> 大致意思是：\n>\n> ```\n> 每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。\n> \n> 当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：\n> (01) 调用了exit()方法，并且exit()有权限被正常执行。\n> (02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。\n> \n> 每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。\n> ```\n>\n> \n>\n>  \n\n### **2. 线程优先级的示例**\n\n我们先看看优先级的示例 \n\n```\nclass MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        for (int i=0; i<5; i++) {\n            System.out.println(Thread.currentThread().getName()\n                    +\"(\"+Thread.currentThread().getPriority()+ \")\"\n                    +\", loop \"+i);\n        }\n    } \n}; \n\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +\"(\"+Thread.currentThread().getPriority()+ \")\");\n\n        Thread t1=new MyThread(\"t1\");    // 新建t1\n        Thread t2=new MyThread(\"t2\");    // 新建t2\n        t1.setPriority(1);                // 设置t1的优先级为1\n        t2.setPriority(10);                // 设置t2的优先级为10\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}\n```\n\n**运行结果**：\n\n```\nmain(5)\nt1(1), loop 0\nt2(10), loop 0\nt1(1), loop 1\nt2(10), loop 1\nt1(1), loop 2\nt2(10), loop 2\nt1(1), loop 3\nt2(10), loop 3\nt1(1), loop 4\nt2(10), loop 4\n```\n\n**结果说明**：\n(01) 主线程main的优先级是5。\n(02) t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。\n\n### **3. 守护线程的示例**\n\n下面是守护线程的示例。\n\n```\n// Demo.java\nclass MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i<5; i++) {\n                Thread.sleep(3);\n                System.out.println(this.getName() \n                \t\t\t+\"(isDaemon=\"+this.isDaemon()+ \")\" \n                \t\t\t+\", loop \"+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}; \n\nclass MyDaemon extends Thread{  \n    public MyDaemon(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i<10000; i++) {\n                Thread.sleep(1);\n                System.out.println(this.getName() +\"(isDaemon=\"+this.isDaemon()+\n                \t\t\")\" +\", loop \"+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +\"(isDaemon=\"+Thread.currentThread().isDaemon()+ \")\");\n\n        Thread t1=new MyThread(\"t1\");    // 新建t1\n        Thread t2=new MyDaemon(\"t2\");    // 新建t2\n        t2.setDaemon(true);                // 设置t2为守护线程\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}=\n```\n\n**运行结果**：\n\n```\nmain(isDaemon=false)\nt2(isDaemon=true), loop 0\nt2(isDaemon=true), loop 1\nt1(isDaemon=false), loop 0\nt2(isDaemon=true), loop 2\nt2(isDaemon=true), loop 3\nt1(isDaemon=false), loop 1\nt2(isDaemon=true), loop 4\nt2(isDaemon=true), loop 5\nt2(isDaemon=true), loop 6\nt1(isDaemon=false), loop 2\nt2(isDaemon=true), loop 7\nt2(isDaemon=true), loop 8\nt2(isDaemon=true), loop 9\nt1(isDaemon=false), loop 3\nt2(isDaemon=true), loop 10\nt2(isDaemon=true), loop 11\nt1(isDaemon=false), loop 4\nt2(isDaemon=true), loop 12\n```\n\n**结果说明**：\n(01) 主线程main是用户线程，它创建的子线程t1也是用户线程。\n(02) t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。\n\n ","slug":"java多线程系列 06  线程优先级和守护线程","published":1,"updated":"2019-01-04T01:48:59.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxwtx0008eb1uartitfbx","content":"<h1 id=\"java多线程系列-06-线程优先级和守护线程\"><a href=\"#java多线程系列-06-线程优先级和守护线程\" class=\"headerlink\" title=\"java多线程系列 06  线程优先级和守护线程\"></a>java多线程系列 06  线程优先级和守护线程</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a><strong>概要</strong></h3><blockquote>\n<ol>\n<li>线程优先级的介绍</li>\n<li>线程优先级的示例</li>\n<li>守护线程的示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程优先级的介绍\"><a href=\"#1-线程优先级的介绍\" class=\"headerlink\" title=\"1. 线程优先级的介绍\"></a><strong>1. 线程优先级的介绍</strong></h3><blockquote>\n<p>java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。</p>\n<p>java 中有两种线程：<strong>用户线程</strong>和<strong>守护线程</strong>。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。<br>用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。</p>\n<p>JDK 中关于线程优先级和守护线程的介绍如下：</p>\n<pre><code>Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.\n\nWhen a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:\n\nThe exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.\nAll threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. \nMarks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.\n</code></pre><p>大致意思是：</p>\n<pre><code>每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。\n\n当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：\n(01) 调用了exit()方法，并且exit()有权限被正常执行。\n(02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。\n\n每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。\n</code></pre></blockquote>\n<h3 id=\"2-线程优先级的示例\"><a href=\"#2-线程优先级的示例\" class=\"headerlink\" title=\"2. 线程优先级的示例\"></a><strong>2. 线程优先级的示例</strong></h3><p>我们先看看优先级的示例 </p>\n<pre><code>class MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        for (int i=0; i&lt;5; i++) {\n            System.out.println(Thread.currentThread().getName()\n                    +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot;\n                    +&quot;, loop &quot;+i);\n        }\n    } \n}; \n\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot;);\n\n        Thread t1=new MyThread(&quot;t1&quot;);    // 新建t1\n        Thread t2=new MyThread(&quot;t2&quot;);    // 新建t2\n        t1.setPriority(1);                // 设置t1的优先级为1\n        t2.setPriority(10);                // 设置t2的优先级为10\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>main(5)\nt1(1), loop 0\nt2(10), loop 0\nt1(1), loop 1\nt2(10), loop 1\nt1(1), loop 2\nt2(10), loop 2\nt1(1), loop 3\nt2(10), loop 3\nt1(1), loop 4\nt2(10), loop 4\n</code></pre><p><strong>结果说明</strong>：<br>(01) 主线程main的优先级是5。<br>(02) t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。</p>\n<h3 id=\"3-守护线程的示例\"><a href=\"#3-守护线程的示例\" class=\"headerlink\" title=\"3. 守护线程的示例\"></a><strong>3. 守护线程的示例</strong></h3><p>下面是守护线程的示例。</p>\n<pre><code>// Demo.java\nclass MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i&lt;5; i++) {\n                Thread.sleep(3);\n                System.out.println(this.getName() \n                            +&quot;(isDaemon=&quot;+this.isDaemon()+ &quot;)&quot; \n                            +&quot;, loop &quot;+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}; \n\nclass MyDaemon extends Thread{  \n    public MyDaemon(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i&lt;10000; i++) {\n                Thread.sleep(1);\n                System.out.println(this.getName() +&quot;(isDaemon=&quot;+this.isDaemon()+\n                        &quot;)&quot; +&quot;, loop &quot;+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +&quot;(isDaemon=&quot;+Thread.currentThread().isDaemon()+ &quot;)&quot;);\n\n        Thread t1=new MyThread(&quot;t1&quot;);    // 新建t1\n        Thread t2=new MyDaemon(&quot;t2&quot;);    // 新建t2\n        t2.setDaemon(true);                // 设置t2为守护线程\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}=\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>main(isDaemon=false)\nt2(isDaemon=true), loop 0\nt2(isDaemon=true), loop 1\nt1(isDaemon=false), loop 0\nt2(isDaemon=true), loop 2\nt2(isDaemon=true), loop 3\nt1(isDaemon=false), loop 1\nt2(isDaemon=true), loop 4\nt2(isDaemon=true), loop 5\nt2(isDaemon=true), loop 6\nt1(isDaemon=false), loop 2\nt2(isDaemon=true), loop 7\nt2(isDaemon=true), loop 8\nt2(isDaemon=true), loop 9\nt1(isDaemon=false), loop 3\nt2(isDaemon=true), loop 10\nt2(isDaemon=true), loop 11\nt1(isDaemon=false), loop 4\nt2(isDaemon=true), loop 12\n</code></pre><p><strong>结果说明</strong>：<br>(01) 主线程main是用户线程，它创建的子线程t1也是用户线程。<br>(02) t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-06-线程优先级和守护线程\"><a href=\"#java多线程系列-06-线程优先级和守护线程\" class=\"headerlink\" title=\"java多线程系列 06  线程优先级和守护线程\"></a>java多线程系列 06  线程优先级和守护线程</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a><strong>概要</strong></h3><blockquote>\n<ol>\n<li>线程优先级的介绍</li>\n<li>线程优先级的示例</li>\n<li>守护线程的示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程优先级的介绍\"><a href=\"#1-线程优先级的介绍\" class=\"headerlink\" title=\"1. 线程优先级的介绍\"></a><strong>1. 线程优先级的介绍</strong></h3><blockquote>\n<p>java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。</p>\n<p>java 中有两种线程：<strong>用户线程</strong>和<strong>守护线程</strong>。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。<br>用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。</p>\n<p>JDK 中关于线程优先级和守护线程的介绍如下：</p>\n<pre><code>Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.\n\nWhen a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:\n\nThe exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.\nAll threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. \nMarks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.\n</code></pre><p>大致意思是：</p>\n<pre><code>每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。\n\n当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：\n(01) 调用了exit()方法，并且exit()有权限被正常执行。\n(02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。\n\n每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。\n</code></pre></blockquote>\n<h3 id=\"2-线程优先级的示例\"><a href=\"#2-线程优先级的示例\" class=\"headerlink\" title=\"2. 线程优先级的示例\"></a><strong>2. 线程优先级的示例</strong></h3><p>我们先看看优先级的示例 </p>\n<pre><code>class MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        for (int i=0; i&lt;5; i++) {\n            System.out.println(Thread.currentThread().getName()\n                    +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot;\n                    +&quot;, loop &quot;+i);\n        }\n    } \n}; \n\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot;);\n\n        Thread t1=new MyThread(&quot;t1&quot;);    // 新建t1\n        Thread t2=new MyThread(&quot;t2&quot;);    // 新建t2\n        t1.setPriority(1);                // 设置t1的优先级为1\n        t2.setPriority(10);                // 设置t2的优先级为10\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>main(5)\nt1(1), loop 0\nt2(10), loop 0\nt1(1), loop 1\nt2(10), loop 1\nt1(1), loop 2\nt2(10), loop 2\nt1(1), loop 3\nt2(10), loop 3\nt1(1), loop 4\nt2(10), loop 4\n</code></pre><p><strong>结果说明</strong>：<br>(01) 主线程main的优先级是5。<br>(02) t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。</p>\n<h3 id=\"3-守护线程的示例\"><a href=\"#3-守护线程的示例\" class=\"headerlink\" title=\"3. 守护线程的示例\"></a><strong>3. 守护线程的示例</strong></h3><p>下面是守护线程的示例。</p>\n<pre><code>// Demo.java\nclass MyThread extends Thread{  \n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i&lt;5; i++) {\n                Thread.sleep(3);\n                System.out.println(this.getName() \n                            +&quot;(isDaemon=&quot;+this.isDaemon()+ &quot;)&quot; \n                            +&quot;, loop &quot;+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}; \n\nclass MyDaemon extends Thread{  \n    public MyDaemon(String name) {\n        super(name);\n    }\n\n    public void run(){\n        try {\n            for (int i=0; i&lt;10000; i++) {\n                Thread.sleep(1);\n                System.out.println(this.getName() +&quot;(isDaemon=&quot;+this.isDaemon()+\n                        &quot;)&quot; +&quot;, loop &quot;+i);\n            }\n        } catch (InterruptedException e) {\n        }\n    } \n}\npublic class Demo {  \n    public static void main(String[] args) {  \n\n        System.out.println(Thread.currentThread().getName()\n                +&quot;(isDaemon=&quot;+Thread.currentThread().isDaemon()+ &quot;)&quot;);\n\n        Thread t1=new MyThread(&quot;t1&quot;);    // 新建t1\n        Thread t2=new MyDaemon(&quot;t2&quot;);    // 新建t2\n        t2.setDaemon(true);                // 设置t2为守护线程\n        t1.start();                        // 启动t1\n        t2.start();                        // 启动t2\n    }  \n}=\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>main(isDaemon=false)\nt2(isDaemon=true), loop 0\nt2(isDaemon=true), loop 1\nt1(isDaemon=false), loop 0\nt2(isDaemon=true), loop 2\nt2(isDaemon=true), loop 3\nt1(isDaemon=false), loop 1\nt2(isDaemon=true), loop 4\nt2(isDaemon=true), loop 5\nt2(isDaemon=true), loop 6\nt1(isDaemon=false), loop 2\nt2(isDaemon=true), loop 7\nt2(isDaemon=true), loop 8\nt2(isDaemon=true), loop 9\nt1(isDaemon=false), loop 3\nt2(isDaemon=true), loop 10\nt2(isDaemon=true), loop 11\nt1(isDaemon=false), loop 4\nt2(isDaemon=true), loop 12\n</code></pre><p><strong>结果说明</strong>：<br>(01) 主线程main是用户线程，它创建的子线程t1也是用户线程。<br>(02) t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。</p>\n"},{"abbrlink":8,"title":"java多线程系列 08 ThreadLocal","author":"zhangke","date":"2018-07-13T08:50:00.000Z","_content":"# java多线程系列之 08 ThreadLocal\n\n### 概要\n\n>1. ThreadLocal介绍\n>2. 基本用法\n>3. ThreadLocal引起的内存泄漏\n\n### ThreadLocal 介绍\n\n>ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被GC。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal通常定义为`private static`类型。\n\n### 2. 基本用法\n\n>```\n>public class ThreadLocalTest {\n>    public static void main(String[] args) {\n>        for (int i = 0; i < 10; i++) {\n>            new Thread() {\n>                public void run() {\n>                    ThreadId id = new ThreadId();\n>                    System.out.println(id.get());\n>                }\n>            }.start();\n>        }\n>    }\n>}\n>class ThreadId {\n>    // Atomic integer containing the next thread ID to be assigned\n>    private static final AtomicInteger nextId = new AtomicInteger(0);\n>\n>    // Thread local variable containing each thread's ID\n>    private static final ThreadLocal<Integer> threadId =\n>        new ThreadLocal<Integer>() {\n>            @Override\n>            protected Integer initialValue() {\n>                return nextId.getAndIncrement();\n>            }\n>        };\n>\n>    // Returns the current thread's unique ID, assigning it if necessary\n>    public int get() {\n>        return threadId.get();\n>    }\n>}\n>```\n>\n>运行结果：\n>\n>```\n>9\n>7\n>6\n>8\n>2\n>4\n>0\n>3\n>5\n>1\n>```\n>\n>虽然ThreadLocal对象时static的，但是由于是每个线程独有的，所以各自线程对应的ThreadLocal属性改变，不会影响其他线程的值，因此可以说是线程私有的。也正是因为此，上面的结果才是10个不一样的值。\n>\n>那么，在什么场景下比较适合使用ThreadLocal？stackoverflow上有人给出了还不错的回答。\n> [When and how should I use a ThreadLocal variable?](https://link.jianshu.com?t=http://stackoverflow.com/questions/817856/when-and-how-should-i-use-a-threadlocal-variable)\n> One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid synchronizing access to that object . Instead, give each thread its own instance of the object. \n>\n>\n\n## ThreadLocal引起的内存泄漏\n\n> `ThreadLocal` 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但是如果滥用`ThreadLocal`，就可能会导致内存泄漏。下面，我们将围绕三个方面来分析`ThreadLocal` 内存泄漏的问题\n>\n> - `ThreadLocal` 实现原理\n> - `ThreadLocal`为什么会内存泄漏\n> - `ThreadLocal` 最佳实践\n>\n> ## ThreadLocal 实现原理\n>\n> [![threadlocal](http://incdn1.b0.upaiyun.com/2016/10/2fdbd552107780c5ae5f98126b38d5a4.png)](http://www.importnew.com/?attachment_id=22042)\n>\n> ThreadLocal\n>\n> `ThreadLocal`的实现是这样的：每个`Thread` 维护一个 `ThreadLocalMap` 映射表，这个映射表的 `key` 是 `ThreadLocal`实例本身，`value` 是真正需要存储的 `Object`。\n>\n> 也就是说 `ThreadLocal` 本身并不存储值，它只是作为一个 `key` 来让线程从 `ThreadLocalMap` 获取 `value`。值得注意的是图中的虚线，表示 `ThreadLocalMap` 是使用 `ThreadLocal` 的弱引用作为 `Key` 的，弱引用的对象在 GC 时会被回收。\n>\n> ## `ThreadLocal`为什么会内存泄漏\n>\n> `ThreadLocalMap`使用`ThreadLocal`的弱引用作为`key`，如果一个`ThreadLocal`没有外部强引用来引用它，那么系统 GC 的时候，这个`ThreadLocal`势必会被回收，这样一来，`ThreadLocalMap`中就会出现`key`为`null`的`Entry`，就没有办法访问这些`key`为`null`的`Entry`的`value`，如果当前线程再迟迟不结束的话，这些`key`为`null`的`Entry`的`value`就会一直存在一条强引用链：`Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value`永远无法回收，造成内存泄漏。\n>\n> 其实，`ThreadLocalMap`的设计中已经考虑到这种情况，也加上了一些防护措施：在`ThreadLocal`的`get()`,`set()`,`remove()`的时候都会清除线程`ThreadLocalMap`里所有`key`为`null`的`value`。\n>\n> 但是这些被动的预防措施并不能保证不会内存泄漏：\n>\n> - 使用`static`的`ThreadLocal`，延长了`ThreadLocal`的生命周期，可能导致的内存泄漏（参考[ThreadLocal 内存泄露的实例分析](http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/)）。\n> - 分配使用了`ThreadLocal`又不再调用`get()`,`set()`,`remove()`方法，那么就会导致内存泄漏。\n>\n> ### 为什么使用弱引用\n>\n> 从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析`ThreadLocal`使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？\n>\n> 我们先来看看官方文档的说法：\n>\n> > To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.\n> > 为了应对非常大和长时间的用途，哈希表使用弱引用的 key。\n>\n> 下面我们分两种情况讨论：\n>\n> - **key 使用强引用**：引用的`ThreadLocal`的对象被回收了，但是`ThreadLocalMap`还持有`ThreadLocal`的强引用，如果没有手动删除，`ThreadLocal`不会被回收，导致`Entry`内存泄漏。\n> - **key 使用弱引用**：引用的`ThreadLocal`的对象被回收了，由于`ThreadLocalMap`持有`ThreadLocal`的弱引用，即使没有手动删除，`ThreadLocal`也会被回收。`value`在下一次`ThreadLocalMap`调用`set`,`get`，`remove`的时候会被清除。\n>\n> 比较两种情况，我们可以发现：由于`ThreadLocalMap`的生命周期跟`Thread`一样长，如果都没有手动删除对应`key`，都会导致内存泄漏，但是使用弱引用可以多一层保障：**弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除**。\n>\n> 因此，`ThreadLocal`内存泄漏的根源是：由于`ThreadLocalMap`的生命周期跟`Thread`一样长，如果没有手动删除对应`key`就会导致内存泄漏，而不是因为弱引用。\n>\n> ## ThreadLocal 最佳实践\n>\n> 综合上面的分析，我们可以理解`ThreadLocal`内存泄漏的前因后果，那么怎么避免内存泄漏呢？\n>\n> - 每次使用完`ThreadLocal`，都调用它的`remove()`方法，清除数据。\n>\n> 在使用线程池的情况下，没有及时清理`ThreadLocal`，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用`ThreadLocal`就跟加锁完要解锁一样，用完就清理。\n\n参考文章\n\n[深入分析 ThreadLocal 内存泄漏问题](http://www.importnew.com/22039.html)\n\n[ThreadLocal 内存泄露的实例分析](http://www.importnew.com/22046.html)\n\n[ThreadLocal内存泄露](http://www.importnew.com/22480.html)\n\n\n\n\n\n","source":"_posts/java多线程系列之 08 ThreadLocal.md","raw":"abbrlink: 8\ntitle: java多线程系列 08 ThreadLocal\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-13 16:50:00\n---\n# java多线程系列之 08 ThreadLocal\n\n### 概要\n\n>1. ThreadLocal介绍\n>2. 基本用法\n>3. ThreadLocal引起的内存泄漏\n\n### ThreadLocal 介绍\n\n>ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被GC。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal通常定义为`private static`类型。\n\n### 2. 基本用法\n\n>```\n>public class ThreadLocalTest {\n>    public static void main(String[] args) {\n>        for (int i = 0; i < 10; i++) {\n>            new Thread() {\n>                public void run() {\n>                    ThreadId id = new ThreadId();\n>                    System.out.println(id.get());\n>                }\n>            }.start();\n>        }\n>    }\n>}\n>class ThreadId {\n>    // Atomic integer containing the next thread ID to be assigned\n>    private static final AtomicInteger nextId = new AtomicInteger(0);\n>\n>    // Thread local variable containing each thread's ID\n>    private static final ThreadLocal<Integer> threadId =\n>        new ThreadLocal<Integer>() {\n>            @Override\n>            protected Integer initialValue() {\n>                return nextId.getAndIncrement();\n>            }\n>        };\n>\n>    // Returns the current thread's unique ID, assigning it if necessary\n>    public int get() {\n>        return threadId.get();\n>    }\n>}\n>```\n>\n>运行结果：\n>\n>```\n>9\n>7\n>6\n>8\n>2\n>4\n>0\n>3\n>5\n>1\n>```\n>\n>虽然ThreadLocal对象时static的，但是由于是每个线程独有的，所以各自线程对应的ThreadLocal属性改变，不会影响其他线程的值，因此可以说是线程私有的。也正是因为此，上面的结果才是10个不一样的值。\n>\n>那么，在什么场景下比较适合使用ThreadLocal？stackoverflow上有人给出了还不错的回答。\n> [When and how should I use a ThreadLocal variable?](https://link.jianshu.com?t=http://stackoverflow.com/questions/817856/when-and-how-should-i-use-a-threadlocal-variable)\n> One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid synchronizing access to that object . Instead, give each thread its own instance of the object. \n>\n>\n\n## ThreadLocal引起的内存泄漏\n\n> `ThreadLocal` 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但是如果滥用`ThreadLocal`，就可能会导致内存泄漏。下面，我们将围绕三个方面来分析`ThreadLocal` 内存泄漏的问题\n>\n> - `ThreadLocal` 实现原理\n> - `ThreadLocal`为什么会内存泄漏\n> - `ThreadLocal` 最佳实践\n>\n> ## ThreadLocal 实现原理\n>\n> [![threadlocal](http://incdn1.b0.upaiyun.com/2016/10/2fdbd552107780c5ae5f98126b38d5a4.png)](http://www.importnew.com/?attachment_id=22042)\n>\n> ThreadLocal\n>\n> `ThreadLocal`的实现是这样的：每个`Thread` 维护一个 `ThreadLocalMap` 映射表，这个映射表的 `key` 是 `ThreadLocal`实例本身，`value` 是真正需要存储的 `Object`。\n>\n> 也就是说 `ThreadLocal` 本身并不存储值，它只是作为一个 `key` 来让线程从 `ThreadLocalMap` 获取 `value`。值得注意的是图中的虚线，表示 `ThreadLocalMap` 是使用 `ThreadLocal` 的弱引用作为 `Key` 的，弱引用的对象在 GC 时会被回收。\n>\n> ## `ThreadLocal`为什么会内存泄漏\n>\n> `ThreadLocalMap`使用`ThreadLocal`的弱引用作为`key`，如果一个`ThreadLocal`没有外部强引用来引用它，那么系统 GC 的时候，这个`ThreadLocal`势必会被回收，这样一来，`ThreadLocalMap`中就会出现`key`为`null`的`Entry`，就没有办法访问这些`key`为`null`的`Entry`的`value`，如果当前线程再迟迟不结束的话，这些`key`为`null`的`Entry`的`value`就会一直存在一条强引用链：`Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value`永远无法回收，造成内存泄漏。\n>\n> 其实，`ThreadLocalMap`的设计中已经考虑到这种情况，也加上了一些防护措施：在`ThreadLocal`的`get()`,`set()`,`remove()`的时候都会清除线程`ThreadLocalMap`里所有`key`为`null`的`value`。\n>\n> 但是这些被动的预防措施并不能保证不会内存泄漏：\n>\n> - 使用`static`的`ThreadLocal`，延长了`ThreadLocal`的生命周期，可能导致的内存泄漏（参考[ThreadLocal 内存泄露的实例分析](http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/)）。\n> - 分配使用了`ThreadLocal`又不再调用`get()`,`set()`,`remove()`方法，那么就会导致内存泄漏。\n>\n> ### 为什么使用弱引用\n>\n> 从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析`ThreadLocal`使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？\n>\n> 我们先来看看官方文档的说法：\n>\n> > To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.\n> > 为了应对非常大和长时间的用途，哈希表使用弱引用的 key。\n>\n> 下面我们分两种情况讨论：\n>\n> - **key 使用强引用**：引用的`ThreadLocal`的对象被回收了，但是`ThreadLocalMap`还持有`ThreadLocal`的强引用，如果没有手动删除，`ThreadLocal`不会被回收，导致`Entry`内存泄漏。\n> - **key 使用弱引用**：引用的`ThreadLocal`的对象被回收了，由于`ThreadLocalMap`持有`ThreadLocal`的弱引用，即使没有手动删除，`ThreadLocal`也会被回收。`value`在下一次`ThreadLocalMap`调用`set`,`get`，`remove`的时候会被清除。\n>\n> 比较两种情况，我们可以发现：由于`ThreadLocalMap`的生命周期跟`Thread`一样长，如果都没有手动删除对应`key`，都会导致内存泄漏，但是使用弱引用可以多一层保障：**弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除**。\n>\n> 因此，`ThreadLocal`内存泄漏的根源是：由于`ThreadLocalMap`的生命周期跟`Thread`一样长，如果没有手动删除对应`key`就会导致内存泄漏，而不是因为弱引用。\n>\n> ## ThreadLocal 最佳实践\n>\n> 综合上面的分析，我们可以理解`ThreadLocal`内存泄漏的前因后果，那么怎么避免内存泄漏呢？\n>\n> - 每次使用完`ThreadLocal`，都调用它的`remove()`方法，清除数据。\n>\n> 在使用线程池的情况下，没有及时清理`ThreadLocal`，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用`ThreadLocal`就跟加锁完要解锁一样，用完就清理。\n\n参考文章\n\n[深入分析 ThreadLocal 内存泄漏问题](http://www.importnew.com/22039.html)\n\n[ThreadLocal 内存泄露的实例分析](http://www.importnew.com/22046.html)\n\n[ThreadLocal内存泄露](http://www.importnew.com/22480.html)\n\n\n\n\n\n","slug":"java多线程系列之 08 ThreadLocal","published":1,"updated":"2019-01-04T01:48:59.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxwty0009eb1u0fvx3uaj","content":"<h1 id=\"java多线程系列之-08-ThreadLocal\"><a href=\"#java多线程系列之-08-ThreadLocal\" class=\"headerlink\" title=\"java多线程系列之 08 ThreadLocal\"></a>java多线程系列之 08 ThreadLocal</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>ThreadLocal介绍</li>\n<li>基本用法</li>\n<li>ThreadLocal引起的内存泄漏</li>\n</ol>\n</blockquote>\n<h3 id=\"ThreadLocal-介绍\"><a href=\"#ThreadLocal-介绍\" class=\"headerlink\" title=\"ThreadLocal 介绍\"></a>ThreadLocal 介绍</h3><blockquote>\n<p>ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被GC。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal通常定义为<code>private static</code>类型。</p>\n</blockquote>\n<h3 id=\"2-基本用法\"><a href=\"#2-基本用法\" class=\"headerlink\" title=\"2. 基本用法\"></a>2. 基本用法</h3><blockquote>\n<pre><code>public class ThreadLocalTest {\n   public static void main(String[] args) {\n       for (int i = 0; i &lt; 10; i++) {\n           new Thread() {\n               public void run() {\n                   ThreadId id = new ThreadId();\n                   System.out.println(id.get());\n               }\n           }.start();\n       }\n   }\n}\nclass ThreadId {\n   // Atomic integer containing the next thread ID to be assigned\n   private static final AtomicInteger nextId = new AtomicInteger(0);\n\n   // Thread local variable containing each thread&#39;s ID\n   private static final ThreadLocal&lt;Integer&gt; threadId =\n       new ThreadLocal&lt;Integer&gt;() {\n           @Override\n           protected Integer initialValue() {\n               return nextId.getAndIncrement();\n           }\n       };\n\n   // Returns the current thread&#39;s unique ID, assigning it if necessary\n   public int get() {\n       return threadId.get();\n   }\n}\n</code></pre><p>运行结果：</p>\n<pre><code>9\n7\n6\n8\n2\n4\n0\n3\n5\n1\n</code></pre><p>虽然ThreadLocal对象时static的，但是由于是每个线程独有的，所以各自线程对应的ThreadLocal属性改变，不会影响其他线程的值，因此可以说是线程私有的。也正是因为此，上面的结果才是10个不一样的值。</p>\n<p>那么，在什么场景下比较适合使用ThreadLocal？stackoverflow上有人给出了还不错的回答。<br><a href=\"https://link.jianshu.com?t=http://stackoverflow.com/questions/817856/when-and-how-should-i-use-a-threadlocal-variable\" target=\"_blank\" rel=\"noopener\">When and how should I use a ThreadLocal variable?</a><br>One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid synchronizing access to that object . Instead, give each thread its own instance of the object. </p>\n</blockquote>\n<h2 id=\"ThreadLocal引起的内存泄漏\"><a href=\"#ThreadLocal引起的内存泄漏\" class=\"headerlink\" title=\"ThreadLocal引起的内存泄漏\"></a>ThreadLocal引起的内存泄漏</h2><blockquote>\n<p><code>ThreadLocal</code> 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但是如果滥用<code>ThreadLocal</code>，就可能会导致内存泄漏。下面，我们将围绕三个方面来分析<code>ThreadLocal</code> 内存泄漏的问题</p>\n<ul>\n<li><code>ThreadLocal</code> 实现原理</li>\n<li><code>ThreadLocal</code>为什么会内存泄漏</li>\n<li><code>ThreadLocal</code> 最佳实践</li>\n</ul>\n<h2 id=\"ThreadLocal-实现原理\"><a href=\"#ThreadLocal-实现原理\" class=\"headerlink\" title=\"ThreadLocal 实现原理\"></a>ThreadLocal 实现原理</h2><p><a href=\"http://www.importnew.com/?attachment_id=22042\" target=\"_blank\" rel=\"noopener\"><img src=\"http://incdn1.b0.upaiyun.com/2016/10/2fdbd552107780c5ae5f98126b38d5a4.png\" alt=\"threadlocal\"></a></p>\n<p>ThreadLocal</p>\n<p><code>ThreadLocal</code>的实现是这样的：每个<code>Thread</code> 维护一个 <code>ThreadLocalMap</code> 映射表，这个映射表的 <code>key</code> 是 <code>ThreadLocal</code>实例本身，<code>value</code> 是真正需要存储的 <code>Object</code>。</p>\n<p>也就是说 <code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。值得注意的是图中的虚线，表示 <code>ThreadLocalMap</code> 是使用 <code>ThreadLocal</code> 的弱引用作为 <code>Key</code> 的，弱引用的对象在 GC 时会被回收。</p>\n<h2 id=\"ThreadLocal为什么会内存泄漏\"><a href=\"#ThreadLocal为什么会内存泄漏\" class=\"headerlink\" title=\"ThreadLocal为什么会内存泄漏\"></a><code>ThreadLocal</code>为什么会内存泄漏</h2><p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 GC 的时候，这个<code>ThreadLocal</code>势必会被回收，这样一来，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>，如果当前线程再迟迟不结束的话，这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄漏。</p>\n<p>其实，<code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p>\n<p>但是这些被动的预防措施并不能保证不会内存泄漏：</p>\n<ul>\n<li>使用<code>static</code>的<code>ThreadLocal</code>，延长了<code>ThreadLocal</code>的生命周期，可能导致的内存泄漏（参考<a href=\"http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/\" target=\"_blank\" rel=\"noopener\">ThreadLocal 内存泄露的实例分析</a>）。</li>\n<li>分配使用了<code>ThreadLocal</code>又不再调用<code>get()</code>,<code>set()</code>,<code>remove()</code>方法，那么就会导致内存泄漏。</li>\n</ul>\n<h3 id=\"为什么使用弱引用\"><a href=\"#为什么使用弱引用\" class=\"headerlink\" title=\"为什么使用弱引用\"></a>为什么使用弱引用</h3><p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析<code>ThreadLocal</code>使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</p>\n<p>我们先来看看官方文档的说法：</p>\n<blockquote>\n<p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了应对非常大和长时间的用途，哈希表使用弱引用的 key。</p>\n</blockquote>\n<p>下面我们分两种情况讨论：</p>\n<ul>\n<li><strong>key 使用强引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>不会被回收，导致<code>Entry</code>内存泄漏。</li>\n<li><strong>key 使用弱引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>,<code>get</code>，<code>remove</code>的时候会被清除。</li>\n</ul>\n<p>比较两种情况，我们可以发现：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果都没有手动删除对应<code>key</code>，都会导致内存泄漏，但是使用弱引用可以多一层保障：<strong>弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除</strong>。</p>\n<p>因此，<code>ThreadLocal</code>内存泄漏的根源是：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果没有手动删除对应<code>key</code>就会导致内存泄漏，而不是因为弱引用。</p>\n<h2 id=\"ThreadLocal-最佳实践\"><a href=\"#ThreadLocal-最佳实践\" class=\"headerlink\" title=\"ThreadLocal 最佳实践\"></a>ThreadLocal 最佳实践</h2><p>综合上面的分析，我们可以理解<code>ThreadLocal</code>内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p>\n<ul>\n<li>每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据。</li>\n</ul>\n<p>在使用线程池的情况下，没有及时清理<code>ThreadLocal</code>，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用<code>ThreadLocal</code>就跟加锁完要解锁一样，用完就清理。</p>\n</blockquote>\n<p>参考文章</p>\n<p><a href=\"http://www.importnew.com/22039.html\" target=\"_blank\" rel=\"noopener\">深入分析 ThreadLocal 内存泄漏问题</a></p>\n<p><a href=\"http://www.importnew.com/22046.html\" target=\"_blank\" rel=\"noopener\">ThreadLocal 内存泄露的实例分析</a></p>\n<p><a href=\"http://www.importnew.com/22480.html\" target=\"_blank\" rel=\"noopener\">ThreadLocal内存泄露</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列之-08-ThreadLocal\"><a href=\"#java多线程系列之-08-ThreadLocal\" class=\"headerlink\" title=\"java多线程系列之 08 ThreadLocal\"></a>java多线程系列之 08 ThreadLocal</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>ThreadLocal介绍</li>\n<li>基本用法</li>\n<li>ThreadLocal引起的内存泄漏</li>\n</ol>\n</blockquote>\n<h3 id=\"ThreadLocal-介绍\"><a href=\"#ThreadLocal-介绍\" class=\"headerlink\" title=\"ThreadLocal 介绍\"></a>ThreadLocal 介绍</h3><blockquote>\n<p>ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被GC。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal通常定义为<code>private static</code>类型。</p>\n</blockquote>\n<h3 id=\"2-基本用法\"><a href=\"#2-基本用法\" class=\"headerlink\" title=\"2. 基本用法\"></a>2. 基本用法</h3><blockquote>\n<pre><code>public class ThreadLocalTest {\n   public static void main(String[] args) {\n       for (int i = 0; i &lt; 10; i++) {\n           new Thread() {\n               public void run() {\n                   ThreadId id = new ThreadId();\n                   System.out.println(id.get());\n               }\n           }.start();\n       }\n   }\n}\nclass ThreadId {\n   // Atomic integer containing the next thread ID to be assigned\n   private static final AtomicInteger nextId = new AtomicInteger(0);\n\n   // Thread local variable containing each thread&#39;s ID\n   private static final ThreadLocal&lt;Integer&gt; threadId =\n       new ThreadLocal&lt;Integer&gt;() {\n           @Override\n           protected Integer initialValue() {\n               return nextId.getAndIncrement();\n           }\n       };\n\n   // Returns the current thread&#39;s unique ID, assigning it if necessary\n   public int get() {\n       return threadId.get();\n   }\n}\n</code></pre><p>运行结果：</p>\n<pre><code>9\n7\n6\n8\n2\n4\n0\n3\n5\n1\n</code></pre><p>虽然ThreadLocal对象时static的，但是由于是每个线程独有的，所以各自线程对应的ThreadLocal属性改变，不会影响其他线程的值，因此可以说是线程私有的。也正是因为此，上面的结果才是10个不一样的值。</p>\n<p>那么，在什么场景下比较适合使用ThreadLocal？stackoverflow上有人给出了还不错的回答。<br><a href=\"https://link.jianshu.com?t=http://stackoverflow.com/questions/817856/when-and-how-should-i-use-a-threadlocal-variable\" target=\"_blank\" rel=\"noopener\">When and how should I use a ThreadLocal variable?</a><br>One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid synchronizing access to that object . Instead, give each thread its own instance of the object. </p>\n</blockquote>\n<h2 id=\"ThreadLocal引起的内存泄漏\"><a href=\"#ThreadLocal引起的内存泄漏\" class=\"headerlink\" title=\"ThreadLocal引起的内存泄漏\"></a>ThreadLocal引起的内存泄漏</h2><blockquote>\n<p><code>ThreadLocal</code> 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但是如果滥用<code>ThreadLocal</code>，就可能会导致内存泄漏。下面，我们将围绕三个方面来分析<code>ThreadLocal</code> 内存泄漏的问题</p>\n<ul>\n<li><code>ThreadLocal</code> 实现原理</li>\n<li><code>ThreadLocal</code>为什么会内存泄漏</li>\n<li><code>ThreadLocal</code> 最佳实践</li>\n</ul>\n<h2 id=\"ThreadLocal-实现原理\"><a href=\"#ThreadLocal-实现原理\" class=\"headerlink\" title=\"ThreadLocal 实现原理\"></a>ThreadLocal 实现原理</h2><p><a href=\"http://www.importnew.com/?attachment_id=22042\" target=\"_blank\" rel=\"noopener\"><img src=\"http://incdn1.b0.upaiyun.com/2016/10/2fdbd552107780c5ae5f98126b38d5a4.png\" alt=\"threadlocal\"></a></p>\n<p>ThreadLocal</p>\n<p><code>ThreadLocal</code>的实现是这样的：每个<code>Thread</code> 维护一个 <code>ThreadLocalMap</code> 映射表，这个映射表的 <code>key</code> 是 <code>ThreadLocal</code>实例本身，<code>value</code> 是真正需要存储的 <code>Object</code>。</p>\n<p>也就是说 <code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。值得注意的是图中的虚线，表示 <code>ThreadLocalMap</code> 是使用 <code>ThreadLocal</code> 的弱引用作为 <code>Key</code> 的，弱引用的对象在 GC 时会被回收。</p>\n<h2 id=\"ThreadLocal为什么会内存泄漏\"><a href=\"#ThreadLocal为什么会内存泄漏\" class=\"headerlink\" title=\"ThreadLocal为什么会内存泄漏\"></a><code>ThreadLocal</code>为什么会内存泄漏</h2><p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 GC 的时候，这个<code>ThreadLocal</code>势必会被回收，这样一来，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>，如果当前线程再迟迟不结束的话，这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄漏。</p>\n<p>其实，<code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p>\n<p>但是这些被动的预防措施并不能保证不会内存泄漏：</p>\n<ul>\n<li>使用<code>static</code>的<code>ThreadLocal</code>，延长了<code>ThreadLocal</code>的生命周期，可能导致的内存泄漏（参考<a href=\"http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/\" target=\"_blank\" rel=\"noopener\">ThreadLocal 内存泄露的实例分析</a>）。</li>\n<li>分配使用了<code>ThreadLocal</code>又不再调用<code>get()</code>,<code>set()</code>,<code>remove()</code>方法，那么就会导致内存泄漏。</li>\n</ul>\n<h3 id=\"为什么使用弱引用\"><a href=\"#为什么使用弱引用\" class=\"headerlink\" title=\"为什么使用弱引用\"></a>为什么使用弱引用</h3><p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析<code>ThreadLocal</code>使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</p>\n<p>我们先来看看官方文档的说法：</p>\n<blockquote>\n<p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了应对非常大和长时间的用途，哈希表使用弱引用的 key。</p>\n</blockquote>\n<p>下面我们分两种情况讨论：</p>\n<ul>\n<li><strong>key 使用强引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>不会被回收，导致<code>Entry</code>内存泄漏。</li>\n<li><strong>key 使用弱引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>,<code>get</code>，<code>remove</code>的时候会被清除。</li>\n</ul>\n<p>比较两种情况，我们可以发现：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果都没有手动删除对应<code>key</code>，都会导致内存泄漏，但是使用弱引用可以多一层保障：<strong>弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除</strong>。</p>\n<p>因此，<code>ThreadLocal</code>内存泄漏的根源是：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果没有手动删除对应<code>key</code>就会导致内存泄漏，而不是因为弱引用。</p>\n<h2 id=\"ThreadLocal-最佳实践\"><a href=\"#ThreadLocal-最佳实践\" class=\"headerlink\" title=\"ThreadLocal 最佳实践\"></a>ThreadLocal 最佳实践</h2><p>综合上面的分析，我们可以理解<code>ThreadLocal</code>内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p>\n<ul>\n<li>每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据。</li>\n</ul>\n<p>在使用线程池的情况下，没有及时清理<code>ThreadLocal</code>，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用<code>ThreadLocal</code>就跟加锁完要解锁一样，用完就清理。</p>\n</blockquote>\n<p>参考文章</p>\n<p><a href=\"http://www.importnew.com/22039.html\" target=\"_blank\" rel=\"noopener\">深入分析 ThreadLocal 内存泄漏问题</a></p>\n<p><a href=\"http://www.importnew.com/22046.html\" target=\"_blank\" rel=\"noopener\">ThreadLocal 内存泄露的实例分析</a></p>\n<p><a href=\"http://www.importnew.com/22480.html\" target=\"_blank\" rel=\"noopener\">ThreadLocal内存泄露</a></p>\n"},{"title":"使用 Travis CI 自动更新 GitHub Pages","author":"枫秀天涯","abbrlink":32102,"date":"2018-12-28T06:59:00.000Z","_content":"此篇博客主要为记录学习使用\n在研究过程中主要参考如下俩篇文章\n1. [使用 Travis CI 自动更新 GitHub Pages](https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/)\n2. [在持续集成过程出现文件为空的错误解决](http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/)","source":"_posts/使用-Travis-CI-自动更新-GitHub-Pages.md","raw":"---\ntitle: 使用 Travis CI 自动更新 GitHub Pages\nauthor: 枫秀天涯\ntags:\n  - 博客建站\ncategories:\n  - 其他\nabbrlink: 32102\ndate: 2018-12-28 14:59:00\n---\n此篇博客主要为记录学习使用\n在研究过程中主要参考如下俩篇文章\n1. [使用 Travis CI 自动更新 GitHub Pages](https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/)\n2. [在持续集成过程出现文件为空的错误解决](http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/)","slug":"使用-Travis-CI-自动更新-GitHub-Pages","published":1,"updated":"2019-01-02T05:50:19.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxwu5000ceb1uhn3efimo","content":"<p>此篇博客主要为记录学习使用<br>在研究过程中主要参考如下俩篇文章</p>\n<ol>\n<li><a href=\"https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/\" target=\"_blank\" rel=\"noopener\">使用 Travis CI 自动更新 GitHub Pages</a></li>\n<li><a href=\"http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/\" target=\"_blank\" rel=\"noopener\">在持续集成过程出现文件为空的错误解决</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>此篇博客主要为记录学习使用<br>在研究过程中主要参考如下俩篇文章</p>\n<ol>\n<li><a href=\"https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/\" target=\"_blank\" rel=\"noopener\">使用 Travis CI 自动更新 GitHub Pages</a></li>\n<li><a href=\"http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/\" target=\"_blank\" rel=\"noopener\">在持续集成过程出现文件为空的错误解决</a></li>\n</ol>\n"},{"title":"虚拟内存","author":"zhangke","abbrlink":"f79e4123","date":"2018-09-21T06:42:00.000Z","_content":"# 虚拟内存\n\n### 概述\n\n1. 虚拟内存是什么、可以用来做什么\n2. 基本概念介绍\n3. 虚拟内存作为缓存的工具\n4. 虚拟内存作为内存管理的工具\n5. 虚拟内存作为内存保护的工具\n\n### 1. 虚拟内存是什么、功能是什么\n\n**虚拟内存是什么**\n\n**虚拟内存**是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。\n\n下面是《深入立即操作系统》给出的定义：\n\n> 为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。\n\n并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。\n\n虚拟内存功能是什么\n\n1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。\n2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。\n3. 它保护了每个进程的地址空间不被其他进程破坏。\n\n<!-- more -->\n\n### 2.基本概念介绍\n\n#### 物理地址、虚拟地址\n\n虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：\n\n![物理寻址](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg)\n\n主存的每个地址都是唯一的，第一个字节地址为0，接下来为1，以此类推。CPU使用这种访问方式就是**物理寻址**。上图所示就是CPU通过**地址总线**传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。\n\n当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：\n\n![img](upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp)\n\n\n\n使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。\n\n我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。\n\n#### 地址空间\n\n地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。\n\n### 3. 虚拟内存作为缓存的工具\n\n**虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。**\n\n从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块(block)，这些块作为和主存(较高层)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。\n\n在任意时刻，虚拟页面都分为三个不相交的部分：\n\n- **未分配的(Unallocated)**：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。\n- **缓存的(Cached)**：当前已缓存在物理内存中的已分配页。\n- **未缓存的(UnCached)**：该页已经映射到磁盘上了，但是还没缓存在物理内存中。\n\n> 其中**未分配的VP**不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射，毕竟程序不可能实际使用那么大的地址空间。\n\n![](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png)\n\n图13：VM使用主存来作为缓存\n\n上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。\n\n> 当然，那个图上标注的不对,VP 部分， `n-p`和`N-1`应该分别标注为`3`和`7`,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。\n\n### 参考\n\n[什么是虚拟内存](https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-3/virtual_mem_managment.html)\n\n[《深入理解计算机系统》| 虚拟存储器](https://www.jianshu.com/p/e1b82b230917)\n\n[什么是内存(二)：虚拟内存](https://www.cnblogs.com/yaoxiaowen/p/7805964.html)","source":"_posts/虚拟内存.md","raw":"title: 虚拟内存\nauthor: zhangke\nabbrlink: f79e4123\ntags:\n  - 操作系统\ncategories:\n  - 操作系统\ndate: 2018-09-21 14:42:00\n---\n# 虚拟内存\n\n### 概述\n\n1. 虚拟内存是什么、可以用来做什么\n2. 基本概念介绍\n3. 虚拟内存作为缓存的工具\n4. 虚拟内存作为内存管理的工具\n5. 虚拟内存作为内存保护的工具\n\n### 1. 虚拟内存是什么、功能是什么\n\n**虚拟内存是什么**\n\n**虚拟内存**是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。\n\n下面是《深入立即操作系统》给出的定义：\n\n> 为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。\n\n并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。\n\n虚拟内存功能是什么\n\n1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。\n2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。\n3. 它保护了每个进程的地址空间不被其他进程破坏。\n\n<!-- more -->\n\n### 2.基本概念介绍\n\n#### 物理地址、虚拟地址\n\n虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：\n\n![物理寻址](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg)\n\n主存的每个地址都是唯一的，第一个字节地址为0，接下来为1，以此类推。CPU使用这种访问方式就是**物理寻址**。上图所示就是CPU通过**地址总线**传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。\n\n当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：\n\n![img](upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp)\n\n\n\n使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。\n\n我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。\n\n#### 地址空间\n\n地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。\n\n### 3. 虚拟内存作为缓存的工具\n\n**虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。**\n\n从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块(block)，这些块作为和主存(较高层)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。\n\n在任意时刻，虚拟页面都分为三个不相交的部分：\n\n- **未分配的(Unallocated)**：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。\n- **缓存的(Cached)**：当前已缓存在物理内存中的已分配页。\n- **未缓存的(UnCached)**：该页已经映射到磁盘上了，但是还没缓存在物理内存中。\n\n> 其中**未分配的VP**不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射，毕竟程序不可能实际使用那么大的地址空间。\n\n![](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png)\n\n图13：VM使用主存来作为缓存\n\n上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。\n\n> 当然，那个图上标注的不对,VP 部分， `n-p`和`N-1`应该分别标注为`3`和`7`,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。\n\n### 参考\n\n[什么是虚拟内存](https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-3/virtual_mem_managment.html)\n\n[《深入理解计算机系统》| 虚拟存储器](https://www.jianshu.com/p/e1b82b230917)\n\n[什么是内存(二)：虚拟内存](https://www.cnblogs.com/yaoxiaowen/p/7805964.html)","slug":"虚拟内存","published":1,"updated":"2019-01-04T01:48:59.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxwu7000deb1uwrbqtfzc","content":"<h1 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>虚拟内存是什么、可以用来做什么</li>\n<li>基本概念介绍</li>\n<li>虚拟内存作为缓存的工具</li>\n<li>虚拟内存作为内存管理的工具</li>\n<li>虚拟内存作为内存保护的工具</li>\n</ol>\n<h3 id=\"1-虚拟内存是什么、功能是什么\"><a href=\"#1-虚拟内存是什么、功能是什么\" class=\"headerlink\" title=\"1. 虚拟内存是什么、功能是什么\"></a>1. 虚拟内存是什么、功能是什么</h3><p><strong>虚拟内存是什么</strong></p>\n<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>\n<p>下面是《深入立即操作系统》给出的定义：</p>\n<blockquote>\n<p>为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。</p>\n</blockquote>\n<p>并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。</p>\n<p>虚拟内存功能是什么</p>\n<ol>\n<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。</li>\n<li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li>\n<li>它保护了每个进程的地址空间不被其他进程破坏。</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"2-基本概念介绍\"><a href=\"#2-基本概念介绍\" class=\"headerlink\" title=\"2.基本概念介绍\"></a>2.基本概念介绍</h3><h4 id=\"物理地址、虚拟地址\"><a href=\"#物理地址、虚拟地址\" class=\"headerlink\" title=\"物理地址、虚拟地址\"></a>物理地址、虚拟地址</h4><p>虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg\" alt=\"物理寻址\"></p>\n<p>主存的每个地址都是唯一的，第一个字节地址为0，接下来为1，以此类推。CPU使用这种访问方式就是<strong>物理寻址</strong>。上图所示就是CPU通过<strong>地址总线</strong>传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。</p>\n<p>当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：</p>\n<p><img src=\"upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp\" alt=\"img\"></p>\n<p>使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。</p>\n<p>我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。</p>\n<h4 id=\"地址空间\"><a href=\"#地址空间\" class=\"headerlink\" title=\"地址空间\"></a>地址空间</h4><p>地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>\n<h3 id=\"3-虚拟内存作为缓存的工具\"><a href=\"#3-虚拟内存作为缓存的工具\" class=\"headerlink\" title=\"3. 虚拟内存作为缓存的工具\"></a>3. 虚拟内存作为缓存的工具</h3><p><strong>虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。</strong></p>\n<p>从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块(block)，这些块作为和主存(较高层)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。</p>\n<p>在任意时刻，虚拟页面都分为三个不相交的部分：</p>\n<ul>\n<li><strong>未分配的(Unallocated)</strong>：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。</li>\n<li><strong>缓存的(Cached)</strong>：当前已缓存在物理内存中的已分配页。</li>\n<li><strong>未缓存的(UnCached)</strong>：该页已经映射到磁盘上了，但是还没缓存在物理内存中。</li>\n</ul>\n<blockquote>\n<p>其中<strong>未分配的VP</strong>不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射，毕竟程序不可能实际使用那么大的地址空间。</p>\n</blockquote>\n<p><img src=\"https://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png\" alt=\"\"></p>\n<p>图13：VM使用主存来作为缓存</p>\n<p>上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。</p>\n<blockquote>\n<p>当然，那个图上标注的不对,VP 部分， <code>n-p</code>和<code>N-1</code>应该分别标注为<code>3</code>和<code>7</code>,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。</p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-3/virtual_mem_managment.html\" target=\"_blank\" rel=\"noopener\">什么是虚拟内存</a></p>\n<p><a href=\"https://www.jianshu.com/p/e1b82b230917\" target=\"_blank\" rel=\"noopener\">《深入理解计算机系统》| 虚拟存储器</a></p>\n<p><a href=\"https://www.cnblogs.com/yaoxiaowen/p/7805964.html\" target=\"_blank\" rel=\"noopener\">什么是内存(二)：虚拟内存</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>虚拟内存是什么、可以用来做什么</li>\n<li>基本概念介绍</li>\n<li>虚拟内存作为缓存的工具</li>\n<li>虚拟内存作为内存管理的工具</li>\n<li>虚拟内存作为内存保护的工具</li>\n</ol>\n<h3 id=\"1-虚拟内存是什么、功能是什么\"><a href=\"#1-虚拟内存是什么、功能是什么\" class=\"headerlink\" title=\"1. 虚拟内存是什么、功能是什么\"></a>1. 虚拟内存是什么、功能是什么</h3><p><strong>虚拟内存是什么</strong></p>\n<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>\n<p>下面是《深入立即操作系统》给出的定义：</p>\n<blockquote>\n<p>为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。</p>\n</blockquote>\n<p>并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。</p>\n<p>虚拟内存功能是什么</p>\n<ol>\n<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。</li>\n<li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li>\n<li>它保护了每个进程的地址空间不被其他进程破坏。</li>\n</ol>","more":"<h3 id=\"2-基本概念介绍\"><a href=\"#2-基本概念介绍\" class=\"headerlink\" title=\"2.基本概念介绍\"></a>2.基本概念介绍</h3><h4 id=\"物理地址、虚拟地址\"><a href=\"#物理地址、虚拟地址\" class=\"headerlink\" title=\"物理地址、虚拟地址\"></a>物理地址、虚拟地址</h4><p>虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg\" alt=\"物理寻址\"></p>\n<p>主存的每个地址都是唯一的，第一个字节地址为0，接下来为1，以此类推。CPU使用这种访问方式就是<strong>物理寻址</strong>。上图所示就是CPU通过<strong>地址总线</strong>传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。</p>\n<p>当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：</p>\n<p><img src=\"upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp\" alt=\"img\"></p>\n<p>使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。</p>\n<p>我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。</p>\n<h4 id=\"地址空间\"><a href=\"#地址空间\" class=\"headerlink\" title=\"地址空间\"></a>地址空间</h4><p>地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>\n<h3 id=\"3-虚拟内存作为缓存的工具\"><a href=\"#3-虚拟内存作为缓存的工具\" class=\"headerlink\" title=\"3. 虚拟内存作为缓存的工具\"></a>3. 虚拟内存作为缓存的工具</h3><p><strong>虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。</strong></p>\n<p>从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块(block)，这些块作为和主存(较高层)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。</p>\n<p>在任意时刻，虚拟页面都分为三个不相交的部分：</p>\n<ul>\n<li><strong>未分配的(Unallocated)</strong>：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。</li>\n<li><strong>缓存的(Cached)</strong>：当前已缓存在物理内存中的已分配页。</li>\n<li><strong>未缓存的(UnCached)</strong>：该页已经映射到磁盘上了，但是还没缓存在物理内存中。</li>\n</ul>\n<blockquote>\n<p>其中<strong>未分配的VP</strong>不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射，毕竟程序不可能实际使用那么大的地址空间。</p>\n</blockquote>\n<p><img src=\"https://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png\" alt=\"\"></p>\n<p>图13：VM使用主存来作为缓存</p>\n<p>上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。</p>\n<blockquote>\n<p>当然，那个图上标注的不对,VP 部分， <code>n-p</code>和<code>N-1</code>应该分别标注为<code>3</code>和<code>7</code>,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。</p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-3/virtual_mem_managment.html\" target=\"_blank\" rel=\"noopener\">什么是虚拟内存</a></p>\n<p><a href=\"https://www.jianshu.com/p/e1b82b230917\" target=\"_blank\" rel=\"noopener\">《深入理解计算机系统》| 虚拟存储器</a></p>\n<p><a href=\"https://www.cnblogs.com/yaoxiaowen/p/7805964.html\" target=\"_blank\" rel=\"noopener\">什么是内存(二)：虚拟内存</a></p>"},{"title":"JVM源码分析之 FinalReference 完全解读","author":"枫秀天涯","abbrlink":13502,"date":"2019-01-04T02:24:00.000Z","_content":"# JVM源码分析之 FinalReference完全解读\n\n## 概述\n\nJava对象引用体系除了强引用之外，出于对性能、可扩展性等方面考虑还特地实现了4种其他引用：`SoftReference`、`WeakReference`、`PhantomReference`、`FinalReference`，本文主要想讲的是`FinalReference`，因为当使用内存分析工具，比如zprofiler、mat等，分析一些oom的heap时，经常能看到 `java.lang.ref.Finalizer`占用的内存大小远远排在前面，而这个类占用的内存大小又和我们这次的主角`FinalReference`有着密不可分的关系。\n\n`FinalReference`及关联的内容可能给我们留下如下印象：\n\n- 自己代码里从没有使用过；\n- 线程dump之后，会看到一个叫做`Finalizer`的Java线程；\n- 偶尔能注意到`java.lang.ref.Finalizer`的存在；\n- 在类里可能会写`finalize`方法。\n\n那`FinalReference`到底存在的意义是什么，以怎样的形式和我们的代码相关联呢？这是本文要理清的问题。\n<!-- more -->\n\n## JDK中的FinalReference\n\n首先我们看看`FinalReference`在JDK里的实现：\n\n```\nclass FinalReference&lt;T&gt; extends Reference&lt;T&gt; {\n\n    public FinalReference(T referent, ReferenceQueue&lt;? super T&gt; q) {\n        super(referent, q);\n    }\n\n}\n```\n\n大家应该注意到了类访问权限是package的，这也就意味着我们不能直接去对其进行扩展，但是JDK里对此类进行了扩展实现`java.lang.ref.Finalizer`，这个类在概述里提到的过，而此类的访问权限也是package的，并且是final的，意味着它不能再被扩展了，接下来的重点我们围绕`java.lang.ref.Finalizer`展开。(PS：后续讲的`Finalizer`其实也是在说`FinalReference`。)\n\n```\nfinal class Finalizer extends FinalReference { \n   /* Package-private; must be in same package as the \n   Referenceclass */\n   \n   /* A native method that invokes an arbitrary object's  \n   finalize method is  required since the finalize method is \n   protected*/\n    static native void invokeFinalizeMethod(Object o) throws Throwable;\n\n    private static ReferenceQueue queue = new ReferenceQueue();\n    private static Finalizer unfinalized = null;\n    private static final Object lock = new Object();\n\n    private Finalizer\n        next = null,\n        prev = null;\n\n    private Finalizer(Object finalizee) {\n        super(finalizee, queue);\n        add();\n    }\n\n    /* Invoked by VM */\n    static void register(Object finalizee) {\n        new Finalizer(finalizee);\n    }  \n\n    private void add() {\n        synchronized (lock) {\n            if (unfinalized != null) {\n                this.next = unfinalized;\n                unfinalized.prev = this;\n            }\n            unfinalized = this;\n        }\n    }\n\n    ...\n\n   }    \n```\n\n### Finalizer的构造函数\n\n`Finalizer`的构造函数提供了以下几个关键信息：\n\n- `private`：意味着我们无法在当前类之外构建这类的对象；\n- `finalizee`参数：`FinalReference`指向的对象引用；\n- 调用`add`方法：将当前对象插入到`Finalizer`对象链里，链里的对象和`Finalizer`类静态关联。言外之意是在这个链里的对象都无法被GC掉，除非将这种引用关系剥离（因为`Finalizer`类无法被unload）。\n\n虽然外面无法创建`Finalizer`对象，但是它有一个名为`register`的静态方法，该方法可以创建这种对象，同时将这个对象加入到`Finalizer`对象链里，这个方法是被vm调用的，那么问题来了，vm在什么情况下会调用这个方法呢？\n\n## Finalizer对象何时被注册到Finalizer对象链里\n\n类的修饰有很多，比如final，abstract，public等，如果某个类用final修饰，我们就说这个类是final类，上面列的都是语法层面我们可以显式指定的，在JVM里其实还会给类标记一些其他符号，比如`finalizer`，表示这个类是一个`finalizer`类（为了和`java.lang.ref.Fianlizer`类区分，下文在提到的`finalizer`类时会简称为f类），GC在处理这种类的对象时要做一些特殊的处理，如在这个对象被回收之前会调用它的`finalize`方法。\n\n#### 如何判断一个类是不是一个final类\n\n在讲这个问题之前，我们先来看下`java.lang.Object`里的一个方法\n\n```\n    protected void finalize() throws Throwable { }\n```\n\n在`Object`类里定义了一个名为`finalize`的空方法，这意味着Java里的所有类都会继承这个方法，甚至可以覆写该方法，并且根据方法覆写原则，如果子类覆盖此方法，方法访问权限至少protected级别的，这样其子类就算没有覆写此方法也会继承此方法。\n\n而判断当前类是否是f类的标准并不仅仅是当前类是否含有一个参数为空，返回值为void的`finalize`方法，还要求`finalize方法必须非空`，因此Object类虽然含有一个`finalize`方法，但它并不是f类，Object的对象在被GC回收时其实并不会调用它的`finalize`方法。\n\n需要注意的是，类在加载过程中其实就已经被标记为是否为f类了。（JVM在类加载的时候会遍历当前类的所有方法，包括父类的方法，只要有一个参数为空且返回void的非空`finalize`方法就认为这个类是f类。）\n\n### f类的对象何时传到Finalizer.register方法\n\n对象的创建其实是被拆分成多个步骤的，比如`A a=new A(2)`这样一条语句对应的字节码如下：\n\n```\n0: new           #1                  // class A\n3: dup\n4: iconst_2\n5: invokespecial #11                 // Method \"&lt;init&gt;\":(I)V\n```\n\n先执行new分配好对象空间，然后再执行invokespecial调用构造函数，JVM里其实可以让用户在这两个时机中选择一个，将当前对象传递给`Finalizer.register`方法来注册到`Finalizer`对象链里，这个选择取决于是否设置了`RegisterFinalizersAtInit`这个vm参数，默认值为true，也就是在构造函数返回之前调用`Finalizer.register`方法，如果通过`-XX:-RegisterFinalizersAtInit`关闭了该参数，那将在对象空间分配好之后将这个对象注册进去。\n\n另外需要提醒的是，当我们通过clone的方式复制一个对象时，如果当前类是一个f类，那么在clone完成时将调用`Finalizer.register`方法进行注册。\n\n### hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register\n\n这个实现比较有意思，在这简单提一下，我们知道执行一个构造函数时，会去调用父类的构造函数，主要是为了初始化继承自父类的属性，那么任何一个对象的初始化最终都会调用到`Object`的空构造函数里（任何空的构造函数其实并不空，会含有三条字节码指令，如下代码所示），为了不对所有类的构造函数都埋点调用`Finalizer.register`方法，hotspot的实现是，在初始化`Object`类时将构造函数里的`return`指令替换为`_return_register_finalizer`指令，该指令并不是标准的字节码指令，是hotspot扩展的指令，这样在处理该指令时调用`Finalizer.register`方法，以很小的侵入性代价完美地解决了这个问题。\n\n```\n0: aload_0\n1: invokespecial #21                 // Method java/lang/Object.\"&lt;init&gt;\":()V\n4: return\n```\n\n## f类对象的GC回收\n\n### FinalizerThread线程\n\n在`Finalizer`类的`clinit`方法（静态块）里，我们看到它会创建一个`FinalizerThread`守护线程，这个线程的优先级并不是最高的，意味着在CPU很紧张的情况下其被调度的优先级可能会受到影响\n\n```\n  private static class FinalizerThread extends Thread {\n        private volatile boolean running;\n        FinalizerThread(ThreadGroup g) {\n            super(g, \"Finalizer\");\n        }\n        public void run() {\n            if (running)\n                return;\n            running = true;\n            for (;;) {\n                try {\n                    Finalizer f = (Finalizer)queue.remove();\n                    f.runFinalizer();\n                } catch (InterruptedException x) {\n                    continue;\n                }\n            }\n        }\n    }\n\n    static {\n        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n        for (ThreadGroup tgn = tg;\n             tgn != null;\n             tg = tgn, tgn = tg.getParent());\n        Thread finalizer = new FinalizerThread(tg);\n        finalizer.setPriority(Thread.MAX_PRIORITY - 2);\n        finalizer.setDaemon(true);\n        finalizer.start();\n    }\n```\n\n这个线程用来从queue里获取`Finalizer`对象，然后执行该对象的`runFinalizer`方法，该方法会将`Finalizer`对象从`Finalizer`对象链里剥离出来，这样意味着下次GC发生时就可以将其关联的f对象回收了，最后将这个`Finalizer`对象关联的f对象传给一个native方法`invokeFinalizeMethod`\n\n```\nprivate void runFinalizer() {\n        synchronized (this) {\n            if (hasBeenFinalized()) return;\n            remove();\n        }\n        try {\n            Object finalizee = this.get();\n            if (finalizee != null && !(finalizee instanceof java.lang.Enum)) {\n                invokeFinalizeMethod(finalizee);\n                /* Clear stack slot containing this variable, to decrease\n                   the chances of false retention with a conservative GC */\n                finalizee = null;\n            }\n        } catch (Throwable x) { }\n        super.clear();\n    }\n\n static native void invokeFinalizeMethod(Object o) throws Throwable;\n```\n\n其实`invokeFinalizeMethod`方法就是调了这个f对象的finalize方法，看到这里大家应该恍然大悟了，整个过程都串起来了。\n\n```\nJNIEXPORT void JNICALL\nJava_java_lang_ref_Finalizer_invokeFinalizeMethod(JNIEnv *env, jclass clazz,\n                                                  jobject ob)\n{\n    jclass cls;\n    jmethodID mid;\n\n    cls = (*env)-&gt;GetObjectClass(env, ob);\n    if (cls == NULL) return;\n    mid = (*env)-&gt;GetMethodID(env, cls, \"finalize\", \"()V\");\n    if (mid == NULL) return;\n    (*env)-&gt;CallVoidMethod(env, ob, mid);\n}\n```\n\n### f对象的finalize方法抛出异常会导致FinalizeThread退出吗\n\n不知道大家有没有想过如果f对象的`finalize`方法抛了一个没捕获的异常，这个`FinalizerThread`会不会退出呢，细心的读者看上面的代码其实就可以找到答案，`runFinalizer`方法里对`Throwable`的异常进行了捕获，因此不可能出现`FinalizerThread`因异常未捕获而退出的情况。\n\n### f对象的finalize方法会执行多次吗\n\n如果我们在f对象的`finalize`方法里重新将当前对象赋值，变成可达对象，当这个f对象再次变成不可达时还会执行`finalize`方法吗？答案是否定的，因为在执行完第一次`finalize`方法后，这个f对象已经和之前的`Finalizer`对象剥离了，也就是下次GC的时候不会再发现`Finalizer`对象指向该f对象了，自然也就不会调用这个f对象的`finalize`方法了。\n\n### Finalizer对象何时被放到ReferenceQueue里\n\n除了这里接下来要介绍的环节之外，整个过程大家应该都比较清楚了。\n\n当GC发生时，GC算法会判断f类对象是不是只被`Finalizer`类引用（f类对象被`Finalizer`对象引用，然后放到`Finalizer`对象链里），如果这个类仅仅被`Finalizer`对象引用，说明这个对象在不久的将来会被回收，现在可以执行它的`finalize`方法了，于是会将这个`Finalizer`对象放到`Finalizer`类的`ReferenceQueue`里，但是这个f类对象其实并没有被回收，因为`Finalizer`这个类还对它们保持引用，在GC完成之前，JVM会调用`ReferenceQueue`中lock对象的notify方法（当`ReferenceQueue`为空时，`FinalizerThread`线程会调用`ReferenceQueue`的lock对象的wait方法直到被JVM唤醒），此时就会执行上面FinalizeThread线程里看到的其他逻辑了。\n\n## Finalizer导致的内存泄露\n\n这里举一个简单的例子，我们使用挺广的Socket通信，`SocksSocketImpl`的父类其实就实现了`finalize`方法:\n\n```\n/**\n * Cleans up if the user forgets to close it.\n */\nprotected void finalize() throws IOException {\n    close();\n}\n```\n\n其实这么做的主要目的是万一用户忘记关闭Socket，那么在这个对象被回收时能主动关闭Socket来释放一些系统资源，但是如果用户真的忘记关闭，那这些`socket`对象可能因为`FinalizeThread`迟迟没有执行这些`socket`对象的`finalize`方法，而导致内存泄露，这种问题我们碰到过多次，因此对于这类情况除了大家好好注意貌似没有什么更好的方法了，该做的事真不能省.\n\n## Finalizer的客观评价\n\n上面的过程基本对`Finalizer`的实现细节进行了完整剖析，Java里我们看到有构造函数，但是并没有看到析构函数一说，`Finalizer`其实是实现了析构函数的概念，我们在对象被回收前可以执行一些“收拾性”的逻辑，应该说是一个特殊场景的补充，但是这种概念的实现给f对象生命周期以及GC等带来了一些影响：\n\n- f对象因为`Finalizer`的引用而变成了一个临时的强引用，即使没有其他的强引用，还是无法立即被回收；\n- f对象至少经历两次GC才能被回收，因为只有在`FinalizerThread`执行完了f对象的`finalize`方法的情况下才有可能被下次GC回收，而有可能期间已经经历过多次GC了，但是一直还没执行f对象的`finalize`方法；\n- CPU资源比较稀缺的情况下`FinalizerThread`线程有可能因为优先级比较低而延迟执行f对象的`finalize`方法；\n- 因为f对象的`finalize`方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易引发old分代的GC，甚至Full GC，GC暂停时间明显变长；\n- f对象的`finalize`方法被调用后，这个对象其实还并没有被回收，虽然可能在不久的将来会被回收。\n\n## 参考\n1. [JVM 源码分析之 FinalReference 完全解读](https://www.infoq.cn/articles/jvm-source-code-analysis-finalreference)","source":"_posts/JVM源码分析之-FinalReference完全解读.md","raw":"title: JVM源码分析之 FinalReference 完全解读\nauthor: 枫秀天涯\nabbrlink: 13502\ntags:\n  - java\n  - java引用\n  - ''\n  - JVM\ncategories:\n  - java\ndate: 2019-01-04 10:24:00\n---\n# JVM源码分析之 FinalReference完全解读\n\n## 概述\n\nJava对象引用体系除了强引用之外，出于对性能、可扩展性等方面考虑还特地实现了4种其他引用：`SoftReference`、`WeakReference`、`PhantomReference`、`FinalReference`，本文主要想讲的是`FinalReference`，因为当使用内存分析工具，比如zprofiler、mat等，分析一些oom的heap时，经常能看到 `java.lang.ref.Finalizer`占用的内存大小远远排在前面，而这个类占用的内存大小又和我们这次的主角`FinalReference`有着密不可分的关系。\n\n`FinalReference`及关联的内容可能给我们留下如下印象：\n\n- 自己代码里从没有使用过；\n- 线程dump之后，会看到一个叫做`Finalizer`的Java线程；\n- 偶尔能注意到`java.lang.ref.Finalizer`的存在；\n- 在类里可能会写`finalize`方法。\n\n那`FinalReference`到底存在的意义是什么，以怎样的形式和我们的代码相关联呢？这是本文要理清的问题。\n<!-- more -->\n\n## JDK中的FinalReference\n\n首先我们看看`FinalReference`在JDK里的实现：\n\n```\nclass FinalReference&lt;T&gt; extends Reference&lt;T&gt; {\n\n    public FinalReference(T referent, ReferenceQueue&lt;? super T&gt; q) {\n        super(referent, q);\n    }\n\n}\n```\n\n大家应该注意到了类访问权限是package的，这也就意味着我们不能直接去对其进行扩展，但是JDK里对此类进行了扩展实现`java.lang.ref.Finalizer`，这个类在概述里提到的过，而此类的访问权限也是package的，并且是final的，意味着它不能再被扩展了，接下来的重点我们围绕`java.lang.ref.Finalizer`展开。(PS：后续讲的`Finalizer`其实也是在说`FinalReference`。)\n\n```\nfinal class Finalizer extends FinalReference { \n   /* Package-private; must be in same package as the \n   Referenceclass */\n   \n   /* A native method that invokes an arbitrary object's  \n   finalize method is  required since the finalize method is \n   protected*/\n    static native void invokeFinalizeMethod(Object o) throws Throwable;\n\n    private static ReferenceQueue queue = new ReferenceQueue();\n    private static Finalizer unfinalized = null;\n    private static final Object lock = new Object();\n\n    private Finalizer\n        next = null,\n        prev = null;\n\n    private Finalizer(Object finalizee) {\n        super(finalizee, queue);\n        add();\n    }\n\n    /* Invoked by VM */\n    static void register(Object finalizee) {\n        new Finalizer(finalizee);\n    }  \n\n    private void add() {\n        synchronized (lock) {\n            if (unfinalized != null) {\n                this.next = unfinalized;\n                unfinalized.prev = this;\n            }\n            unfinalized = this;\n        }\n    }\n\n    ...\n\n   }    \n```\n\n### Finalizer的构造函数\n\n`Finalizer`的构造函数提供了以下几个关键信息：\n\n- `private`：意味着我们无法在当前类之外构建这类的对象；\n- `finalizee`参数：`FinalReference`指向的对象引用；\n- 调用`add`方法：将当前对象插入到`Finalizer`对象链里，链里的对象和`Finalizer`类静态关联。言外之意是在这个链里的对象都无法被GC掉，除非将这种引用关系剥离（因为`Finalizer`类无法被unload）。\n\n虽然外面无法创建`Finalizer`对象，但是它有一个名为`register`的静态方法，该方法可以创建这种对象，同时将这个对象加入到`Finalizer`对象链里，这个方法是被vm调用的，那么问题来了，vm在什么情况下会调用这个方法呢？\n\n## Finalizer对象何时被注册到Finalizer对象链里\n\n类的修饰有很多，比如final，abstract，public等，如果某个类用final修饰，我们就说这个类是final类，上面列的都是语法层面我们可以显式指定的，在JVM里其实还会给类标记一些其他符号，比如`finalizer`，表示这个类是一个`finalizer`类（为了和`java.lang.ref.Fianlizer`类区分，下文在提到的`finalizer`类时会简称为f类），GC在处理这种类的对象时要做一些特殊的处理，如在这个对象被回收之前会调用它的`finalize`方法。\n\n#### 如何判断一个类是不是一个final类\n\n在讲这个问题之前，我们先来看下`java.lang.Object`里的一个方法\n\n```\n    protected void finalize() throws Throwable { }\n```\n\n在`Object`类里定义了一个名为`finalize`的空方法，这意味着Java里的所有类都会继承这个方法，甚至可以覆写该方法，并且根据方法覆写原则，如果子类覆盖此方法，方法访问权限至少protected级别的，这样其子类就算没有覆写此方法也会继承此方法。\n\n而判断当前类是否是f类的标准并不仅仅是当前类是否含有一个参数为空，返回值为void的`finalize`方法，还要求`finalize方法必须非空`，因此Object类虽然含有一个`finalize`方法，但它并不是f类，Object的对象在被GC回收时其实并不会调用它的`finalize`方法。\n\n需要注意的是，类在加载过程中其实就已经被标记为是否为f类了。（JVM在类加载的时候会遍历当前类的所有方法，包括父类的方法，只要有一个参数为空且返回void的非空`finalize`方法就认为这个类是f类。）\n\n### f类的对象何时传到Finalizer.register方法\n\n对象的创建其实是被拆分成多个步骤的，比如`A a=new A(2)`这样一条语句对应的字节码如下：\n\n```\n0: new           #1                  // class A\n3: dup\n4: iconst_2\n5: invokespecial #11                 // Method \"&lt;init&gt;\":(I)V\n```\n\n先执行new分配好对象空间，然后再执行invokespecial调用构造函数，JVM里其实可以让用户在这两个时机中选择一个，将当前对象传递给`Finalizer.register`方法来注册到`Finalizer`对象链里，这个选择取决于是否设置了`RegisterFinalizersAtInit`这个vm参数，默认值为true，也就是在构造函数返回之前调用`Finalizer.register`方法，如果通过`-XX:-RegisterFinalizersAtInit`关闭了该参数，那将在对象空间分配好之后将这个对象注册进去。\n\n另外需要提醒的是，当我们通过clone的方式复制一个对象时，如果当前类是一个f类，那么在clone完成时将调用`Finalizer.register`方法进行注册。\n\n### hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register\n\n这个实现比较有意思，在这简单提一下，我们知道执行一个构造函数时，会去调用父类的构造函数，主要是为了初始化继承自父类的属性，那么任何一个对象的初始化最终都会调用到`Object`的空构造函数里（任何空的构造函数其实并不空，会含有三条字节码指令，如下代码所示），为了不对所有类的构造函数都埋点调用`Finalizer.register`方法，hotspot的实现是，在初始化`Object`类时将构造函数里的`return`指令替换为`_return_register_finalizer`指令，该指令并不是标准的字节码指令，是hotspot扩展的指令，这样在处理该指令时调用`Finalizer.register`方法，以很小的侵入性代价完美地解决了这个问题。\n\n```\n0: aload_0\n1: invokespecial #21                 // Method java/lang/Object.\"&lt;init&gt;\":()V\n4: return\n```\n\n## f类对象的GC回收\n\n### FinalizerThread线程\n\n在`Finalizer`类的`clinit`方法（静态块）里，我们看到它会创建一个`FinalizerThread`守护线程，这个线程的优先级并不是最高的，意味着在CPU很紧张的情况下其被调度的优先级可能会受到影响\n\n```\n  private static class FinalizerThread extends Thread {\n        private volatile boolean running;\n        FinalizerThread(ThreadGroup g) {\n            super(g, \"Finalizer\");\n        }\n        public void run() {\n            if (running)\n                return;\n            running = true;\n            for (;;) {\n                try {\n                    Finalizer f = (Finalizer)queue.remove();\n                    f.runFinalizer();\n                } catch (InterruptedException x) {\n                    continue;\n                }\n            }\n        }\n    }\n\n    static {\n        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n        for (ThreadGroup tgn = tg;\n             tgn != null;\n             tg = tgn, tgn = tg.getParent());\n        Thread finalizer = new FinalizerThread(tg);\n        finalizer.setPriority(Thread.MAX_PRIORITY - 2);\n        finalizer.setDaemon(true);\n        finalizer.start();\n    }\n```\n\n这个线程用来从queue里获取`Finalizer`对象，然后执行该对象的`runFinalizer`方法，该方法会将`Finalizer`对象从`Finalizer`对象链里剥离出来，这样意味着下次GC发生时就可以将其关联的f对象回收了，最后将这个`Finalizer`对象关联的f对象传给一个native方法`invokeFinalizeMethod`\n\n```\nprivate void runFinalizer() {\n        synchronized (this) {\n            if (hasBeenFinalized()) return;\n            remove();\n        }\n        try {\n            Object finalizee = this.get();\n            if (finalizee != null && !(finalizee instanceof java.lang.Enum)) {\n                invokeFinalizeMethod(finalizee);\n                /* Clear stack slot containing this variable, to decrease\n                   the chances of false retention with a conservative GC */\n                finalizee = null;\n            }\n        } catch (Throwable x) { }\n        super.clear();\n    }\n\n static native void invokeFinalizeMethod(Object o) throws Throwable;\n```\n\n其实`invokeFinalizeMethod`方法就是调了这个f对象的finalize方法，看到这里大家应该恍然大悟了，整个过程都串起来了。\n\n```\nJNIEXPORT void JNICALL\nJava_java_lang_ref_Finalizer_invokeFinalizeMethod(JNIEnv *env, jclass clazz,\n                                                  jobject ob)\n{\n    jclass cls;\n    jmethodID mid;\n\n    cls = (*env)-&gt;GetObjectClass(env, ob);\n    if (cls == NULL) return;\n    mid = (*env)-&gt;GetMethodID(env, cls, \"finalize\", \"()V\");\n    if (mid == NULL) return;\n    (*env)-&gt;CallVoidMethod(env, ob, mid);\n}\n```\n\n### f对象的finalize方法抛出异常会导致FinalizeThread退出吗\n\n不知道大家有没有想过如果f对象的`finalize`方法抛了一个没捕获的异常，这个`FinalizerThread`会不会退出呢，细心的读者看上面的代码其实就可以找到答案，`runFinalizer`方法里对`Throwable`的异常进行了捕获，因此不可能出现`FinalizerThread`因异常未捕获而退出的情况。\n\n### f对象的finalize方法会执行多次吗\n\n如果我们在f对象的`finalize`方法里重新将当前对象赋值，变成可达对象，当这个f对象再次变成不可达时还会执行`finalize`方法吗？答案是否定的，因为在执行完第一次`finalize`方法后，这个f对象已经和之前的`Finalizer`对象剥离了，也就是下次GC的时候不会再发现`Finalizer`对象指向该f对象了，自然也就不会调用这个f对象的`finalize`方法了。\n\n### Finalizer对象何时被放到ReferenceQueue里\n\n除了这里接下来要介绍的环节之外，整个过程大家应该都比较清楚了。\n\n当GC发生时，GC算法会判断f类对象是不是只被`Finalizer`类引用（f类对象被`Finalizer`对象引用，然后放到`Finalizer`对象链里），如果这个类仅仅被`Finalizer`对象引用，说明这个对象在不久的将来会被回收，现在可以执行它的`finalize`方法了，于是会将这个`Finalizer`对象放到`Finalizer`类的`ReferenceQueue`里，但是这个f类对象其实并没有被回收，因为`Finalizer`这个类还对它们保持引用，在GC完成之前，JVM会调用`ReferenceQueue`中lock对象的notify方法（当`ReferenceQueue`为空时，`FinalizerThread`线程会调用`ReferenceQueue`的lock对象的wait方法直到被JVM唤醒），此时就会执行上面FinalizeThread线程里看到的其他逻辑了。\n\n## Finalizer导致的内存泄露\n\n这里举一个简单的例子，我们使用挺广的Socket通信，`SocksSocketImpl`的父类其实就实现了`finalize`方法:\n\n```\n/**\n * Cleans up if the user forgets to close it.\n */\nprotected void finalize() throws IOException {\n    close();\n}\n```\n\n其实这么做的主要目的是万一用户忘记关闭Socket，那么在这个对象被回收时能主动关闭Socket来释放一些系统资源，但是如果用户真的忘记关闭，那这些`socket`对象可能因为`FinalizeThread`迟迟没有执行这些`socket`对象的`finalize`方法，而导致内存泄露，这种问题我们碰到过多次，因此对于这类情况除了大家好好注意貌似没有什么更好的方法了，该做的事真不能省.\n\n## Finalizer的客观评价\n\n上面的过程基本对`Finalizer`的实现细节进行了完整剖析，Java里我们看到有构造函数，但是并没有看到析构函数一说，`Finalizer`其实是实现了析构函数的概念，我们在对象被回收前可以执行一些“收拾性”的逻辑，应该说是一个特殊场景的补充，但是这种概念的实现给f对象生命周期以及GC等带来了一些影响：\n\n- f对象因为`Finalizer`的引用而变成了一个临时的强引用，即使没有其他的强引用，还是无法立即被回收；\n- f对象至少经历两次GC才能被回收，因为只有在`FinalizerThread`执行完了f对象的`finalize`方法的情况下才有可能被下次GC回收，而有可能期间已经经历过多次GC了，但是一直还没执行f对象的`finalize`方法；\n- CPU资源比较稀缺的情况下`FinalizerThread`线程有可能因为优先级比较低而延迟执行f对象的`finalize`方法；\n- 因为f对象的`finalize`方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易引发old分代的GC，甚至Full GC，GC暂停时间明显变长；\n- f对象的`finalize`方法被调用后，这个对象其实还并没有被回收，虽然可能在不久的将来会被回收。\n\n## 参考\n1. [JVM 源码分析之 FinalReference 完全解读](https://www.infoq.cn/articles/jvm-source-code-analysis-finalreference)","slug":"JVM源码分析之-FinalReference完全解读","published":1,"updated":"2019-01-04T06:34:58.463Z","_id":"cjqhnxx2c0012eb1uxr3gr88e","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JVM源码分析之-FinalReference完全解读\"><a href=\"#JVM源码分析之-FinalReference完全解读\" class=\"headerlink\" title=\"JVM源码分析之 FinalReference完全解读\"></a>JVM源码分析之 FinalReference完全解读</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Java对象引用体系除了强引用之外，出于对性能、可扩展性等方面考虑还特地实现了4种其他引用：<code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference</code>、<code>FinalReference</code>，本文主要想讲的是<code>FinalReference</code>，因为当使用内存分析工具，比如zprofiler、mat等，分析一些oom的heap时，经常能看到 <code>java.lang.ref.Finalizer</code>占用的内存大小远远排在前面，而这个类占用的内存大小又和我们这次的主角<code>FinalReference</code>有着密不可分的关系。</p>\n<p><code>FinalReference</code>及关联的内容可能给我们留下如下印象：</p>\n<ul>\n<li>自己代码里从没有使用过；</li>\n<li>线程dump之后，会看到一个叫做<code>Finalizer</code>的Java线程；</li>\n<li>偶尔能注意到<code>java.lang.ref.Finalizer</code>的存在；</li>\n<li>在类里可能会写<code>finalize</code>方法。</li>\n</ul>\n<p>那<code>FinalReference</code>到底存在的意义是什么，以怎样的形式和我们的代码相关联呢？这是本文要理清的问题。<br><a id=\"more\"></a></p>\n<h2 id=\"JDK中的FinalReference\"><a href=\"#JDK中的FinalReference\" class=\"headerlink\" title=\"JDK中的FinalReference\"></a>JDK中的FinalReference</h2><p>首先我们看看<code>FinalReference</code>在JDK里的实现：</p>\n<pre><code>class FinalReference&amp;lt;T&amp;gt; extends Reference&amp;lt;T&amp;gt; {\n\n    public FinalReference(T referent, ReferenceQueue&amp;lt;? super T&amp;gt; q) {\n        super(referent, q);\n    }\n\n}\n</code></pre><p>大家应该注意到了类访问权限是package的，这也就意味着我们不能直接去对其进行扩展，但是JDK里对此类进行了扩展实现<code>java.lang.ref.Finalizer</code>，这个类在概述里提到的过，而此类的访问权限也是package的，并且是final的，意味着它不能再被扩展了，接下来的重点我们围绕<code>java.lang.ref.Finalizer</code>展开。(PS：后续讲的<code>Finalizer</code>其实也是在说<code>FinalReference</code>。)</p>\n<pre><code>final class Finalizer extends FinalReference { \n   /* Package-private; must be in same package as the \n   Referenceclass */\n\n   /* A native method that invokes an arbitrary object&#39;s  \n   finalize method is  required since the finalize method is \n   protected*/\n    static native void invokeFinalizeMethod(Object o) throws Throwable;\n\n    private static ReferenceQueue queue = new ReferenceQueue();\n    private static Finalizer unfinalized = null;\n    private static final Object lock = new Object();\n\n    private Finalizer\n        next = null,\n        prev = null;\n\n    private Finalizer(Object finalizee) {\n        super(finalizee, queue);\n        add();\n    }\n\n    /* Invoked by VM */\n    static void register(Object finalizee) {\n        new Finalizer(finalizee);\n    }  \n\n    private void add() {\n        synchronized (lock) {\n            if (unfinalized != null) {\n                this.next = unfinalized;\n                unfinalized.prev = this;\n            }\n            unfinalized = this;\n        }\n    }\n\n    ...\n\n   }    \n</code></pre><h3 id=\"Finalizer的构造函数\"><a href=\"#Finalizer的构造函数\" class=\"headerlink\" title=\"Finalizer的构造函数\"></a>Finalizer的构造函数</h3><p><code>Finalizer</code>的构造函数提供了以下几个关键信息：</p>\n<ul>\n<li><code>private</code>：意味着我们无法在当前类之外构建这类的对象；</li>\n<li><code>finalizee</code>参数：<code>FinalReference</code>指向的对象引用；</li>\n<li>调用<code>add</code>方法：将当前对象插入到<code>Finalizer</code>对象链里，链里的对象和<code>Finalizer</code>类静态关联。言外之意是在这个链里的对象都无法被GC掉，除非将这种引用关系剥离（因为<code>Finalizer</code>类无法被unload）。</li>\n</ul>\n<p>虽然外面无法创建<code>Finalizer</code>对象，但是它有一个名为<code>register</code>的静态方法，该方法可以创建这种对象，同时将这个对象加入到<code>Finalizer</code>对象链里，这个方法是被vm调用的，那么问题来了，vm在什么情况下会调用这个方法呢？</p>\n<h2 id=\"Finalizer对象何时被注册到Finalizer对象链里\"><a href=\"#Finalizer对象何时被注册到Finalizer对象链里\" class=\"headerlink\" title=\"Finalizer对象何时被注册到Finalizer对象链里\"></a>Finalizer对象何时被注册到Finalizer对象链里</h2><p>类的修饰有很多，比如final，abstract，public等，如果某个类用final修饰，我们就说这个类是final类，上面列的都是语法层面我们可以显式指定的，在JVM里其实还会给类标记一些其他符号，比如<code>finalizer</code>，表示这个类是一个<code>finalizer</code>类（为了和<code>java.lang.ref.Fianlizer</code>类区分，下文在提到的<code>finalizer</code>类时会简称为f类），GC在处理这种类的对象时要做一些特殊的处理，如在这个对象被回收之前会调用它的<code>finalize</code>方法。</p>\n<h4 id=\"如何判断一个类是不是一个final类\"><a href=\"#如何判断一个类是不是一个final类\" class=\"headerlink\" title=\"如何判断一个类是不是一个final类\"></a>如何判断一个类是不是一个final类</h4><p>在讲这个问题之前，我们先来看下<code>java.lang.Object</code>里的一个方法</p>\n<pre><code>    protected void finalize() throws Throwable { }\n</code></pre><p>在<code>Object</code>类里定义了一个名为<code>finalize</code>的空方法，这意味着Java里的所有类都会继承这个方法，甚至可以覆写该方法，并且根据方法覆写原则，如果子类覆盖此方法，方法访问权限至少protected级别的，这样其子类就算没有覆写此方法也会继承此方法。</p>\n<p>而判断当前类是否是f类的标准并不仅仅是当前类是否含有一个参数为空，返回值为void的<code>finalize</code>方法，还要求<code>finalize方法必须非空</code>，因此Object类虽然含有一个<code>finalize</code>方法，但它并不是f类，Object的对象在被GC回收时其实并不会调用它的<code>finalize</code>方法。</p>\n<p>需要注意的是，类在加载过程中其实就已经被标记为是否为f类了。（JVM在类加载的时候会遍历当前类的所有方法，包括父类的方法，只要有一个参数为空且返回void的非空<code>finalize</code>方法就认为这个类是f类。）</p>\n<h3 id=\"f类的对象何时传到Finalizer-register方法\"><a href=\"#f类的对象何时传到Finalizer-register方法\" class=\"headerlink\" title=\"f类的对象何时传到Finalizer.register方法\"></a>f类的对象何时传到Finalizer.register方法</h3><p>对象的创建其实是被拆分成多个步骤的，比如<code>A a=new A(2)</code>这样一条语句对应的字节码如下：</p>\n<pre><code>0: new           #1                  // class A\n3: dup\n4: iconst_2\n5: invokespecial #11                 // Method &quot;&amp;lt;init&amp;gt;&quot;:(I)V\n</code></pre><p>先执行new分配好对象空间，然后再执行invokespecial调用构造函数，JVM里其实可以让用户在这两个时机中选择一个，将当前对象传递给<code>Finalizer.register</code>方法来注册到<code>Finalizer</code>对象链里，这个选择取决于是否设置了<code>RegisterFinalizersAtInit</code>这个vm参数，默认值为true，也就是在构造函数返回之前调用<code>Finalizer.register</code>方法，如果通过<code>-XX:-RegisterFinalizersAtInit</code>关闭了该参数，那将在对象空间分配好之后将这个对象注册进去。</p>\n<p>另外需要提醒的是，当我们通过clone的方式复制一个对象时，如果当前类是一个f类，那么在clone完成时将调用<code>Finalizer.register</code>方法进行注册。</p>\n<h3 id=\"hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer-register\"><a href=\"#hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer-register\" class=\"headerlink\" title=\"hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register\"></a>hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register</h3><p>这个实现比较有意思，在这简单提一下，我们知道执行一个构造函数时，会去调用父类的构造函数，主要是为了初始化继承自父类的属性，那么任何一个对象的初始化最终都会调用到<code>Object</code>的空构造函数里（任何空的构造函数其实并不空，会含有三条字节码指令，如下代码所示），为了不对所有类的构造函数都埋点调用<code>Finalizer.register</code>方法，hotspot的实现是，在初始化<code>Object</code>类时将构造函数里的<code>return</code>指令替换为<code>_return_register_finalizer</code>指令，该指令并不是标准的字节码指令，是hotspot扩展的指令，这样在处理该指令时调用<code>Finalizer.register</code>方法，以很小的侵入性代价完美地解决了这个问题。</p>\n<pre><code>0: aload_0\n1: invokespecial #21                 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V\n4: return\n</code></pre><h2 id=\"f类对象的GC回收\"><a href=\"#f类对象的GC回收\" class=\"headerlink\" title=\"f类对象的GC回收\"></a>f类对象的GC回收</h2><h3 id=\"FinalizerThread线程\"><a href=\"#FinalizerThread线程\" class=\"headerlink\" title=\"FinalizerThread线程\"></a>FinalizerThread线程</h3><p>在<code>Finalizer</code>类的<code>clinit</code>方法（静态块）里，我们看到它会创建一个<code>FinalizerThread</code>守护线程，这个线程的优先级并不是最高的，意味着在CPU很紧张的情况下其被调度的优先级可能会受到影响</p>\n<pre><code>  private static class FinalizerThread extends Thread {\n        private volatile boolean running;\n        FinalizerThread(ThreadGroup g) {\n            super(g, &quot;Finalizer&quot;);\n        }\n        public void run() {\n            if (running)\n                return;\n            running = true;\n            for (;;) {\n                try {\n                    Finalizer f = (Finalizer)queue.remove();\n                    f.runFinalizer();\n                } catch (InterruptedException x) {\n                    continue;\n                }\n            }\n        }\n    }\n\n    static {\n        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n        for (ThreadGroup tgn = tg;\n             tgn != null;\n             tg = tgn, tgn = tg.getParent());\n        Thread finalizer = new FinalizerThread(tg);\n        finalizer.setPriority(Thread.MAX_PRIORITY - 2);\n        finalizer.setDaemon(true);\n        finalizer.start();\n    }\n</code></pre><p>这个线程用来从queue里获取<code>Finalizer</code>对象，然后执行该对象的<code>runFinalizer</code>方法，该方法会将<code>Finalizer</code>对象从<code>Finalizer</code>对象链里剥离出来，这样意味着下次GC发生时就可以将其关联的f对象回收了，最后将这个<code>Finalizer</code>对象关联的f对象传给一个native方法<code>invokeFinalizeMethod</code></p>\n<pre><code>private void runFinalizer() {\n        synchronized (this) {\n            if (hasBeenFinalized()) return;\n            remove();\n        }\n        try {\n            Object finalizee = this.get();\n            if (finalizee != null &amp;&amp; !(finalizee instanceof java.lang.Enum)) {\n                invokeFinalizeMethod(finalizee);\n                /* Clear stack slot containing this variable, to decrease\n                   the chances of false retention with a conservative GC */\n                finalizee = null;\n            }\n        } catch (Throwable x) { }\n        super.clear();\n    }\n\n static native void invokeFinalizeMethod(Object o) throws Throwable;\n</code></pre><p>其实<code>invokeFinalizeMethod</code>方法就是调了这个f对象的finalize方法，看到这里大家应该恍然大悟了，整个过程都串起来了。</p>\n<pre><code>JNIEXPORT void JNICALL\nJava_java_lang_ref_Finalizer_invokeFinalizeMethod(JNIEnv *env, jclass clazz,\n                                                  jobject ob)\n{\n    jclass cls;\n    jmethodID mid;\n\n    cls = (*env)-&amp;gt;GetObjectClass(env, ob);\n    if (cls == NULL) return;\n    mid = (*env)-&amp;gt;GetMethodID(env, cls, &quot;finalize&quot;, &quot;()V&quot;);\n    if (mid == NULL) return;\n    (*env)-&amp;gt;CallVoidMethod(env, ob, mid);\n}\n</code></pre><h3 id=\"f对象的finalize方法抛出异常会导致FinalizeThread退出吗\"><a href=\"#f对象的finalize方法抛出异常会导致FinalizeThread退出吗\" class=\"headerlink\" title=\"f对象的finalize方法抛出异常会导致FinalizeThread退出吗\"></a>f对象的finalize方法抛出异常会导致FinalizeThread退出吗</h3><p>不知道大家有没有想过如果f对象的<code>finalize</code>方法抛了一个没捕获的异常，这个<code>FinalizerThread</code>会不会退出呢，细心的读者看上面的代码其实就可以找到答案，<code>runFinalizer</code>方法里对<code>Throwable</code>的异常进行了捕获，因此不可能出现<code>FinalizerThread</code>因异常未捕获而退出的情况。</p>\n<h3 id=\"f对象的finalize方法会执行多次吗\"><a href=\"#f对象的finalize方法会执行多次吗\" class=\"headerlink\" title=\"f对象的finalize方法会执行多次吗\"></a>f对象的finalize方法会执行多次吗</h3><p>如果我们在f对象的<code>finalize</code>方法里重新将当前对象赋值，变成可达对象，当这个f对象再次变成不可达时还会执行<code>finalize</code>方法吗？答案是否定的，因为在执行完第一次<code>finalize</code>方法后，这个f对象已经和之前的<code>Finalizer</code>对象剥离了，也就是下次GC的时候不会再发现<code>Finalizer</code>对象指向该f对象了，自然也就不会调用这个f对象的<code>finalize</code>方法了。</p>\n<h3 id=\"Finalizer对象何时被放到ReferenceQueue里\"><a href=\"#Finalizer对象何时被放到ReferenceQueue里\" class=\"headerlink\" title=\"Finalizer对象何时被放到ReferenceQueue里\"></a>Finalizer对象何时被放到ReferenceQueue里</h3><p>除了这里接下来要介绍的环节之外，整个过程大家应该都比较清楚了。</p>\n<p>当GC发生时，GC算法会判断f类对象是不是只被<code>Finalizer</code>类引用（f类对象被<code>Finalizer</code>对象引用，然后放到<code>Finalizer</code>对象链里），如果这个类仅仅被<code>Finalizer</code>对象引用，说明这个对象在不久的将来会被回收，现在可以执行它的<code>finalize</code>方法了，于是会将这个<code>Finalizer</code>对象放到<code>Finalizer</code>类的<code>ReferenceQueue</code>里，但是这个f类对象其实并没有被回收，因为<code>Finalizer</code>这个类还对它们保持引用，在GC完成之前，JVM会调用<code>ReferenceQueue</code>中lock对象的notify方法（当<code>ReferenceQueue</code>为空时，<code>FinalizerThread</code>线程会调用<code>ReferenceQueue</code>的lock对象的wait方法直到被JVM唤醒），此时就会执行上面FinalizeThread线程里看到的其他逻辑了。</p>\n<h2 id=\"Finalizer导致的内存泄露\"><a href=\"#Finalizer导致的内存泄露\" class=\"headerlink\" title=\"Finalizer导致的内存泄露\"></a>Finalizer导致的内存泄露</h2><p>这里举一个简单的例子，我们使用挺广的Socket通信，<code>SocksSocketImpl</code>的父类其实就实现了<code>finalize</code>方法:</p>\n<pre><code>/**\n * Cleans up if the user forgets to close it.\n */\nprotected void finalize() throws IOException {\n    close();\n}\n</code></pre><p>其实这么做的主要目的是万一用户忘记关闭Socket，那么在这个对象被回收时能主动关闭Socket来释放一些系统资源，但是如果用户真的忘记关闭，那这些<code>socket</code>对象可能因为<code>FinalizeThread</code>迟迟没有执行这些<code>socket</code>对象的<code>finalize</code>方法，而导致内存泄露，这种问题我们碰到过多次，因此对于这类情况除了大家好好注意貌似没有什么更好的方法了，该做的事真不能省.</p>\n<h2 id=\"Finalizer的客观评价\"><a href=\"#Finalizer的客观评价\" class=\"headerlink\" title=\"Finalizer的客观评价\"></a>Finalizer的客观评价</h2><p>上面的过程基本对<code>Finalizer</code>的实现细节进行了完整剖析，Java里我们看到有构造函数，但是并没有看到析构函数一说，<code>Finalizer</code>其实是实现了析构函数的概念，我们在对象被回收前可以执行一些“收拾性”的逻辑，应该说是一个特殊场景的补充，但是这种概念的实现给f对象生命周期以及GC等带来了一些影响：</p>\n<ul>\n<li>f对象因为<code>Finalizer</code>的引用而变成了一个临时的强引用，即使没有其他的强引用，还是无法立即被回收；</li>\n<li>f对象至少经历两次GC才能被回收，因为只有在<code>FinalizerThread</code>执行完了f对象的<code>finalize</code>方法的情况下才有可能被下次GC回收，而有可能期间已经经历过多次GC了，但是一直还没执行f对象的<code>finalize</code>方法；</li>\n<li>CPU资源比较稀缺的情况下<code>FinalizerThread</code>线程有可能因为优先级比较低而延迟执行f对象的<code>finalize</code>方法；</li>\n<li>因为f对象的<code>finalize</code>方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易引发old分代的GC，甚至Full GC，GC暂停时间明显变长；</li>\n<li>f对象的<code>finalize</code>方法被调用后，这个对象其实还并没有被回收，虽然可能在不久的将来会被回收。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.infoq.cn/articles/jvm-source-code-analysis-finalreference\" target=\"_blank\" rel=\"noopener\">JVM 源码分析之 FinalReference 完全解读</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"JVM源码分析之-FinalReference完全解读\"><a href=\"#JVM源码分析之-FinalReference完全解读\" class=\"headerlink\" title=\"JVM源码分析之 FinalReference完全解读\"></a>JVM源码分析之 FinalReference完全解读</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Java对象引用体系除了强引用之外，出于对性能、可扩展性等方面考虑还特地实现了4种其他引用：<code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference</code>、<code>FinalReference</code>，本文主要想讲的是<code>FinalReference</code>，因为当使用内存分析工具，比如zprofiler、mat等，分析一些oom的heap时，经常能看到 <code>java.lang.ref.Finalizer</code>占用的内存大小远远排在前面，而这个类占用的内存大小又和我们这次的主角<code>FinalReference</code>有着密不可分的关系。</p>\n<p><code>FinalReference</code>及关联的内容可能给我们留下如下印象：</p>\n<ul>\n<li>自己代码里从没有使用过；</li>\n<li>线程dump之后，会看到一个叫做<code>Finalizer</code>的Java线程；</li>\n<li>偶尔能注意到<code>java.lang.ref.Finalizer</code>的存在；</li>\n<li>在类里可能会写<code>finalize</code>方法。</li>\n</ul>\n<p>那<code>FinalReference</code>到底存在的意义是什么，以怎样的形式和我们的代码相关联呢？这是本文要理清的问题。<br>","more":"</p>\n<h2 id=\"JDK中的FinalReference\"><a href=\"#JDK中的FinalReference\" class=\"headerlink\" title=\"JDK中的FinalReference\"></a>JDK中的FinalReference</h2><p>首先我们看看<code>FinalReference</code>在JDK里的实现：</p>\n<pre><code>class FinalReference&amp;lt;T&amp;gt; extends Reference&amp;lt;T&amp;gt; {\n\n    public FinalReference(T referent, ReferenceQueue&amp;lt;? super T&amp;gt; q) {\n        super(referent, q);\n    }\n\n}\n</code></pre><p>大家应该注意到了类访问权限是package的，这也就意味着我们不能直接去对其进行扩展，但是JDK里对此类进行了扩展实现<code>java.lang.ref.Finalizer</code>，这个类在概述里提到的过，而此类的访问权限也是package的，并且是final的，意味着它不能再被扩展了，接下来的重点我们围绕<code>java.lang.ref.Finalizer</code>展开。(PS：后续讲的<code>Finalizer</code>其实也是在说<code>FinalReference</code>。)</p>\n<pre><code>final class Finalizer extends FinalReference { \n   /* Package-private; must be in same package as the \n   Referenceclass */\n\n   /* A native method that invokes an arbitrary object&#39;s  \n   finalize method is  required since the finalize method is \n   protected*/\n    static native void invokeFinalizeMethod(Object o) throws Throwable;\n\n    private static ReferenceQueue queue = new ReferenceQueue();\n    private static Finalizer unfinalized = null;\n    private static final Object lock = new Object();\n\n    private Finalizer\n        next = null,\n        prev = null;\n\n    private Finalizer(Object finalizee) {\n        super(finalizee, queue);\n        add();\n    }\n\n    /* Invoked by VM */\n    static void register(Object finalizee) {\n        new Finalizer(finalizee);\n    }  \n\n    private void add() {\n        synchronized (lock) {\n            if (unfinalized != null) {\n                this.next = unfinalized;\n                unfinalized.prev = this;\n            }\n            unfinalized = this;\n        }\n    }\n\n    ...\n\n   }    \n</code></pre><h3 id=\"Finalizer的构造函数\"><a href=\"#Finalizer的构造函数\" class=\"headerlink\" title=\"Finalizer的构造函数\"></a>Finalizer的构造函数</h3><p><code>Finalizer</code>的构造函数提供了以下几个关键信息：</p>\n<ul>\n<li><code>private</code>：意味着我们无法在当前类之外构建这类的对象；</li>\n<li><code>finalizee</code>参数：<code>FinalReference</code>指向的对象引用；</li>\n<li>调用<code>add</code>方法：将当前对象插入到<code>Finalizer</code>对象链里，链里的对象和<code>Finalizer</code>类静态关联。言外之意是在这个链里的对象都无法被GC掉，除非将这种引用关系剥离（因为<code>Finalizer</code>类无法被unload）。</li>\n</ul>\n<p>虽然外面无法创建<code>Finalizer</code>对象，但是它有一个名为<code>register</code>的静态方法，该方法可以创建这种对象，同时将这个对象加入到<code>Finalizer</code>对象链里，这个方法是被vm调用的，那么问题来了，vm在什么情况下会调用这个方法呢？</p>\n<h2 id=\"Finalizer对象何时被注册到Finalizer对象链里\"><a href=\"#Finalizer对象何时被注册到Finalizer对象链里\" class=\"headerlink\" title=\"Finalizer对象何时被注册到Finalizer对象链里\"></a>Finalizer对象何时被注册到Finalizer对象链里</h2><p>类的修饰有很多，比如final，abstract，public等，如果某个类用final修饰，我们就说这个类是final类，上面列的都是语法层面我们可以显式指定的，在JVM里其实还会给类标记一些其他符号，比如<code>finalizer</code>，表示这个类是一个<code>finalizer</code>类（为了和<code>java.lang.ref.Fianlizer</code>类区分，下文在提到的<code>finalizer</code>类时会简称为f类），GC在处理这种类的对象时要做一些特殊的处理，如在这个对象被回收之前会调用它的<code>finalize</code>方法。</p>\n<h4 id=\"如何判断一个类是不是一个final类\"><a href=\"#如何判断一个类是不是一个final类\" class=\"headerlink\" title=\"如何判断一个类是不是一个final类\"></a>如何判断一个类是不是一个final类</h4><p>在讲这个问题之前，我们先来看下<code>java.lang.Object</code>里的一个方法</p>\n<pre><code>    protected void finalize() throws Throwable { }\n</code></pre><p>在<code>Object</code>类里定义了一个名为<code>finalize</code>的空方法，这意味着Java里的所有类都会继承这个方法，甚至可以覆写该方法，并且根据方法覆写原则，如果子类覆盖此方法，方法访问权限至少protected级别的，这样其子类就算没有覆写此方法也会继承此方法。</p>\n<p>而判断当前类是否是f类的标准并不仅仅是当前类是否含有一个参数为空，返回值为void的<code>finalize</code>方法，还要求<code>finalize方法必须非空</code>，因此Object类虽然含有一个<code>finalize</code>方法，但它并不是f类，Object的对象在被GC回收时其实并不会调用它的<code>finalize</code>方法。</p>\n<p>需要注意的是，类在加载过程中其实就已经被标记为是否为f类了。（JVM在类加载的时候会遍历当前类的所有方法，包括父类的方法，只要有一个参数为空且返回void的非空<code>finalize</code>方法就认为这个类是f类。）</p>\n<h3 id=\"f类的对象何时传到Finalizer-register方法\"><a href=\"#f类的对象何时传到Finalizer-register方法\" class=\"headerlink\" title=\"f类的对象何时传到Finalizer.register方法\"></a>f类的对象何时传到Finalizer.register方法</h3><p>对象的创建其实是被拆分成多个步骤的，比如<code>A a=new A(2)</code>这样一条语句对应的字节码如下：</p>\n<pre><code>0: new           #1                  // class A\n3: dup\n4: iconst_2\n5: invokespecial #11                 // Method &quot;&amp;lt;init&amp;gt;&quot;:(I)V\n</code></pre><p>先执行new分配好对象空间，然后再执行invokespecial调用构造函数，JVM里其实可以让用户在这两个时机中选择一个，将当前对象传递给<code>Finalizer.register</code>方法来注册到<code>Finalizer</code>对象链里，这个选择取决于是否设置了<code>RegisterFinalizersAtInit</code>这个vm参数，默认值为true，也就是在构造函数返回之前调用<code>Finalizer.register</code>方法，如果通过<code>-XX:-RegisterFinalizersAtInit</code>关闭了该参数，那将在对象空间分配好之后将这个对象注册进去。</p>\n<p>另外需要提醒的是，当我们通过clone的方式复制一个对象时，如果当前类是一个f类，那么在clone完成时将调用<code>Finalizer.register</code>方法进行注册。</p>\n<h3 id=\"hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer-register\"><a href=\"#hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer-register\" class=\"headerlink\" title=\"hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register\"></a>hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register</h3><p>这个实现比较有意思，在这简单提一下，我们知道执行一个构造函数时，会去调用父类的构造函数，主要是为了初始化继承自父类的属性，那么任何一个对象的初始化最终都会调用到<code>Object</code>的空构造函数里（任何空的构造函数其实并不空，会含有三条字节码指令，如下代码所示），为了不对所有类的构造函数都埋点调用<code>Finalizer.register</code>方法，hotspot的实现是，在初始化<code>Object</code>类时将构造函数里的<code>return</code>指令替换为<code>_return_register_finalizer</code>指令，该指令并不是标准的字节码指令，是hotspot扩展的指令，这样在处理该指令时调用<code>Finalizer.register</code>方法，以很小的侵入性代价完美地解决了这个问题。</p>\n<pre><code>0: aload_0\n1: invokespecial #21                 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V\n4: return\n</code></pre><h2 id=\"f类对象的GC回收\"><a href=\"#f类对象的GC回收\" class=\"headerlink\" title=\"f类对象的GC回收\"></a>f类对象的GC回收</h2><h3 id=\"FinalizerThread线程\"><a href=\"#FinalizerThread线程\" class=\"headerlink\" title=\"FinalizerThread线程\"></a>FinalizerThread线程</h3><p>在<code>Finalizer</code>类的<code>clinit</code>方法（静态块）里，我们看到它会创建一个<code>FinalizerThread</code>守护线程，这个线程的优先级并不是最高的，意味着在CPU很紧张的情况下其被调度的优先级可能会受到影响</p>\n<pre><code>  private static class FinalizerThread extends Thread {\n        private volatile boolean running;\n        FinalizerThread(ThreadGroup g) {\n            super(g, &quot;Finalizer&quot;);\n        }\n        public void run() {\n            if (running)\n                return;\n            running = true;\n            for (;;) {\n                try {\n                    Finalizer f = (Finalizer)queue.remove();\n                    f.runFinalizer();\n                } catch (InterruptedException x) {\n                    continue;\n                }\n            }\n        }\n    }\n\n    static {\n        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n        for (ThreadGroup tgn = tg;\n             tgn != null;\n             tg = tgn, tgn = tg.getParent());\n        Thread finalizer = new FinalizerThread(tg);\n        finalizer.setPriority(Thread.MAX_PRIORITY - 2);\n        finalizer.setDaemon(true);\n        finalizer.start();\n    }\n</code></pre><p>这个线程用来从queue里获取<code>Finalizer</code>对象，然后执行该对象的<code>runFinalizer</code>方法，该方法会将<code>Finalizer</code>对象从<code>Finalizer</code>对象链里剥离出来，这样意味着下次GC发生时就可以将其关联的f对象回收了，最后将这个<code>Finalizer</code>对象关联的f对象传给一个native方法<code>invokeFinalizeMethod</code></p>\n<pre><code>private void runFinalizer() {\n        synchronized (this) {\n            if (hasBeenFinalized()) return;\n            remove();\n        }\n        try {\n            Object finalizee = this.get();\n            if (finalizee != null &amp;&amp; !(finalizee instanceof java.lang.Enum)) {\n                invokeFinalizeMethod(finalizee);\n                /* Clear stack slot containing this variable, to decrease\n                   the chances of false retention with a conservative GC */\n                finalizee = null;\n            }\n        } catch (Throwable x) { }\n        super.clear();\n    }\n\n static native void invokeFinalizeMethod(Object o) throws Throwable;\n</code></pre><p>其实<code>invokeFinalizeMethod</code>方法就是调了这个f对象的finalize方法，看到这里大家应该恍然大悟了，整个过程都串起来了。</p>\n<pre><code>JNIEXPORT void JNICALL\nJava_java_lang_ref_Finalizer_invokeFinalizeMethod(JNIEnv *env, jclass clazz,\n                                                  jobject ob)\n{\n    jclass cls;\n    jmethodID mid;\n\n    cls = (*env)-&amp;gt;GetObjectClass(env, ob);\n    if (cls == NULL) return;\n    mid = (*env)-&amp;gt;GetMethodID(env, cls, &quot;finalize&quot;, &quot;()V&quot;);\n    if (mid == NULL) return;\n    (*env)-&amp;gt;CallVoidMethod(env, ob, mid);\n}\n</code></pre><h3 id=\"f对象的finalize方法抛出异常会导致FinalizeThread退出吗\"><a href=\"#f对象的finalize方法抛出异常会导致FinalizeThread退出吗\" class=\"headerlink\" title=\"f对象的finalize方法抛出异常会导致FinalizeThread退出吗\"></a>f对象的finalize方法抛出异常会导致FinalizeThread退出吗</h3><p>不知道大家有没有想过如果f对象的<code>finalize</code>方法抛了一个没捕获的异常，这个<code>FinalizerThread</code>会不会退出呢，细心的读者看上面的代码其实就可以找到答案，<code>runFinalizer</code>方法里对<code>Throwable</code>的异常进行了捕获，因此不可能出现<code>FinalizerThread</code>因异常未捕获而退出的情况。</p>\n<h3 id=\"f对象的finalize方法会执行多次吗\"><a href=\"#f对象的finalize方法会执行多次吗\" class=\"headerlink\" title=\"f对象的finalize方法会执行多次吗\"></a>f对象的finalize方法会执行多次吗</h3><p>如果我们在f对象的<code>finalize</code>方法里重新将当前对象赋值，变成可达对象，当这个f对象再次变成不可达时还会执行<code>finalize</code>方法吗？答案是否定的，因为在执行完第一次<code>finalize</code>方法后，这个f对象已经和之前的<code>Finalizer</code>对象剥离了，也就是下次GC的时候不会再发现<code>Finalizer</code>对象指向该f对象了，自然也就不会调用这个f对象的<code>finalize</code>方法了。</p>\n<h3 id=\"Finalizer对象何时被放到ReferenceQueue里\"><a href=\"#Finalizer对象何时被放到ReferenceQueue里\" class=\"headerlink\" title=\"Finalizer对象何时被放到ReferenceQueue里\"></a>Finalizer对象何时被放到ReferenceQueue里</h3><p>除了这里接下来要介绍的环节之外，整个过程大家应该都比较清楚了。</p>\n<p>当GC发生时，GC算法会判断f类对象是不是只被<code>Finalizer</code>类引用（f类对象被<code>Finalizer</code>对象引用，然后放到<code>Finalizer</code>对象链里），如果这个类仅仅被<code>Finalizer</code>对象引用，说明这个对象在不久的将来会被回收，现在可以执行它的<code>finalize</code>方法了，于是会将这个<code>Finalizer</code>对象放到<code>Finalizer</code>类的<code>ReferenceQueue</code>里，但是这个f类对象其实并没有被回收，因为<code>Finalizer</code>这个类还对它们保持引用，在GC完成之前，JVM会调用<code>ReferenceQueue</code>中lock对象的notify方法（当<code>ReferenceQueue</code>为空时，<code>FinalizerThread</code>线程会调用<code>ReferenceQueue</code>的lock对象的wait方法直到被JVM唤醒），此时就会执行上面FinalizeThread线程里看到的其他逻辑了。</p>\n<h2 id=\"Finalizer导致的内存泄露\"><a href=\"#Finalizer导致的内存泄露\" class=\"headerlink\" title=\"Finalizer导致的内存泄露\"></a>Finalizer导致的内存泄露</h2><p>这里举一个简单的例子，我们使用挺广的Socket通信，<code>SocksSocketImpl</code>的父类其实就实现了<code>finalize</code>方法:</p>\n<pre><code>/**\n * Cleans up if the user forgets to close it.\n */\nprotected void finalize() throws IOException {\n    close();\n}\n</code></pre><p>其实这么做的主要目的是万一用户忘记关闭Socket，那么在这个对象被回收时能主动关闭Socket来释放一些系统资源，但是如果用户真的忘记关闭，那这些<code>socket</code>对象可能因为<code>FinalizeThread</code>迟迟没有执行这些<code>socket</code>对象的<code>finalize</code>方法，而导致内存泄露，这种问题我们碰到过多次，因此对于这类情况除了大家好好注意貌似没有什么更好的方法了，该做的事真不能省.</p>\n<h2 id=\"Finalizer的客观评价\"><a href=\"#Finalizer的客观评价\" class=\"headerlink\" title=\"Finalizer的客观评价\"></a>Finalizer的客观评价</h2><p>上面的过程基本对<code>Finalizer</code>的实现细节进行了完整剖析，Java里我们看到有构造函数，但是并没有看到析构函数一说，<code>Finalizer</code>其实是实现了析构函数的概念，我们在对象被回收前可以执行一些“收拾性”的逻辑，应该说是一个特殊场景的补充，但是这种概念的实现给f对象生命周期以及GC等带来了一些影响：</p>\n<ul>\n<li>f对象因为<code>Finalizer</code>的引用而变成了一个临时的强引用，即使没有其他的强引用，还是无法立即被回收；</li>\n<li>f对象至少经历两次GC才能被回收，因为只有在<code>FinalizerThread</code>执行完了f对象的<code>finalize</code>方法的情况下才有可能被下次GC回收，而有可能期间已经经历过多次GC了，但是一直还没执行f对象的<code>finalize</code>方法；</li>\n<li>CPU资源比较稀缺的情况下<code>FinalizerThread</code>线程有可能因为优先级比较低而延迟执行f对象的<code>finalize</code>方法；</li>\n<li>因为f对象的<code>finalize</code>方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易引发old分代的GC，甚至Full GC，GC暂停时间明显变长；</li>\n<li>f对象的<code>finalize</code>方法被调用后，这个对象其实还并没有被回收，虽然可能在不久的将来会被回收。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.infoq.cn/articles/jvm-source-code-analysis-finalreference\" target=\"_blank\" rel=\"noopener\">JVM 源码分析之 FinalReference 完全解读</a></li>\n</ol>"},{"title":"Java Reference详解","author":"枫秀天涯","abbrlink":28002,"date":"2019-01-04T02:25:00.000Z","_content":"# Java Reference详解\n\n### 概述\n\nJava引用体系中我们最熟悉的就是强引用类型，如 A a= new A();这是我们经常说的强引用StrongReference，jvm gc时会检测对象是否存在强引用，如果存在由根对象对其有传递的强引用，则不会对其进行回收，即使内存不足抛出OutOfMemoryError。\n\n除了强引用外，Java还引入了SoftReference，WeakReference，PhantomReference，FinalReference ，这些类放在java.lang.ref包下，类的继承体系如下图。Java额外引入这个四种类型引用主要目的是在jvm 在gc时，按照引用类型的不同，在回收时采用不同的逻辑。可以把这些引用看作是对对象的一层包裹，jvm根据外层不同的包裹，对其包裹的对象采用不同的回收策略，或特殊逻辑处理。 这几种类型的引用主要在jvm内存缓存、资源释放、对象可达性事件处理等场景会用到。\n\n![输入图片说明](https://static.oschina.net/uploads/img/201701/21153037_ubGO.png)\n\n本篇文章主要讲解前面三种SoftReference，WeakReference和PhantomReference的使用，以及ReferenceQueue的使用。至于FinalRefeence会在另一篇文章中讲解。\n<!-- more -->\n主要内容如下\n\n1. 对象可达性判断\n2. ReferenceQueue 简介\n3. SoftReference简介及使用\n4. WeakReference简介及使用\n5. PhantomReference简介及使用\n6. 总结\n\n**本文名称使用说明**名称说明下：Reference指代引用对象本身，Referent指代被引用对象，下文介绍会以Reference，Referent形式出现。 \n\n### 1. 对象可达性判断\n\njvm gc时，判断一个对象是否存在引用时，都是从根结合引用(Root Set of References)开始去标识,往往到达一个对象的引用路径会存在多条，如下图。 ![输入图片说明](https://static.oschina.net/uploads/img/201701/21165610_kkb9.png)\n\n那么 垃圾回收时会依据两个原则来判断对象的可达性：\n\n- 单一路径中，以最弱的引用为准\n- 多路径中，以最强的引用为准\n\n例如Obj4的引用，存在3个路径:1->6、2->5、3->4, 那么从根对象到Obj4最强的引用是2->5，因为它们都是强引用。如果仅仅存在一个路径对Obj4有引用时，比如现在只剩1->6,那么根对象到Obj4的引用就是以最弱的为准，就是SoftReference引用,Obj4就是softly-reachable对象。如果是WeakReference引用，就称作weakly-reachable对象。只要一个对象是强引用可达，那么这个对象就不会被gc，即使发生OOM也不会回收这个对象。\n\n### 2. ReferenceQueue 简介\n\n引用队列，在检测到适当的可到达性更改后，即Referent对象的可达性发生适当的改变时，垃圾回收器将已注册的引用对象reference添加到该队列中。\n\n简单用下面代码来说明\n\n```java\nObject object = new Object();\nReferenceQueue  queue = new ReferenceQueue();\nSoftReference<Objecct> soft = new SoftReference<>(object,queue);\nobject = null;\nSysten.gc();\n//休眠一会，等待gc完成\nThread.sleep(100);\nSystem.out.println(queue.poll() == soft);\nSystem.out.println(soft.get() == null)\n```\n\n输出结果：\n\n```java\ntrue\ntrue\n```\n\n结果分析：\n\n对应上面第一句话，就是说当soft引用对象包含的object对象被gc之后，其可达性就会发生改变，同时会将soft对象注册到queue这个引用队列中。可以使用poll()这个方法取出被所有可达性改变的引用对象。\n\nReferenceQueue实现了一个队列的入队(enqueue)和出队(poll,remove)操作，内部元素就是泛型的Reference，并且Queue的实现，是由Reference自身的链表结构( 单向循环链表 )所实现的。\n\nReferenceQueue名义上是一个队列，但实际内部并非有实际的存储结构，它的存储是依赖于内部节点之间的关系来表达。可以理解为queue是一个类似于链表的结构，这里的节点其实就是reference本身。可以理解为queue为一个链表的容器，其自己仅存储当前的head节点，而后面的节点由每个reference节点自己通过next来保持即可。\n\n具体源码分析可以参考这个网站：[ReferenceQueue源码分析参考](http://www.importnew.com/26250.html)\n\n因此可以看出，当reference与referenQueue联合使用的主要作用就是当reference指向的referent回收时，提供一种通知机制，通过queue取到这些reference，来做额外的处理工作。当然，如果我们不需要这种通知机制，在创建Reference对象时不传入queue对象即可。\n\n### 3. SoftReference简介及使用\n\n根据上面我们讲的对象可达性原理，我们把一个对象存在根对象对其有直接或间接的SoftReference，并没有其他强引用路径，我们把该对象成为softly-reachable对象。JVM保证在抛出OutOfMemoryError前会回收这些softly-reachable对象。JVM会根据当前内存的情况来决定是否回收softly-reachable对象，但只要referent有强引用存在，该referent就一定不会被清理，因此SoftReference适合用来实现memory-sensitive caches。\n\n可见，SoftReference在一定程度上会影响JVM GC的，例如softly-reachable对应的referent多次垃圾回收仍然不满足释放条件，那么它会停留在heap old区，占据很大部分空间，在JVM没有抛出OutOfMemoryError前，它有可能会导致频繁的Full GC。\n\n下面是我使用SoftReference做的一个简单的缓存图片的测试\n\n```java\npublic class SoftReferenceImageTest {\n    public static void main(String[] args) throws IOException {\n        testImageLoad();\n    }\n\n    public static void testImageLoad() throws IOException {\n        String s = \"xmind.png\";\n        HashMap<String, SoftReference<byte[]>> map = new HashMap<>(100);\n        for (int i = 0; i < 100; i++) {\n            FileInputStream inputStream = new FileInputStream(s);\n            byte[] bytes = new byte[(int) inputStream.getChannel().size()];\n            while (inputStream.read(bytes) > 0) ;\n            inputStream.close();\n            map.put(s + i, new SoftReference<byte[]>(bytes));\n        }\n        for (int i = 0; i < map.size(); i++) {\n\n            Optional.ofNullable(map.get(s + i))\n                    .filter(softReference -> softReference.get() != null)\n                    .ifPresent(softReference -> {\n                        System.out.println(\"ok\");\n                    });\n        }\n\n    }\n}\n```\n\n运行这段代码时，加上jvm参数(**-Xms10M -Xmx10M -Xmn5M -XX:+PrintGCDetails**)\n\n运行结果为空，因为我加载的图片是5M，而分配给运行时的jvm是10M,所以每次加载完一张图片之后，在下一次加载就会清理这个SoftReference对象，因此最后得到的结果为空。\n\n### 4. WeakReference简介及使用\n\n当一个对象被WeakReference引用时，处于weakly-reachable状态时，只要发生GC时，就会被清除，同时会把WeakReference注册到引用队列中(如果存在的话)。 WeakReference不阻碍或影响它们对应的referent被终结(finalized)和回收(reclaimed)，因此，WeakReference经常被用作实现规范映射(canonicalizing mappings)。相比SoftReference来说，WeakReference对JVM GC几乎是没有影响的。\n\n下面是一个简单的demo\n\n```java\npublic class WeakReferenceTest {\n    public static void main(String[] args) {\n        weak();\n    }\n\n    public static void weak() {\n        ReferenceQueue<Integer> referenceQueue = new ReferenceQueue<>();\n        WeakReference<Integer> weak = new WeakReference<Integer>(new Integer(100), \n                                                                 referenceQueue);\n        System.out.println(\"GC 前===>\" + weak.get());\n        System.gc();\n        System.out.println(\"GC 后===>\" + weak.get());\n      \n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(referenceQueue.poll() == weak);\n    }\n}\n```\n\n运行结果\n\n```java\nGC 前===>100\nGC 后===>null\ntrue\n```\n\n结果分析：\n\n从上面我么可以看到，WeakReference所对应的Referent对象被回收了，因此验证了只要发生gc，weakly-reachable对象就会被gc回收。\n\n另外可以查看这篇文章，仔细说明jdk中WeakHashMap在Tomact中使用的场景[WeakHashMap使用场景](https://blog.csdn.net/kaka0509/article/details/73459419)\n\n### 5. PhantomReference简介及使用\n\n PhantomReference 不同于WeakReference、SoftReference，它存在的意义不是为了获取referent,因为你也永远获取不到，因为它的get如下\n\n```java\n public T get() {\n        return null;\n }\n```\n\nPhantomReference主要作为其指向的referent被回收时的一种通知机制,它就是利用上文讲到的ReferenceQueue实现的。当referent被gc回收时，JVM自动把PhantomReference对象(reference)本身加入到ReferenceQueue中，像发出信号通知一样，表明该reference指向的referent被回收。然后可以通过去queue中取到reference，此时说明其指向的referent已经被回收，可以通过这个通知机制来做额外的清场工作。 因此有些情况可以用PhantomReference 代替finalize()，做资源释放更明智。\n\n下面举个例子，用PhantomReference来自动关闭文件流。\n\n```java\npublic class ResourcePhantomReference<T> extends PhantomReference<T> {\n\n    private List<Closeable> closeables;\n\n    public ResourcePhantomReference(T referent, ReferenceQueue<? super T> q, List<Closeable> resource) {\n        super(referent, q);\n        closeables = resource;\n    }\n\n    public void cleanUp() {\n        if (closeables == null || closeables.size() == 0)\n            return;\n        for (Closeable closeable : closeables) {\n            try {\n                closeable.close();\n                System.out.println(\"clean up:\"+closeable);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n```java\npublic class ResourceCloseDeamon extends Thread {\n\n    private static ReferenceQueue QUEUE = new ReferenceQueue();\n\n    //保持对reference的引用,防止reference本身被回收\n    private static List<Reference> references=new ArrayList<>();\n    @Override\n    public void run() {\n        this.setName(\"ResourceCloseDeamon\");\n        while (true) {\n            try {\n                ResourcePhantomReference reference = (ResourcePhantomReference) QUEUE.remove();\n                reference.cleanUp();\n                references.remove(reference);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void register(Object referent, List<Closeable> closeables) {\n        references.add(new ResourcePhantomReference(referent,QUEUE,closeables));\n    }\n\n\n}\n```\n\n```java\npublic class FileOperation {\n\n    private FileOutputStream outputStream;\n\n    private FileInputStream inputStream;\n\n    public FileOperation(FileInputStream inputStream, FileOutputStream outputStream) {\n        this.outputStream = outputStream;\n        this.inputStream = inputStream;\n    }\n\n    public void operate() {\n        try {\n            inputStream.getChannel().transferTo(0, inputStream.getChannel().size(), outputStream.getChannel());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n}\n```\n\n测试代码：\n\n```java\npublic class PhantomTest {\n\n    public static void main(String[] args) throws Exception {\n        //打开回收\n        ResourceCloseDeamon deamon = new ResourceCloseDeamon();\n        deamon.setDaemon(true);\n        deamon.start();\n\n        // touch a.txt b.txt\n        // echo \"hello\" > a.txt\n\n        //保留对象,防止gc把stream回收掉,其不到演示效果\n        List<Closeable> all=new ArrayList<>();\n        FileInputStream inputStream;\n        FileOutputStream outputStream;\n\n        for (int i = 0; i < 100000; i++) {\n            inputStream = new FileInputStream(\"/Users/robin/a.txt\");\n            outputStream = new FileOutputStream(\"/Users/robin/b.txt\");\n            FileOperation operation = new FileOperation(inputStream, outputStream);\n            operation.operate();\n            TimeUnit.MILLISECONDS.sleep(100);\n\n            List<Closeable>closeables=new ArrayList<>();\n            closeables.add(inputStream);\n            closeables.add(outputStream);\n            all.addAll(closeables);\n            ResourceCloseDeamon.register(operation,closeables);\n            //用下面命令查看文件句柄,如果把上面register注释掉,就会发现句柄数量不断上升\n            //jps | grep PhantomTest | awk '{print $1}' |head -1 | xargs  lsof -p  | grep /User/robin\n            System.gc();\n\n        }\n\n\n    }\n}\n```\n\n运行上面的代码，通过jps | grep PhantomTest | awk '{print $1}' |head -1 | xargs lsof -p | grep /User/robin ｜ wc -l 可以看到句柄没有上升，而去掉ResourceCloseDeamon.register(operation,closeables);时，句柄就不会被释放。\n\nPhantomReference使用时一定要传一个referenceQueue,当然也可以传null,但是这样就毫无意义了。因为PhantomReference的get结果为null,如果在把queue设为null,那么在其指向的referent被回收时，reference本身将永远不会可能被加入队列中，这里我们可以看ReferenceQueue的源码。\n\n### 6. 总结\n\n#### 引用类型对比\n\n| 序号 | 引用类型 | 取得目标对象方式 | 垃圾回收条件   | 是否可能内存泄漏 |\n| ---- | -------- | ---------------- | -------------- | ---------------- |\n| 1    | 强引用   | 直接调用         | 不回收         | 可能             |\n| 2    | 软引用   | 通过 get()方法   | 视内存情况回收 | 不可能           |\n| 3    | 弱引用   | 通过 get()方法   | 永远回收       | 不可能           |\n| 4    | 虚引用   | 无法取得         | 不回收         | 可能             |\n\n通过对SoftReference，WeakReference，PhantomReference 的介绍，可以看出JDK提供这些类型的reference 主要是用来和GC交互的，根据reference的不同，让JVM采用不同策略来进行对对象的回收(reclaim)。softly-reachable的referent在保证在OutOfMemoryError之前回收对象，weakly-reachable的referent在发生GC时就会被回收,同时这些reference和referenceQueue在一起提供通知机制，PhantomReference的作用就是仅仅就是提供对象回收通知机制，Finalizer借助这种机制实现referent的finalize执行，SoftReference、WeakReference也可以配合referenceQueue使用，实现对象回收通知机制。\n\n### 参考\n\n[Java中的四种引用类型](https://www.jianshu.com/p/147793693edc)\n\n[Java Reference详解](https://my.oschina.net/robinyao/blog/829983)\n\n[Reference、ReferenceQueue 详解](http://www.importnew.com/26250.html)\n\n[用弱引用堵住内存泄漏](","source":"_posts/Java-Reference详解.md","raw":"title: Java Reference详解\nauthor: 枫秀天涯\nabbrlink: 28002\ntags:\n  - java\n  - java引用\ncategories:\n  - java\ndate: 2019-01-04 10:25:00\n---\n# Java Reference详解\n\n### 概述\n\nJava引用体系中我们最熟悉的就是强引用类型，如 A a= new A();这是我们经常说的强引用StrongReference，jvm gc时会检测对象是否存在强引用，如果存在由根对象对其有传递的强引用，则不会对其进行回收，即使内存不足抛出OutOfMemoryError。\n\n除了强引用外，Java还引入了SoftReference，WeakReference，PhantomReference，FinalReference ，这些类放在java.lang.ref包下，类的继承体系如下图。Java额外引入这个四种类型引用主要目的是在jvm 在gc时，按照引用类型的不同，在回收时采用不同的逻辑。可以把这些引用看作是对对象的一层包裹，jvm根据外层不同的包裹，对其包裹的对象采用不同的回收策略，或特殊逻辑处理。 这几种类型的引用主要在jvm内存缓存、资源释放、对象可达性事件处理等场景会用到。\n\n![输入图片说明](https://static.oschina.net/uploads/img/201701/21153037_ubGO.png)\n\n本篇文章主要讲解前面三种SoftReference，WeakReference和PhantomReference的使用，以及ReferenceQueue的使用。至于FinalRefeence会在另一篇文章中讲解。\n<!-- more -->\n主要内容如下\n\n1. 对象可达性判断\n2. ReferenceQueue 简介\n3. SoftReference简介及使用\n4. WeakReference简介及使用\n5. PhantomReference简介及使用\n6. 总结\n\n**本文名称使用说明**名称说明下：Reference指代引用对象本身，Referent指代被引用对象，下文介绍会以Reference，Referent形式出现。 \n\n### 1. 对象可达性判断\n\njvm gc时，判断一个对象是否存在引用时，都是从根结合引用(Root Set of References)开始去标识,往往到达一个对象的引用路径会存在多条，如下图。 ![输入图片说明](https://static.oschina.net/uploads/img/201701/21165610_kkb9.png)\n\n那么 垃圾回收时会依据两个原则来判断对象的可达性：\n\n- 单一路径中，以最弱的引用为准\n- 多路径中，以最强的引用为准\n\n例如Obj4的引用，存在3个路径:1->6、2->5、3->4, 那么从根对象到Obj4最强的引用是2->5，因为它们都是强引用。如果仅仅存在一个路径对Obj4有引用时，比如现在只剩1->6,那么根对象到Obj4的引用就是以最弱的为准，就是SoftReference引用,Obj4就是softly-reachable对象。如果是WeakReference引用，就称作weakly-reachable对象。只要一个对象是强引用可达，那么这个对象就不会被gc，即使发生OOM也不会回收这个对象。\n\n### 2. ReferenceQueue 简介\n\n引用队列，在检测到适当的可到达性更改后，即Referent对象的可达性发生适当的改变时，垃圾回收器将已注册的引用对象reference添加到该队列中。\n\n简单用下面代码来说明\n\n```java\nObject object = new Object();\nReferenceQueue  queue = new ReferenceQueue();\nSoftReference<Objecct> soft = new SoftReference<>(object,queue);\nobject = null;\nSysten.gc();\n//休眠一会，等待gc完成\nThread.sleep(100);\nSystem.out.println(queue.poll() == soft);\nSystem.out.println(soft.get() == null)\n```\n\n输出结果：\n\n```java\ntrue\ntrue\n```\n\n结果分析：\n\n对应上面第一句话，就是说当soft引用对象包含的object对象被gc之后，其可达性就会发生改变，同时会将soft对象注册到queue这个引用队列中。可以使用poll()这个方法取出被所有可达性改变的引用对象。\n\nReferenceQueue实现了一个队列的入队(enqueue)和出队(poll,remove)操作，内部元素就是泛型的Reference，并且Queue的实现，是由Reference自身的链表结构( 单向循环链表 )所实现的。\n\nReferenceQueue名义上是一个队列，但实际内部并非有实际的存储结构，它的存储是依赖于内部节点之间的关系来表达。可以理解为queue是一个类似于链表的结构，这里的节点其实就是reference本身。可以理解为queue为一个链表的容器，其自己仅存储当前的head节点，而后面的节点由每个reference节点自己通过next来保持即可。\n\n具体源码分析可以参考这个网站：[ReferenceQueue源码分析参考](http://www.importnew.com/26250.html)\n\n因此可以看出，当reference与referenQueue联合使用的主要作用就是当reference指向的referent回收时，提供一种通知机制，通过queue取到这些reference，来做额外的处理工作。当然，如果我们不需要这种通知机制，在创建Reference对象时不传入queue对象即可。\n\n### 3. SoftReference简介及使用\n\n根据上面我们讲的对象可达性原理，我们把一个对象存在根对象对其有直接或间接的SoftReference，并没有其他强引用路径，我们把该对象成为softly-reachable对象。JVM保证在抛出OutOfMemoryError前会回收这些softly-reachable对象。JVM会根据当前内存的情况来决定是否回收softly-reachable对象，但只要referent有强引用存在，该referent就一定不会被清理，因此SoftReference适合用来实现memory-sensitive caches。\n\n可见，SoftReference在一定程度上会影响JVM GC的，例如softly-reachable对应的referent多次垃圾回收仍然不满足释放条件，那么它会停留在heap old区，占据很大部分空间，在JVM没有抛出OutOfMemoryError前，它有可能会导致频繁的Full GC。\n\n下面是我使用SoftReference做的一个简单的缓存图片的测试\n\n```java\npublic class SoftReferenceImageTest {\n    public static void main(String[] args) throws IOException {\n        testImageLoad();\n    }\n\n    public static void testImageLoad() throws IOException {\n        String s = \"xmind.png\";\n        HashMap<String, SoftReference<byte[]>> map = new HashMap<>(100);\n        for (int i = 0; i < 100; i++) {\n            FileInputStream inputStream = new FileInputStream(s);\n            byte[] bytes = new byte[(int) inputStream.getChannel().size()];\n            while (inputStream.read(bytes) > 0) ;\n            inputStream.close();\n            map.put(s + i, new SoftReference<byte[]>(bytes));\n        }\n        for (int i = 0; i < map.size(); i++) {\n\n            Optional.ofNullable(map.get(s + i))\n                    .filter(softReference -> softReference.get() != null)\n                    .ifPresent(softReference -> {\n                        System.out.println(\"ok\");\n                    });\n        }\n\n    }\n}\n```\n\n运行这段代码时，加上jvm参数(**-Xms10M -Xmx10M -Xmn5M -XX:+PrintGCDetails**)\n\n运行结果为空，因为我加载的图片是5M，而分配给运行时的jvm是10M,所以每次加载完一张图片之后，在下一次加载就会清理这个SoftReference对象，因此最后得到的结果为空。\n\n### 4. WeakReference简介及使用\n\n当一个对象被WeakReference引用时，处于weakly-reachable状态时，只要发生GC时，就会被清除，同时会把WeakReference注册到引用队列中(如果存在的话)。 WeakReference不阻碍或影响它们对应的referent被终结(finalized)和回收(reclaimed)，因此，WeakReference经常被用作实现规范映射(canonicalizing mappings)。相比SoftReference来说，WeakReference对JVM GC几乎是没有影响的。\n\n下面是一个简单的demo\n\n```java\npublic class WeakReferenceTest {\n    public static void main(String[] args) {\n        weak();\n    }\n\n    public static void weak() {\n        ReferenceQueue<Integer> referenceQueue = new ReferenceQueue<>();\n        WeakReference<Integer> weak = new WeakReference<Integer>(new Integer(100), \n                                                                 referenceQueue);\n        System.out.println(\"GC 前===>\" + weak.get());\n        System.gc();\n        System.out.println(\"GC 后===>\" + weak.get());\n      \n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(referenceQueue.poll() == weak);\n    }\n}\n```\n\n运行结果\n\n```java\nGC 前===>100\nGC 后===>null\ntrue\n```\n\n结果分析：\n\n从上面我么可以看到，WeakReference所对应的Referent对象被回收了，因此验证了只要发生gc，weakly-reachable对象就会被gc回收。\n\n另外可以查看这篇文章，仔细说明jdk中WeakHashMap在Tomact中使用的场景[WeakHashMap使用场景](https://blog.csdn.net/kaka0509/article/details/73459419)\n\n### 5. PhantomReference简介及使用\n\n PhantomReference 不同于WeakReference、SoftReference，它存在的意义不是为了获取referent,因为你也永远获取不到，因为它的get如下\n\n```java\n public T get() {\n        return null;\n }\n```\n\nPhantomReference主要作为其指向的referent被回收时的一种通知机制,它就是利用上文讲到的ReferenceQueue实现的。当referent被gc回收时，JVM自动把PhantomReference对象(reference)本身加入到ReferenceQueue中，像发出信号通知一样，表明该reference指向的referent被回收。然后可以通过去queue中取到reference，此时说明其指向的referent已经被回收，可以通过这个通知机制来做额外的清场工作。 因此有些情况可以用PhantomReference 代替finalize()，做资源释放更明智。\n\n下面举个例子，用PhantomReference来自动关闭文件流。\n\n```java\npublic class ResourcePhantomReference<T> extends PhantomReference<T> {\n\n    private List<Closeable> closeables;\n\n    public ResourcePhantomReference(T referent, ReferenceQueue<? super T> q, List<Closeable> resource) {\n        super(referent, q);\n        closeables = resource;\n    }\n\n    public void cleanUp() {\n        if (closeables == null || closeables.size() == 0)\n            return;\n        for (Closeable closeable : closeables) {\n            try {\n                closeable.close();\n                System.out.println(\"clean up:\"+closeable);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n```java\npublic class ResourceCloseDeamon extends Thread {\n\n    private static ReferenceQueue QUEUE = new ReferenceQueue();\n\n    //保持对reference的引用,防止reference本身被回收\n    private static List<Reference> references=new ArrayList<>();\n    @Override\n    public void run() {\n        this.setName(\"ResourceCloseDeamon\");\n        while (true) {\n            try {\n                ResourcePhantomReference reference = (ResourcePhantomReference) QUEUE.remove();\n                reference.cleanUp();\n                references.remove(reference);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void register(Object referent, List<Closeable> closeables) {\n        references.add(new ResourcePhantomReference(referent,QUEUE,closeables));\n    }\n\n\n}\n```\n\n```java\npublic class FileOperation {\n\n    private FileOutputStream outputStream;\n\n    private FileInputStream inputStream;\n\n    public FileOperation(FileInputStream inputStream, FileOutputStream outputStream) {\n        this.outputStream = outputStream;\n        this.inputStream = inputStream;\n    }\n\n    public void operate() {\n        try {\n            inputStream.getChannel().transferTo(0, inputStream.getChannel().size(), outputStream.getChannel());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n}\n```\n\n测试代码：\n\n```java\npublic class PhantomTest {\n\n    public static void main(String[] args) throws Exception {\n        //打开回收\n        ResourceCloseDeamon deamon = new ResourceCloseDeamon();\n        deamon.setDaemon(true);\n        deamon.start();\n\n        // touch a.txt b.txt\n        // echo \"hello\" > a.txt\n\n        //保留对象,防止gc把stream回收掉,其不到演示效果\n        List<Closeable> all=new ArrayList<>();\n        FileInputStream inputStream;\n        FileOutputStream outputStream;\n\n        for (int i = 0; i < 100000; i++) {\n            inputStream = new FileInputStream(\"/Users/robin/a.txt\");\n            outputStream = new FileOutputStream(\"/Users/robin/b.txt\");\n            FileOperation operation = new FileOperation(inputStream, outputStream);\n            operation.operate();\n            TimeUnit.MILLISECONDS.sleep(100);\n\n            List<Closeable>closeables=new ArrayList<>();\n            closeables.add(inputStream);\n            closeables.add(outputStream);\n            all.addAll(closeables);\n            ResourceCloseDeamon.register(operation,closeables);\n            //用下面命令查看文件句柄,如果把上面register注释掉,就会发现句柄数量不断上升\n            //jps | grep PhantomTest | awk '{print $1}' |head -1 | xargs  lsof -p  | grep /User/robin\n            System.gc();\n\n        }\n\n\n    }\n}\n```\n\n运行上面的代码，通过jps | grep PhantomTest | awk '{print $1}' |head -1 | xargs lsof -p | grep /User/robin ｜ wc -l 可以看到句柄没有上升，而去掉ResourceCloseDeamon.register(operation,closeables);时，句柄就不会被释放。\n\nPhantomReference使用时一定要传一个referenceQueue,当然也可以传null,但是这样就毫无意义了。因为PhantomReference的get结果为null,如果在把queue设为null,那么在其指向的referent被回收时，reference本身将永远不会可能被加入队列中，这里我们可以看ReferenceQueue的源码。\n\n### 6. 总结\n\n#### 引用类型对比\n\n| 序号 | 引用类型 | 取得目标对象方式 | 垃圾回收条件   | 是否可能内存泄漏 |\n| ---- | -------- | ---------------- | -------------- | ---------------- |\n| 1    | 强引用   | 直接调用         | 不回收         | 可能             |\n| 2    | 软引用   | 通过 get()方法   | 视内存情况回收 | 不可能           |\n| 3    | 弱引用   | 通过 get()方法   | 永远回收       | 不可能           |\n| 4    | 虚引用   | 无法取得         | 不回收         | 可能             |\n\n通过对SoftReference，WeakReference，PhantomReference 的介绍，可以看出JDK提供这些类型的reference 主要是用来和GC交互的，根据reference的不同，让JVM采用不同策略来进行对对象的回收(reclaim)。softly-reachable的referent在保证在OutOfMemoryError之前回收对象，weakly-reachable的referent在发生GC时就会被回收,同时这些reference和referenceQueue在一起提供通知机制，PhantomReference的作用就是仅仅就是提供对象回收通知机制，Finalizer借助这种机制实现referent的finalize执行，SoftReference、WeakReference也可以配合referenceQueue使用，实现对象回收通知机制。\n\n### 参考\n\n[Java中的四种引用类型](https://www.jianshu.com/p/147793693edc)\n\n[Java Reference详解](https://my.oschina.net/robinyao/blog/829983)\n\n[Reference、ReferenceQueue 详解](http://www.importnew.com/26250.html)\n\n[用弱引用堵住内存泄漏](","slug":"Java-Reference详解","published":1,"updated":"2019-01-04T06:02:10.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx2g0013eb1ug9ly4372","content":"<h1 id=\"Java-Reference详解\"><a href=\"#Java-Reference详解\" class=\"headerlink\" title=\"Java Reference详解\"></a>Java Reference详解</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Java引用体系中我们最熟悉的就是强引用类型，如 A a= new A();这是我们经常说的强引用StrongReference，jvm gc时会检测对象是否存在强引用，如果存在由根对象对其有传递的强引用，则不会对其进行回收，即使内存不足抛出OutOfMemoryError。</p>\n<p>除了强引用外，Java还引入了SoftReference，WeakReference，PhantomReference，FinalReference ，这些类放在java.lang.ref包下，类的继承体系如下图。Java额外引入这个四种类型引用主要目的是在jvm 在gc时，按照引用类型的不同，在回收时采用不同的逻辑。可以把这些引用看作是对对象的一层包裹，jvm根据外层不同的包裹，对其包裹的对象采用不同的回收策略，或特殊逻辑处理。 这几种类型的引用主要在jvm内存缓存、资源释放、对象可达性事件处理等场景会用到。</p>\n<p><img src=\"https://static.oschina.net/uploads/img/201701/21153037_ubGO.png\" alt=\"输入图片说明\"></p>\n<p>本篇文章主要讲解前面三种SoftReference，WeakReference和PhantomReference的使用，以及ReferenceQueue的使用。至于FinalRefeence会在另一篇文章中讲解。<br><a id=\"more\"></a><br>主要内容如下</p>\n<ol>\n<li>对象可达性判断</li>\n<li>ReferenceQueue 简介</li>\n<li>SoftReference简介及使用</li>\n<li>WeakReference简介及使用</li>\n<li>PhantomReference简介及使用</li>\n<li>总结</li>\n</ol>\n<p><strong>本文名称使用说明</strong>名称说明下：Reference指代引用对象本身，Referent指代被引用对象，下文介绍会以Reference，Referent形式出现。 </p>\n<h3 id=\"1-对象可达性判断\"><a href=\"#1-对象可达性判断\" class=\"headerlink\" title=\"1. 对象可达性判断\"></a>1. 对象可达性判断</h3><p>jvm gc时，判断一个对象是否存在引用时，都是从根结合引用(Root Set of References)开始去标识,往往到达一个对象的引用路径会存在多条，如下图。 <img src=\"https://static.oschina.net/uploads/img/201701/21165610_kkb9.png\" alt=\"输入图片说明\"></p>\n<p>那么 垃圾回收时会依据两个原则来判断对象的可达性：</p>\n<ul>\n<li>单一路径中，以最弱的引用为准</li>\n<li>多路径中，以最强的引用为准</li>\n</ul>\n<p>例如Obj4的引用，存在3个路径:1-&gt;6、2-&gt;5、3-&gt;4, 那么从根对象到Obj4最强的引用是2-&gt;5，因为它们都是强引用。如果仅仅存在一个路径对Obj4有引用时，比如现在只剩1-&gt;6,那么根对象到Obj4的引用就是以最弱的为准，就是SoftReference引用,Obj4就是softly-reachable对象。如果是WeakReference引用，就称作weakly-reachable对象。只要一个对象是强引用可达，那么这个对象就不会被gc，即使发生OOM也不会回收这个对象。</p>\n<h3 id=\"2-ReferenceQueue-简介\"><a href=\"#2-ReferenceQueue-简介\" class=\"headerlink\" title=\"2. ReferenceQueue 简介\"></a>2. ReferenceQueue 简介</h3><p>引用队列，在检测到适当的可到达性更改后，即Referent对象的可达性发生适当的改变时，垃圾回收器将已注册的引用对象reference添加到该队列中。</p>\n<p>简单用下面代码来说明</p>\n<pre><code class=\"java\">Object object = new Object();\nReferenceQueue  queue = new ReferenceQueue();\nSoftReference&lt;Objecct&gt; soft = new SoftReference&lt;&gt;(object,queue);\nobject = null;\nSysten.gc();\n//休眠一会，等待gc完成\nThread.sleep(100);\nSystem.out.println(queue.poll() == soft);\nSystem.out.println(soft.get() == null)\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"java\">true\ntrue\n</code></pre>\n<p>结果分析：</p>\n<p>对应上面第一句话，就是说当soft引用对象包含的object对象被gc之后，其可达性就会发生改变，同时会将soft对象注册到queue这个引用队列中。可以使用poll()这个方法取出被所有可达性改变的引用对象。</p>\n<p>ReferenceQueue实现了一个队列的入队(enqueue)和出队(poll,remove)操作，内部元素就是泛型的Reference，并且Queue的实现，是由Reference自身的链表结构( 单向循环链表 )所实现的。</p>\n<p>ReferenceQueue名义上是一个队列，但实际内部并非有实际的存储结构，它的存储是依赖于内部节点之间的关系来表达。可以理解为queue是一个类似于链表的结构，这里的节点其实就是reference本身。可以理解为queue为一个链表的容器，其自己仅存储当前的head节点，而后面的节点由每个reference节点自己通过next来保持即可。</p>\n<p>具体源码分析可以参考这个网站：<a href=\"http://www.importnew.com/26250.html\" target=\"_blank\" rel=\"noopener\">ReferenceQueue源码分析参考</a></p>\n<p>因此可以看出，当reference与referenQueue联合使用的主要作用就是当reference指向的referent回收时，提供一种通知机制，通过queue取到这些reference，来做额外的处理工作。当然，如果我们不需要这种通知机制，在创建Reference对象时不传入queue对象即可。</p>\n<h3 id=\"3-SoftReference简介及使用\"><a href=\"#3-SoftReference简介及使用\" class=\"headerlink\" title=\"3. SoftReference简介及使用\"></a>3. SoftReference简介及使用</h3><p>根据上面我们讲的对象可达性原理，我们把一个对象存在根对象对其有直接或间接的SoftReference，并没有其他强引用路径，我们把该对象成为softly-reachable对象。JVM保证在抛出OutOfMemoryError前会回收这些softly-reachable对象。JVM会根据当前内存的情况来决定是否回收softly-reachable对象，但只要referent有强引用存在，该referent就一定不会被清理，因此SoftReference适合用来实现memory-sensitive caches。</p>\n<p>可见，SoftReference在一定程度上会影响JVM GC的，例如softly-reachable对应的referent多次垃圾回收仍然不满足释放条件，那么它会停留在heap old区，占据很大部分空间，在JVM没有抛出OutOfMemoryError前，它有可能会导致频繁的Full GC。</p>\n<p>下面是我使用SoftReference做的一个简单的缓存图片的测试</p>\n<pre><code class=\"java\">public class SoftReferenceImageTest {\n    public static void main(String[] args) throws IOException {\n        testImageLoad();\n    }\n\n    public static void testImageLoad() throws IOException {\n        String s = &quot;xmind.png&quot;;\n        HashMap&lt;String, SoftReference&lt;byte[]&gt;&gt; map = new HashMap&lt;&gt;(100);\n        for (int i = 0; i &lt; 100; i++) {\n            FileInputStream inputStream = new FileInputStream(s);\n            byte[] bytes = new byte[(int) inputStream.getChannel().size()];\n            while (inputStream.read(bytes) &gt; 0) ;\n            inputStream.close();\n            map.put(s + i, new SoftReference&lt;byte[]&gt;(bytes));\n        }\n        for (int i = 0; i &lt; map.size(); i++) {\n\n            Optional.ofNullable(map.get(s + i))\n                    .filter(softReference -&gt; softReference.get() != null)\n                    .ifPresent(softReference -&gt; {\n                        System.out.println(&quot;ok&quot;);\n                    });\n        }\n\n    }\n}\n</code></pre>\n<p>运行这段代码时，加上jvm参数(<strong>-Xms10M -Xmx10M -Xmn5M -XX:+PrintGCDetails</strong>)</p>\n<p>运行结果为空，因为我加载的图片是5M，而分配给运行时的jvm是10M,所以每次加载完一张图片之后，在下一次加载就会清理这个SoftReference对象，因此最后得到的结果为空。</p>\n<h3 id=\"4-WeakReference简介及使用\"><a href=\"#4-WeakReference简介及使用\" class=\"headerlink\" title=\"4. WeakReference简介及使用\"></a>4. WeakReference简介及使用</h3><p>当一个对象被WeakReference引用时，处于weakly-reachable状态时，只要发生GC时，就会被清除，同时会把WeakReference注册到引用队列中(如果存在的话)。 WeakReference不阻碍或影响它们对应的referent被终结(finalized)和回收(reclaimed)，因此，WeakReference经常被用作实现规范映射(canonicalizing mappings)。相比SoftReference来说，WeakReference对JVM GC几乎是没有影响的。</p>\n<p>下面是一个简单的demo</p>\n<pre><code class=\"java\">public class WeakReferenceTest {\n    public static void main(String[] args) {\n        weak();\n    }\n\n    public static void weak() {\n        ReferenceQueue&lt;Integer&gt; referenceQueue = new ReferenceQueue&lt;&gt;();\n        WeakReference&lt;Integer&gt; weak = new WeakReference&lt;Integer&gt;(new Integer(100), \n                                                                 referenceQueue);\n        System.out.println(&quot;GC 前===&gt;&quot; + weak.get());\n        System.gc();\n        System.out.println(&quot;GC 后===&gt;&quot; + weak.get());\n\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(referenceQueue.poll() == weak);\n    }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code class=\"java\">GC 前===&gt;100\nGC 后===&gt;null\ntrue\n</code></pre>\n<p>结果分析：</p>\n<p>从上面我么可以看到，WeakReference所对应的Referent对象被回收了，因此验证了只要发生gc，weakly-reachable对象就会被gc回收。</p>\n<p>另外可以查看这篇文章，仔细说明jdk中WeakHashMap在Tomact中使用的场景<a href=\"https://blog.csdn.net/kaka0509/article/details/73459419\" target=\"_blank\" rel=\"noopener\">WeakHashMap使用场景</a></p>\n<h3 id=\"5-PhantomReference简介及使用\"><a href=\"#5-PhantomReference简介及使用\" class=\"headerlink\" title=\"5. PhantomReference简介及使用\"></a>5. PhantomReference简介及使用</h3><p> PhantomReference 不同于WeakReference、SoftReference，它存在的意义不是为了获取referent,因为你也永远获取不到，因为它的get如下</p>\n<pre><code class=\"java\"> public T get() {\n        return null;\n }\n</code></pre>\n<p>PhantomReference主要作为其指向的referent被回收时的一种通知机制,它就是利用上文讲到的ReferenceQueue实现的。当referent被gc回收时，JVM自动把PhantomReference对象(reference)本身加入到ReferenceQueue中，像发出信号通知一样，表明该reference指向的referent被回收。然后可以通过去queue中取到reference，此时说明其指向的referent已经被回收，可以通过这个通知机制来做额外的清场工作。 因此有些情况可以用PhantomReference 代替finalize()，做资源释放更明智。</p>\n<p>下面举个例子，用PhantomReference来自动关闭文件流。</p>\n<pre><code class=\"java\">public class ResourcePhantomReference&lt;T&gt; extends PhantomReference&lt;T&gt; {\n\n    private List&lt;Closeable&gt; closeables;\n\n    public ResourcePhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q, List&lt;Closeable&gt; resource) {\n        super(referent, q);\n        closeables = resource;\n    }\n\n    public void cleanUp() {\n        if (closeables == null || closeables.size() == 0)\n            return;\n        for (Closeable closeable : closeables) {\n            try {\n                closeable.close();\n                System.out.println(&quot;clean up:&quot;+closeable);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"java\">public class ResourceCloseDeamon extends Thread {\n\n    private static ReferenceQueue QUEUE = new ReferenceQueue();\n\n    //保持对reference的引用,防止reference本身被回收\n    private static List&lt;Reference&gt; references=new ArrayList&lt;&gt;();\n    @Override\n    public void run() {\n        this.setName(&quot;ResourceCloseDeamon&quot;);\n        while (true) {\n            try {\n                ResourcePhantomReference reference = (ResourcePhantomReference) QUEUE.remove();\n                reference.cleanUp();\n                references.remove(reference);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void register(Object referent, List&lt;Closeable&gt; closeables) {\n        references.add(new ResourcePhantomReference(referent,QUEUE,closeables));\n    }\n\n\n}\n</code></pre>\n<pre><code class=\"java\">public class FileOperation {\n\n    private FileOutputStream outputStream;\n\n    private FileInputStream inputStream;\n\n    public FileOperation(FileInputStream inputStream, FileOutputStream outputStream) {\n        this.outputStream = outputStream;\n        this.inputStream = inputStream;\n    }\n\n    public void operate() {\n        try {\n            inputStream.getChannel().transferTo(0, inputStream.getChannel().size(), outputStream.getChannel());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n}\n</code></pre>\n<p>测试代码：</p>\n<pre><code class=\"java\">public class PhantomTest {\n\n    public static void main(String[] args) throws Exception {\n        //打开回收\n        ResourceCloseDeamon deamon = new ResourceCloseDeamon();\n        deamon.setDaemon(true);\n        deamon.start();\n\n        // touch a.txt b.txt\n        // echo &quot;hello&quot; &gt; a.txt\n\n        //保留对象,防止gc把stream回收掉,其不到演示效果\n        List&lt;Closeable&gt; all=new ArrayList&lt;&gt;();\n        FileInputStream inputStream;\n        FileOutputStream outputStream;\n\n        for (int i = 0; i &lt; 100000; i++) {\n            inputStream = new FileInputStream(&quot;/Users/robin/a.txt&quot;);\n            outputStream = new FileOutputStream(&quot;/Users/robin/b.txt&quot;);\n            FileOperation operation = new FileOperation(inputStream, outputStream);\n            operation.operate();\n            TimeUnit.MILLISECONDS.sleep(100);\n\n            List&lt;Closeable&gt;closeables=new ArrayList&lt;&gt;();\n            closeables.add(inputStream);\n            closeables.add(outputStream);\n            all.addAll(closeables);\n            ResourceCloseDeamon.register(operation,closeables);\n            //用下面命令查看文件句柄,如果把上面register注释掉,就会发现句柄数量不断上升\n            //jps | grep PhantomTest | awk &#39;{print $1}&#39; |head -1 | xargs  lsof -p  | grep /User/robin\n            System.gc();\n\n        }\n\n\n    }\n}\n</code></pre>\n<p>运行上面的代码，通过jps | grep PhantomTest | awk ‘{print $1}’ |head -1 | xargs lsof -p | grep /User/robin ｜ wc -l 可以看到句柄没有上升，而去掉ResourceCloseDeamon.register(operation,closeables);时，句柄就不会被释放。</p>\n<p>PhantomReference使用时一定要传一个referenceQueue,当然也可以传null,但是这样就毫无意义了。因为PhantomReference的get结果为null,如果在把queue设为null,那么在其指向的referent被回收时，reference本身将永远不会可能被加入队列中，这里我们可以看ReferenceQueue的源码。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><h4 id=\"引用类型对比\"><a href=\"#引用类型对比\" class=\"headerlink\" title=\"引用类型对比\"></a>引用类型对比</h4><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>引用类型</th>\n<th>取得目标对象方式</th>\n<th>垃圾回收条件</th>\n<th>是否可能内存泄漏</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>强引用</td>\n<td>直接调用</td>\n<td>不回收</td>\n<td>可能</td>\n</tr>\n<tr>\n<td>2</td>\n<td>软引用</td>\n<td>通过 get()方法</td>\n<td>视内存情况回收</td>\n<td>不可能</td>\n</tr>\n<tr>\n<td>3</td>\n<td>弱引用</td>\n<td>通过 get()方法</td>\n<td>永远回收</td>\n<td>不可能</td>\n</tr>\n<tr>\n<td>4</td>\n<td>虚引用</td>\n<td>无法取得</td>\n<td>不回收</td>\n<td>可能</td>\n</tr>\n</tbody>\n</table>\n<p>通过对SoftReference，WeakReference，PhantomReference 的介绍，可以看出JDK提供这些类型的reference 主要是用来和GC交互的，根据reference的不同，让JVM采用不同策略来进行对对象的回收(reclaim)。softly-reachable的referent在保证在OutOfMemoryError之前回收对象，weakly-reachable的referent在发生GC时就会被回收,同时这些reference和referenceQueue在一起提供通知机制，PhantomReference的作用就是仅仅就是提供对象回收通知机制，Finalizer借助这种机制实现referent的finalize执行，SoftReference、WeakReference也可以配合referenceQueue使用，实现对象回收通知机制。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.jianshu.com/p/147793693edc\" target=\"_blank\" rel=\"noopener\">Java中的四种引用类型</a></p>\n<p><a href=\"https://my.oschina.net/robinyao/blog/829983\" target=\"_blank\" rel=\"noopener\">Java Reference详解</a></p>\n<p><a href=\"http://www.importnew.com/26250.html\" target=\"_blank\" rel=\"noopener\">Reference、ReferenceQueue 详解</a></p>\n<p>[用弱引用堵住内存泄漏](</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java-Reference详解\"><a href=\"#Java-Reference详解\" class=\"headerlink\" title=\"Java Reference详解\"></a>Java Reference详解</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Java引用体系中我们最熟悉的就是强引用类型，如 A a= new A();这是我们经常说的强引用StrongReference，jvm gc时会检测对象是否存在强引用，如果存在由根对象对其有传递的强引用，则不会对其进行回收，即使内存不足抛出OutOfMemoryError。</p>\n<p>除了强引用外，Java还引入了SoftReference，WeakReference，PhantomReference，FinalReference ，这些类放在java.lang.ref包下，类的继承体系如下图。Java额外引入这个四种类型引用主要目的是在jvm 在gc时，按照引用类型的不同，在回收时采用不同的逻辑。可以把这些引用看作是对对象的一层包裹，jvm根据外层不同的包裹，对其包裹的对象采用不同的回收策略，或特殊逻辑处理。 这几种类型的引用主要在jvm内存缓存、资源释放、对象可达性事件处理等场景会用到。</p>\n<p><img src=\"https://static.oschina.net/uploads/img/201701/21153037_ubGO.png\" alt=\"输入图片说明\"></p>\n<p>本篇文章主要讲解前面三种SoftReference，WeakReference和PhantomReference的使用，以及ReferenceQueue的使用。至于FinalRefeence会在另一篇文章中讲解。<br>","more":"<br>主要内容如下</p>\n<ol>\n<li>对象可达性判断</li>\n<li>ReferenceQueue 简介</li>\n<li>SoftReference简介及使用</li>\n<li>WeakReference简介及使用</li>\n<li>PhantomReference简介及使用</li>\n<li>总结</li>\n</ol>\n<p><strong>本文名称使用说明</strong>名称说明下：Reference指代引用对象本身，Referent指代被引用对象，下文介绍会以Reference，Referent形式出现。 </p>\n<h3 id=\"1-对象可达性判断\"><a href=\"#1-对象可达性判断\" class=\"headerlink\" title=\"1. 对象可达性判断\"></a>1. 对象可达性判断</h3><p>jvm gc时，判断一个对象是否存在引用时，都是从根结合引用(Root Set of References)开始去标识,往往到达一个对象的引用路径会存在多条，如下图。 <img src=\"https://static.oschina.net/uploads/img/201701/21165610_kkb9.png\" alt=\"输入图片说明\"></p>\n<p>那么 垃圾回收时会依据两个原则来判断对象的可达性：</p>\n<ul>\n<li>单一路径中，以最弱的引用为准</li>\n<li>多路径中，以最强的引用为准</li>\n</ul>\n<p>例如Obj4的引用，存在3个路径:1-&gt;6、2-&gt;5、3-&gt;4, 那么从根对象到Obj4最强的引用是2-&gt;5，因为它们都是强引用。如果仅仅存在一个路径对Obj4有引用时，比如现在只剩1-&gt;6,那么根对象到Obj4的引用就是以最弱的为准，就是SoftReference引用,Obj4就是softly-reachable对象。如果是WeakReference引用，就称作weakly-reachable对象。只要一个对象是强引用可达，那么这个对象就不会被gc，即使发生OOM也不会回收这个对象。</p>\n<h3 id=\"2-ReferenceQueue-简介\"><a href=\"#2-ReferenceQueue-简介\" class=\"headerlink\" title=\"2. ReferenceQueue 简介\"></a>2. ReferenceQueue 简介</h3><p>引用队列，在检测到适当的可到达性更改后，即Referent对象的可达性发生适当的改变时，垃圾回收器将已注册的引用对象reference添加到该队列中。</p>\n<p>简单用下面代码来说明</p>\n<pre><code class=\"java\">Object object = new Object();\nReferenceQueue  queue = new ReferenceQueue();\nSoftReference&lt;Objecct&gt; soft = new SoftReference&lt;&gt;(object,queue);\nobject = null;\nSysten.gc();\n//休眠一会，等待gc完成\nThread.sleep(100);\nSystem.out.println(queue.poll() == soft);\nSystem.out.println(soft.get() == null)\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"java\">true\ntrue\n</code></pre>\n<p>结果分析：</p>\n<p>对应上面第一句话，就是说当soft引用对象包含的object对象被gc之后，其可达性就会发生改变，同时会将soft对象注册到queue这个引用队列中。可以使用poll()这个方法取出被所有可达性改变的引用对象。</p>\n<p>ReferenceQueue实现了一个队列的入队(enqueue)和出队(poll,remove)操作，内部元素就是泛型的Reference，并且Queue的实现，是由Reference自身的链表结构( 单向循环链表 )所实现的。</p>\n<p>ReferenceQueue名义上是一个队列，但实际内部并非有实际的存储结构，它的存储是依赖于内部节点之间的关系来表达。可以理解为queue是一个类似于链表的结构，这里的节点其实就是reference本身。可以理解为queue为一个链表的容器，其自己仅存储当前的head节点，而后面的节点由每个reference节点自己通过next来保持即可。</p>\n<p>具体源码分析可以参考这个网站：<a href=\"http://www.importnew.com/26250.html\" target=\"_blank\" rel=\"noopener\">ReferenceQueue源码分析参考</a></p>\n<p>因此可以看出，当reference与referenQueue联合使用的主要作用就是当reference指向的referent回收时，提供一种通知机制，通过queue取到这些reference，来做额外的处理工作。当然，如果我们不需要这种通知机制，在创建Reference对象时不传入queue对象即可。</p>\n<h3 id=\"3-SoftReference简介及使用\"><a href=\"#3-SoftReference简介及使用\" class=\"headerlink\" title=\"3. SoftReference简介及使用\"></a>3. SoftReference简介及使用</h3><p>根据上面我们讲的对象可达性原理，我们把一个对象存在根对象对其有直接或间接的SoftReference，并没有其他强引用路径，我们把该对象成为softly-reachable对象。JVM保证在抛出OutOfMemoryError前会回收这些softly-reachable对象。JVM会根据当前内存的情况来决定是否回收softly-reachable对象，但只要referent有强引用存在，该referent就一定不会被清理，因此SoftReference适合用来实现memory-sensitive caches。</p>\n<p>可见，SoftReference在一定程度上会影响JVM GC的，例如softly-reachable对应的referent多次垃圾回收仍然不满足释放条件，那么它会停留在heap old区，占据很大部分空间，在JVM没有抛出OutOfMemoryError前，它有可能会导致频繁的Full GC。</p>\n<p>下面是我使用SoftReference做的一个简单的缓存图片的测试</p>\n<pre><code class=\"java\">public class SoftReferenceImageTest {\n    public static void main(String[] args) throws IOException {\n        testImageLoad();\n    }\n\n    public static void testImageLoad() throws IOException {\n        String s = &quot;xmind.png&quot;;\n        HashMap&lt;String, SoftReference&lt;byte[]&gt;&gt; map = new HashMap&lt;&gt;(100);\n        for (int i = 0; i &lt; 100; i++) {\n            FileInputStream inputStream = new FileInputStream(s);\n            byte[] bytes = new byte[(int) inputStream.getChannel().size()];\n            while (inputStream.read(bytes) &gt; 0) ;\n            inputStream.close();\n            map.put(s + i, new SoftReference&lt;byte[]&gt;(bytes));\n        }\n        for (int i = 0; i &lt; map.size(); i++) {\n\n            Optional.ofNullable(map.get(s + i))\n                    .filter(softReference -&gt; softReference.get() != null)\n                    .ifPresent(softReference -&gt; {\n                        System.out.println(&quot;ok&quot;);\n                    });\n        }\n\n    }\n}\n</code></pre>\n<p>运行这段代码时，加上jvm参数(<strong>-Xms10M -Xmx10M -Xmn5M -XX:+PrintGCDetails</strong>)</p>\n<p>运行结果为空，因为我加载的图片是5M，而分配给运行时的jvm是10M,所以每次加载完一张图片之后，在下一次加载就会清理这个SoftReference对象，因此最后得到的结果为空。</p>\n<h3 id=\"4-WeakReference简介及使用\"><a href=\"#4-WeakReference简介及使用\" class=\"headerlink\" title=\"4. WeakReference简介及使用\"></a>4. WeakReference简介及使用</h3><p>当一个对象被WeakReference引用时，处于weakly-reachable状态时，只要发生GC时，就会被清除，同时会把WeakReference注册到引用队列中(如果存在的话)。 WeakReference不阻碍或影响它们对应的referent被终结(finalized)和回收(reclaimed)，因此，WeakReference经常被用作实现规范映射(canonicalizing mappings)。相比SoftReference来说，WeakReference对JVM GC几乎是没有影响的。</p>\n<p>下面是一个简单的demo</p>\n<pre><code class=\"java\">public class WeakReferenceTest {\n    public static void main(String[] args) {\n        weak();\n    }\n\n    public static void weak() {\n        ReferenceQueue&lt;Integer&gt; referenceQueue = new ReferenceQueue&lt;&gt;();\n        WeakReference&lt;Integer&gt; weak = new WeakReference&lt;Integer&gt;(new Integer(100), \n                                                                 referenceQueue);\n        System.out.println(&quot;GC 前===&gt;&quot; + weak.get());\n        System.gc();\n        System.out.println(&quot;GC 后===&gt;&quot; + weak.get());\n\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(referenceQueue.poll() == weak);\n    }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code class=\"java\">GC 前===&gt;100\nGC 后===&gt;null\ntrue\n</code></pre>\n<p>结果分析：</p>\n<p>从上面我么可以看到，WeakReference所对应的Referent对象被回收了，因此验证了只要发生gc，weakly-reachable对象就会被gc回收。</p>\n<p>另外可以查看这篇文章，仔细说明jdk中WeakHashMap在Tomact中使用的场景<a href=\"https://blog.csdn.net/kaka0509/article/details/73459419\" target=\"_blank\" rel=\"noopener\">WeakHashMap使用场景</a></p>\n<h3 id=\"5-PhantomReference简介及使用\"><a href=\"#5-PhantomReference简介及使用\" class=\"headerlink\" title=\"5. PhantomReference简介及使用\"></a>5. PhantomReference简介及使用</h3><p> PhantomReference 不同于WeakReference、SoftReference，它存在的意义不是为了获取referent,因为你也永远获取不到，因为它的get如下</p>\n<pre><code class=\"java\"> public T get() {\n        return null;\n }\n</code></pre>\n<p>PhantomReference主要作为其指向的referent被回收时的一种通知机制,它就是利用上文讲到的ReferenceQueue实现的。当referent被gc回收时，JVM自动把PhantomReference对象(reference)本身加入到ReferenceQueue中，像发出信号通知一样，表明该reference指向的referent被回收。然后可以通过去queue中取到reference，此时说明其指向的referent已经被回收，可以通过这个通知机制来做额外的清场工作。 因此有些情况可以用PhantomReference 代替finalize()，做资源释放更明智。</p>\n<p>下面举个例子，用PhantomReference来自动关闭文件流。</p>\n<pre><code class=\"java\">public class ResourcePhantomReference&lt;T&gt; extends PhantomReference&lt;T&gt; {\n\n    private List&lt;Closeable&gt; closeables;\n\n    public ResourcePhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q, List&lt;Closeable&gt; resource) {\n        super(referent, q);\n        closeables = resource;\n    }\n\n    public void cleanUp() {\n        if (closeables == null || closeables.size() == 0)\n            return;\n        for (Closeable closeable : closeables) {\n            try {\n                closeable.close();\n                System.out.println(&quot;clean up:&quot;+closeable);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"java\">public class ResourceCloseDeamon extends Thread {\n\n    private static ReferenceQueue QUEUE = new ReferenceQueue();\n\n    //保持对reference的引用,防止reference本身被回收\n    private static List&lt;Reference&gt; references=new ArrayList&lt;&gt;();\n    @Override\n    public void run() {\n        this.setName(&quot;ResourceCloseDeamon&quot;);\n        while (true) {\n            try {\n                ResourcePhantomReference reference = (ResourcePhantomReference) QUEUE.remove();\n                reference.cleanUp();\n                references.remove(reference);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void register(Object referent, List&lt;Closeable&gt; closeables) {\n        references.add(new ResourcePhantomReference(referent,QUEUE,closeables));\n    }\n\n\n}\n</code></pre>\n<pre><code class=\"java\">public class FileOperation {\n\n    private FileOutputStream outputStream;\n\n    private FileInputStream inputStream;\n\n    public FileOperation(FileInputStream inputStream, FileOutputStream outputStream) {\n        this.outputStream = outputStream;\n        this.inputStream = inputStream;\n    }\n\n    public void operate() {\n        try {\n            inputStream.getChannel().transferTo(0, inputStream.getChannel().size(), outputStream.getChannel());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n}\n</code></pre>\n<p>测试代码：</p>\n<pre><code class=\"java\">public class PhantomTest {\n\n    public static void main(String[] args) throws Exception {\n        //打开回收\n        ResourceCloseDeamon deamon = new ResourceCloseDeamon();\n        deamon.setDaemon(true);\n        deamon.start();\n\n        // touch a.txt b.txt\n        // echo &quot;hello&quot; &gt; a.txt\n\n        //保留对象,防止gc把stream回收掉,其不到演示效果\n        List&lt;Closeable&gt; all=new ArrayList&lt;&gt;();\n        FileInputStream inputStream;\n        FileOutputStream outputStream;\n\n        for (int i = 0; i &lt; 100000; i++) {\n            inputStream = new FileInputStream(&quot;/Users/robin/a.txt&quot;);\n            outputStream = new FileOutputStream(&quot;/Users/robin/b.txt&quot;);\n            FileOperation operation = new FileOperation(inputStream, outputStream);\n            operation.operate();\n            TimeUnit.MILLISECONDS.sleep(100);\n\n            List&lt;Closeable&gt;closeables=new ArrayList&lt;&gt;();\n            closeables.add(inputStream);\n            closeables.add(outputStream);\n            all.addAll(closeables);\n            ResourceCloseDeamon.register(operation,closeables);\n            //用下面命令查看文件句柄,如果把上面register注释掉,就会发现句柄数量不断上升\n            //jps | grep PhantomTest | awk &#39;{print $1}&#39; |head -1 | xargs  lsof -p  | grep /User/robin\n            System.gc();\n\n        }\n\n\n    }\n}\n</code></pre>\n<p>运行上面的代码，通过jps | grep PhantomTest | awk ‘{print $1}’ |head -1 | xargs lsof -p | grep /User/robin ｜ wc -l 可以看到句柄没有上升，而去掉ResourceCloseDeamon.register(operation,closeables);时，句柄就不会被释放。</p>\n<p>PhantomReference使用时一定要传一个referenceQueue,当然也可以传null,但是这样就毫无意义了。因为PhantomReference的get结果为null,如果在把queue设为null,那么在其指向的referent被回收时，reference本身将永远不会可能被加入队列中，这里我们可以看ReferenceQueue的源码。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><h4 id=\"引用类型对比\"><a href=\"#引用类型对比\" class=\"headerlink\" title=\"引用类型对比\"></a>引用类型对比</h4><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>引用类型</th>\n<th>取得目标对象方式</th>\n<th>垃圾回收条件</th>\n<th>是否可能内存泄漏</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>强引用</td>\n<td>直接调用</td>\n<td>不回收</td>\n<td>可能</td>\n</tr>\n<tr>\n<td>2</td>\n<td>软引用</td>\n<td>通过 get()方法</td>\n<td>视内存情况回收</td>\n<td>不可能</td>\n</tr>\n<tr>\n<td>3</td>\n<td>弱引用</td>\n<td>通过 get()方法</td>\n<td>永远回收</td>\n<td>不可能</td>\n</tr>\n<tr>\n<td>4</td>\n<td>虚引用</td>\n<td>无法取得</td>\n<td>不回收</td>\n<td>可能</td>\n</tr>\n</tbody>\n</table>\n<p>通过对SoftReference，WeakReference，PhantomReference 的介绍，可以看出JDK提供这些类型的reference 主要是用来和GC交互的，根据reference的不同，让JVM采用不同策略来进行对对象的回收(reclaim)。softly-reachable的referent在保证在OutOfMemoryError之前回收对象，weakly-reachable的referent在发生GC时就会被回收,同时这些reference和referenceQueue在一起提供通知机制，PhantomReference的作用就是仅仅就是提供对象回收通知机制，Finalizer借助这种机制实现referent的finalize执行，SoftReference、WeakReference也可以配合referenceQueue使用，实现对象回收通知机制。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.jianshu.com/p/147793693edc\" target=\"_blank\" rel=\"noopener\">Java中的四种引用类型</a></p>\n<p><a href=\"https://my.oschina.net/robinyao/blog/829983\" target=\"_blank\" rel=\"noopener\">Java Reference详解</a></p>\n<p><a href=\"http://www.importnew.com/26250.html\" target=\"_blank\" rel=\"noopener\">Reference、ReferenceQueue 详解</a></p>\n<p>[用弱引用堵住内存泄漏](</p>"},{"title":"LockSupport","author":"zhangke","abbrlink":34693,"date":"2018-12-13T07:21:00.000Z","_content":"---\n# LockSupport\n\n### 概述\n\n1. 用法简介\n2. 源码分析\n3. 底层实现原理\n\n### 1. 用法简介\n\nLockSupport是用来创建锁和其他同步类的基本**线程阻塞**原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。\n\npark()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。\n\n如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。\n<!-- more -->\n需要特别注意的一点：**park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法**。从这个意义上说，park 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 unpark 配对使用才更高效。\n\n官方推介的使用方式如下\n\n```java\nwhile(!canprocess()){\n    ....\n    LockSupport.park(this);\n}\n```\n\n\n\n三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。\n看下线程dump的结果来理解blocker的作用。\n\n![线程dump结果对比](https://segmentfault.com/img/bVJuIP?w=783&h=375)\n\n从线程dump结果可以看出：\n有blocker的可以传递给开发人员更多的现场信息，可以查看到当前线程的阻塞对象，方便定位问题。所以java6新增加带blocker入参的系列park方法，替代原有的park方法。\n\n#### demo1\n\n看一个Java docs中的示例用法：一个先进先出非重入锁类的框架\n\n```java\nclass FIFOMutex {\n    private final AtomicBoolean locked = new AtomicBoolean(false);\n    private final Queue<Thread> waiters\n      = new ConcurrentLinkedQueue<Thread>();\n \n    public void lock() {\n      boolean wasInterrupted = false;\n      Thread current = Thread.currentThread();\n      waiters.add(current);\n \n      // Block while not first in queue or cannot acquire lock\n      while (waiters.peek() != current ||\n             !locked.compareAndSet(false, true)) {\n        LockSupport.park(this);\n        if (Thread.interrupted()) // ignore interrupts while waiting\n          wasInterrupted = true;\n      }\n\n      waiters.remove();\n      if (wasInterrupted)          // reassert interrupt status on exit\n        current.interrupt();\n    }\n \n    public void unlock() {\n      locked.set(false);\n      LockSupport.unpark(waiters.peek());\n    }\n  }}\n  \n  //具体使用\n  public class LockSupportDemo {\n    public static void main(String[] args) throws InterruptedException {\n        final FIFOMutex lock = new FIFOMutex();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    private static Runnable generateTask(final FIFOMutex lock, \n    \t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n运行结果\n\n```\nThread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n从结果可以看出，运行结果可以看出，确实是先进先出类型的锁，同时也验证了没有俩个线程同时获取修改list的时机，因为如果同时修改List回抛出异常，这里没有。从侧面验证了锁的正确性\n\n#### demo2 \n\n验证一下，在park之前多次调用unpark，是否会累加\n\n```\npublic class LockSupportStudy2 {\n\n    public static void main(String[] args) {\n        //在park之前不管有多少个unpark，都只能释放一个park\n        LockSupport.unpark(Thread.currentThread());\n        LockSupport.unpark(Thread.currentThread());\n        System.out.println(\"暂停线程\");\n        LockSupport.park();\n        System.out.println(\"线程继续\");\n        LockSupport.park();\n        System.out.println(\"线程继续\");\n    }\n}\n```\n\n运行结果\n\n```\n暂停线程\n线程继续\n。。。。。\n```\n\n从实验结果可以看出，不管在park之前调用了多少次的unpark，只会唤醒一次相应的线程阻塞。\n\n另外这个实验可以看出park和unpark的先后顺序是不重要的，因此park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。\n\n### 2. 源码分析\n\n1. LockSupport中主要的两个成员变量：\n\n```\n\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long parkBlockerOffset;\n```\n\nunsafe:全名sun.misc.Unsafe可以直接操控内存，被JDK广泛用于自己的包中，如java.nio和java.util.concurrent。但是不建议在生产环境中使用这个类。因为这个API十分不安全、不轻便、而且不稳定。\nLockSupport的方法底层都是调用Unsafe的方法实现。\n\n再来看parkBlockerOffset:\nparkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。\n\n```\n static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> tk = Thread.class;\n            parkBlockerOffset = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(\"parkBlocker\"));\n        } catch (Exception ex) { throw new Error(ex); }\n }\n```\n\n从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.\n\nJVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。\n\n为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？\n仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。\n\n2.LockSupport的方法：\n\n```\npublic static  Object getBlocker(Thread t)\npublic static  void park()\npublic static  void park(Object blocker)\npublic static  void parkNanos(long nanos)\npublic static  void parkNanos(Object blocker, long nanos)\npublic static  void parkUntil(long deadline)\npublic static  void parkUntil(Object blocker, long deadline)\n```\n\n\n\n可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。\n\n```\n private static void setBlocker(Thread t, Object arg) {\n        // Even though volatile, hotspot doesn't need a write barrier here.\n        UNSAFE.putObject(t, parkBlockerOffset, arg);\n  }\n```\n\n对给定线程t的parkBlocker赋值。\n\n```\n    public static Object getBlocker(Thread t) {\n        if (t == null)\n            throw new NullPointerException();\n        return UNSAFE.getObjectVolatile(t, parkBlockerOffset);\n    }\n  \n```\n\n从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。\n\n接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法\n\n**阻塞线程**\n\n- park()\n\n```\npublic static void park() {\n        UNSAFE.park(false, 0L);\n}\n```\n\n调用native方法阻塞当前线程。\n\n- parkNanos(long nanos)\n\n```\npublic static void parkNanos(long nanos) {\n        if (nanos > 0)\n            UNSAFE.park(false, nanos);\n}\n```\n\n阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。\n\n- parkUntil(long deadline)\n\n```\npublic static void parkUntil(long deadline) {\n  UNSAFE.park(true, deadline);\n}\n```\n\n阻塞当前线程，知道deadline时间（deadline - 毫秒数）。\n\nJDK1.6引入这三个方法对应的拥有Blocker版本。\n\n- park(Object blocker)\n\n```\npublic static void park(Object blocker) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(false, 0L);\n  setBlocker(t, null);\n}\n```\n\n1) 记录当前线程等待的对象（阻塞对象）；\n2) 阻塞当前线程；\n3) 当前线程等待对象置为null。\n\n- parkNanos(Object blocker, long nanos)\n\n```\npublic static void parkNanos(Object blocker, long nanos) {\n  if (nanos > 0) {\n      Thread t = Thread.currentThread();\n      setBlocker(t, blocker);\n      UNSAFE.park(false, nanos);\n      setBlocker(t, null);\n  }\n}\n```\n\n阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。\n\n- parkUntil(Object blocker, long deadline)\n\n```\npublic static void parkUntil(Object blocker, long deadline) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(true, deadline);\n  setBlocker(t, null);\n}\n```\n\n阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。\n\n**唤醒线程**\n\n- unpark(Thread thread)\n\n```\npublic static void unpark(Thread thread) {\n  if (thread != null)\n      UNSAFE.unpark(thread);\n}\n```\n\n唤醒处于阻塞状态的线程Thread。\n\n### 3. 底层实现原理\n\n从LockSupport源码可以看出，park和unpark的实现都是调用Unsafe.park和Unsafe.unpark，因此只要找到这俩个的底层实现原理，就可以明白park和unpark的底层实现。\n\n#### HotSpot 里 park/unpark 的实现\n\n每个 java 线程都有一个 Parker 实例，Parker 类是这样定义的：\n\n```\nclass Parker : public os::PlatformParker {\nprivate:\n  volatile int _counter ;\n  ...\npublic:\n  void park(bool isAbsolute, jlong time);\n  void unpark();\n  ...\n}\nclass PlatformParker : public CHeapObj<mtInternal> {\n  protected:\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [1] ;\n    ...\n}\n```\n\n可以看到 Parker 类实际上用 Posix 的 mutex，condition 来实现的。\n\n在 Parker 类里的_counter 字段，就是用来记录所谓的 “许可” 的。\n\n当调用 park 时，先尝试直接能否直接拿到 “许可”，即_counter>0 时，如果成功，则把_counter 设置为 0, 并返回：\n\n```\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &_counter) > 0) return;\n```\n\n如果不成功，则构造一个 ThreadBlockInVM，然后检查_counter 是不是 > 0，如果是，则把_counter 设置为 0，unlock mutex 并返回：\n\n```\n  ThreadBlockInVM tbivm(jt);\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n```\n\n否则，再判断等待的时间，然后再调用 pthread_cond_wait 函数等待，如果等待返回，则把_counter 设置为 0，unlock mutex 并返回\n\n```\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  OrderAccess::fence();\n```\n\n当 unpark 时，则简单多了，直接设置_counter 为 1，再 unlock mutext 返回。如果_counter 之前的值是 0，则还要调用 pthread_cond_signal 唤醒在 park 中等待的线程\n\n```\nvoid Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n     if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") ;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n     } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") \n     }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n```\n\n简而言之，是用 mutex 和 condition 保护了一个_counter 的变量，当 park 时，这个变量置为了 0，当 unpark 时，这个变量置为 1。\n\n值得注意的是在 park 函数里，调用 pthread_cond_wait 时，并没有用 while 来判断，所以 posix condition 里的 \"Spurious wakeup\" 一样会传递到上层 Java 的代码里，这也是官方为什么推介使用while方式的原因。\n\n关于 \"Spurious wakeup\"，参考这篇文章：[Why does pthread_cond_wait have spurious wakeups?](https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups)\n\n不过在看这篇文章之前，最好看看《Unix环境高级编程》这本书第11章节\n\n```\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n```\n\n这也就是为什么 Java dos 里提到，当下面三种情况下 park 函数会返回：\n\n- Some other thread invokes unpark with the current thread as the target; or\n- Some other thread interrupts the current thread; or\n- **The call spuriously (that is, for no reason) returns.**\n\n相关的实现代码在：\n\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp\n\n### 参考\n\n1. [浅谈Java并发编程系列（八）—— LockSupport原理剖析](https://segmentfault.com/a/1190000008420938)\n2. [并行编程之条件变量（posix condition variables）](https://blog.csdn.net/hengyunabc/article/details/27969613)\n3. [Java的LockSupport.park()实现分析](https://blog.csdn.net/hengyunabc/article/details/28126139)","source":"_posts/LockSupport.md","raw":"title: LockSupport\ntags:\n  - JUC\ncategories:\n  - java\nauthor: zhangke\nabbrlink: 34693\ndate: 2018-12-13 15:21:00\n---\n---\n# LockSupport\n\n### 概述\n\n1. 用法简介\n2. 源码分析\n3. 底层实现原理\n\n### 1. 用法简介\n\nLockSupport是用来创建锁和其他同步类的基本**线程阻塞**原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。\n\npark()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。\n\n如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。\n<!-- more -->\n需要特别注意的一点：**park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法**。从这个意义上说，park 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 unpark 配对使用才更高效。\n\n官方推介的使用方式如下\n\n```java\nwhile(!canprocess()){\n    ....\n    LockSupport.park(this);\n}\n```\n\n\n\n三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。\n看下线程dump的结果来理解blocker的作用。\n\n![线程dump结果对比](https://segmentfault.com/img/bVJuIP?w=783&h=375)\n\n从线程dump结果可以看出：\n有blocker的可以传递给开发人员更多的现场信息，可以查看到当前线程的阻塞对象，方便定位问题。所以java6新增加带blocker入参的系列park方法，替代原有的park方法。\n\n#### demo1\n\n看一个Java docs中的示例用法：一个先进先出非重入锁类的框架\n\n```java\nclass FIFOMutex {\n    private final AtomicBoolean locked = new AtomicBoolean(false);\n    private final Queue<Thread> waiters\n      = new ConcurrentLinkedQueue<Thread>();\n \n    public void lock() {\n      boolean wasInterrupted = false;\n      Thread current = Thread.currentThread();\n      waiters.add(current);\n \n      // Block while not first in queue or cannot acquire lock\n      while (waiters.peek() != current ||\n             !locked.compareAndSet(false, true)) {\n        LockSupport.park(this);\n        if (Thread.interrupted()) // ignore interrupts while waiting\n          wasInterrupted = true;\n      }\n\n      waiters.remove();\n      if (wasInterrupted)          // reassert interrupt status on exit\n        current.interrupt();\n    }\n \n    public void unlock() {\n      locked.set(false);\n      LockSupport.unpark(waiters.peek());\n    }\n  }}\n  \n  //具体使用\n  public class LockSupportDemo {\n    public static void main(String[] args) throws InterruptedException {\n        final FIFOMutex lock = new FIFOMutex();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    private static Runnable generateTask(final FIFOMutex lock, \n    \t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n运行结果\n\n```\nThread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n从结果可以看出，运行结果可以看出，确实是先进先出类型的锁，同时也验证了没有俩个线程同时获取修改list的时机，因为如果同时修改List回抛出异常，这里没有。从侧面验证了锁的正确性\n\n#### demo2 \n\n验证一下，在park之前多次调用unpark，是否会累加\n\n```\npublic class LockSupportStudy2 {\n\n    public static void main(String[] args) {\n        //在park之前不管有多少个unpark，都只能释放一个park\n        LockSupport.unpark(Thread.currentThread());\n        LockSupport.unpark(Thread.currentThread());\n        System.out.println(\"暂停线程\");\n        LockSupport.park();\n        System.out.println(\"线程继续\");\n        LockSupport.park();\n        System.out.println(\"线程继续\");\n    }\n}\n```\n\n运行结果\n\n```\n暂停线程\n线程继续\n。。。。。\n```\n\n从实验结果可以看出，不管在park之前调用了多少次的unpark，只会唤醒一次相应的线程阻塞。\n\n另外这个实验可以看出park和unpark的先后顺序是不重要的，因此park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。\n\n### 2. 源码分析\n\n1. LockSupport中主要的两个成员变量：\n\n```\n\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long parkBlockerOffset;\n```\n\nunsafe:全名sun.misc.Unsafe可以直接操控内存，被JDK广泛用于自己的包中，如java.nio和java.util.concurrent。但是不建议在生产环境中使用这个类。因为这个API十分不安全、不轻便、而且不稳定。\nLockSupport的方法底层都是调用Unsafe的方法实现。\n\n再来看parkBlockerOffset:\nparkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。\n\n```\n static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> tk = Thread.class;\n            parkBlockerOffset = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(\"parkBlocker\"));\n        } catch (Exception ex) { throw new Error(ex); }\n }\n```\n\n从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.\n\nJVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。\n\n为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？\n仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。\n\n2.LockSupport的方法：\n\n```\npublic static  Object getBlocker(Thread t)\npublic static  void park()\npublic static  void park(Object blocker)\npublic static  void parkNanos(long nanos)\npublic static  void parkNanos(Object blocker, long nanos)\npublic static  void parkUntil(long deadline)\npublic static  void parkUntil(Object blocker, long deadline)\n```\n\n\n\n可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。\n\n```\n private static void setBlocker(Thread t, Object arg) {\n        // Even though volatile, hotspot doesn't need a write barrier here.\n        UNSAFE.putObject(t, parkBlockerOffset, arg);\n  }\n```\n\n对给定线程t的parkBlocker赋值。\n\n```\n    public static Object getBlocker(Thread t) {\n        if (t == null)\n            throw new NullPointerException();\n        return UNSAFE.getObjectVolatile(t, parkBlockerOffset);\n    }\n  \n```\n\n从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。\n\n接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法\n\n**阻塞线程**\n\n- park()\n\n```\npublic static void park() {\n        UNSAFE.park(false, 0L);\n}\n```\n\n调用native方法阻塞当前线程。\n\n- parkNanos(long nanos)\n\n```\npublic static void parkNanos(long nanos) {\n        if (nanos > 0)\n            UNSAFE.park(false, nanos);\n}\n```\n\n阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。\n\n- parkUntil(long deadline)\n\n```\npublic static void parkUntil(long deadline) {\n  UNSAFE.park(true, deadline);\n}\n```\n\n阻塞当前线程，知道deadline时间（deadline - 毫秒数）。\n\nJDK1.6引入这三个方法对应的拥有Blocker版本。\n\n- park(Object blocker)\n\n```\npublic static void park(Object blocker) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(false, 0L);\n  setBlocker(t, null);\n}\n```\n\n1) 记录当前线程等待的对象（阻塞对象）；\n2) 阻塞当前线程；\n3) 当前线程等待对象置为null。\n\n- parkNanos(Object blocker, long nanos)\n\n```\npublic static void parkNanos(Object blocker, long nanos) {\n  if (nanos > 0) {\n      Thread t = Thread.currentThread();\n      setBlocker(t, blocker);\n      UNSAFE.park(false, nanos);\n      setBlocker(t, null);\n  }\n}\n```\n\n阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。\n\n- parkUntil(Object blocker, long deadline)\n\n```\npublic static void parkUntil(Object blocker, long deadline) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(true, deadline);\n  setBlocker(t, null);\n}\n```\n\n阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。\n\n**唤醒线程**\n\n- unpark(Thread thread)\n\n```\npublic static void unpark(Thread thread) {\n  if (thread != null)\n      UNSAFE.unpark(thread);\n}\n```\n\n唤醒处于阻塞状态的线程Thread。\n\n### 3. 底层实现原理\n\n从LockSupport源码可以看出，park和unpark的实现都是调用Unsafe.park和Unsafe.unpark，因此只要找到这俩个的底层实现原理，就可以明白park和unpark的底层实现。\n\n#### HotSpot 里 park/unpark 的实现\n\n每个 java 线程都有一个 Parker 实例，Parker 类是这样定义的：\n\n```\nclass Parker : public os::PlatformParker {\nprivate:\n  volatile int _counter ;\n  ...\npublic:\n  void park(bool isAbsolute, jlong time);\n  void unpark();\n  ...\n}\nclass PlatformParker : public CHeapObj<mtInternal> {\n  protected:\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [1] ;\n    ...\n}\n```\n\n可以看到 Parker 类实际上用 Posix 的 mutex，condition 来实现的。\n\n在 Parker 类里的_counter 字段，就是用来记录所谓的 “许可” 的。\n\n当调用 park 时，先尝试直接能否直接拿到 “许可”，即_counter>0 时，如果成功，则把_counter 设置为 0, 并返回：\n\n```\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &_counter) > 0) return;\n```\n\n如果不成功，则构造一个 ThreadBlockInVM，然后检查_counter 是不是 > 0，如果是，则把_counter 设置为 0，unlock mutex 并返回：\n\n```\n  ThreadBlockInVM tbivm(jt);\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n```\n\n否则，再判断等待的时间，然后再调用 pthread_cond_wait 函数等待，如果等待返回，则把_counter 设置为 0，unlock mutex 并返回\n\n```\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  OrderAccess::fence();\n```\n\n当 unpark 时，则简单多了，直接设置_counter 为 1，再 unlock mutext 返回。如果_counter 之前的值是 0，则还要调用 pthread_cond_signal 唤醒在 park 中等待的线程\n\n```\nvoid Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n     if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") ;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n     } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") \n     }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n```\n\n简而言之，是用 mutex 和 condition 保护了一个_counter 的变量，当 park 时，这个变量置为了 0，当 unpark 时，这个变量置为 1。\n\n值得注意的是在 park 函数里，调用 pthread_cond_wait 时，并没有用 while 来判断，所以 posix condition 里的 \"Spurious wakeup\" 一样会传递到上层 Java 的代码里，这也是官方为什么推介使用while方式的原因。\n\n关于 \"Spurious wakeup\"，参考这篇文章：[Why does pthread_cond_wait have spurious wakeups?](https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups)\n\n不过在看这篇文章之前，最好看看《Unix环境高级编程》这本书第11章节\n\n```\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n```\n\n这也就是为什么 Java dos 里提到，当下面三种情况下 park 函数会返回：\n\n- Some other thread invokes unpark with the current thread as the target; or\n- Some other thread interrupts the current thread; or\n- **The call spuriously (that is, for no reason) returns.**\n\n相关的实现代码在：\n\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp\n\n### 参考\n\n1. [浅谈Java并发编程系列（八）—— LockSupport原理剖析](https://segmentfault.com/a/1190000008420938)\n2. [并行编程之条件变量（posix condition variables）](https://blog.csdn.net/hengyunabc/article/details/27969613)\n3. [Java的LockSupport.park()实现分析](https://blog.csdn.net/hengyunabc/article/details/28126139)","slug":"LockSupport","published":1,"updated":"2019-01-04T01:48:59.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx2m0015eb1uk13fqitb","content":"<hr>\n<h1 id=\"LockSupport\"><a href=\"#LockSupport\" class=\"headerlink\" title=\"LockSupport\"></a>LockSupport</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>用法简介</li>\n<li>源码分析</li>\n<li>底层实现原理</li>\n</ol>\n<h3 id=\"1-用法简介\"><a href=\"#1-用法简介\" class=\"headerlink\" title=\"1. 用法简介\"></a>1. 用法简介</h3><p>LockSupport是用来创建锁和其他同步类的基本<strong>线程阻塞</strong>原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。</p>\n<p>park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p>\n<p>如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。<br><a id=\"more\"></a><br>需要特别注意的一点：<strong>park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法</strong>。从这个意义上说，park 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 unpark 配对使用才更高效。</p>\n<p>官方推介的使用方式如下</p>\n<pre><code class=\"java\">while(!canprocess()){\n    ....\n    LockSupport.park(this);\n}\n</code></pre>\n<p>三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。<br>看下线程dump的结果来理解blocker的作用。</p>\n<p><img src=\"https://segmentfault.com/img/bVJuIP?w=783&amp;h=375\" alt=\"线程dump结果对比\"></p>\n<p>从线程dump结果可以看出：<br>有blocker的可以传递给开发人员更多的现场信息，可以查看到当前线程的阻塞对象，方便定位问题。所以java6新增加带blocker入参的系列park方法，替代原有的park方法。</p>\n<h4 id=\"demo1\"><a href=\"#demo1\" class=\"headerlink\" title=\"demo1\"></a>demo1</h4><p>看一个Java docs中的示例用法：一个先进先出非重入锁类的框架</p>\n<pre><code class=\"java\">class FIFOMutex {\n    private final AtomicBoolean locked = new AtomicBoolean(false);\n    private final Queue&lt;Thread&gt; waiters\n      = new ConcurrentLinkedQueue&lt;Thread&gt;();\n\n    public void lock() {\n      boolean wasInterrupted = false;\n      Thread current = Thread.currentThread();\n      waiters.add(current);\n\n      // Block while not first in queue or cannot acquire lock\n      while (waiters.peek() != current ||\n             !locked.compareAndSet(false, true)) {\n        LockSupport.park(this);\n        if (Thread.interrupted()) // ignore interrupts while waiting\n          wasInterrupted = true;\n      }\n\n      waiters.remove();\n      if (wasInterrupted)          // reassert interrupt status on exit\n        current.interrupt();\n    }\n\n    public void unlock() {\n      locked.set(false);\n      LockSupport.unpark(waiters.peek());\n    }\n  }}\n\n  //具体使用\n  public class LockSupportDemo {\n    public static void main(String[] args) throws InterruptedException {\n        final FIFOMutex lock = new FIFOMutex();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    private static Runnable generateTask(final FIFOMutex lock, \n                    final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>Thread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre><p>从结果可以看出，运行结果可以看出，确实是先进先出类型的锁，同时也验证了没有俩个线程同时获取修改list的时机，因为如果同时修改List回抛出异常，这里没有。从侧面验证了锁的正确性</p>\n<h4 id=\"demo2\"><a href=\"#demo2\" class=\"headerlink\" title=\"demo2\"></a>demo2</h4><p>验证一下，在park之前多次调用unpark，是否会累加</p>\n<pre><code>public class LockSupportStudy2 {\n\n    public static void main(String[] args) {\n        //在park之前不管有多少个unpark，都只能释放一个park\n        LockSupport.unpark(Thread.currentThread());\n        LockSupport.unpark(Thread.currentThread());\n        System.out.println(&quot;暂停线程&quot;);\n        LockSupport.park();\n        System.out.println(&quot;线程继续&quot;);\n        LockSupport.park();\n        System.out.println(&quot;线程继续&quot;);\n    }\n}\n</code></pre><p>运行结果</p>\n<pre><code>暂停线程\n线程继续\n。。。。。\n</code></pre><p>从实验结果可以看出，不管在park之前调用了多少次的unpark，只会唤醒一次相应的线程阻塞。</p>\n<p>另外这个实验可以看出park和unpark的先后顺序是不重要的，因此park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p>\n<h3 id=\"2-源码分析\"><a href=\"#2-源码分析\" class=\"headerlink\" title=\"2. 源码分析\"></a>2. 源码分析</h3><ol>\n<li>LockSupport中主要的两个成员变量：</li>\n</ol>\n<pre><code>\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long parkBlockerOffset;\n</code></pre><p>unsafe:全名sun.misc.Unsafe可以直接操控内存，被JDK广泛用于自己的包中，如java.nio和java.util.concurrent。但是不建议在生产环境中使用这个类。因为这个API十分不安全、不轻便、而且不稳定。<br>LockSupport的方法底层都是调用Unsafe的方法实现。</p>\n<p>再来看parkBlockerOffset:<br>parkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。</p>\n<pre><code> static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class&lt;?&gt; tk = Thread.class;\n            parkBlockerOffset = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(&quot;parkBlocker&quot;));\n        } catch (Exception ex) { throw new Error(ex); }\n }\n</code></pre><p>从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.</p>\n<p>JVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。</p>\n<p>为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？<br>仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。</p>\n<p>2.LockSupport的方法：</p>\n<pre><code>public static  Object getBlocker(Thread t)\npublic static  void park()\npublic static  void park(Object blocker)\npublic static  void parkNanos(long nanos)\npublic static  void parkNanos(Object blocker, long nanos)\npublic static  void parkUntil(long deadline)\npublic static  void parkUntil(Object blocker, long deadline)\n</code></pre><p>可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。</p>\n<pre><code> private static void setBlocker(Thread t, Object arg) {\n        // Even though volatile, hotspot doesn&#39;t need a write barrier here.\n        UNSAFE.putObject(t, parkBlockerOffset, arg);\n  }\n</code></pre><p>对给定线程t的parkBlocker赋值。</p>\n<pre><code>    public static Object getBlocker(Thread t) {\n        if (t == null)\n            throw new NullPointerException();\n        return UNSAFE.getObjectVolatile(t, parkBlockerOffset);\n    }\n\n</code></pre><p>从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。</p>\n<p>接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法</p>\n<p><strong>阻塞线程</strong></p>\n<ul>\n<li>park()</li>\n</ul>\n<pre><code>public static void park() {\n        UNSAFE.park(false, 0L);\n}\n</code></pre><p>调用native方法阻塞当前线程。</p>\n<ul>\n<li>parkNanos(long nanos)</li>\n</ul>\n<pre><code>public static void parkNanos(long nanos) {\n        if (nanos &gt; 0)\n            UNSAFE.park(false, nanos);\n}\n</code></pre><p>阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。</p>\n<ul>\n<li>parkUntil(long deadline)</li>\n</ul>\n<pre><code>public static void parkUntil(long deadline) {\n  UNSAFE.park(true, deadline);\n}\n</code></pre><p>阻塞当前线程，知道deadline时间（deadline - 毫秒数）。</p>\n<p>JDK1.6引入这三个方法对应的拥有Blocker版本。</p>\n<ul>\n<li>park(Object blocker)</li>\n</ul>\n<pre><code>public static void park(Object blocker) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(false, 0L);\n  setBlocker(t, null);\n}\n</code></pre><p>1) 记录当前线程等待的对象（阻塞对象）；<br>2) 阻塞当前线程；<br>3) 当前线程等待对象置为null。</p>\n<ul>\n<li>parkNanos(Object blocker, long nanos)</li>\n</ul>\n<pre><code>public static void parkNanos(Object blocker, long nanos) {\n  if (nanos &gt; 0) {\n      Thread t = Thread.currentThread();\n      setBlocker(t, blocker);\n      UNSAFE.park(false, nanos);\n      setBlocker(t, null);\n  }\n}\n</code></pre><p>阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。</p>\n<ul>\n<li>parkUntil(Object blocker, long deadline)</li>\n</ul>\n<pre><code>public static void parkUntil(Object blocker, long deadline) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(true, deadline);\n  setBlocker(t, null);\n}\n</code></pre><p>阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。</p>\n<p><strong>唤醒线程</strong></p>\n<ul>\n<li>unpark(Thread thread)</li>\n</ul>\n<pre><code>public static void unpark(Thread thread) {\n  if (thread != null)\n      UNSAFE.unpark(thread);\n}\n</code></pre><p>唤醒处于阻塞状态的线程Thread。</p>\n<h3 id=\"3-底层实现原理\"><a href=\"#3-底层实现原理\" class=\"headerlink\" title=\"3. 底层实现原理\"></a>3. 底层实现原理</h3><p>从LockSupport源码可以看出，park和unpark的实现都是调用Unsafe.park和Unsafe.unpark，因此只要找到这俩个的底层实现原理，就可以明白park和unpark的底层实现。</p>\n<h4 id=\"HotSpot-里-park-unpark-的实现\"><a href=\"#HotSpot-里-park-unpark-的实现\" class=\"headerlink\" title=\"HotSpot 里 park/unpark 的实现\"></a>HotSpot 里 park/unpark 的实现</h4><p>每个 java 线程都有一个 Parker 实例，Parker 类是这样定义的：</p>\n<pre><code>class Parker : public os::PlatformParker {\nprivate:\n  volatile int _counter ;\n  ...\npublic:\n  void park(bool isAbsolute, jlong time);\n  void unpark();\n  ...\n}\nclass PlatformParker : public CHeapObj&lt;mtInternal&gt; {\n  protected:\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [1] ;\n    ...\n}\n</code></pre><p>可以看到 Parker 类实际上用 Posix 的 mutex，condition 来实现的。</p>\n<p>在 Parker 类里的_counter 字段，就是用来记录所谓的 “许可” 的。</p>\n<p>当调用 park 时，先尝试直接能否直接拿到 “许可”，即_counter&gt;0 时，如果成功，则把_counter 设置为 0, 并返回：</p>\n<pre><code>void Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we&#39;d do something useful while spinning, such\n  // as calling unpackTime().\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;\n</code></pre><p>如果不成功，则构造一个 ThreadBlockInVM，然后检查_counter 是不是 &gt; 0，如果是，则把_counter 设置为 0，unlock mutex 并返回：</p>\n<pre><code>  ThreadBlockInVM tbivm(jt);\n  if (_counter &gt; 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n</code></pre><p>否则，再判断等待的时间，然后再调用 pthread_cond_wait 函数等待，如果等待返回，则把_counter 设置为 0，unlock mutex 并返回</p>\n<pre><code>  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, &quot;invariant&quot;) ;\n  OrderAccess::fence();\n</code></pre><p>当 unpark 时，则简单多了，直接设置_counter 为 1，再 unlock mutext 返回。如果_counter 之前的值是 0，则还要调用 pthread_cond_signal 唤醒在 park 中等待的线程</p>\n<pre><code>void Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, &quot;invariant&quot;) ;\n  s = _counter;\n  _counter = 1;\n  if (s &lt; 1) {\n     if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, &quot;invariant&quot;) ;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, &quot;invariant&quot;) ;\n     } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, &quot;invariant&quot;) ;\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, &quot;invariant&quot;) \n     }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, &quot;invariant&quot;) ;\n  }\n}\n</code></pre><p>简而言之，是用 mutex 和 condition 保护了一个_counter 的变量，当 park 时，这个变量置为了 0，当 unpark 时，这个变量置为 1。</p>\n<p>值得注意的是在 park 函数里，调用 pthread_cond_wait 时，并没有用 while 来判断，所以 posix condition 里的 “Spurious wakeup” 一样会传递到上层 Java 的代码里，这也是官方为什么推介使用while方式的原因。</p>\n<p>关于 “Spurious wakeup”，参考这篇文章：<a href=\"https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups\" target=\"_blank\" rel=\"noopener\">Why does pthread_cond_wait have spurious wakeups?</a></p>\n<p>不过在看这篇文章之前，最好看看《Unix环境高级编程》这本书第11章节</p>\n<pre><code>  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n</code></pre><p>这也就是为什么 Java dos 里提到，当下面三种情况下 park 函数会返回：</p>\n<ul>\n<li>Some other thread invokes unpark with the current thread as the target; or</li>\n<li>Some other thread interrupts the current thread; or</li>\n<li><strong>The call spuriously (that is, for no reason) returns.</strong></li>\n</ul>\n<p>相关的实现代码在：</p>\n<p><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp</a></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000008420938\" target=\"_blank\" rel=\"noopener\">浅谈Java并发编程系列（八）—— LockSupport原理剖析</a></li>\n<li><a href=\"https://blog.csdn.net/hengyunabc/article/details/27969613\" target=\"_blank\" rel=\"noopener\">并行编程之条件变量（posix condition variables）</a></li>\n<li><a href=\"https://blog.csdn.net/hengyunabc/article/details/28126139\" target=\"_blank\" rel=\"noopener\">Java的LockSupport.park()实现分析</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<hr>\n<h1 id=\"LockSupport\"><a href=\"#LockSupport\" class=\"headerlink\" title=\"LockSupport\"></a>LockSupport</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>用法简介</li>\n<li>源码分析</li>\n<li>底层实现原理</li>\n</ol>\n<h3 id=\"1-用法简介\"><a href=\"#1-用法简介\" class=\"headerlink\" title=\"1. 用法简介\"></a>1. 用法简介</h3><p>LockSupport是用来创建锁和其他同步类的基本<strong>线程阻塞</strong>原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。</p>\n<p>park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p>\n<p>如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。<br>","more":"<br>需要特别注意的一点：<strong>park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法</strong>。从这个意义上说，park 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 unpark 配对使用才更高效。</p>\n<p>官方推介的使用方式如下</p>\n<pre><code class=\"java\">while(!canprocess()){\n    ....\n    LockSupport.park(this);\n}\n</code></pre>\n<p>三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。<br>看下线程dump的结果来理解blocker的作用。</p>\n<p><img src=\"https://segmentfault.com/img/bVJuIP?w=783&amp;h=375\" alt=\"线程dump结果对比\"></p>\n<p>从线程dump结果可以看出：<br>有blocker的可以传递给开发人员更多的现场信息，可以查看到当前线程的阻塞对象，方便定位问题。所以java6新增加带blocker入参的系列park方法，替代原有的park方法。</p>\n<h4 id=\"demo1\"><a href=\"#demo1\" class=\"headerlink\" title=\"demo1\"></a>demo1</h4><p>看一个Java docs中的示例用法：一个先进先出非重入锁类的框架</p>\n<pre><code class=\"java\">class FIFOMutex {\n    private final AtomicBoolean locked = new AtomicBoolean(false);\n    private final Queue&lt;Thread&gt; waiters\n      = new ConcurrentLinkedQueue&lt;Thread&gt;();\n\n    public void lock() {\n      boolean wasInterrupted = false;\n      Thread current = Thread.currentThread();\n      waiters.add(current);\n\n      // Block while not first in queue or cannot acquire lock\n      while (waiters.peek() != current ||\n             !locked.compareAndSet(false, true)) {\n        LockSupport.park(this);\n        if (Thread.interrupted()) // ignore interrupts while waiting\n          wasInterrupted = true;\n      }\n\n      waiters.remove();\n      if (wasInterrupted)          // reassert interrupt status on exit\n        current.interrupt();\n    }\n\n    public void unlock() {\n      locked.set(false);\n      LockSupport.unpark(waiters.peek());\n    }\n  }}\n\n  //具体使用\n  public class LockSupportDemo {\n    public static void main(String[] args) throws InterruptedException {\n        final FIFOMutex lock = new FIFOMutex();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    private static Runnable generateTask(final FIFOMutex lock, \n                    final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>Thread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre><p>从结果可以看出，运行结果可以看出，确实是先进先出类型的锁，同时也验证了没有俩个线程同时获取修改list的时机，因为如果同时修改List回抛出异常，这里没有。从侧面验证了锁的正确性</p>\n<h4 id=\"demo2\"><a href=\"#demo2\" class=\"headerlink\" title=\"demo2\"></a>demo2</h4><p>验证一下，在park之前多次调用unpark，是否会累加</p>\n<pre><code>public class LockSupportStudy2 {\n\n    public static void main(String[] args) {\n        //在park之前不管有多少个unpark，都只能释放一个park\n        LockSupport.unpark(Thread.currentThread());\n        LockSupport.unpark(Thread.currentThread());\n        System.out.println(&quot;暂停线程&quot;);\n        LockSupport.park();\n        System.out.println(&quot;线程继续&quot;);\n        LockSupport.park();\n        System.out.println(&quot;线程继续&quot;);\n    }\n}\n</code></pre><p>运行结果</p>\n<pre><code>暂停线程\n线程继续\n。。。。。\n</code></pre><p>从实验结果可以看出，不管在park之前调用了多少次的unpark，只会唤醒一次相应的线程阻塞。</p>\n<p>另外这个实验可以看出park和unpark的先后顺序是不重要的，因此park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p>\n<h3 id=\"2-源码分析\"><a href=\"#2-源码分析\" class=\"headerlink\" title=\"2. 源码分析\"></a>2. 源码分析</h3><ol>\n<li>LockSupport中主要的两个成员变量：</li>\n</ol>\n<pre><code>\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long parkBlockerOffset;\n</code></pre><p>unsafe:全名sun.misc.Unsafe可以直接操控内存，被JDK广泛用于自己的包中，如java.nio和java.util.concurrent。但是不建议在生产环境中使用这个类。因为这个API十分不安全、不轻便、而且不稳定。<br>LockSupport的方法底层都是调用Unsafe的方法实现。</p>\n<p>再来看parkBlockerOffset:<br>parkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。</p>\n<pre><code> static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class&lt;?&gt; tk = Thread.class;\n            parkBlockerOffset = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(&quot;parkBlocker&quot;));\n        } catch (Exception ex) { throw new Error(ex); }\n }\n</code></pre><p>从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.</p>\n<p>JVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。</p>\n<p>为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？<br>仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。</p>\n<p>2.LockSupport的方法：</p>\n<pre><code>public static  Object getBlocker(Thread t)\npublic static  void park()\npublic static  void park(Object blocker)\npublic static  void parkNanos(long nanos)\npublic static  void parkNanos(Object blocker, long nanos)\npublic static  void parkUntil(long deadline)\npublic static  void parkUntil(Object blocker, long deadline)\n</code></pre><p>可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。</p>\n<pre><code> private static void setBlocker(Thread t, Object arg) {\n        // Even though volatile, hotspot doesn&#39;t need a write barrier here.\n        UNSAFE.putObject(t, parkBlockerOffset, arg);\n  }\n</code></pre><p>对给定线程t的parkBlocker赋值。</p>\n<pre><code>    public static Object getBlocker(Thread t) {\n        if (t == null)\n            throw new NullPointerException();\n        return UNSAFE.getObjectVolatile(t, parkBlockerOffset);\n    }\n\n</code></pre><p>从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。</p>\n<p>接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法</p>\n<p><strong>阻塞线程</strong></p>\n<ul>\n<li>park()</li>\n</ul>\n<pre><code>public static void park() {\n        UNSAFE.park(false, 0L);\n}\n</code></pre><p>调用native方法阻塞当前线程。</p>\n<ul>\n<li>parkNanos(long nanos)</li>\n</ul>\n<pre><code>public static void parkNanos(long nanos) {\n        if (nanos &gt; 0)\n            UNSAFE.park(false, nanos);\n}\n</code></pre><p>阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。</p>\n<ul>\n<li>parkUntil(long deadline)</li>\n</ul>\n<pre><code>public static void parkUntil(long deadline) {\n  UNSAFE.park(true, deadline);\n}\n</code></pre><p>阻塞当前线程，知道deadline时间（deadline - 毫秒数）。</p>\n<p>JDK1.6引入这三个方法对应的拥有Blocker版本。</p>\n<ul>\n<li>park(Object blocker)</li>\n</ul>\n<pre><code>public static void park(Object blocker) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(false, 0L);\n  setBlocker(t, null);\n}\n</code></pre><p>1) 记录当前线程等待的对象（阻塞对象）；<br>2) 阻塞当前线程；<br>3) 当前线程等待对象置为null。</p>\n<ul>\n<li>parkNanos(Object blocker, long nanos)</li>\n</ul>\n<pre><code>public static void parkNanos(Object blocker, long nanos) {\n  if (nanos &gt; 0) {\n      Thread t = Thread.currentThread();\n      setBlocker(t, blocker);\n      UNSAFE.park(false, nanos);\n      setBlocker(t, null);\n  }\n}\n</code></pre><p>阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。</p>\n<ul>\n<li>parkUntil(Object blocker, long deadline)</li>\n</ul>\n<pre><code>public static void parkUntil(Object blocker, long deadline) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(true, deadline);\n  setBlocker(t, null);\n}\n</code></pre><p>阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。</p>\n<p><strong>唤醒线程</strong></p>\n<ul>\n<li>unpark(Thread thread)</li>\n</ul>\n<pre><code>public static void unpark(Thread thread) {\n  if (thread != null)\n      UNSAFE.unpark(thread);\n}\n</code></pre><p>唤醒处于阻塞状态的线程Thread。</p>\n<h3 id=\"3-底层实现原理\"><a href=\"#3-底层实现原理\" class=\"headerlink\" title=\"3. 底层实现原理\"></a>3. 底层实现原理</h3><p>从LockSupport源码可以看出，park和unpark的实现都是调用Unsafe.park和Unsafe.unpark，因此只要找到这俩个的底层实现原理，就可以明白park和unpark的底层实现。</p>\n<h4 id=\"HotSpot-里-park-unpark-的实现\"><a href=\"#HotSpot-里-park-unpark-的实现\" class=\"headerlink\" title=\"HotSpot 里 park/unpark 的实现\"></a>HotSpot 里 park/unpark 的实现</h4><p>每个 java 线程都有一个 Parker 实例，Parker 类是这样定义的：</p>\n<pre><code>class Parker : public os::PlatformParker {\nprivate:\n  volatile int _counter ;\n  ...\npublic:\n  void park(bool isAbsolute, jlong time);\n  void unpark();\n  ...\n}\nclass PlatformParker : public CHeapObj&lt;mtInternal&gt; {\n  protected:\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [1] ;\n    ...\n}\n</code></pre><p>可以看到 Parker 类实际上用 Posix 的 mutex，condition 来实现的。</p>\n<p>在 Parker 类里的_counter 字段，就是用来记录所谓的 “许可” 的。</p>\n<p>当调用 park 时，先尝试直接能否直接拿到 “许可”，即_counter&gt;0 时，如果成功，则把_counter 设置为 0, 并返回：</p>\n<pre><code>void Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we&#39;d do something useful while spinning, such\n  // as calling unpackTime().\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;\n</code></pre><p>如果不成功，则构造一个 ThreadBlockInVM，然后检查_counter 是不是 &gt; 0，如果是，则把_counter 设置为 0，unlock mutex 并返回：</p>\n<pre><code>  ThreadBlockInVM tbivm(jt);\n  if (_counter &gt; 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n</code></pre><p>否则，再判断等待的时间，然后再调用 pthread_cond_wait 函数等待，如果等待返回，则把_counter 设置为 0，unlock mutex 并返回</p>\n<pre><code>  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, &quot;invariant&quot;) ;\n  OrderAccess::fence();\n</code></pre><p>当 unpark 时，则简单多了，直接设置_counter 为 1，再 unlock mutext 返回。如果_counter 之前的值是 0，则还要调用 pthread_cond_signal 唤醒在 park 中等待的线程</p>\n<pre><code>void Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, &quot;invariant&quot;) ;\n  s = _counter;\n  _counter = 1;\n  if (s &lt; 1) {\n     if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, &quot;invariant&quot;) ;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, &quot;invariant&quot;) ;\n     } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, &quot;invariant&quot;) ;\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, &quot;invariant&quot;) \n     }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, &quot;invariant&quot;) ;\n  }\n}\n</code></pre><p>简而言之，是用 mutex 和 condition 保护了一个_counter 的变量，当 park 时，这个变量置为了 0，当 unpark 时，这个变量置为 1。</p>\n<p>值得注意的是在 park 函数里，调用 pthread_cond_wait 时，并没有用 while 来判断，所以 posix condition 里的 “Spurious wakeup” 一样会传递到上层 Java 的代码里，这也是官方为什么推介使用while方式的原因。</p>\n<p>关于 “Spurious wakeup”，参考这篇文章：<a href=\"https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups\" target=\"_blank\" rel=\"noopener\">Why does pthread_cond_wait have spurious wakeups?</a></p>\n<p>不过在看这篇文章之前，最好看看《Unix环境高级编程》这本书第11章节</p>\n<pre><code>  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n</code></pre><p>这也就是为什么 Java dos 里提到，当下面三种情况下 park 函数会返回：</p>\n<ul>\n<li>Some other thread invokes unpark with the current thread as the target; or</li>\n<li>Some other thread interrupts the current thread; or</li>\n<li><strong>The call spuriously (that is, for no reason) returns.</strong></li>\n</ul>\n<p>相关的实现代码在：</p>\n<p><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp</a></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000008420938\" target=\"_blank\" rel=\"noopener\">浅谈Java并发编程系列（八）—— LockSupport原理剖析</a></li>\n<li><a href=\"https://blog.csdn.net/hengyunabc/article/details/27969613\" target=\"_blank\" rel=\"noopener\">并行编程之条件变量（posix condition variables）</a></li>\n<li><a href=\"https://blog.csdn.net/hengyunabc/article/details/28126139\" target=\"_blank\" rel=\"noopener\">Java的LockSupport.park()实现分析</a></li>\n</ol>"},{"abbrlink":4,"title":"java多线系列之 04 线程让步和join","author":"zhangke","date":"2018-07-13T03:09:00.000Z","_content":"# java 多线系列之 04 线程让步和join\n\n### 概要\n\n>1.  yield()介绍以及示例\n>2.  yield() 与 wait()的比较\n>3.  join() 介绍及示例\n\n### 1. yield介绍以及示例\n\n>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！\n>\n>下面，通过示例查看它的用法。\n>\n>```\n>// YieldTest.java的源码\n>class ThreadA extends Thread{\n>    public ThreadA(String name){ \n>        super(name); \n>    } \n>    public synchronized void run(){ \n>        for(int i=0; i <10; i++){ \n>            System.out.printf(\"%s [%d]:%d\\n\", this.getName(), \n>            \t\t\t\t\tthis.getPriority(), i); \n>            // i整除4时，调用yield\n>            if (i%4 == 0)\n>                Thread.yield();\n>        } \n>    } \n>} \n>\n>public class YieldTest{ \n>    public static void main(String[] args){ \n>        ThreadA t1 = new ThreadA(\"t1\"); \n>        ThreadA t2 = new ThreadA(\"t2\"); \n>        t1.start(); \n>        t2.start();\n>    } \n>}\n>```\n>\n>运行结果：（你的可能和我不相同）\n>\n>```\n>t1 [5]:0\n>t2 [5]:0\n>t1 [5]:1\n>t1 [5]:2\n>t1 [5]:3\n>t1 [5]:4\n>t1 [5]:5\n>t1 [5]:6\n>t1 [5]:7\n>t1 [5]:8\n>t1 [5]:9\n>t2 [5]:1\n>t2 [5]:2\n>t2 [5]:3\n>t2 [5]:4\n>t2 [5]:5\n>t2 [5]:6\n>t2 [5]:7\n>t2 [5]:8\n>t2 [5]:9\n>```\n>\n>**结果说明**： “线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。\n\n###  2. **yield() 与 wait()的比较**\n\n>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是： \n>\n>(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。\n>\n> (02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。\n>\n>下面通过示例演示yield()是不会释放锁的。\n>\n>```\n>// YieldLockTest.java 的源码\n>public class YieldLockTest{ \n>\n>    private static Object obj = new Object();\n>\n>    public static void main(String[] args){ \n>        ThreadA t1 = new ThreadA(\"t1\"); \n>        ThreadA t2 = new ThreadA(\"t2\"); \n>        t1.start(); \n>        t2.start();\n>    } \n>\n>    static class ThreadA extends Thread{\n>        public ThreadA(String name){ \n>            super(name); \n>        } \n>        public void run(){ \n>            // 获取obj对象的同步锁\n>            synchronized (obj) {\n>                for(int i=0; i <10; i++){ \n>                    System.out.printf(\"%s [%d]:%d\\n\", this.getName(), this.getPriority(), i); \n>                    // i整除4时，调用yield\n>                    if (i%4 == 0)\n>                        Thread.yield();\n>                }\n>            }\n>        } \n>    } \n>}\n>```\n>\n>运行结果\n>\n>```\n>t1 [5]:0\n>t1 [5]:1\n>t1 [5]:2\n>t1 [5]:3\n>t1 [5]:4\n>t1 [5]:5\n>t1 [5]:6\n>t1 [5]:7\n>t1 [5]:8\n>t1 [5]:9\n>t2 [5]:0\n>t2 [5]:1\n>t2 [5]:2\n>t2 [5]:3\n>t2 [5]:4\n>t2 [5]:5\n>t2 [5]:6\n>t2 [5]:7\n>t2 [5]:8\n>t2 [5]:9\n>```\n>\n>**结果说明**： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！\n\n### 3. join()介绍及示例\n\n>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解：\n>\n>```\n>// 主线程\n>public class Father extends Thread {\n>    public void run() {\n>        Son s = new Son();\n>        s.start();\n>        s.join();\n>        ...\n>    }\n>}\n>// 子线程\n>public class Son extends Thread {\n>    public void run() {\n>        ...\n>    }\n>}\n>```\n>\n>**说明**：\n>上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。\n>在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！\n>\n>join源码分析\n>\n>````\n>public final void join() throws InterruptedException {\n>    join(0);\n>}\n>\n>public final synchronized void join(long millis)\n>throws InterruptedException {\n>    long base = System.currentTimeMillis();\n>    long now = 0;\n>\n>    if (millis < 0) {\n>        throw new IllegalArgumentException(\"timeout value is negative\");\n>    }\n>\n>    if (millis == 0) {\n>        while (isAlive()) {\n>            wait(0);\n>        }\n>    } else {\n>        while (isAlive()) {\n>            long delay = millis - now;\n>            if (delay <= 0) {\n>                break;\n>            }\n>            wait(delay);\n>            now = System.currentTimeMillis() - base;\n>        }\n>    }\n>}\n>````\n>\n>**说明**： \n>\n>从代码中，我们可以发现。当millis==0时，会进入while(isAlive())循环；\n>\n>即只要子线程是活的，主线程就不停的等待。 我们根据上面解释join()作用时的代码来理解join()的用法！\n>\n> **问题**： 虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让\"子线程等待才对(因为调用子线程对象s的wait方法嘛)\"？ \n>\n>**答案**：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！\n>\n>join示例\n>\n>```\n>// JoinTest.java的源码\n>public class JoinTest{ \n>\n>    public static void main(String[] args){ \n>        try {\n>            ThreadA t1 = new ThreadA(\"t1\"); // 新建“线程t1”\n>\n>            t1.start();                     // 启动“线程t1”\n>            t1.join();                        // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成”\n>            System.out.printf(\"%s finish\\n\", Thread.currentThread().getName()); \n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>    } \n>\n>    static class ThreadA extends Thread{\n>\n>        public ThreadA(String name){ \n>            super(name); \n>        } \n>        public void run(){ \n>            System.out.printf(\"%s start\\n\", this.getName()); \n>\n>            // 延时操作\n>            for(int i=0; i <1000000; i++)\n>               ;\n>\n>            System.out.printf(\"%s finish\\n\", this.getName()); \n>        } \n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 start\n>t1 finish\n>main finish\n>```\n>\n>**结果说明**：\n>运行流程如图 \n>(01) 在“主线程main”中通过 new ThreadA(\"t1\") 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。\n>(02) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。\n>\n>![](https://images0.cnblogs.com/blog/497634/201312/18184312-a72a58e2bda54b17bf669f325ecda377.png)\n>\n>\n>\n>\n\n","source":"_posts/java 多线系列之 04 线程让步和join.md","raw":"abbrlink: 4\ntitle: java多线系列之 04 线程让步和join\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-13 11:09:00\n---\n# java 多线系列之 04 线程让步和join\n\n### 概要\n\n>1.  yield()介绍以及示例\n>2.  yield() 与 wait()的比较\n>3.  join() 介绍及示例\n\n### 1. yield介绍以及示例\n\n>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！\n>\n>下面，通过示例查看它的用法。\n>\n>```\n>// YieldTest.java的源码\n>class ThreadA extends Thread{\n>    public ThreadA(String name){ \n>        super(name); \n>    } \n>    public synchronized void run(){ \n>        for(int i=0; i <10; i++){ \n>            System.out.printf(\"%s [%d]:%d\\n\", this.getName(), \n>            \t\t\t\t\tthis.getPriority(), i); \n>            // i整除4时，调用yield\n>            if (i%4 == 0)\n>                Thread.yield();\n>        } \n>    } \n>} \n>\n>public class YieldTest{ \n>    public static void main(String[] args){ \n>        ThreadA t1 = new ThreadA(\"t1\"); \n>        ThreadA t2 = new ThreadA(\"t2\"); \n>        t1.start(); \n>        t2.start();\n>    } \n>}\n>```\n>\n>运行结果：（你的可能和我不相同）\n>\n>```\n>t1 [5]:0\n>t2 [5]:0\n>t1 [5]:1\n>t1 [5]:2\n>t1 [5]:3\n>t1 [5]:4\n>t1 [5]:5\n>t1 [5]:6\n>t1 [5]:7\n>t1 [5]:8\n>t1 [5]:9\n>t2 [5]:1\n>t2 [5]:2\n>t2 [5]:3\n>t2 [5]:4\n>t2 [5]:5\n>t2 [5]:6\n>t2 [5]:7\n>t2 [5]:8\n>t2 [5]:9\n>```\n>\n>**结果说明**： “线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。\n\n###  2. **yield() 与 wait()的比较**\n\n>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是： \n>\n>(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。\n>\n> (02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。\n>\n>下面通过示例演示yield()是不会释放锁的。\n>\n>```\n>// YieldLockTest.java 的源码\n>public class YieldLockTest{ \n>\n>    private static Object obj = new Object();\n>\n>    public static void main(String[] args){ \n>        ThreadA t1 = new ThreadA(\"t1\"); \n>        ThreadA t2 = new ThreadA(\"t2\"); \n>        t1.start(); \n>        t2.start();\n>    } \n>\n>    static class ThreadA extends Thread{\n>        public ThreadA(String name){ \n>            super(name); \n>        } \n>        public void run(){ \n>            // 获取obj对象的同步锁\n>            synchronized (obj) {\n>                for(int i=0; i <10; i++){ \n>                    System.out.printf(\"%s [%d]:%d\\n\", this.getName(), this.getPriority(), i); \n>                    // i整除4时，调用yield\n>                    if (i%4 == 0)\n>                        Thread.yield();\n>                }\n>            }\n>        } \n>    } \n>}\n>```\n>\n>运行结果\n>\n>```\n>t1 [5]:0\n>t1 [5]:1\n>t1 [5]:2\n>t1 [5]:3\n>t1 [5]:4\n>t1 [5]:5\n>t1 [5]:6\n>t1 [5]:7\n>t1 [5]:8\n>t1 [5]:9\n>t2 [5]:0\n>t2 [5]:1\n>t2 [5]:2\n>t2 [5]:3\n>t2 [5]:4\n>t2 [5]:5\n>t2 [5]:6\n>t2 [5]:7\n>t2 [5]:8\n>t2 [5]:9\n>```\n>\n>**结果说明**： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！\n\n### 3. join()介绍及示例\n\n>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解：\n>\n>```\n>// 主线程\n>public class Father extends Thread {\n>    public void run() {\n>        Son s = new Son();\n>        s.start();\n>        s.join();\n>        ...\n>    }\n>}\n>// 子线程\n>public class Son extends Thread {\n>    public void run() {\n>        ...\n>    }\n>}\n>```\n>\n>**说明**：\n>上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。\n>在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！\n>\n>join源码分析\n>\n>````\n>public final void join() throws InterruptedException {\n>    join(0);\n>}\n>\n>public final synchronized void join(long millis)\n>throws InterruptedException {\n>    long base = System.currentTimeMillis();\n>    long now = 0;\n>\n>    if (millis < 0) {\n>        throw new IllegalArgumentException(\"timeout value is negative\");\n>    }\n>\n>    if (millis == 0) {\n>        while (isAlive()) {\n>            wait(0);\n>        }\n>    } else {\n>        while (isAlive()) {\n>            long delay = millis - now;\n>            if (delay <= 0) {\n>                break;\n>            }\n>            wait(delay);\n>            now = System.currentTimeMillis() - base;\n>        }\n>    }\n>}\n>````\n>\n>**说明**： \n>\n>从代码中，我们可以发现。当millis==0时，会进入while(isAlive())循环；\n>\n>即只要子线程是活的，主线程就不停的等待。 我们根据上面解释join()作用时的代码来理解join()的用法！\n>\n> **问题**： 虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让\"子线程等待才对(因为调用子线程对象s的wait方法嘛)\"？ \n>\n>**答案**：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！\n>\n>join示例\n>\n>```\n>// JoinTest.java的源码\n>public class JoinTest{ \n>\n>    public static void main(String[] args){ \n>        try {\n>            ThreadA t1 = new ThreadA(\"t1\"); // 新建“线程t1”\n>\n>            t1.start();                     // 启动“线程t1”\n>            t1.join();                        // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成”\n>            System.out.printf(\"%s finish\\n\", Thread.currentThread().getName()); \n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>    } \n>\n>    static class ThreadA extends Thread{\n>\n>        public ThreadA(String name){ \n>            super(name); \n>        } \n>        public void run(){ \n>            System.out.printf(\"%s start\\n\", this.getName()); \n>\n>            // 延时操作\n>            for(int i=0; i <1000000; i++)\n>               ;\n>\n>            System.out.printf(\"%s finish\\n\", this.getName()); \n>        } \n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 start\n>t1 finish\n>main finish\n>```\n>\n>**结果说明**：\n>运行流程如图 \n>(01) 在“主线程main”中通过 new ThreadA(\"t1\") 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。\n>(02) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。\n>\n>![](https://images0.cnblogs.com/blog/497634/201312/18184312-a72a58e2bda54b17bf669f325ecda377.png)\n>\n>\n>\n>\n\n","slug":"java 多线系列之 04 线程让步和join","published":1,"updated":"2019-01-04T01:48:59.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx2o0016eb1u85n5h48v","content":"<h1 id=\"java-多线系列之-04-线程让步和join\"><a href=\"#java-多线系列之-04-线程让步和join\" class=\"headerlink\" title=\"java 多线系列之 04 线程让步和join\"></a>java 多线系列之 04 线程让步和join</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>yield()介绍以及示例</li>\n<li>yield() 与 wait()的比较</li>\n<li>join() 介绍及示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-yield介绍以及示例\"><a href=\"#1-yield介绍以及示例\" class=\"headerlink\" title=\"1. yield介绍以及示例\"></a>1. yield介绍以及示例</h3><blockquote>\n<p>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！</p>\n<p>下面，通过示例查看它的用法。</p>\n<pre><code>// YieldTest.java的源码\nclass ThreadA extends Thread{\n   public ThreadA(String name){ \n       super(name); \n   } \n   public synchronized void run(){ \n       for(int i=0; i &lt;10; i++){ \n           System.out.printf(&quot;%s [%d]:%d\\n&quot;, this.getName(), \n                               this.getPriority(), i); \n           // i整除4时，调用yield\n           if (i%4 == 0)\n               Thread.yield();\n       } \n   } \n} \n\npublic class YieldTest{ \n   public static void main(String[] args){ \n       ThreadA t1 = new ThreadA(&quot;t1&quot;); \n       ThreadA t2 = new ThreadA(&quot;t2&quot;); \n       t1.start(); \n       t2.start();\n   } \n}\n</code></pre><p>运行结果：（你的可能和我不相同）</p>\n<pre><code>t1 [5]:0\nt2 [5]:0\nt1 [5]:1\nt1 [5]:2\nt1 [5]:3\nt1 [5]:4\nt1 [5]:5\nt1 [5]:6\nt1 [5]:7\nt1 [5]:8\nt1 [5]:9\nt2 [5]:1\nt2 [5]:2\nt2 [5]:3\nt2 [5]:4\nt2 [5]:5\nt2 [5]:6\nt2 [5]:7\nt2 [5]:8\nt2 [5]:9\n</code></pre><p><strong>结果说明</strong>： “线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。</p>\n</blockquote>\n<h3 id=\"2-yield-与-wait-的比较\"><a href=\"#2-yield-与-wait-的比较\" class=\"headerlink\" title=\"2. yield() 与 wait()的比较\"></a>2. <strong>yield() 与 wait()的比较</strong></h3><blockquote>\n<p>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是： </p>\n<p>(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。</p>\n<p>(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。</p>\n<p>下面通过示例演示yield()是不会释放锁的。</p>\n<pre><code>// YieldLockTest.java 的源码\npublic class YieldLockTest{ \n\n   private static Object obj = new Object();\n\n   public static void main(String[] args){ \n       ThreadA t1 = new ThreadA(&quot;t1&quot;); \n       ThreadA t2 = new ThreadA(&quot;t2&quot;); \n       t1.start(); \n       t2.start();\n   } \n\n   static class ThreadA extends Thread{\n       public ThreadA(String name){ \n           super(name); \n       } \n       public void run(){ \n           // 获取obj对象的同步锁\n           synchronized (obj) {\n               for(int i=0; i &lt;10; i++){ \n                   System.out.printf(&quot;%s [%d]:%d\\n&quot;, this.getName(), this.getPriority(), i); \n                   // i整除4时，调用yield\n                   if (i%4 == 0)\n                       Thread.yield();\n               }\n           }\n       } \n   } \n}\n</code></pre><p>运行结果</p>\n<pre><code>t1 [5]:0\nt1 [5]:1\nt1 [5]:2\nt1 [5]:3\nt1 [5]:4\nt1 [5]:5\nt1 [5]:6\nt1 [5]:7\nt1 [5]:8\nt1 [5]:9\nt2 [5]:0\nt2 [5]:1\nt2 [5]:2\nt2 [5]:3\nt2 [5]:4\nt2 [5]:5\nt2 [5]:6\nt2 [5]:7\nt2 [5]:8\nt2 [5]:9\n</code></pre><p><strong>结果说明</strong>： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！</p>\n</blockquote>\n<h3 id=\"3-join-介绍及示例\"><a href=\"#3-join-介绍及示例\" class=\"headerlink\" title=\"3. join()介绍及示例\"></a>3. join()介绍及示例</h3><blockquote>\n<p>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解：</p>\n<pre><code>// 主线程\npublic class Father extends Thread {\n   public void run() {\n       Son s = new Son();\n       s.start();\n       s.join();\n       ...\n   }\n}\n// 子线程\npublic class Son extends Thread {\n   public void run() {\n       ...\n   }\n}\n</code></pre><p><strong>说明</strong>：<br>上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。<br>在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！</p>\n<p>join源码分析</p>\n<pre><code>public final void join() throws InterruptedException {\n   join(0);\n}\n\npublic final synchronized void join(long millis)\nthrows InterruptedException {\n   long base = System.currentTimeMillis();\n   long now = 0;\n\n   if (millis &lt; 0) {\n       throw new IllegalArgumentException(&quot;timeout value is negative&quot;);\n   }\n\n   if (millis == 0) {\n       while (isAlive()) {\n           wait(0);\n       }\n   } else {\n       while (isAlive()) {\n           long delay = millis - now;\n           if (delay &lt;= 0) {\n               break;\n           }\n           wait(delay);\n           now = System.currentTimeMillis() - base;\n       }\n   }\n}\n</code></pre><p><strong>说明</strong>： </p>\n<p>从代码中，我们可以发现。当millis==0时，会进入while(isAlive())循环；</p>\n<p>即只要子线程是活的，主线程就不停的等待。 我们根据上面解释join()作用时的代码来理解join()的用法！</p>\n<p><strong>问题</strong>： 虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让”子线程等待才对(因为调用子线程对象s的wait方法嘛)”？ </p>\n<p><strong>答案</strong>：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！</p>\n<p>join示例</p>\n<pre><code>// JoinTest.java的源码\npublic class JoinTest{ \n\n   public static void main(String[] args){ \n       try {\n           ThreadA t1 = new ThreadA(&quot;t1&quot;); // 新建“线程t1”\n\n           t1.start();                     // 启动“线程t1”\n           t1.join();                        // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成”\n           System.out.printf(&quot;%s finish\\n&quot;, Thread.currentThread().getName()); \n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n   } \n\n   static class ThreadA extends Thread{\n\n       public ThreadA(String name){ \n           super(name); \n       } \n       public void run(){ \n           System.out.printf(&quot;%s start\\n&quot;, this.getName()); \n\n           // 延时操作\n           for(int i=0; i &lt;1000000; i++)\n              ;\n\n           System.out.printf(&quot;%s finish\\n&quot;, this.getName()); \n       } \n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 start\nt1 finish\nmain finish\n</code></pre><p><strong>结果说明</strong>：<br>运行流程如图<br>(01) 在“主线程main”中通过 new ThreadA(“t1”) 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。<br>(02) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18184312-a72a58e2bda54b17bf669f325ecda377.png\" alt=\"\"></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java-多线系列之-04-线程让步和join\"><a href=\"#java-多线系列之-04-线程让步和join\" class=\"headerlink\" title=\"java 多线系列之 04 线程让步和join\"></a>java 多线系列之 04 线程让步和join</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>yield()介绍以及示例</li>\n<li>yield() 与 wait()的比较</li>\n<li>join() 介绍及示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-yield介绍以及示例\"><a href=\"#1-yield介绍以及示例\" class=\"headerlink\" title=\"1. yield介绍以及示例\"></a>1. yield介绍以及示例</h3><blockquote>\n<p>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！</p>\n<p>下面，通过示例查看它的用法。</p>\n<pre><code>// YieldTest.java的源码\nclass ThreadA extends Thread{\n   public ThreadA(String name){ \n       super(name); \n   } \n   public synchronized void run(){ \n       for(int i=0; i &lt;10; i++){ \n           System.out.printf(&quot;%s [%d]:%d\\n&quot;, this.getName(), \n                               this.getPriority(), i); \n           // i整除4时，调用yield\n           if (i%4 == 0)\n               Thread.yield();\n       } \n   } \n} \n\npublic class YieldTest{ \n   public static void main(String[] args){ \n       ThreadA t1 = new ThreadA(&quot;t1&quot;); \n       ThreadA t2 = new ThreadA(&quot;t2&quot;); \n       t1.start(); \n       t2.start();\n   } \n}\n</code></pre><p>运行结果：（你的可能和我不相同）</p>\n<pre><code>t1 [5]:0\nt2 [5]:0\nt1 [5]:1\nt1 [5]:2\nt1 [5]:3\nt1 [5]:4\nt1 [5]:5\nt1 [5]:6\nt1 [5]:7\nt1 [5]:8\nt1 [5]:9\nt2 [5]:1\nt2 [5]:2\nt2 [5]:3\nt2 [5]:4\nt2 [5]:5\nt2 [5]:6\nt2 [5]:7\nt2 [5]:8\nt2 [5]:9\n</code></pre><p><strong>结果说明</strong>： “线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。</p>\n</blockquote>\n<h3 id=\"2-yield-与-wait-的比较\"><a href=\"#2-yield-与-wait-的比较\" class=\"headerlink\" title=\"2. yield() 与 wait()的比较\"></a>2. <strong>yield() 与 wait()的比较</strong></h3><blockquote>\n<p>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是： </p>\n<p>(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。</p>\n<p>(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。</p>\n<p>下面通过示例演示yield()是不会释放锁的。</p>\n<pre><code>// YieldLockTest.java 的源码\npublic class YieldLockTest{ \n\n   private static Object obj = new Object();\n\n   public static void main(String[] args){ \n       ThreadA t1 = new ThreadA(&quot;t1&quot;); \n       ThreadA t2 = new ThreadA(&quot;t2&quot;); \n       t1.start(); \n       t2.start();\n   } \n\n   static class ThreadA extends Thread{\n       public ThreadA(String name){ \n           super(name); \n       } \n       public void run(){ \n           // 获取obj对象的同步锁\n           synchronized (obj) {\n               for(int i=0; i &lt;10; i++){ \n                   System.out.printf(&quot;%s [%d]:%d\\n&quot;, this.getName(), this.getPriority(), i); \n                   // i整除4时，调用yield\n                   if (i%4 == 0)\n                       Thread.yield();\n               }\n           }\n       } \n   } \n}\n</code></pre><p>运行结果</p>\n<pre><code>t1 [5]:0\nt1 [5]:1\nt1 [5]:2\nt1 [5]:3\nt1 [5]:4\nt1 [5]:5\nt1 [5]:6\nt1 [5]:7\nt1 [5]:8\nt1 [5]:9\nt2 [5]:0\nt2 [5]:1\nt2 [5]:2\nt2 [5]:3\nt2 [5]:4\nt2 [5]:5\nt2 [5]:6\nt2 [5]:7\nt2 [5]:8\nt2 [5]:9\n</code></pre><p><strong>结果说明</strong>： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！</p>\n</blockquote>\n<h3 id=\"3-join-介绍及示例\"><a href=\"#3-join-介绍及示例\" class=\"headerlink\" title=\"3. join()介绍及示例\"></a>3. join()介绍及示例</h3><blockquote>\n<p>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解：</p>\n<pre><code>// 主线程\npublic class Father extends Thread {\n   public void run() {\n       Son s = new Son();\n       s.start();\n       s.join();\n       ...\n   }\n}\n// 子线程\npublic class Son extends Thread {\n   public void run() {\n       ...\n   }\n}\n</code></pre><p><strong>说明</strong>：<br>上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。<br>在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！</p>\n<p>join源码分析</p>\n<pre><code>public final void join() throws InterruptedException {\n   join(0);\n}\n\npublic final synchronized void join(long millis)\nthrows InterruptedException {\n   long base = System.currentTimeMillis();\n   long now = 0;\n\n   if (millis &lt; 0) {\n       throw new IllegalArgumentException(&quot;timeout value is negative&quot;);\n   }\n\n   if (millis == 0) {\n       while (isAlive()) {\n           wait(0);\n       }\n   } else {\n       while (isAlive()) {\n           long delay = millis - now;\n           if (delay &lt;= 0) {\n               break;\n           }\n           wait(delay);\n           now = System.currentTimeMillis() - base;\n       }\n   }\n}\n</code></pre><p><strong>说明</strong>： </p>\n<p>从代码中，我们可以发现。当millis==0时，会进入while(isAlive())循环；</p>\n<p>即只要子线程是活的，主线程就不停的等待。 我们根据上面解释join()作用时的代码来理解join()的用法！</p>\n<p><strong>问题</strong>： 虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让”子线程等待才对(因为调用子线程对象s的wait方法嘛)”？ </p>\n<p><strong>答案</strong>：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！</p>\n<p>join示例</p>\n<pre><code>// JoinTest.java的源码\npublic class JoinTest{ \n\n   public static void main(String[] args){ \n       try {\n           ThreadA t1 = new ThreadA(&quot;t1&quot;); // 新建“线程t1”\n\n           t1.start();                     // 启动“线程t1”\n           t1.join();                        // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成”\n           System.out.printf(&quot;%s finish\\n&quot;, Thread.currentThread().getName()); \n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n   } \n\n   static class ThreadA extends Thread{\n\n       public ThreadA(String name){ \n           super(name); \n       } \n       public void run(){ \n           System.out.printf(&quot;%s start\\n&quot;, this.getName()); \n\n           // 延时操作\n           for(int i=0; i &lt;1000000; i++)\n              ;\n\n           System.out.printf(&quot;%s finish\\n&quot;, this.getName()); \n       } \n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 start\nt1 finish\nmain finish\n</code></pre><p><strong>结果说明</strong>：<br>运行流程如图<br>(01) 在“主线程main”中通过 new ThreadA(“t1”) 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。<br>(02) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18184312-a72a58e2bda54b17bf669f325ecda377.png\" alt=\"\"></p>\n</blockquote>\n"},{"title":"String、StringBuffer和StringBuilder对比","author":"zhangke","abbrlink":10143,"date":"2019-01-02T05:24:00.000Z","_content":"---\n# String、StringBuffer和StringBuilder对比\n\n### 概述\n\n1. 简单介绍\n2. 性能对比\n3. 字符串常量池\n<!-- more -->\n\n### 1. 简单介绍\n\n这里只对这三个类做个简单的总结，如果你希望详细了解这三个类，可以看一下三篇文章，我觉得写得很好。\n\n1.  [String 详解(String系列之1)](https://www.cnblogs.com/skywang12345/p/string01.html)\n2.  [StringBuilder 详解 (String系列之2)](http://www.cnblogs.com/skywang12345/p/string02.html)\n3.  [StringBuffer 详解 (String系列之3)](http://www.cnblogs.com/skywang12345/p/string03.html)\n\n首先一个简单的对比\n\n**String 字符串常量**\n\n**StringBuffer 字符串变量（线程安全）**\n\n**StringBuilder 字符串变量（非线程安全）**\n\nStringBuffer与StringBuilder的实现几乎是一样的，只是StringBufferr为了保证线程安全，在方法前面加上Synchronize关键字来保证安全性，因此下面先用StringBuffer来和String进行对比\n\nString 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。\n 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：\n\n```java\n String S1 = “This is only a” + “ simple” + “ test”;\n StringBuffer Sb = new StringBuffer(“This is only a”).append(“ simple”).append(“ test”);\n```\n\n测试结果：\n\n```\n\nBenchmark                         Mode  Cnt   Score    Error  Units\nStringBenchmark.testString        avgt    3   5.701 ±  2.431  ns/op\nStringBenchmark.testStringBuffer  avgt    3  27.077 ± 21.828  ns/op\n```\n\n**其中score对应是每次操作花费的纳秒说**\n\n 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个\n**String S1 = “This is only a” + “ simple” + “test”; **其实就是：\n** String S1 = “This is only a simple test”**; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：\n\n```\nString S2 = “This is only a”;\nString S3 = “ simple”;\nString S4 = “ test”;\nString S1 = S2 +S3 + S4;\n```\n\n这时候 JVM 会规规矩矩的按照原来的方式去做\n在大部分情况下 StringBuffer的性能要好于 String\n**StringBuffer**\nJava.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。\n例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(\"le\") 会使字符串缓冲区包含“startle”，而 z.insert(4, \"le\") 将更改字符串缓冲区，使之包含“starlet”。\n在大部分情况下 StringBuilder > StringBuffer\n\n**StringBuilder**\njava.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。\n\n### 2. 性能对比\n\n测试性能源码(使用了JMH来进行基准测试)\n\n```\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 3)\n@Measurement(iterations = 3, time = 3)\n@Threads(1)\n@Fork(1)\n@State(Scope.Thread)\npublic class StringBenchmark {\n\n    String s1;\n\n    StringBuffer stringBuffer;\n\n    StringBuilder stringBuilder;\n\n\n    @Setup(Level.Iteration)\n    public void before() {\n        s1 = \"s1\";\n        stringBuffer = new StringBuffer(\"s1\");\n        stringBuilder = new StringBuilder(\"s1\");\n\n    }\n\n\n    @TearDown\n    public void after() {\n\n    }\n\n\n    @Benchmark\n    public String testStringAppend() {\n\n        return s1 += \"s2\";\n    }\n\n\n    @Benchmark\n    public StringBuffer testStringBufferAppend() {\n\n        return stringBuffer.append(\"s2\");\n\n    }\n\n\n    @Benchmark\n    public StringBuilder testStringBuilderAppend() {\n        //下面这个还会单独生成一个String对象，因此性能上有所损失，所以调整一下\n//        return new StringBuilder(\"s1\").append(\"s2\").toString();\n\n        return stringBuilder.append(\"s2\");\n    }\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(StringBenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n```\n\n测试结果\n\n```\nBenchmark                                Mode  Cnt      Score       Error  Units\nStringBenchmark.testStringAppend         avgt    3  28179.211 ± 25587.942  ns/op\nStringBenchmark.testStringBufferAppend   avgt    3     26.152 ±   189.157  ns/op\nStringBenchmark.testStringBuilderAppend  avgt    3     21.150 ±    48.648  ns/op\n```\n\n从结果可以验证，在上面简单介绍中所说的，如果字符串拼接操作，最好选择StringBuilder，如果要保证线程安全选择StringBuffer，另外上面结果有一点需要注意的是，从测试结果看，StringBuffer和StringBuilder的性能差不多，这是因为我是在jdk8上运行的，JVM在运行时，因为只有一个线程，因此对Synchronize做了优化，使得StringBuffer性能得到提升。\n\n### 3. 字符串常量池\n\n我觉得这篇文章已经写得非常好因此可以看这篇文章\n\n[String：字符串常量池](https://segmentfault.com/a/1190000009888357)\n\n但是我对这个持有疑问\n\n**String str2 = new String(\"ABC\") + \"ABC\" ; 会创建多少个对象?**\n\nstr2 ：\n字符串常量池：\"ABC\" : 1个\n堆：new String(\"ABC\") ：1个\n引用： str2 ：1个\n总共 ： 3个\n\n我认为结果是这样的：\n\n字符串常量池 “ABC” 1个\n\n堆：new String(\"ABC\"),new String(\"ABCABC\"),new StringBuilder()\n\nNew String(\"ABCABC\") 是由于new String(\"ABC\") +\"ABC\"在编译的时候会按照下面这种方式来生成\n\n```java\nStringBuilder  stringBuilder = new StringBuilder();\nstringBuilder.append(\"ABC\");\nstringBuilder.append(\"ABC);\nstringBuilder.toString();// 这时就会产生 new String(\"ABCABC)\n```\n\n另外由于这个是使用new String(\"ABC\") + \"ABC\"，因此ABCABC不会进入常量池，除非调用String.intern()方法\n\n不知道对不对，欢迎大家讨论\n\n### 参考\n\n1.  [String,StringBuffer与StringBuilder的区别|线程安全与线程不安全](https://www.cnblogs.com/xingzc/p/6277581.html)\n2. [字面量和常量池初探](https://mccxj.github.io/blog/20130615_java-string-constant-pool.html) 基于java1.6","source":"_posts/String、StringBuffer和StringBuilder对比.md","raw":"---\ntitle: String、StringBuffer和StringBuilder对比\ntags:\n  - java\n  - java基础\n  - String\ncategories:\n  - java\nauthor: zhangke\nabbrlink: 10143\ndate: 2019-01-02 13:24:00\n---\n---\n# String、StringBuffer和StringBuilder对比\n\n### 概述\n\n1. 简单介绍\n2. 性能对比\n3. 字符串常量池\n<!-- more -->\n\n### 1. 简单介绍\n\n这里只对这三个类做个简单的总结，如果你希望详细了解这三个类，可以看一下三篇文章，我觉得写得很好。\n\n1.  [String 详解(String系列之1)](https://www.cnblogs.com/skywang12345/p/string01.html)\n2.  [StringBuilder 详解 (String系列之2)](http://www.cnblogs.com/skywang12345/p/string02.html)\n3.  [StringBuffer 详解 (String系列之3)](http://www.cnblogs.com/skywang12345/p/string03.html)\n\n首先一个简单的对比\n\n**String 字符串常量**\n\n**StringBuffer 字符串变量（线程安全）**\n\n**StringBuilder 字符串变量（非线程安全）**\n\nStringBuffer与StringBuilder的实现几乎是一样的，只是StringBufferr为了保证线程安全，在方法前面加上Synchronize关键字来保证安全性，因此下面先用StringBuffer来和String进行对比\n\nString 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。\n 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：\n\n```java\n String S1 = “This is only a” + “ simple” + “ test”;\n StringBuffer Sb = new StringBuffer(“This is only a”).append(“ simple”).append(“ test”);\n```\n\n测试结果：\n\n```\n\nBenchmark                         Mode  Cnt   Score    Error  Units\nStringBenchmark.testString        avgt    3   5.701 ±  2.431  ns/op\nStringBenchmark.testStringBuffer  avgt    3  27.077 ± 21.828  ns/op\n```\n\n**其中score对应是每次操作花费的纳秒说**\n\n 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个\n**String S1 = “This is only a” + “ simple” + “test”; **其实就是：\n** String S1 = “This is only a simple test”**; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：\n\n```\nString S2 = “This is only a”;\nString S3 = “ simple”;\nString S4 = “ test”;\nString S1 = S2 +S3 + S4;\n```\n\n这时候 JVM 会规规矩矩的按照原来的方式去做\n在大部分情况下 StringBuffer的性能要好于 String\n**StringBuffer**\nJava.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。\n例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(\"le\") 会使字符串缓冲区包含“startle”，而 z.insert(4, \"le\") 将更改字符串缓冲区，使之包含“starlet”。\n在大部分情况下 StringBuilder > StringBuffer\n\n**StringBuilder**\njava.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。\n\n### 2. 性能对比\n\n测试性能源码(使用了JMH来进行基准测试)\n\n```\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 3)\n@Measurement(iterations = 3, time = 3)\n@Threads(1)\n@Fork(1)\n@State(Scope.Thread)\npublic class StringBenchmark {\n\n    String s1;\n\n    StringBuffer stringBuffer;\n\n    StringBuilder stringBuilder;\n\n\n    @Setup(Level.Iteration)\n    public void before() {\n        s1 = \"s1\";\n        stringBuffer = new StringBuffer(\"s1\");\n        stringBuilder = new StringBuilder(\"s1\");\n\n    }\n\n\n    @TearDown\n    public void after() {\n\n    }\n\n\n    @Benchmark\n    public String testStringAppend() {\n\n        return s1 += \"s2\";\n    }\n\n\n    @Benchmark\n    public StringBuffer testStringBufferAppend() {\n\n        return stringBuffer.append(\"s2\");\n\n    }\n\n\n    @Benchmark\n    public StringBuilder testStringBuilderAppend() {\n        //下面这个还会单独生成一个String对象，因此性能上有所损失，所以调整一下\n//        return new StringBuilder(\"s1\").append(\"s2\").toString();\n\n        return stringBuilder.append(\"s2\");\n    }\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(StringBenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n```\n\n测试结果\n\n```\nBenchmark                                Mode  Cnt      Score       Error  Units\nStringBenchmark.testStringAppend         avgt    3  28179.211 ± 25587.942  ns/op\nStringBenchmark.testStringBufferAppend   avgt    3     26.152 ±   189.157  ns/op\nStringBenchmark.testStringBuilderAppend  avgt    3     21.150 ±    48.648  ns/op\n```\n\n从结果可以验证，在上面简单介绍中所说的，如果字符串拼接操作，最好选择StringBuilder，如果要保证线程安全选择StringBuffer，另外上面结果有一点需要注意的是，从测试结果看，StringBuffer和StringBuilder的性能差不多，这是因为我是在jdk8上运行的，JVM在运行时，因为只有一个线程，因此对Synchronize做了优化，使得StringBuffer性能得到提升。\n\n### 3. 字符串常量池\n\n我觉得这篇文章已经写得非常好因此可以看这篇文章\n\n[String：字符串常量池](https://segmentfault.com/a/1190000009888357)\n\n但是我对这个持有疑问\n\n**String str2 = new String(\"ABC\") + \"ABC\" ; 会创建多少个对象?**\n\nstr2 ：\n字符串常量池：\"ABC\" : 1个\n堆：new String(\"ABC\") ：1个\n引用： str2 ：1个\n总共 ： 3个\n\n我认为结果是这样的：\n\n字符串常量池 “ABC” 1个\n\n堆：new String(\"ABC\"),new String(\"ABCABC\"),new StringBuilder()\n\nNew String(\"ABCABC\") 是由于new String(\"ABC\") +\"ABC\"在编译的时候会按照下面这种方式来生成\n\n```java\nStringBuilder  stringBuilder = new StringBuilder();\nstringBuilder.append(\"ABC\");\nstringBuilder.append(\"ABC);\nstringBuilder.toString();// 这时就会产生 new String(\"ABCABC)\n```\n\n另外由于这个是使用new String(\"ABC\") + \"ABC\"，因此ABCABC不会进入常量池，除非调用String.intern()方法\n\n不知道对不对，欢迎大家讨论\n\n### 参考\n\n1.  [String,StringBuffer与StringBuilder的区别|线程安全与线程不安全](https://www.cnblogs.com/xingzc/p/6277581.html)\n2. [字面量和常量池初探](https://mccxj.github.io/blog/20130615_java-string-constant-pool.html) 基于java1.6","slug":"String、StringBuffer和StringBuilder对比","published":1,"updated":"2019-01-02T05:50:19.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx2p0019eb1unry36yac","content":"<hr>\n<h1 id=\"String、StringBuffer和StringBuilder对比\"><a href=\"#String、StringBuffer和StringBuilder对比\" class=\"headerlink\" title=\"String、StringBuffer和StringBuilder对比\"></a>String、StringBuffer和StringBuilder对比</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>简单介绍</li>\n<li>性能对比</li>\n<li>字符串常量池<a id=\"more\"></a>\n</li>\n</ol>\n<h3 id=\"1-简单介绍\"><a href=\"#1-简单介绍\" class=\"headerlink\" title=\"1. 简单介绍\"></a>1. 简单介绍</h3><p>这里只对这三个类做个简单的总结，如果你希望详细了解这三个类，可以看一下三篇文章，我觉得写得很好。</p>\n<ol>\n<li><a href=\"https://www.cnblogs.com/skywang12345/p/string01.html\" target=\"_blank\" rel=\"noopener\">String 详解(String系列之1)</a></li>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/string02.html\" target=\"_blank\" rel=\"noopener\">StringBuilder 详解 (String系列之2)</a></li>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/string03.html\" target=\"_blank\" rel=\"noopener\">StringBuffer 详解 (String系列之3)</a></li>\n</ol>\n<p>首先一个简单的对比</p>\n<p><strong>String 字符串常量</strong></p>\n<p><strong>StringBuffer 字符串变量（线程安全）</strong></p>\n<p><strong>StringBuilder 字符串变量（非线程安全）</strong></p>\n<p>StringBuffer与StringBuilder的实现几乎是一样的，只是StringBufferr为了保证线程安全，在方法前面加上Synchronize关键字来保证安全性，因此下面先用StringBuffer来和String进行对比</p>\n<p>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。<br> 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>\n<pre><code class=\"java\"> String S1 = “This is only a” + “ simple” + “ test”;\n StringBuffer Sb = new StringBuffer(“This is only a”).append(“ simple”).append(“ test”);\n</code></pre>\n<p>测试结果：</p>\n<pre><code>\nBenchmark                         Mode  Cnt   Score    Error  Units\nStringBenchmark.testString        avgt    3   5.701 ±  2.431  ns/op\nStringBenchmark.testStringBuffer  avgt    3  27.077 ± 21.828  ns/op\n</code></pre><p><strong>其中score对应是每次操作花费的纳秒说</strong></p>\n<p> 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个<br><strong>String S1 = “This is only a” + “ simple” + “test”; </strong>其实就是：<br><strong> String S1 = “This is only a simple test”</strong>; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：</p>\n<pre><code>String S2 = “This is only a”;\nString S3 = “ simple”;\nString S4 = “ test”;\nString S1 = S2 +S3 + S4;\n</code></pre><p>这时候 JVM 会规规矩矩的按照原来的方式去做<br>在大部分情况下 StringBuffer的性能要好于 String<br><strong>StringBuffer</strong><br>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。<br>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。<br>在大部分情况下 StringBuilder &gt; StringBuffer</p>\n<p><strong>StringBuilder</strong><br>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>\n<h3 id=\"2-性能对比\"><a href=\"#2-性能对比\" class=\"headerlink\" title=\"2. 性能对比\"></a>2. 性能对比</h3><p>测试性能源码(使用了JMH来进行基准测试)</p>\n<pre><code>@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 3)\n@Measurement(iterations = 3, time = 3)\n@Threads(1)\n@Fork(1)\n@State(Scope.Thread)\npublic class StringBenchmark {\n\n    String s1;\n\n    StringBuffer stringBuffer;\n\n    StringBuilder stringBuilder;\n\n\n    @Setup(Level.Iteration)\n    public void before() {\n        s1 = &quot;s1&quot;;\n        stringBuffer = new StringBuffer(&quot;s1&quot;);\n        stringBuilder = new StringBuilder(&quot;s1&quot;);\n\n    }\n\n\n    @TearDown\n    public void after() {\n\n    }\n\n\n    @Benchmark\n    public String testStringAppend() {\n\n        return s1 += &quot;s2&quot;;\n    }\n\n\n    @Benchmark\n    public StringBuffer testStringBufferAppend() {\n\n        return stringBuffer.append(&quot;s2&quot;);\n\n    }\n\n\n    @Benchmark\n    public StringBuilder testStringBuilderAppend() {\n        //下面这个还会单独生成一个String对象，因此性能上有所损失，所以调整一下\n//        return new StringBuilder(&quot;s1&quot;).append(&quot;s2&quot;).toString();\n\n        return stringBuilder.append(&quot;s2&quot;);\n    }\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(StringBenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n</code></pre><p>测试结果</p>\n<pre><code>Benchmark                                Mode  Cnt      Score       Error  Units\nStringBenchmark.testStringAppend         avgt    3  28179.211 ± 25587.942  ns/op\nStringBenchmark.testStringBufferAppend   avgt    3     26.152 ±   189.157  ns/op\nStringBenchmark.testStringBuilderAppend  avgt    3     21.150 ±    48.648  ns/op\n</code></pre><p>从结果可以验证，在上面简单介绍中所说的，如果字符串拼接操作，最好选择StringBuilder，如果要保证线程安全选择StringBuffer，另外上面结果有一点需要注意的是，从测试结果看，StringBuffer和StringBuilder的性能差不多，这是因为我是在jdk8上运行的，JVM在运行时，因为只有一个线程，因此对Synchronize做了优化，使得StringBuffer性能得到提升。</p>\n<h3 id=\"3-字符串常量池\"><a href=\"#3-字符串常量池\" class=\"headerlink\" title=\"3. 字符串常量池\"></a>3. 字符串常量池</h3><p>我觉得这篇文章已经写得非常好因此可以看这篇文章</p>\n<p><a href=\"https://segmentfault.com/a/1190000009888357\" target=\"_blank\" rel=\"noopener\">String：字符串常量池</a></p>\n<p>但是我对这个持有疑问</p>\n<p><strong>String str2 = new String(“ABC”) + “ABC” ; 会创建多少个对象?</strong></p>\n<p>str2 ：<br>字符串常量池：”ABC” : 1个<br>堆：new String(“ABC”) ：1个<br>引用： str2 ：1个<br>总共 ： 3个</p>\n<p>我认为结果是这样的：</p>\n<p>字符串常量池 “ABC” 1个</p>\n<p>堆：new String(“ABC”),new String(“ABCABC”),new StringBuilder()</p>\n<p>New String(“ABCABC”) 是由于new String(“ABC”) +”ABC”在编译的时候会按照下面这种方式来生成</p>\n<pre><code class=\"java\">StringBuilder  stringBuilder = new StringBuilder();\nstringBuilder.append(&quot;ABC&quot;);\nstringBuilder.append(&quot;ABC);\nstringBuilder.toString();// 这时就会产生 new String(&quot;ABCABC)\n</code></pre>\n<p>另外由于这个是使用new String(“ABC”) + “ABC”，因此ABCABC不会进入常量池，除非调用String.intern()方法</p>\n<p>不知道对不对，欢迎大家讨论</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://www.cnblogs.com/xingzc/p/6277581.html\" target=\"_blank\" rel=\"noopener\">String,StringBuffer与StringBuilder的区别|线程安全与线程不安全</a></li>\n<li><a href=\"https://mccxj.github.io/blog/20130615_java-string-constant-pool.html\" target=\"_blank\" rel=\"noopener\">字面量和常量池初探</a> 基于java1.6</li>\n</ol>\n","site":{"data":{}},"excerpt":"<hr>\n<h1 id=\"String、StringBuffer和StringBuilder对比\"><a href=\"#String、StringBuffer和StringBuilder对比\" class=\"headerlink\" title=\"String、StringBuffer和StringBuilder对比\"></a>String、StringBuffer和StringBuilder对比</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>简单介绍</li>\n<li>性能对比</li>\n<li>字符串常量池","more":"</li>\n</ol>\n<h3 id=\"1-简单介绍\"><a href=\"#1-简单介绍\" class=\"headerlink\" title=\"1. 简单介绍\"></a>1. 简单介绍</h3><p>这里只对这三个类做个简单的总结，如果你希望详细了解这三个类，可以看一下三篇文章，我觉得写得很好。</p>\n<ol>\n<li><a href=\"https://www.cnblogs.com/skywang12345/p/string01.html\" target=\"_blank\" rel=\"noopener\">String 详解(String系列之1)</a></li>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/string02.html\" target=\"_blank\" rel=\"noopener\">StringBuilder 详解 (String系列之2)</a></li>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/string03.html\" target=\"_blank\" rel=\"noopener\">StringBuffer 详解 (String系列之3)</a></li>\n</ol>\n<p>首先一个简单的对比</p>\n<p><strong>String 字符串常量</strong></p>\n<p><strong>StringBuffer 字符串变量（线程安全）</strong></p>\n<p><strong>StringBuilder 字符串变量（非线程安全）</strong></p>\n<p>StringBuffer与StringBuilder的实现几乎是一样的，只是StringBufferr为了保证线程安全，在方法前面加上Synchronize关键字来保证安全性，因此下面先用StringBuffer来和String进行对比</p>\n<p>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。<br> 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>\n<pre><code class=\"java\"> String S1 = “This is only a” + “ simple” + “ test”;\n StringBuffer Sb = new StringBuffer(“This is only a”).append(“ simple”).append(“ test”);\n</code></pre>\n<p>测试结果：</p>\n<pre><code>\nBenchmark                         Mode  Cnt   Score    Error  Units\nStringBenchmark.testString        avgt    3   5.701 ±  2.431  ns/op\nStringBenchmark.testStringBuffer  avgt    3  27.077 ± 21.828  ns/op\n</code></pre><p><strong>其中score对应是每次操作花费的纳秒说</strong></p>\n<p> 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个<br><strong>String S1 = “This is only a” + “ simple” + “test”; </strong>其实就是：<br><strong> String S1 = “This is only a simple test”</strong>; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：</p>\n<pre><code>String S2 = “This is only a”;\nString S3 = “ simple”;\nString S4 = “ test”;\nString S1 = S2 +S3 + S4;\n</code></pre><p>这时候 JVM 会规规矩矩的按照原来的方式去做<br>在大部分情况下 StringBuffer的性能要好于 String<br><strong>StringBuffer</strong><br>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。<br>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。<br>在大部分情况下 StringBuilder &gt; StringBuffer</p>\n<p><strong>StringBuilder</strong><br>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>\n<h3 id=\"2-性能对比\"><a href=\"#2-性能对比\" class=\"headerlink\" title=\"2. 性能对比\"></a>2. 性能对比</h3><p>测试性能源码(使用了JMH来进行基准测试)</p>\n<pre><code>@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 3)\n@Measurement(iterations = 3, time = 3)\n@Threads(1)\n@Fork(1)\n@State(Scope.Thread)\npublic class StringBenchmark {\n\n    String s1;\n\n    StringBuffer stringBuffer;\n\n    StringBuilder stringBuilder;\n\n\n    @Setup(Level.Iteration)\n    public void before() {\n        s1 = &quot;s1&quot;;\n        stringBuffer = new StringBuffer(&quot;s1&quot;);\n        stringBuilder = new StringBuilder(&quot;s1&quot;);\n\n    }\n\n\n    @TearDown\n    public void after() {\n\n    }\n\n\n    @Benchmark\n    public String testStringAppend() {\n\n        return s1 += &quot;s2&quot;;\n    }\n\n\n    @Benchmark\n    public StringBuffer testStringBufferAppend() {\n\n        return stringBuffer.append(&quot;s2&quot;);\n\n    }\n\n\n    @Benchmark\n    public StringBuilder testStringBuilderAppend() {\n        //下面这个还会单独生成一个String对象，因此性能上有所损失，所以调整一下\n//        return new StringBuilder(&quot;s1&quot;).append(&quot;s2&quot;).toString();\n\n        return stringBuilder.append(&quot;s2&quot;);\n    }\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(StringBenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n</code></pre><p>测试结果</p>\n<pre><code>Benchmark                                Mode  Cnt      Score       Error  Units\nStringBenchmark.testStringAppend         avgt    3  28179.211 ± 25587.942  ns/op\nStringBenchmark.testStringBufferAppend   avgt    3     26.152 ±   189.157  ns/op\nStringBenchmark.testStringBuilderAppend  avgt    3     21.150 ±    48.648  ns/op\n</code></pre><p>从结果可以验证，在上面简单介绍中所说的，如果字符串拼接操作，最好选择StringBuilder，如果要保证线程安全选择StringBuffer，另外上面结果有一点需要注意的是，从测试结果看，StringBuffer和StringBuilder的性能差不多，这是因为我是在jdk8上运行的，JVM在运行时，因为只有一个线程，因此对Synchronize做了优化，使得StringBuffer性能得到提升。</p>\n<h3 id=\"3-字符串常量池\"><a href=\"#3-字符串常量池\" class=\"headerlink\" title=\"3. 字符串常量池\"></a>3. 字符串常量池</h3><p>我觉得这篇文章已经写得非常好因此可以看这篇文章</p>\n<p><a href=\"https://segmentfault.com/a/1190000009888357\" target=\"_blank\" rel=\"noopener\">String：字符串常量池</a></p>\n<p>但是我对这个持有疑问</p>\n<p><strong>String str2 = new String(“ABC”) + “ABC” ; 会创建多少个对象?</strong></p>\n<p>str2 ：<br>字符串常量池：”ABC” : 1个<br>堆：new String(“ABC”) ：1个<br>引用： str2 ：1个<br>总共 ： 3个</p>\n<p>我认为结果是这样的：</p>\n<p>字符串常量池 “ABC” 1个</p>\n<p>堆：new String(“ABC”),new String(“ABCABC”),new StringBuilder()</p>\n<p>New String(“ABCABC”) 是由于new String(“ABC”) +”ABC”在编译的时候会按照下面这种方式来生成</p>\n<pre><code class=\"java\">StringBuilder  stringBuilder = new StringBuilder();\nstringBuilder.append(&quot;ABC&quot;);\nstringBuilder.append(&quot;ABC);\nstringBuilder.toString();// 这时就会产生 new String(&quot;ABCABC)\n</code></pre>\n<p>另外由于这个是使用new String(“ABC”) + “ABC”，因此ABCABC不会进入常量池，除非调用String.intern()方法</p>\n<p>不知道对不对，欢迎大家讨论</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://www.cnblogs.com/xingzc/p/6277581.html\" target=\"_blank\" rel=\"noopener\">String,StringBuffer与StringBuilder的区别|线程安全与线程不安全</a></li>\n<li><a href=\"https://mccxj.github.io/blog/20130615_java-string-constant-pool.html\" target=\"_blank\" rel=\"noopener\">字面量和常量池初探</a> 基于java1.6</li>\n</ol>"},{"abbrlink":7,"title":"java多线程系列 07 ThreadGroup","author":"zhangke","date":"2018-07-13T07:27:00.000Z","_content":"# java多线程系列之07 ThreadGroup\n\n### 概要\n\n>1. ThreadGroup 介绍\n>2. 基本API的使用与介绍\n\n### 1. ThreadGroup 介绍\n\n> 在java的多线程处理中有线程组ThreadGroup的概念，ThreadGroup是为了方便线程管理出现了，可以统一设定线程组的一些属性，比如setDaemon，设置未处理异常的处理方法，设置统一的安全策略等等；也可以通过线程组方便的获得线程的一些信息。\n>\n> 每一个ThreadGroup都可以包含一组的子线程和一组子线程组，在一个进程中线程组是以树形的方式存在，通常情况下根线程组是system线程组。system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。\n\n### 2. 基本API介绍\n\n>```\n>// 构造函数 \n>ThreadGroup(String name)  \n>ThreadGroup(ThreadGroup parent, String name)\n>\n>// 基本API\n>int\tactiveCount()  //返回一个预估的当前TreadGroup和子group中存活线程的数量\n>int\tactiveGroupCount() //返回一个预估的当前TreadGroup所包含的group中存活ThreadGroup的数量\n>void\tcheckAccess() //判断当前运行的线程是否有权限修改此group\n>void\tdestroy()   //销毁当前group和子group\n>int\tenumerate(Thread[] list) //拷贝当前group和子group中的没有dead的线程\n>int\tenumerate(Thread[] list,boolean recurs)//和上一个的区别就是是否需要拷贝子group中的线程\n>int\tenumerate(ThreadGroup[] list)  //拷贝当前group和子group中ThreadGroup\n>int\tenumerate(ThreadGroup[] list, boolean recurse) //是否需要子Group\n>String\tgetName()\n>ThreadGroup\tgetParent()\n>void\tinterrupt()  //设置当前ThreadGroup中所有的线程中断标记为true\n>boolean\tisDaemon()\n>boolean\tisDestroyed()  //判断当前group是否被销毁\n>void\tlist() //打印当前group中的信息去标准输入流\n>boolean\tparentOf(ThreadGroup g)\n>void\tsetDaemon(boolean daemon)  //改变当前group中的线程为daemon线程\n>void\tsetMaxPriority(int pri)  //设置当前group的权限最大值\n>int\t    getMaxPriority() //返回当前ThreadGroup的最大权限\n>\n>void\tuncaughtException(Thread t, Throwable e)\n>```\n>\n>### 创建ThreadGroup\n>\n>简单demo\n>\n>```\n>  //创建ThreadGroup\n>    public static void createThreadGroup() {\n>        //获取当前的ThreadGroup\n>        ThreadGroup currentGroup = Thread.currentThread().getThreadGroup();\n>\n>        //定义一个新的ThreadGroup，默认panrent为当前线程所对应的group\n>        ThreadGroup group1 = new ThreadGroup(\"Group1\");\n>\n>        //判断当前线程对应的ThreadGroup是否是group1的parentgroup\n>        System.out.println(currentGroup == group1.getParent());\n>\n>        //定义一个新的group2，其parent为group1\n>        ThreadGroup group2 = new ThreadGroup(group1, \"group2\");\n>\n>        //使用ThreadGroup自带的API判断group1是否是group2的parent\n>        System.out.println(group1.parentOf(group2));\n>    }\n>```\n>\n>运行结果\n>\n>```\n>true\n>true\n>```\n>\n>结果分析：说明如果没有指定创建ThreadGroup的parent，则默认为当前线程所对应的ThreadGroup，另外需要注意的是，ThreadGroup是树形的分布，这课树的根是system，也就是在类加载时就建立好的，接着在main线程启动时，创建了一个以main为名的ThreadGroup。\n>\n>### 使用enumerate 获取当前thread\n>\n>```\n>    //使用enumerate 复制Thread\n>    public static void enumerateThread() throws InterruptedException {\n>        //创建一个新的ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group\");\n>\n>        //创建线程，设置ThreadGroup\n>        Thread thread = new Thread(group, () -> {\n>            while (true) {\n>                try {\n>                    TimeUnit.SECONDS.sleep(1);\n>                } catch (Exception e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        });\n>\n>        thread.start();\n>        TimeUnit.MILLISECONDS.sleep(2);\n>\n>        //得到当前线程对应的ThreadGroup\n>        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();\n>\n>        //创建存储当前ThreadGroup对应线程的数组\n>        Thread[] list = new Thread[mainGroup.activeCount()];\n>\n>        int recuresize = mainGroup.enumerate(list);\n>        System.out.println(recuresize);\n>\n>        recuresize = mainGroup.enumerate(list, false);\n>        System.out.println(recuresize);\n>    }\n>```\n>\n>运行结果:\n>\n>```\n>2\n>1\n>```\n>\n>### 基本API的使用\n>\n>```\n> //一些基本API的操作\n>    public static void testAPI() throws InterruptedException {\n>        //创建一个ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group1\");\n>\n>        //创建线程，设置ThreadGroup\n>        Thread thread = new Thread(group, () -> {\n>            while (true) {\n>                try {\n>                    TimeUnit.SECONDS.sleep(2);\n>                } catch (Exception e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        });\n>        thread.setDaemon(true);\n>        thread.start();\n>\n>\n>        //确保thread开启\n>        TimeUnit.MILLISECONDS.sleep(2);\n>        ThreadGroup mainThreadGroup = Thread.currentThread().getThreadGroup();\n>        System.out.println(\"activeCount = \" + mainThreadGroup.activeCount());\n>        System.out.println(\"activeGroupCount=\" + mainThreadGroup.activeGroupCount());\n>        System.out.println(\"getMaxPriority = \" + mainThreadGroup.getMaxPriority());\n>        System.out.println(\"getName = \" + mainThreadGroup.getName());\n>        System.out.println(\"getParent = \" + mainThreadGroup.getName());\n>        mainThreadGroup.list();\n>        System.out.println(\"------------------------------------\");\n>        System.out.println(\"parentOf = \" + mainThreadGroup.parentOf(group));\n>        System.out.println(\"parentOf = \" + mainThreadGroup.parentOf(mainThreadGroup));\n>\n>    }\n>```\n>\n>运行结果：\n>\n>```\n>activeCount = 2\n>activeGroupCount=1\n>getMaxPriority = 10\n>getName = main\n>getParent = main\n>java.lang.ThreadGroup[name=main,maxpri=10]\n>    Thread[main,5,main]\n>    java.lang.ThreadGroup[name=group1,maxpri=10]\n>        Thread[Thread-0,5,group1]\n>------------------------------------\n>parentOf = true\n>parentOf = true\n>```\n>\n>最后需要注意的是，group的parent也可以是自己本身，这不知道是不是bug。\n>\n>### setMaxPriority\n>\n>```\n>//线程组优先级设置\n>    public static void threadGroupPriority() {\n>        //创建一个ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group1\");\n>\n>        //创建线程，设置ThreadGroup\n>        Thread thread = new Thread(group, () -> {\n>            while (true) {\n>                try {\n>                    TimeUnit.SECONDS.sleep(2);\n>                } catch (Exception e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        });\n>        thread.setDaemon(true);\n>        thread.start();\n>        System.out.println(\"group getMaxPriority()=\" + group.getMaxPriority());\n>        System.out.println(\"thread.getPriority()=\" + thread.getPriority());\n>\n>        //改变group的最大优先级\n>        group.setMaxPriority(3);\n>        System.out.println(\"group getMaxPriority()=\" + group.getMaxPriority());\n>        System.out.println(\"thread.getPriority()=\" + thread.getPriority());\n>    }\n>```\n>\n>运行结果\n>\n>```\n>group getMaxPriority()=10\n>thread.getPriority()=5\n>group getMaxPriority()=3\n>thread.getPriority()=5\n>```\n>\n>在ThreadGroup中线程的优先级是不能大于ThreadGroup设置的最大优先级，但是上面的结果显示线程的优先级大于了ThreadGroup的最大优先级。这是因为，线程在添加时优先级是不大于ThreadGroup的最大优先级，但是后来ThreadGroup修改了最大优先级，但由于线程的优先级已经设置好了，ThreadGroup将不能去更改这个优先级，所以就存在线程组中有大于线程组最大优先级的线程。但是在这之后添加的线程就不会大于线程组的优先级。\n>\n>### ThreadGroup的Damon设置和destory\n>\n>```\n>//守护ThreadGroup 和destory\n>    public static void threadGroupDaemon() throws InterruptedException {\n>        //创建一个ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group1\");\n>\n>        //创建线程，设置ThreadGroup\n>        new Thread(group, () -> {\n>\n>            try {\n>                TimeUnit.SECONDS.sleep(1);\n>            } catch (Exception e) {\n>                e.printStackTrace();\n>            }\n>\n>        }, \"group1-thread\").start();\n>        //创建一个ThreadGroup\n>        ThreadGroup group2 = new ThreadGroup(\"group2\");\n>\n>        //创建线程，设置ThreadGroup\n>        new Thread(group2, () -> {\n>\n>            try {\n>                TimeUnit.SECONDS.sleep(1);\n>            } catch (Exception e) {\n>                e.printStackTrace();\n>            }\n>\n>        }, \"group2-thread\").start();\n>\n>        //设置group2为daemon为true\n>        group2.setDaemon(true);\n>        TimeUnit.SECONDS.sleep(3);\n>        System.out.println(group.isDestroyed());\n>        System.out.println(group2.isDestroyed());\n>    }\n>```\n>\n>运行结果:\n>\n>```\n>false\n>true\n>```\n>\n>当线程组设置为daemon之后，只要线程组中不存在活跃的线程，线程组则自动destory。但是如果线程组没有设置daemon为true，即使线程组中没有活跃的线程，也不会自动destory。\n>\n>注意一点是：destory只有当线程组和子线程组中没有活跃的线程才能调用，否则抛出异常。\n>\n>\n>\n>\n>\n>","source":"_posts/java多线程系列 07 ThreadGroup.md","raw":"abbrlink: 7\ntitle: java多线程系列 07 ThreadGroup\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-13 15:27:00\n---\n# java多线程系列之07 ThreadGroup\n\n### 概要\n\n>1. ThreadGroup 介绍\n>2. 基本API的使用与介绍\n\n### 1. ThreadGroup 介绍\n\n> 在java的多线程处理中有线程组ThreadGroup的概念，ThreadGroup是为了方便线程管理出现了，可以统一设定线程组的一些属性，比如setDaemon，设置未处理异常的处理方法，设置统一的安全策略等等；也可以通过线程组方便的获得线程的一些信息。\n>\n> 每一个ThreadGroup都可以包含一组的子线程和一组子线程组，在一个进程中线程组是以树形的方式存在，通常情况下根线程组是system线程组。system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。\n\n### 2. 基本API介绍\n\n>```\n>// 构造函数 \n>ThreadGroup(String name)  \n>ThreadGroup(ThreadGroup parent, String name)\n>\n>// 基本API\n>int\tactiveCount()  //返回一个预估的当前TreadGroup和子group中存活线程的数量\n>int\tactiveGroupCount() //返回一个预估的当前TreadGroup所包含的group中存活ThreadGroup的数量\n>void\tcheckAccess() //判断当前运行的线程是否有权限修改此group\n>void\tdestroy()   //销毁当前group和子group\n>int\tenumerate(Thread[] list) //拷贝当前group和子group中的没有dead的线程\n>int\tenumerate(Thread[] list,boolean recurs)//和上一个的区别就是是否需要拷贝子group中的线程\n>int\tenumerate(ThreadGroup[] list)  //拷贝当前group和子group中ThreadGroup\n>int\tenumerate(ThreadGroup[] list, boolean recurse) //是否需要子Group\n>String\tgetName()\n>ThreadGroup\tgetParent()\n>void\tinterrupt()  //设置当前ThreadGroup中所有的线程中断标记为true\n>boolean\tisDaemon()\n>boolean\tisDestroyed()  //判断当前group是否被销毁\n>void\tlist() //打印当前group中的信息去标准输入流\n>boolean\tparentOf(ThreadGroup g)\n>void\tsetDaemon(boolean daemon)  //改变当前group中的线程为daemon线程\n>void\tsetMaxPriority(int pri)  //设置当前group的权限最大值\n>int\t    getMaxPriority() //返回当前ThreadGroup的最大权限\n>\n>void\tuncaughtException(Thread t, Throwable e)\n>```\n>\n>### 创建ThreadGroup\n>\n>简单demo\n>\n>```\n>  //创建ThreadGroup\n>    public static void createThreadGroup() {\n>        //获取当前的ThreadGroup\n>        ThreadGroup currentGroup = Thread.currentThread().getThreadGroup();\n>\n>        //定义一个新的ThreadGroup，默认panrent为当前线程所对应的group\n>        ThreadGroup group1 = new ThreadGroup(\"Group1\");\n>\n>        //判断当前线程对应的ThreadGroup是否是group1的parentgroup\n>        System.out.println(currentGroup == group1.getParent());\n>\n>        //定义一个新的group2，其parent为group1\n>        ThreadGroup group2 = new ThreadGroup(group1, \"group2\");\n>\n>        //使用ThreadGroup自带的API判断group1是否是group2的parent\n>        System.out.println(group1.parentOf(group2));\n>    }\n>```\n>\n>运行结果\n>\n>```\n>true\n>true\n>```\n>\n>结果分析：说明如果没有指定创建ThreadGroup的parent，则默认为当前线程所对应的ThreadGroup，另外需要注意的是，ThreadGroup是树形的分布，这课树的根是system，也就是在类加载时就建立好的，接着在main线程启动时，创建了一个以main为名的ThreadGroup。\n>\n>### 使用enumerate 获取当前thread\n>\n>```\n>    //使用enumerate 复制Thread\n>    public static void enumerateThread() throws InterruptedException {\n>        //创建一个新的ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group\");\n>\n>        //创建线程，设置ThreadGroup\n>        Thread thread = new Thread(group, () -> {\n>            while (true) {\n>                try {\n>                    TimeUnit.SECONDS.sleep(1);\n>                } catch (Exception e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        });\n>\n>        thread.start();\n>        TimeUnit.MILLISECONDS.sleep(2);\n>\n>        //得到当前线程对应的ThreadGroup\n>        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();\n>\n>        //创建存储当前ThreadGroup对应线程的数组\n>        Thread[] list = new Thread[mainGroup.activeCount()];\n>\n>        int recuresize = mainGroup.enumerate(list);\n>        System.out.println(recuresize);\n>\n>        recuresize = mainGroup.enumerate(list, false);\n>        System.out.println(recuresize);\n>    }\n>```\n>\n>运行结果:\n>\n>```\n>2\n>1\n>```\n>\n>### 基本API的使用\n>\n>```\n> //一些基本API的操作\n>    public static void testAPI() throws InterruptedException {\n>        //创建一个ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group1\");\n>\n>        //创建线程，设置ThreadGroup\n>        Thread thread = new Thread(group, () -> {\n>            while (true) {\n>                try {\n>                    TimeUnit.SECONDS.sleep(2);\n>                } catch (Exception e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        });\n>        thread.setDaemon(true);\n>        thread.start();\n>\n>\n>        //确保thread开启\n>        TimeUnit.MILLISECONDS.sleep(2);\n>        ThreadGroup mainThreadGroup = Thread.currentThread().getThreadGroup();\n>        System.out.println(\"activeCount = \" + mainThreadGroup.activeCount());\n>        System.out.println(\"activeGroupCount=\" + mainThreadGroup.activeGroupCount());\n>        System.out.println(\"getMaxPriority = \" + mainThreadGroup.getMaxPriority());\n>        System.out.println(\"getName = \" + mainThreadGroup.getName());\n>        System.out.println(\"getParent = \" + mainThreadGroup.getName());\n>        mainThreadGroup.list();\n>        System.out.println(\"------------------------------------\");\n>        System.out.println(\"parentOf = \" + mainThreadGroup.parentOf(group));\n>        System.out.println(\"parentOf = \" + mainThreadGroup.parentOf(mainThreadGroup));\n>\n>    }\n>```\n>\n>运行结果：\n>\n>```\n>activeCount = 2\n>activeGroupCount=1\n>getMaxPriority = 10\n>getName = main\n>getParent = main\n>java.lang.ThreadGroup[name=main,maxpri=10]\n>    Thread[main,5,main]\n>    java.lang.ThreadGroup[name=group1,maxpri=10]\n>        Thread[Thread-0,5,group1]\n>------------------------------------\n>parentOf = true\n>parentOf = true\n>```\n>\n>最后需要注意的是，group的parent也可以是自己本身，这不知道是不是bug。\n>\n>### setMaxPriority\n>\n>```\n>//线程组优先级设置\n>    public static void threadGroupPriority() {\n>        //创建一个ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group1\");\n>\n>        //创建线程，设置ThreadGroup\n>        Thread thread = new Thread(group, () -> {\n>            while (true) {\n>                try {\n>                    TimeUnit.SECONDS.sleep(2);\n>                } catch (Exception e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        });\n>        thread.setDaemon(true);\n>        thread.start();\n>        System.out.println(\"group getMaxPriority()=\" + group.getMaxPriority());\n>        System.out.println(\"thread.getPriority()=\" + thread.getPriority());\n>\n>        //改变group的最大优先级\n>        group.setMaxPriority(3);\n>        System.out.println(\"group getMaxPriority()=\" + group.getMaxPriority());\n>        System.out.println(\"thread.getPriority()=\" + thread.getPriority());\n>    }\n>```\n>\n>运行结果\n>\n>```\n>group getMaxPriority()=10\n>thread.getPriority()=5\n>group getMaxPriority()=3\n>thread.getPriority()=5\n>```\n>\n>在ThreadGroup中线程的优先级是不能大于ThreadGroup设置的最大优先级，但是上面的结果显示线程的优先级大于了ThreadGroup的最大优先级。这是因为，线程在添加时优先级是不大于ThreadGroup的最大优先级，但是后来ThreadGroup修改了最大优先级，但由于线程的优先级已经设置好了，ThreadGroup将不能去更改这个优先级，所以就存在线程组中有大于线程组最大优先级的线程。但是在这之后添加的线程就不会大于线程组的优先级。\n>\n>### ThreadGroup的Damon设置和destory\n>\n>```\n>//守护ThreadGroup 和destory\n>    public static void threadGroupDaemon() throws InterruptedException {\n>        //创建一个ThreadGroup\n>        ThreadGroup group = new ThreadGroup(\"group1\");\n>\n>        //创建线程，设置ThreadGroup\n>        new Thread(group, () -> {\n>\n>            try {\n>                TimeUnit.SECONDS.sleep(1);\n>            } catch (Exception e) {\n>                e.printStackTrace();\n>            }\n>\n>        }, \"group1-thread\").start();\n>        //创建一个ThreadGroup\n>        ThreadGroup group2 = new ThreadGroup(\"group2\");\n>\n>        //创建线程，设置ThreadGroup\n>        new Thread(group2, () -> {\n>\n>            try {\n>                TimeUnit.SECONDS.sleep(1);\n>            } catch (Exception e) {\n>                e.printStackTrace();\n>            }\n>\n>        }, \"group2-thread\").start();\n>\n>        //设置group2为daemon为true\n>        group2.setDaemon(true);\n>        TimeUnit.SECONDS.sleep(3);\n>        System.out.println(group.isDestroyed());\n>        System.out.println(group2.isDestroyed());\n>    }\n>```\n>\n>运行结果:\n>\n>```\n>false\n>true\n>```\n>\n>当线程组设置为daemon之后，只要线程组中不存在活跃的线程，线程组则自动destory。但是如果线程组没有设置daemon为true，即使线程组中没有活跃的线程，也不会自动destory。\n>\n>注意一点是：destory只有当线程组和子线程组中没有活跃的线程才能调用，否则抛出异常。\n>\n>\n>\n>\n>\n>","slug":"java多线程系列 07 ThreadGroup","published":1,"updated":"2019-01-04T01:48:59.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx2r001deb1u684fat6q","content":"<h1 id=\"java多线程系列之07-ThreadGroup\"><a href=\"#java多线程系列之07-ThreadGroup\" class=\"headerlink\" title=\"java多线程系列之07 ThreadGroup\"></a>java多线程系列之07 ThreadGroup</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>ThreadGroup 介绍</li>\n<li>基本API的使用与介绍</li>\n</ol>\n</blockquote>\n<h3 id=\"1-ThreadGroup-介绍\"><a href=\"#1-ThreadGroup-介绍\" class=\"headerlink\" title=\"1. ThreadGroup 介绍\"></a>1. ThreadGroup 介绍</h3><blockquote>\n<p>在java的多线程处理中有线程组ThreadGroup的概念，ThreadGroup是为了方便线程管理出现了，可以统一设定线程组的一些属性，比如setDaemon，设置未处理异常的处理方法，设置统一的安全策略等等；也可以通过线程组方便的获得线程的一些信息。</p>\n<p>每一个ThreadGroup都可以包含一组的子线程和一组子线程组，在一个进程中线程组是以树形的方式存在，通常情况下根线程组是system线程组。system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。</p>\n</blockquote>\n<h3 id=\"2-基本API介绍\"><a href=\"#2-基本API介绍\" class=\"headerlink\" title=\"2. 基本API介绍\"></a>2. 基本API介绍</h3><blockquote>\n<pre><code>// 构造函数 \nThreadGroup(String name)  \nThreadGroup(ThreadGroup parent, String name)\n\n// 基本API\nint    activeCount()  //返回一个预估的当前TreadGroup和子group中存活线程的数量\nint    activeGroupCount() //返回一个预估的当前TreadGroup所包含的group中存活ThreadGroup的数量\nvoid    checkAccess() //判断当前运行的线程是否有权限修改此group\nvoid    destroy()   //销毁当前group和子group\nint    enumerate(Thread[] list) //拷贝当前group和子group中的没有dead的线程\nint    enumerate(Thread[] list,boolean recurs)//和上一个的区别就是是否需要拷贝子group中的线程\nint    enumerate(ThreadGroup[] list)  //拷贝当前group和子group中ThreadGroup\nint    enumerate(ThreadGroup[] list, boolean recurse) //是否需要子Group\nString    getName()\nThreadGroup    getParent()\nvoid    interrupt()  //设置当前ThreadGroup中所有的线程中断标记为true\nboolean    isDaemon()\nboolean    isDestroyed()  //判断当前group是否被销毁\nvoid    list() //打印当前group中的信息去标准输入流\nboolean    parentOf(ThreadGroup g)\nvoid    setDaemon(boolean daemon)  //改变当前group中的线程为daemon线程\nvoid    setMaxPriority(int pri)  //设置当前group的权限最大值\nint        getMaxPriority() //返回当前ThreadGroup的最大权限\n\nvoid    uncaughtException(Thread t, Throwable e)\n</code></pre><h3 id=\"创建ThreadGroup\"><a href=\"#创建ThreadGroup\" class=\"headerlink\" title=\"创建ThreadGroup\"></a>创建ThreadGroup</h3><p>简单demo</p>\n<pre><code> //创建ThreadGroup\n   public static void createThreadGroup() {\n       //获取当前的ThreadGroup\n       ThreadGroup currentGroup = Thread.currentThread().getThreadGroup();\n\n       //定义一个新的ThreadGroup，默认panrent为当前线程所对应的group\n       ThreadGroup group1 = new ThreadGroup(&quot;Group1&quot;);\n\n       //判断当前线程对应的ThreadGroup是否是group1的parentgroup\n       System.out.println(currentGroup == group1.getParent());\n\n       //定义一个新的group2，其parent为group1\n       ThreadGroup group2 = new ThreadGroup(group1, &quot;group2&quot;);\n\n       //使用ThreadGroup自带的API判断group1是否是group2的parent\n       System.out.println(group1.parentOf(group2));\n   }\n</code></pre><p>运行结果</p>\n<pre><code>true\ntrue\n</code></pre><p>结果分析：说明如果没有指定创建ThreadGroup的parent，则默认为当前线程所对应的ThreadGroup，另外需要注意的是，ThreadGroup是树形的分布，这课树的根是system，也就是在类加载时就建立好的，接着在main线程启动时，创建了一个以main为名的ThreadGroup。</p>\n<h3 id=\"使用enumerate-获取当前thread\"><a href=\"#使用enumerate-获取当前thread\" class=\"headerlink\" title=\"使用enumerate 获取当前thread\"></a>使用enumerate 获取当前thread</h3><pre><code>   //使用enumerate 复制Thread\n   public static void enumerateThread() throws InterruptedException {\n       //创建一个新的ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group&quot;);\n\n       //创建线程，设置ThreadGroup\n       Thread thread = new Thread(group, () -&gt; {\n           while (true) {\n               try {\n                   TimeUnit.SECONDS.sleep(1);\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n           }\n       });\n\n       thread.start();\n       TimeUnit.MILLISECONDS.sleep(2);\n\n       //得到当前线程对应的ThreadGroup\n       ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();\n\n       //创建存储当前ThreadGroup对应线程的数组\n       Thread[] list = new Thread[mainGroup.activeCount()];\n\n       int recuresize = mainGroup.enumerate(list);\n       System.out.println(recuresize);\n\n       recuresize = mainGroup.enumerate(list, false);\n       System.out.println(recuresize);\n   }\n</code></pre><p>运行结果:</p>\n<pre><code>2\n1\n</code></pre><h3 id=\"基本API的使用\"><a href=\"#基本API的使用\" class=\"headerlink\" title=\"基本API的使用\"></a>基本API的使用</h3><pre><code>//一些基本API的操作\n   public static void testAPI() throws InterruptedException {\n       //创建一个ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group1&quot;);\n\n       //创建线程，设置ThreadGroup\n       Thread thread = new Thread(group, () -&gt; {\n           while (true) {\n               try {\n                   TimeUnit.SECONDS.sleep(2);\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n           }\n       });\n       thread.setDaemon(true);\n       thread.start();\n\n\n       //确保thread开启\n       TimeUnit.MILLISECONDS.sleep(2);\n       ThreadGroup mainThreadGroup = Thread.currentThread().getThreadGroup();\n       System.out.println(&quot;activeCount = &quot; + mainThreadGroup.activeCount());\n       System.out.println(&quot;activeGroupCount=&quot; + mainThreadGroup.activeGroupCount());\n       System.out.println(&quot;getMaxPriority = &quot; + mainThreadGroup.getMaxPriority());\n       System.out.println(&quot;getName = &quot; + mainThreadGroup.getName());\n       System.out.println(&quot;getParent = &quot; + mainThreadGroup.getName());\n       mainThreadGroup.list();\n       System.out.println(&quot;------------------------------------&quot;);\n       System.out.println(&quot;parentOf = &quot; + mainThreadGroup.parentOf(group));\n       System.out.println(&quot;parentOf = &quot; + mainThreadGroup.parentOf(mainThreadGroup));\n\n   }\n</code></pre><p>运行结果：</p>\n<pre><code>activeCount = 2\nactiveGroupCount=1\ngetMaxPriority = 10\ngetName = main\ngetParent = main\njava.lang.ThreadGroup[name=main,maxpri=10]\n   Thread[main,5,main]\n   java.lang.ThreadGroup[name=group1,maxpri=10]\n       Thread[Thread-0,5,group1]\n------------------------------------\nparentOf = true\nparentOf = true\n</code></pre><p>最后需要注意的是，group的parent也可以是自己本身，这不知道是不是bug。</p>\n<h3 id=\"setMaxPriority\"><a href=\"#setMaxPriority\" class=\"headerlink\" title=\"setMaxPriority\"></a>setMaxPriority</h3><pre><code>//线程组优先级设置\n   public static void threadGroupPriority() {\n       //创建一个ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group1&quot;);\n\n       //创建线程，设置ThreadGroup\n       Thread thread = new Thread(group, () -&gt; {\n           while (true) {\n               try {\n                   TimeUnit.SECONDS.sleep(2);\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n           }\n       });\n       thread.setDaemon(true);\n       thread.start();\n       System.out.println(&quot;group getMaxPriority()=&quot; + group.getMaxPriority());\n       System.out.println(&quot;thread.getPriority()=&quot; + thread.getPriority());\n\n       //改变group的最大优先级\n       group.setMaxPriority(3);\n       System.out.println(&quot;group getMaxPriority()=&quot; + group.getMaxPriority());\n       System.out.println(&quot;thread.getPriority()=&quot; + thread.getPriority());\n   }\n</code></pre><p>运行结果</p>\n<pre><code>group getMaxPriority()=10\nthread.getPriority()=5\ngroup getMaxPriority()=3\nthread.getPriority()=5\n</code></pre><p>在ThreadGroup中线程的优先级是不能大于ThreadGroup设置的最大优先级，但是上面的结果显示线程的优先级大于了ThreadGroup的最大优先级。这是因为，线程在添加时优先级是不大于ThreadGroup的最大优先级，但是后来ThreadGroup修改了最大优先级，但由于线程的优先级已经设置好了，ThreadGroup将不能去更改这个优先级，所以就存在线程组中有大于线程组最大优先级的线程。但是在这之后添加的线程就不会大于线程组的优先级。</p>\n<h3 id=\"ThreadGroup的Damon设置和destory\"><a href=\"#ThreadGroup的Damon设置和destory\" class=\"headerlink\" title=\"ThreadGroup的Damon设置和destory\"></a>ThreadGroup的Damon设置和destory</h3><pre><code>//守护ThreadGroup 和destory\n   public static void threadGroupDaemon() throws InterruptedException {\n       //创建一个ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group1&quot;);\n\n       //创建线程，设置ThreadGroup\n       new Thread(group, () -&gt; {\n\n           try {\n               TimeUnit.SECONDS.sleep(1);\n           } catch (Exception e) {\n               e.printStackTrace();\n           }\n\n       }, &quot;group1-thread&quot;).start();\n       //创建一个ThreadGroup\n       ThreadGroup group2 = new ThreadGroup(&quot;group2&quot;);\n\n       //创建线程，设置ThreadGroup\n       new Thread(group2, () -&gt; {\n\n           try {\n               TimeUnit.SECONDS.sleep(1);\n           } catch (Exception e) {\n               e.printStackTrace();\n           }\n\n       }, &quot;group2-thread&quot;).start();\n\n       //设置group2为daemon为true\n       group2.setDaemon(true);\n       TimeUnit.SECONDS.sleep(3);\n       System.out.println(group.isDestroyed());\n       System.out.println(group2.isDestroyed());\n   }\n</code></pre><p>运行结果:</p>\n<pre><code>false\ntrue\n</code></pre><p>当线程组设置为daemon之后，只要线程组中不存在活跃的线程，线程组则自动destory。但是如果线程组没有设置daemon为true，即使线程组中没有活跃的线程，也不会自动destory。</p>\n<p>注意一点是：destory只有当线程组和子线程组中没有活跃的线程才能调用，否则抛出异常。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列之07-ThreadGroup\"><a href=\"#java多线程系列之07-ThreadGroup\" class=\"headerlink\" title=\"java多线程系列之07 ThreadGroup\"></a>java多线程系列之07 ThreadGroup</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>ThreadGroup 介绍</li>\n<li>基本API的使用与介绍</li>\n</ol>\n</blockquote>\n<h3 id=\"1-ThreadGroup-介绍\"><a href=\"#1-ThreadGroup-介绍\" class=\"headerlink\" title=\"1. ThreadGroup 介绍\"></a>1. ThreadGroup 介绍</h3><blockquote>\n<p>在java的多线程处理中有线程组ThreadGroup的概念，ThreadGroup是为了方便线程管理出现了，可以统一设定线程组的一些属性，比如setDaemon，设置未处理异常的处理方法，设置统一的安全策略等等；也可以通过线程组方便的获得线程的一些信息。</p>\n<p>每一个ThreadGroup都可以包含一组的子线程和一组子线程组，在一个进程中线程组是以树形的方式存在，通常情况下根线程组是system线程组。system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。</p>\n</blockquote>\n<h3 id=\"2-基本API介绍\"><a href=\"#2-基本API介绍\" class=\"headerlink\" title=\"2. 基本API介绍\"></a>2. 基本API介绍</h3><blockquote>\n<pre><code>// 构造函数 \nThreadGroup(String name)  \nThreadGroup(ThreadGroup parent, String name)\n\n// 基本API\nint    activeCount()  //返回一个预估的当前TreadGroup和子group中存活线程的数量\nint    activeGroupCount() //返回一个预估的当前TreadGroup所包含的group中存活ThreadGroup的数量\nvoid    checkAccess() //判断当前运行的线程是否有权限修改此group\nvoid    destroy()   //销毁当前group和子group\nint    enumerate(Thread[] list) //拷贝当前group和子group中的没有dead的线程\nint    enumerate(Thread[] list,boolean recurs)//和上一个的区别就是是否需要拷贝子group中的线程\nint    enumerate(ThreadGroup[] list)  //拷贝当前group和子group中ThreadGroup\nint    enumerate(ThreadGroup[] list, boolean recurse) //是否需要子Group\nString    getName()\nThreadGroup    getParent()\nvoid    interrupt()  //设置当前ThreadGroup中所有的线程中断标记为true\nboolean    isDaemon()\nboolean    isDestroyed()  //判断当前group是否被销毁\nvoid    list() //打印当前group中的信息去标准输入流\nboolean    parentOf(ThreadGroup g)\nvoid    setDaemon(boolean daemon)  //改变当前group中的线程为daemon线程\nvoid    setMaxPriority(int pri)  //设置当前group的权限最大值\nint        getMaxPriority() //返回当前ThreadGroup的最大权限\n\nvoid    uncaughtException(Thread t, Throwable e)\n</code></pre><h3 id=\"创建ThreadGroup\"><a href=\"#创建ThreadGroup\" class=\"headerlink\" title=\"创建ThreadGroup\"></a>创建ThreadGroup</h3><p>简单demo</p>\n<pre><code> //创建ThreadGroup\n   public static void createThreadGroup() {\n       //获取当前的ThreadGroup\n       ThreadGroup currentGroup = Thread.currentThread().getThreadGroup();\n\n       //定义一个新的ThreadGroup，默认panrent为当前线程所对应的group\n       ThreadGroup group1 = new ThreadGroup(&quot;Group1&quot;);\n\n       //判断当前线程对应的ThreadGroup是否是group1的parentgroup\n       System.out.println(currentGroup == group1.getParent());\n\n       //定义一个新的group2，其parent为group1\n       ThreadGroup group2 = new ThreadGroup(group1, &quot;group2&quot;);\n\n       //使用ThreadGroup自带的API判断group1是否是group2的parent\n       System.out.println(group1.parentOf(group2));\n   }\n</code></pre><p>运行结果</p>\n<pre><code>true\ntrue\n</code></pre><p>结果分析：说明如果没有指定创建ThreadGroup的parent，则默认为当前线程所对应的ThreadGroup，另外需要注意的是，ThreadGroup是树形的分布，这课树的根是system，也就是在类加载时就建立好的，接着在main线程启动时，创建了一个以main为名的ThreadGroup。</p>\n<h3 id=\"使用enumerate-获取当前thread\"><a href=\"#使用enumerate-获取当前thread\" class=\"headerlink\" title=\"使用enumerate 获取当前thread\"></a>使用enumerate 获取当前thread</h3><pre><code>   //使用enumerate 复制Thread\n   public static void enumerateThread() throws InterruptedException {\n       //创建一个新的ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group&quot;);\n\n       //创建线程，设置ThreadGroup\n       Thread thread = new Thread(group, () -&gt; {\n           while (true) {\n               try {\n                   TimeUnit.SECONDS.sleep(1);\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n           }\n       });\n\n       thread.start();\n       TimeUnit.MILLISECONDS.sleep(2);\n\n       //得到当前线程对应的ThreadGroup\n       ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();\n\n       //创建存储当前ThreadGroup对应线程的数组\n       Thread[] list = new Thread[mainGroup.activeCount()];\n\n       int recuresize = mainGroup.enumerate(list);\n       System.out.println(recuresize);\n\n       recuresize = mainGroup.enumerate(list, false);\n       System.out.println(recuresize);\n   }\n</code></pre><p>运行结果:</p>\n<pre><code>2\n1\n</code></pre><h3 id=\"基本API的使用\"><a href=\"#基本API的使用\" class=\"headerlink\" title=\"基本API的使用\"></a>基本API的使用</h3><pre><code>//一些基本API的操作\n   public static void testAPI() throws InterruptedException {\n       //创建一个ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group1&quot;);\n\n       //创建线程，设置ThreadGroup\n       Thread thread = new Thread(group, () -&gt; {\n           while (true) {\n               try {\n                   TimeUnit.SECONDS.sleep(2);\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n           }\n       });\n       thread.setDaemon(true);\n       thread.start();\n\n\n       //确保thread开启\n       TimeUnit.MILLISECONDS.sleep(2);\n       ThreadGroup mainThreadGroup = Thread.currentThread().getThreadGroup();\n       System.out.println(&quot;activeCount = &quot; + mainThreadGroup.activeCount());\n       System.out.println(&quot;activeGroupCount=&quot; + mainThreadGroup.activeGroupCount());\n       System.out.println(&quot;getMaxPriority = &quot; + mainThreadGroup.getMaxPriority());\n       System.out.println(&quot;getName = &quot; + mainThreadGroup.getName());\n       System.out.println(&quot;getParent = &quot; + mainThreadGroup.getName());\n       mainThreadGroup.list();\n       System.out.println(&quot;------------------------------------&quot;);\n       System.out.println(&quot;parentOf = &quot; + mainThreadGroup.parentOf(group));\n       System.out.println(&quot;parentOf = &quot; + mainThreadGroup.parentOf(mainThreadGroup));\n\n   }\n</code></pre><p>运行结果：</p>\n<pre><code>activeCount = 2\nactiveGroupCount=1\ngetMaxPriority = 10\ngetName = main\ngetParent = main\njava.lang.ThreadGroup[name=main,maxpri=10]\n   Thread[main,5,main]\n   java.lang.ThreadGroup[name=group1,maxpri=10]\n       Thread[Thread-0,5,group1]\n------------------------------------\nparentOf = true\nparentOf = true\n</code></pre><p>最后需要注意的是，group的parent也可以是自己本身，这不知道是不是bug。</p>\n<h3 id=\"setMaxPriority\"><a href=\"#setMaxPriority\" class=\"headerlink\" title=\"setMaxPriority\"></a>setMaxPriority</h3><pre><code>//线程组优先级设置\n   public static void threadGroupPriority() {\n       //创建一个ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group1&quot;);\n\n       //创建线程，设置ThreadGroup\n       Thread thread = new Thread(group, () -&gt; {\n           while (true) {\n               try {\n                   TimeUnit.SECONDS.sleep(2);\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n           }\n       });\n       thread.setDaemon(true);\n       thread.start();\n       System.out.println(&quot;group getMaxPriority()=&quot; + group.getMaxPriority());\n       System.out.println(&quot;thread.getPriority()=&quot; + thread.getPriority());\n\n       //改变group的最大优先级\n       group.setMaxPriority(3);\n       System.out.println(&quot;group getMaxPriority()=&quot; + group.getMaxPriority());\n       System.out.println(&quot;thread.getPriority()=&quot; + thread.getPriority());\n   }\n</code></pre><p>运行结果</p>\n<pre><code>group getMaxPriority()=10\nthread.getPriority()=5\ngroup getMaxPriority()=3\nthread.getPriority()=5\n</code></pre><p>在ThreadGroup中线程的优先级是不能大于ThreadGroup设置的最大优先级，但是上面的结果显示线程的优先级大于了ThreadGroup的最大优先级。这是因为，线程在添加时优先级是不大于ThreadGroup的最大优先级，但是后来ThreadGroup修改了最大优先级，但由于线程的优先级已经设置好了，ThreadGroup将不能去更改这个优先级，所以就存在线程组中有大于线程组最大优先级的线程。但是在这之后添加的线程就不会大于线程组的优先级。</p>\n<h3 id=\"ThreadGroup的Damon设置和destory\"><a href=\"#ThreadGroup的Damon设置和destory\" class=\"headerlink\" title=\"ThreadGroup的Damon设置和destory\"></a>ThreadGroup的Damon设置和destory</h3><pre><code>//守护ThreadGroup 和destory\n   public static void threadGroupDaemon() throws InterruptedException {\n       //创建一个ThreadGroup\n       ThreadGroup group = new ThreadGroup(&quot;group1&quot;);\n\n       //创建线程，设置ThreadGroup\n       new Thread(group, () -&gt; {\n\n           try {\n               TimeUnit.SECONDS.sleep(1);\n           } catch (Exception e) {\n               e.printStackTrace();\n           }\n\n       }, &quot;group1-thread&quot;).start();\n       //创建一个ThreadGroup\n       ThreadGroup group2 = new ThreadGroup(&quot;group2&quot;);\n\n       //创建线程，设置ThreadGroup\n       new Thread(group2, () -&gt; {\n\n           try {\n               TimeUnit.SECONDS.sleep(1);\n           } catch (Exception e) {\n               e.printStackTrace();\n           }\n\n       }, &quot;group2-thread&quot;).start();\n\n       //设置group2为daemon为true\n       group2.setDaemon(true);\n       TimeUnit.SECONDS.sleep(3);\n       System.out.println(group.isDestroyed());\n       System.out.println(group2.isDestroyed());\n   }\n</code></pre><p>运行结果:</p>\n<pre><code>false\ntrue\n</code></pre><p>当线程组设置为daemon之后，只要线程组中不存在活跃的线程，线程组则自动destory。但是如果线程组没有设置daemon为true，即使线程组中没有活跃的线程，也不会自动destory。</p>\n<p>注意一点是：destory只有当线程组和子线程组中没有活跃的线程才能调用，否则抛出异常。</p>\n</blockquote>\n"},{"abbrlink":9,"title":"java多线程系列-JUC线程池之 01 线程池架构","author":"zhangke","date":"2018-07-23T06:07:00.000Z","_content":"# java多线程系列-JUC线程池之 01 线程池架构\n\n### 概要\n\n>1. 线程池整体架构介绍\n>2. 简单示例\n\n### 1. 线程池整体架构介绍\n\n>### 1. Executor\n>\n>> Executor将任务的执行和任务的创建分离开来。他提供了执行的接口，是来执行任务的。只要提交的任务实现了Runnable接口，就可以将此任务交给Executor来执行，这个接口只包含一个函数，代码如下:\n>>\n>> ```\n>> public interface Executor{\n>>     //在未来执行给定的任务\n>>     void\texecute(Runnable command)\n>> }\n>> ```\n>>\n>> \n>\n>### 2. ExecutorService\n>\n>>现在可以通过Executor来实现任务的运行。通常Executor的实现通常会创建线程来执行任务。但JVM只有在所有非守护线程全部终止后才会退出，因此如果无法正确的关闭Executor，那么JVM将无法结束。\n>>\n>>关闭任务的方式：\n>>\n>>1. 直接关闭，相当于断开电源\n>>2. 执行完所有当前线程上执行的任务，不在接收新的任务。然后关闭\n>>\n>>此时Executor接口定义的方法不足以满足这些要求的实现，所以有了ExecutorService接口。添加了一些用于生命周期管理的方法（同时还有一些用于任务提交的便利方法）：\n>>\n>>```java\n>>// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。\n>>boolean awaitTermination(long timeout, TimeUnit unit)\n>>    \n>>// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。\n>><T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n>>// 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。\n>><T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n>>// 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。\n>><T> T invokeAny(Collection<? extends Callable<T>> tasks)\n>>// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。\n>><T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n>>    \n>>    \n>>// 如果此执行程序已关闭，则返回 true。\n>>boolean isShutdown()\n>>// 如果关闭后所有任务都已完成，则返回 true。\n>>boolean isTerminated()\n>>    \n>>    \n>>// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。\n>>void shutdown()\n>>// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。\n>>List<Runnable> shutdownNow()\n>>    \n>>    \n>>// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n>><T> Future<T> submit(Callable<T> task)\n>>// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>>Future<?> submit(Runnable task)\n>>// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>><T> Future<T> submit(Runnable task, T result)\n>>```\n>>\n>>ExecutorService的生命周期有三种状态：运行、关闭和已终止。\n>>\n>>1. 在初始创建时处于运行状态，\n>>\n>>2. shutdown方法将执行平缓的关闭状态：不在接收新的任务，同时等待已经提交的任务执行完成，包括那些还未开始执行的任务\n>>\n>>3. shutdownNow方法将执行粗暴的关闭过程，将尝试取消所有运行中的任务。\n>>\n>>   通过isTerminated来确定线程池是否终止，终止后不同拒绝策略有不同的返回结果的方式。\n>\n>### **3. AbstractExecutorService**\n>\n>> AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。方便我们定制线程池。这个类的方法和ExecutorService一样，所有就不列出来，后面再分析线程池源码时我会在来说这个类。\n>\n>### 4.**ThreadPoolExecutor**\n>\n>> ThreadPoolExecutor就是大名鼎鼎的\"线程池\"，它继承于AbstractExecutorService抽象类。是线程池的主要实现类，也是我们后面关注的重点，因此就现在这里提一下，后面会仔细讲。\n>>\n>> \n>\n>### 5. **ScheduledExecutorService**\n>\n>>ScheduledExecutorService是一个接口，它继承于于ExecutorService。它相当于提供了\"延时\"和\"周期执行\"功能的ExecutorService。 ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。\n>>\n>>**ScheduledExecutorService函数列表**\n>>\n>>````Java\n>>// 创建并执行在给定延迟后启用的 ScheduledFuture。\n>><V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit)\n>>// 创建并执行在给定延迟后启用的一次性操作。\n>>ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)\n>>// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\n>>ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n>>// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\n>>ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n>>````\n>>\n>>\n>\n>### 6. **ScheduledThreadPoolExecutor**\n>\n>> ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了\"延时\"和\"周期执行\"功能的ExecutorService。 ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。\n>>\n>> 在没有此接口之前，我们使用Timer来做定时任务，Timer定时任务的缺陷：\n>>\n>> 1. 执行定时任务时，只创建一个线程，因此如果某个任务执行时间过长，会导致其他定时任务的执行周期加长\n>> 2. 由于只创建了一个线程，当这个线程因为异常关闭之后，其他定时任务就无法启动。（这个问题称之为线程泄漏）\n>>\n>> 因此在5.0 之后很少使用这个类来做定时任务，换成了ScheduledThreadPoolExecutor来做定时任务。\n>>\n>> 同时要构建自己的调度任务还需要队列的支持，这时可以使用DelayQueue，他实现了BlockingQueue，并为ScheduledThreadPoolExecutor提供调度功能，DelayQUeue管理者一组Delayed对象，每个Delayed对象都有一个相应的延迟时间。在DelayQueue中，只有某个元素逾期后，才能从这个队列中take操作。\n>>\n>> 参数列表\n>>\n>> ```Java\n>> // 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize)\n>> // 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler)\n>> // 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory)\n>> // 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n>> \n>> // 修改或替换用于执行 callable 的任务。\n>> protected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task)\n>> // 修改或替换用于执行 runnable 的任务。\n>> protected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task)\n>> // 使用所要求的零延迟执行命令。\n>> void execute(Runnable command)\n>> // 获取有关在此执行程序已 shutdown 的情况下、是否继续执行现有定期任务的策略。\n>> boolean getContinueExistingPeriodicTasksAfterShutdownPolicy()\n>> // 获取有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\n>> boolean getExecuteExistingDelayedTasksAfterShutdownPolicy()\n>> // 返回此执行程序使用的任务队列。\n>> BlockingQueue<Runnable> getQueue()\n>> // 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。\n>> boolean remove(Runnable task)\n>> // 创建并执行在给定延迟后启用的 ScheduledFuture。\n>> <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit)\n>> // 创建并执行在给定延迟后启用的一次性操作。\n>> ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)\n>> // 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\n>> ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n>> // 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\n>> ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n>> // 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有定期任务的策略。\n>> void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)\n>> // 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\n>> void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)\n>> // 在以前已提交任务的执行中发起一个有序的关闭，但是不接受新任务。\n>> void shutdown()\n>> // 尝试停止所有正在执行的任务、暂停等待任务的处理，并返回等待执行的任务列表。\n>> List<Runnable> shutdownNow()\n>> // 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n>> <T> Future<T> submit(Callable<T> task)\n>> // 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>> Future<?> submit(Runnable task)\n>> // 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>> <T> Future<T> submit(Runnable task, T result)\n>> ```\n>>\n>> \n>\n>### 7. Executors\n>\n>>Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。\n>>\n>>```java\n>>// 返回 Callable 对象，调用它时可运行给定特权的操作并返回其结果。\n>>static Callable<Object> callable(PrivilegedAction<?> action)\n>>// 返回 Callable 对象，调用它时可运行给定特权的异常操作并返回其结果。\n>>static Callable<Object> callable(PrivilegedExceptionAction<?> action)\n>>// 返回 Callable 对象，调用它时可运行给定的任务并返回 null。\n>>static Callable<Object> callable(Runnable task)\n>>// 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果。\n>>static <T> Callable<T> callable(Runnable task, T result)\n>>// 返回用于创建新线程的默认线程工厂。\n>>static ThreadFactory defaultThreadFactory()\n>>// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。\n>>static ExecutorService newCachedThreadPool()\n>>// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。\n>>static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)\n>>// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。\n>>static ExecutorService newFixedThreadPool(int nThreads)\n>>// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。\n>>static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)\n>>// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n>>// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)\n>>// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。\n>>static ExecutorService newSingleThreadExecutor()\n>>// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，并在需要时使用提供的 ThreadFactory 创建新线程。\n>>static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)\n>>// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newSingleThreadScheduledExecutor()\n>>// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)\n>>// 返回 Callable 对象，调用它时可在当前的访问控制上下文中执行给定的 callable 对象。\n>>static <T> Callable<T> privilegedCallable(Callable<T> callable)\n>>// 返回 Callable 对象，调用它时可在当前的访问控制上下文中，使用当前上下文类加载器作为上下文类加载器来执行给定的 callable 对象。\n>>static <T> Callable<T> privilegedCallableUsingCurrentClassLoader(Callable<T> callable)\n>>// 返回用于创建新线程的线程工厂，这些新线程与当前线程具有相同的权限。\n>>static ThreadFactory privilegedThreadFactory()\n>>// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\n>>static ExecutorService unconfigurableExecutorService(ExecutorService executor)\n>>// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\n>>static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)\n>>```\n>>\n>>\n>\n>\n\n### 2. 简单示例\n\n>```java\n>import java.util.concurrent.Executors;\n>import java.util.concurrent.ExecutorService;\n>\n>public class ThreadPoolDemo1 {\n>\n>    public static void main(String[] args) {\n>        // 创建一个可重用固定线程数的线程池\n>        ExecutorService pool = Executors.newFixedThreadPool(2);\n>        // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n>        Thread ta = new MyThread();\n>        Thread tb = new MyThread();\n>        Thread tc = new MyThread();\n>        Thread td = new MyThread();\n>        Thread te = new MyThread();\n>        // 将线程放入池中进行执行\n>        pool.execute(ta);\n>        pool.execute(tb);\n>        pool.execute(tc);\n>        pool.execute(td);\n>        pool.execute(te);\n>        // 关闭线程池\n>        pool.shutdown();\n>    }\n>}\n>\n>class MyThread extends Thread {\n>\n>    @Override\n>    public void run() {\n>        System.out.println(Thread.currentThread().getName()+ \" is running.\");\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>```\n>\n>**结果说明**：\n>主线程中创建了线程池pool，线程池的容量是2。即，线程池中最多能同时运行2个线程。\n>紧接着，将ta,tb,tc,td,te这3个线程添加到线程池中运行。\n>最后，通过shutdown()关闭线程池。","source":"_posts/java多线程系列-JUC线程池之 01 线程池架构.md","raw":"abbrlink: 9\ntitle: java多线程系列-JUC线程池之 01 线程池架构\ntags:\n  - JUC\n  - 线程池\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-23 14:07:00\n---\n# java多线程系列-JUC线程池之 01 线程池架构\n\n### 概要\n\n>1. 线程池整体架构介绍\n>2. 简单示例\n\n### 1. 线程池整体架构介绍\n\n>### 1. Executor\n>\n>> Executor将任务的执行和任务的创建分离开来。他提供了执行的接口，是来执行任务的。只要提交的任务实现了Runnable接口，就可以将此任务交给Executor来执行，这个接口只包含一个函数，代码如下:\n>>\n>> ```\n>> public interface Executor{\n>>     //在未来执行给定的任务\n>>     void\texecute(Runnable command)\n>> }\n>> ```\n>>\n>> \n>\n>### 2. ExecutorService\n>\n>>现在可以通过Executor来实现任务的运行。通常Executor的实现通常会创建线程来执行任务。但JVM只有在所有非守护线程全部终止后才会退出，因此如果无法正确的关闭Executor，那么JVM将无法结束。\n>>\n>>关闭任务的方式：\n>>\n>>1. 直接关闭，相当于断开电源\n>>2. 执行完所有当前线程上执行的任务，不在接收新的任务。然后关闭\n>>\n>>此时Executor接口定义的方法不足以满足这些要求的实现，所以有了ExecutorService接口。添加了一些用于生命周期管理的方法（同时还有一些用于任务提交的便利方法）：\n>>\n>>```java\n>>// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。\n>>boolean awaitTermination(long timeout, TimeUnit unit)\n>>    \n>>// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。\n>><T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n>>// 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。\n>><T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n>>// 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。\n>><T> T invokeAny(Collection<? extends Callable<T>> tasks)\n>>// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。\n>><T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n>>    \n>>    \n>>// 如果此执行程序已关闭，则返回 true。\n>>boolean isShutdown()\n>>// 如果关闭后所有任务都已完成，则返回 true。\n>>boolean isTerminated()\n>>    \n>>    \n>>// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。\n>>void shutdown()\n>>// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。\n>>List<Runnable> shutdownNow()\n>>    \n>>    \n>>// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n>><T> Future<T> submit(Callable<T> task)\n>>// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>>Future<?> submit(Runnable task)\n>>// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>><T> Future<T> submit(Runnable task, T result)\n>>```\n>>\n>>ExecutorService的生命周期有三种状态：运行、关闭和已终止。\n>>\n>>1. 在初始创建时处于运行状态，\n>>\n>>2. shutdown方法将执行平缓的关闭状态：不在接收新的任务，同时等待已经提交的任务执行完成，包括那些还未开始执行的任务\n>>\n>>3. shutdownNow方法将执行粗暴的关闭过程，将尝试取消所有运行中的任务。\n>>\n>>   通过isTerminated来确定线程池是否终止，终止后不同拒绝策略有不同的返回结果的方式。\n>\n>### **3. AbstractExecutorService**\n>\n>> AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。方便我们定制线程池。这个类的方法和ExecutorService一样，所有就不列出来，后面再分析线程池源码时我会在来说这个类。\n>\n>### 4.**ThreadPoolExecutor**\n>\n>> ThreadPoolExecutor就是大名鼎鼎的\"线程池\"，它继承于AbstractExecutorService抽象类。是线程池的主要实现类，也是我们后面关注的重点，因此就现在这里提一下，后面会仔细讲。\n>>\n>> \n>\n>### 5. **ScheduledExecutorService**\n>\n>>ScheduledExecutorService是一个接口，它继承于于ExecutorService。它相当于提供了\"延时\"和\"周期执行\"功能的ExecutorService。 ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。\n>>\n>>**ScheduledExecutorService函数列表**\n>>\n>>````Java\n>>// 创建并执行在给定延迟后启用的 ScheduledFuture。\n>><V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit)\n>>// 创建并执行在给定延迟后启用的一次性操作。\n>>ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)\n>>// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\n>>ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n>>// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\n>>ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n>>````\n>>\n>>\n>\n>### 6. **ScheduledThreadPoolExecutor**\n>\n>> ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了\"延时\"和\"周期执行\"功能的ExecutorService。 ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。\n>>\n>> 在没有此接口之前，我们使用Timer来做定时任务，Timer定时任务的缺陷：\n>>\n>> 1. 执行定时任务时，只创建一个线程，因此如果某个任务执行时间过长，会导致其他定时任务的执行周期加长\n>> 2. 由于只创建了一个线程，当这个线程因为异常关闭之后，其他定时任务就无法启动。（这个问题称之为线程泄漏）\n>>\n>> 因此在5.0 之后很少使用这个类来做定时任务，换成了ScheduledThreadPoolExecutor来做定时任务。\n>>\n>> 同时要构建自己的调度任务还需要队列的支持，这时可以使用DelayQueue，他实现了BlockingQueue，并为ScheduledThreadPoolExecutor提供调度功能，DelayQUeue管理者一组Delayed对象，每个Delayed对象都有一个相应的延迟时间。在DelayQueue中，只有某个元素逾期后，才能从这个队列中take操作。\n>>\n>> 参数列表\n>>\n>> ```Java\n>> // 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize)\n>> // 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler)\n>> // 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory)\n>> // 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\n>> ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n>> \n>> // 修改或替换用于执行 callable 的任务。\n>> protected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task)\n>> // 修改或替换用于执行 runnable 的任务。\n>> protected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task)\n>> // 使用所要求的零延迟执行命令。\n>> void execute(Runnable command)\n>> // 获取有关在此执行程序已 shutdown 的情况下、是否继续执行现有定期任务的策略。\n>> boolean getContinueExistingPeriodicTasksAfterShutdownPolicy()\n>> // 获取有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\n>> boolean getExecuteExistingDelayedTasksAfterShutdownPolicy()\n>> // 返回此执行程序使用的任务队列。\n>> BlockingQueue<Runnable> getQueue()\n>> // 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。\n>> boolean remove(Runnable task)\n>> // 创建并执行在给定延迟后启用的 ScheduledFuture。\n>> <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit)\n>> // 创建并执行在给定延迟后启用的一次性操作。\n>> ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)\n>> // 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\n>> ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n>> // 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\n>> ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n>> // 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有定期任务的策略。\n>> void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)\n>> // 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\n>> void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)\n>> // 在以前已提交任务的执行中发起一个有序的关闭，但是不接受新任务。\n>> void shutdown()\n>> // 尝试停止所有正在执行的任务、暂停等待任务的处理，并返回等待执行的任务列表。\n>> List<Runnable> shutdownNow()\n>> // 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n>> <T> Future<T> submit(Callable<T> task)\n>> // 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>> Future<?> submit(Runnable task)\n>> // 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n>> <T> Future<T> submit(Runnable task, T result)\n>> ```\n>>\n>> \n>\n>### 7. Executors\n>\n>>Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。\n>>\n>>```java\n>>// 返回 Callable 对象，调用它时可运行给定特权的操作并返回其结果。\n>>static Callable<Object> callable(PrivilegedAction<?> action)\n>>// 返回 Callable 对象，调用它时可运行给定特权的异常操作并返回其结果。\n>>static Callable<Object> callable(PrivilegedExceptionAction<?> action)\n>>// 返回 Callable 对象，调用它时可运行给定的任务并返回 null。\n>>static Callable<Object> callable(Runnable task)\n>>// 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果。\n>>static <T> Callable<T> callable(Runnable task, T result)\n>>// 返回用于创建新线程的默认线程工厂。\n>>static ThreadFactory defaultThreadFactory()\n>>// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。\n>>static ExecutorService newCachedThreadPool()\n>>// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。\n>>static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)\n>>// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。\n>>static ExecutorService newFixedThreadPool(int nThreads)\n>>// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。\n>>static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)\n>>// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n>>// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)\n>>// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。\n>>static ExecutorService newSingleThreadExecutor()\n>>// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，并在需要时使用提供的 ThreadFactory 创建新线程。\n>>static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)\n>>// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newSingleThreadScheduledExecutor()\n>>// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\n>>static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)\n>>// 返回 Callable 对象，调用它时可在当前的访问控制上下文中执行给定的 callable 对象。\n>>static <T> Callable<T> privilegedCallable(Callable<T> callable)\n>>// 返回 Callable 对象，调用它时可在当前的访问控制上下文中，使用当前上下文类加载器作为上下文类加载器来执行给定的 callable 对象。\n>>static <T> Callable<T> privilegedCallableUsingCurrentClassLoader(Callable<T> callable)\n>>// 返回用于创建新线程的线程工厂，这些新线程与当前线程具有相同的权限。\n>>static ThreadFactory privilegedThreadFactory()\n>>// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\n>>static ExecutorService unconfigurableExecutorService(ExecutorService executor)\n>>// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\n>>static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)\n>>```\n>>\n>>\n>\n>\n\n### 2. 简单示例\n\n>```java\n>import java.util.concurrent.Executors;\n>import java.util.concurrent.ExecutorService;\n>\n>public class ThreadPoolDemo1 {\n>\n>    public static void main(String[] args) {\n>        // 创建一个可重用固定线程数的线程池\n>        ExecutorService pool = Executors.newFixedThreadPool(2);\n>        // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n>        Thread ta = new MyThread();\n>        Thread tb = new MyThread();\n>        Thread tc = new MyThread();\n>        Thread td = new MyThread();\n>        Thread te = new MyThread();\n>        // 将线程放入池中进行执行\n>        pool.execute(ta);\n>        pool.execute(tb);\n>        pool.execute(tc);\n>        pool.execute(td);\n>        pool.execute(te);\n>        // 关闭线程池\n>        pool.shutdown();\n>    }\n>}\n>\n>class MyThread extends Thread {\n>\n>    @Override\n>    public void run() {\n>        System.out.println(Thread.currentThread().getName()+ \" is running.\");\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>```\n>\n>**结果说明**：\n>主线程中创建了线程池pool，线程池的容量是2。即，线程池中最多能同时运行2个线程。\n>紧接着，将ta,tb,tc,td,te这3个线程添加到线程池中运行。\n>最后，通过shutdown()关闭线程池。","slug":"java多线程系列-JUC线程池之 01 线程池架构","published":1,"updated":"2019-01-04T02:18:27.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx2u001feb1uv8afof78","content":"<h1 id=\"java多线程系列-JUC线程池之-01-线程池架构\"><a href=\"#java多线程系列-JUC线程池之-01-线程池架构\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之 01 线程池架构\"></a>java多线程系列-JUC线程池之 01 线程池架构</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>线程池整体架构介绍</li>\n<li>简单示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程池整体架构介绍\"><a href=\"#1-线程池整体架构介绍\" class=\"headerlink\" title=\"1. 线程池整体架构介绍\"></a>1. 线程池整体架构介绍</h3><blockquote>\n<h3 id=\"1-Executor\"><a href=\"#1-Executor\" class=\"headerlink\" title=\"1. Executor\"></a>1. Executor</h3><blockquote>\n<p>Executor将任务的执行和任务的创建分离开来。他提供了执行的接口，是来执行任务的。只要提交的任务实现了Runnable接口，就可以将此任务交给Executor来执行，这个接口只包含一个函数，代码如下:</p>\n<pre><code>public interface Executor{\n    //在未来执行给定的任务\n    void    execute(Runnable command)\n}\n</code></pre></blockquote>\n<h3 id=\"2-ExecutorService\"><a href=\"#2-ExecutorService\" class=\"headerlink\" title=\"2. ExecutorService\"></a>2. ExecutorService</h3><blockquote>\n<p>现在可以通过Executor来实现任务的运行。通常Executor的实现通常会创建线程来执行任务。但JVM只有在所有非守护线程全部终止后才会退出，因此如果无法正确的关闭Executor，那么JVM将无法结束。</p>\n<p>关闭任务的方式：</p>\n<ol>\n<li>直接关闭，相当于断开电源</li>\n<li>执行完所有当前线程上执行的任务，不在接收新的任务。然后关闭</li>\n</ol>\n<p>此时Executor接口定义的方法不足以满足这些要求的实现，所以有了ExecutorService接口。添加了一些用于生命周期管理的方法（同时还有一些用于任务提交的便利方法）：</p>\n<pre><code class=\"java\">// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。\nboolean awaitTermination(long timeout, TimeUnit unit)\n\n// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。\n&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)\n// 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。\n&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)\n// 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。\n&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)\n// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。\n&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)\n\n\n// 如果此执行程序已关闭，则返回 true。\nboolean isShutdown()\n// 如果关闭后所有任务都已完成，则返回 true。\nboolean isTerminated()\n\n\n// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。\nvoid shutdown()\n// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。\nList&lt;Runnable&gt; shutdownNow()\n\n\n// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\nFuture&lt;?&gt; submit(Runnable task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)\n</code></pre>\n<p>ExecutorService的生命周期有三种状态：运行、关闭和已终止。</p>\n<ol>\n<li><p>在初始创建时处于运行状态，</p>\n</li>\n<li><p>shutdown方法将执行平缓的关闭状态：不在接收新的任务，同时等待已经提交的任务执行完成，包括那些还未开始执行的任务</p>\n</li>\n<li><p>shutdownNow方法将执行粗暴的关闭过程，将尝试取消所有运行中的任务。</p>\n<p>通过isTerminated来确定线程池是否终止，终止后不同拒绝策略有不同的返回结果的方式。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"3-AbstractExecutorService\"><a href=\"#3-AbstractExecutorService\" class=\"headerlink\" title=\"3. AbstractExecutorService\"></a><strong>3. AbstractExecutorService</strong></h3><blockquote>\n<p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。方便我们定制线程池。这个类的方法和ExecutorService一样，所有就不列出来，后面再分析线程池源码时我会在来说这个类。</p>\n</blockquote>\n<h3 id=\"4-ThreadPoolExecutor\"><a href=\"#4-ThreadPoolExecutor\" class=\"headerlink\" title=\"4.ThreadPoolExecutor\"></a>4.<strong>ThreadPoolExecutor</strong></h3><blockquote>\n<p>ThreadPoolExecutor就是大名鼎鼎的”线程池”，它继承于AbstractExecutorService抽象类。是线程池的主要实现类，也是我们后面关注的重点，因此就现在这里提一下，后面会仔细讲。</p>\n</blockquote>\n<h3 id=\"5-ScheduledExecutorService\"><a href=\"#5-ScheduledExecutorService\" class=\"headerlink\" title=\"5. ScheduledExecutorService\"></a>5. <strong>ScheduledExecutorService</strong></h3><blockquote>\n<p>ScheduledExecutorService是一个接口，它继承于于ExecutorService。它相当于提供了”延时”和”周期执行”功能的ExecutorService。 ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。</p>\n<p><strong>ScheduledExecutorService函数列表</strong></p>\n<pre><code class=\"Java\">// 创建并执行在给定延迟后启用的 ScheduledFuture。\n&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)\n// 创建并执行在给定延迟后启用的一次性操作。\nScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\nScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\nScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n</code></pre>\n</blockquote>\n<h3 id=\"6-ScheduledThreadPoolExecutor\"><a href=\"#6-ScheduledThreadPoolExecutor\" class=\"headerlink\" title=\"6. ScheduledThreadPoolExecutor\"></a>6. <strong>ScheduledThreadPoolExecutor</strong></h3><blockquote>\n<p>ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了”延时”和”周期执行”功能的ExecutorService。 ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。</p>\n<p>在没有此接口之前，我们使用Timer来做定时任务，Timer定时任务的缺陷：</p>\n<ol>\n<li>执行定时任务时，只创建一个线程，因此如果某个任务执行时间过长，会导致其他定时任务的执行周期加长</li>\n<li>由于只创建了一个线程，当这个线程因为异常关闭之后，其他定时任务就无法启动。（这个问题称之为线程泄漏）</li>\n</ol>\n<p>因此在5.0 之后很少使用这个类来做定时任务，换成了ScheduledThreadPoolExecutor来做定时任务。</p>\n<p>同时要构建自己的调度任务还需要队列的支持，这时可以使用DelayQueue，他实现了BlockingQueue，并为ScheduledThreadPoolExecutor提供调度功能，DelayQUeue管理者一组Delayed对象，每个Delayed对象都有一个相应的延迟时间。在DelayQueue中，只有某个元素逾期后，才能从这个队列中take操作。</p>\n<p>参数列表</p>\n<pre><code class=\"Java\">// 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize)\n// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler)\n// 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory)\n// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n\n// 修改或替换用于执行 callable 的任务。\nprotected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task)\n// 修改或替换用于执行 runnable 的任务。\nprotected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)\n// 使用所要求的零延迟执行命令。\nvoid execute(Runnable command)\n// 获取有关在此执行程序已 shutdown 的情况下、是否继续执行现有定期任务的策略。\nboolean getContinueExistingPeriodicTasksAfterShutdownPolicy()\n// 获取有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\nboolean getExecuteExistingDelayedTasksAfterShutdownPolicy()\n// 返回此执行程序使用的任务队列。\nBlockingQueue&lt;Runnable&gt; getQueue()\n// 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。\nboolean remove(Runnable task)\n// 创建并执行在给定延迟后启用的 ScheduledFuture。\n&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)\n// 创建并执行在给定延迟后启用的一次性操作。\nScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\nScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\nScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有定期任务的策略。\nvoid setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)\n// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\nvoid setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)\n// 在以前已提交任务的执行中发起一个有序的关闭，但是不接受新任务。\nvoid shutdown()\n// 尝试停止所有正在执行的任务、暂停等待任务的处理，并返回等待执行的任务列表。\nList&lt;Runnable&gt; shutdownNow()\n// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\nFuture&lt;?&gt; submit(Runnable task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)\n</code></pre>\n</blockquote>\n<h3 id=\"7-Executors\"><a href=\"#7-Executors\" class=\"headerlink\" title=\"7. Executors\"></a>7. Executors</h3><blockquote>\n<p>Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。</p>\n<pre><code class=\"java\">// 返回 Callable 对象，调用它时可运行给定特权的操作并返回其结果。\nstatic Callable&lt;Object&gt; callable(PrivilegedAction&lt;?&gt; action)\n// 返回 Callable 对象，调用它时可运行给定特权的异常操作并返回其结果。\nstatic Callable&lt;Object&gt; callable(PrivilegedExceptionAction&lt;?&gt; action)\n// 返回 Callable 对象，调用它时可运行给定的任务并返回 null。\nstatic Callable&lt;Object&gt; callable(Runnable task)\n// 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果。\nstatic &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)\n// 返回用于创建新线程的默认线程工厂。\nstatic ThreadFactory defaultThreadFactory()\n// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。\nstatic ExecutorService newCachedThreadPool()\n// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。\nstatic ExecutorService newCachedThreadPool(ThreadFactory threadFactory)\n// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。\nstatic ExecutorService newFixedThreadPool(int nThreads)\n// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。\nstatic ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)\n// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)\n// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。\nstatic ExecutorService newSingleThreadExecutor()\n// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，并在需要时使用提供的 ThreadFactory 创建新线程。\nstatic ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)\n// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newSingleThreadScheduledExecutor()\n// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)\n// 返回 Callable 对象，调用它时可在当前的访问控制上下文中执行给定的 callable 对象。\nstatic &lt;T&gt; Callable&lt;T&gt; privilegedCallable(Callable&lt;T&gt; callable)\n// 返回 Callable 对象，调用它时可在当前的访问控制上下文中，使用当前上下文类加载器作为上下文类加载器来执行给定的 callable 对象。\nstatic &lt;T&gt; Callable&lt;T&gt; privilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; callable)\n// 返回用于创建新线程的线程工厂，这些新线程与当前线程具有相同的权限。\nstatic ThreadFactory privilegedThreadFactory()\n// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\nstatic ExecutorService unconfigurableExecutorService(ExecutorService executor)\n// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\nstatic ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)\n</code></pre>\n</blockquote>\n</blockquote>\n<h3 id=\"2-简单示例\"><a href=\"#2-简单示例\" class=\"headerlink\" title=\"2. 简单示例\"></a>2. 简单示例</h3><blockquote>\n<pre><code class=\"java\">import java.util.concurrent.Executors;\nimport java.util.concurrent.ExecutorService;\n\npublic class ThreadPoolDemo1 {\n\n   public static void main(String[] args) {\n       // 创建一个可重用固定线程数的线程池\n       ExecutorService pool = Executors.newFixedThreadPool(2);\n       // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n       Thread ta = new MyThread();\n       Thread tb = new MyThread();\n       Thread tc = new MyThread();\n       Thread td = new MyThread();\n       Thread te = new MyThread();\n       // 将线程放入池中进行执行\n       pool.execute(ta);\n       pool.execute(tb);\n       pool.execute(tc);\n       pool.execute(td);\n       pool.execute(te);\n       // 关闭线程池\n       pool.shutdown();\n   }\n}\n\nclass MyThread extends Thread {\n\n   @Override\n   public void run() {\n       System.out.println(Thread.currentThread().getName()+ &quot; is running.&quot;);\n   }\n}\n</code></pre>\n<p><strong>运行结果</strong>：</p>\n<pre><code>pool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\n</code></pre><p><strong>结果说明</strong>：<br>主线程中创建了线程池pool，线程池的容量是2。即，线程池中最多能同时运行2个线程。<br>紧接着，将ta,tb,tc,td,te这3个线程添加到线程池中运行。<br>最后，通过shutdown()关闭线程池。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-JUC线程池之-01-线程池架构\"><a href=\"#java多线程系列-JUC线程池之-01-线程池架构\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之 01 线程池架构\"></a>java多线程系列-JUC线程池之 01 线程池架构</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>线程池整体架构介绍</li>\n<li>简单示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程池整体架构介绍\"><a href=\"#1-线程池整体架构介绍\" class=\"headerlink\" title=\"1. 线程池整体架构介绍\"></a>1. 线程池整体架构介绍</h3><blockquote>\n<h3 id=\"1-Executor\"><a href=\"#1-Executor\" class=\"headerlink\" title=\"1. Executor\"></a>1. Executor</h3><blockquote>\n<p>Executor将任务的执行和任务的创建分离开来。他提供了执行的接口，是来执行任务的。只要提交的任务实现了Runnable接口，就可以将此任务交给Executor来执行，这个接口只包含一个函数，代码如下:</p>\n<pre><code>public interface Executor{\n    //在未来执行给定的任务\n    void    execute(Runnable command)\n}\n</code></pre></blockquote>\n<h3 id=\"2-ExecutorService\"><a href=\"#2-ExecutorService\" class=\"headerlink\" title=\"2. ExecutorService\"></a>2. ExecutorService</h3><blockquote>\n<p>现在可以通过Executor来实现任务的运行。通常Executor的实现通常会创建线程来执行任务。但JVM只有在所有非守护线程全部终止后才会退出，因此如果无法正确的关闭Executor，那么JVM将无法结束。</p>\n<p>关闭任务的方式：</p>\n<ol>\n<li>直接关闭，相当于断开电源</li>\n<li>执行完所有当前线程上执行的任务，不在接收新的任务。然后关闭</li>\n</ol>\n<p>此时Executor接口定义的方法不足以满足这些要求的实现，所以有了ExecutorService接口。添加了一些用于生命周期管理的方法（同时还有一些用于任务提交的便利方法）：</p>\n<pre><code class=\"java\">// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。\nboolean awaitTermination(long timeout, TimeUnit unit)\n\n// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。\n&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)\n// 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。\n&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)\n// 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。\n&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)\n// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。\n&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)\n\n\n// 如果此执行程序已关闭，则返回 true。\nboolean isShutdown()\n// 如果关闭后所有任务都已完成，则返回 true。\nboolean isTerminated()\n\n\n// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。\nvoid shutdown()\n// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。\nList&lt;Runnable&gt; shutdownNow()\n\n\n// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\nFuture&lt;?&gt; submit(Runnable task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)\n</code></pre>\n<p>ExecutorService的生命周期有三种状态：运行、关闭和已终止。</p>\n<ol>\n<li><p>在初始创建时处于运行状态，</p>\n</li>\n<li><p>shutdown方法将执行平缓的关闭状态：不在接收新的任务，同时等待已经提交的任务执行完成，包括那些还未开始执行的任务</p>\n</li>\n<li><p>shutdownNow方法将执行粗暴的关闭过程，将尝试取消所有运行中的任务。</p>\n<p>通过isTerminated来确定线程池是否终止，终止后不同拒绝策略有不同的返回结果的方式。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"3-AbstractExecutorService\"><a href=\"#3-AbstractExecutorService\" class=\"headerlink\" title=\"3. AbstractExecutorService\"></a><strong>3. AbstractExecutorService</strong></h3><blockquote>\n<p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。方便我们定制线程池。这个类的方法和ExecutorService一样，所有就不列出来，后面再分析线程池源码时我会在来说这个类。</p>\n</blockquote>\n<h3 id=\"4-ThreadPoolExecutor\"><a href=\"#4-ThreadPoolExecutor\" class=\"headerlink\" title=\"4.ThreadPoolExecutor\"></a>4.<strong>ThreadPoolExecutor</strong></h3><blockquote>\n<p>ThreadPoolExecutor就是大名鼎鼎的”线程池”，它继承于AbstractExecutorService抽象类。是线程池的主要实现类，也是我们后面关注的重点，因此就现在这里提一下，后面会仔细讲。</p>\n</blockquote>\n<h3 id=\"5-ScheduledExecutorService\"><a href=\"#5-ScheduledExecutorService\" class=\"headerlink\" title=\"5. ScheduledExecutorService\"></a>5. <strong>ScheduledExecutorService</strong></h3><blockquote>\n<p>ScheduledExecutorService是一个接口，它继承于于ExecutorService。它相当于提供了”延时”和”周期执行”功能的ExecutorService。 ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。</p>\n<p><strong>ScheduledExecutorService函数列表</strong></p>\n<pre><code class=\"Java\">// 创建并执行在给定延迟后启用的 ScheduledFuture。\n&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)\n// 创建并执行在给定延迟后启用的一次性操作。\nScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\nScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\nScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n</code></pre>\n</blockquote>\n<h3 id=\"6-ScheduledThreadPoolExecutor\"><a href=\"#6-ScheduledThreadPoolExecutor\" class=\"headerlink\" title=\"6. ScheduledThreadPoolExecutor\"></a>6. <strong>ScheduledThreadPoolExecutor</strong></h3><blockquote>\n<p>ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了”延时”和”周期执行”功能的ExecutorService。 ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。</p>\n<p>在没有此接口之前，我们使用Timer来做定时任务，Timer定时任务的缺陷：</p>\n<ol>\n<li>执行定时任务时，只创建一个线程，因此如果某个任务执行时间过长，会导致其他定时任务的执行周期加长</li>\n<li>由于只创建了一个线程，当这个线程因为异常关闭之后，其他定时任务就无法启动。（这个问题称之为线程泄漏）</li>\n</ol>\n<p>因此在5.0 之后很少使用这个类来做定时任务，换成了ScheduledThreadPoolExecutor来做定时任务。</p>\n<p>同时要构建自己的调度任务还需要队列的支持，这时可以使用DelayQueue，他实现了BlockingQueue，并为ScheduledThreadPoolExecutor提供调度功能，DelayQUeue管理者一组Delayed对象，每个Delayed对象都有一个相应的延迟时间。在DelayQueue中，只有某个元素逾期后，才能从这个队列中take操作。</p>\n<p>参数列表</p>\n<pre><code class=\"Java\">// 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize)\n// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler)\n// 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory)\n// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。\nScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n\n// 修改或替换用于执行 callable 的任务。\nprotected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task)\n// 修改或替换用于执行 runnable 的任务。\nprotected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)\n// 使用所要求的零延迟执行命令。\nvoid execute(Runnable command)\n// 获取有关在此执行程序已 shutdown 的情况下、是否继续执行现有定期任务的策略。\nboolean getContinueExistingPeriodicTasksAfterShutdownPolicy()\n// 获取有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\nboolean getExecuteExistingDelayedTasksAfterShutdownPolicy()\n// 返回此执行程序使用的任务队列。\nBlockingQueue&lt;Runnable&gt; getQueue()\n// 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。\nboolean remove(Runnable task)\n// 创建并执行在给定延迟后启用的 ScheduledFuture。\n&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)\n// 创建并执行在给定延迟后启用的一次性操作。\nScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。\nScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)\n// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。\nScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)\n// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有定期任务的策略。\nvoid setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)\n// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。\nvoid setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)\n// 在以前已提交任务的执行中发起一个有序的关闭，但是不接受新任务。\nvoid shutdown()\n// 尝试停止所有正在执行的任务、暂停等待任务的处理，并返回等待执行的任务列表。\nList&lt;Runnable&gt; shutdownNow()\n// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\nFuture&lt;?&gt; submit(Runnable task)\n// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)\n</code></pre>\n</blockquote>\n<h3 id=\"7-Executors\"><a href=\"#7-Executors\" class=\"headerlink\" title=\"7. Executors\"></a>7. Executors</h3><blockquote>\n<p>Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。</p>\n<pre><code class=\"java\">// 返回 Callable 对象，调用它时可运行给定特权的操作并返回其结果。\nstatic Callable&lt;Object&gt; callable(PrivilegedAction&lt;?&gt; action)\n// 返回 Callable 对象，调用它时可运行给定特权的异常操作并返回其结果。\nstatic Callable&lt;Object&gt; callable(PrivilegedExceptionAction&lt;?&gt; action)\n// 返回 Callable 对象，调用它时可运行给定的任务并返回 null。\nstatic Callable&lt;Object&gt; callable(Runnable task)\n// 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果。\nstatic &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)\n// 返回用于创建新线程的默认线程工厂。\nstatic ThreadFactory defaultThreadFactory()\n// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。\nstatic ExecutorService newCachedThreadPool()\n// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。\nstatic ExecutorService newCachedThreadPool(ThreadFactory threadFactory)\n// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。\nstatic ExecutorService newFixedThreadPool(int nThreads)\n// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。\nstatic ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)\n// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)\n// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。\nstatic ExecutorService newSingleThreadExecutor()\n// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，并在需要时使用提供的 ThreadFactory 创建新线程。\nstatic ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)\n// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newSingleThreadScheduledExecutor()\n// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。\nstatic ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)\n// 返回 Callable 对象，调用它时可在当前的访问控制上下文中执行给定的 callable 对象。\nstatic &lt;T&gt; Callable&lt;T&gt; privilegedCallable(Callable&lt;T&gt; callable)\n// 返回 Callable 对象，调用它时可在当前的访问控制上下文中，使用当前上下文类加载器作为上下文类加载器来执行给定的 callable 对象。\nstatic &lt;T&gt; Callable&lt;T&gt; privilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; callable)\n// 返回用于创建新线程的线程工厂，这些新线程与当前线程具有相同的权限。\nstatic ThreadFactory privilegedThreadFactory()\n// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\nstatic ExecutorService unconfigurableExecutorService(ExecutorService executor)\n// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。\nstatic ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)\n</code></pre>\n</blockquote>\n</blockquote>\n<h3 id=\"2-简单示例\"><a href=\"#2-简单示例\" class=\"headerlink\" title=\"2. 简单示例\"></a>2. 简单示例</h3><blockquote>\n<pre><code class=\"java\">import java.util.concurrent.Executors;\nimport java.util.concurrent.ExecutorService;\n\npublic class ThreadPoolDemo1 {\n\n   public static void main(String[] args) {\n       // 创建一个可重用固定线程数的线程池\n       ExecutorService pool = Executors.newFixedThreadPool(2);\n       // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n       Thread ta = new MyThread();\n       Thread tb = new MyThread();\n       Thread tc = new MyThread();\n       Thread td = new MyThread();\n       Thread te = new MyThread();\n       // 将线程放入池中进行执行\n       pool.execute(ta);\n       pool.execute(tb);\n       pool.execute(tc);\n       pool.execute(td);\n       pool.execute(te);\n       // 关闭线程池\n       pool.shutdown();\n   }\n}\n\nclass MyThread extends Thread {\n\n   @Override\n   public void run() {\n       System.out.println(Thread.currentThread().getName()+ &quot; is running.&quot;);\n   }\n}\n</code></pre>\n<p><strong>运行结果</strong>：</p>\n<pre><code>pool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\n</code></pre><p><strong>结果说明</strong>：<br>主线程中创建了线程池pool，线程池的容量是2。即，线程池中最多能同时运行2个线程。<br>紧接着，将ta,tb,tc,td,te这3个线程添加到线程池中运行。<br>最后，通过shutdown()关闭线程池。</p>\n</blockquote>\n"},{"abbrlink":10,"title":"java多线程系列-JUC线程池之04 Future 和Callable","author":"zhangke","date":"2018-07-24T07:12:00.000Z","_content":"# java多线程系列-JUC线程池之04 Future 和Callable\n\n### 概要\n\n>1. Callable和Future简介\n>2. ThreadPoolExecutor中submit分析\n>3. FutureTask源码分析\n\n### 1. Callable 和 Future 简介\n\n>Executor框架使用Runnable作为其基本的任务表示形式。Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。\n>\n>许多任务实际上都是存在延迟的计算—执行数据库插叙，从网络上获取资源，或者计算某个复杂的功能，对于这些任务，Callable是一种更好的抽象：他认为主入口点（即call）将返回一个值，并可能抛出一个异常。\n>\n>在Executor中包含了一些辅助的方法能将其他类型的任务封装为一个Callabe。\n>\n>Runnable和Callable描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确的起始点，并且最终会结束。Executor执行的任务有4个声明周期阶段：创建、提交、开始和完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于哪些已经开始执行的任务，只能当他们响应中断时，才能取消。\n>\n>Future表示一个任务额声明周期，并定义相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。并且在Future规范中的隐含意义是，任务声明周期只能前进，不能后退，就像ExecutorService的生命周期一样。当某个任务完成后，他就永远停留在完成状态上。\n>\n>**1. Callable**\n>\n>Callable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。\n>\n>为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。\n>\n>Callable的源码如下：\n>\n>```\n>public interface Callable<V> {\n>    V call() throws Exception;\n>}\n>```\n>\n>**说明**：从中我们可以看出Callable支持泛型。 \n>\n>**2. Future**\n>\n>Future 是一个接口。它用于表示异步计算的结果。提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。\n>\n>Future的源码如下：\n>\n>```java\n>public interface Future<V> {\n>    // 试图取消对此任务的执行。\n>    boolean     cancel(boolean mayInterruptIfRunning)\n>\n>    // 如果在任务正常完成前将其取消，则返回 true。\n>    boolean     isCancelled()\n>\n>    // 如果任务已完成，则返回 true。\n>    boolean     isDone()\n>\n>    // 如有必要，等待计算完成，然后获取其结果。\n>    V           get() throws InterruptedException, ExecutionException;\n>\n>    // 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。\n>    V       get(long timeout, TimeUnit unit)\n>          throws InterruptedException, ExecutionException, TimeoutException;\n>}\n>```\n\n### 2. ThreadPoolExecutor中submit分析\n\n>前面我们已经对ThreadPoolExecutor中execute进行了分析，在execute中执行的任务是没有返回结果。这在很大程度上限制了这个方法的使用，因此在ExecutorService中提供了submit方法，可以在任务执行完成后返回结果，这个方法有三个重载方法，源码如下：\n>\n>```java\n>\t//执行Runnable接口，返回一个没有任何结果的Future\n>    public Future<?> submit(Runnable task) {\n>        if (task == null) throw new NullPointerException();\n>        RunnableFuture<Void> ftask = newTaskFor(task, null);\n>        execute(ftask);\n>        return ftask;\n>    }\n>\t//执行Runnable接口，并返回一个带有result结果的Future\n>    public <T> Future<T> submit(Runnable task, T result) {\n>        if (task == null) throw new NullPointerException();\n>        RunnableFuture<T> ftask = newTaskFor(task, result);\n>        execute(ftask);\n>        return ftask;\n>    }\n>\t\n>   \t//执行Callable接口，并返回Future对象\n>    public <T> Future<T> submit(Callable<T> task) {\n>        if (task == null) throw new NullPointerException();\n>        RunnableFuture<T> ftask = newTaskFor(task);\n>        execute(ftask);\n>        return ftask;\n>    }\n>```\n>\n>通过看上面的代码，大体上代码的结构都是相同的，首先通过newTaskFor方法创建一个RunnableFuture对象，然后使用execute执行这个任务。\n>\n>下面我们看一下newTaskFor这个方法，这个方法也包括俩个重载的方法，源码如下\n>\n>```java\n>protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {\n>     return new FutureTask<T>(runnable, value);\n>}\n>\n> protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n>      return new FutureTask<T>(callable);\n>}\n>```\n>\n>这个方法是将提供的Runnable和Callable接口封装在FutureTask内，然后返回一个RunnableFuture对象，事实上，FutureTask实现了RunnablFuture这个接口。\n\n###3.  FutureTask源码分析\n\n>Future继承体系如下\n>\n>![]()\n>\n>Future表示一个任务的状态有以下几种，\n>\n>```\n>NEW      ：任务新创建状态   \n>COMPLETING  ：任务完成状态\n>NORMAL \t\t：正常完成状态\n>EXCEPTIONAL ：异常完成状态\n>CANCELLED    ：取消状态\n>INTERRUPTING ：正在中断状态\n>INTERRUPTED  ：已经被中断状态\n>```\n>\n>状态只能从一个状态转变到另外一个状态，不能后退，状态的转换大致上有以下几种：\n>\n>```\n>NEW -> COMPLETING -> NORMAL\n>NEW -> COMPLETING -> EXCEPTIONAL\n>NEW -> CANCELLED\n>NEW -> INTERRUPTING -> INTERRUPTED\n>```\n>\n>### FutureTask构造函数\n>\n>```java\n>public FutureTask(Callable<V> callable) {\n>    if (callable == null)\n>        throw new NullPointerException();\n>    // callable是一个Callable对象\n>    this.callable = callable;\n>    // state记录FutureTask的状态\n>    this.state = NEW;       // ensure visibility of callable\n>}\n>\n>public FutureTask(Runnable runnable, V result) {\n>    \t//将给定的runnable接口封装成Callable类，\n>        this.callable = Executors.callable(runnable, result);\n>        this.state = NEW;       // ensure visibility of callable\n>}\n>\n>```\n>\n>### FutureTask中run函数\n>\n>在newTaskFor()新建一个ftask对象之后，会通过execute(ftask)执行该任务。此时ftask被当作一个Runnable对象进行执行，最终会调用到它的run()方法:源码如下：\n>\n>```java\n>public void run() {\n>    //判断当前任务的状态\n>    if (state != NEW ||\n>        !UNSAFE.compareAndSwapObject(this, runnerOffset,\n>                                     null, Thread.currentThread()))\n>        return;\n>    try {\n>        // 将callable对象赋值给c。\n>        Callable<V> c = callable;\n>        if (c != null && state == NEW) {\n>            V result;\n>            boolean ran;\n>            try {\n>                // 执行Callable的call()方法，并保存结果到result中。\n>                result = c.call();\n>                ran = true;\n>            } catch (Throwable ex) {\n>                result = null;\n>                ran = false;\n>                setException(ex);\n>            }\n>            // 如果运行成功，则将result保存\n>            if (ran)\n>                set(result);\n>        }\n>    } finally {\n>        runner = null;\n>        // 设置“state状态标记”\n>        int s = state;\n>        if (s >= INTERRUPTING)\n>            handlePossibleCancellationInterrupt(s);\n>    }\n>}\n>```\n>\n>**说明**：run()中会执行Callable对象的call()方法，并且最终将结果保存到result中，并通过set(result)将result保存。 之后调用FutureTask的get()方法，返回的就是通过set(result)保存的值。\n>\n>### FutureTask中get函数\n>\n>get是用来得到任务执行的结果，如果任务没有执行完成，就会暂停当前任务的执行\n>\n>```java\n> public V get() throws InterruptedException, ExecutionException {\n>        int s = state;\n>        if (s <= COMPLETING)\n>            s = awaitDone(false, 0L);\n>        return report(s);\n>    }\n>\n>```\n>\n>从上面代码可以看出，get是调用awaitDone来阻塞当前线程。源码如下\n>\n>```java\n>    private int awaitDone(boolean timed, long nanos)\n>        throws InterruptedException {\n>        //得到截止时间\n>        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n>        WaitNode q = null;\n>        boolean queued = false;\n>        //循环判断，知道任务执行完成\n>        for (;;) {\n>            //删除中断的等待结果返回线程\n>            if (Thread.interrupted()) {\n>                removeWaiter(q);\n>                throw new InterruptedException();\n>            }\n>\n>            //得到任务状态\n>            int s = state;\n>            //如果是以完成状态，则返回结果\n>            if (s > COMPLETING) {\n>                if (q != null)\n>                    q.thread = null;\n>                return s;\n>            }\n>            //如果是正在执行状态，当前线程让出cpu\n>            else if (s == COMPLETING) // cannot time out yet\n>                Thread.yield();\n>            //创建新的等待节点\n>            else if (q == null)\n>                q = new WaitNode();\n>            //将等待节点插入等待队列\n>            else if (!queued)\n>                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n>                                                     q.next = waiters, q);\n>            //如果是有等待时间限制的\n>            else if (timed) {\n>                nanos = deadline - System.nanoTime();\n>                //过了等待时间，则删除等待对应的等待节点\n>                if (nanos <= 0L) {\n>                    removeWaiter(q);\n>                    return state;\n>                }\n>                //阻塞当前线程\n>                LockSupport.parkNanos(this, nanos);\n>            }\n>            else\n>                LockSupport.park(this);\n>        }\n>    }\n>```\n>\n>分析：\n>\n>上面代码可以阻塞调用线程的执行，但是线程的唤醒是不在这里面的。其实这样设计是对的，任务是否执行完成，Future是无法决定的，只要执行这个任务的线程才知道，所以就把唤醒线程的代码放在run方法里面，但是为什么刚刚没有在run里面看到呢，是因为封装在finishCompletion这个方法里面，而这个方法的调用是由set和setExecption俩个方法调用，源码如下：\n>\n>```java\n>\t//任务执行完成，设置执行结果，并设置当前任务状态   \n>protected void set(V v) {\n>        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n>            outcome = v;\n>            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n>            //唤醒所有等待的此任务完成的线程\n>            finishCompletion();\n>        }\n>    }\n>\t//此方法和上面的set方法执行流程一样，只是改变当前任务的状态时异常状态\n>    protected void setException(Throwable t) {\n>        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n>            outcome = t;\n>            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n>            finishCompletion();\n>        }\n>    }\n>\t//唤醒锁等带此任务执行完成的线程\n>    private void finishCompletion() {\n>        // assert state > COMPLETING;\n>        for (WaitNode q; (q = waiters) != null;) {\n>            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n>                for (;;) {\n>                    Thread t = q.thread;\n>                    if (t != null) {\n>                        q.thread = null;\n>                        LockSupport.unpark(t);\n>                    }\n>                    WaitNode next = q.next;\n>                    if (next == null)\n>                        break;\n>                    q.next = null; // unlink to help gc\n>                    q = next;\n>                }\n>                break;\n>            }\n>        }\n>\t\t//这个方法是一个空方法，如果希望任务执行完成后调用一个类似于callback回调，继承此类，\n>        //然后封装此方法\n>        done();\n>\n>        callable = null;        // to reduce footprint\n>    }\n>```\n>\n>\n>\n>\n\n","source":"_posts/java多线程系列-JUC线程池之04 Future 和Callable.md","raw":"abbrlink: 10\ntitle: java多线程系列-JUC线程池之04 Future 和Callable\ntags:\n  - 线程池\n  - JUC\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-24 15:12:00\n---\n# java多线程系列-JUC线程池之04 Future 和Callable\n\n### 概要\n\n>1. Callable和Future简介\n>2. ThreadPoolExecutor中submit分析\n>3. FutureTask源码分析\n\n### 1. Callable 和 Future 简介\n\n>Executor框架使用Runnable作为其基本的任务表示形式。Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。\n>\n>许多任务实际上都是存在延迟的计算—执行数据库插叙，从网络上获取资源，或者计算某个复杂的功能，对于这些任务，Callable是一种更好的抽象：他认为主入口点（即call）将返回一个值，并可能抛出一个异常。\n>\n>在Executor中包含了一些辅助的方法能将其他类型的任务封装为一个Callabe。\n>\n>Runnable和Callable描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确的起始点，并且最终会结束。Executor执行的任务有4个声明周期阶段：创建、提交、开始和完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于哪些已经开始执行的任务，只能当他们响应中断时，才能取消。\n>\n>Future表示一个任务额声明周期，并定义相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。并且在Future规范中的隐含意义是，任务声明周期只能前进，不能后退，就像ExecutorService的生命周期一样。当某个任务完成后，他就永远停留在完成状态上。\n>\n>**1. Callable**\n>\n>Callable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。\n>\n>为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。\n>\n>Callable的源码如下：\n>\n>```\n>public interface Callable<V> {\n>    V call() throws Exception;\n>}\n>```\n>\n>**说明**：从中我们可以看出Callable支持泛型。 \n>\n>**2. Future**\n>\n>Future 是一个接口。它用于表示异步计算的结果。提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。\n>\n>Future的源码如下：\n>\n>```java\n>public interface Future<V> {\n>    // 试图取消对此任务的执行。\n>    boolean     cancel(boolean mayInterruptIfRunning)\n>\n>    // 如果在任务正常完成前将其取消，则返回 true。\n>    boolean     isCancelled()\n>\n>    // 如果任务已完成，则返回 true。\n>    boolean     isDone()\n>\n>    // 如有必要，等待计算完成，然后获取其结果。\n>    V           get() throws InterruptedException, ExecutionException;\n>\n>    // 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。\n>    V       get(long timeout, TimeUnit unit)\n>          throws InterruptedException, ExecutionException, TimeoutException;\n>}\n>```\n\n### 2. ThreadPoolExecutor中submit分析\n\n>前面我们已经对ThreadPoolExecutor中execute进行了分析，在execute中执行的任务是没有返回结果。这在很大程度上限制了这个方法的使用，因此在ExecutorService中提供了submit方法，可以在任务执行完成后返回结果，这个方法有三个重载方法，源码如下：\n>\n>```java\n>\t//执行Runnable接口，返回一个没有任何结果的Future\n>    public Future<?> submit(Runnable task) {\n>        if (task == null) throw new NullPointerException();\n>        RunnableFuture<Void> ftask = newTaskFor(task, null);\n>        execute(ftask);\n>        return ftask;\n>    }\n>\t//执行Runnable接口，并返回一个带有result结果的Future\n>    public <T> Future<T> submit(Runnable task, T result) {\n>        if (task == null) throw new NullPointerException();\n>        RunnableFuture<T> ftask = newTaskFor(task, result);\n>        execute(ftask);\n>        return ftask;\n>    }\n>\t\n>   \t//执行Callable接口，并返回Future对象\n>    public <T> Future<T> submit(Callable<T> task) {\n>        if (task == null) throw new NullPointerException();\n>        RunnableFuture<T> ftask = newTaskFor(task);\n>        execute(ftask);\n>        return ftask;\n>    }\n>```\n>\n>通过看上面的代码，大体上代码的结构都是相同的，首先通过newTaskFor方法创建一个RunnableFuture对象，然后使用execute执行这个任务。\n>\n>下面我们看一下newTaskFor这个方法，这个方法也包括俩个重载的方法，源码如下\n>\n>```java\n>protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {\n>     return new FutureTask<T>(runnable, value);\n>}\n>\n> protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n>      return new FutureTask<T>(callable);\n>}\n>```\n>\n>这个方法是将提供的Runnable和Callable接口封装在FutureTask内，然后返回一个RunnableFuture对象，事实上，FutureTask实现了RunnablFuture这个接口。\n\n###3.  FutureTask源码分析\n\n>Future继承体系如下\n>\n>![]()\n>\n>Future表示一个任务的状态有以下几种，\n>\n>```\n>NEW      ：任务新创建状态   \n>COMPLETING  ：任务完成状态\n>NORMAL \t\t：正常完成状态\n>EXCEPTIONAL ：异常完成状态\n>CANCELLED    ：取消状态\n>INTERRUPTING ：正在中断状态\n>INTERRUPTED  ：已经被中断状态\n>```\n>\n>状态只能从一个状态转变到另外一个状态，不能后退，状态的转换大致上有以下几种：\n>\n>```\n>NEW -> COMPLETING -> NORMAL\n>NEW -> COMPLETING -> EXCEPTIONAL\n>NEW -> CANCELLED\n>NEW -> INTERRUPTING -> INTERRUPTED\n>```\n>\n>### FutureTask构造函数\n>\n>```java\n>public FutureTask(Callable<V> callable) {\n>    if (callable == null)\n>        throw new NullPointerException();\n>    // callable是一个Callable对象\n>    this.callable = callable;\n>    // state记录FutureTask的状态\n>    this.state = NEW;       // ensure visibility of callable\n>}\n>\n>public FutureTask(Runnable runnable, V result) {\n>    \t//将给定的runnable接口封装成Callable类，\n>        this.callable = Executors.callable(runnable, result);\n>        this.state = NEW;       // ensure visibility of callable\n>}\n>\n>```\n>\n>### FutureTask中run函数\n>\n>在newTaskFor()新建一个ftask对象之后，会通过execute(ftask)执行该任务。此时ftask被当作一个Runnable对象进行执行，最终会调用到它的run()方法:源码如下：\n>\n>```java\n>public void run() {\n>    //判断当前任务的状态\n>    if (state != NEW ||\n>        !UNSAFE.compareAndSwapObject(this, runnerOffset,\n>                                     null, Thread.currentThread()))\n>        return;\n>    try {\n>        // 将callable对象赋值给c。\n>        Callable<V> c = callable;\n>        if (c != null && state == NEW) {\n>            V result;\n>            boolean ran;\n>            try {\n>                // 执行Callable的call()方法，并保存结果到result中。\n>                result = c.call();\n>                ran = true;\n>            } catch (Throwable ex) {\n>                result = null;\n>                ran = false;\n>                setException(ex);\n>            }\n>            // 如果运行成功，则将result保存\n>            if (ran)\n>                set(result);\n>        }\n>    } finally {\n>        runner = null;\n>        // 设置“state状态标记”\n>        int s = state;\n>        if (s >= INTERRUPTING)\n>            handlePossibleCancellationInterrupt(s);\n>    }\n>}\n>```\n>\n>**说明**：run()中会执行Callable对象的call()方法，并且最终将结果保存到result中，并通过set(result)将result保存。 之后调用FutureTask的get()方法，返回的就是通过set(result)保存的值。\n>\n>### FutureTask中get函数\n>\n>get是用来得到任务执行的结果，如果任务没有执行完成，就会暂停当前任务的执行\n>\n>```java\n> public V get() throws InterruptedException, ExecutionException {\n>        int s = state;\n>        if (s <= COMPLETING)\n>            s = awaitDone(false, 0L);\n>        return report(s);\n>    }\n>\n>```\n>\n>从上面代码可以看出，get是调用awaitDone来阻塞当前线程。源码如下\n>\n>```java\n>    private int awaitDone(boolean timed, long nanos)\n>        throws InterruptedException {\n>        //得到截止时间\n>        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n>        WaitNode q = null;\n>        boolean queued = false;\n>        //循环判断，知道任务执行完成\n>        for (;;) {\n>            //删除中断的等待结果返回线程\n>            if (Thread.interrupted()) {\n>                removeWaiter(q);\n>                throw new InterruptedException();\n>            }\n>\n>            //得到任务状态\n>            int s = state;\n>            //如果是以完成状态，则返回结果\n>            if (s > COMPLETING) {\n>                if (q != null)\n>                    q.thread = null;\n>                return s;\n>            }\n>            //如果是正在执行状态，当前线程让出cpu\n>            else if (s == COMPLETING) // cannot time out yet\n>                Thread.yield();\n>            //创建新的等待节点\n>            else if (q == null)\n>                q = new WaitNode();\n>            //将等待节点插入等待队列\n>            else if (!queued)\n>                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n>                                                     q.next = waiters, q);\n>            //如果是有等待时间限制的\n>            else if (timed) {\n>                nanos = deadline - System.nanoTime();\n>                //过了等待时间，则删除等待对应的等待节点\n>                if (nanos <= 0L) {\n>                    removeWaiter(q);\n>                    return state;\n>                }\n>                //阻塞当前线程\n>                LockSupport.parkNanos(this, nanos);\n>            }\n>            else\n>                LockSupport.park(this);\n>        }\n>    }\n>```\n>\n>分析：\n>\n>上面代码可以阻塞调用线程的执行，但是线程的唤醒是不在这里面的。其实这样设计是对的，任务是否执行完成，Future是无法决定的，只要执行这个任务的线程才知道，所以就把唤醒线程的代码放在run方法里面，但是为什么刚刚没有在run里面看到呢，是因为封装在finishCompletion这个方法里面，而这个方法的调用是由set和setExecption俩个方法调用，源码如下：\n>\n>```java\n>\t//任务执行完成，设置执行结果，并设置当前任务状态   \n>protected void set(V v) {\n>        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n>            outcome = v;\n>            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n>            //唤醒所有等待的此任务完成的线程\n>            finishCompletion();\n>        }\n>    }\n>\t//此方法和上面的set方法执行流程一样，只是改变当前任务的状态时异常状态\n>    protected void setException(Throwable t) {\n>        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n>            outcome = t;\n>            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n>            finishCompletion();\n>        }\n>    }\n>\t//唤醒锁等带此任务执行完成的线程\n>    private void finishCompletion() {\n>        // assert state > COMPLETING;\n>        for (WaitNode q; (q = waiters) != null;) {\n>            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n>                for (;;) {\n>                    Thread t = q.thread;\n>                    if (t != null) {\n>                        q.thread = null;\n>                        LockSupport.unpark(t);\n>                    }\n>                    WaitNode next = q.next;\n>                    if (next == null)\n>                        break;\n>                    q.next = null; // unlink to help gc\n>                    q = next;\n>                }\n>                break;\n>            }\n>        }\n>\t\t//这个方法是一个空方法，如果希望任务执行完成后调用一个类似于callback回调，继承此类，\n>        //然后封装此方法\n>        done();\n>\n>        callable = null;        // to reduce footprint\n>    }\n>```\n>\n>\n>\n>\n\n","slug":"java多线程系列-JUC线程池之04 Future 和Callable","published":1,"updated":"2019-01-04T01:48:59.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx2w001jeb1uaq3x32b1","content":"<h1 id=\"java多线程系列-JUC线程池之04-Future-和Callable\"><a href=\"#java多线程系列-JUC线程池之04-Future-和Callable\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之04 Future 和Callable\"></a>java多线程系列-JUC线程池之04 Future 和Callable</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>Callable和Future简介</li>\n<li>ThreadPoolExecutor中submit分析</li>\n<li>FutureTask源码分析</li>\n</ol>\n</blockquote>\n<h3 id=\"1-Callable-和-Future-简介\"><a href=\"#1-Callable-和-Future-简介\" class=\"headerlink\" title=\"1. Callable 和 Future 简介\"></a>1. Callable 和 Future 简介</h3><blockquote>\n<p>Executor框架使用Runnable作为其基本的任务表示形式。Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。</p>\n<p>许多任务实际上都是存在延迟的计算—执行数据库插叙，从网络上获取资源，或者计算某个复杂的功能，对于这些任务，Callable是一种更好的抽象：他认为主入口点（即call）将返回一个值，并可能抛出一个异常。</p>\n<p>在Executor中包含了一些辅助的方法能将其他类型的任务封装为一个Callabe。</p>\n<p>Runnable和Callable描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确的起始点，并且最终会结束。Executor执行的任务有4个声明周期阶段：创建、提交、开始和完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于哪些已经开始执行的任务，只能当他们响应中断时，才能取消。</p>\n<p>Future表示一个任务额声明周期，并定义相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。并且在Future规范中的隐含意义是，任务声明周期只能前进，不能后退，就像ExecutorService的生命周期一样。当某个任务完成后，他就永远停留在完成状态上。</p>\n<p><strong>1. Callable</strong></p>\n<p>Callable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。</p>\n<p>为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。</p>\n<p>Callable的源码如下：</p>\n<pre><code>public interface Callable&lt;V&gt; {\n   V call() throws Exception;\n}\n</code></pre><p><strong>说明</strong>：从中我们可以看出Callable支持泛型。 </p>\n<p><strong>2. Future</strong></p>\n<p>Future 是一个接口。它用于表示异步计算的结果。提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。</p>\n<p>Future的源码如下：</p>\n<pre><code class=\"java\">public interface Future&lt;V&gt; {\n   // 试图取消对此任务的执行。\n   boolean     cancel(boolean mayInterruptIfRunning)\n\n   // 如果在任务正常完成前将其取消，则返回 true。\n   boolean     isCancelled()\n\n   // 如果任务已完成，则返回 true。\n   boolean     isDone()\n\n   // 如有必要，等待计算完成，然后获取其结果。\n   V           get() throws InterruptedException, ExecutionException;\n\n   // 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。\n   V       get(long timeout, TimeUnit unit)\n         throws InterruptedException, ExecutionException, TimeoutException;\n}\n</code></pre>\n</blockquote>\n<h3 id=\"2-ThreadPoolExecutor中submit分析\"><a href=\"#2-ThreadPoolExecutor中submit分析\" class=\"headerlink\" title=\"2. ThreadPoolExecutor中submit分析\"></a>2. ThreadPoolExecutor中submit分析</h3><blockquote>\n<p>前面我们已经对ThreadPoolExecutor中execute进行了分析，在execute中执行的任务是没有返回结果。这在很大程度上限制了这个方法的使用，因此在ExecutorService中提供了submit方法，可以在任务执行完成后返回结果，这个方法有三个重载方法，源码如下：</p>\n<pre><code class=\"java\">   //执行Runnable接口，返回一个没有任何结果的Future\n   public Future&lt;?&gt; submit(Runnable task) {\n       if (task == null) throw new NullPointerException();\n       RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);\n       execute(ftask);\n       return ftask;\n   }\n   //执行Runnable接口，并返回一个带有result结果的Future\n   public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {\n       if (task == null) throw new NullPointerException();\n       RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);\n       execute(ftask);\n       return ftask;\n   }\n\n      //执行Callable接口，并返回Future对象\n   public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {\n       if (task == null) throw new NullPointerException();\n       RunnableFuture&lt;T&gt; ftask = newTaskFor(task);\n       execute(ftask);\n       return ftask;\n   }\n</code></pre>\n<p>通过看上面的代码，大体上代码的结构都是相同的，首先通过newTaskFor方法创建一个RunnableFuture对象，然后使用execute执行这个任务。</p>\n<p>下面我们看一下newTaskFor这个方法，这个方法也包括俩个重载的方法，源码如下</p>\n<pre><code class=\"java\">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {\n    return new FutureTask&lt;T&gt;(runnable, value);\n}\n\nprotected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {\n     return new FutureTask&lt;T&gt;(callable);\n}\n</code></pre>\n<p>这个方法是将提供的Runnable和Callable接口封装在FutureTask内，然后返回一个RunnableFuture对象，事实上，FutureTask实现了RunnablFuture这个接口。</p>\n</blockquote>\n<p>###3.  FutureTask源码分析</p>\n<blockquote>\n<p>Future继承体系如下</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>Future表示一个任务的状态有以下几种，</p>\n<pre><code>NEW      ：任务新创建状态   \nCOMPLETING  ：任务完成状态\nNORMAL         ：正常完成状态\nEXCEPTIONAL ：异常完成状态\nCANCELLED    ：取消状态\nINTERRUPTING ：正在中断状态\nINTERRUPTED  ：已经被中断状态\n</code></pre><p>状态只能从一个状态转变到另外一个状态，不能后退，状态的转换大致上有以下几种：</p>\n<pre><code>NEW -&gt; COMPLETING -&gt; NORMAL\nNEW -&gt; COMPLETING -&gt; EXCEPTIONAL\nNEW -&gt; CANCELLED\nNEW -&gt; INTERRUPTING -&gt; INTERRUPTED\n</code></pre><h3 id=\"FutureTask构造函数\"><a href=\"#FutureTask构造函数\" class=\"headerlink\" title=\"FutureTask构造函数\"></a>FutureTask构造函数</h3><pre><code class=\"java\">public FutureTask(Callable&lt;V&gt; callable) {\n   if (callable == null)\n       throw new NullPointerException();\n   // callable是一个Callable对象\n   this.callable = callable;\n   // state记录FutureTask的状态\n   this.state = NEW;       // ensure visibility of callable\n}\n\npublic FutureTask(Runnable runnable, V result) {\n       //将给定的runnable接口封装成Callable类，\n       this.callable = Executors.callable(runnable, result);\n       this.state = NEW;       // ensure visibility of callable\n}\n\n</code></pre>\n<h3 id=\"FutureTask中run函数\"><a href=\"#FutureTask中run函数\" class=\"headerlink\" title=\"FutureTask中run函数\"></a>FutureTask中run函数</h3><p>在newTaskFor()新建一个ftask对象之后，会通过execute(ftask)执行该任务。此时ftask被当作一个Runnable对象进行执行，最终会调用到它的run()方法:源码如下：</p>\n<pre><code class=\"java\">public void run() {\n   //判断当前任务的状态\n   if (state != NEW ||\n       !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                    null, Thread.currentThread()))\n       return;\n   try {\n       // 将callable对象赋值给c。\n       Callable&lt;V&gt; c = callable;\n       if (c != null &amp;&amp; state == NEW) {\n           V result;\n           boolean ran;\n           try {\n               // 执行Callable的call()方法，并保存结果到result中。\n               result = c.call();\n               ran = true;\n           } catch (Throwable ex) {\n               result = null;\n               ran = false;\n               setException(ex);\n           }\n           // 如果运行成功，则将result保存\n           if (ran)\n               set(result);\n       }\n   } finally {\n       runner = null;\n       // 设置“state状态标记”\n       int s = state;\n       if (s &gt;= INTERRUPTING)\n           handlePossibleCancellationInterrupt(s);\n   }\n}\n</code></pre>\n<p><strong>说明</strong>：run()中会执行Callable对象的call()方法，并且最终将结果保存到result中，并通过set(result)将result保存。 之后调用FutureTask的get()方法，返回的就是通过set(result)保存的值。</p>\n<h3 id=\"FutureTask中get函数\"><a href=\"#FutureTask中get函数\" class=\"headerlink\" title=\"FutureTask中get函数\"></a>FutureTask中get函数</h3><p>get是用来得到任务执行的结果，如果任务没有执行完成，就会暂停当前任务的执行</p>\n<pre><code class=\"java\">public V get() throws InterruptedException, ExecutionException {\n       int s = state;\n       if (s &lt;= COMPLETING)\n           s = awaitDone(false, 0L);\n       return report(s);\n   }\n\n</code></pre>\n<p>从上面代码可以看出，get是调用awaitDone来阻塞当前线程。源码如下</p>\n<pre><code class=\"java\">   private int awaitDone(boolean timed, long nanos)\n       throws InterruptedException {\n       //得到截止时间\n       final long deadline = timed ? System.nanoTime() + nanos : 0L;\n       WaitNode q = null;\n       boolean queued = false;\n       //循环判断，知道任务执行完成\n       for (;;) {\n           //删除中断的等待结果返回线程\n           if (Thread.interrupted()) {\n               removeWaiter(q);\n               throw new InterruptedException();\n           }\n\n           //得到任务状态\n           int s = state;\n           //如果是以完成状态，则返回结果\n           if (s &gt; COMPLETING) {\n               if (q != null)\n                   q.thread = null;\n               return s;\n           }\n           //如果是正在执行状态，当前线程让出cpu\n           else if (s == COMPLETING) // cannot time out yet\n               Thread.yield();\n           //创建新的等待节点\n           else if (q == null)\n               q = new WaitNode();\n           //将等待节点插入等待队列\n           else if (!queued)\n               queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                    q.next = waiters, q);\n           //如果是有等待时间限制的\n           else if (timed) {\n               nanos = deadline - System.nanoTime();\n               //过了等待时间，则删除等待对应的等待节点\n               if (nanos &lt;= 0L) {\n                   removeWaiter(q);\n                   return state;\n               }\n               //阻塞当前线程\n               LockSupport.parkNanos(this, nanos);\n           }\n           else\n               LockSupport.park(this);\n       }\n   }\n</code></pre>\n<p>分析：</p>\n<p>上面代码可以阻塞调用线程的执行，但是线程的唤醒是不在这里面的。其实这样设计是对的，任务是否执行完成，Future是无法决定的，只要执行这个任务的线程才知道，所以就把唤醒线程的代码放在run方法里面，但是为什么刚刚没有在run里面看到呢，是因为封装在finishCompletion这个方法里面，而这个方法的调用是由set和setExecption俩个方法调用，源码如下：</p>\n<pre><code class=\"java\">   //任务执行完成，设置执行结果，并设置当前任务状态   \nprotected void set(V v) {\n       if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n           outcome = v;\n           UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n           //唤醒所有等待的此任务完成的线程\n           finishCompletion();\n       }\n   }\n   //此方法和上面的set方法执行流程一样，只是改变当前任务的状态时异常状态\n   protected void setException(Throwable t) {\n       if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n           outcome = t;\n           UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n           finishCompletion();\n       }\n   }\n   //唤醒锁等带此任务执行完成的线程\n   private void finishCompletion() {\n       // assert state &gt; COMPLETING;\n       for (WaitNode q; (q = waiters) != null;) {\n           if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n               for (;;) {\n                   Thread t = q.thread;\n                   if (t != null) {\n                       q.thread = null;\n                       LockSupport.unpark(t);\n                   }\n                   WaitNode next = q.next;\n                   if (next == null)\n                       break;\n                   q.next = null; // unlink to help gc\n                   q = next;\n               }\n               break;\n           }\n       }\n       //这个方法是一个空方法，如果希望任务执行完成后调用一个类似于callback回调，继承此类，\n       //然后封装此方法\n       done();\n\n       callable = null;        // to reduce footprint\n   }\n</code></pre>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-JUC线程池之04-Future-和Callable\"><a href=\"#java多线程系列-JUC线程池之04-Future-和Callable\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之04 Future 和Callable\"></a>java多线程系列-JUC线程池之04 Future 和Callable</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>Callable和Future简介</li>\n<li>ThreadPoolExecutor中submit分析</li>\n<li>FutureTask源码分析</li>\n</ol>\n</blockquote>\n<h3 id=\"1-Callable-和-Future-简介\"><a href=\"#1-Callable-和-Future-简介\" class=\"headerlink\" title=\"1. Callable 和 Future 简介\"></a>1. Callable 和 Future 简介</h3><blockquote>\n<p>Executor框架使用Runnable作为其基本的任务表示形式。Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。</p>\n<p>许多任务实际上都是存在延迟的计算—执行数据库插叙，从网络上获取资源，或者计算某个复杂的功能，对于这些任务，Callable是一种更好的抽象：他认为主入口点（即call）将返回一个值，并可能抛出一个异常。</p>\n<p>在Executor中包含了一些辅助的方法能将其他类型的任务封装为一个Callabe。</p>\n<p>Runnable和Callable描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确的起始点，并且最终会结束。Executor执行的任务有4个声明周期阶段：创建、提交、开始和完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于哪些已经开始执行的任务，只能当他们响应中断时，才能取消。</p>\n<p>Future表示一个任务额声明周期，并定义相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。并且在Future规范中的隐含意义是，任务声明周期只能前进，不能后退，就像ExecutorService的生命周期一样。当某个任务完成后，他就永远停留在完成状态上。</p>\n<p><strong>1. Callable</strong></p>\n<p>Callable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。</p>\n<p>为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。</p>\n<p>Callable的源码如下：</p>\n<pre><code>public interface Callable&lt;V&gt; {\n   V call() throws Exception;\n}\n</code></pre><p><strong>说明</strong>：从中我们可以看出Callable支持泛型。 </p>\n<p><strong>2. Future</strong></p>\n<p>Future 是一个接口。它用于表示异步计算的结果。提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。</p>\n<p>Future的源码如下：</p>\n<pre><code class=\"java\">public interface Future&lt;V&gt; {\n   // 试图取消对此任务的执行。\n   boolean     cancel(boolean mayInterruptIfRunning)\n\n   // 如果在任务正常完成前将其取消，则返回 true。\n   boolean     isCancelled()\n\n   // 如果任务已完成，则返回 true。\n   boolean     isDone()\n\n   // 如有必要，等待计算完成，然后获取其结果。\n   V           get() throws InterruptedException, ExecutionException;\n\n   // 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。\n   V       get(long timeout, TimeUnit unit)\n         throws InterruptedException, ExecutionException, TimeoutException;\n}\n</code></pre>\n</blockquote>\n<h3 id=\"2-ThreadPoolExecutor中submit分析\"><a href=\"#2-ThreadPoolExecutor中submit分析\" class=\"headerlink\" title=\"2. ThreadPoolExecutor中submit分析\"></a>2. ThreadPoolExecutor中submit分析</h3><blockquote>\n<p>前面我们已经对ThreadPoolExecutor中execute进行了分析，在execute中执行的任务是没有返回结果。这在很大程度上限制了这个方法的使用，因此在ExecutorService中提供了submit方法，可以在任务执行完成后返回结果，这个方法有三个重载方法，源码如下：</p>\n<pre><code class=\"java\">   //执行Runnable接口，返回一个没有任何结果的Future\n   public Future&lt;?&gt; submit(Runnable task) {\n       if (task == null) throw new NullPointerException();\n       RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);\n       execute(ftask);\n       return ftask;\n   }\n   //执行Runnable接口，并返回一个带有result结果的Future\n   public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {\n       if (task == null) throw new NullPointerException();\n       RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);\n       execute(ftask);\n       return ftask;\n   }\n\n      //执行Callable接口，并返回Future对象\n   public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {\n       if (task == null) throw new NullPointerException();\n       RunnableFuture&lt;T&gt; ftask = newTaskFor(task);\n       execute(ftask);\n       return ftask;\n   }\n</code></pre>\n<p>通过看上面的代码，大体上代码的结构都是相同的，首先通过newTaskFor方法创建一个RunnableFuture对象，然后使用execute执行这个任务。</p>\n<p>下面我们看一下newTaskFor这个方法，这个方法也包括俩个重载的方法，源码如下</p>\n<pre><code class=\"java\">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {\n    return new FutureTask&lt;T&gt;(runnable, value);\n}\n\nprotected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {\n     return new FutureTask&lt;T&gt;(callable);\n}\n</code></pre>\n<p>这个方法是将提供的Runnable和Callable接口封装在FutureTask内，然后返回一个RunnableFuture对象，事实上，FutureTask实现了RunnablFuture这个接口。</p>\n</blockquote>\n<p>###3.  FutureTask源码分析</p>\n<blockquote>\n<p>Future继承体系如下</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>Future表示一个任务的状态有以下几种，</p>\n<pre><code>NEW      ：任务新创建状态   \nCOMPLETING  ：任务完成状态\nNORMAL         ：正常完成状态\nEXCEPTIONAL ：异常完成状态\nCANCELLED    ：取消状态\nINTERRUPTING ：正在中断状态\nINTERRUPTED  ：已经被中断状态\n</code></pre><p>状态只能从一个状态转变到另外一个状态，不能后退，状态的转换大致上有以下几种：</p>\n<pre><code>NEW -&gt; COMPLETING -&gt; NORMAL\nNEW -&gt; COMPLETING -&gt; EXCEPTIONAL\nNEW -&gt; CANCELLED\nNEW -&gt; INTERRUPTING -&gt; INTERRUPTED\n</code></pre><h3 id=\"FutureTask构造函数\"><a href=\"#FutureTask构造函数\" class=\"headerlink\" title=\"FutureTask构造函数\"></a>FutureTask构造函数</h3><pre><code class=\"java\">public FutureTask(Callable&lt;V&gt; callable) {\n   if (callable == null)\n       throw new NullPointerException();\n   // callable是一个Callable对象\n   this.callable = callable;\n   // state记录FutureTask的状态\n   this.state = NEW;       // ensure visibility of callable\n}\n\npublic FutureTask(Runnable runnable, V result) {\n       //将给定的runnable接口封装成Callable类，\n       this.callable = Executors.callable(runnable, result);\n       this.state = NEW;       // ensure visibility of callable\n}\n\n</code></pre>\n<h3 id=\"FutureTask中run函数\"><a href=\"#FutureTask中run函数\" class=\"headerlink\" title=\"FutureTask中run函数\"></a>FutureTask中run函数</h3><p>在newTaskFor()新建一个ftask对象之后，会通过execute(ftask)执行该任务。此时ftask被当作一个Runnable对象进行执行，最终会调用到它的run()方法:源码如下：</p>\n<pre><code class=\"java\">public void run() {\n   //判断当前任务的状态\n   if (state != NEW ||\n       !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                    null, Thread.currentThread()))\n       return;\n   try {\n       // 将callable对象赋值给c。\n       Callable&lt;V&gt; c = callable;\n       if (c != null &amp;&amp; state == NEW) {\n           V result;\n           boolean ran;\n           try {\n               // 执行Callable的call()方法，并保存结果到result中。\n               result = c.call();\n               ran = true;\n           } catch (Throwable ex) {\n               result = null;\n               ran = false;\n               setException(ex);\n           }\n           // 如果运行成功，则将result保存\n           if (ran)\n               set(result);\n       }\n   } finally {\n       runner = null;\n       // 设置“state状态标记”\n       int s = state;\n       if (s &gt;= INTERRUPTING)\n           handlePossibleCancellationInterrupt(s);\n   }\n}\n</code></pre>\n<p><strong>说明</strong>：run()中会执行Callable对象的call()方法，并且最终将结果保存到result中，并通过set(result)将result保存。 之后调用FutureTask的get()方法，返回的就是通过set(result)保存的值。</p>\n<h3 id=\"FutureTask中get函数\"><a href=\"#FutureTask中get函数\" class=\"headerlink\" title=\"FutureTask中get函数\"></a>FutureTask中get函数</h3><p>get是用来得到任务执行的结果，如果任务没有执行完成，就会暂停当前任务的执行</p>\n<pre><code class=\"java\">public V get() throws InterruptedException, ExecutionException {\n       int s = state;\n       if (s &lt;= COMPLETING)\n           s = awaitDone(false, 0L);\n       return report(s);\n   }\n\n</code></pre>\n<p>从上面代码可以看出，get是调用awaitDone来阻塞当前线程。源码如下</p>\n<pre><code class=\"java\">   private int awaitDone(boolean timed, long nanos)\n       throws InterruptedException {\n       //得到截止时间\n       final long deadline = timed ? System.nanoTime() + nanos : 0L;\n       WaitNode q = null;\n       boolean queued = false;\n       //循环判断，知道任务执行完成\n       for (;;) {\n           //删除中断的等待结果返回线程\n           if (Thread.interrupted()) {\n               removeWaiter(q);\n               throw new InterruptedException();\n           }\n\n           //得到任务状态\n           int s = state;\n           //如果是以完成状态，则返回结果\n           if (s &gt; COMPLETING) {\n               if (q != null)\n                   q.thread = null;\n               return s;\n           }\n           //如果是正在执行状态，当前线程让出cpu\n           else if (s == COMPLETING) // cannot time out yet\n               Thread.yield();\n           //创建新的等待节点\n           else if (q == null)\n               q = new WaitNode();\n           //将等待节点插入等待队列\n           else if (!queued)\n               queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                    q.next = waiters, q);\n           //如果是有等待时间限制的\n           else if (timed) {\n               nanos = deadline - System.nanoTime();\n               //过了等待时间，则删除等待对应的等待节点\n               if (nanos &lt;= 0L) {\n                   removeWaiter(q);\n                   return state;\n               }\n               //阻塞当前线程\n               LockSupport.parkNanos(this, nanos);\n           }\n           else\n               LockSupport.park(this);\n       }\n   }\n</code></pre>\n<p>分析：</p>\n<p>上面代码可以阻塞调用线程的执行，但是线程的唤醒是不在这里面的。其实这样设计是对的，任务是否执行完成，Future是无法决定的，只要执行这个任务的线程才知道，所以就把唤醒线程的代码放在run方法里面，但是为什么刚刚没有在run里面看到呢，是因为封装在finishCompletion这个方法里面，而这个方法的调用是由set和setExecption俩个方法调用，源码如下：</p>\n<pre><code class=\"java\">   //任务执行完成，设置执行结果，并设置当前任务状态   \nprotected void set(V v) {\n       if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n           outcome = v;\n           UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n           //唤醒所有等待的此任务完成的线程\n           finishCompletion();\n       }\n   }\n   //此方法和上面的set方法执行流程一样，只是改变当前任务的状态时异常状态\n   protected void setException(Throwable t) {\n       if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n           outcome = t;\n           UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n           finishCompletion();\n       }\n   }\n   //唤醒锁等带此任务执行完成的线程\n   private void finishCompletion() {\n       // assert state &gt; COMPLETING;\n       for (WaitNode q; (q = waiters) != null;) {\n           if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n               for (;;) {\n                   Thread t = q.thread;\n                   if (t != null) {\n                       q.thread = null;\n                       LockSupport.unpark(t);\n                   }\n                   WaitNode next = q.next;\n                   if (next == null)\n                       break;\n                   q.next = null; // unlink to help gc\n                   q = next;\n               }\n               break;\n           }\n       }\n       //这个方法是一个空方法，如果希望任务执行完成后调用一个类似于callback回调，继承此类，\n       //然后封装此方法\n       done();\n\n       callable = null;        // to reduce footprint\n   }\n</code></pre>\n</blockquote>\n"},{"abbrlink":17,"title":"泛型中 < ? extends T > 和 < ? extends T > 的区别","author":"zhangke","date":"2018-01-11T05:55:00.000Z","_content":"# 泛型中 < ? extends T > 和 < ? extends T > 的区别\n\n这俩个主要用于对参数的保护，如果你看过Java api 源码的话，你经常看到方法参数类似上面的写法。\n\n### 概要\n\n>1. 类型擦除\n>2. 逆变与协变\n>3. ？ 的用法 \n>4. extends 的用法\n>5. super的用法\n>6. PECS原则\n\n### 类型擦除\n\n>```java\n>import java.util.*;\n>public class main{\n>  public static void main(String[] args){\n>    Class c1 = new ArrayList< String>().getClass();\n>    Class c2 = new ArrayList< Integer>().getClass();\n>    System.out.println(c1 == c2);\n>  }\n>}\n>```\n>\n>上面程序运行的结果是true。出现这个结果的原因正是类型擦除。\n>\n>在Java语言中，泛型是通过类型擦除来实现的，这意味着当你在使用泛型时，任何具体的类型都将被擦除，你唯一知道的就是你正在使用的是一个对象。因此上面List< String> 和List< Integer>在运行时事实上是同样的类型。（泛型类型只有在静态类型检查期间才出现，静态类型检查：基于程序的源代码来验证类型安全的过程；动态类型检查：在程序运行期间验证类型安全的过程；）\n>\n>#### 擦除带来的问题\n>\n>```java\n>class HasF{\n>  public void f(){\n>    System.out.println(\"f\");\n>  }\n>}\n>class Manipulator< T>{\n>  private T obj;\n>  public Manipulator(T x){\n>    obj = x;\n>  }\n>  public void manipulate(){\n>    obj.f();\n>  }\n>}\n>public class main{\n>  \n>  public static  void main(String[] args){\n>    HasF hasf = new HasF();\n>    Manipulator< HasF> m = new Manipulator< HasF>(hasf);\n>    m.manipulate()  // error\n>  }\n>}\n>```\n>\n>上面这段代码会报错，正是由于类型擦除导致的。因为类型擦除，所以泛型内部无法知道类型的信息，当你调用object没有的方法时，就会报错。\n>\n>### 补充一点：边界\n>\n>>因为擦除在方法体中移除了类型信息，所以运行时，你就需要辨别边界，边界是指：对象进入和离开方法的地点，这里是指泛型的方法体。\n>>\n>>```java\n>>public class ArrayMaker< T> {\n>>  private Class< T> kind;\n>>  public ArrayMaker(Class<T> kind) {\n>>    this.kind = kind;\n>>  }\n>>  @SuppressWarnings(\"unchecked\")\n>>  T[] create(int size) {\n>>    return (T[])Array.newInstance(kind, size);\n>>  }\n>>  public static void main(String[] args) {\n>>    ArrayMaker< String> stringMaker =\n>>      new ArrayMaker< String>(String.class);\n>>    String[] stringArray = stringMaker.create(9);\n>>    System.out.println(Arrays.toString(stringArray));\n>>  }\n>>} /* Output:\n>>[null, null, null, null, null, null, null, null, null]\n>>*///:~\n>>```\n>>\n>>上面这段代码就是因为在泛型的方法体中初始化，所以就把所有的类型当成了Object类型，因此输出的结果都是null。如果是String对象的话，输出的是**“  ”**\n>>\n>>仔细查看下面俩段代码：\n>>\n>>```java\n>>// 不存在泛型\n>>public class SimpleHolder {\n>>  private Object obj;\n>>  public void set(Object obj) { this.obj = obj; }\n>>  public Object get() { return obj; }\n>>  public static void main(String[] args) {\n>>    SimpleHolder holder = new SimpleHolder();\n>>    holder.set(\"Item\");\n>>    String s = (String)holder.get();\n>>  }\n>>} ///:~\n>>```\n>>\n>>```java\n>>/// 存在泛型\n>>public class GenericHolder<T> {\n>>  private T obj;\n>>  public void set(T obj) { this.obj = obj; }\n>>  public T get() { return obj; }\n>>  public static void main(String[] args) {\n>>    GenericHolder< String > holder =\n>>      new GenericHolder< String >();\n>>    holder.set(\"Item\");\n>>    String s = holder.get();\n>>  }\n>>} \n>>```\n>>\n>>但是如果你仔细查看俩段代码的字节码，你会发现是相同的。并且你会发现泛型所有的动作都是发生在边界处，会对传进来的值进行额外的编译检查，并插入对传递出去的值的类型。所以，可以得出一个结论，边界就是发生动作的地方。\n\n### 逆变与协变\n\n>协变与逆变这来个术语是用来描述类型转换（type transformations）后的继承关系。定义如下：A,B表示类型**≤ **表示继承关系.(比如：A ≤B表示A是B派生出来的子类  )\n>\n>- 逆变（contravariant），当A≤B时，B可以转化成A。\n>- 协变（covariant），A≤B时，A可以转换成B。\n>- 不变（invariant），如果上述俩种均不能使用。\n>\n>先来看一个简单的例子：\n>\n>考虑List< A >是否是协变，逆变，不变？协变意味着List< String >是List< Object>的子类，逆变意味着List\n>\n>< Object>是List< String>的子类，不变意味着上面俩种都不是。在java中List< String>和List< Object>是不变的类型。下面的代码在java中是编译不过去的，验证了集合在java中是不变的。\n>\n>```java\n>ArrayList<String> strings = new ArrayList<Object>();\n>ArrayList<Object> objects = new ArrayList<String>();\n>```\n>\n>\n>\n>在来看另外一个例子，数组 A[]，判断数组是逆变，协变，不变三个的哪一种？很容易可以证明，在java中数组是协变的\n>\n>```java\n>Object[] objs = new String[3]\n>```\n>\n>下面这个例子是来研究方法,直接通过一个例子来说明\n>\n>```java\n>Number[] method(ArrayList<Number> list) {\n>  ...\n>}\n>//下面三个没有一个能编译过\n>Integer[] result = method(new ArrayList<Integer>());\n>Number[] result = method(new ArrayList<Integer>());\n>Object[] result = method(new ArrayList<Object>());\n>//下面俩个能编译过\n>Number[] result = method(new ArrayList<Number>());\n>Object[] result = method(new ArrayList<Number>());\n>\n>```\n>\n>调用方法`result = method(n)`；传入形参的类型应为method形参的子类型，即`typeof(n)≤typeof(method's parameter)`；result应为method返回值的基类型，即`typeof(methods's return)≤typeof(result)`：\n>\n>在Java 1.4中，子类覆盖（override）父类方法时，形参与返回值的类型必须与父类保持一致：\n>\n>```java\n>class Super {\n>    Number method(Number n) { ... }\n>}\n>\n>class Sub extends Super {\n>    @Override \n>    Number method(Number n) { ... }\n>}\n>```\n>\n>从Java 1.5开始，子类覆盖父类方法时允许协变返回更为具体的类型：\n>\n>```java\n>class Super {\n>    Number method(Number n) { ... }\n>}\n>\n>class Sub extends Super {\n>    @Override \n>    Integer method(Number n) { ... }\n>}\n>```\n\n### ？ 的用法 \n\n>下面是使用案例\n>\n>```Java\n>public class UnboundedWildcardsl {\n>    static List list1;\n>    static List<?> list2;\n>    static List<? extends Object> list3;\n>//    @SuppressWarnings(\"unchecked\")\n>    static void assign1(List list){\n>        list1 = list;\n>        list2 = list;\n>\n>        list3 = list;     //未检查的转换\n>    }\n>    static void assign2(List<?> list){\n>        list1 = list;\n>        list2 = list;\n>        list3 = list;\n>    }\n>    static void assign3(List<? extends Object> list){\n>        list1 = list;\n>        list2 = list;\n>        list3 = list;\n>    }\n>\n>    public static void main(String[] args) {\n>        assign1(new ArrayList());\n>        assign2(new ArrayList());\n>        assign3(new ArrayList());\n>\n>        assign1(new ArrayList<>());\n>        assign2(new ArrayList<>());\n>        assign3(new ArrayList<>());\n>\n>        List<?> wildList = new ArrayList();\n>        wildList = new ArrayList<String>();\n>        assign1(wildList);\n>        assign2(wildList);\n>        assign3(wildList);\n>    }\n>}\n>```\n>\n> 在很多情况下你会看到和这个情况类似，编译器很少关心使用的是原生类型还是< ?>，这些情况< ?> 被认为是一种装饰，不过还是有价值的，即我想用java泛型来编写代码。我在这里并不是要使用原生的类型，但是这种情况下，泛型参数可以支持有任何类型。\n\n### extends 的用法\n\n>extends表示的是上界通配符，下面展示的是如何使用:以 List<? extends Number> 为例来展示使用\n>\n>```Java\n>//Number extends Number \n>List<? extends Number>  foo3 = new ArrayList<? extends Number>();\n>\n>//Integer extends Number\n>List<? extends Number> foo3 = new ArrayList<? extends Integer>();\n>\n>//Double extends Number\n>List<? extends Number> foo3 = new ArrayList<? extends Double>();\n>\n>//下面的是错误使用\n>foo3.add(12);\n>\n>```\n>\n>1. 读取操作通过以上给定的赋值语句，你一定能从foo3列表中读取到的元素的类型是什么呢？你可以读取到Number，因为以上的列表要么包含Number元素，要么包含Number的子类元素。\n>\n>   你不能保证读取到Integer，因为foo3可能指向的是List< Double>。\n>\n>   你不能保证读取到Double，因为foo3可能指向的是List< Integer>。\n>\n>2. 写入操作过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？\n>\n>   你不能插入一个Integer元素，因为foo3可能指向List< Double>。\n>\n>   你不能插入一个Double元素，因为foo3可能指向List< Integer>。\n>\n>   你不能插入一个Number元素，因为foo3可能指向List< Integer>。\n>\n>   你不能往List< ? extends T>中插入任何类型的对象，因为你不能保证列表实际指向的类型是什么，你并不能保证列表中实际存储什么类型的对象。唯一可以保证的是，你可以从中读取到T或者T的子类。这也验证了java集合是不变的，由于无法判断类型，所以你也无法进行插入。\n\n### super 的用法\n\n>super下界通配符，下面以List\\<？ super Integer>来展示super的用法\n>\n>```java\n>//integer is a superClass of Integer \n>List<? super Integer>  foo3 = new ArrayList<Integer>()\n> \n>//Number is a superClass of Integer\n>List<? super Integer> foo3 = new ArrayList<Number>();\n>\n>//Object is superClass of Integer\n>List<? super Integer> foo3 = new ArrayList<Object>();\n>\n>//下面代码是错误的\n>list.get(index);  //不能获取\n>```\n>\n>1. foo3可能指向List< Number>或者List< Object>。\n>\n>   你不能保证读取到Number，因为foo3可能指向List< Object>。\n>\n>   唯一可以保证的是，你可以读取到Object或者Object子类的对象（你并不知道具体的子类是什么）。\n>\n>2. 写入操作通过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？你可以插入Integer对象，因为上述声明的列表都支持Integer。\n>\n>   你可以插入Integer的子类的对象，因为Integer的子类同时也是Integer，原因同上。\n>\n>   你不能插入Double对象，因为foo3可能指向ArrayList< Integer>。\n>\n>   你不能插入Number对象，因为foo3可能指向ArrayList< Integer>。\n>\n>   你不能插入Object对象，因为foo3可能指向ArrayList< Integer>。\n\n#### PECS(Pruducer extends,Consumer super)\n\n>请记住PECS原则：生产者（Producer）使用extends，消费者（Consumer）使用super。\n>\n>- 生产者使用extends\n>\n>如果你需要一个列表提供T类型的元素（即你想从列表中读取T类型的元素），你需要把这个列表声明成\\<? extends T>，比如List\\<? extends Integer>，因此你不能往该列表中添加任何元素。\n>\n>- 消费者使用super\n>\n>如果需要一个列表使用T类型的元素（即你想把T类型的元素加入到列表中），你需要把这个列表声明成\\<? super T>，比如List\\<? super Integer>，因此你不能保证从中读取到的元素的类型。\n>\n>- 即是生产者，也是消费者\n>\n>如果一个列表即要生产，又要消费，你不能使用泛型通配符声明列表，比如List\\<Integer>。\n>\n>请参考java.util.Collections里的copy方法(JDK1.7)：copy使用到了PECS原则，实现了对参数的保护。\n>\n>```Java\n>/**\n>     * Copies all of the elements from one list into another.  After the\n>     * operation, the index of each copied element in the destination list\n>     * will be identical to its index in the source list.  The destination\n>     * list must be at least as long as the source list.  If it is longer, the\n>     * remaining elements in the destination list are unaffected. <p>\n>     *\n>     * This method runs in linear time.\n>     *\n>     * @param  <T> the class of the objects in the lists\n>     * @param  dest The destination list.\n>     * @param  src The source list.\n>     * @throws IndexOutOfBoundsException if the destination list is too small\n>     *         to contain the entire source List.\n>     * @throws UnsupportedOperationException if the destination list's\n>     *         list-iterator does not support the <tt>set</tt> operation.\n>     */\n>    public static < T> void copy(List< ? super T> dest, List<? extends T> src) {\n>        int srcSize = src.size();\n>        if (srcSize > dest.size())\n>            throw new IndexOutOfBoundsException(\"Source does not fit in dest\");\n>\n>        if (srcSize < COPY_THRESHOLD ||\n>            (src instanceof RandomAccess && dest instanceof RandomAccess)) {\n>            for (int i=0; i<srcSize; i++)\n>                dest.set(i, src.get(i));\n>        } else {\n>            ListIterator< ? super T> di=dest.listIterator();\n>            ListIterator< ? extends T> si=src.listIterator();\n>            for (int i=0; i<srcSize; i++) {\n>                di.next();\n>                di.set(si.next());\n>            }\n>        }\n>    }\n>```\n>\n>\n\n\n\n\n\n","source":"_posts/super 和 extends.md","raw":"abbrlink: 17\ntitle: 泛型中 < ? extends T > 和 < ? extends T > 的区别\ntags:\n  - java\n  - 泛型\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-01-11 13:55:00\n---\n# 泛型中 < ? extends T > 和 < ? extends T > 的区别\n\n这俩个主要用于对参数的保护，如果你看过Java api 源码的话，你经常看到方法参数类似上面的写法。\n\n### 概要\n\n>1. 类型擦除\n>2. 逆变与协变\n>3. ？ 的用法 \n>4. extends 的用法\n>5. super的用法\n>6. PECS原则\n\n### 类型擦除\n\n>```java\n>import java.util.*;\n>public class main{\n>  public static void main(String[] args){\n>    Class c1 = new ArrayList< String>().getClass();\n>    Class c2 = new ArrayList< Integer>().getClass();\n>    System.out.println(c1 == c2);\n>  }\n>}\n>```\n>\n>上面程序运行的结果是true。出现这个结果的原因正是类型擦除。\n>\n>在Java语言中，泛型是通过类型擦除来实现的，这意味着当你在使用泛型时，任何具体的类型都将被擦除，你唯一知道的就是你正在使用的是一个对象。因此上面List< String> 和List< Integer>在运行时事实上是同样的类型。（泛型类型只有在静态类型检查期间才出现，静态类型检查：基于程序的源代码来验证类型安全的过程；动态类型检查：在程序运行期间验证类型安全的过程；）\n>\n>#### 擦除带来的问题\n>\n>```java\n>class HasF{\n>  public void f(){\n>    System.out.println(\"f\");\n>  }\n>}\n>class Manipulator< T>{\n>  private T obj;\n>  public Manipulator(T x){\n>    obj = x;\n>  }\n>  public void manipulate(){\n>    obj.f();\n>  }\n>}\n>public class main{\n>  \n>  public static  void main(String[] args){\n>    HasF hasf = new HasF();\n>    Manipulator< HasF> m = new Manipulator< HasF>(hasf);\n>    m.manipulate()  // error\n>  }\n>}\n>```\n>\n>上面这段代码会报错，正是由于类型擦除导致的。因为类型擦除，所以泛型内部无法知道类型的信息，当你调用object没有的方法时，就会报错。\n>\n>### 补充一点：边界\n>\n>>因为擦除在方法体中移除了类型信息，所以运行时，你就需要辨别边界，边界是指：对象进入和离开方法的地点，这里是指泛型的方法体。\n>>\n>>```java\n>>public class ArrayMaker< T> {\n>>  private Class< T> kind;\n>>  public ArrayMaker(Class<T> kind) {\n>>    this.kind = kind;\n>>  }\n>>  @SuppressWarnings(\"unchecked\")\n>>  T[] create(int size) {\n>>    return (T[])Array.newInstance(kind, size);\n>>  }\n>>  public static void main(String[] args) {\n>>    ArrayMaker< String> stringMaker =\n>>      new ArrayMaker< String>(String.class);\n>>    String[] stringArray = stringMaker.create(9);\n>>    System.out.println(Arrays.toString(stringArray));\n>>  }\n>>} /* Output:\n>>[null, null, null, null, null, null, null, null, null]\n>>*///:~\n>>```\n>>\n>>上面这段代码就是因为在泛型的方法体中初始化，所以就把所有的类型当成了Object类型，因此输出的结果都是null。如果是String对象的话，输出的是**“  ”**\n>>\n>>仔细查看下面俩段代码：\n>>\n>>```java\n>>// 不存在泛型\n>>public class SimpleHolder {\n>>  private Object obj;\n>>  public void set(Object obj) { this.obj = obj; }\n>>  public Object get() { return obj; }\n>>  public static void main(String[] args) {\n>>    SimpleHolder holder = new SimpleHolder();\n>>    holder.set(\"Item\");\n>>    String s = (String)holder.get();\n>>  }\n>>} ///:~\n>>```\n>>\n>>```java\n>>/// 存在泛型\n>>public class GenericHolder<T> {\n>>  private T obj;\n>>  public void set(T obj) { this.obj = obj; }\n>>  public T get() { return obj; }\n>>  public static void main(String[] args) {\n>>    GenericHolder< String > holder =\n>>      new GenericHolder< String >();\n>>    holder.set(\"Item\");\n>>    String s = holder.get();\n>>  }\n>>} \n>>```\n>>\n>>但是如果你仔细查看俩段代码的字节码，你会发现是相同的。并且你会发现泛型所有的动作都是发生在边界处，会对传进来的值进行额外的编译检查，并插入对传递出去的值的类型。所以，可以得出一个结论，边界就是发生动作的地方。\n\n### 逆变与协变\n\n>协变与逆变这来个术语是用来描述类型转换（type transformations）后的继承关系。定义如下：A,B表示类型**≤ **表示继承关系.(比如：A ≤B表示A是B派生出来的子类  )\n>\n>- 逆变（contravariant），当A≤B时，B可以转化成A。\n>- 协变（covariant），A≤B时，A可以转换成B。\n>- 不变（invariant），如果上述俩种均不能使用。\n>\n>先来看一个简单的例子：\n>\n>考虑List< A >是否是协变，逆变，不变？协变意味着List< String >是List< Object>的子类，逆变意味着List\n>\n>< Object>是List< String>的子类，不变意味着上面俩种都不是。在java中List< String>和List< Object>是不变的类型。下面的代码在java中是编译不过去的，验证了集合在java中是不变的。\n>\n>```java\n>ArrayList<String> strings = new ArrayList<Object>();\n>ArrayList<Object> objects = new ArrayList<String>();\n>```\n>\n>\n>\n>在来看另外一个例子，数组 A[]，判断数组是逆变，协变，不变三个的哪一种？很容易可以证明，在java中数组是协变的\n>\n>```java\n>Object[] objs = new String[3]\n>```\n>\n>下面这个例子是来研究方法,直接通过一个例子来说明\n>\n>```java\n>Number[] method(ArrayList<Number> list) {\n>  ...\n>}\n>//下面三个没有一个能编译过\n>Integer[] result = method(new ArrayList<Integer>());\n>Number[] result = method(new ArrayList<Integer>());\n>Object[] result = method(new ArrayList<Object>());\n>//下面俩个能编译过\n>Number[] result = method(new ArrayList<Number>());\n>Object[] result = method(new ArrayList<Number>());\n>\n>```\n>\n>调用方法`result = method(n)`；传入形参的类型应为method形参的子类型，即`typeof(n)≤typeof(method's parameter)`；result应为method返回值的基类型，即`typeof(methods's return)≤typeof(result)`：\n>\n>在Java 1.4中，子类覆盖（override）父类方法时，形参与返回值的类型必须与父类保持一致：\n>\n>```java\n>class Super {\n>    Number method(Number n) { ... }\n>}\n>\n>class Sub extends Super {\n>    @Override \n>    Number method(Number n) { ... }\n>}\n>```\n>\n>从Java 1.5开始，子类覆盖父类方法时允许协变返回更为具体的类型：\n>\n>```java\n>class Super {\n>    Number method(Number n) { ... }\n>}\n>\n>class Sub extends Super {\n>    @Override \n>    Integer method(Number n) { ... }\n>}\n>```\n\n### ？ 的用法 \n\n>下面是使用案例\n>\n>```Java\n>public class UnboundedWildcardsl {\n>    static List list1;\n>    static List<?> list2;\n>    static List<? extends Object> list3;\n>//    @SuppressWarnings(\"unchecked\")\n>    static void assign1(List list){\n>        list1 = list;\n>        list2 = list;\n>\n>        list3 = list;     //未检查的转换\n>    }\n>    static void assign2(List<?> list){\n>        list1 = list;\n>        list2 = list;\n>        list3 = list;\n>    }\n>    static void assign3(List<? extends Object> list){\n>        list1 = list;\n>        list2 = list;\n>        list3 = list;\n>    }\n>\n>    public static void main(String[] args) {\n>        assign1(new ArrayList());\n>        assign2(new ArrayList());\n>        assign3(new ArrayList());\n>\n>        assign1(new ArrayList<>());\n>        assign2(new ArrayList<>());\n>        assign3(new ArrayList<>());\n>\n>        List<?> wildList = new ArrayList();\n>        wildList = new ArrayList<String>();\n>        assign1(wildList);\n>        assign2(wildList);\n>        assign3(wildList);\n>    }\n>}\n>```\n>\n> 在很多情况下你会看到和这个情况类似，编译器很少关心使用的是原生类型还是< ?>，这些情况< ?> 被认为是一种装饰，不过还是有价值的，即我想用java泛型来编写代码。我在这里并不是要使用原生的类型，但是这种情况下，泛型参数可以支持有任何类型。\n\n### extends 的用法\n\n>extends表示的是上界通配符，下面展示的是如何使用:以 List<? extends Number> 为例来展示使用\n>\n>```Java\n>//Number extends Number \n>List<? extends Number>  foo3 = new ArrayList<? extends Number>();\n>\n>//Integer extends Number\n>List<? extends Number> foo3 = new ArrayList<? extends Integer>();\n>\n>//Double extends Number\n>List<? extends Number> foo3 = new ArrayList<? extends Double>();\n>\n>//下面的是错误使用\n>foo3.add(12);\n>\n>```\n>\n>1. 读取操作通过以上给定的赋值语句，你一定能从foo3列表中读取到的元素的类型是什么呢？你可以读取到Number，因为以上的列表要么包含Number元素，要么包含Number的子类元素。\n>\n>   你不能保证读取到Integer，因为foo3可能指向的是List< Double>。\n>\n>   你不能保证读取到Double，因为foo3可能指向的是List< Integer>。\n>\n>2. 写入操作过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？\n>\n>   你不能插入一个Integer元素，因为foo3可能指向List< Double>。\n>\n>   你不能插入一个Double元素，因为foo3可能指向List< Integer>。\n>\n>   你不能插入一个Number元素，因为foo3可能指向List< Integer>。\n>\n>   你不能往List< ? extends T>中插入任何类型的对象，因为你不能保证列表实际指向的类型是什么，你并不能保证列表中实际存储什么类型的对象。唯一可以保证的是，你可以从中读取到T或者T的子类。这也验证了java集合是不变的，由于无法判断类型，所以你也无法进行插入。\n\n### super 的用法\n\n>super下界通配符，下面以List\\<？ super Integer>来展示super的用法\n>\n>```java\n>//integer is a superClass of Integer \n>List<? super Integer>  foo3 = new ArrayList<Integer>()\n> \n>//Number is a superClass of Integer\n>List<? super Integer> foo3 = new ArrayList<Number>();\n>\n>//Object is superClass of Integer\n>List<? super Integer> foo3 = new ArrayList<Object>();\n>\n>//下面代码是错误的\n>list.get(index);  //不能获取\n>```\n>\n>1. foo3可能指向List< Number>或者List< Object>。\n>\n>   你不能保证读取到Number，因为foo3可能指向List< Object>。\n>\n>   唯一可以保证的是，你可以读取到Object或者Object子类的对象（你并不知道具体的子类是什么）。\n>\n>2. 写入操作通过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？你可以插入Integer对象，因为上述声明的列表都支持Integer。\n>\n>   你可以插入Integer的子类的对象，因为Integer的子类同时也是Integer，原因同上。\n>\n>   你不能插入Double对象，因为foo3可能指向ArrayList< Integer>。\n>\n>   你不能插入Number对象，因为foo3可能指向ArrayList< Integer>。\n>\n>   你不能插入Object对象，因为foo3可能指向ArrayList< Integer>。\n\n#### PECS(Pruducer extends,Consumer super)\n\n>请记住PECS原则：生产者（Producer）使用extends，消费者（Consumer）使用super。\n>\n>- 生产者使用extends\n>\n>如果你需要一个列表提供T类型的元素（即你想从列表中读取T类型的元素），你需要把这个列表声明成\\<? extends T>，比如List\\<? extends Integer>，因此你不能往该列表中添加任何元素。\n>\n>- 消费者使用super\n>\n>如果需要一个列表使用T类型的元素（即你想把T类型的元素加入到列表中），你需要把这个列表声明成\\<? super T>，比如List\\<? super Integer>，因此你不能保证从中读取到的元素的类型。\n>\n>- 即是生产者，也是消费者\n>\n>如果一个列表即要生产，又要消费，你不能使用泛型通配符声明列表，比如List\\<Integer>。\n>\n>请参考java.util.Collections里的copy方法(JDK1.7)：copy使用到了PECS原则，实现了对参数的保护。\n>\n>```Java\n>/**\n>     * Copies all of the elements from one list into another.  After the\n>     * operation, the index of each copied element in the destination list\n>     * will be identical to its index in the source list.  The destination\n>     * list must be at least as long as the source list.  If it is longer, the\n>     * remaining elements in the destination list are unaffected. <p>\n>     *\n>     * This method runs in linear time.\n>     *\n>     * @param  <T> the class of the objects in the lists\n>     * @param  dest The destination list.\n>     * @param  src The source list.\n>     * @throws IndexOutOfBoundsException if the destination list is too small\n>     *         to contain the entire source List.\n>     * @throws UnsupportedOperationException if the destination list's\n>     *         list-iterator does not support the <tt>set</tt> operation.\n>     */\n>    public static < T> void copy(List< ? super T> dest, List<? extends T> src) {\n>        int srcSize = src.size();\n>        if (srcSize > dest.size())\n>            throw new IndexOutOfBoundsException(\"Source does not fit in dest\");\n>\n>        if (srcSize < COPY_THRESHOLD ||\n>            (src instanceof RandomAccess && dest instanceof RandomAccess)) {\n>            for (int i=0; i<srcSize; i++)\n>                dest.set(i, src.get(i));\n>        } else {\n>            ListIterator< ? super T> di=dest.listIterator();\n>            ListIterator< ? extends T> si=src.listIterator();\n>            for (int i=0; i<srcSize; i++) {\n>                di.next();\n>                di.set(si.next());\n>            }\n>        }\n>    }\n>```\n>\n>\n\n\n\n\n\n","slug":"super 和 extends","published":1,"updated":"2019-01-04T01:48:59.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx2y001meb1u5kxf1oam","content":"<h1 id=\"泛型中-lt-extends-T-gt-和-lt-extends-T-gt-的区别\"><a href=\"#泛型中-lt-extends-T-gt-和-lt-extends-T-gt-的区别\" class=\"headerlink\" title=\"泛型中 &lt; ? extends T &gt; 和 &lt; ? extends T &gt; 的区别\"></a>泛型中 &lt; ? extends T &gt; 和 &lt; ? extends T &gt; 的区别</h1><p>这俩个主要用于对参数的保护，如果你看过Java api 源码的话，你经常看到方法参数类似上面的写法。</p>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>类型擦除</li>\n<li>逆变与协变</li>\n<li>？ 的用法 </li>\n<li>extends 的用法</li>\n<li>super的用法</li>\n<li>PECS原则</li>\n</ol>\n</blockquote>\n<h3 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h3><blockquote>\n<pre><code class=\"java\">import java.util.*;\npublic class main{\n public static void main(String[] args){\n   Class c1 = new ArrayList&lt; String&gt;().getClass();\n   Class c2 = new ArrayList&lt; Integer&gt;().getClass();\n   System.out.println(c1 == c2);\n }\n}\n</code></pre>\n<p>上面程序运行的结果是true。出现这个结果的原因正是类型擦除。</p>\n<p>在Java语言中，泛型是通过类型擦除来实现的，这意味着当你在使用泛型时，任何具体的类型都将被擦除，你唯一知道的就是你正在使用的是一个对象。因此上面List&lt; String&gt; 和List&lt; Integer&gt;在运行时事实上是同样的类型。（泛型类型只有在静态类型检查期间才出现，静态类型检查：基于程序的源代码来验证类型安全的过程；动态类型检查：在程序运行期间验证类型安全的过程；）</p>\n<h4 id=\"擦除带来的问题\"><a href=\"#擦除带来的问题\" class=\"headerlink\" title=\"擦除带来的问题\"></a>擦除带来的问题</h4><pre><code class=\"java\">class HasF{\n public void f(){\n   System.out.println(&quot;f&quot;);\n }\n}\nclass Manipulator&lt; T&gt;{\n private T obj;\n public Manipulator(T x){\n   obj = x;\n }\n public void manipulate(){\n   obj.f();\n }\n}\npublic class main{\n\n public static  void main(String[] args){\n   HasF hasf = new HasF();\n   Manipulator&lt; HasF&gt; m = new Manipulator&lt; HasF&gt;(hasf);\n   m.manipulate()  // error\n }\n}\n</code></pre>\n<p>上面这段代码会报错，正是由于类型擦除导致的。因为类型擦除，所以泛型内部无法知道类型的信息，当你调用object没有的方法时，就会报错。</p>\n<h3 id=\"补充一点：边界\"><a href=\"#补充一点：边界\" class=\"headerlink\" title=\"补充一点：边界\"></a>补充一点：边界</h3><blockquote>\n<p>因为擦除在方法体中移除了类型信息，所以运行时，你就需要辨别边界，边界是指：对象进入和离开方法的地点，这里是指泛型的方法体。</p>\n<pre><code class=\"java\">public class ArrayMaker&lt; T&gt; {\n private Class&lt; T&gt; kind;\n public ArrayMaker(Class&lt;T&gt; kind) {\n   this.kind = kind;\n }\n @SuppressWarnings(&quot;unchecked&quot;)\n T[] create(int size) {\n   return (T[])Array.newInstance(kind, size);\n }\n public static void main(String[] args) {\n   ArrayMaker&lt; String&gt; stringMaker =\n     new ArrayMaker&lt; String&gt;(String.class);\n   String[] stringArray = stringMaker.create(9);\n   System.out.println(Arrays.toString(stringArray));\n }\n} /* Output:\n[null, null, null, null, null, null, null, null, null]\n*///:~\n</code></pre>\n<p>上面这段代码就是因为在泛型的方法体中初始化，所以就把所有的类型当成了Object类型，因此输出的结果都是null。如果是String对象的话，输出的是<strong>“  ”</strong></p>\n<p>仔细查看下面俩段代码：</p>\n<pre><code class=\"java\">// 不存在泛型\npublic class SimpleHolder {\n private Object obj;\n public void set(Object obj) { this.obj = obj; }\n public Object get() { return obj; }\n public static void main(String[] args) {\n   SimpleHolder holder = new SimpleHolder();\n   holder.set(&quot;Item&quot;);\n   String s = (String)holder.get();\n }\n} ///:~\n</code></pre>\n<pre><code class=\"java\">/// 存在泛型\npublic class GenericHolder&lt;T&gt; {\n private T obj;\n public void set(T obj) { this.obj = obj; }\n public T get() { return obj; }\n public static void main(String[] args) {\n   GenericHolder&lt; String &gt; holder =\n     new GenericHolder&lt; String &gt;();\n   holder.set(&quot;Item&quot;);\n   String s = holder.get();\n }\n} \n</code></pre>\n<p>但是如果你仔细查看俩段代码的字节码，你会发现是相同的。并且你会发现泛型所有的动作都是发生在边界处，会对传进来的值进行额外的编译检查，并插入对传递出去的值的类型。所以，可以得出一个结论，边界就是发生动作的地方。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"逆变与协变\"><a href=\"#逆变与协变\" class=\"headerlink\" title=\"逆变与协变\"></a>逆变与协变</h3><blockquote>\n<p>协变与逆变这来个术语是用来描述类型转换（type transformations）后的继承关系。定义如下：A,B表示类型<strong>≤ </strong>表示继承关系.(比如：A ≤B表示A是B派生出来的子类  )</p>\n<ul>\n<li>逆变（contravariant），当A≤B时，B可以转化成A。</li>\n<li>协变（covariant），A≤B时，A可以转换成B。</li>\n<li>不变（invariant），如果上述俩种均不能使用。</li>\n</ul>\n<p>先来看一个简单的例子：</p>\n<p>考虑List&lt; A &gt;是否是协变，逆变，不变？协变意味着List&lt; String &gt;是List&lt; Object&gt;的子类，逆变意味着List</p>\n<p>&lt; Object&gt;是List&lt; String&gt;的子类，不变意味着上面俩种都不是。在java中List&lt; String&gt;和List&lt; Object&gt;是不变的类型。下面的代码在java中是编译不过去的，验证了集合在java中是不变的。</p>\n<pre><code class=\"java\">ArrayList&lt;String&gt; strings = new ArrayList&lt;Object&gt;();\nArrayList&lt;Object&gt; objects = new ArrayList&lt;String&gt;();\n</code></pre>\n<p>在来看另外一个例子，数组 A[]，判断数组是逆变，协变，不变三个的哪一种？很容易可以证明，在java中数组是协变的</p>\n<pre><code class=\"java\">Object[] objs = new String[3]\n</code></pre>\n<p>下面这个例子是来研究方法,直接通过一个例子来说明</p>\n<pre><code class=\"java\">Number[] method(ArrayList&lt;Number&gt; list) {\n ...\n}\n//下面三个没有一个能编译过\nInteger[] result = method(new ArrayList&lt;Integer&gt;());\nNumber[] result = method(new ArrayList&lt;Integer&gt;());\nObject[] result = method(new ArrayList&lt;Object&gt;());\n//下面俩个能编译过\nNumber[] result = method(new ArrayList&lt;Number&gt;());\nObject[] result = method(new ArrayList&lt;Number&gt;());\n\n</code></pre>\n<p>调用方法<code>result = method(n)</code>；传入形参的类型应为method形参的子类型，即<code>typeof(n)≤typeof(method&#39;s parameter)</code>；result应为method返回值的基类型，即<code>typeof(methods&#39;s return)≤typeof(result)</code>：</p>\n<p>在Java 1.4中，子类覆盖（override）父类方法时，形参与返回值的类型必须与父类保持一致：</p>\n<pre><code class=\"java\">class Super {\n   Number method(Number n) { ... }\n}\n\nclass Sub extends Super {\n   @Override \n   Number method(Number n) { ... }\n}\n</code></pre>\n<p>从Java 1.5开始，子类覆盖父类方法时允许协变返回更为具体的类型：</p>\n<pre><code class=\"java\">class Super {\n   Number method(Number n) { ... }\n}\n\nclass Sub extends Super {\n   @Override \n   Integer method(Number n) { ... }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"？-的用法\"><a href=\"#？-的用法\" class=\"headerlink\" title=\"？ 的用法\"></a>？ 的用法</h3><blockquote>\n<p>下面是使用案例</p>\n<pre><code class=\"Java\">public class UnboundedWildcardsl {\n   static List list1;\n   static List&lt;?&gt; list2;\n   static List&lt;? extends Object&gt; list3;\n//    @SuppressWarnings(&quot;unchecked&quot;)\n   static void assign1(List list){\n       list1 = list;\n       list2 = list;\n\n       list3 = list;     //未检查的转换\n   }\n   static void assign2(List&lt;?&gt; list){\n       list1 = list;\n       list2 = list;\n       list3 = list;\n   }\n   static void assign3(List&lt;? extends Object&gt; list){\n       list1 = list;\n       list2 = list;\n       list3 = list;\n   }\n\n   public static void main(String[] args) {\n       assign1(new ArrayList());\n       assign2(new ArrayList());\n       assign3(new ArrayList());\n\n       assign1(new ArrayList&lt;&gt;());\n       assign2(new ArrayList&lt;&gt;());\n       assign3(new ArrayList&lt;&gt;());\n\n       List&lt;?&gt; wildList = new ArrayList();\n       wildList = new ArrayList&lt;String&gt;();\n       assign1(wildList);\n       assign2(wildList);\n       assign3(wildList);\n   }\n}\n</code></pre>\n<p>在很多情况下你会看到和这个情况类似，编译器很少关心使用的是原生类型还是&lt; ?&gt;，这些情况&lt; ?&gt; 被认为是一种装饰，不过还是有价值的，即我想用java泛型来编写代码。我在这里并不是要使用原生的类型，但是这种情况下，泛型参数可以支持有任何类型。</p>\n</blockquote>\n<h3 id=\"extends-的用法\"><a href=\"#extends-的用法\" class=\"headerlink\" title=\"extends 的用法\"></a>extends 的用法</h3><blockquote>\n<p>extends表示的是上界通配符，下面展示的是如何使用:以 List&lt;? extends Number&gt; 为例来展示使用</p>\n<pre><code class=\"Java\">//Number extends Number \nList&lt;? extends Number&gt;  foo3 = new ArrayList&lt;? extends Number&gt;();\n\n//Integer extends Number\nList&lt;? extends Number&gt; foo3 = new ArrayList&lt;? extends Integer&gt;();\n\n//Double extends Number\nList&lt;? extends Number&gt; foo3 = new ArrayList&lt;? extends Double&gt;();\n\n//下面的是错误使用\nfoo3.add(12);\n\n</code></pre>\n<ol>\n<li><p>读取操作通过以上给定的赋值语句，你一定能从foo3列表中读取到的元素的类型是什么呢？你可以读取到Number，因为以上的列表要么包含Number元素，要么包含Number的子类元素。</p>\n<p>你不能保证读取到Integer，因为foo3可能指向的是List&lt; Double&gt;。</p>\n<p>你不能保证读取到Double，因为foo3可能指向的是List&lt; Integer&gt;。</p>\n</li>\n<li><p>写入操作过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？</p>\n<p>你不能插入一个Integer元素，因为foo3可能指向List&lt; Double&gt;。</p>\n<p>你不能插入一个Double元素，因为foo3可能指向List&lt; Integer&gt;。</p>\n<p>你不能插入一个Number元素，因为foo3可能指向List&lt; Integer&gt;。</p>\n<p>你不能往List&lt; ? extends T&gt;中插入任何类型的对象，因为你不能保证列表实际指向的类型是什么，你并不能保证列表中实际存储什么类型的对象。唯一可以保证的是，你可以从中读取到T或者T的子类。这也验证了java集合是不变的，由于无法判断类型，所以你也无法进行插入。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"super-的用法\"><a href=\"#super-的用法\" class=\"headerlink\" title=\"super 的用法\"></a>super 的用法</h3><blockquote>\n<p>super下界通配符，下面以List\\&lt;？ super Integer&gt;来展示super的用法</p>\n<pre><code class=\"java\">//integer is a superClass of Integer \nList&lt;? super Integer&gt;  foo3 = new ArrayList&lt;Integer&gt;()\n\n//Number is a superClass of Integer\nList&lt;? super Integer&gt; foo3 = new ArrayList&lt;Number&gt;();\n\n//Object is superClass of Integer\nList&lt;? super Integer&gt; foo3 = new ArrayList&lt;Object&gt;();\n\n//下面代码是错误的\nlist.get(index);  //不能获取\n</code></pre>\n<ol>\n<li><p>foo3可能指向List&lt; Number&gt;或者List&lt; Object&gt;。</p>\n<p>你不能保证读取到Number，因为foo3可能指向List&lt; Object&gt;。</p>\n<p>唯一可以保证的是，你可以读取到Object或者Object子类的对象（你并不知道具体的子类是什么）。</p>\n</li>\n<li><p>写入操作通过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？你可以插入Integer对象，因为上述声明的列表都支持Integer。</p>\n<p>你可以插入Integer的子类的对象，因为Integer的子类同时也是Integer，原因同上。</p>\n<p>你不能插入Double对象，因为foo3可能指向ArrayList&lt; Integer&gt;。</p>\n<p>你不能插入Number对象，因为foo3可能指向ArrayList&lt; Integer&gt;。</p>\n<p>你不能插入Object对象，因为foo3可能指向ArrayList&lt; Integer&gt;。</p>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"PECS-Pruducer-extends-Consumer-super\"><a href=\"#PECS-Pruducer-extends-Consumer-super\" class=\"headerlink\" title=\"PECS(Pruducer extends,Consumer super)\"></a>PECS(Pruducer extends,Consumer super)</h4><blockquote>\n<p>请记住PECS原则：生产者（Producer）使用extends，消费者（Consumer）使用super。</p>\n<ul>\n<li>生产者使用extends</li>\n</ul>\n<p>如果你需要一个列表提供T类型的元素（即你想从列表中读取T类型的元素），你需要把这个列表声明成\\&lt;? extends T&gt;，比如List\\&lt;? extends Integer&gt;，因此你不能往该列表中添加任何元素。</p>\n<ul>\n<li>消费者使用super</li>\n</ul>\n<p>如果需要一个列表使用T类型的元素（即你想把T类型的元素加入到列表中），你需要把这个列表声明成\\&lt;? super T&gt;，比如List\\&lt;? super Integer&gt;，因此你不能保证从中读取到的元素的类型。</p>\n<ul>\n<li>即是生产者，也是消费者</li>\n</ul>\n<p>如果一个列表即要生产，又要消费，你不能使用泛型通配符声明列表，比如List\\<integer>。</integer></p>\n<p>请参考java.util.Collections里的copy方法(JDK1.7)：copy使用到了PECS原则，实现了对参数的保护。</p>\n<pre><code class=\"Java\">/**\n    * Copies all of the elements from one list into another.  After the\n    * operation, the index of each copied element in the destination list\n    * will be identical to its index in the source list.  The destination\n    * list must be at least as long as the source list.  If it is longer, the\n    * remaining elements in the destination list are unaffected. &lt;p&gt;\n    *\n    * This method runs in linear time.\n    *\n    * @param  &lt;T&gt; the class of the objects in the lists\n    * @param  dest The destination list.\n    * @param  src The source list.\n    * @throws IndexOutOfBoundsException if the destination list is too small\n    *         to contain the entire source List.\n    * @throws UnsupportedOperationException if the destination list&#39;s\n    *         list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.\n    */\n   public static &lt; T&gt; void copy(List&lt; ? super T&gt; dest, List&lt;? extends T&gt; src) {\n       int srcSize = src.size();\n       if (srcSize &gt; dest.size())\n           throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);\n\n       if (srcSize &lt; COPY_THRESHOLD ||\n           (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) {\n           for (int i=0; i&lt;srcSize; i++)\n               dest.set(i, src.get(i));\n       } else {\n           ListIterator&lt; ? super T&gt; di=dest.listIterator();\n           ListIterator&lt; ? extends T&gt; si=src.listIterator();\n           for (int i=0; i&lt;srcSize; i++) {\n               di.next();\n               di.set(si.next());\n           }\n       }\n   }\n</code></pre>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"泛型中-lt-extends-T-gt-和-lt-extends-T-gt-的区别\"><a href=\"#泛型中-lt-extends-T-gt-和-lt-extends-T-gt-的区别\" class=\"headerlink\" title=\"泛型中 &lt; ? extends T &gt; 和 &lt; ? extends T &gt; 的区别\"></a>泛型中 &lt; ? extends T &gt; 和 &lt; ? extends T &gt; 的区别</h1><p>这俩个主要用于对参数的保护，如果你看过Java api 源码的话，你经常看到方法参数类似上面的写法。</p>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>类型擦除</li>\n<li>逆变与协变</li>\n<li>？ 的用法 </li>\n<li>extends 的用法</li>\n<li>super的用法</li>\n<li>PECS原则</li>\n</ol>\n</blockquote>\n<h3 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h3><blockquote>\n<pre><code class=\"java\">import java.util.*;\npublic class main{\n public static void main(String[] args){\n   Class c1 = new ArrayList&lt; String&gt;().getClass();\n   Class c2 = new ArrayList&lt; Integer&gt;().getClass();\n   System.out.println(c1 == c2);\n }\n}\n</code></pre>\n<p>上面程序运行的结果是true。出现这个结果的原因正是类型擦除。</p>\n<p>在Java语言中，泛型是通过类型擦除来实现的，这意味着当你在使用泛型时，任何具体的类型都将被擦除，你唯一知道的就是你正在使用的是一个对象。因此上面List&lt; String&gt; 和List&lt; Integer&gt;在运行时事实上是同样的类型。（泛型类型只有在静态类型检查期间才出现，静态类型检查：基于程序的源代码来验证类型安全的过程；动态类型检查：在程序运行期间验证类型安全的过程；）</p>\n<h4 id=\"擦除带来的问题\"><a href=\"#擦除带来的问题\" class=\"headerlink\" title=\"擦除带来的问题\"></a>擦除带来的问题</h4><pre><code class=\"java\">class HasF{\n public void f(){\n   System.out.println(&quot;f&quot;);\n }\n}\nclass Manipulator&lt; T&gt;{\n private T obj;\n public Manipulator(T x){\n   obj = x;\n }\n public void manipulate(){\n   obj.f();\n }\n}\npublic class main{\n\n public static  void main(String[] args){\n   HasF hasf = new HasF();\n   Manipulator&lt; HasF&gt; m = new Manipulator&lt; HasF&gt;(hasf);\n   m.manipulate()  // error\n }\n}\n</code></pre>\n<p>上面这段代码会报错，正是由于类型擦除导致的。因为类型擦除，所以泛型内部无法知道类型的信息，当你调用object没有的方法时，就会报错。</p>\n<h3 id=\"补充一点：边界\"><a href=\"#补充一点：边界\" class=\"headerlink\" title=\"补充一点：边界\"></a>补充一点：边界</h3><blockquote>\n<p>因为擦除在方法体中移除了类型信息，所以运行时，你就需要辨别边界，边界是指：对象进入和离开方法的地点，这里是指泛型的方法体。</p>\n<pre><code class=\"java\">public class ArrayMaker&lt; T&gt; {\n private Class&lt; T&gt; kind;\n public ArrayMaker(Class&lt;T&gt; kind) {\n   this.kind = kind;\n }\n @SuppressWarnings(&quot;unchecked&quot;)\n T[] create(int size) {\n   return (T[])Array.newInstance(kind, size);\n }\n public static void main(String[] args) {\n   ArrayMaker&lt; String&gt; stringMaker =\n     new ArrayMaker&lt; String&gt;(String.class);\n   String[] stringArray = stringMaker.create(9);\n   System.out.println(Arrays.toString(stringArray));\n }\n} /* Output:\n[null, null, null, null, null, null, null, null, null]\n*///:~\n</code></pre>\n<p>上面这段代码就是因为在泛型的方法体中初始化，所以就把所有的类型当成了Object类型，因此输出的结果都是null。如果是String对象的话，输出的是<strong>“  ”</strong></p>\n<p>仔细查看下面俩段代码：</p>\n<pre><code class=\"java\">// 不存在泛型\npublic class SimpleHolder {\n private Object obj;\n public void set(Object obj) { this.obj = obj; }\n public Object get() { return obj; }\n public static void main(String[] args) {\n   SimpleHolder holder = new SimpleHolder();\n   holder.set(&quot;Item&quot;);\n   String s = (String)holder.get();\n }\n} ///:~\n</code></pre>\n<pre><code class=\"java\">/// 存在泛型\npublic class GenericHolder&lt;T&gt; {\n private T obj;\n public void set(T obj) { this.obj = obj; }\n public T get() { return obj; }\n public static void main(String[] args) {\n   GenericHolder&lt; String &gt; holder =\n     new GenericHolder&lt; String &gt;();\n   holder.set(&quot;Item&quot;);\n   String s = holder.get();\n }\n} \n</code></pre>\n<p>但是如果你仔细查看俩段代码的字节码，你会发现是相同的。并且你会发现泛型所有的动作都是发生在边界处，会对传进来的值进行额外的编译检查，并插入对传递出去的值的类型。所以，可以得出一个结论，边界就是发生动作的地方。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"逆变与协变\"><a href=\"#逆变与协变\" class=\"headerlink\" title=\"逆变与协变\"></a>逆变与协变</h3><blockquote>\n<p>协变与逆变这来个术语是用来描述类型转换（type transformations）后的继承关系。定义如下：A,B表示类型<strong>≤ </strong>表示继承关系.(比如：A ≤B表示A是B派生出来的子类  )</p>\n<ul>\n<li>逆变（contravariant），当A≤B时，B可以转化成A。</li>\n<li>协变（covariant），A≤B时，A可以转换成B。</li>\n<li>不变（invariant），如果上述俩种均不能使用。</li>\n</ul>\n<p>先来看一个简单的例子：</p>\n<p>考虑List&lt; A &gt;是否是协变，逆变，不变？协变意味着List&lt; String &gt;是List&lt; Object&gt;的子类，逆变意味着List</p>\n<p>&lt; Object&gt;是List&lt; String&gt;的子类，不变意味着上面俩种都不是。在java中List&lt; String&gt;和List&lt; Object&gt;是不变的类型。下面的代码在java中是编译不过去的，验证了集合在java中是不变的。</p>\n<pre><code class=\"java\">ArrayList&lt;String&gt; strings = new ArrayList&lt;Object&gt;();\nArrayList&lt;Object&gt; objects = new ArrayList&lt;String&gt;();\n</code></pre>\n<p>在来看另外一个例子，数组 A[]，判断数组是逆变，协变，不变三个的哪一种？很容易可以证明，在java中数组是协变的</p>\n<pre><code class=\"java\">Object[] objs = new String[3]\n</code></pre>\n<p>下面这个例子是来研究方法,直接通过一个例子来说明</p>\n<pre><code class=\"java\">Number[] method(ArrayList&lt;Number&gt; list) {\n ...\n}\n//下面三个没有一个能编译过\nInteger[] result = method(new ArrayList&lt;Integer&gt;());\nNumber[] result = method(new ArrayList&lt;Integer&gt;());\nObject[] result = method(new ArrayList&lt;Object&gt;());\n//下面俩个能编译过\nNumber[] result = method(new ArrayList&lt;Number&gt;());\nObject[] result = method(new ArrayList&lt;Number&gt;());\n\n</code></pre>\n<p>调用方法<code>result = method(n)</code>；传入形参的类型应为method形参的子类型，即<code>typeof(n)≤typeof(method&#39;s parameter)</code>；result应为method返回值的基类型，即<code>typeof(methods&#39;s return)≤typeof(result)</code>：</p>\n<p>在Java 1.4中，子类覆盖（override）父类方法时，形参与返回值的类型必须与父类保持一致：</p>\n<pre><code class=\"java\">class Super {\n   Number method(Number n) { ... }\n}\n\nclass Sub extends Super {\n   @Override \n   Number method(Number n) { ... }\n}\n</code></pre>\n<p>从Java 1.5开始，子类覆盖父类方法时允许协变返回更为具体的类型：</p>\n<pre><code class=\"java\">class Super {\n   Number method(Number n) { ... }\n}\n\nclass Sub extends Super {\n   @Override \n   Integer method(Number n) { ... }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"？-的用法\"><a href=\"#？-的用法\" class=\"headerlink\" title=\"？ 的用法\"></a>？ 的用法</h3><blockquote>\n<p>下面是使用案例</p>\n<pre><code class=\"Java\">public class UnboundedWildcardsl {\n   static List list1;\n   static List&lt;?&gt; list2;\n   static List&lt;? extends Object&gt; list3;\n//    @SuppressWarnings(&quot;unchecked&quot;)\n   static void assign1(List list){\n       list1 = list;\n       list2 = list;\n\n       list3 = list;     //未检查的转换\n   }\n   static void assign2(List&lt;?&gt; list){\n       list1 = list;\n       list2 = list;\n       list3 = list;\n   }\n   static void assign3(List&lt;? extends Object&gt; list){\n       list1 = list;\n       list2 = list;\n       list3 = list;\n   }\n\n   public static void main(String[] args) {\n       assign1(new ArrayList());\n       assign2(new ArrayList());\n       assign3(new ArrayList());\n\n       assign1(new ArrayList&lt;&gt;());\n       assign2(new ArrayList&lt;&gt;());\n       assign3(new ArrayList&lt;&gt;());\n\n       List&lt;?&gt; wildList = new ArrayList();\n       wildList = new ArrayList&lt;String&gt;();\n       assign1(wildList);\n       assign2(wildList);\n       assign3(wildList);\n   }\n}\n</code></pre>\n<p>在很多情况下你会看到和这个情况类似，编译器很少关心使用的是原生类型还是&lt; ?&gt;，这些情况&lt; ?&gt; 被认为是一种装饰，不过还是有价值的，即我想用java泛型来编写代码。我在这里并不是要使用原生的类型，但是这种情况下，泛型参数可以支持有任何类型。</p>\n</blockquote>\n<h3 id=\"extends-的用法\"><a href=\"#extends-的用法\" class=\"headerlink\" title=\"extends 的用法\"></a>extends 的用法</h3><blockquote>\n<p>extends表示的是上界通配符，下面展示的是如何使用:以 List&lt;? extends Number&gt; 为例来展示使用</p>\n<pre><code class=\"Java\">//Number extends Number \nList&lt;? extends Number&gt;  foo3 = new ArrayList&lt;? extends Number&gt;();\n\n//Integer extends Number\nList&lt;? extends Number&gt; foo3 = new ArrayList&lt;? extends Integer&gt;();\n\n//Double extends Number\nList&lt;? extends Number&gt; foo3 = new ArrayList&lt;? extends Double&gt;();\n\n//下面的是错误使用\nfoo3.add(12);\n\n</code></pre>\n<ol>\n<li><p>读取操作通过以上给定的赋值语句，你一定能从foo3列表中读取到的元素的类型是什么呢？你可以读取到Number，因为以上的列表要么包含Number元素，要么包含Number的子类元素。</p>\n<p>你不能保证读取到Integer，因为foo3可能指向的是List&lt; Double&gt;。</p>\n<p>你不能保证读取到Double，因为foo3可能指向的是List&lt; Integer&gt;。</p>\n</li>\n<li><p>写入操作过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？</p>\n<p>你不能插入一个Integer元素，因为foo3可能指向List&lt; Double&gt;。</p>\n<p>你不能插入一个Double元素，因为foo3可能指向List&lt; Integer&gt;。</p>\n<p>你不能插入一个Number元素，因为foo3可能指向List&lt; Integer&gt;。</p>\n<p>你不能往List&lt; ? extends T&gt;中插入任何类型的对象，因为你不能保证列表实际指向的类型是什么，你并不能保证列表中实际存储什么类型的对象。唯一可以保证的是，你可以从中读取到T或者T的子类。这也验证了java集合是不变的，由于无法判断类型，所以你也无法进行插入。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"super-的用法\"><a href=\"#super-的用法\" class=\"headerlink\" title=\"super 的用法\"></a>super 的用法</h3><blockquote>\n<p>super下界通配符，下面以List\\&lt;？ super Integer&gt;来展示super的用法</p>\n<pre><code class=\"java\">//integer is a superClass of Integer \nList&lt;? super Integer&gt;  foo3 = new ArrayList&lt;Integer&gt;()\n\n//Number is a superClass of Integer\nList&lt;? super Integer&gt; foo3 = new ArrayList&lt;Number&gt;();\n\n//Object is superClass of Integer\nList&lt;? super Integer&gt; foo3 = new ArrayList&lt;Object&gt;();\n\n//下面代码是错误的\nlist.get(index);  //不能获取\n</code></pre>\n<ol>\n<li><p>foo3可能指向List&lt; Number&gt;或者List&lt; Object&gt;。</p>\n<p>你不能保证读取到Number，因为foo3可能指向List&lt; Object&gt;。</p>\n<p>唯一可以保证的是，你可以读取到Object或者Object子类的对象（你并不知道具体的子类是什么）。</p>\n</li>\n<li><p>写入操作通过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到foo3中呢？你可以插入Integer对象，因为上述声明的列表都支持Integer。</p>\n<p>你可以插入Integer的子类的对象，因为Integer的子类同时也是Integer，原因同上。</p>\n<p>你不能插入Double对象，因为foo3可能指向ArrayList&lt; Integer&gt;。</p>\n<p>你不能插入Number对象，因为foo3可能指向ArrayList&lt; Integer&gt;。</p>\n<p>你不能插入Object对象，因为foo3可能指向ArrayList&lt; Integer&gt;。</p>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"PECS-Pruducer-extends-Consumer-super\"><a href=\"#PECS-Pruducer-extends-Consumer-super\" class=\"headerlink\" title=\"PECS(Pruducer extends,Consumer super)\"></a>PECS(Pruducer extends,Consumer super)</h4><blockquote>\n<p>请记住PECS原则：生产者（Producer）使用extends，消费者（Consumer）使用super。</p>\n<ul>\n<li>生产者使用extends</li>\n</ul>\n<p>如果你需要一个列表提供T类型的元素（即你想从列表中读取T类型的元素），你需要把这个列表声明成\\&lt;? extends T&gt;，比如List\\&lt;? extends Integer&gt;，因此你不能往该列表中添加任何元素。</p>\n<ul>\n<li>消费者使用super</li>\n</ul>\n<p>如果需要一个列表使用T类型的元素（即你想把T类型的元素加入到列表中），你需要把这个列表声明成\\&lt;? super T&gt;，比如List\\&lt;? super Integer&gt;，因此你不能保证从中读取到的元素的类型。</p>\n<ul>\n<li>即是生产者，也是消费者</li>\n</ul>\n<p>如果一个列表即要生产，又要消费，你不能使用泛型通配符声明列表，比如List\\<integer>。</integer></p>\n<p>请参考java.util.Collections里的copy方法(JDK1.7)：copy使用到了PECS原则，实现了对参数的保护。</p>\n<pre><code class=\"Java\">/**\n    * Copies all of the elements from one list into another.  After the\n    * operation, the index of each copied element in the destination list\n    * will be identical to its index in the source list.  The destination\n    * list must be at least as long as the source list.  If it is longer, the\n    * remaining elements in the destination list are unaffected. &lt;p&gt;\n    *\n    * This method runs in linear time.\n    *\n    * @param  &lt;T&gt; the class of the objects in the lists\n    * @param  dest The destination list.\n    * @param  src The source list.\n    * @throws IndexOutOfBoundsException if the destination list is too small\n    *         to contain the entire source List.\n    * @throws UnsupportedOperationException if the destination list&#39;s\n    *         list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.\n    */\n   public static &lt; T&gt; void copy(List&lt; ? super T&gt; dest, List&lt;? extends T&gt; src) {\n       int srcSize = src.size();\n       if (srcSize &gt; dest.size())\n           throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);\n\n       if (srcSize &lt; COPY_THRESHOLD ||\n           (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) {\n           for (int i=0; i&lt;srcSize; i++)\n               dest.set(i, src.get(i));\n       } else {\n           ListIterator&lt; ? super T&gt; di=dest.listIterator();\n           ListIterator&lt; ? extends T&gt; si=src.listIterator();\n           for (int i=0; i&lt;srcSize; i++) {\n               di.next();\n               di.set(si.next());\n           }\n       }\n   }\n</code></pre>\n</blockquote>\n"},{"abbrlink":15,"title":"内部类的定义与分类","author":"zhangke","date":"2018-03-22T09:14:00.000Z","_content":"# 内部类的定义与分类\n\n>在《Thinking in Java》这本书里面给出的定义是：可以将一个类的定义放在另一个类的定义内部就是内部类。用一段代码来说明就是下面这样的\n>\n>```\n>class Outter{\n>  class InnerClass{}\n>}\n>```\n>\n>其中InnerClass就是内部类。\n>\n>内部类大体上可以划分为以下几种：成员内部类，局部内部类，静态内部类，匿名内部类。下面我将依次讲解这几种内部类。\n>\n>\n\n### 成员内部类\n\n> 成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，即使是private属性成员和方法也可以访问。但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。\n>\n> 在成员内部类中要注意的几点：\n>\n> **第一：**成员内部类中不能存在任何static的变量和方法；\n>\n> **第二：**成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。\n>\n> **第三**：成员内部类也是有包的权限的，如果是public，则在任何一个包下面都可以使用，没有权限修饰符的则  \n>\n> ​           只能在当前包下面使用。private则只能在当前类中使用，protected则可以在子类中使用。\n>\n> 下面我们来看一个案例\n>\n> ```java\n> public class OuterClass {\n>    private String str;\n>    \n>    public void outerDisplay(){\n>        System.out.println(\"outerClass...\");\n>    }\n>    \n>    public class InnerClass{\n>        public void innerDisplay(){\n>            //使用外围内的属性\n>            str = \"chenssy...\";\n>            System.out.println(str);\n>            //使用外围内的方法\n>            outerDisplay();\n>        }\n>    }\n>    \n>    /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */\n>    public InnerClass getInnerClass(){\n>        return new InnerClass();\n>    }\n>    \n>    public static void main(String[] args) {\n>        OuterClass outer = new OuterClass();\n>        OuterClass.InnerClass inner = outer.getInnerClass();\n>        inner.innerDisplay();\n>    }\n> }\n> --------------------\n> chenssy...\n> outerClass...\n> ```\n>\n> ### .this 和 .new的使用\n>\n> 如果你需要在内部类生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。\n>\n> ### **.this**使用\n>\n> >```\n> >public class OutterClass {\n> >\n> >\n> >    private int key = 0;\n> >    private int key2 = 0;\n> >\n> >\n> >    public static void main(String[] args) {\n> >        OutterClass k1 = new OutterClass();\n> >        InnerClass in = k1.new InnerClass(); //生成内部类\n> >        OutterClass k2 = in.getOutterClass(); //通过 .this 来生成外部类\n> >        System.out.println(k1 == k2); //true 说明俩个对象指向同一个引用\n> >    }\n> >\n> >    public int getKey() {\n> >        return this.key;\n> >    }\n> >\n> >    public class InnerClass {\n> >\n> >        public InnerClass() {\n> >            key = 12;\n> >            key2 = 13;\n> >        }\n> >\n> >        public int getKey() {\n> >            // 通过 .this 来使用外部类的getKey\n> >            return OutterClass.this.getKey();\n> >        }\n> >\t\t// 使用 .this 返回外部类对象\n> >        public OutterClass getOutterClass() {\n> >            return OutterClass.this;\n> >        }\n> >    }\n> >}\n> >---------------\n> >outPut:\n> >true\n> >```\n> >\n> >这个例子演示了**.this**的使用，同时也证明了**.this**返回的就是外部类生成的对象。\n>\n> ###  **.new **使用\n>\n> > 如果希望创建内部类对象，则必须先拥有外部类对象前提下才能创建，这是因为内部类对象会暗暗地连接到创建它的外部类对象上。这里就先不仔细说明，等看过例子之后在来说明好理解一些。创建内部类的格式是\n> >\n> > ```\n> > outterObject.new    outterclass.innerClass\n> > ```\n> >\n> > 也就是外部类的对象后面跟上圆点和new。\n> >\n> > ```\n> > public class OuterClass {\n> >    private String name ;\n> >    private int age;\n> >\n> >    /**省略getter和setter方法**/\n> >    \n> >    public class InnerClass{\n> >        public InnerClass(){\n> >            name = \"chenssy\";\n> >            age = 23;\n> >        }\n> >        \n> >        public void display(){\n> >            System.out.println(\"name：\" + getName() +\"   ;age：\" + getAge());\n> >        }\n> >    }\n> >    \n> >    public static void main(String[] args) {\n> >        OuterClass outerClass = new OuterClass();\n> >        OuterClass.InnerClass innerClass = outerClass.new InnerClass();\n> >        innerClass.display();\n> >    }\n> > }\n> > --------------\n> > Output：\n> > name：chenssy   ;age：23\n> > ```\n> >\n> > \n>\n> \n>\n> 通过上面的例子你大概能明白**.this**和**.new**的作用。\n>\n> 通过上面的介绍相信你对成员内部类有一定的了解了，但肯定也会有一些以后，为什么内部类会自动拥有对其外部类所有成员的访问权。这是如何做到的呢？当某个外部类创建完一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，当你访问此外围类的成员时，就是用那个引用来选择外围类的成员。幸运的是，编译器会帮你处理所有的细节。\n>\n> \n>\n> \n\n### 局部内部类\n\n>其实这个名字不是太好，但是又不知道起什么名字。这一部分讲解的类主要是在方法和作用域内的内部类。在一个方法里面或者任意的作用域内定义内部类的理由有俩个：\n>\n>1. 实现了某类型的接口，于是可以创建并返回对其的引用。\n>2. 你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但又不希望这个类是公共可用的。\n>\n>下面使用来个具体的例子来讲解，因为这一部分没有什么好讲解的，主要是自己体会。\n>\n>```Java\n>public class Parcel5{\n>  private int i= 0;\n>  public Destination destination(String s ){\n>    class PDestination implements Destination{\n>      private String label;\n>      private PDestination(Strng whereTo){\n>        label = whereTo;\n>      }\n>      public String readLable(){\n>        return label;\n>      }\n>    }\n>    return new PDestination(s);\n>  }\n>  public static void main(String[] args){\n>    Parcel5 p =new Parcel5();\n>    Destination d = p.destination(\"fuyang\");\n>  }\n>}\n>```\n>\n>上面的代码演示的是定义在方法中的内部类，不过在这里有一点需要注意的是，这个内部类的范围是在方法内。也就是他的作用域就在方法内部。所以方法外面的属性是访问不到的，但是可以访问方法内的变量。\n>\n>```java\n>public class Parcel6 {\n>    private void internalTracking(boolean b){\n>        if(b){\n>            class TrackingSlip{\n>                private String id;\n>                TrackingSlip(String s) {\n>                    id = s;\n>                }\n>                String getSlip(){\n>                    return id;\n>                }\n>            }\n>            TrackingSlip ts = new TrackingSlip(\"chenssy\");\n>            String string = ts.getSlip();\n>        }\n>      \n>      \t// 到这里就不能使用上面定义的TrackingSlip内部类了。\n>        //下面这句话就会编译报错\n>      \t// TrackingSlip ts = new TrackingSlip(\"chenssy\");\n>    }\n>    \n>    public void track(){\n>        internalTracking(true);\n>    }\n>    \n>    public static void main(String[] args) {\n>        Parcel6 parcel6 = new Parcel6();\n>        parcel6.track();\n>    }\n>}\n>```\n>\n>\n>\n>\n\n### 静态内部类\n\n> 使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：\n>\n> ​      **1、** 它的创建是不需要依赖于外围类的。\n>\n> ​      **2、** 它不能使用任何外围类的非static成员变量和方法。\n>\n> ```java\n> public class OuterClass {\n>    private String sex;\n>    public static String name = \"chenssy\";\n>    \n>    /**\n>     *静态内部类\n>     */\n>    static class InnerClass1{\n>        /* 在静态内部类中可以存在静态成员 */\n>        public static String _name1 = \"chenssy_static\";\n>        \n>        public void display(){\n>            /* \n>             * 静态内部类只能访问外围类的静态成员变量和方法\n>             * 不能访问外围类的非静态成员变量和方法\n>             */\n>            System.out.println(\"OutClass name :\" + name);\n>        }\n>    }\n>    \n>    /**\n>     * 非静态内部类\n>     */\n>    class InnerClass2{\n>        /* 非静态内部类中不能存在静态成员 */\n>        public String _name2 = \"chenssy_inner\";\n>        /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */\n>        public void display(){\n>            System.out.println(\"OuterClass name：\" + name);\n>        }\n>    }\n>    \n>  \n>    public void display(){\n>        /* 外围类访问静态内部类：内部类. */\n>        System.out.println(InnerClass1._name1);\n>        /* 静态内部类 可以直接创建实例不需要依赖于外围类 */\n>        new InnerClass1().display();\n>        \n>        /* 非静态内部的创建需要依赖于外围类 */\n>        OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2();\n>        /* 方位非静态内部类的成员需要使用非静态内部类的实例 */\n>        System.out.println(inner2._name2);\n>        inner2.display();\n>    }\n>    \n>    public static void main(String[] args) {\n>        OuterClass outer = new OuterClass();\n>        outer.display();\n>    }\n> }\n> ----------------\n> Output:\n> chenssy_static\n> OutClass name :chenssy\n> chenssy_inner\n> OuterClass name：chenssy\n> ```\n>\n> \n>\n> \n\n### 匿名内部类\n\n>匿名内部类可以简单理解就是没有名字的类。我们直接用例子演示可以说的更清楚。\n>\n>```java\n>button2.addActionListener(  \n>                new ActionListener(){  \n>                    public void actionPerformed(ActionEvent e) {  \n>                        System.out.println(\"你按了按钮二\");  \n>                    }  \n>                });\n>```\n>\n>相信很多人都写过与上面类似的代码，这其实就是匿名类。其实就是在定义的时候就创建这个类的对象，但因为没有类名，所以以后就不能在创建使用。\n>\n>````java\n>public class OuterClass {\n>    public InnerClass getInnerClass(final int num,String str2){\n>        return new InnerClass(){\n>            int number = num + 3;\n>            public int getNumber(){\n>                return number;\n>            }\n>        };  /* 注意：分号不能省 */\n>    }\n>    \n>    public static void main(String[] args) {\n>        OuterClass out = new OuterClass();\n>        InnerClass inner = out.getInnerClass(2, \"chenssy\");\n>        System.out.println(inner.getNumber());\n>    }\n>}\n>\n>interface InnerClass {\n>    int getNumber();\n>}\n>\n>----------------\n>Output:\n>````\n>\n>  这里我们就需要看清几个地方\n>\n>​        **1、** 匿名内部类是没有访问修饰符的。\n>\n>​        **2、** new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。\n>\n>​         **3、** 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。\n>\n>​        **4、** 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。\n>\n>\n>\n>\n\n### 为什么要使用内部类\n\n>​        使用内部类最吸引人的原因是：**每个内部类都能独立的继承自一个接口的实现，所以无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响**。\n>\n>​         在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。\n>\n>同时使用内部类还可以获得以下的一些特性：\n>\n>1. 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围里对象的信息相互独立。\n>2. 在单个外围类中，可以多个内部类以不同的方式实现同一个接口或者继承同一个类。\n>3. 创建内部类对象的时刻并不依赖于外部类的创建。\n>4. 内部类并没有令人迷惑的\"is-a\"关系，他就是一个独立的实体。\n>\n>以上主要摘自《Thinking in java》","source":"_posts/内部类.md","raw":"abbrlink: 15\ntitle: 内部类的定义与分类\ntags:\n  - java基础\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-03-22 17:14:00\n---\n# 内部类的定义与分类\n\n>在《Thinking in Java》这本书里面给出的定义是：可以将一个类的定义放在另一个类的定义内部就是内部类。用一段代码来说明就是下面这样的\n>\n>```\n>class Outter{\n>  class InnerClass{}\n>}\n>```\n>\n>其中InnerClass就是内部类。\n>\n>内部类大体上可以划分为以下几种：成员内部类，局部内部类，静态内部类，匿名内部类。下面我将依次讲解这几种内部类。\n>\n>\n\n### 成员内部类\n\n> 成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，即使是private属性成员和方法也可以访问。但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。\n>\n> 在成员内部类中要注意的几点：\n>\n> **第一：**成员内部类中不能存在任何static的变量和方法；\n>\n> **第二：**成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。\n>\n> **第三**：成员内部类也是有包的权限的，如果是public，则在任何一个包下面都可以使用，没有权限修饰符的则  \n>\n> ​           只能在当前包下面使用。private则只能在当前类中使用，protected则可以在子类中使用。\n>\n> 下面我们来看一个案例\n>\n> ```java\n> public class OuterClass {\n>    private String str;\n>    \n>    public void outerDisplay(){\n>        System.out.println(\"outerClass...\");\n>    }\n>    \n>    public class InnerClass{\n>        public void innerDisplay(){\n>            //使用外围内的属性\n>            str = \"chenssy...\";\n>            System.out.println(str);\n>            //使用外围内的方法\n>            outerDisplay();\n>        }\n>    }\n>    \n>    /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */\n>    public InnerClass getInnerClass(){\n>        return new InnerClass();\n>    }\n>    \n>    public static void main(String[] args) {\n>        OuterClass outer = new OuterClass();\n>        OuterClass.InnerClass inner = outer.getInnerClass();\n>        inner.innerDisplay();\n>    }\n> }\n> --------------------\n> chenssy...\n> outerClass...\n> ```\n>\n> ### .this 和 .new的使用\n>\n> 如果你需要在内部类生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。\n>\n> ### **.this**使用\n>\n> >```\n> >public class OutterClass {\n> >\n> >\n> >    private int key = 0;\n> >    private int key2 = 0;\n> >\n> >\n> >    public static void main(String[] args) {\n> >        OutterClass k1 = new OutterClass();\n> >        InnerClass in = k1.new InnerClass(); //生成内部类\n> >        OutterClass k2 = in.getOutterClass(); //通过 .this 来生成外部类\n> >        System.out.println(k1 == k2); //true 说明俩个对象指向同一个引用\n> >    }\n> >\n> >    public int getKey() {\n> >        return this.key;\n> >    }\n> >\n> >    public class InnerClass {\n> >\n> >        public InnerClass() {\n> >            key = 12;\n> >            key2 = 13;\n> >        }\n> >\n> >        public int getKey() {\n> >            // 通过 .this 来使用外部类的getKey\n> >            return OutterClass.this.getKey();\n> >        }\n> >\t\t// 使用 .this 返回外部类对象\n> >        public OutterClass getOutterClass() {\n> >            return OutterClass.this;\n> >        }\n> >    }\n> >}\n> >---------------\n> >outPut:\n> >true\n> >```\n> >\n> >这个例子演示了**.this**的使用，同时也证明了**.this**返回的就是外部类生成的对象。\n>\n> ###  **.new **使用\n>\n> > 如果希望创建内部类对象，则必须先拥有外部类对象前提下才能创建，这是因为内部类对象会暗暗地连接到创建它的外部类对象上。这里就先不仔细说明，等看过例子之后在来说明好理解一些。创建内部类的格式是\n> >\n> > ```\n> > outterObject.new    outterclass.innerClass\n> > ```\n> >\n> > 也就是外部类的对象后面跟上圆点和new。\n> >\n> > ```\n> > public class OuterClass {\n> >    private String name ;\n> >    private int age;\n> >\n> >    /**省略getter和setter方法**/\n> >    \n> >    public class InnerClass{\n> >        public InnerClass(){\n> >            name = \"chenssy\";\n> >            age = 23;\n> >        }\n> >        \n> >        public void display(){\n> >            System.out.println(\"name：\" + getName() +\"   ;age：\" + getAge());\n> >        }\n> >    }\n> >    \n> >    public static void main(String[] args) {\n> >        OuterClass outerClass = new OuterClass();\n> >        OuterClass.InnerClass innerClass = outerClass.new InnerClass();\n> >        innerClass.display();\n> >    }\n> > }\n> > --------------\n> > Output：\n> > name：chenssy   ;age：23\n> > ```\n> >\n> > \n>\n> \n>\n> 通过上面的例子你大概能明白**.this**和**.new**的作用。\n>\n> 通过上面的介绍相信你对成员内部类有一定的了解了，但肯定也会有一些以后，为什么内部类会自动拥有对其外部类所有成员的访问权。这是如何做到的呢？当某个外部类创建完一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，当你访问此外围类的成员时，就是用那个引用来选择外围类的成员。幸运的是，编译器会帮你处理所有的细节。\n>\n> \n>\n> \n\n### 局部内部类\n\n>其实这个名字不是太好，但是又不知道起什么名字。这一部分讲解的类主要是在方法和作用域内的内部类。在一个方法里面或者任意的作用域内定义内部类的理由有俩个：\n>\n>1. 实现了某类型的接口，于是可以创建并返回对其的引用。\n>2. 你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但又不希望这个类是公共可用的。\n>\n>下面使用来个具体的例子来讲解，因为这一部分没有什么好讲解的，主要是自己体会。\n>\n>```Java\n>public class Parcel5{\n>  private int i= 0;\n>  public Destination destination(String s ){\n>    class PDestination implements Destination{\n>      private String label;\n>      private PDestination(Strng whereTo){\n>        label = whereTo;\n>      }\n>      public String readLable(){\n>        return label;\n>      }\n>    }\n>    return new PDestination(s);\n>  }\n>  public static void main(String[] args){\n>    Parcel5 p =new Parcel5();\n>    Destination d = p.destination(\"fuyang\");\n>  }\n>}\n>```\n>\n>上面的代码演示的是定义在方法中的内部类，不过在这里有一点需要注意的是，这个内部类的范围是在方法内。也就是他的作用域就在方法内部。所以方法外面的属性是访问不到的，但是可以访问方法内的变量。\n>\n>```java\n>public class Parcel6 {\n>    private void internalTracking(boolean b){\n>        if(b){\n>            class TrackingSlip{\n>                private String id;\n>                TrackingSlip(String s) {\n>                    id = s;\n>                }\n>                String getSlip(){\n>                    return id;\n>                }\n>            }\n>            TrackingSlip ts = new TrackingSlip(\"chenssy\");\n>            String string = ts.getSlip();\n>        }\n>      \n>      \t// 到这里就不能使用上面定义的TrackingSlip内部类了。\n>        //下面这句话就会编译报错\n>      \t// TrackingSlip ts = new TrackingSlip(\"chenssy\");\n>    }\n>    \n>    public void track(){\n>        internalTracking(true);\n>    }\n>    \n>    public static void main(String[] args) {\n>        Parcel6 parcel6 = new Parcel6();\n>        parcel6.track();\n>    }\n>}\n>```\n>\n>\n>\n>\n\n### 静态内部类\n\n> 使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：\n>\n> ​      **1、** 它的创建是不需要依赖于外围类的。\n>\n> ​      **2、** 它不能使用任何外围类的非static成员变量和方法。\n>\n> ```java\n> public class OuterClass {\n>    private String sex;\n>    public static String name = \"chenssy\";\n>    \n>    /**\n>     *静态内部类\n>     */\n>    static class InnerClass1{\n>        /* 在静态内部类中可以存在静态成员 */\n>        public static String _name1 = \"chenssy_static\";\n>        \n>        public void display(){\n>            /* \n>             * 静态内部类只能访问外围类的静态成员变量和方法\n>             * 不能访问外围类的非静态成员变量和方法\n>             */\n>            System.out.println(\"OutClass name :\" + name);\n>        }\n>    }\n>    \n>    /**\n>     * 非静态内部类\n>     */\n>    class InnerClass2{\n>        /* 非静态内部类中不能存在静态成员 */\n>        public String _name2 = \"chenssy_inner\";\n>        /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */\n>        public void display(){\n>            System.out.println(\"OuterClass name：\" + name);\n>        }\n>    }\n>    \n>  \n>    public void display(){\n>        /* 外围类访问静态内部类：内部类. */\n>        System.out.println(InnerClass1._name1);\n>        /* 静态内部类 可以直接创建实例不需要依赖于外围类 */\n>        new InnerClass1().display();\n>        \n>        /* 非静态内部的创建需要依赖于外围类 */\n>        OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2();\n>        /* 方位非静态内部类的成员需要使用非静态内部类的实例 */\n>        System.out.println(inner2._name2);\n>        inner2.display();\n>    }\n>    \n>    public static void main(String[] args) {\n>        OuterClass outer = new OuterClass();\n>        outer.display();\n>    }\n> }\n> ----------------\n> Output:\n> chenssy_static\n> OutClass name :chenssy\n> chenssy_inner\n> OuterClass name：chenssy\n> ```\n>\n> \n>\n> \n\n### 匿名内部类\n\n>匿名内部类可以简单理解就是没有名字的类。我们直接用例子演示可以说的更清楚。\n>\n>```java\n>button2.addActionListener(  \n>                new ActionListener(){  \n>                    public void actionPerformed(ActionEvent e) {  \n>                        System.out.println(\"你按了按钮二\");  \n>                    }  \n>                });\n>```\n>\n>相信很多人都写过与上面类似的代码，这其实就是匿名类。其实就是在定义的时候就创建这个类的对象，但因为没有类名，所以以后就不能在创建使用。\n>\n>````java\n>public class OuterClass {\n>    public InnerClass getInnerClass(final int num,String str2){\n>        return new InnerClass(){\n>            int number = num + 3;\n>            public int getNumber(){\n>                return number;\n>            }\n>        };  /* 注意：分号不能省 */\n>    }\n>    \n>    public static void main(String[] args) {\n>        OuterClass out = new OuterClass();\n>        InnerClass inner = out.getInnerClass(2, \"chenssy\");\n>        System.out.println(inner.getNumber());\n>    }\n>}\n>\n>interface InnerClass {\n>    int getNumber();\n>}\n>\n>----------------\n>Output:\n>````\n>\n>  这里我们就需要看清几个地方\n>\n>​        **1、** 匿名内部类是没有访问修饰符的。\n>\n>​        **2、** new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。\n>\n>​         **3、** 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。\n>\n>​        **4、** 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。\n>\n>\n>\n>\n\n### 为什么要使用内部类\n\n>​        使用内部类最吸引人的原因是：**每个内部类都能独立的继承自一个接口的实现，所以无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响**。\n>\n>​         在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。\n>\n>同时使用内部类还可以获得以下的一些特性：\n>\n>1. 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围里对象的信息相互独立。\n>2. 在单个外围类中，可以多个内部类以不同的方式实现同一个接口或者继承同一个类。\n>3. 创建内部类对象的时刻并不依赖于外部类的创建。\n>4. 内部类并没有令人迷惑的\"is-a\"关系，他就是一个独立的实体。\n>\n>以上主要摘自《Thinking in java》","slug":"内部类","published":1,"updated":"2019-01-04T01:48:59.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx30001qeb1u1x0d481h","content":"<h1 id=\"内部类的定义与分类\"><a href=\"#内部类的定义与分类\" class=\"headerlink\" title=\"内部类的定义与分类\"></a>内部类的定义与分类</h1><blockquote>\n<p>在《Thinking in Java》这本书里面给出的定义是：可以将一个类的定义放在另一个类的定义内部就是内部类。用一段代码来说明就是下面这样的</p>\n<pre><code>class Outter{\n class InnerClass{}\n}\n</code></pre><p>其中InnerClass就是内部类。</p>\n<p>内部类大体上可以划分为以下几种：成员内部类，局部内部类，静态内部类，匿名内部类。下面我将依次讲解这几种内部类。</p>\n</blockquote>\n<h3 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h3><blockquote>\n<p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，即使是private属性成员和方法也可以访问。但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。</p>\n<p>在成员内部类中要注意的几点：</p>\n<p><strong>第一：</strong>成员内部类中不能存在任何static的变量和方法；</p>\n<p><strong>第二：</strong>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。</p>\n<p><strong>第三</strong>：成员内部类也是有包的权限的，如果是public，则在任何一个包下面都可以使用，没有权限修饰符的则  </p>\n<p>​           只能在当前包下面使用。private则只能在当前类中使用，protected则可以在子类中使用。</p>\n<p>下面我们来看一个案例</p>\n<pre><code class=\"java\">public class OuterClass {\n   private String str;\n\n   public void outerDisplay(){\n       System.out.println(&quot;outerClass...&quot;);\n   }\n\n   public class InnerClass{\n       public void innerDisplay(){\n           //使用外围内的属性\n           str = &quot;chenssy...&quot;;\n           System.out.println(str);\n           //使用外围内的方法\n           outerDisplay();\n       }\n   }\n\n   /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */\n   public InnerClass getInnerClass(){\n       return new InnerClass();\n   }\n\n   public static void main(String[] args) {\n       OuterClass outer = new OuterClass();\n       OuterClass.InnerClass inner = outer.getInnerClass();\n       inner.innerDisplay();\n   }\n}\n--------------------\nchenssy...\nouterClass...\n</code></pre>\n<h3 id=\"this-和-new的使用\"><a href=\"#this-和-new的使用\" class=\"headerlink\" title=\".this 和 .new的使用\"></a>.this 和 .new的使用</h3><p>如果你需要在内部类生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。</p>\n<h3 id=\"this使用\"><a href=\"#this使用\" class=\"headerlink\" title=\".this使用\"></a><strong>.this</strong>使用</h3><blockquote>\n<pre><code>public class OutterClass {\n\n\n   private int key = 0;\n   private int key2 = 0;\n\n\n   public static void main(String[] args) {\n       OutterClass k1 = new OutterClass();\n       InnerClass in = k1.new InnerClass(); //生成内部类\n       OutterClass k2 = in.getOutterClass(); //通过 .this 来生成外部类\n       System.out.println(k1 == k2); //true 说明俩个对象指向同一个引用\n   }\n\n   public int getKey() {\n       return this.key;\n   }\n\n   public class InnerClass {\n\n       public InnerClass() {\n           key = 12;\n           key2 = 13;\n       }\n\n       public int getKey() {\n           // 通过 .this 来使用外部类的getKey\n           return OutterClass.this.getKey();\n       }\n       // 使用 .this 返回外部类对象\n       public OutterClass getOutterClass() {\n           return OutterClass.this;\n       }\n   }\n}\n---------------\noutPut:\ntrue\n</code></pre><p>这个例子演示了<strong>.this</strong>的使用，同时也证明了<strong>.this</strong>返回的就是外部类生成的对象。</p>\n</blockquote>\n<h3 id=\"new-使用\"><a href=\"#new-使用\" class=\"headerlink\" title=\".new 使用\"></a><strong>.new </strong>使用</h3><blockquote>\n<p>如果希望创建内部类对象，则必须先拥有外部类对象前提下才能创建，这是因为内部类对象会暗暗地连接到创建它的外部类对象上。这里就先不仔细说明，等看过例子之后在来说明好理解一些。创建内部类的格式是</p>\n<pre><code>outterObject.new    outterclass.innerClass\n</code></pre><p>也就是外部类的对象后面跟上圆点和new。</p>\n<pre><code>public class OuterClass {\n   private String name ;\n   private int age;\n\n   /**省略getter和setter方法**/\n\n   public class InnerClass{\n       public InnerClass(){\n           name = &quot;chenssy&quot;;\n           age = 23;\n       }\n\n       public void display(){\n           System.out.println(&quot;name：&quot; + getName() +&quot;   ;age：&quot; + getAge());\n       }\n   }\n\n   public static void main(String[] args) {\n       OuterClass outerClass = new OuterClass();\n       OuterClass.InnerClass innerClass = outerClass.new InnerClass();\n       innerClass.display();\n   }\n}\n--------------\nOutput：\nname：chenssy   ;age：23\n</code></pre></blockquote>\n<p>通过上面的例子你大概能明白<strong>.this</strong>和<strong>.new</strong>的作用。</p>\n<p>通过上面的介绍相信你对成员内部类有一定的了解了，但肯定也会有一些以后，为什么内部类会自动拥有对其外部类所有成员的访问权。这是如何做到的呢？当某个外部类创建完一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，当你访问此外围类的成员时，就是用那个引用来选择外围类的成员。幸运的是，编译器会帮你处理所有的细节。</p>\n</blockquote>\n<h3 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h3><blockquote>\n<p>其实这个名字不是太好，但是又不知道起什么名字。这一部分讲解的类主要是在方法和作用域内的内部类。在一个方法里面或者任意的作用域内定义内部类的理由有俩个：</p>\n<ol>\n<li>实现了某类型的接口，于是可以创建并返回对其的引用。</li>\n<li>你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但又不希望这个类是公共可用的。</li>\n</ol>\n<p>下面使用来个具体的例子来讲解，因为这一部分没有什么好讲解的，主要是自己体会。</p>\n<pre><code class=\"Java\">public class Parcel5{\n private int i= 0;\n public Destination destination(String s ){\n   class PDestination implements Destination{\n     private String label;\n     private PDestination(Strng whereTo){\n       label = whereTo;\n     }\n     public String readLable(){\n       return label;\n     }\n   }\n   return new PDestination(s);\n }\n public static void main(String[] args){\n   Parcel5 p =new Parcel5();\n   Destination d = p.destination(&quot;fuyang&quot;);\n }\n}\n</code></pre>\n<p>上面的代码演示的是定义在方法中的内部类，不过在这里有一点需要注意的是，这个内部类的范围是在方法内。也就是他的作用域就在方法内部。所以方法外面的属性是访问不到的，但是可以访问方法内的变量。</p>\n<pre><code class=\"java\">public class Parcel6 {\n   private void internalTracking(boolean b){\n       if(b){\n           class TrackingSlip{\n               private String id;\n               TrackingSlip(String s) {\n                   id = s;\n               }\n               String getSlip(){\n                   return id;\n               }\n           }\n           TrackingSlip ts = new TrackingSlip(&quot;chenssy&quot;);\n           String string = ts.getSlip();\n       }\n\n         // 到这里就不能使用上面定义的TrackingSlip内部类了。\n       //下面这句话就会编译报错\n         // TrackingSlip ts = new TrackingSlip(&quot;chenssy&quot;);\n   }\n\n   public void track(){\n       internalTracking(true);\n   }\n\n   public static void main(String[] args) {\n       Parcel6 parcel6 = new Parcel6();\n       parcel6.track();\n   }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><blockquote>\n<p>使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：</p>\n<p>​      <strong>1、</strong> 它的创建是不需要依赖于外围类的。</p>\n<p>​      <strong>2、</strong> 它不能使用任何外围类的非static成员变量和方法。</p>\n<pre><code class=\"java\">public class OuterClass {\n   private String sex;\n   public static String name = &quot;chenssy&quot;;\n\n   /**\n    *静态内部类\n    */\n   static class InnerClass1{\n       /* 在静态内部类中可以存在静态成员 */\n       public static String _name1 = &quot;chenssy_static&quot;;\n\n       public void display(){\n           /* \n            * 静态内部类只能访问外围类的静态成员变量和方法\n            * 不能访问外围类的非静态成员变量和方法\n            */\n           System.out.println(&quot;OutClass name :&quot; + name);\n       }\n   }\n\n   /**\n    * 非静态内部类\n    */\n   class InnerClass2{\n       /* 非静态内部类中不能存在静态成员 */\n       public String _name2 = &quot;chenssy_inner&quot;;\n       /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */\n       public void display(){\n           System.out.println(&quot;OuterClass name：&quot; + name);\n       }\n   }\n\n\n   public void display(){\n       /* 外围类访问静态内部类：内部类. */\n       System.out.println(InnerClass1._name1);\n       /* 静态内部类 可以直接创建实例不需要依赖于外围类 */\n       new InnerClass1().display();\n\n       /* 非静态内部的创建需要依赖于外围类 */\n       OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2();\n       /* 方位非静态内部类的成员需要使用非静态内部类的实例 */\n       System.out.println(inner2._name2);\n       inner2.display();\n   }\n\n   public static void main(String[] args) {\n       OuterClass outer = new OuterClass();\n       outer.display();\n   }\n}\n----------------\nOutput:\nchenssy_static\nOutClass name :chenssy\nchenssy_inner\nOuterClass name：chenssy\n</code></pre>\n</blockquote>\n<h3 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h3><blockquote>\n<p>匿名内部类可以简单理解就是没有名字的类。我们直接用例子演示可以说的更清楚。</p>\n<pre><code class=\"java\">button2.addActionListener(  \n               new ActionListener(){  \n                   public void actionPerformed(ActionEvent e) {  \n                       System.out.println(&quot;你按了按钮二&quot;);  \n                   }  \n               });\n</code></pre>\n<p>相信很多人都写过与上面类似的代码，这其实就是匿名类。其实就是在定义的时候就创建这个类的对象，但因为没有类名，所以以后就不能在创建使用。</p>\n<pre><code class=\"java\">public class OuterClass {\n   public InnerClass getInnerClass(final int num,String str2){\n       return new InnerClass(){\n           int number = num + 3;\n           public int getNumber(){\n               return number;\n           }\n       };  /* 注意：分号不能省 */\n   }\n\n   public static void main(String[] args) {\n       OuterClass out = new OuterClass();\n       InnerClass inner = out.getInnerClass(2, &quot;chenssy&quot;);\n       System.out.println(inner.getNumber());\n   }\n}\n\ninterface InnerClass {\n   int getNumber();\n}\n\n----------------\nOutput:\n</code></pre>\n<p> 这里我们就需要看清几个地方</p>\n<p>​        <strong>1、</strong> 匿名内部类是没有访问修饰符的。</p>\n<p>​        <strong>2、</strong> new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。</p>\n<p>​         <strong>3、</strong> 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。</p>\n<p>​        <strong>4、</strong> 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。</p>\n</blockquote>\n<h3 id=\"为什么要使用内部类\"><a href=\"#为什么要使用内部类\" class=\"headerlink\" title=\"为什么要使用内部类\"></a>为什么要使用内部类</h3><blockquote>\n<p>​        使用内部类最吸引人的原因是：<strong>每个内部类都能独立的继承自一个接口的实现，所以无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响</strong>。</p>\n<p>​         在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>\n<p>同时使用内部类还可以获得以下的一些特性：</p>\n<ol>\n<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围里对象的信息相互独立。</li>\n<li>在单个外围类中，可以多个内部类以不同的方式实现同一个接口或者继承同一个类。</li>\n<li>创建内部类对象的时刻并不依赖于外部类的创建。</li>\n<li>内部类并没有令人迷惑的”is-a”关系，他就是一个独立的实体。</li>\n</ol>\n<p>以上主要摘自《Thinking in java》</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内部类的定义与分类\"><a href=\"#内部类的定义与分类\" class=\"headerlink\" title=\"内部类的定义与分类\"></a>内部类的定义与分类</h1><blockquote>\n<p>在《Thinking in Java》这本书里面给出的定义是：可以将一个类的定义放在另一个类的定义内部就是内部类。用一段代码来说明就是下面这样的</p>\n<pre><code>class Outter{\n class InnerClass{}\n}\n</code></pre><p>其中InnerClass就是内部类。</p>\n<p>内部类大体上可以划分为以下几种：成员内部类，局部内部类，静态内部类，匿名内部类。下面我将依次讲解这几种内部类。</p>\n</blockquote>\n<h3 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h3><blockquote>\n<p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，即使是private属性成员和方法也可以访问。但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。</p>\n<p>在成员内部类中要注意的几点：</p>\n<p><strong>第一：</strong>成员内部类中不能存在任何static的变量和方法；</p>\n<p><strong>第二：</strong>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。</p>\n<p><strong>第三</strong>：成员内部类也是有包的权限的，如果是public，则在任何一个包下面都可以使用，没有权限修饰符的则  </p>\n<p>​           只能在当前包下面使用。private则只能在当前类中使用，protected则可以在子类中使用。</p>\n<p>下面我们来看一个案例</p>\n<pre><code class=\"java\">public class OuterClass {\n   private String str;\n\n   public void outerDisplay(){\n       System.out.println(&quot;outerClass...&quot;);\n   }\n\n   public class InnerClass{\n       public void innerDisplay(){\n           //使用外围内的属性\n           str = &quot;chenssy...&quot;;\n           System.out.println(str);\n           //使用外围内的方法\n           outerDisplay();\n       }\n   }\n\n   /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */\n   public InnerClass getInnerClass(){\n       return new InnerClass();\n   }\n\n   public static void main(String[] args) {\n       OuterClass outer = new OuterClass();\n       OuterClass.InnerClass inner = outer.getInnerClass();\n       inner.innerDisplay();\n   }\n}\n--------------------\nchenssy...\nouterClass...\n</code></pre>\n<h3 id=\"this-和-new的使用\"><a href=\"#this-和-new的使用\" class=\"headerlink\" title=\".this 和 .new的使用\"></a>.this 和 .new的使用</h3><p>如果你需要在内部类生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。</p>\n<h3 id=\"this使用\"><a href=\"#this使用\" class=\"headerlink\" title=\".this使用\"></a><strong>.this</strong>使用</h3><blockquote>\n<pre><code>public class OutterClass {\n\n\n   private int key = 0;\n   private int key2 = 0;\n\n\n   public static void main(String[] args) {\n       OutterClass k1 = new OutterClass();\n       InnerClass in = k1.new InnerClass(); //生成内部类\n       OutterClass k2 = in.getOutterClass(); //通过 .this 来生成外部类\n       System.out.println(k1 == k2); //true 说明俩个对象指向同一个引用\n   }\n\n   public int getKey() {\n       return this.key;\n   }\n\n   public class InnerClass {\n\n       public InnerClass() {\n           key = 12;\n           key2 = 13;\n       }\n\n       public int getKey() {\n           // 通过 .this 来使用外部类的getKey\n           return OutterClass.this.getKey();\n       }\n       // 使用 .this 返回外部类对象\n       public OutterClass getOutterClass() {\n           return OutterClass.this;\n       }\n   }\n}\n---------------\noutPut:\ntrue\n</code></pre><p>这个例子演示了<strong>.this</strong>的使用，同时也证明了<strong>.this</strong>返回的就是外部类生成的对象。</p>\n</blockquote>\n<h3 id=\"new-使用\"><a href=\"#new-使用\" class=\"headerlink\" title=\".new 使用\"></a><strong>.new </strong>使用</h3><blockquote>\n<p>如果希望创建内部类对象，则必须先拥有外部类对象前提下才能创建，这是因为内部类对象会暗暗地连接到创建它的外部类对象上。这里就先不仔细说明，等看过例子之后在来说明好理解一些。创建内部类的格式是</p>\n<pre><code>outterObject.new    outterclass.innerClass\n</code></pre><p>也就是外部类的对象后面跟上圆点和new。</p>\n<pre><code>public class OuterClass {\n   private String name ;\n   private int age;\n\n   /**省略getter和setter方法**/\n\n   public class InnerClass{\n       public InnerClass(){\n           name = &quot;chenssy&quot;;\n           age = 23;\n       }\n\n       public void display(){\n           System.out.println(&quot;name：&quot; + getName() +&quot;   ;age：&quot; + getAge());\n       }\n   }\n\n   public static void main(String[] args) {\n       OuterClass outerClass = new OuterClass();\n       OuterClass.InnerClass innerClass = outerClass.new InnerClass();\n       innerClass.display();\n   }\n}\n--------------\nOutput：\nname：chenssy   ;age：23\n</code></pre></blockquote>\n<p>通过上面的例子你大概能明白<strong>.this</strong>和<strong>.new</strong>的作用。</p>\n<p>通过上面的介绍相信你对成员内部类有一定的了解了，但肯定也会有一些以后，为什么内部类会自动拥有对其外部类所有成员的访问权。这是如何做到的呢？当某个外部类创建完一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，当你访问此外围类的成员时，就是用那个引用来选择外围类的成员。幸运的是，编译器会帮你处理所有的细节。</p>\n</blockquote>\n<h3 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h3><blockquote>\n<p>其实这个名字不是太好，但是又不知道起什么名字。这一部分讲解的类主要是在方法和作用域内的内部类。在一个方法里面或者任意的作用域内定义内部类的理由有俩个：</p>\n<ol>\n<li>实现了某类型的接口，于是可以创建并返回对其的引用。</li>\n<li>你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但又不希望这个类是公共可用的。</li>\n</ol>\n<p>下面使用来个具体的例子来讲解，因为这一部分没有什么好讲解的，主要是自己体会。</p>\n<pre><code class=\"Java\">public class Parcel5{\n private int i= 0;\n public Destination destination(String s ){\n   class PDestination implements Destination{\n     private String label;\n     private PDestination(Strng whereTo){\n       label = whereTo;\n     }\n     public String readLable(){\n       return label;\n     }\n   }\n   return new PDestination(s);\n }\n public static void main(String[] args){\n   Parcel5 p =new Parcel5();\n   Destination d = p.destination(&quot;fuyang&quot;);\n }\n}\n</code></pre>\n<p>上面的代码演示的是定义在方法中的内部类，不过在这里有一点需要注意的是，这个内部类的范围是在方法内。也就是他的作用域就在方法内部。所以方法外面的属性是访问不到的，但是可以访问方法内的变量。</p>\n<pre><code class=\"java\">public class Parcel6 {\n   private void internalTracking(boolean b){\n       if(b){\n           class TrackingSlip{\n               private String id;\n               TrackingSlip(String s) {\n                   id = s;\n               }\n               String getSlip(){\n                   return id;\n               }\n           }\n           TrackingSlip ts = new TrackingSlip(&quot;chenssy&quot;);\n           String string = ts.getSlip();\n       }\n\n         // 到这里就不能使用上面定义的TrackingSlip内部类了。\n       //下面这句话就会编译报错\n         // TrackingSlip ts = new TrackingSlip(&quot;chenssy&quot;);\n   }\n\n   public void track(){\n       internalTracking(true);\n   }\n\n   public static void main(String[] args) {\n       Parcel6 parcel6 = new Parcel6();\n       parcel6.track();\n   }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><blockquote>\n<p>使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：</p>\n<p>​      <strong>1、</strong> 它的创建是不需要依赖于外围类的。</p>\n<p>​      <strong>2、</strong> 它不能使用任何外围类的非static成员变量和方法。</p>\n<pre><code class=\"java\">public class OuterClass {\n   private String sex;\n   public static String name = &quot;chenssy&quot;;\n\n   /**\n    *静态内部类\n    */\n   static class InnerClass1{\n       /* 在静态内部类中可以存在静态成员 */\n       public static String _name1 = &quot;chenssy_static&quot;;\n\n       public void display(){\n           /* \n            * 静态内部类只能访问外围类的静态成员变量和方法\n            * 不能访问外围类的非静态成员变量和方法\n            */\n           System.out.println(&quot;OutClass name :&quot; + name);\n       }\n   }\n\n   /**\n    * 非静态内部类\n    */\n   class InnerClass2{\n       /* 非静态内部类中不能存在静态成员 */\n       public String _name2 = &quot;chenssy_inner&quot;;\n       /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */\n       public void display(){\n           System.out.println(&quot;OuterClass name：&quot; + name);\n       }\n   }\n\n\n   public void display(){\n       /* 外围类访问静态内部类：内部类. */\n       System.out.println(InnerClass1._name1);\n       /* 静态内部类 可以直接创建实例不需要依赖于外围类 */\n       new InnerClass1().display();\n\n       /* 非静态内部的创建需要依赖于外围类 */\n       OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2();\n       /* 方位非静态内部类的成员需要使用非静态内部类的实例 */\n       System.out.println(inner2._name2);\n       inner2.display();\n   }\n\n   public static void main(String[] args) {\n       OuterClass outer = new OuterClass();\n       outer.display();\n   }\n}\n----------------\nOutput:\nchenssy_static\nOutClass name :chenssy\nchenssy_inner\nOuterClass name：chenssy\n</code></pre>\n</blockquote>\n<h3 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h3><blockquote>\n<p>匿名内部类可以简单理解就是没有名字的类。我们直接用例子演示可以说的更清楚。</p>\n<pre><code class=\"java\">button2.addActionListener(  \n               new ActionListener(){  \n                   public void actionPerformed(ActionEvent e) {  \n                       System.out.println(&quot;你按了按钮二&quot;);  \n                   }  \n               });\n</code></pre>\n<p>相信很多人都写过与上面类似的代码，这其实就是匿名类。其实就是在定义的时候就创建这个类的对象，但因为没有类名，所以以后就不能在创建使用。</p>\n<pre><code class=\"java\">public class OuterClass {\n   public InnerClass getInnerClass(final int num,String str2){\n       return new InnerClass(){\n           int number = num + 3;\n           public int getNumber(){\n               return number;\n           }\n       };  /* 注意：分号不能省 */\n   }\n\n   public static void main(String[] args) {\n       OuterClass out = new OuterClass();\n       InnerClass inner = out.getInnerClass(2, &quot;chenssy&quot;);\n       System.out.println(inner.getNumber());\n   }\n}\n\ninterface InnerClass {\n   int getNumber();\n}\n\n----------------\nOutput:\n</code></pre>\n<p> 这里我们就需要看清几个地方</p>\n<p>​        <strong>1、</strong> 匿名内部类是没有访问修饰符的。</p>\n<p>​        <strong>2、</strong> new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。</p>\n<p>​         <strong>3、</strong> 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。</p>\n<p>​        <strong>4、</strong> 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。</p>\n</blockquote>\n<h3 id=\"为什么要使用内部类\"><a href=\"#为什么要使用内部类\" class=\"headerlink\" title=\"为什么要使用内部类\"></a>为什么要使用内部类</h3><blockquote>\n<p>​        使用内部类最吸引人的原因是：<strong>每个内部类都能独立的继承自一个接口的实现，所以无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响</strong>。</p>\n<p>​         在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>\n<p>同时使用内部类还可以获得以下的一些特性：</p>\n<ol>\n<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围里对象的信息相互独立。</li>\n<li>在单个外围类中，可以多个内部类以不同的方式实现同一个接口或者继承同一个类。</li>\n<li>创建内部类对象的时刻并不依赖于外部类的创建。</li>\n<li>内部类并没有令人迷惑的”is-a”关系，他就是一个独立的实体。</li>\n</ol>\n<p>以上主要摘自《Thinking in java》</p>\n</blockquote>\n"},{"title":"深入分析ThreadLocal","author":"zhangke","abbrlink":"400f00a6","date":"2018-09-12T02:28:00.000Z","_content":"###  概述\n>1. ThreadLocal是什么\n>2. 如何使用ThreadLocal\n>3. ThreadLocal源码分析\n>4. 总结\n\n### ThreadLocal 是什么\n>首先我们要明白一点，线程同步主要是为了完成线程间数据共享和同步，保持数据的完整性。而ThreadLocal正如他的名字一样是线程的本地变量，也就是线程所私有的。因此他和线程同步无关，（因为不存在线程之间共享变量的问题，就不需要使用同步机制）。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？\n<!-- more --->\n>\n>#### API是这样介绍它的：\n>\n>**This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).**\n>\n>#### 中文翻译\n>\n>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其`get` 或 `set`方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。`ThreadLocal`实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。正如这句话所说，spring 中的事务就使用了ThreadLocal来保证同一个线程中的所有操作使用的是同一个数据库连接。\n>\n>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。\n\n### 如何使用ThreadLocal\n\n>简单案例\n>\n>```JAVA\n>public class SeqCount {\n>\n>    private static ThreadLocal<Integer> seqCount = new ThreadLocal<Integer>(){\n>        // 实现initialValue()\n>        public Integer initialValue() {\n>            return 0;\n>        }\n>    };\n>\n>    public int nextSeq(){\n>        seqCount.set(seqCount.get() + 1);\n>\n>        return seqCount.get();\n>    }\n>\n>    public static void main(String[] args){\n>        SeqCount seqCount = new SeqCount();\n>\n>        SeqThread thread1 = new SeqThread(seqCount);\n>        SeqThread thread2 = new SeqThread(seqCount);\n>        SeqThread thread3 = new SeqThread(seqCount);\n>        SeqThread thread4 = new SeqThread(seqCount);\n>\n>        thread1.start();\n>        thread2.start();\n>        thread3.start();\n>        thread4.start();\n>    }\n>\n>    private static class SeqThread extends Thread{\n>        private SeqCount seqCount;\n>\n>        SeqThread(SeqCount seqCount){\n>            this.seqCount = seqCount;\n>        }\n>\n>        public void run() {\n>            for(int i = 0 ; i < 3 ; i++){\n>                System.out.println(Thread.currentThread().getName() + \" seqCount :\" + seqCount.nextSeq());\n>            }\n>        }\n>    }\n>}\n>```\n>\n>运行结果\n>\n>```\n>Thread-1 seqCount :1\n>Thread-0 seqCount :1\n>Thread-2 seqCount :1\n>Thread-3 seqCount :1\n>Thread-1 seqCount :2\n>Thread-0 seqCount :2\n>Thread-2 seqCount :2\n>Thread-3 seqCount :2\n>Thread-1 seqCount :3\n>Thread-0 seqCount :3\n>Thread-2 seqCount :3\n>Thread-3 seqCount :3\n>```\n>\n>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。\n>\n>**不过这里要注意一个问题，不要使用对象的引用来设置ThreadLocal的初始值，这样会导致线程共享此对象**\n>\n>就像下面这样写\n>\n>```java\n>    A a = new A();\n>    private static ThreadLocal<A> seqCount = new ThreadLocal<A>(){\n>        // 实现initialValue()\n>        public A initialValue() {\n>            return a;\n>        }\n>    };\n>\n>    class A{\n>        // ....\n>    }\n>```\n>\n>具体过程请参考：[对ThreadLocal实现原理的一点思考](http://www.jianshu.com/p/ee8c9dccc953)\n>\n>总结一般使用ThreadLocal的方式是：\n>\n>1. 设置ThreadLocal对象为静态内部私有属性\n>2. 使用initalValue方法进行初始化值的时候，不要使用引用对象，这样会造成线程间共享此对象，从而达不到线程私有变量的的效果。\n>\n>具体代码如下\n>\n>```java\n>private statis ThreadLocal<T> objectName = new  \n>    ThreadLocal(){\n>        private T initialValue() {\n>        \t\t//下面写法肯定有问题，主要是告诉你要声明一个对\n>        \t\t//象，而不是返回对象的引用\n>            return new T() ;\n>        }\n>}\n>```\n>\n>\n\n### ThreadLocal源码解析\n\n>ThreadLocal定义了四个方法：\n>\n>- get()：返回此线程局部变量的当前线程副本中的值。\n>- initialValue()：返回此线程局部变量的当前线程的“初始值”。\n>- remove()：移除此线程局部变量当前线程的值。\n>- set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。\n>\n>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。\n>\n>对于ThreadLocal需要注意的有两点：\n>\n>1. ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。\n>2. 是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。\n>\n>下图是Thread、ThreadLocal、ThreadLocalMap的关系\n>\n>![](http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg)\n>\n>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。\n>\n>### ThreadLocalMap\n>\n>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：\n>\n>```\n>       static class Entry extends WeakReference<ThreadLocal<?>> {\n>            /** The value associated with this ThreadLocal. */\n>            Object value;\n>\n>            Entry(ThreadLocal<?> k, Object v) {\n>                super(k);\n>                value = v;\n>            }\n>        }\n>```\n>\n>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：[Java 理论与实践: 用弱引用堵住内存泄漏](https://www.ibm.com/developerworks/cn/java/j-jtp11225/)）\n>\n>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal> key, Object value)方法。\n>\n>**set(ThreadLocal<?> key, Object value)**\n>\n>```\n>    private void set(ThreadLocal<?> key, Object value) {\n>\n>        ThreadLocal.ThreadLocalMap.Entry[] tab = table;\n>        int len = tab.length;\n>\n>        // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置\n>        int i = key.threadLocalHashCode & (len-1);\n>\n>        // 采用“线性探测法”，寻找合适位置\n>        for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];\n>            e != null;\n>            e = tab[i = nextIndex(i, len)]) {\n>\n>            ThreadLocal<?> k = e.get();\n>\n>            // key 存在，直接覆盖\n>            if (k == key) {\n>                e.value = value;\n>                return;\n>            }\n>\n>            // key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了\n>            if (k == null) {\n>                // 用新元素替换陈旧的元素\n>                replaceStaleEntry(key, value, i);\n>                return;\n>            }\n>        }\n>\n>        // ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个\n>        tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value);\n>\n>        int sz = ++size;\n>\n>        // cleanSomeSlots 清楚陈旧的Entry（key == null）\n>        // 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash\n>        if (!cleanSomeSlots(i, sz) && sz >= threshold)\n>            rehash();\n>    }\n>```\n>\n>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考[散列冲突处理系列博客](http://www.nowamagic.net/academy/detail/3008015)）。掌握了开放地址法该方法就一目了然了。\n>\n>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：\n>\n>```\n>private final int threadLocalHashCode = nextHashCode();\n>```\n>\n>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：\n>\n>```\n>    private static AtomicInteger nextHashCode = new AtomicInteger();\n>\n>    private static final int HASH_INCREMENT = 0x61c88647;\n>\n>    private static int nextHashCode() {\n>        return nextHashCode.getAndAdd(HASH_INCREMENT);\n>    }\n>```\n>\n>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。\n>\n>**getEntry()**\n>\n>```\n>        private Entry getEntry(ThreadLocal<?> key) {\n>            int i = key.threadLocalHashCode & (table.length - 1);\n>            Entry e = table[i];\n>            if (e != null && e.get() == key)\n>                return e;\n>            else\n>                return getEntryAfterMiss(key, i, e);\n>        }\n>```\n>\n>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：\n>\n>```\n>        private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n>            Entry[] tab = table;\n>            int len = tab.length;\n>\n>            while (e != null) {\n>                ThreadLocal<?> k = e.get();\n>                if (k == key)\n>                    return e;\n>                if (k == null)\n>                    expungeStaleEntry(i);\n>                else\n>                    i = nextIndex(i, len);\n>                e = tab[i];\n>            }\n>            return null;\n>        }\n>```\n>\n>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。\n>\n>### get()\n>\n>> 返回当前线程所对应的线程变量\n>\n>```\n>    public T get() {\n>        // 获取当前线程\n>        Thread t = Thread.currentThread();\n>\n>        // 获取当前线程的成员变量 threadLocal\n>        ThreadLocalMap map = getMap(t);\n>        if (map != null) {\n>            // 从当前线程的ThreadLocalMap获取相对应的Entry\n>            ThreadLocalMap.Entry e = map.getEntry(this);\n>            if (e != null) {\n>                @SuppressWarnings(\"unchecked\")\n>\n>                // 获取目标值        \n>                T result = (T)e.value;\n>                return result;\n>            }\n>        }\n>        return setInitialValue();\n>    }\n>```\n>\n>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。\n>\n>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：\n>\n>```\n>    ThreadLocalMap getMap(Thread t) {\n>        return t.threadLocals;\n>    }\n>```\n>\n>### set(T value)\n>\n>> 设置当前线程的线程局部变量的值。\n>\n>```\n>    public void set(T value) {\n>        Thread t = Thread.currentThread();\n>        ThreadLocalMap map = getMap(t);\n>        if (map != null)\n>            map.set(this, value);\n>        else\n>            createMap(t, value);\n>    }\n>```\n>\n>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：\n>\n>```\n>    void createMap(Thread t, T firstValue) {\n>        t.threadLocals = new ThreadLocalMap(this, firstValue);\n>    }\n>```\n>\n>### initialValue()\n>\n>> 返回该线程局部变量的初始值。\n>\n>``` JAVA\n>    protected T initialValue() {\n>        return null;\n>    }\n>```\n>\n>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。\n>\n>### remove()\n>\n>> 将当前线程局部变量的值删除。\n>\n>```java\n>public void remove() {\n>    ThreadLocalMap m =  getMap(Thread.currentThread());\n>    if (m != null)\n>        m.remove(this);\n>}\n>```\n>\n>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。\n>\n> \n\n### 总结\n\n>- ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。\n>- 每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。\n>- ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。\n>\n>这里有一个使用ThreadLocal的案例，可以好好看看，写的很好\n>\n>[透彻理解Spring事务设计思想之手写实现](https://www.jianshu.com/p/1becdc376f5d)\n\n### 参考\n\n1. [深入分析 ThreadLocal 内存泄漏问题](http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/)\n2.  [【死磕Java并发】—–深入分析ThreadLocal](http://cmsblogs.com/?p=2442)","source":"_posts/深入分析ThreadLocal.md","raw":"title: 深入分析ThreadLocal\nauthor: zhangke\nabbrlink: 400f00a6\ntags:\n  - java\n  - 并发\n  - 线程\n  - thread\ncategories:\n  - java\ndate: 2018-09-12 10:28:00\n---\n###  概述\n>1. ThreadLocal是什么\n>2. 如何使用ThreadLocal\n>3. ThreadLocal源码分析\n>4. 总结\n\n### ThreadLocal 是什么\n>首先我们要明白一点，线程同步主要是为了完成线程间数据共享和同步，保持数据的完整性。而ThreadLocal正如他的名字一样是线程的本地变量，也就是线程所私有的。因此他和线程同步无关，（因为不存在线程之间共享变量的问题，就不需要使用同步机制）。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？\n<!-- more --->\n>\n>#### API是这样介绍它的：\n>\n>**This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).**\n>\n>#### 中文翻译\n>\n>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其`get` 或 `set`方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。`ThreadLocal`实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。正如这句话所说，spring 中的事务就使用了ThreadLocal来保证同一个线程中的所有操作使用的是同一个数据库连接。\n>\n>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。\n\n### 如何使用ThreadLocal\n\n>简单案例\n>\n>```JAVA\n>public class SeqCount {\n>\n>    private static ThreadLocal<Integer> seqCount = new ThreadLocal<Integer>(){\n>        // 实现initialValue()\n>        public Integer initialValue() {\n>            return 0;\n>        }\n>    };\n>\n>    public int nextSeq(){\n>        seqCount.set(seqCount.get() + 1);\n>\n>        return seqCount.get();\n>    }\n>\n>    public static void main(String[] args){\n>        SeqCount seqCount = new SeqCount();\n>\n>        SeqThread thread1 = new SeqThread(seqCount);\n>        SeqThread thread2 = new SeqThread(seqCount);\n>        SeqThread thread3 = new SeqThread(seqCount);\n>        SeqThread thread4 = new SeqThread(seqCount);\n>\n>        thread1.start();\n>        thread2.start();\n>        thread3.start();\n>        thread4.start();\n>    }\n>\n>    private static class SeqThread extends Thread{\n>        private SeqCount seqCount;\n>\n>        SeqThread(SeqCount seqCount){\n>            this.seqCount = seqCount;\n>        }\n>\n>        public void run() {\n>            for(int i = 0 ; i < 3 ; i++){\n>                System.out.println(Thread.currentThread().getName() + \" seqCount :\" + seqCount.nextSeq());\n>            }\n>        }\n>    }\n>}\n>```\n>\n>运行结果\n>\n>```\n>Thread-1 seqCount :1\n>Thread-0 seqCount :1\n>Thread-2 seqCount :1\n>Thread-3 seqCount :1\n>Thread-1 seqCount :2\n>Thread-0 seqCount :2\n>Thread-2 seqCount :2\n>Thread-3 seqCount :2\n>Thread-1 seqCount :3\n>Thread-0 seqCount :3\n>Thread-2 seqCount :3\n>Thread-3 seqCount :3\n>```\n>\n>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。\n>\n>**不过这里要注意一个问题，不要使用对象的引用来设置ThreadLocal的初始值，这样会导致线程共享此对象**\n>\n>就像下面这样写\n>\n>```java\n>    A a = new A();\n>    private static ThreadLocal<A> seqCount = new ThreadLocal<A>(){\n>        // 实现initialValue()\n>        public A initialValue() {\n>            return a;\n>        }\n>    };\n>\n>    class A{\n>        // ....\n>    }\n>```\n>\n>具体过程请参考：[对ThreadLocal实现原理的一点思考](http://www.jianshu.com/p/ee8c9dccc953)\n>\n>总结一般使用ThreadLocal的方式是：\n>\n>1. 设置ThreadLocal对象为静态内部私有属性\n>2. 使用initalValue方法进行初始化值的时候，不要使用引用对象，这样会造成线程间共享此对象，从而达不到线程私有变量的的效果。\n>\n>具体代码如下\n>\n>```java\n>private statis ThreadLocal<T> objectName = new  \n>    ThreadLocal(){\n>        private T initialValue() {\n>        \t\t//下面写法肯定有问题，主要是告诉你要声明一个对\n>        \t\t//象，而不是返回对象的引用\n>            return new T() ;\n>        }\n>}\n>```\n>\n>\n\n### ThreadLocal源码解析\n\n>ThreadLocal定义了四个方法：\n>\n>- get()：返回此线程局部变量的当前线程副本中的值。\n>- initialValue()：返回此线程局部变量的当前线程的“初始值”。\n>- remove()：移除此线程局部变量当前线程的值。\n>- set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。\n>\n>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。\n>\n>对于ThreadLocal需要注意的有两点：\n>\n>1. ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。\n>2. 是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。\n>\n>下图是Thread、ThreadLocal、ThreadLocalMap的关系\n>\n>![](http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg)\n>\n>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。\n>\n>### ThreadLocalMap\n>\n>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：\n>\n>```\n>       static class Entry extends WeakReference<ThreadLocal<?>> {\n>            /** The value associated with this ThreadLocal. */\n>            Object value;\n>\n>            Entry(ThreadLocal<?> k, Object v) {\n>                super(k);\n>                value = v;\n>            }\n>        }\n>```\n>\n>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：[Java 理论与实践: 用弱引用堵住内存泄漏](https://www.ibm.com/developerworks/cn/java/j-jtp11225/)）\n>\n>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal> key, Object value)方法。\n>\n>**set(ThreadLocal<?> key, Object value)**\n>\n>```\n>    private void set(ThreadLocal<?> key, Object value) {\n>\n>        ThreadLocal.ThreadLocalMap.Entry[] tab = table;\n>        int len = tab.length;\n>\n>        // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置\n>        int i = key.threadLocalHashCode & (len-1);\n>\n>        // 采用“线性探测法”，寻找合适位置\n>        for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];\n>            e != null;\n>            e = tab[i = nextIndex(i, len)]) {\n>\n>            ThreadLocal<?> k = e.get();\n>\n>            // key 存在，直接覆盖\n>            if (k == key) {\n>                e.value = value;\n>                return;\n>            }\n>\n>            // key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了\n>            if (k == null) {\n>                // 用新元素替换陈旧的元素\n>                replaceStaleEntry(key, value, i);\n>                return;\n>            }\n>        }\n>\n>        // ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个\n>        tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value);\n>\n>        int sz = ++size;\n>\n>        // cleanSomeSlots 清楚陈旧的Entry（key == null）\n>        // 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash\n>        if (!cleanSomeSlots(i, sz) && sz >= threshold)\n>            rehash();\n>    }\n>```\n>\n>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考[散列冲突处理系列博客](http://www.nowamagic.net/academy/detail/3008015)）。掌握了开放地址法该方法就一目了然了。\n>\n>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：\n>\n>```\n>private final int threadLocalHashCode = nextHashCode();\n>```\n>\n>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：\n>\n>```\n>    private static AtomicInteger nextHashCode = new AtomicInteger();\n>\n>    private static final int HASH_INCREMENT = 0x61c88647;\n>\n>    private static int nextHashCode() {\n>        return nextHashCode.getAndAdd(HASH_INCREMENT);\n>    }\n>```\n>\n>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。\n>\n>**getEntry()**\n>\n>```\n>        private Entry getEntry(ThreadLocal<?> key) {\n>            int i = key.threadLocalHashCode & (table.length - 1);\n>            Entry e = table[i];\n>            if (e != null && e.get() == key)\n>                return e;\n>            else\n>                return getEntryAfterMiss(key, i, e);\n>        }\n>```\n>\n>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：\n>\n>```\n>        private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n>            Entry[] tab = table;\n>            int len = tab.length;\n>\n>            while (e != null) {\n>                ThreadLocal<?> k = e.get();\n>                if (k == key)\n>                    return e;\n>                if (k == null)\n>                    expungeStaleEntry(i);\n>                else\n>                    i = nextIndex(i, len);\n>                e = tab[i];\n>            }\n>            return null;\n>        }\n>```\n>\n>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。\n>\n>### get()\n>\n>> 返回当前线程所对应的线程变量\n>\n>```\n>    public T get() {\n>        // 获取当前线程\n>        Thread t = Thread.currentThread();\n>\n>        // 获取当前线程的成员变量 threadLocal\n>        ThreadLocalMap map = getMap(t);\n>        if (map != null) {\n>            // 从当前线程的ThreadLocalMap获取相对应的Entry\n>            ThreadLocalMap.Entry e = map.getEntry(this);\n>            if (e != null) {\n>                @SuppressWarnings(\"unchecked\")\n>\n>                // 获取目标值        \n>                T result = (T)e.value;\n>                return result;\n>            }\n>        }\n>        return setInitialValue();\n>    }\n>```\n>\n>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。\n>\n>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：\n>\n>```\n>    ThreadLocalMap getMap(Thread t) {\n>        return t.threadLocals;\n>    }\n>```\n>\n>### set(T value)\n>\n>> 设置当前线程的线程局部变量的值。\n>\n>```\n>    public void set(T value) {\n>        Thread t = Thread.currentThread();\n>        ThreadLocalMap map = getMap(t);\n>        if (map != null)\n>            map.set(this, value);\n>        else\n>            createMap(t, value);\n>    }\n>```\n>\n>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：\n>\n>```\n>    void createMap(Thread t, T firstValue) {\n>        t.threadLocals = new ThreadLocalMap(this, firstValue);\n>    }\n>```\n>\n>### initialValue()\n>\n>> 返回该线程局部变量的初始值。\n>\n>``` JAVA\n>    protected T initialValue() {\n>        return null;\n>    }\n>```\n>\n>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。\n>\n>### remove()\n>\n>> 将当前线程局部变量的值删除。\n>\n>```java\n>public void remove() {\n>    ThreadLocalMap m =  getMap(Thread.currentThread());\n>    if (m != null)\n>        m.remove(this);\n>}\n>```\n>\n>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。\n>\n> \n\n### 总结\n\n>- ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。\n>- 每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。\n>- ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。\n>\n>这里有一个使用ThreadLocal的案例，可以好好看看，写的很好\n>\n>[透彻理解Spring事务设计思想之手写实现](https://www.jianshu.com/p/1becdc376f5d)\n\n### 参考\n\n1. [深入分析 ThreadLocal 内存泄漏问题](http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/)\n2.  [【死磕Java并发】—–深入分析ThreadLocal](http://cmsblogs.com/?p=2442)","slug":"深入分析ThreadLocal","published":1,"updated":"2019-01-02T05:37:58.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx34001teb1uuol6hjty","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<ol>\n<li>ThreadLocal是什么</li>\n<li>如何使用ThreadLocal</li>\n<li>ThreadLocal源码分析</li>\n<li>总结</li>\n</ol>\n</blockquote>\n<h3 id=\"ThreadLocal-是什么\"><a href=\"#ThreadLocal-是什么\" class=\"headerlink\" title=\"ThreadLocal 是什么\"></a>ThreadLocal 是什么</h3><blockquote>\n<p>首先我们要明白一点，线程同步主要是为了完成线程间数据共享和同步，保持数据的完整性。而ThreadLocal正如他的名字一样是线程的本地变量，也就是线程所私有的。因此他和线程同步无关，（因为不存在线程之间共享变量的问题，就不需要使用同步机制）。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？<br><a id=\"more\"></a></p>\n<h4 id=\"API是这样介绍它的：\"><a href=\"#API是这样介绍它的：\" class=\"headerlink\" title=\"API是这样介绍它的：\"></a>API是这样介绍它的：</h4><p><strong>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).</strong></p>\n<h4 id=\"中文翻译\"><a href=\"#中文翻译\" class=\"headerlink\" title=\"中文翻译\"></a>中文翻译</h4><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其<code>get</code> 或 <code>set</code>方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。<code>ThreadLocal</code>实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。正如这句话所说，spring 中的事务就使用了ThreadLocal来保证同一个线程中的所有操作使用的是同一个数据库连接。</p>\n<p>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。</p>\n</blockquote>\n<h3 id=\"如何使用ThreadLocal\"><a href=\"#如何使用ThreadLocal\" class=\"headerlink\" title=\"如何使用ThreadLocal\"></a>如何使用ThreadLocal</h3><blockquote>\n<p>简单案例</p>\n<pre><code class=\"JAVA\">public class SeqCount {\n\n   private static ThreadLocal&lt;Integer&gt; seqCount = new ThreadLocal&lt;Integer&gt;(){\n       // 实现initialValue()\n       public Integer initialValue() {\n           return 0;\n       }\n   };\n\n   public int nextSeq(){\n       seqCount.set(seqCount.get() + 1);\n\n       return seqCount.get();\n   }\n\n   public static void main(String[] args){\n       SeqCount seqCount = new SeqCount();\n\n       SeqThread thread1 = new SeqThread(seqCount);\n       SeqThread thread2 = new SeqThread(seqCount);\n       SeqThread thread3 = new SeqThread(seqCount);\n       SeqThread thread4 = new SeqThread(seqCount);\n\n       thread1.start();\n       thread2.start();\n       thread3.start();\n       thread4.start();\n   }\n\n   private static class SeqThread extends Thread{\n       private SeqCount seqCount;\n\n       SeqThread(SeqCount seqCount){\n           this.seqCount = seqCount;\n       }\n\n       public void run() {\n           for(int i = 0 ; i &lt; 3 ; i++){\n               System.out.println(Thread.currentThread().getName() + &quot; seqCount :&quot; + seqCount.nextSeq());\n           }\n       }\n   }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>Thread-1 seqCount :1\nThread-0 seqCount :1\nThread-2 seqCount :1\nThread-3 seqCount :1\nThread-1 seqCount :2\nThread-0 seqCount :2\nThread-2 seqCount :2\nThread-3 seqCount :2\nThread-1 seqCount :3\nThread-0 seqCount :3\nThread-2 seqCount :3\nThread-3 seqCount :3\n</code></pre><p>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。</p>\n<p><strong>不过这里要注意一个问题，不要使用对象的引用来设置ThreadLocal的初始值，这样会导致线程共享此对象</strong></p>\n<p>就像下面这样写</p>\n<pre><code class=\"java\">   A a = new A();\n   private static ThreadLocal&lt;A&gt; seqCount = new ThreadLocal&lt;A&gt;(){\n       // 实现initialValue()\n       public A initialValue() {\n           return a;\n       }\n   };\n\n   class A{\n       // ....\n   }\n</code></pre>\n<p>具体过程请参考：<a href=\"http://www.jianshu.com/p/ee8c9dccc953\" target=\"_blank\" rel=\"noopener\">对ThreadLocal实现原理的一点思考</a></p>\n<p>总结一般使用ThreadLocal的方式是：</p>\n<ol>\n<li>设置ThreadLocal对象为静态内部私有属性</li>\n<li>使用initalValue方法进行初始化值的时候，不要使用引用对象，这样会造成线程间共享此对象，从而达不到线程私有变量的的效果。</li>\n</ol>\n<p>具体代码如下</p>\n<pre><code class=\"java\">private statis ThreadLocal&lt;T&gt; objectName = new  \n   ThreadLocal(){\n       private T initialValue() {\n               //下面写法肯定有问题，主要是告诉你要声明一个对\n               //象，而不是返回对象的引用\n           return new T() ;\n       }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"ThreadLocal源码解析\"><a href=\"#ThreadLocal源码解析\" class=\"headerlink\" title=\"ThreadLocal源码解析\"></a>ThreadLocal源码解析</h3><blockquote>\n<p>ThreadLocal定义了四个方法：</p>\n<ul>\n<li>get()：返回此线程局部变量的当前线程副本中的值。</li>\n<li>initialValue()：返回此线程局部变量的当前线程的“初始值”。</li>\n<li>remove()：移除此线程局部变量当前线程的值。</li>\n<li>set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。</li>\n</ul>\n<p>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</p>\n<p>对于ThreadLocal需要注意的有两点：</p>\n<ol>\n<li>ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。</li>\n<li>是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。</li>\n</ol>\n<p>下图是Thread、ThreadLocal、ThreadLocalMap的关系</p>\n<p><img src=\"http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg\" alt=\"\"></p>\n<p>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。</p>\n<h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><p>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：</p>\n<pre><code>      static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n           /** The value associated with this ThreadLocal. */\n           Object value;\n\n           Entry(ThreadLocal&lt;?&gt; k, Object v) {\n               super(k);\n               value = v;\n           }\n       }\n</code></pre><p>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp11225/\" target=\"_blank\" rel=\"noopener\">Java 理论与实践: 用弱引用堵住内存泄漏</a>）</p>\n<p>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal&gt; key, Object value)方法。</p>\n<p><strong>set(ThreadLocal&lt;?&gt; key, Object value)</strong></p>\n<pre><code>   private void set(ThreadLocal&lt;?&gt; key, Object value) {\n\n       ThreadLocal.ThreadLocalMap.Entry[] tab = table;\n       int len = tab.length;\n\n       // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置\n       int i = key.threadLocalHashCode &amp; (len-1);\n\n       // 采用“线性探测法”，寻找合适位置\n       for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];\n           e != null;\n           e = tab[i = nextIndex(i, len)]) {\n\n           ThreadLocal&lt;?&gt; k = e.get();\n\n           // key 存在，直接覆盖\n           if (k == key) {\n               e.value = value;\n               return;\n           }\n\n           // key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了\n           if (k == null) {\n               // 用新元素替换陈旧的元素\n               replaceStaleEntry(key, value, i);\n               return;\n           }\n       }\n\n       // ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个\n       tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value);\n\n       int sz = ++size;\n\n       // cleanSomeSlots 清楚陈旧的Entry（key == null）\n       // 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash\n       if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)\n           rehash();\n   }\n</code></pre><p>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考<a href=\"http://www.nowamagic.net/academy/detail/3008015\" target=\"_blank\" rel=\"noopener\">散列冲突处理系列博客</a>）。掌握了开放地址法该方法就一目了然了。</p>\n<p>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：</p>\n<pre><code>private final int threadLocalHashCode = nextHashCode();\n</code></pre><p>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：</p>\n<pre><code>   private static AtomicInteger nextHashCode = new AtomicInteger();\n\n   private static final int HASH_INCREMENT = 0x61c88647;\n\n   private static int nextHashCode() {\n       return nextHashCode.getAndAdd(HASH_INCREMENT);\n   }\n</code></pre><p>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。</p>\n<p><strong>getEntry()</strong></p>\n<pre><code>       private Entry getEntry(ThreadLocal&lt;?&gt; key) {\n           int i = key.threadLocalHashCode &amp; (table.length - 1);\n           Entry e = table[i];\n           if (e != null &amp;&amp; e.get() == key)\n               return e;\n           else\n               return getEntryAfterMiss(key, i, e);\n       }\n</code></pre><p>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：</p>\n<pre><code>       private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {\n           Entry[] tab = table;\n           int len = tab.length;\n\n           while (e != null) {\n               ThreadLocal&lt;?&gt; k = e.get();\n               if (k == key)\n                   return e;\n               if (k == null)\n                   expungeStaleEntry(i);\n               else\n                   i = nextIndex(i, len);\n               e = tab[i];\n           }\n           return null;\n       }\n</code></pre><p>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><blockquote>\n<p>返回当前线程所对应的线程变量</p>\n</blockquote>\n<pre><code>   public T get() {\n       // 获取当前线程\n       Thread t = Thread.currentThread();\n\n       // 获取当前线程的成员变量 threadLocal\n       ThreadLocalMap map = getMap(t);\n       if (map != null) {\n           // 从当前线程的ThreadLocalMap获取相对应的Entry\n           ThreadLocalMap.Entry e = map.getEntry(this);\n           if (e != null) {\n               @SuppressWarnings(&quot;unchecked&quot;)\n\n               // 获取目标值        \n               T result = (T)e.value;\n               return result;\n           }\n       }\n       return setInitialValue();\n   }\n</code></pre><p>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。</p>\n<p>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：</p>\n<pre><code>   ThreadLocalMap getMap(Thread t) {\n       return t.threadLocals;\n   }\n</code></pre><h3 id=\"set-T-value\"><a href=\"#set-T-value\" class=\"headerlink\" title=\"set(T value)\"></a>set(T value)</h3><blockquote>\n<p>设置当前线程的线程局部变量的值。</p>\n</blockquote>\n<pre><code>   public void set(T value) {\n       Thread t = Thread.currentThread();\n       ThreadLocalMap map = getMap(t);\n       if (map != null)\n           map.set(this, value);\n       else\n           createMap(t, value);\n   }\n</code></pre><p>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：</p>\n<pre><code>   void createMap(Thread t, T firstValue) {\n       t.threadLocals = new ThreadLocalMap(this, firstValue);\n   }\n</code></pre><h3 id=\"initialValue\"><a href=\"#initialValue\" class=\"headerlink\" title=\"initialValue()\"></a>initialValue()</h3><blockquote>\n<p>返回该线程局部变量的初始值。</p>\n</blockquote>\n<pre><code class=\"JAVA\">   protected T initialValue() {\n       return null;\n   }\n</code></pre>\n<p>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><blockquote>\n<p>将当前线程局部变量的值删除。</p>\n</blockquote>\n<pre><code class=\"java\">public void remove() {\n   ThreadLocalMap m =  getMap(Thread.currentThread());\n   if (m != null)\n       m.remove(this);\n}\n</code></pre>\n<p>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<ul>\n<li>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。</li>\n<li>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</li>\n<li>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li>\n</ul>\n<p>这里有一个使用ThreadLocal的案例，可以好好看看，写的很好</p>\n<p><a href=\"https://www.jianshu.com/p/1becdc376f5d\" target=\"_blank\" rel=\"noopener\">透彻理解Spring事务设计思想之手写实现</a></p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/\" target=\"_blank\" rel=\"noopener\">深入分析 ThreadLocal 内存泄漏问题</a></li>\n<li><a href=\"http://cmsblogs.com/?p=2442\" target=\"_blank\" rel=\"noopener\">【死磕Java并发】—–深入分析ThreadLocal</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<ol>\n<li>ThreadLocal是什么</li>\n<li>如何使用ThreadLocal</li>\n<li>ThreadLocal源码分析</li>\n<li>总结</li>\n</ol>\n</blockquote>\n<h3 id=\"ThreadLocal-是什么\"><a href=\"#ThreadLocal-是什么\" class=\"headerlink\" title=\"ThreadLocal 是什么\"></a>ThreadLocal 是什么</h3><blockquote>\n<p>首先我们要明白一点，线程同步主要是为了完成线程间数据共享和同步，保持数据的完整性。而ThreadLocal正如他的名字一样是线程的本地变量，也就是线程所私有的。因此他和线程同步无关，（因为不存在线程之间共享变量的问题，就不需要使用同步机制）。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？<br>","more":"</p>\n<h4 id=\"API是这样介绍它的：\"><a href=\"#API是这样介绍它的：\" class=\"headerlink\" title=\"API是这样介绍它的：\"></a>API是这样介绍它的：</h4><p><strong>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).</strong></p>\n<h4 id=\"中文翻译\"><a href=\"#中文翻译\" class=\"headerlink\" title=\"中文翻译\"></a>中文翻译</h4><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其<code>get</code> 或 <code>set</code>方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。<code>ThreadLocal</code>实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。正如这句话所说，spring 中的事务就使用了ThreadLocal来保证同一个线程中的所有操作使用的是同一个数据库连接。</p>\n<p>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。</p>\n</blockquote>\n<h3 id=\"如何使用ThreadLocal\"><a href=\"#如何使用ThreadLocal\" class=\"headerlink\" title=\"如何使用ThreadLocal\"></a>如何使用ThreadLocal</h3><blockquote>\n<p>简单案例</p>\n<pre><code class=\"JAVA\">public class SeqCount {\n\n   private static ThreadLocal&lt;Integer&gt; seqCount = new ThreadLocal&lt;Integer&gt;(){\n       // 实现initialValue()\n       public Integer initialValue() {\n           return 0;\n       }\n   };\n\n   public int nextSeq(){\n       seqCount.set(seqCount.get() + 1);\n\n       return seqCount.get();\n   }\n\n   public static void main(String[] args){\n       SeqCount seqCount = new SeqCount();\n\n       SeqThread thread1 = new SeqThread(seqCount);\n       SeqThread thread2 = new SeqThread(seqCount);\n       SeqThread thread3 = new SeqThread(seqCount);\n       SeqThread thread4 = new SeqThread(seqCount);\n\n       thread1.start();\n       thread2.start();\n       thread3.start();\n       thread4.start();\n   }\n\n   private static class SeqThread extends Thread{\n       private SeqCount seqCount;\n\n       SeqThread(SeqCount seqCount){\n           this.seqCount = seqCount;\n       }\n\n       public void run() {\n           for(int i = 0 ; i &lt; 3 ; i++){\n               System.out.println(Thread.currentThread().getName() + &quot; seqCount :&quot; + seqCount.nextSeq());\n           }\n       }\n   }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>Thread-1 seqCount :1\nThread-0 seqCount :1\nThread-2 seqCount :1\nThread-3 seqCount :1\nThread-1 seqCount :2\nThread-0 seqCount :2\nThread-2 seqCount :2\nThread-3 seqCount :2\nThread-1 seqCount :3\nThread-0 seqCount :3\nThread-2 seqCount :3\nThread-3 seqCount :3\n</code></pre><p>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。</p>\n<p><strong>不过这里要注意一个问题，不要使用对象的引用来设置ThreadLocal的初始值，这样会导致线程共享此对象</strong></p>\n<p>就像下面这样写</p>\n<pre><code class=\"java\">   A a = new A();\n   private static ThreadLocal&lt;A&gt; seqCount = new ThreadLocal&lt;A&gt;(){\n       // 实现initialValue()\n       public A initialValue() {\n           return a;\n       }\n   };\n\n   class A{\n       // ....\n   }\n</code></pre>\n<p>具体过程请参考：<a href=\"http://www.jianshu.com/p/ee8c9dccc953\" target=\"_blank\" rel=\"noopener\">对ThreadLocal实现原理的一点思考</a></p>\n<p>总结一般使用ThreadLocal的方式是：</p>\n<ol>\n<li>设置ThreadLocal对象为静态内部私有属性</li>\n<li>使用initalValue方法进行初始化值的时候，不要使用引用对象，这样会造成线程间共享此对象，从而达不到线程私有变量的的效果。</li>\n</ol>\n<p>具体代码如下</p>\n<pre><code class=\"java\">private statis ThreadLocal&lt;T&gt; objectName = new  \n   ThreadLocal(){\n       private T initialValue() {\n               //下面写法肯定有问题，主要是告诉你要声明一个对\n               //象，而不是返回对象的引用\n           return new T() ;\n       }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"ThreadLocal源码解析\"><a href=\"#ThreadLocal源码解析\" class=\"headerlink\" title=\"ThreadLocal源码解析\"></a>ThreadLocal源码解析</h3><blockquote>\n<p>ThreadLocal定义了四个方法：</p>\n<ul>\n<li>get()：返回此线程局部变量的当前线程副本中的值。</li>\n<li>initialValue()：返回此线程局部变量的当前线程的“初始值”。</li>\n<li>remove()：移除此线程局部变量当前线程的值。</li>\n<li>set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。</li>\n</ul>\n<p>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</p>\n<p>对于ThreadLocal需要注意的有两点：</p>\n<ol>\n<li>ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。</li>\n<li>是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。</li>\n</ol>\n<p>下图是Thread、ThreadLocal、ThreadLocalMap的关系</p>\n<p><img src=\"http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg\" alt=\"\"></p>\n<p>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。</p>\n<h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><p>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：</p>\n<pre><code>      static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n           /** The value associated with this ThreadLocal. */\n           Object value;\n\n           Entry(ThreadLocal&lt;?&gt; k, Object v) {\n               super(k);\n               value = v;\n           }\n       }\n</code></pre><p>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp11225/\" target=\"_blank\" rel=\"noopener\">Java 理论与实践: 用弱引用堵住内存泄漏</a>）</p>\n<p>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal&gt; key, Object value)方法。</p>\n<p><strong>set(ThreadLocal&lt;?&gt; key, Object value)</strong></p>\n<pre><code>   private void set(ThreadLocal&lt;?&gt; key, Object value) {\n\n       ThreadLocal.ThreadLocalMap.Entry[] tab = table;\n       int len = tab.length;\n\n       // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置\n       int i = key.threadLocalHashCode &amp; (len-1);\n\n       // 采用“线性探测法”，寻找合适位置\n       for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];\n           e != null;\n           e = tab[i = nextIndex(i, len)]) {\n\n           ThreadLocal&lt;?&gt; k = e.get();\n\n           // key 存在，直接覆盖\n           if (k == key) {\n               e.value = value;\n               return;\n           }\n\n           // key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了\n           if (k == null) {\n               // 用新元素替换陈旧的元素\n               replaceStaleEntry(key, value, i);\n               return;\n           }\n       }\n\n       // ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个\n       tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value);\n\n       int sz = ++size;\n\n       // cleanSomeSlots 清楚陈旧的Entry（key == null）\n       // 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash\n       if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)\n           rehash();\n   }\n</code></pre><p>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考<a href=\"http://www.nowamagic.net/academy/detail/3008015\" target=\"_blank\" rel=\"noopener\">散列冲突处理系列博客</a>）。掌握了开放地址法该方法就一目了然了。</p>\n<p>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：</p>\n<pre><code>private final int threadLocalHashCode = nextHashCode();\n</code></pre><p>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：</p>\n<pre><code>   private static AtomicInteger nextHashCode = new AtomicInteger();\n\n   private static final int HASH_INCREMENT = 0x61c88647;\n\n   private static int nextHashCode() {\n       return nextHashCode.getAndAdd(HASH_INCREMENT);\n   }\n</code></pre><p>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。</p>\n<p><strong>getEntry()</strong></p>\n<pre><code>       private Entry getEntry(ThreadLocal&lt;?&gt; key) {\n           int i = key.threadLocalHashCode &amp; (table.length - 1);\n           Entry e = table[i];\n           if (e != null &amp;&amp; e.get() == key)\n               return e;\n           else\n               return getEntryAfterMiss(key, i, e);\n       }\n</code></pre><p>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：</p>\n<pre><code>       private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {\n           Entry[] tab = table;\n           int len = tab.length;\n\n           while (e != null) {\n               ThreadLocal&lt;?&gt; k = e.get();\n               if (k == key)\n                   return e;\n               if (k == null)\n                   expungeStaleEntry(i);\n               else\n                   i = nextIndex(i, len);\n               e = tab[i];\n           }\n           return null;\n       }\n</code></pre><p>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><blockquote>\n<p>返回当前线程所对应的线程变量</p>\n</blockquote>\n<pre><code>   public T get() {\n       // 获取当前线程\n       Thread t = Thread.currentThread();\n\n       // 获取当前线程的成员变量 threadLocal\n       ThreadLocalMap map = getMap(t);\n       if (map != null) {\n           // 从当前线程的ThreadLocalMap获取相对应的Entry\n           ThreadLocalMap.Entry e = map.getEntry(this);\n           if (e != null) {\n               @SuppressWarnings(&quot;unchecked&quot;)\n\n               // 获取目标值        \n               T result = (T)e.value;\n               return result;\n           }\n       }\n       return setInitialValue();\n   }\n</code></pre><p>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。</p>\n<p>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：</p>\n<pre><code>   ThreadLocalMap getMap(Thread t) {\n       return t.threadLocals;\n   }\n</code></pre><h3 id=\"set-T-value\"><a href=\"#set-T-value\" class=\"headerlink\" title=\"set(T value)\"></a>set(T value)</h3><blockquote>\n<p>设置当前线程的线程局部变量的值。</p>\n</blockquote>\n<pre><code>   public void set(T value) {\n       Thread t = Thread.currentThread();\n       ThreadLocalMap map = getMap(t);\n       if (map != null)\n           map.set(this, value);\n       else\n           createMap(t, value);\n   }\n</code></pre><p>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：</p>\n<pre><code>   void createMap(Thread t, T firstValue) {\n       t.threadLocals = new ThreadLocalMap(this, firstValue);\n   }\n</code></pre><h3 id=\"initialValue\"><a href=\"#initialValue\" class=\"headerlink\" title=\"initialValue()\"></a>initialValue()</h3><blockquote>\n<p>返回该线程局部变量的初始值。</p>\n</blockquote>\n<pre><code class=\"JAVA\">   protected T initialValue() {\n       return null;\n   }\n</code></pre>\n<p>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><blockquote>\n<p>将当前线程局部变量的值删除。</p>\n</blockquote>\n<pre><code class=\"java\">public void remove() {\n   ThreadLocalMap m =  getMap(Thread.currentThread());\n   if (m != null)\n       m.remove(this);\n}\n</code></pre>\n<p>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<ul>\n<li>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。</li>\n<li>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</li>\n<li>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li>\n</ul>\n<p>这里有一个使用ThreadLocal的案例，可以好好看看，写的很好</p>\n<p><a href=\"https://www.jianshu.com/p/1becdc376f5d\" target=\"_blank\" rel=\"noopener\">透彻理解Spring事务设计思想之手写实现</a></p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/\" target=\"_blank\" rel=\"noopener\">深入分析 ThreadLocal 内存泄漏问题</a></li>\n<li><a href=\"http://cmsblogs.com/?p=2442\" target=\"_blank\" rel=\"noopener\">【死磕Java并发】—–深入分析ThreadLocal</a></li>\n</ol>"},{"abbrlink":3,"title":"Java NIO之浅谈内存映射文件原理与DirectMemory","author":"zhangke","date":"2018-09-22T04:57:00.000Z","_content":"# Java NIO之浅谈内存映射文件原理与DirectMemory\n\n### 概述\n\n1. 传统文件IO操作原理\n2. 什么是内存映射\n3. NIO中内存映射\n4. 直接缓冲区（DirectMemory）\n\n学习了很久的NIO，但是一直对NIO中内存映射和DirectMemory有很多的不理解，恰好最近在读《深入理解操作系统》，对其中一些不理解的地点有了自己的一些感悟。此篇文章将结合操作系统谈谈自己对NIO中的内存映射和DirectMemory的理解。\n\n<!-- more -->\n\n### 1.传统文件IO操作原理\n\n在传统的文件IO操作中，我们都是调用操作系统提供的底层标准IO系统调用函数  read()、write() ，此时调用此函数的进程（在JAVA中即java进程）会从用户态切换到内核态，然后OS的内核代码负责将相应的文件数据读取到内核的IO缓冲区，然后再把数据从内核IO缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。至于为什么要多此一举搞一个内核IO缓冲区把原本只需一次拷贝数据的事情搞成需要2次数据拷贝呢？ 我想学过操作系统或者计算机系统结构的人都知道，这么做是为了减少磁盘的IO操作，为了提高性能而考虑的，因为我们的程序访问一般都带有局部性，也就是所谓的局部性原理，在这里主要是指的空间局部性，即我们访问了文件的某一段数据，那么接下去很可能还会访问接下去的一段数据，由于磁盘IO操作的速度比直接访问内存慢了好几个数量级，所以OS根据局部性原理会在一次 read()系统调用过程中预读更多的文件数据缓存在内核IO缓冲区中，当继续访问的文件数据在缓冲区中时便直接拷贝数据到进程私有空间，避免了再次的低效率磁盘IO操作。在JAVA中当我们采用IO包下的文件操作流，如：  \n\n```\n   FileInputStream in = new FileInputStream(\"D:\\\\java.txt\");\n   in.read();\n```\n\n   JAVA虚拟机内部便会调用OS底层的 read()系统调用完成操作，如上所述，在第二次调用 in.read()的时候可能就是从内核缓冲区直接返回数据了（可能还有经过 native堆做一次中转，因为这些函数都被声明为 native，即本地平台相关，所以可能在C代码中有做一次中转，如 win32中是通过 C代码从OS读取数据，然后再传给JVM内存）。既然如此，JAVA的IO包中为啥还要提供一个 BufferedInputStream 类来作为缓冲区呢。关键在于四个字，\"系统调用\"！当读取OS内核缓冲区数据的时候，便发起了一次系统调用操作（通过native的C函数调用），而系统调用的代价相对来说是比较高的，涉及到进程用户态和内核态的上下文切换等一系列操作，所以我们经常采用如下的包装：\n\n```java\n   FileInputStream in = new FileInputStream(\"D:\\\\java.txt\"); \n   BufferedInputStream buf_in = new BufferedInputStream(in);\n   buf_in.read();\n```\n\n  这样一来，我们每一次 buf_in.read() 时候，BufferedInputStream 会根据情况自动为我们预读更多的字节数据到它自己维护的一个内部字节数组缓冲区中，这样我们便可以减少系统调用次数，从而达到其缓冲区的目的。所以要明确的一点是 BufferedInputStream 的作用不是减少磁盘IO操作次数（这个OS已经帮我们做了），而是通过减少系统调用次数来提高性能的。同理 BufferedOuputStream , BufferedReader/Writer 也是一样的。在 C语言的函数库中也有类似的实现，如 fread()，这个函数就是 C语言中的缓冲IO，作用与BufferedInputStream()相同.\n\n​    这里简单的引用下JDK8 中 BufferedInputStream 的源码验证下：\n\n```java\npublic\nclass BufferedInputStream extends FilterInputStream {\n\t\n    /**\n    * 只列出了重要的部分\n    */\n\n    protected volatile byte buf[];\n\n    public synchronized int read() throws IOException {\n        if (pos >= count) {\n            fill();\n            if (pos >= count)\n                return -1;\n        }\n        return getBufIfOpen()[pos++] & 0xff;\n    }\n\n  \n\n```\n\n\n\n   我们可以看到，BufferedInputStream 内部维护着一个 字节数组 byte[] buf 来实现缓冲区的功能，我们调用的  buf_in.read() 方法在返回数据之前有做一个 if 判断，如果 buf 数组的当前索引不在有效的索引范围之内，即 if 条件成立， buf 字段维护的缓冲区已经不够了，这时候会调用 内部的 fill() 方法进行填充，而fill()会预读更多的数据到 buf 数组缓冲区中去，然后再返回当前字节数据，如果 if 条件不成立便直接从 buf缓冲区数组返回数据了。其中getBufIfOpen()返回的就是 buf字段的引用。顺便说下，源码中的 buf 字段声明为  protected volatile byte buf[];  主要是为了通过 volatile 关键字保证 buf数组在多线程并发环境中的内存可见性.\n\n### 2. 什么是内存映射\n\nLinux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。虚拟内存区域可以映射到俩种类型的对象一种：\n\n1. linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分。并且磁盘文件区被分成页大小的片，每一片包含一个虚拟页面的初始内容。此时并没有拷贝数据到内存中去，而是当进程代码第一次引用这段代码内的虚拟地址时，触发了缺页异常，这时候OS根据映射关系直接将文件的相关部分数据拷贝到进程的用户私有空间中去，当有操作第N页数据的时候重复这样的OS页面调度程序操作。**现在终于找出内存映射效率高的原因，原来内存映射文件的效率比标准IO高的重要原因就是因为少了把数据拷贝到OS内核缓冲区这一步（可能还少了native堆中转这一步）。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。**\n2. 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件时有内核穿件的，包含的去不是二进制零。CPU第一次引用这样的一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，经这个页面标记为是驻留在内存中的。注意在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制零的页。\n\n**注：如果你对虚拟内存不是很明白，推介你去看《深入理解操作系统》第九章**\n\n### 3.NIO中内存映射\n\n上面介绍了普通文件IO和内存映射，已经总结了为什么内存映射比普通的IO函数要快。现在来了解java中的内存映射，这也是NIO中的一个特性。其实java中的内存映射就是用c语言封装了一层，方便我们用java来调用，因此在了解概念的基础后，我们来看看如何使用。\n\n  java中提供了3种内存映射模式，即：只读(readonly)、读写(read_write)、专用(private) ，\n\n1. 对于只读模式来说，如果程序试图进行写操作，则会抛出ReadOnlyBufferException异常；\n2. 第二种的读写模式表明了通过内存映射文件的方式写或修改文件内容的话是会立刻反映到磁盘文件中去的，别的进程如果共享了同一个映射文件，那么也会立即看到变化！而不是像标准IO那样每个进程有各自的内核缓冲区，比如JAVA代码中，没有执行 IO输出流的 flush() 或者  close() 操作，那么对文件的修改不会更新到磁盘去，除非进程运行结束；\n3. 最后一种专用模式采用的是OS的“写时拷贝”原则，即在没有发生写操作的情况下，多个进程之间都是共享文件的同一块物理内存（进程各自的虚拟地址指向同一片物理地址），一旦某个进程进行写操作，那么将会把受影响的文件数据单独拷贝一份到进程的私有缓冲区中，不会反映到物理文件中去。\n\n   在JAVA NIO中可以很容易的创建一块内存映射区域，代码如下：\n\n```java\nFile file = new File(\"E:\\download\\office2007pro.chs.ISO\");\nFileInputStream in = new FileInputStream(file);\nFileChannel channel = in.getChannel();\n\nMappedByteBuffer buff = channel.map(FileChannel.MapMode.READ_ONLY, 0,channel.size());\n```\n\n  这里创建了一个只读模式的内存映射文件区域，接下来我就来测试下与普通NIO中的通道操作相比性能上的优势，先看如下代码：\n\n```java\npublic class MapperToBasic {\n\n    static final int BUFFER_SIZE = 1024;\n\n    String path =\"/Users/zhangke/code/java/tem/wechat.dmg\";\n\n    @Test\n    public void mapperTest() {\n        File file = new File(path);\n\n        FileInputStream in = null;\n        FileChannel channel = null;\n        try {\n            in = new FileInputStream(file);\n            channel = in.getChannel();\n            MappedByteBuffer buff = \n                channel.map(FileChannel.MapMode.READ_ONLY, \n                            0, channel.size());\n\n            byte[] b = new byte[1024];\n            int len = (int) file.length();\n\n            long begin = System.currentTimeMillis();\n\n            for (int offset = 0; offset < len; offset += \n                 1024) {\n\n                if (len - offset > BUFFER_SIZE) {\n                    buff.get(b);\n                } else {\n                    buff.get(new byte[len - offset]);\n                }\n            }\n\n            long end = System.currentTimeMillis();\n            System.out.println(\"time is:\" + (end - begin));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n\n            Optional.ofNullable(channel).ifPresent(c -> {\n                try {\n\n                    c.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void basiTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.flip();\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"time is:\" + (end - begin));\n        \n\n    }\n```\n\n上面第一个函数是测试NIO和普通IO读取文件大小为100M的文件内容的时间NIO读取完所有的内容大概花了30毫秒，普通IO大概花了160毫秒。文件越大，差距便越大。所以内存映射文件特别适合于对大文件的操作，JAVA中的限制是最大不得超过 Integer.MAX_VALUE，即2G左右，不过我们可以通过多次映射文件(channel.map)的不同部分来达到操作整个文件的目的。\n\n按照jdk文档的官方说法，内存映射文件属于JVM中的直接缓冲区，还可以通过 ByteBuffer.allocateDirect() ，即DirectMemory的方式来创建直接缓冲区。他们相比基础的 IO操作来说就是少了中间缓冲区的数据拷贝开销。同时他们属于JVM堆外内存，不受JVM堆内存大小的限制。\n\n### 4. 直接内存\n\nDirectMemory 默认的大小是等同于JVM最大堆，理论上说受限于进程的虚拟地址空间大小，比如 32位的windows上，每个进程有4G的虚拟空间除去 2G为OS内核保留外，再减去 JVM堆的最大值，剩余的才是DirectMemory大小。通过设置 JVM参数 -Xmx64M，即JVM最大堆为64M，然后执行以下程序可以证明DirectMemory不受JVM堆大小控制：\n\n```java\n public static void main(String[] args) {\t   \n   ByteBuffer.allocateDirect(1024*1024*100); // 100MB\n   }\n```\n我们设置了JVM堆 64M限制，然后在 直接内存上分配了 100MB空间，程序执行后直接报错：**Exception in thread \"main\" java.lang.OutOfMemoryError: Direct buffer memory**。接着我设置 -Xmx200M，程序正常结束。然后我修改配置： -Xmx64M  -XX:MaxDirectMemorySize=200M，程序正常结束。因此得出结论： 直接内存DirectMemory的大小默认为 -Xmx 的JVM堆的最大值，但是并不受其限制，而是由JVM参数 MaxDirectMemorySize单独控制。接下来我们来证明直接内存不是分配在JVM堆中。我们先执行以下程序，并设置 JVM参数       **-XX:+PrintGC** \n\n```\n public static void main(String[] args) {\t   \n\t for(int i=0;i<20000;i++) {\n            ByteBuffer.allocateDirect(1024*100);  //100K\n       }\n   }\n```\n\n  输出结果如下：\n\n     [GC 1371K->1328K(61312K), 0.0070033 secs]\n     [Full GC 1328K->1297K(61312K), 0.0329592 secs]\n     [GC 3029K->2481K(61312K), 0.0037401 secs]\n     [Full GC 2481K->2435K(61312K), 0.0102255 secs]\n\n   我们看到这里执行 GC的次数较少，但是触发了 两次 Full GC，原因在于直接内存不受 GC(新生代的Minor GC)影响，只有当执行老年代的 Full GC时候才会顺便回收直接内存！而直接内存是通过存储在JVM堆中的DirectByteBuffer对象来引用的，所以当众多的DirectByteBuffer对象从新生代被送入老年代后才触发了 full gc。\n\n  再看直接在JVM堆上分配内存区域的情况：\n\n ```java\n   public static void main(String[] args) {\t   \n\tfor(int i=0;i<10000;i++) {\n             ByteBuffer.allocate(1024*100);  //100K\n\t }\n   }\n ```\n\n  ByteBuffer.allocate 意味着直接在 JVM堆上分配内存，所以受 新生代的 Minor GC影响，输出如下：\n\n\n        [GC 16023K->224K(61312K), 0.0012432 secs]\n        [GC 16211K->192K(77376K), 0.0006917 secs]\n        [GC 32242K->176K(77376K), 0.0010613 secs]\n        [GC 32225K->224K(109504K), 0.0005539 secs]\n        [GC 64423K->192K(109504K), 0.0006151 secs]\n        [GC 64376K->192K(171392K), 0.0004968 secs]\n        [GC 128646K->204K(171392K), 0.0007423 secs]\n        [GC 128646K->204K(299968K), 0.0002067 secs]\n        [GC 257190K->204K(299968K), 0.0003862 secs]\n        [GC 257193K->204K(287680K), 0.0001718 secs]\n        [GC 245103K->204K(276480K), 0.0001994 secs]\n        [GC 233662K->204K(265344K), 0.0001828 secs]\n        [GC 222782K->172K(255232K), 0.0001998 secs]\n        [GC 212374K->172K(245120K), 0.0002217 secs]\n\n   可以看到，由于直接在 JVM堆上分配内存，所以触发了多次GC，且不会触及  Full GC，因为对象根本没机会进入老年代。\n\n在这里要来探讨一下内存映射和DirectMemory的内存回收问题。NIO中的DirectMemory和内存文件映射同属于直接缓冲区，但是前者和 -Xmx和-XX:MaxDirectMemorySize有关，而后者完全没有JVM参数可以影响和控制，这让我不禁怀疑两者的直接缓冲区是否相同，前者指的是 JAVA进程中的 native堆，即涉及底层平台如 win32的dll 部分，因为 C语言中的 malloc()分配的内存就属于 native堆，不属于 JVM堆，这也是DirectMemory能在一些场景中显著提高性能的原因，因为它避免了在 native堆和jvm堆之间数据的来回复制；而后者则是没有经过 native堆，是由 JAVA进程直接建立起 某一段虚拟地址空间和文件对象的关联映射关系，参见 Linux虚拟存储器图中的 “Memory mapped region for shared libraries”  区域，所以内存映射文件的区域并不在JVM GC的回收范围内，因为它本身就不属于堆区，卸载这部分区域只能通过系统调用 unmap()来实现 (Linux)中，而 JAVA API 只提供了 FileChannel.map 的形式创建内存映射区域，却没有提供对应的 unmap()。\n\n事实是由JVM帮助我们自动回收这部分内存，在定义这些类时，通过一个虚引用包裹这些创建的NIO对象，当JVM进行GC时检测指向这些内存映射或者直接内存的java对象是否被回收（java对象都是保存在堆上，只是对象中使用变量空间指向对外内存）。如果这些对象被回收，那么JVM就会自动的帮助我们回收这些堆外内存。具体参考：[堆外内存 之 DirectByteBuffer 详解](https://www.jianshu.com/p/007052ee3773)\n\n最后再试试通过 DirectMemory来操作前面 内存映射和基本通道操作的例子，来看看直接内存操作的话，程序的性能如何：\n\n```\n    @Test\n    public void directBufferTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n        \n        ByteBuffer buff = ByteBuffer.allocateDirect(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"time is:\" + (end - begin));\n        in.close();\n    }\n```\n\n\n\n程序输出为 130毫秒，看来比普通的NIO通道操作（160毫秒）来的快，但是比 mmap 内存映射的 30差距太多了，我想应该不至于吧，通过修改：\n\n```\nByteBuffer buff = ByteBuffer.allocateDirect(1024);  \n//将上面语句修改如下\nByteBuffer buff = ByteBuffer.allocateDirect((int)file.length())，\n```\n\n即一次性分配整个文件长度大小的堆外内存，最终输出为 78毫秒，由此可以得出两个结论：\n\n1. 堆外内存的分配耗时比较大.  \n\n2. 还是比mmap内存映射来得慢，都不要说通过mmap读取数据的时候还涉及缺页异常、页面调度的系统调用了。\n\n最后一点为 DirectMemory的内存只有在 JVM执行 full gc 的时候才会被回收，那么如果在其上分配过大的内存空间，那么也将出现 OutofMemoryError，即便 JVM 堆中的很多内存处于空闲状态。\n\n **补充下额外的一个知识点，关于 JVM堆大小的设置是不受限于物理内存，而是受限于虚拟内存空间大小，理论上来说是进程的虚拟地址空间大小，但是实际上我们的虚拟内存空间是有限制的，一般windows上默认在C盘，大小为物理内存的2倍左右。我做了个实验：我机子是 64位的win7，那么理论上说进程虚拟空间是几乎无限大，物理内存为4G，而我设置 -Xms5000M， 即在启动JAVA程序的时候一次性申请到超过物理内存大小的5000M内存，程序正常启动，而当我加到 -Xms8000M的时候就报OOM错误了，然后我修改增加 win7的虚拟内存，程序又正常启动了，说明 -Xms 受限于虚拟内存的大小。我设置-Xms5000M，即超过了4G物理内存，并在一个死循环中不断创建对象，并保证不会被GC回收。程序运行一会后整个电脑几乎死机状态，即卡住了，反映很慢很慢，推测是发生了系统颠簸，即频繁的页面调度置换导致，说明 -Xms -Xmx不是局限于物理内存的大小，而是综合虚拟内存了，JVM会根据电脑虚拟内存的设置来控制。**\n\n###  参考\n\n1. [JAVA NIO之浅谈内存映射文件原理与DirectMemory](https://blog.csdn.net/fcbayernmunchen/article/details/8635427)","source":"_posts/JAVA NIO之浅谈内存映射文件原理与DirectBuffer.md","raw":"abbrlink: 3\ntitle: Java NIO之浅谈内存映射文件原理与DirectMemory\ntags:\n  - NIO\n  - 内存映射\n  - 直接内存\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-09-22 12:57:00\n---\n# Java NIO之浅谈内存映射文件原理与DirectMemory\n\n### 概述\n\n1. 传统文件IO操作原理\n2. 什么是内存映射\n3. NIO中内存映射\n4. 直接缓冲区（DirectMemory）\n\n学习了很久的NIO，但是一直对NIO中内存映射和DirectMemory有很多的不理解，恰好最近在读《深入理解操作系统》，对其中一些不理解的地点有了自己的一些感悟。此篇文章将结合操作系统谈谈自己对NIO中的内存映射和DirectMemory的理解。\n\n<!-- more -->\n\n### 1.传统文件IO操作原理\n\n在传统的文件IO操作中，我们都是调用操作系统提供的底层标准IO系统调用函数  read()、write() ，此时调用此函数的进程（在JAVA中即java进程）会从用户态切换到内核态，然后OS的内核代码负责将相应的文件数据读取到内核的IO缓冲区，然后再把数据从内核IO缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。至于为什么要多此一举搞一个内核IO缓冲区把原本只需一次拷贝数据的事情搞成需要2次数据拷贝呢？ 我想学过操作系统或者计算机系统结构的人都知道，这么做是为了减少磁盘的IO操作，为了提高性能而考虑的，因为我们的程序访问一般都带有局部性，也就是所谓的局部性原理，在这里主要是指的空间局部性，即我们访问了文件的某一段数据，那么接下去很可能还会访问接下去的一段数据，由于磁盘IO操作的速度比直接访问内存慢了好几个数量级，所以OS根据局部性原理会在一次 read()系统调用过程中预读更多的文件数据缓存在内核IO缓冲区中，当继续访问的文件数据在缓冲区中时便直接拷贝数据到进程私有空间，避免了再次的低效率磁盘IO操作。在JAVA中当我们采用IO包下的文件操作流，如：  \n\n```\n   FileInputStream in = new FileInputStream(\"D:\\\\java.txt\");\n   in.read();\n```\n\n   JAVA虚拟机内部便会调用OS底层的 read()系统调用完成操作，如上所述，在第二次调用 in.read()的时候可能就是从内核缓冲区直接返回数据了（可能还有经过 native堆做一次中转，因为这些函数都被声明为 native，即本地平台相关，所以可能在C代码中有做一次中转，如 win32中是通过 C代码从OS读取数据，然后再传给JVM内存）。既然如此，JAVA的IO包中为啥还要提供一个 BufferedInputStream 类来作为缓冲区呢。关键在于四个字，\"系统调用\"！当读取OS内核缓冲区数据的时候，便发起了一次系统调用操作（通过native的C函数调用），而系统调用的代价相对来说是比较高的，涉及到进程用户态和内核态的上下文切换等一系列操作，所以我们经常采用如下的包装：\n\n```java\n   FileInputStream in = new FileInputStream(\"D:\\\\java.txt\"); \n   BufferedInputStream buf_in = new BufferedInputStream(in);\n   buf_in.read();\n```\n\n  这样一来，我们每一次 buf_in.read() 时候，BufferedInputStream 会根据情况自动为我们预读更多的字节数据到它自己维护的一个内部字节数组缓冲区中，这样我们便可以减少系统调用次数，从而达到其缓冲区的目的。所以要明确的一点是 BufferedInputStream 的作用不是减少磁盘IO操作次数（这个OS已经帮我们做了），而是通过减少系统调用次数来提高性能的。同理 BufferedOuputStream , BufferedReader/Writer 也是一样的。在 C语言的函数库中也有类似的实现，如 fread()，这个函数就是 C语言中的缓冲IO，作用与BufferedInputStream()相同.\n\n​    这里简单的引用下JDK8 中 BufferedInputStream 的源码验证下：\n\n```java\npublic\nclass BufferedInputStream extends FilterInputStream {\n\t\n    /**\n    * 只列出了重要的部分\n    */\n\n    protected volatile byte buf[];\n\n    public synchronized int read() throws IOException {\n        if (pos >= count) {\n            fill();\n            if (pos >= count)\n                return -1;\n        }\n        return getBufIfOpen()[pos++] & 0xff;\n    }\n\n  \n\n```\n\n\n\n   我们可以看到，BufferedInputStream 内部维护着一个 字节数组 byte[] buf 来实现缓冲区的功能，我们调用的  buf_in.read() 方法在返回数据之前有做一个 if 判断，如果 buf 数组的当前索引不在有效的索引范围之内，即 if 条件成立， buf 字段维护的缓冲区已经不够了，这时候会调用 内部的 fill() 方法进行填充，而fill()会预读更多的数据到 buf 数组缓冲区中去，然后再返回当前字节数据，如果 if 条件不成立便直接从 buf缓冲区数组返回数据了。其中getBufIfOpen()返回的就是 buf字段的引用。顺便说下，源码中的 buf 字段声明为  protected volatile byte buf[];  主要是为了通过 volatile 关键字保证 buf数组在多线程并发环境中的内存可见性.\n\n### 2. 什么是内存映射\n\nLinux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。虚拟内存区域可以映射到俩种类型的对象一种：\n\n1. linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分。并且磁盘文件区被分成页大小的片，每一片包含一个虚拟页面的初始内容。此时并没有拷贝数据到内存中去，而是当进程代码第一次引用这段代码内的虚拟地址时，触发了缺页异常，这时候OS根据映射关系直接将文件的相关部分数据拷贝到进程的用户私有空间中去，当有操作第N页数据的时候重复这样的OS页面调度程序操作。**现在终于找出内存映射效率高的原因，原来内存映射文件的效率比标准IO高的重要原因就是因为少了把数据拷贝到OS内核缓冲区这一步（可能还少了native堆中转这一步）。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。**\n2. 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件时有内核穿件的，包含的去不是二进制零。CPU第一次引用这样的一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，经这个页面标记为是驻留在内存中的。注意在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制零的页。\n\n**注：如果你对虚拟内存不是很明白，推介你去看《深入理解操作系统》第九章**\n\n### 3.NIO中内存映射\n\n上面介绍了普通文件IO和内存映射，已经总结了为什么内存映射比普通的IO函数要快。现在来了解java中的内存映射，这也是NIO中的一个特性。其实java中的内存映射就是用c语言封装了一层，方便我们用java来调用，因此在了解概念的基础后，我们来看看如何使用。\n\n  java中提供了3种内存映射模式，即：只读(readonly)、读写(read_write)、专用(private) ，\n\n1. 对于只读模式来说，如果程序试图进行写操作，则会抛出ReadOnlyBufferException异常；\n2. 第二种的读写模式表明了通过内存映射文件的方式写或修改文件内容的话是会立刻反映到磁盘文件中去的，别的进程如果共享了同一个映射文件，那么也会立即看到变化！而不是像标准IO那样每个进程有各自的内核缓冲区，比如JAVA代码中，没有执行 IO输出流的 flush() 或者  close() 操作，那么对文件的修改不会更新到磁盘去，除非进程运行结束；\n3. 最后一种专用模式采用的是OS的“写时拷贝”原则，即在没有发生写操作的情况下，多个进程之间都是共享文件的同一块物理内存（进程各自的虚拟地址指向同一片物理地址），一旦某个进程进行写操作，那么将会把受影响的文件数据单独拷贝一份到进程的私有缓冲区中，不会反映到物理文件中去。\n\n   在JAVA NIO中可以很容易的创建一块内存映射区域，代码如下：\n\n```java\nFile file = new File(\"E:\\download\\office2007pro.chs.ISO\");\nFileInputStream in = new FileInputStream(file);\nFileChannel channel = in.getChannel();\n\nMappedByteBuffer buff = channel.map(FileChannel.MapMode.READ_ONLY, 0,channel.size());\n```\n\n  这里创建了一个只读模式的内存映射文件区域，接下来我就来测试下与普通NIO中的通道操作相比性能上的优势，先看如下代码：\n\n```java\npublic class MapperToBasic {\n\n    static final int BUFFER_SIZE = 1024;\n\n    String path =\"/Users/zhangke/code/java/tem/wechat.dmg\";\n\n    @Test\n    public void mapperTest() {\n        File file = new File(path);\n\n        FileInputStream in = null;\n        FileChannel channel = null;\n        try {\n            in = new FileInputStream(file);\n            channel = in.getChannel();\n            MappedByteBuffer buff = \n                channel.map(FileChannel.MapMode.READ_ONLY, \n                            0, channel.size());\n\n            byte[] b = new byte[1024];\n            int len = (int) file.length();\n\n            long begin = System.currentTimeMillis();\n\n            for (int offset = 0; offset < len; offset += \n                 1024) {\n\n                if (len - offset > BUFFER_SIZE) {\n                    buff.get(b);\n                } else {\n                    buff.get(new byte[len - offset]);\n                }\n            }\n\n            long end = System.currentTimeMillis();\n            System.out.println(\"time is:\" + (end - begin));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n\n            Optional.ofNullable(channel).ifPresent(c -> {\n                try {\n\n                    c.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void basiTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.flip();\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"time is:\" + (end - begin));\n        \n\n    }\n```\n\n上面第一个函数是测试NIO和普通IO读取文件大小为100M的文件内容的时间NIO读取完所有的内容大概花了30毫秒，普通IO大概花了160毫秒。文件越大，差距便越大。所以内存映射文件特别适合于对大文件的操作，JAVA中的限制是最大不得超过 Integer.MAX_VALUE，即2G左右，不过我们可以通过多次映射文件(channel.map)的不同部分来达到操作整个文件的目的。\n\n按照jdk文档的官方说法，内存映射文件属于JVM中的直接缓冲区，还可以通过 ByteBuffer.allocateDirect() ，即DirectMemory的方式来创建直接缓冲区。他们相比基础的 IO操作来说就是少了中间缓冲区的数据拷贝开销。同时他们属于JVM堆外内存，不受JVM堆内存大小的限制。\n\n### 4. 直接内存\n\nDirectMemory 默认的大小是等同于JVM最大堆，理论上说受限于进程的虚拟地址空间大小，比如 32位的windows上，每个进程有4G的虚拟空间除去 2G为OS内核保留外，再减去 JVM堆的最大值，剩余的才是DirectMemory大小。通过设置 JVM参数 -Xmx64M，即JVM最大堆为64M，然后执行以下程序可以证明DirectMemory不受JVM堆大小控制：\n\n```java\n public static void main(String[] args) {\t   \n   ByteBuffer.allocateDirect(1024*1024*100); // 100MB\n   }\n```\n我们设置了JVM堆 64M限制，然后在 直接内存上分配了 100MB空间，程序执行后直接报错：**Exception in thread \"main\" java.lang.OutOfMemoryError: Direct buffer memory**。接着我设置 -Xmx200M，程序正常结束。然后我修改配置： -Xmx64M  -XX:MaxDirectMemorySize=200M，程序正常结束。因此得出结论： 直接内存DirectMemory的大小默认为 -Xmx 的JVM堆的最大值，但是并不受其限制，而是由JVM参数 MaxDirectMemorySize单独控制。接下来我们来证明直接内存不是分配在JVM堆中。我们先执行以下程序，并设置 JVM参数       **-XX:+PrintGC** \n\n```\n public static void main(String[] args) {\t   \n\t for(int i=0;i<20000;i++) {\n            ByteBuffer.allocateDirect(1024*100);  //100K\n       }\n   }\n```\n\n  输出结果如下：\n\n     [GC 1371K->1328K(61312K), 0.0070033 secs]\n     [Full GC 1328K->1297K(61312K), 0.0329592 secs]\n     [GC 3029K->2481K(61312K), 0.0037401 secs]\n     [Full GC 2481K->2435K(61312K), 0.0102255 secs]\n\n   我们看到这里执行 GC的次数较少，但是触发了 两次 Full GC，原因在于直接内存不受 GC(新生代的Minor GC)影响，只有当执行老年代的 Full GC时候才会顺便回收直接内存！而直接内存是通过存储在JVM堆中的DirectByteBuffer对象来引用的，所以当众多的DirectByteBuffer对象从新生代被送入老年代后才触发了 full gc。\n\n  再看直接在JVM堆上分配内存区域的情况：\n\n ```java\n   public static void main(String[] args) {\t   \n\tfor(int i=0;i<10000;i++) {\n             ByteBuffer.allocate(1024*100);  //100K\n\t }\n   }\n ```\n\n  ByteBuffer.allocate 意味着直接在 JVM堆上分配内存，所以受 新生代的 Minor GC影响，输出如下：\n\n\n        [GC 16023K->224K(61312K), 0.0012432 secs]\n        [GC 16211K->192K(77376K), 0.0006917 secs]\n        [GC 32242K->176K(77376K), 0.0010613 secs]\n        [GC 32225K->224K(109504K), 0.0005539 secs]\n        [GC 64423K->192K(109504K), 0.0006151 secs]\n        [GC 64376K->192K(171392K), 0.0004968 secs]\n        [GC 128646K->204K(171392K), 0.0007423 secs]\n        [GC 128646K->204K(299968K), 0.0002067 secs]\n        [GC 257190K->204K(299968K), 0.0003862 secs]\n        [GC 257193K->204K(287680K), 0.0001718 secs]\n        [GC 245103K->204K(276480K), 0.0001994 secs]\n        [GC 233662K->204K(265344K), 0.0001828 secs]\n        [GC 222782K->172K(255232K), 0.0001998 secs]\n        [GC 212374K->172K(245120K), 0.0002217 secs]\n\n   可以看到，由于直接在 JVM堆上分配内存，所以触发了多次GC，且不会触及  Full GC，因为对象根本没机会进入老年代。\n\n在这里要来探讨一下内存映射和DirectMemory的内存回收问题。NIO中的DirectMemory和内存文件映射同属于直接缓冲区，但是前者和 -Xmx和-XX:MaxDirectMemorySize有关，而后者完全没有JVM参数可以影响和控制，这让我不禁怀疑两者的直接缓冲区是否相同，前者指的是 JAVA进程中的 native堆，即涉及底层平台如 win32的dll 部分，因为 C语言中的 malloc()分配的内存就属于 native堆，不属于 JVM堆，这也是DirectMemory能在一些场景中显著提高性能的原因，因为它避免了在 native堆和jvm堆之间数据的来回复制；而后者则是没有经过 native堆，是由 JAVA进程直接建立起 某一段虚拟地址空间和文件对象的关联映射关系，参见 Linux虚拟存储器图中的 “Memory mapped region for shared libraries”  区域，所以内存映射文件的区域并不在JVM GC的回收范围内，因为它本身就不属于堆区，卸载这部分区域只能通过系统调用 unmap()来实现 (Linux)中，而 JAVA API 只提供了 FileChannel.map 的形式创建内存映射区域，却没有提供对应的 unmap()。\n\n事实是由JVM帮助我们自动回收这部分内存，在定义这些类时，通过一个虚引用包裹这些创建的NIO对象，当JVM进行GC时检测指向这些内存映射或者直接内存的java对象是否被回收（java对象都是保存在堆上，只是对象中使用变量空间指向对外内存）。如果这些对象被回收，那么JVM就会自动的帮助我们回收这些堆外内存。具体参考：[堆外内存 之 DirectByteBuffer 详解](https://www.jianshu.com/p/007052ee3773)\n\n最后再试试通过 DirectMemory来操作前面 内存映射和基本通道操作的例子，来看看直接内存操作的话，程序的性能如何：\n\n```\n    @Test\n    public void directBufferTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n        \n        ByteBuffer buff = ByteBuffer.allocateDirect(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"time is:\" + (end - begin));\n        in.close();\n    }\n```\n\n\n\n程序输出为 130毫秒，看来比普通的NIO通道操作（160毫秒）来的快，但是比 mmap 内存映射的 30差距太多了，我想应该不至于吧，通过修改：\n\n```\nByteBuffer buff = ByteBuffer.allocateDirect(1024);  \n//将上面语句修改如下\nByteBuffer buff = ByteBuffer.allocateDirect((int)file.length())，\n```\n\n即一次性分配整个文件长度大小的堆外内存，最终输出为 78毫秒，由此可以得出两个结论：\n\n1. 堆外内存的分配耗时比较大.  \n\n2. 还是比mmap内存映射来得慢，都不要说通过mmap读取数据的时候还涉及缺页异常、页面调度的系统调用了。\n\n最后一点为 DirectMemory的内存只有在 JVM执行 full gc 的时候才会被回收，那么如果在其上分配过大的内存空间，那么也将出现 OutofMemoryError，即便 JVM 堆中的很多内存处于空闲状态。\n\n **补充下额外的一个知识点，关于 JVM堆大小的设置是不受限于物理内存，而是受限于虚拟内存空间大小，理论上来说是进程的虚拟地址空间大小，但是实际上我们的虚拟内存空间是有限制的，一般windows上默认在C盘，大小为物理内存的2倍左右。我做了个实验：我机子是 64位的win7，那么理论上说进程虚拟空间是几乎无限大，物理内存为4G，而我设置 -Xms5000M， 即在启动JAVA程序的时候一次性申请到超过物理内存大小的5000M内存，程序正常启动，而当我加到 -Xms8000M的时候就报OOM错误了，然后我修改增加 win7的虚拟内存，程序又正常启动了，说明 -Xms 受限于虚拟内存的大小。我设置-Xms5000M，即超过了4G物理内存，并在一个死循环中不断创建对象，并保证不会被GC回收。程序运行一会后整个电脑几乎死机状态，即卡住了，反映很慢很慢，推测是发生了系统颠簸，即频繁的页面调度置换导致，说明 -Xms -Xmx不是局限于物理内存的大小，而是综合虚拟内存了，JVM会根据电脑虚拟内存的设置来控制。**\n\n###  参考\n\n1. [JAVA NIO之浅谈内存映射文件原理与DirectMemory](https://blog.csdn.net/fcbayernmunchen/article/details/8635427)","slug":"JAVA NIO之浅谈内存映射文件原理与DirectBuffer","published":1,"updated":"2019-01-04T01:48:59.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx6d002meb1uykreokja","content":"<h1 id=\"Java-NIO之浅谈内存映射文件原理与DirectMemory\"><a href=\"#Java-NIO之浅谈内存映射文件原理与DirectMemory\" class=\"headerlink\" title=\"Java NIO之浅谈内存映射文件原理与DirectMemory\"></a>Java NIO之浅谈内存映射文件原理与DirectMemory</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>传统文件IO操作原理</li>\n<li>什么是内存映射</li>\n<li>NIO中内存映射</li>\n<li>直接缓冲区（DirectMemory）</li>\n</ol>\n<p>学习了很久的NIO，但是一直对NIO中内存映射和DirectMemory有很多的不理解，恰好最近在读《深入理解操作系统》，对其中一些不理解的地点有了自己的一些感悟。此篇文章将结合操作系统谈谈自己对NIO中的内存映射和DirectMemory的理解。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-传统文件IO操作原理\"><a href=\"#1-传统文件IO操作原理\" class=\"headerlink\" title=\"1.传统文件IO操作原理\"></a>1.传统文件IO操作原理</h3><p>在传统的文件IO操作中，我们都是调用操作系统提供的底层标准IO系统调用函数  read()、write() ，此时调用此函数的进程（在JAVA中即java进程）会从用户态切换到内核态，然后OS的内核代码负责将相应的文件数据读取到内核的IO缓冲区，然后再把数据从内核IO缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。至于为什么要多此一举搞一个内核IO缓冲区把原本只需一次拷贝数据的事情搞成需要2次数据拷贝呢？ 我想学过操作系统或者计算机系统结构的人都知道，这么做是为了减少磁盘的IO操作，为了提高性能而考虑的，因为我们的程序访问一般都带有局部性，也就是所谓的局部性原理，在这里主要是指的空间局部性，即我们访问了文件的某一段数据，那么接下去很可能还会访问接下去的一段数据，由于磁盘IO操作的速度比直接访问内存慢了好几个数量级，所以OS根据局部性原理会在一次 read()系统调用过程中预读更多的文件数据缓存在内核IO缓冲区中，当继续访问的文件数据在缓冲区中时便直接拷贝数据到进程私有空间，避免了再次的低效率磁盘IO操作。在JAVA中当我们采用IO包下的文件操作流，如：  </p>\n<pre><code>   FileInputStream in = new FileInputStream(&quot;D:\\\\java.txt&quot;);\n   in.read();\n</code></pre><p>   JAVA虚拟机内部便会调用OS底层的 read()系统调用完成操作，如上所述，在第二次调用 in.read()的时候可能就是从内核缓冲区直接返回数据了（可能还有经过 native堆做一次中转，因为这些函数都被声明为 native，即本地平台相关，所以可能在C代码中有做一次中转，如 win32中是通过 C代码从OS读取数据，然后再传给JVM内存）。既然如此，JAVA的IO包中为啥还要提供一个 BufferedInputStream 类来作为缓冲区呢。关键在于四个字，”系统调用”！当读取OS内核缓冲区数据的时候，便发起了一次系统调用操作（通过native的C函数调用），而系统调用的代价相对来说是比较高的，涉及到进程用户态和内核态的上下文切换等一系列操作，所以我们经常采用如下的包装：</p>\n<pre><code class=\"java\">   FileInputStream in = new FileInputStream(&quot;D:\\\\java.txt&quot;); \n   BufferedInputStream buf_in = new BufferedInputStream(in);\n   buf_in.read();\n</code></pre>\n<p>  这样一来，我们每一次 buf_in.read() 时候，BufferedInputStream 会根据情况自动为我们预读更多的字节数据到它自己维护的一个内部字节数组缓冲区中，这样我们便可以减少系统调用次数，从而达到其缓冲区的目的。所以要明确的一点是 BufferedInputStream 的作用不是减少磁盘IO操作次数（这个OS已经帮我们做了），而是通过减少系统调用次数来提高性能的。同理 BufferedOuputStream , BufferedReader/Writer 也是一样的。在 C语言的函数库中也有类似的实现，如 fread()，这个函数就是 C语言中的缓冲IO，作用与BufferedInputStream()相同.</p>\n<p>​    这里简单的引用下JDK8 中 BufferedInputStream 的源码验证下：</p>\n<pre><code class=\"java\">public\nclass BufferedInputStream extends FilterInputStream {\n\n    /**\n    * 只列出了重要的部分\n    */\n\n    protected volatile byte buf[];\n\n    public synchronized int read() throws IOException {\n        if (pos &gt;= count) {\n            fill();\n            if (pos &gt;= count)\n                return -1;\n        }\n        return getBufIfOpen()[pos++] &amp; 0xff;\n    }\n\n\n\n</code></pre>\n<p>   我们可以看到，BufferedInputStream 内部维护着一个 字节数组 byte[] buf 来实现缓冲区的功能，我们调用的  buf_in.read() 方法在返回数据之前有做一个 if 判断，如果 buf 数组的当前索引不在有效的索引范围之内，即 if 条件成立， buf 字段维护的缓冲区已经不够了，这时候会调用 内部的 fill() 方法进行填充，而fill()会预读更多的数据到 buf 数组缓冲区中去，然后再返回当前字节数据，如果 if 条件不成立便直接从 buf缓冲区数组返回数据了。其中getBufIfOpen()返回的就是 buf字段的引用。顺便说下，源码中的 buf 字段声明为  protected volatile byte buf[];  主要是为了通过 volatile 关键字保证 buf数组在多线程并发环境中的内存可见性.</p>\n<h3 id=\"2-什么是内存映射\"><a href=\"#2-什么是内存映射\" class=\"headerlink\" title=\"2. 什么是内存映射\"></a>2. 什么是内存映射</h3><p>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。虚拟内存区域可以映射到俩种类型的对象一种：</p>\n<ol>\n<li>linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分。并且磁盘文件区被分成页大小的片，每一片包含一个虚拟页面的初始内容。此时并没有拷贝数据到内存中去，而是当进程代码第一次引用这段代码内的虚拟地址时，触发了缺页异常，这时候OS根据映射关系直接将文件的相关部分数据拷贝到进程的用户私有空间中去，当有操作第N页数据的时候重复这样的OS页面调度程序操作。<strong>现在终于找出内存映射效率高的原因，原来内存映射文件的效率比标准IO高的重要原因就是因为少了把数据拷贝到OS内核缓冲区这一步（可能还少了native堆中转这一步）。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。</strong></li>\n<li>匿名文件：一个区域也可以映射到一个匿名文件，匿名文件时有内核穿件的，包含的去不是二进制零。CPU第一次引用这样的一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，经这个页面标记为是驻留在内存中的。注意在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制零的页。</li>\n</ol>\n<p><strong>注：如果你对虚拟内存不是很明白，推介你去看《深入理解操作系统》第九章</strong></p>\n<h3 id=\"3-NIO中内存映射\"><a href=\"#3-NIO中内存映射\" class=\"headerlink\" title=\"3.NIO中内存映射\"></a>3.NIO中内存映射</h3><p>上面介绍了普通文件IO和内存映射，已经总结了为什么内存映射比普通的IO函数要快。现在来了解java中的内存映射，这也是NIO中的一个特性。其实java中的内存映射就是用c语言封装了一层，方便我们用java来调用，因此在了解概念的基础后，我们来看看如何使用。</p>\n<p>  java中提供了3种内存映射模式，即：只读(readonly)、读写(read_write)、专用(private) ，</p>\n<ol>\n<li>对于只读模式来说，如果程序试图进行写操作，则会抛出ReadOnlyBufferException异常；</li>\n<li>第二种的读写模式表明了通过内存映射文件的方式写或修改文件内容的话是会立刻反映到磁盘文件中去的，别的进程如果共享了同一个映射文件，那么也会立即看到变化！而不是像标准IO那样每个进程有各自的内核缓冲区，比如JAVA代码中，没有执行 IO输出流的 flush() 或者  close() 操作，那么对文件的修改不会更新到磁盘去，除非进程运行结束；</li>\n<li><p>最后一种专用模式采用的是OS的“写时拷贝”原则，即在没有发生写操作的情况下，多个进程之间都是共享文件的同一块物理内存（进程各自的虚拟地址指向同一片物理地址），一旦某个进程进行写操作，那么将会把受影响的文件数据单独拷贝一份到进程的私有缓冲区中，不会反映到物理文件中去。</p>\n<p>在JAVA NIO中可以很容易的创建一块内存映射区域，代码如下：</p>\n</li>\n</ol>\n<pre><code class=\"java\">File file = new File(&quot;E:\\download\\office2007pro.chs.ISO&quot;);\nFileInputStream in = new FileInputStream(file);\nFileChannel channel = in.getChannel();\n\nMappedByteBuffer buff = channel.map(FileChannel.MapMode.READ_ONLY, 0,channel.size());\n</code></pre>\n<p>  这里创建了一个只读模式的内存映射文件区域，接下来我就来测试下与普通NIO中的通道操作相比性能上的优势，先看如下代码：</p>\n<pre><code class=\"java\">public class MapperToBasic {\n\n    static final int BUFFER_SIZE = 1024;\n\n    String path =&quot;/Users/zhangke/code/java/tem/wechat.dmg&quot;;\n\n    @Test\n    public void mapperTest() {\n        File file = new File(path);\n\n        FileInputStream in = null;\n        FileChannel channel = null;\n        try {\n            in = new FileInputStream(file);\n            channel = in.getChannel();\n            MappedByteBuffer buff = \n                channel.map(FileChannel.MapMode.READ_ONLY, \n                            0, channel.size());\n\n            byte[] b = new byte[1024];\n            int len = (int) file.length();\n\n            long begin = System.currentTimeMillis();\n\n            for (int offset = 0; offset &lt; len; offset += \n                 1024) {\n\n                if (len - offset &gt; BUFFER_SIZE) {\n                    buff.get(b);\n                } else {\n                    buff.get(new byte[len - offset]);\n                }\n            }\n\n            long end = System.currentTimeMillis();\n            System.out.println(&quot;time is:&quot; + (end - begin));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n\n            Optional.ofNullable(channel).ifPresent(c -&gt; {\n                try {\n\n                    c.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void basiTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.flip();\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;time is:&quot; + (end - begin));\n\n\n    }\n</code></pre>\n<p>上面第一个函数是测试NIO和普通IO读取文件大小为100M的文件内容的时间NIO读取完所有的内容大概花了30毫秒，普通IO大概花了160毫秒。文件越大，差距便越大。所以内存映射文件特别适合于对大文件的操作，JAVA中的限制是最大不得超过 Integer.MAX_VALUE，即2G左右，不过我们可以通过多次映射文件(channel.map)的不同部分来达到操作整个文件的目的。</p>\n<p>按照jdk文档的官方说法，内存映射文件属于JVM中的直接缓冲区，还可以通过 ByteBuffer.allocateDirect() ，即DirectMemory的方式来创建直接缓冲区。他们相比基础的 IO操作来说就是少了中间缓冲区的数据拷贝开销。同时他们属于JVM堆外内存，不受JVM堆内存大小的限制。</p>\n<h3 id=\"4-直接内存\"><a href=\"#4-直接内存\" class=\"headerlink\" title=\"4. 直接内存\"></a>4. 直接内存</h3><p>DirectMemory 默认的大小是等同于JVM最大堆，理论上说受限于进程的虚拟地址空间大小，比如 32位的windows上，每个进程有4G的虚拟空间除去 2G为OS内核保留外，再减去 JVM堆的最大值，剩余的才是DirectMemory大小。通过设置 JVM参数 -Xmx64M，即JVM最大堆为64M，然后执行以下程序可以证明DirectMemory不受JVM堆大小控制：</p>\n<pre><code class=\"java\"> public static void main(String[] args) {       \n   ByteBuffer.allocateDirect(1024*1024*100); // 100MB\n   }\n</code></pre>\n<p>我们设置了JVM堆 64M限制，然后在 直接内存上分配了 100MB空间，程序执行后直接报错：<strong>Exception in thread “main” java.lang.OutOfMemoryError: Direct buffer memory</strong>。接着我设置 -Xmx200M，程序正常结束。然后我修改配置： -Xmx64M  -XX:MaxDirectMemorySize=200M，程序正常结束。因此得出结论： 直接内存DirectMemory的大小默认为 -Xmx 的JVM堆的最大值，但是并不受其限制，而是由JVM参数 MaxDirectMemorySize单独控制。接下来我们来证明直接内存不是分配在JVM堆中。我们先执行以下程序，并设置 JVM参数       <strong>-XX:+PrintGC</strong> </p>\n<pre><code> public static void main(String[] args) {       \n     for(int i=0;i&lt;20000;i++) {\n            ByteBuffer.allocateDirect(1024*100);  //100K\n       }\n   }\n</code></pre><p>  输出结果如下：</p>\n<pre><code> [GC 1371K-&gt;1328K(61312K), 0.0070033 secs]\n [Full GC 1328K-&gt;1297K(61312K), 0.0329592 secs]\n [GC 3029K-&gt;2481K(61312K), 0.0037401 secs]\n [Full GC 2481K-&gt;2435K(61312K), 0.0102255 secs]\n</code></pre><p>   我们看到这里执行 GC的次数较少，但是触发了 两次 Full GC，原因在于直接内存不受 GC(新生代的Minor GC)影响，只有当执行老年代的 Full GC时候才会顺便回收直接内存！而直接内存是通过存储在JVM堆中的DirectByteBuffer对象来引用的，所以当众多的DirectByteBuffer对象从新生代被送入老年代后才触发了 full gc。</p>\n<p>  再看直接在JVM堆上分配内存区域的情况：</p>\n<pre><code class=\"java\">   public static void main(String[] args) {       \n    for(int i=0;i&lt;10000;i++) {\n             ByteBuffer.allocate(1024*100);  //100K\n     }\n   }\n</code></pre>\n<p>  ByteBuffer.allocate 意味着直接在 JVM堆上分配内存，所以受 新生代的 Minor GC影响，输出如下：</p>\n<pre><code>    [GC 16023K-&gt;224K(61312K), 0.0012432 secs]\n    [GC 16211K-&gt;192K(77376K), 0.0006917 secs]\n    [GC 32242K-&gt;176K(77376K), 0.0010613 secs]\n    [GC 32225K-&gt;224K(109504K), 0.0005539 secs]\n    [GC 64423K-&gt;192K(109504K), 0.0006151 secs]\n    [GC 64376K-&gt;192K(171392K), 0.0004968 secs]\n    [GC 128646K-&gt;204K(171392K), 0.0007423 secs]\n    [GC 128646K-&gt;204K(299968K), 0.0002067 secs]\n    [GC 257190K-&gt;204K(299968K), 0.0003862 secs]\n    [GC 257193K-&gt;204K(287680K), 0.0001718 secs]\n    [GC 245103K-&gt;204K(276480K), 0.0001994 secs]\n    [GC 233662K-&gt;204K(265344K), 0.0001828 secs]\n    [GC 222782K-&gt;172K(255232K), 0.0001998 secs]\n    [GC 212374K-&gt;172K(245120K), 0.0002217 secs]\n</code></pre><p>   可以看到，由于直接在 JVM堆上分配内存，所以触发了多次GC，且不会触及  Full GC，因为对象根本没机会进入老年代。</p>\n<p>在这里要来探讨一下内存映射和DirectMemory的内存回收问题。NIO中的DirectMemory和内存文件映射同属于直接缓冲区，但是前者和 -Xmx和-XX:MaxDirectMemorySize有关，而后者完全没有JVM参数可以影响和控制，这让我不禁怀疑两者的直接缓冲区是否相同，前者指的是 JAVA进程中的 native堆，即涉及底层平台如 win32的dll 部分，因为 C语言中的 malloc()分配的内存就属于 native堆，不属于 JVM堆，这也是DirectMemory能在一些场景中显著提高性能的原因，因为它避免了在 native堆和jvm堆之间数据的来回复制；而后者则是没有经过 native堆，是由 JAVA进程直接建立起 某一段虚拟地址空间和文件对象的关联映射关系，参见 Linux虚拟存储器图中的 “Memory mapped region for shared libraries”  区域，所以内存映射文件的区域并不在JVM GC的回收范围内，因为它本身就不属于堆区，卸载这部分区域只能通过系统调用 unmap()来实现 (Linux)中，而 JAVA API 只提供了 FileChannel.map 的形式创建内存映射区域，却没有提供对应的 unmap()。</p>\n<p>事实是由JVM帮助我们自动回收这部分内存，在定义这些类时，通过一个虚引用包裹这些创建的NIO对象，当JVM进行GC时检测指向这些内存映射或者直接内存的java对象是否被回收（java对象都是保存在堆上，只是对象中使用变量空间指向对外内存）。如果这些对象被回收，那么JVM就会自动的帮助我们回收这些堆外内存。具体参考：<a href=\"https://www.jianshu.com/p/007052ee3773\" target=\"_blank\" rel=\"noopener\">堆外内存 之 DirectByteBuffer 详解</a></p>\n<p>最后再试试通过 DirectMemory来操作前面 内存映射和基本通道操作的例子，来看看直接内存操作的话，程序的性能如何：</p>\n<pre><code>    @Test\n    public void directBufferTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n\n        ByteBuffer buff = ByteBuffer.allocateDirect(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;time is:&quot; + (end - begin));\n        in.close();\n    }\n</code></pre><p>程序输出为 130毫秒，看来比普通的NIO通道操作（160毫秒）来的快，但是比 mmap 内存映射的 30差距太多了，我想应该不至于吧，通过修改：</p>\n<pre><code>ByteBuffer buff = ByteBuffer.allocateDirect(1024);  \n//将上面语句修改如下\nByteBuffer buff = ByteBuffer.allocateDirect((int)file.length())，\n</code></pre><p>即一次性分配整个文件长度大小的堆外内存，最终输出为 78毫秒，由此可以得出两个结论：</p>\n<ol>\n<li><p>堆外内存的分配耗时比较大.  </p>\n</li>\n<li><p>还是比mmap内存映射来得慢，都不要说通过mmap读取数据的时候还涉及缺页异常、页面调度的系统调用了。</p>\n</li>\n</ol>\n<p>最后一点为 DirectMemory的内存只有在 JVM执行 full gc 的时候才会被回收，那么如果在其上分配过大的内存空间，那么也将出现 OutofMemoryError，即便 JVM 堆中的很多内存处于空闲状态。</p>\n<p> <strong>补充下额外的一个知识点，关于 JVM堆大小的设置是不受限于物理内存，而是受限于虚拟内存空间大小，理论上来说是进程的虚拟地址空间大小，但是实际上我们的虚拟内存空间是有限制的，一般windows上默认在C盘，大小为物理内存的2倍左右。我做了个实验：我机子是 64位的win7，那么理论上说进程虚拟空间是几乎无限大，物理内存为4G，而我设置 -Xms5000M， 即在启动JAVA程序的时候一次性申请到超过物理内存大小的5000M内存，程序正常启动，而当我加到 -Xms8000M的时候就报OOM错误了，然后我修改增加 win7的虚拟内存，程序又正常启动了，说明 -Xms 受限于虚拟内存的大小。我设置-Xms5000M，即超过了4G物理内存，并在一个死循环中不断创建对象，并保证不会被GC回收。程序运行一会后整个电脑几乎死机状态，即卡住了，反映很慢很慢，推测是发生了系统颠簸，即频繁的页面调度置换导致，说明 -Xms -Xmx不是局限于物理内存的大小，而是综合虚拟内存了，JVM会根据电脑虚拟内存的设置来控制。</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://blog.csdn.net/fcbayernmunchen/article/details/8635427\" target=\"_blank\" rel=\"noopener\">JAVA NIO之浅谈内存映射文件原理与DirectMemory</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java-NIO之浅谈内存映射文件原理与DirectMemory\"><a href=\"#Java-NIO之浅谈内存映射文件原理与DirectMemory\" class=\"headerlink\" title=\"Java NIO之浅谈内存映射文件原理与DirectMemory\"></a>Java NIO之浅谈内存映射文件原理与DirectMemory</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>传统文件IO操作原理</li>\n<li>什么是内存映射</li>\n<li>NIO中内存映射</li>\n<li>直接缓冲区（DirectMemory）</li>\n</ol>\n<p>学习了很久的NIO，但是一直对NIO中内存映射和DirectMemory有很多的不理解，恰好最近在读《深入理解操作系统》，对其中一些不理解的地点有了自己的一些感悟。此篇文章将结合操作系统谈谈自己对NIO中的内存映射和DirectMemory的理解。</p>","more":"<h3 id=\"1-传统文件IO操作原理\"><a href=\"#1-传统文件IO操作原理\" class=\"headerlink\" title=\"1.传统文件IO操作原理\"></a>1.传统文件IO操作原理</h3><p>在传统的文件IO操作中，我们都是调用操作系统提供的底层标准IO系统调用函数  read()、write() ，此时调用此函数的进程（在JAVA中即java进程）会从用户态切换到内核态，然后OS的内核代码负责将相应的文件数据读取到内核的IO缓冲区，然后再把数据从内核IO缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。至于为什么要多此一举搞一个内核IO缓冲区把原本只需一次拷贝数据的事情搞成需要2次数据拷贝呢？ 我想学过操作系统或者计算机系统结构的人都知道，这么做是为了减少磁盘的IO操作，为了提高性能而考虑的，因为我们的程序访问一般都带有局部性，也就是所谓的局部性原理，在这里主要是指的空间局部性，即我们访问了文件的某一段数据，那么接下去很可能还会访问接下去的一段数据，由于磁盘IO操作的速度比直接访问内存慢了好几个数量级，所以OS根据局部性原理会在一次 read()系统调用过程中预读更多的文件数据缓存在内核IO缓冲区中，当继续访问的文件数据在缓冲区中时便直接拷贝数据到进程私有空间，避免了再次的低效率磁盘IO操作。在JAVA中当我们采用IO包下的文件操作流，如：  </p>\n<pre><code>   FileInputStream in = new FileInputStream(&quot;D:\\\\java.txt&quot;);\n   in.read();\n</code></pre><p>   JAVA虚拟机内部便会调用OS底层的 read()系统调用完成操作，如上所述，在第二次调用 in.read()的时候可能就是从内核缓冲区直接返回数据了（可能还有经过 native堆做一次中转，因为这些函数都被声明为 native，即本地平台相关，所以可能在C代码中有做一次中转，如 win32中是通过 C代码从OS读取数据，然后再传给JVM内存）。既然如此，JAVA的IO包中为啥还要提供一个 BufferedInputStream 类来作为缓冲区呢。关键在于四个字，”系统调用”！当读取OS内核缓冲区数据的时候，便发起了一次系统调用操作（通过native的C函数调用），而系统调用的代价相对来说是比较高的，涉及到进程用户态和内核态的上下文切换等一系列操作，所以我们经常采用如下的包装：</p>\n<pre><code class=\"java\">   FileInputStream in = new FileInputStream(&quot;D:\\\\java.txt&quot;); \n   BufferedInputStream buf_in = new BufferedInputStream(in);\n   buf_in.read();\n</code></pre>\n<p>  这样一来，我们每一次 buf_in.read() 时候，BufferedInputStream 会根据情况自动为我们预读更多的字节数据到它自己维护的一个内部字节数组缓冲区中，这样我们便可以减少系统调用次数，从而达到其缓冲区的目的。所以要明确的一点是 BufferedInputStream 的作用不是减少磁盘IO操作次数（这个OS已经帮我们做了），而是通过减少系统调用次数来提高性能的。同理 BufferedOuputStream , BufferedReader/Writer 也是一样的。在 C语言的函数库中也有类似的实现，如 fread()，这个函数就是 C语言中的缓冲IO，作用与BufferedInputStream()相同.</p>\n<p>​    这里简单的引用下JDK8 中 BufferedInputStream 的源码验证下：</p>\n<pre><code class=\"java\">public\nclass BufferedInputStream extends FilterInputStream {\n\n    /**\n    * 只列出了重要的部分\n    */\n\n    protected volatile byte buf[];\n\n    public synchronized int read() throws IOException {\n        if (pos &gt;= count) {\n            fill();\n            if (pos &gt;= count)\n                return -1;\n        }\n        return getBufIfOpen()[pos++] &amp; 0xff;\n    }\n\n\n\n</code></pre>\n<p>   我们可以看到，BufferedInputStream 内部维护着一个 字节数组 byte[] buf 来实现缓冲区的功能，我们调用的  buf_in.read() 方法在返回数据之前有做一个 if 判断，如果 buf 数组的当前索引不在有效的索引范围之内，即 if 条件成立， buf 字段维护的缓冲区已经不够了，这时候会调用 内部的 fill() 方法进行填充，而fill()会预读更多的数据到 buf 数组缓冲区中去，然后再返回当前字节数据，如果 if 条件不成立便直接从 buf缓冲区数组返回数据了。其中getBufIfOpen()返回的就是 buf字段的引用。顺便说下，源码中的 buf 字段声明为  protected volatile byte buf[];  主要是为了通过 volatile 关键字保证 buf数组在多线程并发环境中的内存可见性.</p>\n<h3 id=\"2-什么是内存映射\"><a href=\"#2-什么是内存映射\" class=\"headerlink\" title=\"2. 什么是内存映射\"></a>2. 什么是内存映射</h3><p>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。虚拟内存区域可以映射到俩种类型的对象一种：</p>\n<ol>\n<li>linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分。并且磁盘文件区被分成页大小的片，每一片包含一个虚拟页面的初始内容。此时并没有拷贝数据到内存中去，而是当进程代码第一次引用这段代码内的虚拟地址时，触发了缺页异常，这时候OS根据映射关系直接将文件的相关部分数据拷贝到进程的用户私有空间中去，当有操作第N页数据的时候重复这样的OS页面调度程序操作。<strong>现在终于找出内存映射效率高的原因，原来内存映射文件的效率比标准IO高的重要原因就是因为少了把数据拷贝到OS内核缓冲区这一步（可能还少了native堆中转这一步）。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。</strong></li>\n<li>匿名文件：一个区域也可以映射到一个匿名文件，匿名文件时有内核穿件的，包含的去不是二进制零。CPU第一次引用这样的一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，经这个页面标记为是驻留在内存中的。注意在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制零的页。</li>\n</ol>\n<p><strong>注：如果你对虚拟内存不是很明白，推介你去看《深入理解操作系统》第九章</strong></p>\n<h3 id=\"3-NIO中内存映射\"><a href=\"#3-NIO中内存映射\" class=\"headerlink\" title=\"3.NIO中内存映射\"></a>3.NIO中内存映射</h3><p>上面介绍了普通文件IO和内存映射，已经总结了为什么内存映射比普通的IO函数要快。现在来了解java中的内存映射，这也是NIO中的一个特性。其实java中的内存映射就是用c语言封装了一层，方便我们用java来调用，因此在了解概念的基础后，我们来看看如何使用。</p>\n<p>  java中提供了3种内存映射模式，即：只读(readonly)、读写(read_write)、专用(private) ，</p>\n<ol>\n<li>对于只读模式来说，如果程序试图进行写操作，则会抛出ReadOnlyBufferException异常；</li>\n<li>第二种的读写模式表明了通过内存映射文件的方式写或修改文件内容的话是会立刻反映到磁盘文件中去的，别的进程如果共享了同一个映射文件，那么也会立即看到变化！而不是像标准IO那样每个进程有各自的内核缓冲区，比如JAVA代码中，没有执行 IO输出流的 flush() 或者  close() 操作，那么对文件的修改不会更新到磁盘去，除非进程运行结束；</li>\n<li><p>最后一种专用模式采用的是OS的“写时拷贝”原则，即在没有发生写操作的情况下，多个进程之间都是共享文件的同一块物理内存（进程各自的虚拟地址指向同一片物理地址），一旦某个进程进行写操作，那么将会把受影响的文件数据单独拷贝一份到进程的私有缓冲区中，不会反映到物理文件中去。</p>\n<p>在JAVA NIO中可以很容易的创建一块内存映射区域，代码如下：</p>\n</li>\n</ol>\n<pre><code class=\"java\">File file = new File(&quot;E:\\download\\office2007pro.chs.ISO&quot;);\nFileInputStream in = new FileInputStream(file);\nFileChannel channel = in.getChannel();\n\nMappedByteBuffer buff = channel.map(FileChannel.MapMode.READ_ONLY, 0,channel.size());\n</code></pre>\n<p>  这里创建了一个只读模式的内存映射文件区域，接下来我就来测试下与普通NIO中的通道操作相比性能上的优势，先看如下代码：</p>\n<pre><code class=\"java\">public class MapperToBasic {\n\n    static final int BUFFER_SIZE = 1024;\n\n    String path =&quot;/Users/zhangke/code/java/tem/wechat.dmg&quot;;\n\n    @Test\n    public void mapperTest() {\n        File file = new File(path);\n\n        FileInputStream in = null;\n        FileChannel channel = null;\n        try {\n            in = new FileInputStream(file);\n            channel = in.getChannel();\n            MappedByteBuffer buff = \n                channel.map(FileChannel.MapMode.READ_ONLY, \n                            0, channel.size());\n\n            byte[] b = new byte[1024];\n            int len = (int) file.length();\n\n            long begin = System.currentTimeMillis();\n\n            for (int offset = 0; offset &lt; len; offset += \n                 1024) {\n\n                if (len - offset &gt; BUFFER_SIZE) {\n                    buff.get(b);\n                } else {\n                    buff.get(new byte[len - offset]);\n                }\n            }\n\n            long end = System.currentTimeMillis();\n            System.out.println(&quot;time is:&quot; + (end - begin));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n\n            Optional.ofNullable(channel).ifPresent(c -&gt; {\n                try {\n\n                    c.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void basiTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.flip();\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;time is:&quot; + (end - begin));\n\n\n    }\n</code></pre>\n<p>上面第一个函数是测试NIO和普通IO读取文件大小为100M的文件内容的时间NIO读取完所有的内容大概花了30毫秒，普通IO大概花了160毫秒。文件越大，差距便越大。所以内存映射文件特别适合于对大文件的操作，JAVA中的限制是最大不得超过 Integer.MAX_VALUE，即2G左右，不过我们可以通过多次映射文件(channel.map)的不同部分来达到操作整个文件的目的。</p>\n<p>按照jdk文档的官方说法，内存映射文件属于JVM中的直接缓冲区，还可以通过 ByteBuffer.allocateDirect() ，即DirectMemory的方式来创建直接缓冲区。他们相比基础的 IO操作来说就是少了中间缓冲区的数据拷贝开销。同时他们属于JVM堆外内存，不受JVM堆内存大小的限制。</p>\n<h3 id=\"4-直接内存\"><a href=\"#4-直接内存\" class=\"headerlink\" title=\"4. 直接内存\"></a>4. 直接内存</h3><p>DirectMemory 默认的大小是等同于JVM最大堆，理论上说受限于进程的虚拟地址空间大小，比如 32位的windows上，每个进程有4G的虚拟空间除去 2G为OS内核保留外，再减去 JVM堆的最大值，剩余的才是DirectMemory大小。通过设置 JVM参数 -Xmx64M，即JVM最大堆为64M，然后执行以下程序可以证明DirectMemory不受JVM堆大小控制：</p>\n<pre><code class=\"java\"> public static void main(String[] args) {       \n   ByteBuffer.allocateDirect(1024*1024*100); // 100MB\n   }\n</code></pre>\n<p>我们设置了JVM堆 64M限制，然后在 直接内存上分配了 100MB空间，程序执行后直接报错：<strong>Exception in thread “main” java.lang.OutOfMemoryError: Direct buffer memory</strong>。接着我设置 -Xmx200M，程序正常结束。然后我修改配置： -Xmx64M  -XX:MaxDirectMemorySize=200M，程序正常结束。因此得出结论： 直接内存DirectMemory的大小默认为 -Xmx 的JVM堆的最大值，但是并不受其限制，而是由JVM参数 MaxDirectMemorySize单独控制。接下来我们来证明直接内存不是分配在JVM堆中。我们先执行以下程序，并设置 JVM参数       <strong>-XX:+PrintGC</strong> </p>\n<pre><code> public static void main(String[] args) {       \n     for(int i=0;i&lt;20000;i++) {\n            ByteBuffer.allocateDirect(1024*100);  //100K\n       }\n   }\n</code></pre><p>  输出结果如下：</p>\n<pre><code> [GC 1371K-&gt;1328K(61312K), 0.0070033 secs]\n [Full GC 1328K-&gt;1297K(61312K), 0.0329592 secs]\n [GC 3029K-&gt;2481K(61312K), 0.0037401 secs]\n [Full GC 2481K-&gt;2435K(61312K), 0.0102255 secs]\n</code></pre><p>   我们看到这里执行 GC的次数较少，但是触发了 两次 Full GC，原因在于直接内存不受 GC(新生代的Minor GC)影响，只有当执行老年代的 Full GC时候才会顺便回收直接内存！而直接内存是通过存储在JVM堆中的DirectByteBuffer对象来引用的，所以当众多的DirectByteBuffer对象从新生代被送入老年代后才触发了 full gc。</p>\n<p>  再看直接在JVM堆上分配内存区域的情况：</p>\n<pre><code class=\"java\">   public static void main(String[] args) {       \n    for(int i=0;i&lt;10000;i++) {\n             ByteBuffer.allocate(1024*100);  //100K\n     }\n   }\n</code></pre>\n<p>  ByteBuffer.allocate 意味着直接在 JVM堆上分配内存，所以受 新生代的 Minor GC影响，输出如下：</p>\n<pre><code>    [GC 16023K-&gt;224K(61312K), 0.0012432 secs]\n    [GC 16211K-&gt;192K(77376K), 0.0006917 secs]\n    [GC 32242K-&gt;176K(77376K), 0.0010613 secs]\n    [GC 32225K-&gt;224K(109504K), 0.0005539 secs]\n    [GC 64423K-&gt;192K(109504K), 0.0006151 secs]\n    [GC 64376K-&gt;192K(171392K), 0.0004968 secs]\n    [GC 128646K-&gt;204K(171392K), 0.0007423 secs]\n    [GC 128646K-&gt;204K(299968K), 0.0002067 secs]\n    [GC 257190K-&gt;204K(299968K), 0.0003862 secs]\n    [GC 257193K-&gt;204K(287680K), 0.0001718 secs]\n    [GC 245103K-&gt;204K(276480K), 0.0001994 secs]\n    [GC 233662K-&gt;204K(265344K), 0.0001828 secs]\n    [GC 222782K-&gt;172K(255232K), 0.0001998 secs]\n    [GC 212374K-&gt;172K(245120K), 0.0002217 secs]\n</code></pre><p>   可以看到，由于直接在 JVM堆上分配内存，所以触发了多次GC，且不会触及  Full GC，因为对象根本没机会进入老年代。</p>\n<p>在这里要来探讨一下内存映射和DirectMemory的内存回收问题。NIO中的DirectMemory和内存文件映射同属于直接缓冲区，但是前者和 -Xmx和-XX:MaxDirectMemorySize有关，而后者完全没有JVM参数可以影响和控制，这让我不禁怀疑两者的直接缓冲区是否相同，前者指的是 JAVA进程中的 native堆，即涉及底层平台如 win32的dll 部分，因为 C语言中的 malloc()分配的内存就属于 native堆，不属于 JVM堆，这也是DirectMemory能在一些场景中显著提高性能的原因，因为它避免了在 native堆和jvm堆之间数据的来回复制；而后者则是没有经过 native堆，是由 JAVA进程直接建立起 某一段虚拟地址空间和文件对象的关联映射关系，参见 Linux虚拟存储器图中的 “Memory mapped region for shared libraries”  区域，所以内存映射文件的区域并不在JVM GC的回收范围内，因为它本身就不属于堆区，卸载这部分区域只能通过系统调用 unmap()来实现 (Linux)中，而 JAVA API 只提供了 FileChannel.map 的形式创建内存映射区域，却没有提供对应的 unmap()。</p>\n<p>事实是由JVM帮助我们自动回收这部分内存，在定义这些类时，通过一个虚引用包裹这些创建的NIO对象，当JVM进行GC时检测指向这些内存映射或者直接内存的java对象是否被回收（java对象都是保存在堆上，只是对象中使用变量空间指向对外内存）。如果这些对象被回收，那么JVM就会自动的帮助我们回收这些堆外内存。具体参考：<a href=\"https://www.jianshu.com/p/007052ee3773\" target=\"_blank\" rel=\"noopener\">堆外内存 之 DirectByteBuffer 详解</a></p>\n<p>最后再试试通过 DirectMemory来操作前面 内存映射和基本通道操作的例子，来看看直接内存操作的话，程序的性能如何：</p>\n<pre><code>    @Test\n    public void directBufferTest() throws IOException {\n        File file = new File(path);\n        FileInputStream in = new FileInputStream(file);\n        FileChannel channel = in.getChannel();\n\n        ByteBuffer buff = ByteBuffer.allocateDirect(1024);\n\n        long begin = System.currentTimeMillis();\n        while (channel.read(buff) != -1) {\n            buff.clear();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;time is:&quot; + (end - begin));\n        in.close();\n    }\n</code></pre><p>程序输出为 130毫秒，看来比普通的NIO通道操作（160毫秒）来的快，但是比 mmap 内存映射的 30差距太多了，我想应该不至于吧，通过修改：</p>\n<pre><code>ByteBuffer buff = ByteBuffer.allocateDirect(1024);  \n//将上面语句修改如下\nByteBuffer buff = ByteBuffer.allocateDirect((int)file.length())，\n</code></pre><p>即一次性分配整个文件长度大小的堆外内存，最终输出为 78毫秒，由此可以得出两个结论：</p>\n<ol>\n<li><p>堆外内存的分配耗时比较大.  </p>\n</li>\n<li><p>还是比mmap内存映射来得慢，都不要说通过mmap读取数据的时候还涉及缺页异常、页面调度的系统调用了。</p>\n</li>\n</ol>\n<p>最后一点为 DirectMemory的内存只有在 JVM执行 full gc 的时候才会被回收，那么如果在其上分配过大的内存空间，那么也将出现 OutofMemoryError，即便 JVM 堆中的很多内存处于空闲状态。</p>\n<p> <strong>补充下额外的一个知识点，关于 JVM堆大小的设置是不受限于物理内存，而是受限于虚拟内存空间大小，理论上来说是进程的虚拟地址空间大小，但是实际上我们的虚拟内存空间是有限制的，一般windows上默认在C盘，大小为物理内存的2倍左右。我做了个实验：我机子是 64位的win7，那么理论上说进程虚拟空间是几乎无限大，物理内存为4G，而我设置 -Xms5000M， 即在启动JAVA程序的时候一次性申请到超过物理内存大小的5000M内存，程序正常启动，而当我加到 -Xms8000M的时候就报OOM错误了，然后我修改增加 win7的虚拟内存，程序又正常启动了，说明 -Xms 受限于虚拟内存的大小。我设置-Xms5000M，即超过了4G物理内存，并在一个死循环中不断创建对象，并保证不会被GC回收。程序运行一会后整个电脑几乎死机状态，即卡住了，反映很慢很慢，推测是发生了系统颠簸，即频繁的页面调度置换导致，说明 -Xms -Xmx不是局限于物理内存的大小，而是综合虚拟内存了，JVM会根据电脑虚拟内存的设置来控制。</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://blog.csdn.net/fcbayernmunchen/article/details/8635427\" target=\"_blank\" rel=\"noopener\">JAVA NIO之浅谈内存映射文件原理与DirectMemory</a></li>\n</ol>"},{"abbrlink":2,"title":"java多线程系列 02 sychronized关键字","author":"zhangke","date":"2018-07-12T07:55:00.000Z","_content":"# java多线程系列 02 sychronized关键字\n\n### 概要\n\n1. Sychronized 基本用法\n2. sychronized基本规则\n3. 对象锁和类索\n\n### 1. sychronized基本用法\n\nsychronized主要由俩种用法，一种是用来修饰方法，另外一种是用来修饰代码块。\n\n**synchronized方法示例**\n\n```java\npublic synchronized void foo1() {\n    System.out.println(\"synchronized methoed\");\n}\n```\n\n**synchronized代码块**\n\n```java\npublic void foo2() {\n    synchronized (this) {\n        System.out.println(\"synchronized methoed\");\n    }\n}\n```\n\nsynchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。\n\nsynchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率(并不是在所有情况下是最好的)。下面通过一个示例来演示：\n\n```Java\npublic class Demo4 {\n\n    public synchronized void synMethod() {\n        for (int i = 0; i < 1000000; i++)\n            ;\n    }\n\n    public void synBlock() {\n        synchronized (this) {\n            for (int i = 0; i < 1000000; i++)\n                ;\n        }\n    }\n\n    public static void main(String[] args) {\n        Demo4 demo = new Demo4();\n\n        long start, diff;\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synMethod();                                // 调用“synchronized方法”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(\"synMethod() : \" + diff);\n\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synBlock();                                // 调用“synchronized方法块”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(\"synBlock()  : \" + diff);\n    }\n}\n```\n>\n>下面是在我电脑上运行的结果：\n>\n>```\n>synMethod() : 2\n>synBlock()  : 3\n>```\n>\n>\n\n### 2. sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。 \n\n>\n>\n>>## 第一条\n>>\n>>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 \n>>\n>>下面是“synchronized代码块”对应的演示程序。\n>>\n>>```java\n>>class MyRunable implements Runnable {\n>>\n>>    @Override\n>>    public void run() {\n>>        //锁住当前线程\n>>        synchronized (this) {\n>>            try {\n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() \n>>                                       + \" loop \" + i);\n>>                }\n>>            } catch (InterruptedException ie) {\n>>            }\n>>        }\n>>    }\n>>}\n>>\n>>public class Demo1_1 {\n>>\n>>    public static void main(String[] args) {\n>>        // 新建“Runnable对象”\n>>        Runnable demo = new MyRunable();\n>>\n>>        // 新建“线程t1”, t1是基于demo这个Runnable对象\n>>        Thread t1 = new Thread(demo, \"t1\");\n>>\n>>        // 新建“线程t2”, t2是基于demo这个Runnable对象\n>>        Thread t2 = new Thread(demo, \"t2\");\n>>        t1.start();           // 启动“线程t1”\n>>        t2.start();           // 启动“线程t2”\n>>    }\n>>}\n>>```\n>>\n>>运行结果\n>>\n>>```\n>>t1 loop 0\n>>t1 loop 1\n>>t1 loop 2\n>>t1 loop 3\n>>t1 loop 4\n>>t2 loop 0\n>>t2 loop 1\n>>t2 loop 2\n>>t2 loop 3\n>>t2 loop 4\n>>```\n>>\n>>**结果说明**：\n>>run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于\"demo这个Runnable对象\"创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。\n>>\n>>如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下：\n>>\n>>```\n>>class MyThread extends Thread {\n>>    \n>>    public MyThread(String name) {\n>>        super(name);\n>>    }\n>>\n>>    @Override\n>>    public void run() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() \n>>                    + \" loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }  \n>>    }\n>>}\n>>\n>>public class Demo1_2 {\n>>\n>>    public static void main(String[] args) {  \n>>        Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>>        Thread t2 = new MyThread(\"t2\");  // 新建“线程t2”\n>>        t1.start();                          // 启动“线程t1”\n>>        t2.start();                          // 启动“线程t2” \n>>    } \n>>}\n>>```\n>>\n>>**代码说明**： 比较Demo1_2 和 Demo1_1，我们发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。 幸运的是，在“Demo1_2的run()方法”也调用了synchronized(this)，正如“Demo1_1的run()方法”也调用了synchronized(this)一样！ 那么，Demo1_2的执行流程是不是和Demo1_1一样呢？\n>>\n>>运行结果\n>>\n>>```\n>>t1 loop 0\n>>t2 loop 0\n>>t1 loop 1\n>>t2 loop 1\n>>t1 loop 2\n>>t2 loop 2\n>>t1 loop 3\n>>t2 loop 3\n>>t1 loop 4\n>>t2 loop 4\n>>```\n>>\n>>**结果说明**：\n>>如果这个结果一点也不令你感到惊讶，那么我相信你对synchronized和this的认识已经比较深刻了。否则的话，请继续阅读这里的分析。\n>>synchronized(this)中的this是指“当前的类对象”，即synchronized(this)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。\n>>对于Demo1_2中，synchronized(this)中的this代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行synchronized(this)时，获取的是不同对象的同步锁。对于Demo1_1对而言，synchronized(this)中的this代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。\n>>\n>>## 第二条\n>>\n>>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 下面是“synchronized代码块”对应的演示程序:\n>>\n>>```\n>>class Count {\n>>\n>>    // 含有synchronized同步块的方法\n>>    public void synMethod() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() + \" synMethod loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }  \n>>    }\n>>\n>>    // 非同步的方法\n>>    public void nonSynMethod() {\n>>        try {  \n>>            for (int i = 0; i < 5; i++) {\n>>                Thread.sleep(100);\n>>                System.out.println(Thread.currentThread().getName() + \" nonSynMethod loop \" + i);  \n>>            }\n>>        } catch (InterruptedException ie) {  \n>>        }\n>>    }\n>>}\n>>\n>>public class Demo2 {\n>>\n>>    public static void main(String[] args) {  \n>>        final Count count = new Count();\n>>        // 新建t1, t1会调用“count对象”的synMethod()方法\n>>        Thread t1 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.synMethod();\n>>                    }\n>>                }, \"t1\");\n>>\n>>        // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n>>        Thread t2 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.nonSynMethod();\n>>                    }\n>>                }, \"t2\");  \n>>\n>>\n>>        t1.start();  // 启动t1\n>>        t2.start();  // 启动t2\n>>    } \n>>}\n>>```\n>>\n>>运行结果：\n>>\n>>```\n>>t1 synMethod loop 0\n>>t2 nonSynMethod loop 0\n>>t1 synMethod loop 1\n>>t2 nonSynMethod loop 1\n>>t1 synMethod loop 2\n>>t2 nonSynMethod loop 2\n>>t1 synMethod loop 3\n>>t2 nonSynMethod loop 3\n>>t1 synMethod loop 4\n>>t2 nonSynMethod loop 4\n>>```\n>>\n>>**结果说明**： 主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。\n>>\n>># 第三条\n>>\n>>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 我们将上面的例子中的nonSynMethod()方法体的也用synchronized(this)修饰。修改后的源码如下：\n>>\n>>```\n>>class Count {\n>>\n>>    // 含有synchronized同步块的方法\n>>    public void synMethod() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() + \" synMethod loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }  \n>>    }\n>>\n>>    // 也包含synchronized同步块的方法\n>>    public void nonSynMethod() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100);\n>>                    System.out.println(Thread.currentThread().getName() + \" nonSynMethod loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }\n>>    }\n>>}\n>>\n>>public class Demo3 {\n>>\n>>    public static void main(String[] args) {  \n>>        final Count count = new Count();\n>>        // 新建t1, t1会调用“count对象”的synMethod()方法\n>>        Thread t1 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.synMethod();\n>>                    }\n>>                }, \"t1\");\n>>\n>>        // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n>>        Thread t2 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.nonSynMethod();\n>>                    }\n>>                }, \"t2\");  \n>>\n>>\n>>        t1.start();  // 启动t1\n>>        t2.start();  // 启动t2\n>>    } \n>>}\n>>```\n>>\n>>运行结果：\n>>\n>>```\n>>t1 synMethod loop 0\n>>t1 synMethod loop 1\n>>t1 synMethod loop 2\n>>t1 synMethod loop 3\n>>t1 synMethod loop 4\n>>t2 nonSynMethod loop 0\n>>t2 nonSynMethod loop 1\n>>t2 nonSynMethod loop 2\n>>t2 nonSynMethod loop 3\n>>t2 nonSynMethod loop 4\n>>```\n>>\n>>**结果说明**： 主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。\n>\n>\n\n### 3. 对象锁和类索\n\n>**对象锁** -- 锁在某一个实例对象上。如果该类是单例，那么该锁也和类锁具有相同的效果。          \n>\n> **类锁** -- 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 类锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。\n>\n>关于“实例锁”和“全局锁”有一个很形象的例子：\n>\n>```\n>pulbic class Something {\n>    public synchronized void isSyncA(){}\n>    public synchronized void isSyncB(){}\n>    public static synchronized void cSyncA(){}\n>    public static synchronized void cSyncB(){}\n>}\n>```\n>\n>假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。\n>(01) x.isSyncA()与x.isSyncB() \n>(02) x.isSyncA()与y.isSyncA()\n>(03) x.cSyncA()与y.cSyncB()\n>(04) x.isSyncA()与Something.cSyncA()\n>\n>**(01) 不能被同时访问。**因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！\n>\n>```\n> // LockTest1.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest1 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(01) x.isSyncA()与x.isSyncB() \n>    private void test1() {\n>        // 新建t11, t11会调用 x.isSyncA()\n>        Thread t11 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncA();\n>                    }\n>                }, \"t11\");\n>\n>        // 新建t12, t12会调用 x.isSyncB()\n>        Thread t12 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncB();\n>                    }\n>                }, \"t12\");  \n>\n>\n>        t11.start();  // 启动t11\n>        t12.start();  // 启动t12\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest1 demo = new LockTest1();\n>        demo.test1();\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t11 : isSyncA\n>t11 : isSyncA\n>t11 : isSyncA\n>t11 : isSyncA\n>t11 : isSyncA\n>t12 : isSyncB\n>t12 : isSyncB\n>t12 : isSyncB\n>t12 : isSyncB\n>t12 : isSyncB\n>```\n>\n>**(02) 可以同时被访问。**因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。\n>\n>```\n>// LockTest1.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest1 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(01) x.isSyncA()与x.isSyncB() \n>    private void test1() {\n>        // 新建t11, t11会调用 x.isSyncA()\n>        Thread t11 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncA();\n>                    }\n>                }, \"t11\");\n>\n>        // 新建t12, t12会调用 x.isSyncB()\n>        Thread t12 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncB();\n>                    }\n>                }, \"t12\");  \n>\n>\n>        t11.start();  // 启动t11\n>        t12.start();  // 启动t12\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest1 demo = new LockTest1();\n>        demo.test1();\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>```\n>\n>**(03) 不能被同时访问。**因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。\n>\n>```\n> // LockTest3.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncA\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncB\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest3 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(03) x.cSyncA()与y.cSyncB()\n>    private void test3() {\n>        // 新建t31, t31会调用 x.isSyncA()\n>        Thread t31 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.cSyncA();\n>                    }\n>                }, \"t31\");\n>\n>        // 新建t32, t32会调用 x.isSyncB()\n>        Thread t32 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        y.cSyncB();\n>                    }\n>                }, \"t32\");  \n>\n>\n>        t31.start();  // 启动t31\n>        t32.start();  // 启动t32\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest3 demo = new LockTest3();\n>\n>        demo.test3();\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t31 : cSyncA\n>t31 : cSyncA\n>t31 : cSyncA\n>t31 : cSyncA\n>t31 : cSyncA\n>t32 : cSyncB\n>t32 : cSyncB\n>t32 : cSyncB\n>t32 : cSyncB\n>t32 : cSyncB \n>```\n>\n>**(04) 可以被同时访问。**因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。\n>\n>```\n>// LockTest4.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncA\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncB\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest4 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(04) x.isSyncA()与Something.cSyncA()\n>    private void test4() {\n>        // 新建t41, t41会调用 x.isSyncA()\n>        Thread t41 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncA();\n>                    }\n>                }, \"t41\");\n>\n>        // 新建t42, t42会调用 x.isSyncB()\n>        Thread t42 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        Something.cSyncA();\n>                    }\n>                }, \"t42\");  \n>\n>\n>        t41.start();  // 启动t41\n>        t42.start();  // 启动t42\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest4 demo = new LockTest4();\n>\n>        demo.test4();\n>    }\n>}**运行结果**：\n>```\n>\n\n总结：其实你可以将类锁和对象锁相同看待，我这里的相同看待是指，将他们看成俩个不同的对象的形式，其实每个class都有一个监视对象。用来管理类的创建等任务。Synchronized关键字也是锁住了这个监视器对象。所以可以类比着看。","source":"_posts/java多线程系列 02 synchronized 关键字.md","raw":"abbrlink: 2\ntitle: java多线程系列 02 sychronized关键字\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-12 15:55:00\n---\n# java多线程系列 02 sychronized关键字\n\n### 概要\n\n1. Sychronized 基本用法\n2. sychronized基本规则\n3. 对象锁和类索\n\n### 1. sychronized基本用法\n\nsychronized主要由俩种用法，一种是用来修饰方法，另外一种是用来修饰代码块。\n\n**synchronized方法示例**\n\n```java\npublic synchronized void foo1() {\n    System.out.println(\"synchronized methoed\");\n}\n```\n\n**synchronized代码块**\n\n```java\npublic void foo2() {\n    synchronized (this) {\n        System.out.println(\"synchronized methoed\");\n    }\n}\n```\n\nsynchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。\n\nsynchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率(并不是在所有情况下是最好的)。下面通过一个示例来演示：\n\n```Java\npublic class Demo4 {\n\n    public synchronized void synMethod() {\n        for (int i = 0; i < 1000000; i++)\n            ;\n    }\n\n    public void synBlock() {\n        synchronized (this) {\n            for (int i = 0; i < 1000000; i++)\n                ;\n        }\n    }\n\n    public static void main(String[] args) {\n        Demo4 demo = new Demo4();\n\n        long start, diff;\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synMethod();                                // 调用“synchronized方法”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(\"synMethod() : \" + diff);\n\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synBlock();                                // 调用“synchronized方法块”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(\"synBlock()  : \" + diff);\n    }\n}\n```\n>\n>下面是在我电脑上运行的结果：\n>\n>```\n>synMethod() : 2\n>synBlock()  : 3\n>```\n>\n>\n\n### 2. sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。 \n\n>\n>\n>>## 第一条\n>>\n>>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 \n>>\n>>下面是“synchronized代码块”对应的演示程序。\n>>\n>>```java\n>>class MyRunable implements Runnable {\n>>\n>>    @Override\n>>    public void run() {\n>>        //锁住当前线程\n>>        synchronized (this) {\n>>            try {\n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() \n>>                                       + \" loop \" + i);\n>>                }\n>>            } catch (InterruptedException ie) {\n>>            }\n>>        }\n>>    }\n>>}\n>>\n>>public class Demo1_1 {\n>>\n>>    public static void main(String[] args) {\n>>        // 新建“Runnable对象”\n>>        Runnable demo = new MyRunable();\n>>\n>>        // 新建“线程t1”, t1是基于demo这个Runnable对象\n>>        Thread t1 = new Thread(demo, \"t1\");\n>>\n>>        // 新建“线程t2”, t2是基于demo这个Runnable对象\n>>        Thread t2 = new Thread(demo, \"t2\");\n>>        t1.start();           // 启动“线程t1”\n>>        t2.start();           // 启动“线程t2”\n>>    }\n>>}\n>>```\n>>\n>>运行结果\n>>\n>>```\n>>t1 loop 0\n>>t1 loop 1\n>>t1 loop 2\n>>t1 loop 3\n>>t1 loop 4\n>>t2 loop 0\n>>t2 loop 1\n>>t2 loop 2\n>>t2 loop 3\n>>t2 loop 4\n>>```\n>>\n>>**结果说明**：\n>>run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于\"demo这个Runnable对象\"创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。\n>>\n>>如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下：\n>>\n>>```\n>>class MyThread extends Thread {\n>>    \n>>    public MyThread(String name) {\n>>        super(name);\n>>    }\n>>\n>>    @Override\n>>    public void run() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() \n>>                    + \" loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }  \n>>    }\n>>}\n>>\n>>public class Demo1_2 {\n>>\n>>    public static void main(String[] args) {  \n>>        Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>>        Thread t2 = new MyThread(\"t2\");  // 新建“线程t2”\n>>        t1.start();                          // 启动“线程t1”\n>>        t2.start();                          // 启动“线程t2” \n>>    } \n>>}\n>>```\n>>\n>>**代码说明**： 比较Demo1_2 和 Demo1_1，我们发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。 幸运的是，在“Demo1_2的run()方法”也调用了synchronized(this)，正如“Demo1_1的run()方法”也调用了synchronized(this)一样！ 那么，Demo1_2的执行流程是不是和Demo1_1一样呢？\n>>\n>>运行结果\n>>\n>>```\n>>t1 loop 0\n>>t2 loop 0\n>>t1 loop 1\n>>t2 loop 1\n>>t1 loop 2\n>>t2 loop 2\n>>t1 loop 3\n>>t2 loop 3\n>>t1 loop 4\n>>t2 loop 4\n>>```\n>>\n>>**结果说明**：\n>>如果这个结果一点也不令你感到惊讶，那么我相信你对synchronized和this的认识已经比较深刻了。否则的话，请继续阅读这里的分析。\n>>synchronized(this)中的this是指“当前的类对象”，即synchronized(this)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。\n>>对于Demo1_2中，synchronized(this)中的this代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行synchronized(this)时，获取的是不同对象的同步锁。对于Demo1_1对而言，synchronized(this)中的this代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。\n>>\n>>## 第二条\n>>\n>>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 下面是“synchronized代码块”对应的演示程序:\n>>\n>>```\n>>class Count {\n>>\n>>    // 含有synchronized同步块的方法\n>>    public void synMethod() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() + \" synMethod loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }  \n>>    }\n>>\n>>    // 非同步的方法\n>>    public void nonSynMethod() {\n>>        try {  \n>>            for (int i = 0; i < 5; i++) {\n>>                Thread.sleep(100);\n>>                System.out.println(Thread.currentThread().getName() + \" nonSynMethod loop \" + i);  \n>>            }\n>>        } catch (InterruptedException ie) {  \n>>        }\n>>    }\n>>}\n>>\n>>public class Demo2 {\n>>\n>>    public static void main(String[] args) {  \n>>        final Count count = new Count();\n>>        // 新建t1, t1会调用“count对象”的synMethod()方法\n>>        Thread t1 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.synMethod();\n>>                    }\n>>                }, \"t1\");\n>>\n>>        // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n>>        Thread t2 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.nonSynMethod();\n>>                    }\n>>                }, \"t2\");  \n>>\n>>\n>>        t1.start();  // 启动t1\n>>        t2.start();  // 启动t2\n>>    } \n>>}\n>>```\n>>\n>>运行结果：\n>>\n>>```\n>>t1 synMethod loop 0\n>>t2 nonSynMethod loop 0\n>>t1 synMethod loop 1\n>>t2 nonSynMethod loop 1\n>>t1 synMethod loop 2\n>>t2 nonSynMethod loop 2\n>>t1 synMethod loop 3\n>>t2 nonSynMethod loop 3\n>>t1 synMethod loop 4\n>>t2 nonSynMethod loop 4\n>>```\n>>\n>>**结果说明**： 主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。\n>>\n>># 第三条\n>>\n>>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 我们将上面的例子中的nonSynMethod()方法体的也用synchronized(this)修饰。修改后的源码如下：\n>>\n>>```\n>>class Count {\n>>\n>>    // 含有synchronized同步块的方法\n>>    public void synMethod() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100); // 休眠100ms\n>>                    System.out.println(Thread.currentThread().getName() + \" synMethod loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }  \n>>    }\n>>\n>>    // 也包含synchronized同步块的方法\n>>    public void nonSynMethod() {\n>>        synchronized(this) {\n>>            try {  \n>>                for (int i = 0; i < 5; i++) {\n>>                    Thread.sleep(100);\n>>                    System.out.println(Thread.currentThread().getName() + \" nonSynMethod loop \" + i);  \n>>                }\n>>            } catch (InterruptedException ie) {  \n>>            }\n>>        }\n>>    }\n>>}\n>>\n>>public class Demo3 {\n>>\n>>    public static void main(String[] args) {  \n>>        final Count count = new Count();\n>>        // 新建t1, t1会调用“count对象”的synMethod()方法\n>>        Thread t1 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.synMethod();\n>>                    }\n>>                }, \"t1\");\n>>\n>>        // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n>>        Thread t2 = new Thread(\n>>                new Runnable() {\n>>                    @Override\n>>                    public void run() {\n>>                        count.nonSynMethod();\n>>                    }\n>>                }, \"t2\");  \n>>\n>>\n>>        t1.start();  // 启动t1\n>>        t2.start();  // 启动t2\n>>    } \n>>}\n>>```\n>>\n>>运行结果：\n>>\n>>```\n>>t1 synMethod loop 0\n>>t1 synMethod loop 1\n>>t1 synMethod loop 2\n>>t1 synMethod loop 3\n>>t1 synMethod loop 4\n>>t2 nonSynMethod loop 0\n>>t2 nonSynMethod loop 1\n>>t2 nonSynMethod loop 2\n>>t2 nonSynMethod loop 3\n>>t2 nonSynMethod loop 4\n>>```\n>>\n>>**结果说明**： 主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。\n>\n>\n\n### 3. 对象锁和类索\n\n>**对象锁** -- 锁在某一个实例对象上。如果该类是单例，那么该锁也和类锁具有相同的效果。          \n>\n> **类锁** -- 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 类锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。\n>\n>关于“实例锁”和“全局锁”有一个很形象的例子：\n>\n>```\n>pulbic class Something {\n>    public synchronized void isSyncA(){}\n>    public synchronized void isSyncB(){}\n>    public static synchronized void cSyncA(){}\n>    public static synchronized void cSyncB(){}\n>}\n>```\n>\n>假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。\n>(01) x.isSyncA()与x.isSyncB() \n>(02) x.isSyncA()与y.isSyncA()\n>(03) x.cSyncA()与y.cSyncB()\n>(04) x.isSyncA()与Something.cSyncA()\n>\n>**(01) 不能被同时访问。**因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！\n>\n>```\n> // LockTest1.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest1 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(01) x.isSyncA()与x.isSyncB() \n>    private void test1() {\n>        // 新建t11, t11会调用 x.isSyncA()\n>        Thread t11 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncA();\n>                    }\n>                }, \"t11\");\n>\n>        // 新建t12, t12会调用 x.isSyncB()\n>        Thread t12 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncB();\n>                    }\n>                }, \"t12\");  \n>\n>\n>        t11.start();  // 启动t11\n>        t12.start();  // 启动t12\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest1 demo = new LockTest1();\n>        demo.test1();\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t11 : isSyncA\n>t11 : isSyncA\n>t11 : isSyncA\n>t11 : isSyncA\n>t11 : isSyncA\n>t12 : isSyncB\n>t12 : isSyncB\n>t12 : isSyncB\n>t12 : isSyncB\n>t12 : isSyncB\n>```\n>\n>**(02) 可以同时被访问。**因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。\n>\n>```\n>// LockTest1.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest1 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(01) x.isSyncA()与x.isSyncB() \n>    private void test1() {\n>        // 新建t11, t11会调用 x.isSyncA()\n>        Thread t11 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncA();\n>                    }\n>                }, \"t11\");\n>\n>        // 新建t12, t12会调用 x.isSyncB()\n>        Thread t12 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncB();\n>                    }\n>                }, \"t12\");  \n>\n>\n>        t11.start();  // 启动t11\n>        t12.start();  // 启动t12\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest1 demo = new LockTest1();\n>        demo.test1();\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>t21 : isSyncA\n>t22 : isSyncA\n>```\n>\n>**(03) 不能被同时访问。**因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。\n>\n>```\n> // LockTest3.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncA\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncB\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest3 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(03) x.cSyncA()与y.cSyncB()\n>    private void test3() {\n>        // 新建t31, t31会调用 x.isSyncA()\n>        Thread t31 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.cSyncA();\n>                    }\n>                }, \"t31\");\n>\n>        // 新建t32, t32会调用 x.isSyncB()\n>        Thread t32 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        y.cSyncB();\n>                    }\n>                }, \"t32\");  \n>\n>\n>        t31.start();  // 启动t31\n>        t32.start();  // 启动t32\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest3 demo = new LockTest3();\n>\n>        demo.test3();\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t31 : cSyncA\n>t31 : cSyncA\n>t31 : cSyncA\n>t31 : cSyncA\n>t31 : cSyncA\n>t32 : cSyncB\n>t32 : cSyncB\n>t32 : cSyncB\n>t32 : cSyncB\n>t32 : cSyncB \n>```\n>\n>**(04) 可以被同时访问。**因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。\n>\n>```\n>// LockTest4.java的源码\n>class Something {\n>    public synchronized void isSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public synchronized void isSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n>            }\n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncA(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncA\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>    public static synchronized void cSyncB(){\n>        try {  \n>            for (int i = 0; i < 5; i++) {\n>                Thread.sleep(100); // 休眠100ms\n>                System.out.println(Thread.currentThread().getName()+\" : cSyncB\");\n>            } \n>        }catch (InterruptedException ie) {  \n>        }  \n>    }\n>}\n>\n>public class LockTest4 {\n>\n>    Something x = new Something();\n>    Something y = new Something();\n>\n>    // 比较(04) x.isSyncA()与Something.cSyncA()\n>    private void test4() {\n>        // 新建t41, t41会调用 x.isSyncA()\n>        Thread t41 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        x.isSyncA();\n>                    }\n>                }, \"t41\");\n>\n>        // 新建t42, t42会调用 x.isSyncB()\n>        Thread t42 = new Thread(\n>                new Runnable() {\n>                    @Override\n>                    public void run() {\n>                        Something.cSyncA();\n>                    }\n>                }, \"t42\");  \n>\n>\n>        t41.start();  // 启动t41\n>        t42.start();  // 启动t42\n>    }\n>\n>    public static void main(String[] args) {\n>        LockTest4 demo = new LockTest4();\n>\n>        demo.test4();\n>    }\n>}**运行结果**：\n>```\n>\n\n总结：其实你可以将类锁和对象锁相同看待，我这里的相同看待是指，将他们看成俩个不同的对象的形式，其实每个class都有一个监视对象。用来管理类的创建等任务。Synchronized关键字也是锁住了这个监视器对象。所以可以类比着看。","slug":"java多线程系列 02 synchronized 关键字","published":1,"updated":"2019-01-04T01:48:59.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx6i002neb1u0l72mwmo","content":"<h1 id=\"java多线程系列-02-sychronized关键字\"><a href=\"#java多线程系列-02-sychronized关键字\" class=\"headerlink\" title=\"java多线程系列 02 sychronized关键字\"></a>java多线程系列 02 sychronized关键字</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><ol>\n<li>Sychronized 基本用法</li>\n<li>sychronized基本规则</li>\n<li>对象锁和类索</li>\n</ol>\n<h3 id=\"1-sychronized基本用法\"><a href=\"#1-sychronized基本用法\" class=\"headerlink\" title=\"1. sychronized基本用法\"></a>1. sychronized基本用法</h3><p>sychronized主要由俩种用法，一种是用来修饰方法，另外一种是用来修饰代码块。</p>\n<p><strong>synchronized方法示例</strong></p>\n<pre><code class=\"java\">public synchronized void foo1() {\n    System.out.println(&quot;synchronized methoed&quot;);\n}\n</code></pre>\n<p><strong>synchronized代码块</strong></p>\n<pre><code class=\"java\">public void foo2() {\n    synchronized (this) {\n        System.out.println(&quot;synchronized methoed&quot;);\n    }\n}\n</code></pre>\n<p>synchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。</p>\n<p>synchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率(并不是在所有情况下是最好的)。下面通过一个示例来演示：</p>\n<pre><code class=\"Java\">public class Demo4 {\n\n    public synchronized void synMethod() {\n        for (int i = 0; i &lt; 1000000; i++)\n            ;\n    }\n\n    public void synBlock() {\n        synchronized (this) {\n            for (int i = 0; i &lt; 1000000; i++)\n                ;\n        }\n    }\n\n    public static void main(String[] args) {\n        Demo4 demo = new Demo4();\n\n        long start, diff;\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synMethod();                                // 调用“synchronized方法”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(&quot;synMethod() : &quot; + diff);\n\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synBlock();                                // 调用“synchronized方法块”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(&quot;synBlock()  : &quot; + diff);\n    }\n}\n</code></pre>\n<blockquote>\n<p>下面是在我电脑上运行的结果：</p>\n<pre><code>synMethod() : 2\nsynBlock()  : 3\n</code></pre></blockquote>\n<h3 id=\"2-sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。\"><a href=\"#2-sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。\" class=\"headerlink\" title=\"2. sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。\"></a>2. sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。</h3><blockquote>\n<blockquote>\n<h2 id=\"第一条\"><a href=\"#第一条\" class=\"headerlink\" title=\"第一条\"></a>第一条</h2><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 </p>\n<p>下面是“synchronized代码块”对应的演示程序。</p>\n<pre><code class=\"java\">class MyRunable implements Runnable {\n\n   @Override\n   public void run() {\n       //锁住当前线程\n       synchronized (this) {\n           try {\n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() \n                                      + &quot; loop &quot; + i);\n               }\n           } catch (InterruptedException ie) {\n           }\n       }\n   }\n}\n\npublic class Demo1_1 {\n\n   public static void main(String[] args) {\n       // 新建“Runnable对象”\n       Runnable demo = new MyRunable();\n\n       // 新建“线程t1”, t1是基于demo这个Runnable对象\n       Thread t1 = new Thread(demo, &quot;t1&quot;);\n\n       // 新建“线程t2”, t2是基于demo这个Runnable对象\n       Thread t2 = new Thread(demo, &quot;t2&quot;);\n       t1.start();           // 启动“线程t1”\n       t2.start();           // 启动“线程t2”\n   }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>t1 loop 0\nt1 loop 1\nt1 loop 2\nt1 loop 3\nt1 loop 4\nt2 loop 0\nt2 loop 1\nt2 loop 2\nt2 loop 3\nt2 loop 4\n</code></pre><p><strong>结果说明</strong>：<br>run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于”demo这个Runnable对象”创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。</p>\n<p>如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下：</p>\n<pre><code>class MyThread extends Thread {\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() \n                   + &quot; loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }  \n   }\n}\n\npublic class Demo1_2 {\n\n   public static void main(String[] args) {  \n       Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n       Thread t2 = new MyThread(&quot;t2&quot;);  // 新建“线程t2”\n       t1.start();                          // 启动“线程t1”\n       t2.start();                          // 启动“线程t2” \n   } \n}\n</code></pre><p><strong>代码说明</strong>： 比较Demo1_2 和 Demo1_1，我们发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。 幸运的是，在“Demo1_2的run()方法”也调用了synchronized(this)，正如“Demo1_1的run()方法”也调用了synchronized(this)一样！ 那么，Demo1_2的执行流程是不是和Demo1_1一样呢？</p>\n<p>运行结果</p>\n<pre><code>t1 loop 0\nt2 loop 0\nt1 loop 1\nt2 loop 1\nt1 loop 2\nt2 loop 2\nt1 loop 3\nt2 loop 3\nt1 loop 4\nt2 loop 4\n</code></pre><p><strong>结果说明</strong>：<br>如果这个结果一点也不令你感到惊讶，那么我相信你对synchronized和this的认识已经比较深刻了。否则的话，请继续阅读这里的分析。<br>synchronized(this)中的this是指“当前的类对象”，即synchronized(this)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。<br>对于Demo1_2中，synchronized(this)中的this代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行synchronized(this)时，获取的是不同对象的同步锁。对于Demo1_1对而言，synchronized(this)中的this代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。</p>\n<h2 id=\"第二条\"><a href=\"#第二条\" class=\"headerlink\" title=\"第二条\"></a>第二条</h2><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 下面是“synchronized代码块”对应的演示程序:</p>\n<pre><code>class Count {\n\n   // 含有synchronized同步块的方法\n   public void synMethod() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }  \n   }\n\n   // 非同步的方法\n   public void nonSynMethod() {\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100);\n               System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i);  \n           }\n       } catch (InterruptedException ie) {  \n       }\n   }\n}\n\npublic class Demo2 {\n\n   public static void main(String[] args) {  \n       final Count count = new Count();\n       // 新建t1, t1会调用“count对象”的synMethod()方法\n       Thread t1 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.synMethod();\n                   }\n               }, &quot;t1&quot;);\n\n       // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n       Thread t2 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.nonSynMethod();\n                   }\n               }, &quot;t2&quot;);  \n\n\n       t1.start();  // 启动t1\n       t2.start();  // 启动t2\n   } \n}\n</code></pre><p>运行结果：</p>\n<pre><code>t1 synMethod loop 0\nt2 nonSynMethod loop 0\nt1 synMethod loop 1\nt2 nonSynMethod loop 1\nt1 synMethod loop 2\nt2 nonSynMethod loop 2\nt1 synMethod loop 3\nt2 nonSynMethod loop 3\nt1 synMethod loop 4\nt2 nonSynMethod loop 4\n</code></pre><p><strong>结果说明</strong>： 主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。</p>\n<h1 id=\"第三条\"><a href=\"#第三条\" class=\"headerlink\" title=\"第三条\"></a>第三条</h1><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 我们将上面的例子中的nonSynMethod()方法体的也用synchronized(this)修饰。修改后的源码如下：</p>\n<pre><code>class Count {\n\n   // 含有synchronized同步块的方法\n   public void synMethod() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }  \n   }\n\n   // 也包含synchronized同步块的方法\n   public void nonSynMethod() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100);\n                   System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }\n   }\n}\n\npublic class Demo3 {\n\n   public static void main(String[] args) {  \n       final Count count = new Count();\n       // 新建t1, t1会调用“count对象”的synMethod()方法\n       Thread t1 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.synMethod();\n                   }\n               }, &quot;t1&quot;);\n\n       // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n       Thread t2 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.nonSynMethod();\n                   }\n               }, &quot;t2&quot;);  \n\n\n       t1.start();  // 启动t1\n       t2.start();  // 启动t2\n   } \n}\n</code></pre><p>运行结果：</p>\n<pre><code>t1 synMethod loop 0\nt1 synMethod loop 1\nt1 synMethod loop 2\nt1 synMethod loop 3\nt1 synMethod loop 4\nt2 nonSynMethod loop 0\nt2 nonSynMethod loop 1\nt2 nonSynMethod loop 2\nt2 nonSynMethod loop 3\nt2 nonSynMethod loop 4\n</code></pre><p><strong>结果说明</strong>： 主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"3-对象锁和类索\"><a href=\"#3-对象锁和类索\" class=\"headerlink\" title=\"3. 对象锁和类索\"></a>3. 对象锁和类索</h3><blockquote>\n<p><strong>对象锁</strong> – 锁在某一个实例对象上。如果该类是单例，那么该锁也和类锁具有相同的效果。          </p>\n<p><strong>类锁</strong> – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 类锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。</p>\n<p>关于“实例锁”和“全局锁”有一个很形象的例子：</p>\n<pre><code>pulbic class Something {\n   public synchronized void isSyncA(){}\n   public synchronized void isSyncB(){}\n   public static synchronized void cSyncA(){}\n   public static synchronized void cSyncB(){}\n}\n</code></pre><p>假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。<br>(01) x.isSyncA()与x.isSyncB()<br>(02) x.isSyncA()与y.isSyncA()<br>(03) x.cSyncA()与y.cSyncB()<br>(04) x.isSyncA()与Something.cSyncA()</p>\n<p><strong>(01) 不能被同时访问。</strong>因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！</p>\n<pre><code>// LockTest1.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest1 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(01) x.isSyncA()与x.isSyncB() \n   private void test1() {\n       // 新建t11, t11会调用 x.isSyncA()\n       Thread t11 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncA();\n                   }\n               }, &quot;t11&quot;);\n\n       // 新建t12, t12会调用 x.isSyncB()\n       Thread t12 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncB();\n                   }\n               }, &quot;t12&quot;);  \n\n\n       t11.start();  // 启动t11\n       t12.start();  // 启动t12\n   }\n\n   public static void main(String[] args) {\n       LockTest1 demo = new LockTest1();\n       demo.test1();\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\n</code></pre><p><strong>(02) 可以同时被访问。</strong>因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。</p>\n<pre><code>// LockTest1.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest1 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(01) x.isSyncA()与x.isSyncB() \n   private void test1() {\n       // 新建t11, t11会调用 x.isSyncA()\n       Thread t11 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncA();\n                   }\n               }, &quot;t11&quot;);\n\n       // 新建t12, t12会调用 x.isSyncB()\n       Thread t12 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncB();\n                   }\n               }, &quot;t12&quot;);  \n\n\n       t11.start();  // 启动t11\n       t12.start();  // 启动t12\n   }\n\n   public static void main(String[] args) {\n       LockTest1 demo = new LockTest1();\n       demo.test1();\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\n</code></pre><p><strong>(03) 不能被同时访问。</strong>因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。</p>\n<pre><code>// LockTest3.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest3 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(03) x.cSyncA()与y.cSyncB()\n   private void test3() {\n       // 新建t31, t31会调用 x.isSyncA()\n       Thread t31 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.cSyncA();\n                   }\n               }, &quot;t31&quot;);\n\n       // 新建t32, t32会调用 x.isSyncB()\n       Thread t32 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       y.cSyncB();\n                   }\n               }, &quot;t32&quot;);  \n\n\n       t31.start();  // 启动t31\n       t32.start();  // 启动t32\n   }\n\n   public static void main(String[] args) {\n       LockTest3 demo = new LockTest3();\n\n       demo.test3();\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB \n</code></pre><p><strong>(04) 可以被同时访问。</strong>因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。</p>\n<pre><code>// LockTest4.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest4 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(04) x.isSyncA()与Something.cSyncA()\n   private void test4() {\n       // 新建t41, t41会调用 x.isSyncA()\n       Thread t41 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncA();\n                   }\n               }, &quot;t41&quot;);\n\n       // 新建t42, t42会调用 x.isSyncB()\n       Thread t42 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       Something.cSyncA();\n                   }\n               }, &quot;t42&quot;);  \n\n\n       t41.start();  // 启动t41\n       t42.start();  // 启动t42\n   }\n\n   public static void main(String[] args) {\n       LockTest4 demo = new LockTest4();\n\n       demo.test4();\n   }\n}**运行结果**：\n</code></pre></blockquote>\n<p>总结：其实你可以将类锁和对象锁相同看待，我这里的相同看待是指，将他们看成俩个不同的对象的形式，其实每个class都有一个监视对象。用来管理类的创建等任务。Synchronized关键字也是锁住了这个监视器对象。所以可以类比着看。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-02-sychronized关键字\"><a href=\"#java多线程系列-02-sychronized关键字\" class=\"headerlink\" title=\"java多线程系列 02 sychronized关键字\"></a>java多线程系列 02 sychronized关键字</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><ol>\n<li>Sychronized 基本用法</li>\n<li>sychronized基本规则</li>\n<li>对象锁和类索</li>\n</ol>\n<h3 id=\"1-sychronized基本用法\"><a href=\"#1-sychronized基本用法\" class=\"headerlink\" title=\"1. sychronized基本用法\"></a>1. sychronized基本用法</h3><p>sychronized主要由俩种用法，一种是用来修饰方法，另外一种是用来修饰代码块。</p>\n<p><strong>synchronized方法示例</strong></p>\n<pre><code class=\"java\">public synchronized void foo1() {\n    System.out.println(&quot;synchronized methoed&quot;);\n}\n</code></pre>\n<p><strong>synchronized代码块</strong></p>\n<pre><code class=\"java\">public void foo2() {\n    synchronized (this) {\n        System.out.println(&quot;synchronized methoed&quot;);\n    }\n}\n</code></pre>\n<p>synchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。</p>\n<p>synchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率(并不是在所有情况下是最好的)。下面通过一个示例来演示：</p>\n<pre><code class=\"Java\">public class Demo4 {\n\n    public synchronized void synMethod() {\n        for (int i = 0; i &lt; 1000000; i++)\n            ;\n    }\n\n    public void synBlock() {\n        synchronized (this) {\n            for (int i = 0; i &lt; 1000000; i++)\n                ;\n        }\n    }\n\n    public static void main(String[] args) {\n        Demo4 demo = new Demo4();\n\n        long start, diff;\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synMethod();                                // 调用“synchronized方法”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(&quot;synMethod() : &quot; + diff);\n\n        start = System.currentTimeMillis();                // 获取当前时间(millis)\n        demo.synBlock();                                // 调用“synchronized方法块”\n        diff = System.currentTimeMillis() - start;        // 获取“时间差值”\n        System.out.println(&quot;synBlock()  : &quot; + diff);\n    }\n}\n</code></pre>\n<blockquote>\n<p>下面是在我电脑上运行的结果：</p>\n<pre><code>synMethod() : 2\nsynBlock()  : 3\n</code></pre></blockquote>\n<h3 id=\"2-sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。\"><a href=\"#2-sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。\" class=\"headerlink\" title=\"2. sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。\"></a>2. sychronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。</h3><blockquote>\n<blockquote>\n<h2 id=\"第一条\"><a href=\"#第一条\" class=\"headerlink\" title=\"第一条\"></a>第一条</h2><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 </p>\n<p>下面是“synchronized代码块”对应的演示程序。</p>\n<pre><code class=\"java\">class MyRunable implements Runnable {\n\n   @Override\n   public void run() {\n       //锁住当前线程\n       synchronized (this) {\n           try {\n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() \n                                      + &quot; loop &quot; + i);\n               }\n           } catch (InterruptedException ie) {\n           }\n       }\n   }\n}\n\npublic class Demo1_1 {\n\n   public static void main(String[] args) {\n       // 新建“Runnable对象”\n       Runnable demo = new MyRunable();\n\n       // 新建“线程t1”, t1是基于demo这个Runnable对象\n       Thread t1 = new Thread(demo, &quot;t1&quot;);\n\n       // 新建“线程t2”, t2是基于demo这个Runnable对象\n       Thread t2 = new Thread(demo, &quot;t2&quot;);\n       t1.start();           // 启动“线程t1”\n       t2.start();           // 启动“线程t2”\n   }\n}\n</code></pre>\n<p>运行结果</p>\n<pre><code>t1 loop 0\nt1 loop 1\nt1 loop 2\nt1 loop 3\nt1 loop 4\nt2 loop 0\nt2 loop 1\nt2 loop 2\nt2 loop 3\nt2 loop 4\n</code></pre><p><strong>结果说明</strong>：<br>run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于”demo这个Runnable对象”创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。</p>\n<p>如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下：</p>\n<pre><code>class MyThread extends Thread {\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() \n                   + &quot; loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }  \n   }\n}\n\npublic class Demo1_2 {\n\n   public static void main(String[] args) {  \n       Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n       Thread t2 = new MyThread(&quot;t2&quot;);  // 新建“线程t2”\n       t1.start();                          // 启动“线程t1”\n       t2.start();                          // 启动“线程t2” \n   } \n}\n</code></pre><p><strong>代码说明</strong>： 比较Demo1_2 和 Demo1_1，我们发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。 幸运的是，在“Demo1_2的run()方法”也调用了synchronized(this)，正如“Demo1_1的run()方法”也调用了synchronized(this)一样！ 那么，Demo1_2的执行流程是不是和Demo1_1一样呢？</p>\n<p>运行结果</p>\n<pre><code>t1 loop 0\nt2 loop 0\nt1 loop 1\nt2 loop 1\nt1 loop 2\nt2 loop 2\nt1 loop 3\nt2 loop 3\nt1 loop 4\nt2 loop 4\n</code></pre><p><strong>结果说明</strong>：<br>如果这个结果一点也不令你感到惊讶，那么我相信你对synchronized和this的认识已经比较深刻了。否则的话，请继续阅读这里的分析。<br>synchronized(this)中的this是指“当前的类对象”，即synchronized(this)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。<br>对于Demo1_2中，synchronized(this)中的this代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行synchronized(this)时，获取的是不同对象的同步锁。对于Demo1_1对而言，synchronized(this)中的this代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。</p>\n<h2 id=\"第二条\"><a href=\"#第二条\" class=\"headerlink\" title=\"第二条\"></a>第二条</h2><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 下面是“synchronized代码块”对应的演示程序:</p>\n<pre><code>class Count {\n\n   // 含有synchronized同步块的方法\n   public void synMethod() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }  \n   }\n\n   // 非同步的方法\n   public void nonSynMethod() {\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100);\n               System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i);  \n           }\n       } catch (InterruptedException ie) {  \n       }\n   }\n}\n\npublic class Demo2 {\n\n   public static void main(String[] args) {  \n       final Count count = new Count();\n       // 新建t1, t1会调用“count对象”的synMethod()方法\n       Thread t1 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.synMethod();\n                   }\n               }, &quot;t1&quot;);\n\n       // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n       Thread t2 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.nonSynMethod();\n                   }\n               }, &quot;t2&quot;);  \n\n\n       t1.start();  // 启动t1\n       t2.start();  // 启动t2\n   } \n}\n</code></pre><p>运行结果：</p>\n<pre><code>t1 synMethod loop 0\nt2 nonSynMethod loop 0\nt1 synMethod loop 1\nt2 nonSynMethod loop 1\nt1 synMethod loop 2\nt2 nonSynMethod loop 2\nt1 synMethod loop 3\nt2 nonSynMethod loop 3\nt1 synMethod loop 4\nt2 nonSynMethod loop 4\n</code></pre><p><strong>结果说明</strong>： 主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。</p>\n<h1 id=\"第三条\"><a href=\"#第三条\" class=\"headerlink\" title=\"第三条\"></a>第三条</h1><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 我们将上面的例子中的nonSynMethod()方法体的也用synchronized(this)修饰。修改后的源码如下：</p>\n<pre><code>class Count {\n\n   // 含有synchronized同步块的方法\n   public void synMethod() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100); // 休眠100ms\n                   System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }  \n   }\n\n   // 也包含synchronized同步块的方法\n   public void nonSynMethod() {\n       synchronized(this) {\n           try {  \n               for (int i = 0; i &lt; 5; i++) {\n                   Thread.sleep(100);\n                   System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n           }\n       }\n   }\n}\n\npublic class Demo3 {\n\n   public static void main(String[] args) {  \n       final Count count = new Count();\n       // 新建t1, t1会调用“count对象”的synMethod()方法\n       Thread t1 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.synMethod();\n                   }\n               }, &quot;t1&quot;);\n\n       // 新建t2, t2会调用“count对象”的nonSynMethod()方法\n       Thread t2 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       count.nonSynMethod();\n                   }\n               }, &quot;t2&quot;);  \n\n\n       t1.start();  // 启动t1\n       t2.start();  // 启动t2\n   } \n}\n</code></pre><p>运行结果：</p>\n<pre><code>t1 synMethod loop 0\nt1 synMethod loop 1\nt1 synMethod loop 2\nt1 synMethod loop 3\nt1 synMethod loop 4\nt2 nonSynMethod loop 0\nt2 nonSynMethod loop 1\nt2 nonSynMethod loop 2\nt2 nonSynMethod loop 3\nt2 nonSynMethod loop 4\n</code></pre><p><strong>结果说明</strong>： 主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"3-对象锁和类索\"><a href=\"#3-对象锁和类索\" class=\"headerlink\" title=\"3. 对象锁和类索\"></a>3. 对象锁和类索</h3><blockquote>\n<p><strong>对象锁</strong> – 锁在某一个实例对象上。如果该类是单例，那么该锁也和类锁具有相同的效果。          </p>\n<p><strong>类锁</strong> – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 类锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。</p>\n<p>关于“实例锁”和“全局锁”有一个很形象的例子：</p>\n<pre><code>pulbic class Something {\n   public synchronized void isSyncA(){}\n   public synchronized void isSyncB(){}\n   public static synchronized void cSyncA(){}\n   public static synchronized void cSyncB(){}\n}\n</code></pre><p>假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。<br>(01) x.isSyncA()与x.isSyncB()<br>(02) x.isSyncA()与y.isSyncA()<br>(03) x.cSyncA()与y.cSyncB()<br>(04) x.isSyncA()与Something.cSyncA()</p>\n<p><strong>(01) 不能被同时访问。</strong>因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！</p>\n<pre><code>// LockTest1.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest1 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(01) x.isSyncA()与x.isSyncB() \n   private void test1() {\n       // 新建t11, t11会调用 x.isSyncA()\n       Thread t11 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncA();\n                   }\n               }, &quot;t11&quot;);\n\n       // 新建t12, t12会调用 x.isSyncB()\n       Thread t12 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncB();\n                   }\n               }, &quot;t12&quot;);  \n\n\n       t11.start();  // 启动t11\n       t12.start();  // 启动t12\n   }\n\n   public static void main(String[] args) {\n       LockTest1 demo = new LockTest1();\n       demo.test1();\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\n</code></pre><p><strong>(02) 可以同时被访问。</strong>因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。</p>\n<pre><code>// LockTest1.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest1 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(01) x.isSyncA()与x.isSyncB() \n   private void test1() {\n       // 新建t11, t11会调用 x.isSyncA()\n       Thread t11 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncA();\n                   }\n               }, &quot;t11&quot;);\n\n       // 新建t12, t12会调用 x.isSyncB()\n       Thread t12 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncB();\n                   }\n               }, &quot;t12&quot;);  \n\n\n       t11.start();  // 启动t11\n       t12.start();  // 启动t12\n   }\n\n   public static void main(String[] args) {\n       LockTest1 demo = new LockTest1();\n       demo.test1();\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\n</code></pre><p><strong>(03) 不能被同时访问。</strong>因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。</p>\n<pre><code>// LockTest3.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest3 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(03) x.cSyncA()与y.cSyncB()\n   private void test3() {\n       // 新建t31, t31会调用 x.isSyncA()\n       Thread t31 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.cSyncA();\n                   }\n               }, &quot;t31&quot;);\n\n       // 新建t32, t32会调用 x.isSyncB()\n       Thread t32 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       y.cSyncB();\n                   }\n               }, &quot;t32&quot;);  \n\n\n       t31.start();  // 启动t31\n       t32.start();  // 启动t32\n   }\n\n   public static void main(String[] args) {\n       LockTest3 demo = new LockTest3();\n\n       demo.test3();\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB \n</code></pre><p><strong>(04) 可以被同时访问。</strong>因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。</p>\n<pre><code>// LockTest4.java的源码\nclass Something {\n   public synchronized void isSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public synchronized void isSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);\n           }\n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncA(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n   public static synchronized void cSyncB(){\n       try {  \n           for (int i = 0; i &lt; 5; i++) {\n               Thread.sleep(100); // 休眠100ms\n               System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;);\n           } \n       }catch (InterruptedException ie) {  \n       }  \n   }\n}\n\npublic class LockTest4 {\n\n   Something x = new Something();\n   Something y = new Something();\n\n   // 比较(04) x.isSyncA()与Something.cSyncA()\n   private void test4() {\n       // 新建t41, t41会调用 x.isSyncA()\n       Thread t41 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       x.isSyncA();\n                   }\n               }, &quot;t41&quot;);\n\n       // 新建t42, t42会调用 x.isSyncB()\n       Thread t42 = new Thread(\n               new Runnable() {\n                   @Override\n                   public void run() {\n                       Something.cSyncA();\n                   }\n               }, &quot;t42&quot;);  \n\n\n       t41.start();  // 启动t41\n       t42.start();  // 启动t42\n   }\n\n   public static void main(String[] args) {\n       LockTest4 demo = new LockTest4();\n\n       demo.test4();\n   }\n}**运行结果**：\n</code></pre></blockquote>\n<p>总结：其实你可以将类锁和对象锁相同看待，我这里的相同看待是指，将他们看成俩个不同的对象的形式，其实每个class都有一个监视对象。用来管理类的创建等任务。Synchronized关键字也是锁住了这个监视器对象。所以可以类比着看。</p>\n"},{"abbrlink":5,"title":" java多线程系列 03 线程等待与唤醒，线程休眠","author":"zhangke","date":"2018-07-13T03:08:00.000Z","_content":"# java多线程系列 03 线程等待与唤醒，线程休眠\n\n### 概要\n\n>1. wait(), notify(), notifyAll()等方法介绍\n>2. wait()和notify()示例\n>3. wait(long timeout)和notify()示例\n>4. wait() 和 notifyAll()\n>5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中\n>6. sleep()介绍与使用\n>7. sleep() 与 wait()的比较\n\n### 1. wait(), notify(), notifyAll()等方法介绍\n\n>在Object类中，定义了wait(), notify()和notifyAll()等接口。\n>\n>wait()的作用是让当前线程进入等待状态，**同时，wait()也会让当前线程释放它所持有的锁。**而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。\n>\n>Object类中关于等待/唤醒的API详细信息如下：\n>**notify()**        -- 唤醒在此对象监视器上等待的单个线程。\n>**notifyAll()**   -- 唤醒在此对象监视器上等待的所有线程。\n>**wait()**           -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。\n>**wait(long timeout)**   -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。\n>**wait(long timeout, int nanos)**  -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。\n\n### 2. wait()和notify()示例\n\n>代码如下:\n>\n>```java\n>class ThreadA extends Thread {\n>\n>    public ThreadA(String name) {\n>        super(name);\n>    }\n>\n>    public void run() {\n>        synchronized (this) {\n>            System.out.println(Thread.currentThread().getName() \n>                               \t\t+ \" call notify()\");\n>            // 唤醒当前的wait线程\n>            notify();\n>        }\n>    }\n>}\n>\n>public class WaitTest {\n>\n>    public static void main(String[] args) {\n>\n>        ThreadA t1 = new ThreadA(\"t1\");\n>        synchronized (t1) {\n>            try {\n>                // 启动“线程t1”\n>                System.out.println(Thread.currentThread().getName() + \" start t1\");\n>                t1.start();\n>\n>                // 主线程等待t1通过notify()唤醒。\n>                System.out.println(Thread.currentThread().getName() + \" wait()\");\n>                t1.wait();\n>\n>                System.out.println(Thread.currentThread().getName() + \" continue\");\n>            } catch (InterruptedException e) {\n>                e.printStackTrace();\n>            }\n>        }\n>    }\n>}\n>```\n>\n>**运行结果**:\n>\n>```\n>main start t1\n>main wait()\n>t1 call notify()\n>main continue\n>```\n>\n>**结果说明**：\n>如下图，说明了“主线程”和“线程t1”的流程。\n>\n>(01) 注意，图中\"主线程\" 代表“主线程main”。\"线程t1\" 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。\n>(02) “主线程”通过 new ThreadA(\"t1\") 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。\n>(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。\n>(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。\n>(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。\n>\n>![img](https://images0.cnblogs.com/blog/497634/201312/18183712-f04899f92aaa43b6a33a85fecfa60a9d.png)\n>\n>对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？\n>在解答该问题前，我们先看看jdk文档中关于wait的一段介绍：\n>\n>```\n>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. \n>In other words, this method behaves exactly as if it simply performs the call wait(0).\n>The current thread must own this object's monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object's monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.\n>```\n>\n>中文意思大概是：\n>\n>```\n>引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。\n>```\n>\n>注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！\n>这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！\n\n### **3. wait(long timeout)和notify()**\n\n>wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 \n>\n>下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。\n>\n>```\n>// WaitTimeoutTest.java的源码\n>class ThreadA extends Thread{\n>\n>    public ThreadA(String name) {\n>        super(name);\n>    }\n>\n>    public void run() {\n>        System.out.println(Thread.currentThread().getName() + \" run \");\n>        // 死循环，不断运行。\n>        while(true)\n>            ;\n>    }\n>}\n>\n>public class WaitTimeoutTest {\n>\n>    public static void main(String[] args) {\n>\n>        ThreadA t1 = new ThreadA(\"t1\");\n>\n>        synchronized(t1) {\n>            try {\n>                // 启动“线程t1”\n>                System.out.println(Thread.currentThread().getName() + \" start t1\");\n>                t1.start();\n>\n>       // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。\n>         System.out.println(Thread.currentThread().getName() + \" call wait \");\n>                t1.wait(3000);\n>\n>                System.out.println(Thread.currentThread().getName() + \" continue\");\n>            } catch (InterruptedException e) {\n>                e.printStackTrace();\n>            }\n>        }\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>main start t1\n>main call wait \n>t1 run                  // 大约3秒之后...输出“main continue”\n>main continue\n>```\n>\n>**结果说明**：\n>如下图，说明了“主线程”和“线程t1”的流程。\n>(01) 注意，图中\"主线程\" 代表WaitTimeoutTest主线程(即，线程main)。\"线程t1\" 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。\n>(02) 主线程main执行t1.start()启动“线程t1”。\n>(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。\n>(04) “线程t1”运行之后，进入了死循环，一直不断的运行。\n>(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。\n>\n>![img](https://images0.cnblogs.com/blog/497634/201312/18183848-d4c16bf2760847afa4fede6a9d959083.png)\n\n### **4. wait() 和 notifyAll()**\n\n>通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。\n>\n>下面，我们通过示例演示notifyAll()的用法；它的作用是唤醒在此对象监视器上等待的所有线程。\n>\n>```\n>public class NotifyAllTest {\n>\n>    private static Object obj = new Object();\n>\n>    public static void main(String[] args) {\n>\n>        ThreadA t1 = new ThreadA(\"t1\");\n>        ThreadA t2 = new ThreadA(\"t2\");\n>        ThreadA t3 = new ThreadA(\"t3\");\n>        t1.start();\n>        t2.start();\n>        t3.start();\n>\n>        try {\n>            System.out.println(Thread.currentThread().getName() + \" sleep(3000)\");\n>            Thread.sleep(3000);\n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>\n>        synchronized (obj) {\n>            // 主线程等待唤醒。\n>            System.out.println(Thread.currentThread().getName() + \" notifyAll()\");\n>            obj.notifyAll();\n>        }\n>    }\n>\n>    static class ThreadA extends Thread {\n>\n>        public ThreadA(String name) {\n>            super(name);\n>        }\n>\n>        public void run() {\n>            synchronized (obj) {\n>                try {\n>                    // 打印输出结果\n>                    System.out.println(Thread.currentThread().getName() + \" wait\");\n>\n>                    // 唤醒当前的wait线程\n>                    obj.wait();\n>\n>                    // 打印输出结果\n>                    System.out.println(Thread.currentThread().getName() \n>                    \t\t+ \" continue\");\n>                } catch (InterruptedException e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        }\n>    }\n>}\n>```\n>\n>运行结果\n>\n>```\n>t1 wait\n>main sleep(3000)\n>t3 wait\n>t2 wait\n>main notifyAll()\n>t2 continue\n>t3 continue\n>t1 continue\n>```\n>\n>**结果说明**：\n>参考下面的流程图。 \n>(01) 主线程中新建并且启动了3个线程\"t1\", \"t2\"和\"t3\"。\n>(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设\"t1\", \"t2\"和\"t3\"这3个线程都运行了。以\"t1\"为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，\"t2\"和\"t3\"也会等待其它线程通过nofity()或nofityAll()来唤醒它们。\n>(03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒\"t1\", \"t2\"和\"t3\"这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，\"t1\", \"t2\"和\"t3\"就可以获取“obj锁”而继续运行了！\n>\n>![img](https://images0.cnblogs.com/blog/497634/201312/18183923-95275c066212410f96181704a681f453.png)\n>\n>**需要注意的一点是：notifyAll会唤醒所有等待获取此对象的线程，他们会彼此竞争，但是他们已经退出了等待，但是由于同步锁的原因，因此同一时刻只会有一个线程获取到锁，所以也只有一个线程会运行，但最终所有的线程都是依次获取到锁，接着运行**\n\n### **5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中**\n\n>Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。\n>\n>wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！\n>OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。\n>\n>负责唤醒等待线程的那个线程(我们称为“**唤醒线程**”)，它只有在获取“该对象的同步锁”(**这里的同步锁必须和等待线程的同步锁是同一个**)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。\n>\n>总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。\n\n### 6. sleep()介绍与使用\n\n>sleep() 定义在Thread.java中。 sleep() 的作用是让当前线程休眠，即当前线程会从**运行状态**进入到**休眠(阻塞)状态**。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由**阻塞状态**变成**就绪状态**，从而等待cpu的调度执行。\n>\n>下面是一个简单的demo\n>\n>```\n>// SleepTest.java的源码\n>class ThreadA extends Thread{\n>    public ThreadA(String name){ \n>        super(name); \n>    } \n>    public synchronized void run() { \n>        try {\n>            for(int i=0; i <10; i++){ \n>                System.out.printf(\"%s: %d\\n\", this.getName(), i); \n>                // i能被4整除时，休眠100毫秒\n>                if (i%4 == 0)\n>                    Thread.sleep(100);\n>            } \n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>    } \n>} \n>\n>public class SleepTest{ \n>    public static void main(String[] args){ \n>        ThreadA t1 = new ThreadA(\"t1\"); \n>        t1.start(); \n>    } \n>}\n>```\n>\n>运行结果:\n>\n>```\n>t1: 0\n>t1: 1\n>t1: 2\n>t1: 3\n>t1: 4\n>t1: 5\n>t1: 6\n>t1: 7\n>t1: 8\n>t1: 9\n>```\n>\n>**结果说明**： 程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(100)休眠100毫秒。\n>\n>\n\n### **7. sleep() 与 wait()的比较**\n\n>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。 但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。\n>\n>\u0010 下面通过示例演示sleep()是不会释放锁的。\n>\n>```\n>public class SleepLockTest {\n>\n>    private static Object obj = new Object();\n>\n>    public static void main(String[] args) {\n>        ThreadA t1 = new ThreadA(\"t1\");\n>        ThreadA t2 = new ThreadA(\"t2\");\n>        t1.start();\n>        t2.start();\n>    }\n>\n>    static class ThreadA extends Thread {\n>        public ThreadA(String name) {\n>            super(name);\n>        }\n>\n>        public void run() {\n>            // 获取obj对象的同步锁\n>            synchronized (obj) {\n>                try {\n>                    for (int i = 0; i < 10; i++) {\n>                        System.out.printf(\"%s: %d\\n\", this.getName(), i);\n>                        // i能被4整除时，休眠100毫秒\n>                        if (i % 4 == 0)\n>                            Thread.sleep(100);\n>                    }\n>                } catch (InterruptedException e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        }\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1: 0\n>t1: 1\n>t1: 2\n>t1: 3\n>t1: 4\n>t1: 5\n>t1: 6\n>t1: 7\n>t1: 8\n>t1: 9\n>t2: 0\n>t2: 1\n>t2: 2\n>t2: 3\n>t2: 4\n>t2: 5\n>t2: 6\n>t2: 7\n>t2: 8\n>t2: 9\n>```\n>\n>**结果说明**： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.sleep(100)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！ 注意，若我们注释掉synchronized (obj)后再次执行该程序，t1和t2是可以相互切换的。","source":"_posts/java多线程系列 03 线程等待与唤醒，线程休眠.md","raw":"abbrlink: 5\ntitle: ' java多线程系列 03 线程等待与唤醒，线程休眠'\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-13 11:08:00\n---\n# java多线程系列 03 线程等待与唤醒，线程休眠\n\n### 概要\n\n>1. wait(), notify(), notifyAll()等方法介绍\n>2. wait()和notify()示例\n>3. wait(long timeout)和notify()示例\n>4. wait() 和 notifyAll()\n>5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中\n>6. sleep()介绍与使用\n>7. sleep() 与 wait()的比较\n\n### 1. wait(), notify(), notifyAll()等方法介绍\n\n>在Object类中，定义了wait(), notify()和notifyAll()等接口。\n>\n>wait()的作用是让当前线程进入等待状态，**同时，wait()也会让当前线程释放它所持有的锁。**而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。\n>\n>Object类中关于等待/唤醒的API详细信息如下：\n>**notify()**        -- 唤醒在此对象监视器上等待的单个线程。\n>**notifyAll()**   -- 唤醒在此对象监视器上等待的所有线程。\n>**wait()**           -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。\n>**wait(long timeout)**   -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。\n>**wait(long timeout, int nanos)**  -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。\n\n### 2. wait()和notify()示例\n\n>代码如下:\n>\n>```java\n>class ThreadA extends Thread {\n>\n>    public ThreadA(String name) {\n>        super(name);\n>    }\n>\n>    public void run() {\n>        synchronized (this) {\n>            System.out.println(Thread.currentThread().getName() \n>                               \t\t+ \" call notify()\");\n>            // 唤醒当前的wait线程\n>            notify();\n>        }\n>    }\n>}\n>\n>public class WaitTest {\n>\n>    public static void main(String[] args) {\n>\n>        ThreadA t1 = new ThreadA(\"t1\");\n>        synchronized (t1) {\n>            try {\n>                // 启动“线程t1”\n>                System.out.println(Thread.currentThread().getName() + \" start t1\");\n>                t1.start();\n>\n>                // 主线程等待t1通过notify()唤醒。\n>                System.out.println(Thread.currentThread().getName() + \" wait()\");\n>                t1.wait();\n>\n>                System.out.println(Thread.currentThread().getName() + \" continue\");\n>            } catch (InterruptedException e) {\n>                e.printStackTrace();\n>            }\n>        }\n>    }\n>}\n>```\n>\n>**运行结果**:\n>\n>```\n>main start t1\n>main wait()\n>t1 call notify()\n>main continue\n>```\n>\n>**结果说明**：\n>如下图，说明了“主线程”和“线程t1”的流程。\n>\n>(01) 注意，图中\"主线程\" 代表“主线程main”。\"线程t1\" 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。\n>(02) “主线程”通过 new ThreadA(\"t1\") 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。\n>(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。\n>(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。\n>(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。\n>\n>![img](https://images0.cnblogs.com/blog/497634/201312/18183712-f04899f92aaa43b6a33a85fecfa60a9d.png)\n>\n>对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？\n>在解答该问题前，我们先看看jdk文档中关于wait的一段介绍：\n>\n>```\n>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. \n>In other words, this method behaves exactly as if it simply performs the call wait(0).\n>The current thread must own this object's monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object's monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.\n>```\n>\n>中文意思大概是：\n>\n>```\n>引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。\n>```\n>\n>注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！\n>这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！\n\n### **3. wait(long timeout)和notify()**\n\n>wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 \n>\n>下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。\n>\n>```\n>// WaitTimeoutTest.java的源码\n>class ThreadA extends Thread{\n>\n>    public ThreadA(String name) {\n>        super(name);\n>    }\n>\n>    public void run() {\n>        System.out.println(Thread.currentThread().getName() + \" run \");\n>        // 死循环，不断运行。\n>        while(true)\n>            ;\n>    }\n>}\n>\n>public class WaitTimeoutTest {\n>\n>    public static void main(String[] args) {\n>\n>        ThreadA t1 = new ThreadA(\"t1\");\n>\n>        synchronized(t1) {\n>            try {\n>                // 启动“线程t1”\n>                System.out.println(Thread.currentThread().getName() + \" start t1\");\n>                t1.start();\n>\n>       // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。\n>         System.out.println(Thread.currentThread().getName() + \" call wait \");\n>                t1.wait(3000);\n>\n>                System.out.println(Thread.currentThread().getName() + \" continue\");\n>            } catch (InterruptedException e) {\n>                e.printStackTrace();\n>            }\n>        }\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>main start t1\n>main call wait \n>t1 run                  // 大约3秒之后...输出“main continue”\n>main continue\n>```\n>\n>**结果说明**：\n>如下图，说明了“主线程”和“线程t1”的流程。\n>(01) 注意，图中\"主线程\" 代表WaitTimeoutTest主线程(即，线程main)。\"线程t1\" 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。\n>(02) 主线程main执行t1.start()启动“线程t1”。\n>(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。\n>(04) “线程t1”运行之后，进入了死循环，一直不断的运行。\n>(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。\n>\n>![img](https://images0.cnblogs.com/blog/497634/201312/18183848-d4c16bf2760847afa4fede6a9d959083.png)\n\n### **4. wait() 和 notifyAll()**\n\n>通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。\n>\n>下面，我们通过示例演示notifyAll()的用法；它的作用是唤醒在此对象监视器上等待的所有线程。\n>\n>```\n>public class NotifyAllTest {\n>\n>    private static Object obj = new Object();\n>\n>    public static void main(String[] args) {\n>\n>        ThreadA t1 = new ThreadA(\"t1\");\n>        ThreadA t2 = new ThreadA(\"t2\");\n>        ThreadA t3 = new ThreadA(\"t3\");\n>        t1.start();\n>        t2.start();\n>        t3.start();\n>\n>        try {\n>            System.out.println(Thread.currentThread().getName() + \" sleep(3000)\");\n>            Thread.sleep(3000);\n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>\n>        synchronized (obj) {\n>            // 主线程等待唤醒。\n>            System.out.println(Thread.currentThread().getName() + \" notifyAll()\");\n>            obj.notifyAll();\n>        }\n>    }\n>\n>    static class ThreadA extends Thread {\n>\n>        public ThreadA(String name) {\n>            super(name);\n>        }\n>\n>        public void run() {\n>            synchronized (obj) {\n>                try {\n>                    // 打印输出结果\n>                    System.out.println(Thread.currentThread().getName() + \" wait\");\n>\n>                    // 唤醒当前的wait线程\n>                    obj.wait();\n>\n>                    // 打印输出结果\n>                    System.out.println(Thread.currentThread().getName() \n>                    \t\t+ \" continue\");\n>                } catch (InterruptedException e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        }\n>    }\n>}\n>```\n>\n>运行结果\n>\n>```\n>t1 wait\n>main sleep(3000)\n>t3 wait\n>t2 wait\n>main notifyAll()\n>t2 continue\n>t3 continue\n>t1 continue\n>```\n>\n>**结果说明**：\n>参考下面的流程图。 \n>(01) 主线程中新建并且启动了3个线程\"t1\", \"t2\"和\"t3\"。\n>(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设\"t1\", \"t2\"和\"t3\"这3个线程都运行了。以\"t1\"为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，\"t2\"和\"t3\"也会等待其它线程通过nofity()或nofityAll()来唤醒它们。\n>(03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒\"t1\", \"t2\"和\"t3\"这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，\"t1\", \"t2\"和\"t3\"就可以获取“obj锁”而继续运行了！\n>\n>![img](https://images0.cnblogs.com/blog/497634/201312/18183923-95275c066212410f96181704a681f453.png)\n>\n>**需要注意的一点是：notifyAll会唤醒所有等待获取此对象的线程，他们会彼此竞争，但是他们已经退出了等待，但是由于同步锁的原因，因此同一时刻只会有一个线程获取到锁，所以也只有一个线程会运行，但最终所有的线程都是依次获取到锁，接着运行**\n\n### **5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中**\n\n>Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。\n>\n>wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！\n>OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。\n>\n>负责唤醒等待线程的那个线程(我们称为“**唤醒线程**”)，它只有在获取“该对象的同步锁”(**这里的同步锁必须和等待线程的同步锁是同一个**)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。\n>\n>总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。\n\n### 6. sleep()介绍与使用\n\n>sleep() 定义在Thread.java中。 sleep() 的作用是让当前线程休眠，即当前线程会从**运行状态**进入到**休眠(阻塞)状态**。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由**阻塞状态**变成**就绪状态**，从而等待cpu的调度执行。\n>\n>下面是一个简单的demo\n>\n>```\n>// SleepTest.java的源码\n>class ThreadA extends Thread{\n>    public ThreadA(String name){ \n>        super(name); \n>    } \n>    public synchronized void run() { \n>        try {\n>            for(int i=0; i <10; i++){ \n>                System.out.printf(\"%s: %d\\n\", this.getName(), i); \n>                // i能被4整除时，休眠100毫秒\n>                if (i%4 == 0)\n>                    Thread.sleep(100);\n>            } \n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>    } \n>} \n>\n>public class SleepTest{ \n>    public static void main(String[] args){ \n>        ThreadA t1 = new ThreadA(\"t1\"); \n>        t1.start(); \n>    } \n>}\n>```\n>\n>运行结果:\n>\n>```\n>t1: 0\n>t1: 1\n>t1: 2\n>t1: 3\n>t1: 4\n>t1: 5\n>t1: 6\n>t1: 7\n>t1: 8\n>t1: 9\n>```\n>\n>**结果说明**： 程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(100)休眠100毫秒。\n>\n>\n\n### **7. sleep() 与 wait()的比较**\n\n>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。 但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。\n>\n>\u0010 下面通过示例演示sleep()是不会释放锁的。\n>\n>```\n>public class SleepLockTest {\n>\n>    private static Object obj = new Object();\n>\n>    public static void main(String[] args) {\n>        ThreadA t1 = new ThreadA(\"t1\");\n>        ThreadA t2 = new ThreadA(\"t2\");\n>        t1.start();\n>        t2.start();\n>    }\n>\n>    static class ThreadA extends Thread {\n>        public ThreadA(String name) {\n>            super(name);\n>        }\n>\n>        public void run() {\n>            // 获取obj对象的同步锁\n>            synchronized (obj) {\n>                try {\n>                    for (int i = 0; i < 10; i++) {\n>                        System.out.printf(\"%s: %d\\n\", this.getName(), i);\n>                        // i能被4整除时，休眠100毫秒\n>                        if (i % 4 == 0)\n>                            Thread.sleep(100);\n>                    }\n>                } catch (InterruptedException e) {\n>                    e.printStackTrace();\n>                }\n>            }\n>        }\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1: 0\n>t1: 1\n>t1: 2\n>t1: 3\n>t1: 4\n>t1: 5\n>t1: 6\n>t1: 7\n>t1: 8\n>t1: 9\n>t2: 0\n>t2: 1\n>t2: 2\n>t2: 3\n>t2: 4\n>t2: 5\n>t2: 6\n>t2: 7\n>t2: 8\n>t2: 9\n>```\n>\n>**结果说明**： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.sleep(100)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！ 注意，若我们注释掉synchronized (obj)后再次执行该程序，t1和t2是可以相互切换的。","slug":"java多线程系列 03 线程等待与唤醒，线程休眠","published":1,"updated":"2019-01-04T01:48:59.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx6q002peb1u27f68izp","content":"<h1 id=\"java多线程系列-03-线程等待与唤醒，线程休眠\"><a href=\"#java多线程系列-03-线程等待与唤醒，线程休眠\" class=\"headerlink\" title=\"java多线程系列 03 线程等待与唤醒，线程休眠\"></a>java多线程系列 03 线程等待与唤醒，线程休眠</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>wait(), notify(), notifyAll()等方法介绍</li>\n<li>wait()和notify()示例</li>\n<li>wait(long timeout)和notify()示例</li>\n<li>wait() 和 notifyAll()</li>\n<li>为什么notify(), wait()等函数定义在Object中，而不是Thread中</li>\n<li>sleep()介绍与使用</li>\n<li>sleep() 与 wait()的比较</li>\n</ol>\n</blockquote>\n<h3 id=\"1-wait-notify-notifyAll-等方法介绍\"><a href=\"#1-wait-notify-notifyAll-等方法介绍\" class=\"headerlink\" title=\"1. wait(), notify(), notifyAll()等方法介绍\"></a>1. wait(), notify(), notifyAll()等方法介绍</h3><blockquote>\n<p>在Object类中，定义了wait(), notify()和notifyAll()等接口。</p>\n<p>wait()的作用是让当前线程进入等待状态，<strong>同时，wait()也会让当前线程释放它所持有的锁。</strong>而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。</p>\n<p>Object类中关于等待/唤醒的API详细信息如下：<br><strong>notify()</strong>        – 唤醒在此对象监视器上等待的单个线程。<br><strong>notifyAll()</strong>   – 唤醒在此对象监视器上等待的所有线程。<br><strong>wait()</strong>           – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。<br><strong>wait(long timeout)</strong>   – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。<br><strong>wait(long timeout, int nanos)</strong>  – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</p>\n</blockquote>\n<h3 id=\"2-wait-和notify-示例\"><a href=\"#2-wait-和notify-示例\" class=\"headerlink\" title=\"2. wait()和notify()示例\"></a>2. wait()和notify()示例</h3><blockquote>\n<p>代码如下:</p>\n<pre><code class=\"java\">class ThreadA extends Thread {\n\n   public ThreadA(String name) {\n       super(name);\n   }\n\n   public void run() {\n       synchronized (this) {\n           System.out.println(Thread.currentThread().getName() \n                                      + &quot; call notify()&quot;);\n           // 唤醒当前的wait线程\n           notify();\n       }\n   }\n}\n\npublic class WaitTest {\n\n   public static void main(String[] args) {\n\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n       synchronized (t1) {\n           try {\n               // 启动“线程t1”\n               System.out.println(Thread.currentThread().getName() + &quot; start t1&quot;);\n               t1.start();\n\n               // 主线程等待t1通过notify()唤醒。\n               System.out.println(Thread.currentThread().getName() + &quot; wait()&quot;);\n               t1.wait();\n\n               System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n}\n</code></pre>\n<p><strong>运行结果</strong>:</p>\n<pre><code>main start t1\nmain wait()\nt1 call notify()\nmain continue\n</code></pre><p><strong>结果说明</strong>：<br>如下图，说明了“主线程”和“线程t1”的流程。</p>\n<p>(01) 注意，图中”主线程” 代表“主线程main”。”线程t1” 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。<br>(02) “主线程”通过 new ThreadA(“t1”) 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。<br>(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。<br>(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。<br>(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18183712-f04899f92aaa43b6a33a85fecfa60a9d.png\" alt=\"img\"></p>\n<p>对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？<br>在解答该问题前，我们先看看jdk文档中关于wait的一段介绍：</p>\n<pre><code>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. \nIn other words, this method behaves exactly as if it simply performs the call wait(0).\nThe current thread must own this object&#39;s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object&#39;s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.\n</code></pre><p>中文意思大概是：</p>\n<pre><code>引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。\n</code></pre><p>注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！<br>这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！</p>\n</blockquote>\n<h3 id=\"3-wait-long-timeout-和notify\"><a href=\"#3-wait-long-timeout-和notify\" class=\"headerlink\" title=\"3. wait(long timeout)和notify()\"></a><strong>3. wait(long timeout)和notify()</strong></h3><blockquote>\n<p>wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 </p>\n<p>下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。</p>\n<pre><code>// WaitTimeoutTest.java的源码\nclass ThreadA extends Thread{\n\n   public ThreadA(String name) {\n       super(name);\n   }\n\n   public void run() {\n       System.out.println(Thread.currentThread().getName() + &quot; run &quot;);\n       // 死循环，不断运行。\n       while(true)\n           ;\n   }\n}\n\npublic class WaitTimeoutTest {\n\n   public static void main(String[] args) {\n\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n\n       synchronized(t1) {\n           try {\n               // 启动“线程t1”\n               System.out.println(Thread.currentThread().getName() + &quot; start t1&quot;);\n               t1.start();\n\n      // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。\n        System.out.println(Thread.currentThread().getName() + &quot; call wait &quot;);\n               t1.wait(3000);\n\n               System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>main start t1\nmain call wait \nt1 run                  // 大约3秒之后...输出“main continue”\nmain continue\n</code></pre><p><strong>结果说明</strong>：<br>如下图，说明了“主线程”和“线程t1”的流程。<br>(01) 注意，图中”主线程” 代表WaitTimeoutTest主线程(即，线程main)。”线程t1” 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。<br>(02) 主线程main执行t1.start()启动“线程t1”。<br>(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。<br>(04) “线程t1”运行之后，进入了死循环，一直不断的运行。<br>(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18183848-d4c16bf2760847afa4fede6a9d959083.png\" alt=\"img\"></p>\n</blockquote>\n<h3 id=\"4-wait-和-notifyAll\"><a href=\"#4-wait-和-notifyAll\" class=\"headerlink\" title=\"4. wait() 和 notifyAll()\"></a><strong>4. wait() 和 notifyAll()</strong></h3><blockquote>\n<p>通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。</p>\n<p>下面，我们通过示例演示notifyAll()的用法；它的作用是唤醒在此对象监视器上等待的所有线程。</p>\n<pre><code>public class NotifyAllTest {\n\n   private static Object obj = new Object();\n\n   public static void main(String[] args) {\n\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n       ThreadA t2 = new ThreadA(&quot;t2&quot;);\n       ThreadA t3 = new ThreadA(&quot;t3&quot;);\n       t1.start();\n       t2.start();\n       t3.start();\n\n       try {\n           System.out.println(Thread.currentThread().getName() + &quot; sleep(3000)&quot;);\n           Thread.sleep(3000);\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n       synchronized (obj) {\n           // 主线程等待唤醒。\n           System.out.println(Thread.currentThread().getName() + &quot; notifyAll()&quot;);\n           obj.notifyAll();\n       }\n   }\n\n   static class ThreadA extends Thread {\n\n       public ThreadA(String name) {\n           super(name);\n       }\n\n       public void run() {\n           synchronized (obj) {\n               try {\n                   // 打印输出结果\n                   System.out.println(Thread.currentThread().getName() + &quot; wait&quot;);\n\n                   // 唤醒当前的wait线程\n                   obj.wait();\n\n                   // 打印输出结果\n                   System.out.println(Thread.currentThread().getName() \n                           + &quot; continue&quot;);\n               } catch (InterruptedException e) {\n                   e.printStackTrace();\n               }\n           }\n       }\n   }\n}\n</code></pre><p>运行结果</p>\n<pre><code>t1 wait\nmain sleep(3000)\nt3 wait\nt2 wait\nmain notifyAll()\nt2 continue\nt3 continue\nt1 continue\n</code></pre><p><strong>结果说明</strong>：<br>参考下面的流程图。<br>(01) 主线程中新建并且启动了3个线程”t1”, “t2”和”t3”。<br>(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设”t1”, “t2”和”t3”这3个线程都运行了。以”t1”为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，”t2”和”t3”也会等待其它线程通过nofity()或nofityAll()来唤醒它们。<br>(03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒”t1”, “t2”和”t3”这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，”t1”, “t2”和”t3”就可以获取“obj锁”而继续运行了！</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18183923-95275c066212410f96181704a681f453.png\" alt=\"img\"></p>\n<p><strong>需要注意的一点是：notifyAll会唤醒所有等待获取此对象的线程，他们会彼此竞争，但是他们已经退出了等待，但是由于同步锁的原因，因此同一时刻只会有一个线程获取到锁，所以也只有一个线程会运行，但最终所有的线程都是依次获取到锁，接着运行</strong></p>\n</blockquote>\n<h3 id=\"5-为什么notify-wait-等函数定义在Object中，而不是Thread中\"><a href=\"#5-为什么notify-wait-等函数定义在Object中，而不是Thread中\" class=\"headerlink\" title=\"5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中\"></a><strong>5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中</strong></h3><blockquote>\n<p>Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。</p>\n<p>wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！<br>OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。</p>\n<p>负责唤醒等待线程的那个线程(我们称为“<strong>唤醒线程</strong>”)，它只有在获取“该对象的同步锁”(<strong>这里的同步锁必须和等待线程的同步锁是同一个</strong>)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p>\n<p>总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。</p>\n</blockquote>\n<h3 id=\"6-sleep-介绍与使用\"><a href=\"#6-sleep-介绍与使用\" class=\"headerlink\" title=\"6. sleep()介绍与使用\"></a>6. sleep()介绍与使用</h3><blockquote>\n<p>sleep() 定义在Thread.java中。 sleep() 的作用是让当前线程休眠，即当前线程会从<strong>运行状态</strong>进入到<strong>休眠(阻塞)状态</strong>。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由<strong>阻塞状态</strong>变成<strong>就绪状态</strong>，从而等待cpu的调度执行。</p>\n<p>下面是一个简单的demo</p>\n<pre><code>// SleepTest.java的源码\nclass ThreadA extends Thread{\n   public ThreadA(String name){ \n       super(name); \n   } \n   public synchronized void run() { \n       try {\n           for(int i=0; i &lt;10; i++){ \n               System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i); \n               // i能被4整除时，休眠100毫秒\n               if (i%4 == 0)\n                   Thread.sleep(100);\n           } \n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n   } \n} \n\npublic class SleepTest{ \n   public static void main(String[] args){ \n       ThreadA t1 = new ThreadA(&quot;t1&quot;); \n       t1.start(); \n   } \n}\n</code></pre><p>运行结果:</p>\n<pre><code>t1: 0\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt1: 5\nt1: 6\nt1: 7\nt1: 8\nt1: 9\n</code></pre><p><strong>结果说明</strong>： 程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(100)休眠100毫秒。</p>\n</blockquote>\n<h3 id=\"7-sleep-与-wait-的比较\"><a href=\"#7-sleep-与-wait-的比较\" class=\"headerlink\" title=\"7. sleep() 与 wait()的比较\"></a><strong>7. sleep() 与 wait()的比较</strong></h3><blockquote>\n<p>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。 但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。</p>\n<p>\u0010 下面通过示例演示sleep()是不会释放锁的。</p>\n<pre><code>public class SleepLockTest {\n\n   private static Object obj = new Object();\n\n   public static void main(String[] args) {\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n       ThreadA t2 = new ThreadA(&quot;t2&quot;);\n       t1.start();\n       t2.start();\n   }\n\n   static class ThreadA extends Thread {\n       public ThreadA(String name) {\n           super(name);\n       }\n\n       public void run() {\n           // 获取obj对象的同步锁\n           synchronized (obj) {\n               try {\n                   for (int i = 0; i &lt; 10; i++) {\n                       System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i);\n                       // i能被4整除时，休眠100毫秒\n                       if (i % 4 == 0)\n                           Thread.sleep(100);\n                   }\n               } catch (InterruptedException e) {\n                   e.printStackTrace();\n               }\n           }\n       }\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1: 0\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt1: 5\nt1: 6\nt1: 7\nt1: 8\nt1: 9\nt2: 0\nt2: 1\nt2: 2\nt2: 3\nt2: 4\nt2: 5\nt2: 6\nt2: 7\nt2: 8\nt2: 9\n</code></pre><p><strong>结果说明</strong>： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.sleep(100)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！ 注意，若我们注释掉synchronized (obj)后再次执行该程序，t1和t2是可以相互切换的。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-03-线程等待与唤醒，线程休眠\"><a href=\"#java多线程系列-03-线程等待与唤醒，线程休眠\" class=\"headerlink\" title=\"java多线程系列 03 线程等待与唤醒，线程休眠\"></a>java多线程系列 03 线程等待与唤醒，线程休眠</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>wait(), notify(), notifyAll()等方法介绍</li>\n<li>wait()和notify()示例</li>\n<li>wait(long timeout)和notify()示例</li>\n<li>wait() 和 notifyAll()</li>\n<li>为什么notify(), wait()等函数定义在Object中，而不是Thread中</li>\n<li>sleep()介绍与使用</li>\n<li>sleep() 与 wait()的比较</li>\n</ol>\n</blockquote>\n<h3 id=\"1-wait-notify-notifyAll-等方法介绍\"><a href=\"#1-wait-notify-notifyAll-等方法介绍\" class=\"headerlink\" title=\"1. wait(), notify(), notifyAll()等方法介绍\"></a>1. wait(), notify(), notifyAll()等方法介绍</h3><blockquote>\n<p>在Object类中，定义了wait(), notify()和notifyAll()等接口。</p>\n<p>wait()的作用是让当前线程进入等待状态，<strong>同时，wait()也会让当前线程释放它所持有的锁。</strong>而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。</p>\n<p>Object类中关于等待/唤醒的API详细信息如下：<br><strong>notify()</strong>        – 唤醒在此对象监视器上等待的单个线程。<br><strong>notifyAll()</strong>   – 唤醒在此对象监视器上等待的所有线程。<br><strong>wait()</strong>           – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。<br><strong>wait(long timeout)</strong>   – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。<br><strong>wait(long timeout, int nanos)</strong>  – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</p>\n</blockquote>\n<h3 id=\"2-wait-和notify-示例\"><a href=\"#2-wait-和notify-示例\" class=\"headerlink\" title=\"2. wait()和notify()示例\"></a>2. wait()和notify()示例</h3><blockquote>\n<p>代码如下:</p>\n<pre><code class=\"java\">class ThreadA extends Thread {\n\n   public ThreadA(String name) {\n       super(name);\n   }\n\n   public void run() {\n       synchronized (this) {\n           System.out.println(Thread.currentThread().getName() \n                                      + &quot; call notify()&quot;);\n           // 唤醒当前的wait线程\n           notify();\n       }\n   }\n}\n\npublic class WaitTest {\n\n   public static void main(String[] args) {\n\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n       synchronized (t1) {\n           try {\n               // 启动“线程t1”\n               System.out.println(Thread.currentThread().getName() + &quot; start t1&quot;);\n               t1.start();\n\n               // 主线程等待t1通过notify()唤醒。\n               System.out.println(Thread.currentThread().getName() + &quot; wait()&quot;);\n               t1.wait();\n\n               System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n}\n</code></pre>\n<p><strong>运行结果</strong>:</p>\n<pre><code>main start t1\nmain wait()\nt1 call notify()\nmain continue\n</code></pre><p><strong>结果说明</strong>：<br>如下图，说明了“主线程”和“线程t1”的流程。</p>\n<p>(01) 注意，图中”主线程” 代表“主线程main”。”线程t1” 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。<br>(02) “主线程”通过 new ThreadA(“t1”) 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。<br>(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。<br>(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。<br>(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18183712-f04899f92aaa43b6a33a85fecfa60a9d.png\" alt=\"img\"></p>\n<p>对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？<br>在解答该问题前，我们先看看jdk文档中关于wait的一段介绍：</p>\n<pre><code>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. \nIn other words, this method behaves exactly as if it simply performs the call wait(0).\nThe current thread must own this object&#39;s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object&#39;s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.\n</code></pre><p>中文意思大概是：</p>\n<pre><code>引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。\n</code></pre><p>注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！<br>这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！</p>\n</blockquote>\n<h3 id=\"3-wait-long-timeout-和notify\"><a href=\"#3-wait-long-timeout-和notify\" class=\"headerlink\" title=\"3. wait(long timeout)和notify()\"></a><strong>3. wait(long timeout)和notify()</strong></h3><blockquote>\n<p>wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 </p>\n<p>下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。</p>\n<pre><code>// WaitTimeoutTest.java的源码\nclass ThreadA extends Thread{\n\n   public ThreadA(String name) {\n       super(name);\n   }\n\n   public void run() {\n       System.out.println(Thread.currentThread().getName() + &quot; run &quot;);\n       // 死循环，不断运行。\n       while(true)\n           ;\n   }\n}\n\npublic class WaitTimeoutTest {\n\n   public static void main(String[] args) {\n\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n\n       synchronized(t1) {\n           try {\n               // 启动“线程t1”\n               System.out.println(Thread.currentThread().getName() + &quot; start t1&quot;);\n               t1.start();\n\n      // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。\n        System.out.println(Thread.currentThread().getName() + &quot; call wait &quot;);\n               t1.wait(3000);\n\n               System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>main start t1\nmain call wait \nt1 run                  // 大约3秒之后...输出“main continue”\nmain continue\n</code></pre><p><strong>结果说明</strong>：<br>如下图，说明了“主线程”和“线程t1”的流程。<br>(01) 注意，图中”主线程” 代表WaitTimeoutTest主线程(即，线程main)。”线程t1” 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。<br>(02) 主线程main执行t1.start()启动“线程t1”。<br>(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。<br>(04) “线程t1”运行之后，进入了死循环，一直不断的运行。<br>(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18183848-d4c16bf2760847afa4fede6a9d959083.png\" alt=\"img\"></p>\n</blockquote>\n<h3 id=\"4-wait-和-notifyAll\"><a href=\"#4-wait-和-notifyAll\" class=\"headerlink\" title=\"4. wait() 和 notifyAll()\"></a><strong>4. wait() 和 notifyAll()</strong></h3><blockquote>\n<p>通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。</p>\n<p>下面，我们通过示例演示notifyAll()的用法；它的作用是唤醒在此对象监视器上等待的所有线程。</p>\n<pre><code>public class NotifyAllTest {\n\n   private static Object obj = new Object();\n\n   public static void main(String[] args) {\n\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n       ThreadA t2 = new ThreadA(&quot;t2&quot;);\n       ThreadA t3 = new ThreadA(&quot;t3&quot;);\n       t1.start();\n       t2.start();\n       t3.start();\n\n       try {\n           System.out.println(Thread.currentThread().getName() + &quot; sleep(3000)&quot;);\n           Thread.sleep(3000);\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n       synchronized (obj) {\n           // 主线程等待唤醒。\n           System.out.println(Thread.currentThread().getName() + &quot; notifyAll()&quot;);\n           obj.notifyAll();\n       }\n   }\n\n   static class ThreadA extends Thread {\n\n       public ThreadA(String name) {\n           super(name);\n       }\n\n       public void run() {\n           synchronized (obj) {\n               try {\n                   // 打印输出结果\n                   System.out.println(Thread.currentThread().getName() + &quot; wait&quot;);\n\n                   // 唤醒当前的wait线程\n                   obj.wait();\n\n                   // 打印输出结果\n                   System.out.println(Thread.currentThread().getName() \n                           + &quot; continue&quot;);\n               } catch (InterruptedException e) {\n                   e.printStackTrace();\n               }\n           }\n       }\n   }\n}\n</code></pre><p>运行结果</p>\n<pre><code>t1 wait\nmain sleep(3000)\nt3 wait\nt2 wait\nmain notifyAll()\nt2 continue\nt3 continue\nt1 continue\n</code></pre><p><strong>结果说明</strong>：<br>参考下面的流程图。<br>(01) 主线程中新建并且启动了3个线程”t1”, “t2”和”t3”。<br>(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设”t1”, “t2”和”t3”这3个线程都运行了。以”t1”为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，”t2”和”t3”也会等待其它线程通过nofity()或nofityAll()来唤醒它们。<br>(03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒”t1”, “t2”和”t3”这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，”t1”, “t2”和”t3”就可以获取“obj锁”而继续运行了！</p>\n<p><img src=\"https://images0.cnblogs.com/blog/497634/201312/18183923-95275c066212410f96181704a681f453.png\" alt=\"img\"></p>\n<p><strong>需要注意的一点是：notifyAll会唤醒所有等待获取此对象的线程，他们会彼此竞争，但是他们已经退出了等待，但是由于同步锁的原因，因此同一时刻只会有一个线程获取到锁，所以也只有一个线程会运行，但最终所有的线程都是依次获取到锁，接着运行</strong></p>\n</blockquote>\n<h3 id=\"5-为什么notify-wait-等函数定义在Object中，而不是Thread中\"><a href=\"#5-为什么notify-wait-等函数定义在Object中，而不是Thread中\" class=\"headerlink\" title=\"5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中\"></a><strong>5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中</strong></h3><blockquote>\n<p>Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。</p>\n<p>wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！<br>OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。</p>\n<p>负责唤醒等待线程的那个线程(我们称为“<strong>唤醒线程</strong>”)，它只有在获取“该对象的同步锁”(<strong>这里的同步锁必须和等待线程的同步锁是同一个</strong>)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p>\n<p>总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。</p>\n</blockquote>\n<h3 id=\"6-sleep-介绍与使用\"><a href=\"#6-sleep-介绍与使用\" class=\"headerlink\" title=\"6. sleep()介绍与使用\"></a>6. sleep()介绍与使用</h3><blockquote>\n<p>sleep() 定义在Thread.java中。 sleep() 的作用是让当前线程休眠，即当前线程会从<strong>运行状态</strong>进入到<strong>休眠(阻塞)状态</strong>。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由<strong>阻塞状态</strong>变成<strong>就绪状态</strong>，从而等待cpu的调度执行。</p>\n<p>下面是一个简单的demo</p>\n<pre><code>// SleepTest.java的源码\nclass ThreadA extends Thread{\n   public ThreadA(String name){ \n       super(name); \n   } \n   public synchronized void run() { \n       try {\n           for(int i=0; i &lt;10; i++){ \n               System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i); \n               // i能被4整除时，休眠100毫秒\n               if (i%4 == 0)\n                   Thread.sleep(100);\n           } \n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n   } \n} \n\npublic class SleepTest{ \n   public static void main(String[] args){ \n       ThreadA t1 = new ThreadA(&quot;t1&quot;); \n       t1.start(); \n   } \n}\n</code></pre><p>运行结果:</p>\n<pre><code>t1: 0\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt1: 5\nt1: 6\nt1: 7\nt1: 8\nt1: 9\n</code></pre><p><strong>结果说明</strong>： 程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(100)休眠100毫秒。</p>\n</blockquote>\n<h3 id=\"7-sleep-与-wait-的比较\"><a href=\"#7-sleep-与-wait-的比较\" class=\"headerlink\" title=\"7. sleep() 与 wait()的比较\"></a><strong>7. sleep() 与 wait()的比较</strong></h3><blockquote>\n<p>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。 但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。</p>\n<p>\u0010 下面通过示例演示sleep()是不会释放锁的。</p>\n<pre><code>public class SleepLockTest {\n\n   private static Object obj = new Object();\n\n   public static void main(String[] args) {\n       ThreadA t1 = new ThreadA(&quot;t1&quot;);\n       ThreadA t2 = new ThreadA(&quot;t2&quot;);\n       t1.start();\n       t2.start();\n   }\n\n   static class ThreadA extends Thread {\n       public ThreadA(String name) {\n           super(name);\n       }\n\n       public void run() {\n           // 获取obj对象的同步锁\n           synchronized (obj) {\n               try {\n                   for (int i = 0; i &lt; 10; i++) {\n                       System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i);\n                       // i能被4整除时，休眠100毫秒\n                       if (i % 4 == 0)\n                           Thread.sleep(100);\n                   }\n               } catch (InterruptedException e) {\n                   e.printStackTrace();\n               }\n           }\n       }\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1: 0\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt1: 5\nt1: 6\nt1: 7\nt1: 8\nt1: 9\nt2: 0\nt2: 1\nt2: 2\nt2: 3\nt2: 4\nt2: 5\nt2: 6\nt2: 7\nt2: 8\nt2: 9\n</code></pre><p><strong>结果说明</strong>： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.sleep(100)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！ 注意，若我们注释掉synchronized (obj)后再次执行该程序，t1和t2是可以相互切换的。</p>\n</blockquote>\n"},{"abbrlink":6,"title":" Java多线程系列 05 interrupt()和线程终止方式","author":"zhangke","date":"2018-07-13T03:11:00.000Z","_content":"# Java多线程系列 05 interrupt()和线程终止方式\n\n### 概要\n\n>1. interrupt()说明\n>2. 终止线程的方式\n>3. 终止线程的示例\n\n### 1. interrupt()说明\n\n>在介绍终止线程的方式之前，有必要先对interrupt()进行了解。\n>关于interrupt()，java的djk文档描述如下：<http://docs.oracle.com/javase/7/docs/api/>\n>\n>```\n>Interrupts this thread.Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.\n>\n>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.\n>\n>If this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a ClosedByInterruptException.\n>\n>If this thread is blocked in a Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked.\n>\n>If none of the previous conditions hold then this thread's interrupt status will be set.\n>\n>Interrupting a thread that is not alive need not have any effect.\n>```\n>\n>大致意思是：\n>\n>```\n>interrupt()的作用是中断本线程。\n>本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。\n>如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。\n>如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。\n>如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。\n>```\n>\n>\n\n### **2. 终止线程的方式**\n\n>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！ 下面，我先分别讨论线程在“阻塞状态”和“运行状态”的终止方式，然后再总结出一个通用的方式。\n>\n>### 2.1 终止处于“阻塞状态”的线程\n>\n>通常，我们通过“中断”方式终止处于“阻塞状态”的线程。\n>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的位置就能终止线程，形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    try {\n>        while (true) {\n>            // 执行任务...\n>        }\n>    } catch (InterruptedException ie) {  \n>        // 由于产生InterruptedException异常，退出while(true)循环，线程终止！\n>    }\n>}\n>```\n>\n>**说明**：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！\n>注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    while (true) {\n>        try {\n>            // 执行任务...\n>        } catch (InterruptedException ie) {  \n>            // InterruptedException在while(true)循环体内。\n>           // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出\n>            break;\n>        }\n>    }\n>}\n>```\n>\n>说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。\n>\n>### 2.2 终止处于“运行状态”的线程\n>\n>通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“**中断标记**”和“**额外添加标记**”。\n>**(01) 通过“中断标记”终止线程。**\n>形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    while (!isInterrupted()) {\n>        // 执行任务...\n>    }\n>}\n>```\n>\n>**说明**：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。\n>**注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。**\n>\n>上面上面说的可以通过一个小案例来测试:\n>\n>````\n>package concurrent;\n>\n>/**************************************\n> *      Author : zhangke\n> *      Date   : 2018/7/12 20:09\n> *      Desc   : \n> ***************************************/\n>public class InterruptedTest {\n>    public static void main(String[] args) {\n>        try {\n>            Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is new.\");\n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() + \n>            \t\t\" (\" + t1.getState() + \") is started.\");\n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(10);\n>            t1.interrupt();\n>            System.out.println(t1.getName() \n>            \t\t\t+ \" (\" + t1.getState() + \") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() \n>            \t\t\t+ \" (\" + t1.getState() + \") is interrupted now.\");\n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>\n>    }\n>\n>    static class MyThread extends Thread {\n>\n>        public MyThread(String name) {\n>            super(name);\n>        }\n>\n>        @Override\n>        public void run() {\n>\n>            int i = 0;\n>            while (!isInterrupted()) {\n>                i++;\n>                if (i % 100000 == 0)\n>                    System.out.println(Thread.currentThread().getName() \n>                    \t\t+ \" (\" + this.getState() + \") loop \" + i);\n>            }\n>            while (true) {\n>                System.out.println(\"test\");\n>            }\n>\n>        }\n>    }\n>}\n>\n>\n>````\n>\n>运行结果:\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 100000\n>t1 (RUNNABLE) loop 200000\n>test\n>test\n>test\n>test\n>test\n>test\n>test\n>..........\n>```\n>\n>通过上面的例子可以看出，interrupt方法只是产生了中断标记，但是并没有暂停当前线程。否则就不会出现test这个字符\n>\n>**(02) 通过“额外添加标记”。**\n>形式如下：\n>\n>```\n>private volatile boolean flag= true;\n>protected void stopTask() {\n>    flag = false;\n>}\n>\n>@Override\n>public void run() {\n>    while (flag) {\n>        // 执行任务...\n>    }\n>}\n>```\n>\n>**说明**：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。\n>注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。\n>\n>综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    try {\n>        // 1. isInterrupted()保证，只要中断标记为true就终止线程。\n>        while (!isInterrupted()) {\n>            // 执行任务...\n>        }\n>    } catch (InterruptedException ie) {  \n>        // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。\n>    }\n>}\n>```\n>\n>\n\n### **3. 终止线程的示例**\n\n>interrupt()常常被用来终止“阻塞状态”线程。参考下面示例：\n>\n>```\n>// Demo1.java的源码\n>class MyThread extends Thread {\n>    \n>    public MyThread(String name) {\n>        super(name);\n>    }\n>\n>    @Override\n>    public void run() {\n>        try {  \n>            int i=0;\n>            while (!isInterrupted()) {\n>                Thread.sleep(100); // 休眠100ms\n>                i++;\n>                System.out.println(Thread.currentThread().getName()+\" \n>                (\"+this.getState()+\") loop \" + i);  \n>            }\n>        } catch (InterruptedException e) {  \n>            System.out.println(Thread.currentThread().getName() +\n>            \" (\"+this.getState()+\") catch InterruptedException.\");  \n>        }\n>    }\n>}\n>\n>public class Demo1 {\n>\n>    public static void main(String[] args) {  \n>        try {  \n>            Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\");  \n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\");  \n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(300);\n>            t1.interrupt();\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() \n>            \t\t+\" (\"+t1.getState()+\") is interrupted now.\");\n>        } catch (InterruptedException e) {  \n>            e.printStackTrace();\n>        }\n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 1\n>t1 (RUNNABLE) loop 2\n>t1 (TIMED_WAITING) is interrupted.\n>t1 (RUNNABLE) catch InterruptedException.\n>t1 (TERMINATED) is interrupted now.\n>```\n>\n>**结果说明**：\n>(01) 主线程main中通过new MyThread(\"t1\")创建线程t1，之后通过t1.start()启动线程t1。\n>(02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。\n>(03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。\n>\n>我们对上面的结果进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。\n>\n>```\n>// Demo2.java的源码\n>class MyThread extends Thread {\n>    \n>    public MyThread(String name) {\n>        super(name);\n>    }\n>\n>    @Override\n>    public void run() {\n>        int i=0;\n>        while (!isInterrupted()) {\n>            try {\n>                Thread.sleep(100); // 休眠100ms\n>            } catch (InterruptedException ie) {  \n>                System.out.println(Thread.currentThread().getName() \n>                \t\t+\" (\"+this.getState()+\") catch InterruptedException.\");  \n>            }\n>            i++;\n>            System.out.println(Thread.currentThread().getName()+\n>            \t\" (\"+this.getState()+\") loop \" + i);  \n>        }\n>    }\n>}\n>\n>public class Demo2 {\n>\n>    public static void main(String[] args) {  \n>        try {  \n>            Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\");  \n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\");  \n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(300);\n>            t1.interrupt();\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() +\n>            \t\t\t\" (\"+t1.getState()+\") is interrupted now.\");\n>        } catch (InterruptedException e) {  \n>            e.printStackTrace();\n>        }\n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 1\n>t1 (RUNNABLE) loop 2\n>t1 (TIMED_WAITING) is interrupted.\n>t1 (RUNNABLE) catch InterruptedException.\n>t1 (RUNNABLE) loop 3\n>t1 (RUNNABLE) loop 4\n>t1 (RUNNABLE) loop 5\n>t1 (TIMED_WAITING) is interrupted now.\n>t1 (RUNNABLE) loop 6\n>t1 (RUNNABLE) loop 7\n>t1 (RUNNABLE) loop 8\n>t1 (RUNNABLE) loop 9\n>...\n>```\n>\n>**结果说明**：\n>程序进入了死循环！\n>为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。\n>解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。\n>\n>同时这个也说明interrupt只是产生了中断标记，并没有终止当前线程。\n>\n>下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例：\n>\n>```\n>// Demo3.java的源码\n>class MyThread extends Thread {\n>\n>    private volatile boolean flag= true;\n>    public void stopTask() {\n>        flag = false;\n>    }\n>    \n>    public MyThread(String name) {\n>        super(name);\n>    }\n>\n>    @Override\n>    public void run() {\n>        synchronized(this) {\n>            try {\n>                int i=0;\n>                while (flag) {\n>                    Thread.sleep(100); // 休眠100ms\n>                    i++;\n>                    System.out.println(Thread.currentThread().getName()+\n>                    \t\t\" (\"+this.getState()+\") loop \" + i);  \n>                }\n>            } catch (InterruptedException ie) {  \n>                System.out.println(Thread.currentThread().getName() +\n>                \t\t\" (\"+this.getState()+\") catch InterruptedException.\");  \n>            }\n>        }  \n>    }\n>}\n>\n>public class Demo3 {\n>\n>    public static void main(String[] args) {  \n>        try {  \n>            MyThread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\");  \n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\");  \n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(300);\n>            t1.stopTask();\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted now.\");\n>        } catch (InterruptedException e) {  \n>            e.printStackTrace();\n>        }\n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 1\n>t1 (RUNNABLE) loop 2\n>t1 (TIMED_WAITING) is interrupted.\n>t1 (RUNNABLE) loop 3\n>t1 (TERMINATED) is interrupted now.\n>```\n>\n>\n\n### **4. interrupted() 和 isInterrupted()的区别**\n\n>最后谈谈 interrupted() 和 isInterrupted()。\n>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。\n>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。\n\n\n\n\n\n","source":"_posts/java多线程系列 05 interrupt()和线程终止方式.md","raw":"abbrlink: 6\ntitle: ' Java多线程系列 05 interrupt()和线程终止方式'\ntags:\n  - 多线程\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-07-13 11:11:00\n---\n# Java多线程系列 05 interrupt()和线程终止方式\n\n### 概要\n\n>1. interrupt()说明\n>2. 终止线程的方式\n>3. 终止线程的示例\n\n### 1. interrupt()说明\n\n>在介绍终止线程的方式之前，有必要先对interrupt()进行了解。\n>关于interrupt()，java的djk文档描述如下：<http://docs.oracle.com/javase/7/docs/api/>\n>\n>```\n>Interrupts this thread.Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.\n>\n>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.\n>\n>If this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a ClosedByInterruptException.\n>\n>If this thread is blocked in a Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked.\n>\n>If none of the previous conditions hold then this thread's interrupt status will be set.\n>\n>Interrupting a thread that is not alive need not have any effect.\n>```\n>\n>大致意思是：\n>\n>```\n>interrupt()的作用是中断本线程。\n>本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。\n>如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。\n>如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。\n>如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。\n>```\n>\n>\n\n### **2. 终止线程的方式**\n\n>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！ 下面，我先分别讨论线程在“阻塞状态”和“运行状态”的终止方式，然后再总结出一个通用的方式。\n>\n>### 2.1 终止处于“阻塞状态”的线程\n>\n>通常，我们通过“中断”方式终止处于“阻塞状态”的线程。\n>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的位置就能终止线程，形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    try {\n>        while (true) {\n>            // 执行任务...\n>        }\n>    } catch (InterruptedException ie) {  \n>        // 由于产生InterruptedException异常，退出while(true)循环，线程终止！\n>    }\n>}\n>```\n>\n>**说明**：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！\n>注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    while (true) {\n>        try {\n>            // 执行任务...\n>        } catch (InterruptedException ie) {  \n>            // InterruptedException在while(true)循环体内。\n>           // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出\n>            break;\n>        }\n>    }\n>}\n>```\n>\n>说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。\n>\n>### 2.2 终止处于“运行状态”的线程\n>\n>通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“**中断标记**”和“**额外添加标记**”。\n>**(01) 通过“中断标记”终止线程。**\n>形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    while (!isInterrupted()) {\n>        // 执行任务...\n>    }\n>}\n>```\n>\n>**说明**：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。\n>**注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。**\n>\n>上面上面说的可以通过一个小案例来测试:\n>\n>````\n>package concurrent;\n>\n>/**************************************\n> *      Author : zhangke\n> *      Date   : 2018/7/12 20:09\n> *      Desc   : \n> ***************************************/\n>public class InterruptedTest {\n>    public static void main(String[] args) {\n>        try {\n>            Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is new.\");\n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() + \n>            \t\t\" (\" + t1.getState() + \") is started.\");\n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(10);\n>            t1.interrupt();\n>            System.out.println(t1.getName() \n>            \t\t\t+ \" (\" + t1.getState() + \") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() \n>            \t\t\t+ \" (\" + t1.getState() + \") is interrupted now.\");\n>        } catch (InterruptedException e) {\n>            e.printStackTrace();\n>        }\n>\n>    }\n>\n>    static class MyThread extends Thread {\n>\n>        public MyThread(String name) {\n>            super(name);\n>        }\n>\n>        @Override\n>        public void run() {\n>\n>            int i = 0;\n>            while (!isInterrupted()) {\n>                i++;\n>                if (i % 100000 == 0)\n>                    System.out.println(Thread.currentThread().getName() \n>                    \t\t+ \" (\" + this.getState() + \") loop \" + i);\n>            }\n>            while (true) {\n>                System.out.println(\"test\");\n>            }\n>\n>        }\n>    }\n>}\n>\n>\n>````\n>\n>运行结果:\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 100000\n>t1 (RUNNABLE) loop 200000\n>test\n>test\n>test\n>test\n>test\n>test\n>test\n>..........\n>```\n>\n>通过上面的例子可以看出，interrupt方法只是产生了中断标记，但是并没有暂停当前线程。否则就不会出现test这个字符\n>\n>**(02) 通过“额外添加标记”。**\n>形式如下：\n>\n>```\n>private volatile boolean flag= true;\n>protected void stopTask() {\n>    flag = false;\n>}\n>\n>@Override\n>public void run() {\n>    while (flag) {\n>        // 执行任务...\n>    }\n>}\n>```\n>\n>**说明**：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。\n>注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。\n>\n>综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下：\n>\n>```\n>@Override\n>public void run() {\n>    try {\n>        // 1. isInterrupted()保证，只要中断标记为true就终止线程。\n>        while (!isInterrupted()) {\n>            // 执行任务...\n>        }\n>    } catch (InterruptedException ie) {  \n>        // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。\n>    }\n>}\n>```\n>\n>\n\n### **3. 终止线程的示例**\n\n>interrupt()常常被用来终止“阻塞状态”线程。参考下面示例：\n>\n>```\n>// Demo1.java的源码\n>class MyThread extends Thread {\n>    \n>    public MyThread(String name) {\n>        super(name);\n>    }\n>\n>    @Override\n>    public void run() {\n>        try {  \n>            int i=0;\n>            while (!isInterrupted()) {\n>                Thread.sleep(100); // 休眠100ms\n>                i++;\n>                System.out.println(Thread.currentThread().getName()+\" \n>                (\"+this.getState()+\") loop \" + i);  \n>            }\n>        } catch (InterruptedException e) {  \n>            System.out.println(Thread.currentThread().getName() +\n>            \" (\"+this.getState()+\") catch InterruptedException.\");  \n>        }\n>    }\n>}\n>\n>public class Demo1 {\n>\n>    public static void main(String[] args) {  \n>        try {  \n>            Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\");  \n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\");  \n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(300);\n>            t1.interrupt();\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() \n>            \t\t+\" (\"+t1.getState()+\") is interrupted now.\");\n>        } catch (InterruptedException e) {  \n>            e.printStackTrace();\n>        }\n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 1\n>t1 (RUNNABLE) loop 2\n>t1 (TIMED_WAITING) is interrupted.\n>t1 (RUNNABLE) catch InterruptedException.\n>t1 (TERMINATED) is interrupted now.\n>```\n>\n>**结果说明**：\n>(01) 主线程main中通过new MyThread(\"t1\")创建线程t1，之后通过t1.start()启动线程t1。\n>(02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。\n>(03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。\n>\n>我们对上面的结果进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。\n>\n>```\n>// Demo2.java的源码\n>class MyThread extends Thread {\n>    \n>    public MyThread(String name) {\n>        super(name);\n>    }\n>\n>    @Override\n>    public void run() {\n>        int i=0;\n>        while (!isInterrupted()) {\n>            try {\n>                Thread.sleep(100); // 休眠100ms\n>            } catch (InterruptedException ie) {  \n>                System.out.println(Thread.currentThread().getName() \n>                \t\t+\" (\"+this.getState()+\") catch InterruptedException.\");  \n>            }\n>            i++;\n>            System.out.println(Thread.currentThread().getName()+\n>            \t\" (\"+this.getState()+\") loop \" + i);  \n>        }\n>    }\n>}\n>\n>public class Demo2 {\n>\n>    public static void main(String[] args) {  \n>        try {  \n>            Thread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\");  \n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\");  \n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(300);\n>            t1.interrupt();\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() +\n>            \t\t\t\" (\"+t1.getState()+\") is interrupted now.\");\n>        } catch (InterruptedException e) {  \n>            e.printStackTrace();\n>        }\n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 1\n>t1 (RUNNABLE) loop 2\n>t1 (TIMED_WAITING) is interrupted.\n>t1 (RUNNABLE) catch InterruptedException.\n>t1 (RUNNABLE) loop 3\n>t1 (RUNNABLE) loop 4\n>t1 (RUNNABLE) loop 5\n>t1 (TIMED_WAITING) is interrupted now.\n>t1 (RUNNABLE) loop 6\n>t1 (RUNNABLE) loop 7\n>t1 (RUNNABLE) loop 8\n>t1 (RUNNABLE) loop 9\n>...\n>```\n>\n>**结果说明**：\n>程序进入了死循环！\n>为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。\n>解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。\n>\n>同时这个也说明interrupt只是产生了中断标记，并没有终止当前线程。\n>\n>下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例：\n>\n>```\n>// Demo3.java的源码\n>class MyThread extends Thread {\n>\n>    private volatile boolean flag= true;\n>    public void stopTask() {\n>        flag = false;\n>    }\n>    \n>    public MyThread(String name) {\n>        super(name);\n>    }\n>\n>    @Override\n>    public void run() {\n>        synchronized(this) {\n>            try {\n>                int i=0;\n>                while (flag) {\n>                    Thread.sleep(100); // 休眠100ms\n>                    i++;\n>                    System.out.println(Thread.currentThread().getName()+\n>                    \t\t\" (\"+this.getState()+\") loop \" + i);  \n>                }\n>            } catch (InterruptedException ie) {  \n>                System.out.println(Thread.currentThread().getName() +\n>                \t\t\" (\"+this.getState()+\") catch InterruptedException.\");  \n>            }\n>        }  \n>    }\n>}\n>\n>public class Demo3 {\n>\n>    public static void main(String[] args) {  \n>        try {  \n>            MyThread t1 = new MyThread(\"t1\");  // 新建“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\");  \n>\n>            t1.start();                      // 启动“线程t1”\n>            System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\");  \n>\n>            // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n>            Thread.sleep(300);\n>            t1.stopTask();\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted.\");\n>\n>            // 主线程休眠300ms，然后查看t1的状态。\n>            Thread.sleep(300);\n>            System.out.println(t1.getName() +\n>            \t\t\" (\"+t1.getState()+\") is interrupted now.\");\n>        } catch (InterruptedException e) {  \n>            e.printStackTrace();\n>        }\n>    } \n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>t1 (NEW) is new.\n>t1 (RUNNABLE) is started.\n>t1 (RUNNABLE) loop 1\n>t1 (RUNNABLE) loop 2\n>t1 (TIMED_WAITING) is interrupted.\n>t1 (RUNNABLE) loop 3\n>t1 (TERMINATED) is interrupted now.\n>```\n>\n>\n\n### **4. interrupted() 和 isInterrupted()的区别**\n\n>最后谈谈 interrupted() 和 isInterrupted()。\n>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。\n>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。\n\n\n\n\n\n","slug":"java多线程系列 05 interrupt()和线程终止方式","published":1,"updated":"2019-01-04T01:48:59.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx6s002reb1uaahjb14y","content":"<h1 id=\"Java多线程系列-05-interrupt-和线程终止方式\"><a href=\"#Java多线程系列-05-interrupt-和线程终止方式\" class=\"headerlink\" title=\"Java多线程系列 05 interrupt()和线程终止方式\"></a>Java多线程系列 05 interrupt()和线程终止方式</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>interrupt()说明</li>\n<li>终止线程的方式</li>\n<li>终止线程的示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-interrupt-说明\"><a href=\"#1-interrupt-说明\" class=\"headerlink\" title=\"1. interrupt()说明\"></a>1. interrupt()说明</h3><blockquote>\n<p>在介绍终止线程的方式之前，有必要先对interrupt()进行了解。<br>关于interrupt()，java的djk文档描述如下：<a href=\"http://docs.oracle.com/javase/7/docs/api/\" target=\"_blank\" rel=\"noopener\">http://docs.oracle.com/javase/7/docs/api/</a></p>\n<pre><code>Interrupts this thread.Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.\n\nIf this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.\n\nIf this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread&#39;s interrupt status will be set, and the thread will receive a ClosedByInterruptException.\n\nIf this thread is blocked in a Selector then the thread&#39;s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector&#39;s wakeup method were invoked.\n\nIf none of the previous conditions hold then this thread&#39;s interrupt status will be set.\n\nInterrupting a thread that is not alive need not have any effect.\n</code></pre><p>大致意思是：</p>\n<pre><code>interrupt()的作用是中断本线程。\n本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。\n如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。\n如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。\n如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。\n</code></pre></blockquote>\n<h3 id=\"2-终止线程的方式\"><a href=\"#2-终止线程的方式\" class=\"headerlink\" title=\"2. 终止线程的方式\"></a><strong>2. 终止线程的方式</strong></h3><blockquote>\n<p>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！ 下面，我先分别讨论线程在“阻塞状态”和“运行状态”的终止方式，然后再总结出一个通用的方式。</p>\n<h3 id=\"2-1-终止处于“阻塞状态”的线程\"><a href=\"#2-1-终止处于“阻塞状态”的线程\" class=\"headerlink\" title=\"2.1 终止处于“阻塞状态”的线程\"></a>2.1 终止处于“阻塞状态”的线程</h3><p>通常，我们通过“中断”方式终止处于“阻塞状态”的线程。<br>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的位置就能终止线程，形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   try {\n       while (true) {\n           // 执行任务...\n       }\n   } catch (InterruptedException ie) {  \n       // 由于产生InterruptedException异常，退出while(true)循环，线程终止！\n   }\n}\n</code></pre><p><strong>说明</strong>：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！<br>注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   while (true) {\n       try {\n           // 执行任务...\n       } catch (InterruptedException ie) {  \n           // InterruptedException在while(true)循环体内。\n          // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出\n           break;\n       }\n   }\n}\n</code></pre><p>说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。</p>\n<h3 id=\"2-2-终止处于“运行状态”的线程\"><a href=\"#2-2-终止处于“运行状态”的线程\" class=\"headerlink\" title=\"2.2 终止处于“运行状态”的线程\"></a>2.2 终止处于“运行状态”的线程</h3><p>通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“<strong>中断标记</strong>”和“<strong>额外添加标记</strong>”。<br><strong>(01) 通过“中断标记”终止线程。</strong><br>形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   while (!isInterrupted()) {\n       // 执行任务...\n   }\n}\n</code></pre><p><strong>说明</strong>：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。<br><strong>注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。</strong></p>\n<p>上面上面说的可以通过一个小案例来测试:</p>\n<pre><code>package concurrent;\n\n/**************************************\n*      Author : zhangke\n*      Date   : 2018/7/12 20:09\n*      Desc   : \n***************************************/\npublic class InterruptedTest {\n   public static void main(String[] args) {\n       try {\n           Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is new.&quot;);\n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() + \n                   &quot; (&quot; + t1.getState() + &quot;) is started.&quot;);\n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(10);\n           t1.interrupt();\n           System.out.println(t1.getName() \n                       + &quot; (&quot; + t1.getState() + &quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() \n                       + &quot; (&quot; + t1.getState() + &quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n   }\n\n   static class MyThread extends Thread {\n\n       public MyThread(String name) {\n           super(name);\n       }\n\n       @Override\n       public void run() {\n\n           int i = 0;\n           while (!isInterrupted()) {\n               i++;\n               if (i % 100000 == 0)\n                   System.out.println(Thread.currentThread().getName() \n                           + &quot; (&quot; + this.getState() + &quot;) loop &quot; + i);\n           }\n           while (true) {\n               System.out.println(&quot;test&quot;);\n           }\n\n       }\n   }\n}\n\n\n</code></pre><p>运行结果:</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 100000\nt1 (RUNNABLE) loop 200000\ntest\ntest\ntest\ntest\ntest\ntest\ntest\n..........\n</code></pre><p>通过上面的例子可以看出，interrupt方法只是产生了中断标记，但是并没有暂停当前线程。否则就不会出现test这个字符</p>\n<p><strong>(02) 通过“额外添加标记”。</strong><br>形式如下：</p>\n<pre><code>private volatile boolean flag= true;\nprotected void stopTask() {\n   flag = false;\n}\n\n@Override\npublic void run() {\n   while (flag) {\n       // 执行任务...\n   }\n}\n</code></pre><p><strong>说明</strong>：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。<br>注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。</p>\n<p>综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   try {\n       // 1. isInterrupted()保证，只要中断标记为true就终止线程。\n       while (!isInterrupted()) {\n           // 执行任务...\n       }\n   } catch (InterruptedException ie) {  \n       // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。\n   }\n}\n</code></pre></blockquote>\n<h3 id=\"3-终止线程的示例\"><a href=\"#3-终止线程的示例\" class=\"headerlink\" title=\"3. 终止线程的示例\"></a><strong>3. 终止线程的示例</strong></h3><blockquote>\n<p>interrupt()常常被用来终止“阻塞状态”线程。参考下面示例：</p>\n<pre><code>// Demo1.java的源码\nclass MyThread extends Thread {\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       try {  \n           int i=0;\n           while (!isInterrupted()) {\n               Thread.sleep(100); // 休眠100ms\n               i++;\n               System.out.println(Thread.currentThread().getName()+&quot; \n               (&quot;+this.getState()+&quot;) loop &quot; + i);  \n           }\n       } catch (InterruptedException e) {  \n           System.out.println(Thread.currentThread().getName() +\n           &quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  \n       }\n   }\n}\n\npublic class Demo1 {\n\n   public static void main(String[] args) {  \n       try {  \n           Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  \n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  \n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(300);\n           t1.interrupt();\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() \n                   +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {  \n           e.printStackTrace();\n       }\n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) catch InterruptedException.\nt1 (TERMINATED) is interrupted now.\n</code></pre><p><strong>结果说明</strong>：<br>(01) 主线程main中通过new MyThread(“t1”)创建线程t1，之后通过t1.start()启动线程t1。<br>(02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。<br>(03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。</p>\n<p>我们对上面的结果进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。</p>\n<pre><code>// Demo2.java的源码\nclass MyThread extends Thread {\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       int i=0;\n       while (!isInterrupted()) {\n           try {\n               Thread.sleep(100); // 休眠100ms\n           } catch (InterruptedException ie) {  \n               System.out.println(Thread.currentThread().getName() \n                       +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  \n           }\n           i++;\n           System.out.println(Thread.currentThread().getName()+\n               &quot; (&quot;+this.getState()+&quot;) loop &quot; + i);  \n       }\n   }\n}\n\npublic class Demo2 {\n\n   public static void main(String[] args) {  \n       try {  \n           Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  \n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  \n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(300);\n           t1.interrupt();\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() +\n                       &quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {  \n           e.printStackTrace();\n       }\n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) catch InterruptedException.\nt1 (RUNNABLE) loop 3\nt1 (RUNNABLE) loop 4\nt1 (RUNNABLE) loop 5\nt1 (TIMED_WAITING) is interrupted now.\nt1 (RUNNABLE) loop 6\nt1 (RUNNABLE) loop 7\nt1 (RUNNABLE) loop 8\nt1 (RUNNABLE) loop 9\n...\n</code></pre><p><strong>结果说明</strong>：<br>程序进入了死循环！<br>为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。<br>解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。</p>\n<p>同时这个也说明interrupt只是产生了中断标记，并没有终止当前线程。</p>\n<p>下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例：</p>\n<pre><code>// Demo3.java的源码\nclass MyThread extends Thread {\n\n   private volatile boolean flag= true;\n   public void stopTask() {\n       flag = false;\n   }\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       synchronized(this) {\n           try {\n               int i=0;\n               while (flag) {\n                   Thread.sleep(100); // 休眠100ms\n                   i++;\n                   System.out.println(Thread.currentThread().getName()+\n                           &quot; (&quot;+this.getState()+&quot;) loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n               System.out.println(Thread.currentThread().getName() +\n                       &quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  \n           }\n       }  \n   }\n}\n\npublic class Demo3 {\n\n   public static void main(String[] args) {  \n       try {  \n           MyThread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  \n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  \n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(300);\n           t1.stopTask();\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {  \n           e.printStackTrace();\n       }\n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) loop 3\nt1 (TERMINATED) is interrupted now.\n</code></pre></blockquote>\n<h3 id=\"4-interrupted-和-isInterrupted-的区别\"><a href=\"#4-interrupted-和-isInterrupted-的区别\" class=\"headerlink\" title=\"4. interrupted() 和 isInterrupted()的区别\"></a><strong>4. interrupted() 和 isInterrupted()的区别</strong></h3><blockquote>\n<p>最后谈谈 interrupted() 和 isInterrupted()。<br>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。<br>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java多线程系列-05-interrupt-和线程终止方式\"><a href=\"#Java多线程系列-05-interrupt-和线程终止方式\" class=\"headerlink\" title=\"Java多线程系列 05 interrupt()和线程终止方式\"></a>Java多线程系列 05 interrupt()和线程终止方式</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>interrupt()说明</li>\n<li>终止线程的方式</li>\n<li>终止线程的示例</li>\n</ol>\n</blockquote>\n<h3 id=\"1-interrupt-说明\"><a href=\"#1-interrupt-说明\" class=\"headerlink\" title=\"1. interrupt()说明\"></a>1. interrupt()说明</h3><blockquote>\n<p>在介绍终止线程的方式之前，有必要先对interrupt()进行了解。<br>关于interrupt()，java的djk文档描述如下：<a href=\"http://docs.oracle.com/javase/7/docs/api/\" target=\"_blank\" rel=\"noopener\">http://docs.oracle.com/javase/7/docs/api/</a></p>\n<pre><code>Interrupts this thread.Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.\n\nIf this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.\n\nIf this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread&#39;s interrupt status will be set, and the thread will receive a ClosedByInterruptException.\n\nIf this thread is blocked in a Selector then the thread&#39;s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector&#39;s wakeup method were invoked.\n\nIf none of the previous conditions hold then this thread&#39;s interrupt status will be set.\n\nInterrupting a thread that is not alive need not have any effect.\n</code></pre><p>大致意思是：</p>\n<pre><code>interrupt()的作用是中断本线程。\n本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。\n如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。\n如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。\n如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。\n</code></pre></blockquote>\n<h3 id=\"2-终止线程的方式\"><a href=\"#2-终止线程的方式\" class=\"headerlink\" title=\"2. 终止线程的方式\"></a><strong>2. 终止线程的方式</strong></h3><blockquote>\n<p>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！ 下面，我先分别讨论线程在“阻塞状态”和“运行状态”的终止方式，然后再总结出一个通用的方式。</p>\n<h3 id=\"2-1-终止处于“阻塞状态”的线程\"><a href=\"#2-1-终止处于“阻塞状态”的线程\" class=\"headerlink\" title=\"2.1 终止处于“阻塞状态”的线程\"></a>2.1 终止处于“阻塞状态”的线程</h3><p>通常，我们通过“中断”方式终止处于“阻塞状态”的线程。<br>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的位置就能终止线程，形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   try {\n       while (true) {\n           // 执行任务...\n       }\n   } catch (InterruptedException ie) {  \n       // 由于产生InterruptedException异常，退出while(true)循环，线程终止！\n   }\n}\n</code></pre><p><strong>说明</strong>：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！<br>注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   while (true) {\n       try {\n           // 执行任务...\n       } catch (InterruptedException ie) {  \n           // InterruptedException在while(true)循环体内。\n          // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出\n           break;\n       }\n   }\n}\n</code></pre><p>说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。</p>\n<h3 id=\"2-2-终止处于“运行状态”的线程\"><a href=\"#2-2-终止处于“运行状态”的线程\" class=\"headerlink\" title=\"2.2 终止处于“运行状态”的线程\"></a>2.2 终止处于“运行状态”的线程</h3><p>通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“<strong>中断标记</strong>”和“<strong>额外添加标记</strong>”。<br><strong>(01) 通过“中断标记”终止线程。</strong><br>形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   while (!isInterrupted()) {\n       // 执行任务...\n   }\n}\n</code></pre><p><strong>说明</strong>：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。<br><strong>注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。</strong></p>\n<p>上面上面说的可以通过一个小案例来测试:</p>\n<pre><code>package concurrent;\n\n/**************************************\n*      Author : zhangke\n*      Date   : 2018/7/12 20:09\n*      Desc   : \n***************************************/\npublic class InterruptedTest {\n   public static void main(String[] args) {\n       try {\n           Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is new.&quot;);\n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() + \n                   &quot; (&quot; + t1.getState() + &quot;) is started.&quot;);\n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(10);\n           t1.interrupt();\n           System.out.println(t1.getName() \n                       + &quot; (&quot; + t1.getState() + &quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() \n                       + &quot; (&quot; + t1.getState() + &quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {\n           e.printStackTrace();\n       }\n\n   }\n\n   static class MyThread extends Thread {\n\n       public MyThread(String name) {\n           super(name);\n       }\n\n       @Override\n       public void run() {\n\n           int i = 0;\n           while (!isInterrupted()) {\n               i++;\n               if (i % 100000 == 0)\n                   System.out.println(Thread.currentThread().getName() \n                           + &quot; (&quot; + this.getState() + &quot;) loop &quot; + i);\n           }\n           while (true) {\n               System.out.println(&quot;test&quot;);\n           }\n\n       }\n   }\n}\n\n\n</code></pre><p>运行结果:</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 100000\nt1 (RUNNABLE) loop 200000\ntest\ntest\ntest\ntest\ntest\ntest\ntest\n..........\n</code></pre><p>通过上面的例子可以看出，interrupt方法只是产生了中断标记，但是并没有暂停当前线程。否则就不会出现test这个字符</p>\n<p><strong>(02) 通过“额外添加标记”。</strong><br>形式如下：</p>\n<pre><code>private volatile boolean flag= true;\nprotected void stopTask() {\n   flag = false;\n}\n\n@Override\npublic void run() {\n   while (flag) {\n       // 执行任务...\n   }\n}\n</code></pre><p><strong>说明</strong>：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。<br>注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。</p>\n<p>综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下：</p>\n<pre><code>@Override\npublic void run() {\n   try {\n       // 1. isInterrupted()保证，只要中断标记为true就终止线程。\n       while (!isInterrupted()) {\n           // 执行任务...\n       }\n   } catch (InterruptedException ie) {  \n       // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。\n   }\n}\n</code></pre></blockquote>\n<h3 id=\"3-终止线程的示例\"><a href=\"#3-终止线程的示例\" class=\"headerlink\" title=\"3. 终止线程的示例\"></a><strong>3. 终止线程的示例</strong></h3><blockquote>\n<p>interrupt()常常被用来终止“阻塞状态”线程。参考下面示例：</p>\n<pre><code>// Demo1.java的源码\nclass MyThread extends Thread {\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       try {  \n           int i=0;\n           while (!isInterrupted()) {\n               Thread.sleep(100); // 休眠100ms\n               i++;\n               System.out.println(Thread.currentThread().getName()+&quot; \n               (&quot;+this.getState()+&quot;) loop &quot; + i);  \n           }\n       } catch (InterruptedException e) {  \n           System.out.println(Thread.currentThread().getName() +\n           &quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  \n       }\n   }\n}\n\npublic class Demo1 {\n\n   public static void main(String[] args) {  \n       try {  \n           Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  \n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  \n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(300);\n           t1.interrupt();\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() \n                   +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {  \n           e.printStackTrace();\n       }\n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) catch InterruptedException.\nt1 (TERMINATED) is interrupted now.\n</code></pre><p><strong>结果说明</strong>：<br>(01) 主线程main中通过new MyThread(“t1”)创建线程t1，之后通过t1.start()启动线程t1。<br>(02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。<br>(03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。</p>\n<p>我们对上面的结果进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。</p>\n<pre><code>// Demo2.java的源码\nclass MyThread extends Thread {\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       int i=0;\n       while (!isInterrupted()) {\n           try {\n               Thread.sleep(100); // 休眠100ms\n           } catch (InterruptedException ie) {  \n               System.out.println(Thread.currentThread().getName() \n                       +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  \n           }\n           i++;\n           System.out.println(Thread.currentThread().getName()+\n               &quot; (&quot;+this.getState()+&quot;) loop &quot; + i);  \n       }\n   }\n}\n\npublic class Demo2 {\n\n   public static void main(String[] args) {  \n       try {  \n           Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  \n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  \n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(300);\n           t1.interrupt();\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() +\n                       &quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {  \n           e.printStackTrace();\n       }\n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) catch InterruptedException.\nt1 (RUNNABLE) loop 3\nt1 (RUNNABLE) loop 4\nt1 (RUNNABLE) loop 5\nt1 (TIMED_WAITING) is interrupted now.\nt1 (RUNNABLE) loop 6\nt1 (RUNNABLE) loop 7\nt1 (RUNNABLE) loop 8\nt1 (RUNNABLE) loop 9\n...\n</code></pre><p><strong>结果说明</strong>：<br>程序进入了死循环！<br>为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。<br>解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。</p>\n<p>同时这个也说明interrupt只是产生了中断标记，并没有终止当前线程。</p>\n<p>下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例：</p>\n<pre><code>// Demo3.java的源码\nclass MyThread extends Thread {\n\n   private volatile boolean flag= true;\n   public void stopTask() {\n       flag = false;\n   }\n\n   public MyThread(String name) {\n       super(name);\n   }\n\n   @Override\n   public void run() {\n       synchronized(this) {\n           try {\n               int i=0;\n               while (flag) {\n                   Thread.sleep(100); // 休眠100ms\n                   i++;\n                   System.out.println(Thread.currentThread().getName()+\n                           &quot; (&quot;+this.getState()+&quot;) loop &quot; + i);  \n               }\n           } catch (InterruptedException ie) {  \n               System.out.println(Thread.currentThread().getName() +\n                       &quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  \n           }\n       }  \n   }\n}\n\npublic class Demo3 {\n\n   public static void main(String[] args) {  \n       try {  \n           MyThread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  \n\n           t1.start();                      // 启动“线程t1”\n           System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  \n\n           // 主线程休眠300ms，然后主线程给t1发“中断”指令。\n           Thread.sleep(300);\n           t1.stopTask();\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);\n\n           // 主线程休眠300ms，然后查看t1的状态。\n           Thread.sleep(300);\n           System.out.println(t1.getName() +\n                   &quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);\n       } catch (InterruptedException e) {  \n           e.printStackTrace();\n       }\n   } \n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>t1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) loop 3\nt1 (TERMINATED) is interrupted now.\n</code></pre></blockquote>\n<h3 id=\"4-interrupted-和-isInterrupted-的区别\"><a href=\"#4-interrupted-和-isInterrupted-的区别\" class=\"headerlink\" title=\"4. interrupted() 和 isInterrupted()的区别\"></a><strong>4. interrupted() 和 isInterrupted()的区别</strong></h3><blockquote>\n<p>最后谈谈 interrupted() 和 isInterrupted()。<br>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。<br>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。</p>\n</blockquote>\n"},{"abbrlink":16,"title":"伪共享（false sharing）并发编程无声的性能杀手","author":"zhangke","date":"2018-04-10T11:41:00.000Z","_content":"# 伪共享（false sharing），并发编程无声的性能杀手\n\n在并发编程过程中，我们大部分的焦点都放在如何控制共享变量的访问控制上（代码层面），但是很少人会关注系统硬件及 JVM 底层相关的影响因素。前段时间学习了一个牛X的高性能异步处理框架 Disruptor，它被誉为“最快的消息框架”，其 LMAX 架构能够在一个线程里每秒处理 6百万 订单！在讲到 Disruptor 为什么这么快时，接触到了一个概念——伪共享( false sharing )，其中提到：缓存行上的写竞争是运行在 SMP 系统中并行线程实现可伸缩性最重要的限制因素。由于从代码中很难看出是否会出现伪共享，有人将其描述成无声的性能杀手。\n\n本文仅针对目前所学进行合并整理，目前并无非常深入地研究和实践，希望对大家从零开始理解伪共享提供一些帮助。\n\n> 伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。\n\n下面我们就来详细剖析伪共享产生的前因后果。首先，我们要了解什么是缓存系统。\n\n###  \n\n## **一、CPU 缓存**\n\nCPU 缓存的百度百科定义为：\n\nCPU 缓存（Cache Memory）是位于 CPU 与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。\n高速缓存的出现主要是为了解决 CPU 运算速度与内存读写速度不匹配的矛盾，因为 CPU 运算速度要比内存读写速度快很多，这样会使 CPU 花费很长时间等待数据到来或把数据写入内存。\n在缓存中的数据是内存中的一小部分，但这一小部分是短时间内 CPU 即将访问的，当 CPU 调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。\n\nCPU 和主内存之间有好几层缓存，因为即使直接访问主内存也是非常慢的。如果你正在多次对一块数据做相同的运算，那么在执行运算的时候把它加载到离 CPU 很近的地方就有意义了。\n\n按照数据读取顺序和与 CPU 结合的紧密程度，CPU 缓存可以分为一级缓存，二级缓存，部分高端 CPU 还具有三级缓存。每一级缓存中所储存的全部数据都是下一级缓存的一部分，越靠近 CPU 的缓存越快也越小。所以 L1 缓存很小但很快(译注：L1 表示一级缓存)，并且紧靠着在使用它的 CPU 内核。L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。拥有三级缓存的的 CPU，到三级缓存时能够达到 95% 的命中率，只有不到 5% 的数据需要从内存中查询。\n\n多核机器的存储结构如下图所示：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201221667-1059026925.png)\n\n当 CPU 执行运算的时候，它先去 L1 查找所需的数据，再去 L2，然后是 L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要确保数据在 L1 缓存中。\n\nMartin Thompson 给出了一些缓存未命中的消耗数据，如下所示：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201305464-895015043.png)\n\n## **二、MESI 协议及 RFO 请求**\n\n从上一节中我们知道，每个核都有自己私有的 L1,、L2 缓存。那么多线程编程时, 另外一个核的线程想要访问当前核内 L1、L2 缓存行的数据, 该怎么办呢？\n\n有人说可以通过第 2 个核直接访问第 1 个核的缓存行，这是当然是可行的，但这种方法不够快。跨核访问需要通过 Memory Controller（内存控制器，是计算机系统内部控制内存并且通过内存控制器使内存与 CPU 之间交换数据的重要组成部分），典型的情况是第 2 个核经常访问第 1 个核的这条数据，那么每次都有跨核的消耗.。更糟的情况是，有可能第 2 个核与第 1 个核不在一个插槽内，况且 Memory Controller 的总线带宽是有限的，扛不住这么多数据传输。所以，CPU 设计者们更偏向于另一种办法： 如果第 2 个核需要这份数据，由第 1 个核直接把数据内容发过去，数据只需要传一次。\n\n那么什么时候会发生缓存行的传输呢？答案很简单：当一个核需要读取另外一个核的脏缓存行时发生。但是前者怎么判断后者的缓存行已经被弄脏(写)了呢？\n\n下面将详细地解答以上问题. 首先我们需要谈到一个协议—— MESI 协议。现在主流的处理器都是用它来保证缓存的相干性和内存的相干性。M、E、S 和 I 代表使用 MESI 协议时缓存行所处的四个状态：\n\n* M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；\n* E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；\n* S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；\n* I（无效，Invalid）：缓存行失效, 不能使用。\n\n下面说明这四个状态是如何转换的：\n\n初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。\n\n本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。\n\n本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）\n\n远程读（Remote Read）：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。\n\n远程写（Remote Write）：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。\n\n状态转换由下图做个补充：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201649808-555029301.png)\n\n我们从上节知道，写操作的代价很高，特别当需要发送 RFO 消息时。我们编写程序时，什么时候会发生 RFO 请求呢？有以下两种：\n\n1. 线程的工作从一个处理器移到另一个处理器, 它操作的所有缓存行都需要移到新的处理器上。此后如果再写缓存行，则此缓存行在不同核上有多个拷贝，需要发送 RFO 请求了。\n2. 两个不同的处理器确实都需要操作相同的缓存行\n\n接下来，我们要了解什么是缓存行。\n\n## **缓存行**\n\n为了高效地存取缓存, 不是简单随意地将单条数据写入缓存的.  缓存是由缓存行组成的, 典型的一行是64字节. 读者可以通过下面的shell命令,查看cherency_line_size就知道知道机器的缓存行是多大. \n\n```\n cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size   \n 64  \n```\n\nCPU存取缓存都是按行为最小单位操作的. 在这儿我将不提及缓存的associativity问题, 将问题简化一些. 一个Java long型占8字节, 所以从一条缓存行上你可以获取到8个long型变量. 所以如果你访问一个long型数组, 当有一个long被加载到cache中, 你将无消耗地加载了另外7个. 所以你可以非常快地遍历数组.\n\n下面是利用缓存行来进行的对比实验代码\n\n```java\npublic class L1CacheMiss {  \n    private static final int RUNS = 10;  \n    private static final int DIMENSION_1 = 1024 * 1024;  \n    private static final int DIMENSION_2 = 62;  \n  \n    private static long[][] longs;  \n  \n    public static void main(String[] args) throws Exception {  \n        Thread.sleep(10000);  \n        longs = new long[DIMENSION_1][];  \n        for (int i = 0; i < DIMENSION_1; i++) {  \n            longs[i] = new long[DIMENSION_2];  \n            for (int j = 0; j < DIMENSION_2; j++) {  \n                longs[i][j] = 0L;  \n            }  \n        }  \n        System.out.println(\"starting....\");  \n  \n        final long start = System.nanoTime();  \n        long sum = 0L;  \n        for (int r = 0; r < RUNS; r++) {  \n//          for (int j = 0; j < DIMENSION_2; j++) {  \n//              for (int i = 0; i < DIMENSION_1; i++) {  \n//                  sum += longs[i][j];  \n//              }  \n//          }  \n  \n            for (int i = 0; i < DIMENSION_1; i++) {  \n                for (int j = 0; j < DIMENSION_2; j++) {  \n                    sum += longs[i][j];  \n                }  \n            }  \n        }  \n        System.out.println(\"duration = \" + (System.nanoTime() - start));  \n    }  \n}  \n```\n\n编译运行得到的结果如下\n\n```\n    starting....\n    duration =  850623099\n```\n\n然后我们将22-26行的注释取消, 将28-32行注释, 编译后再次运行,结果是不是比我们预想得还糟? \n\n```\nstarting....\nduration = 8078753353\n```\n\n通过对比可以看出，第二个花的时间是第一个的10倍还多。从上节我们可以知道在加载longs\\[i][j]时, longs\\[i][j+1]很可能也会被加载至cache中, 所以立即访问longs\\[i][j+1]将会命中L1 Cache, 而如果你访问longs\\[i+1][j]情况就不一样了, 这时候很可能会产生 cache miss导致效率低下. \n\n以上我只是示例了在L1 Cache满了之后才会发生的cache miss. 其实cache miss的原因有下面三种: \n\n1. 第一次访问数据, 在cache中根本不存在这条数据, 所以cache miss, 可以通过prefetch解决. \n2. cache冲突, 需要通过补齐来解决. \n3. 就是我示例的这种, cache满, 一般情况下我们需要减少操作的数据大小, 尽量按数据的物理顺序访问数据\n\n## 四、伪共享\n\n在文章开头提到过，缓存系统中是以缓存行（cache line）为单位存储的。缓存行通常是 64 字节（译注：本文基于 64 字节，其他长度的如 32 字节等不适本文讨论的重点），并且它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。所以，如果你访问一个 long 数组，当数组中的一个值被加载到缓存中，它会额外加载另外 7 个，以致你能非常快地遍历这个数组。事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构。而如果你在数据结构中的项在内存中不是彼此相邻的（如链表），你将得不到免费缓存加载所带来的优势，并且在这些数据结构中的每一个项都可能会出现缓存未命中。\n\n如果存在这样的场景，有多个线程操作不同的成员变量，但是相同的缓存行，这个时候会发生什么？。没错，伪共享（False Sharing）问题就发生了！有张 Disruptor 项目的经典示例图，如下：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202002573-736704844.png)\n\n上图中，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送 RFO 消息，占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。\n\n表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。\n\n## *五、遭遇伪共享*\n\n好的，那么接下来我们就用 code 来进行实验和佐证。\n\n```\npublic class FalseShareTest implements Runnable {\n    public static int NUM_THREADS = 4;\n    public final static long ITERATIONS = 500L * 1000L * 1000L;\n    private final int arrayIndex;\n    private static VolatileLong[] longs;\n    public static long SUM_TIME = 0l;\n    public FalseShareTest(final int arrayIndex) {\n        this.arrayIndex = arrayIndex;\n    }\n    public static void main(final String[] args) throws Exception {\n        Thread.sleep(10000);\n        for(int j=0; j<10; j++){\n            System.out.println(j);\n            if (args.length == 1) {\n                NUM_THREADS = Integer.parseInt(args[0]);\n            }\n            longs = new VolatileLong[NUM_THREADS];\n            for (int i = 0; i < longs.length; i++) {\n                longs[i] = new VolatileLong();\n            }\n            final long start = System.nanoTime();\n            runTest();\n            final long end = System.nanoTime();\n            SUM_TIME += end - start;\n        }\n        System.out.println(\"平均耗时：\"+SUM_TIME/10);\n    }\n    private static void runTest() throws InterruptedException {\n        Thread[] threads = new Thread[NUM_THREADS];\n        for (int i = 0; i < threads.length; i++) {\n            threads[i] = new Thread(new FalseShareTest(i));\n        }\n        for (Thread t : threads) {\n            t.start();\n        }\n        for (Thread t : threads) {\n            t.join();\n        }\n    }\n    public void run() {\n        long i = ITERATIONS + 1;\n        while (0 != --i) {\n            longs[arrayIndex].value = i;\n        }\n    }\n    public final static class VolatileLong {\n        public volatile long value = 0L;\n        public long p1, p2, p3, p4, p5, p6;     //屏蔽此行\n    }\n}\n```\n\n上述代码的逻辑很简单，就是四个线程修改一数组不同元素的内容。元素的类型是 VolatileLong，只有一个长整型成员 value 和 6 个没用到的长整型成员。value 设为 volatile 是为了让 value 的修改对所有线程都可见。程序分两种情况执行，第一种情况为不屏蔽倒数第三行（见”屏蔽此行”字样），第二种情况为屏蔽倒数第三行。为了”保证”数据的相对可靠性，程序取 10 次执行的平均时间。执行情况如下（执行环境：32位 windows，四核，8GB 内存）：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202253714-555001087.png)         ![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202308245-492044780.png)\n\n（不屏蔽）                                                          （屏蔽）\n\n两个逻辑一模一样的程序，前者的耗时大概是后者的 2.5 倍，这太不可思议了！那么这个时候，我们再用伪共享（False Sharing）的理论来分析一下。前者 longs 数组的 4 个元素，由于 VolatileLong 只有 1 个长整型成员，所以整个数组都将被加载至同一缓存行，但有4个线程同时操作这条缓存行，于是伪共享就悄悄地发生了。\n\n基于此，我们有理由相信，在一定线程数量范围内（注意思考：为什么强调是一定线程数量范围内），随着线程数量的增加，伪共享发生的频率也越大，直观体现就是执行时间越长。为了证实这个观点，本人在同样的机器上分别用单线程、2、4、8个线程，对有填充和无填充两种情况进行测试。执行场景是取 10 次执行的平均时间，结果如下所示：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202449620-46958750.png)\n\n## 六、如何避免伪共享？**\n\n> 其中一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可。\n\n那么该如何做到呢？其实在我们注释的那行代码中就有答案，那就是缓存行填充（Padding） 。现在分析上面的例子，我们知道一条缓存行有 64 字节，而 Java 程序的对象头固定占 8 字节(32位系统)或 12 字节( 64 位系统默认开启压缩, 不开压缩为 16 字节)，所以我们只需要填 6 个无用的长整型补上6*8=48字节，让不同的 VolatileLong 对象处于不同的缓存行，就避免了伪共享( 64 位系统超过缓存行的 64 字节也无所谓，只要保证不同线程不操作同一缓存行就可以)。\n\n伪共享在多核编程中很容易发生，而且非常隐蔽。例如，在 JDK 的 LinkedBlockingQueue 中，存在指向队列头的引用 head 和指向队列尾的引用 tail 。而这种队列经常在异步编程中使有，这两个引用的值经常的被不同的线程修改，但它们却很可能在同一个缓存行，于是就产生了伪共享。线程越多，核越多，对性能产生的负面效果就越大。\n\n由于某些 Java 编译器的优化策略，那些没有使用到的补齐数据可能会在编译期间被优化掉，我们可以在程序中加入一些代码防止被编译优化。如下：\n\n```\npublic static long preventFromOptimization(VolatileLong v) {  \n        return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;  \n}\n```\n\n> 另外一种技术是使用编译指示，来强制使每一个变量对齐。\n\n下面的代码显式了编译器使用__declspec( align(n) ) 此处 n=64，按照 cache line 边界对齐。\n\n```\n__declspec (align(64)) int thread1_global_variable;\n__declspec (align(64)) int thread2_global_variable;\n```\n\n当使用数组时，在 cache line 尾部填充 padding 来保证数据元素在 cache line 边界开始。如果不能够保证数组按照 cache line 边界对齐，填充数据结构【数组元素】使之是 cache line 大小的两倍。下面的代码显式了填充数据结构使之按照 cache line 对齐。并且通过 __declspec( align(n) ) 语句来保证数组也是对齐的。如果数组是动态分配的，你可以增加分配的大小，并调整指针来对其到 cache line 边界。\n\n```\nstruct ThreadParams\n{\n    // For the following 4 variables: 4*4 = 16 bytes\n    unsigned long thread_id;\n    unsigned long v; // Frequent read/write access variable\n    unsigned long start;\n    unsigned long end;\n    // expand to 64 bytes to avoid false-sharing \n    // (4 unsigned long variables + 12 padding)*4 = 64\n    int padding[12];\n};\n```\n\n除此之外，在网上还有很多对伪共享的研究，提出了一些基于数据融合的方案，有兴趣的同学可以了解下。\n\n## 七、对于伪共享，我们在实际开发中该怎么做？**\n\n通过上面大篇幅的介绍，我们已经知道伪共享的对程序的影响。那么，在实际的生产开发过程中，我们一定要通过缓存行填充去解决掉潜在的伪共享问题吗？\n\n其实并不一定。\n\n首先就是多次强调的，伪共享是很隐蔽的，我们暂时无法从系统层面上通过工具来探测伪共享事件。其次，不同类型的计算机具有不同的微架构（如 32 位系统和 64 位系统的 java 对象所占自己数就不一样），如果设计到跨平台的设计，那就更难以把握了，一个确切的填充方案只适用于一个特定的操作系统。还有，缓存的资源是有限的，如果填充会浪费珍贵的 cache 资源，并不适合大范围应用。最后，目前主流的 Intel 微架构 CPU 的 L1 缓存，已能够达到 80% 以上的命中率。\n\n综上所述，并不是每个系统都适合花大量精力去解决潜在的伪共享问题。\n\n","source":"_posts/伪缓存.md","raw":"abbrlink: 16\ntitle: 伪共享（false sharing）并发编程无声的性能杀手\ntags:\n  - 操作系统\ncategories:\n  - 操作系统\nauthor: zhangke\ndate: 2018-04-10 19:41:00\n---\n# 伪共享（false sharing），并发编程无声的性能杀手\n\n在并发编程过程中，我们大部分的焦点都放在如何控制共享变量的访问控制上（代码层面），但是很少人会关注系统硬件及 JVM 底层相关的影响因素。前段时间学习了一个牛X的高性能异步处理框架 Disruptor，它被誉为“最快的消息框架”，其 LMAX 架构能够在一个线程里每秒处理 6百万 订单！在讲到 Disruptor 为什么这么快时，接触到了一个概念——伪共享( false sharing )，其中提到：缓存行上的写竞争是运行在 SMP 系统中并行线程实现可伸缩性最重要的限制因素。由于从代码中很难看出是否会出现伪共享，有人将其描述成无声的性能杀手。\n\n本文仅针对目前所学进行合并整理，目前并无非常深入地研究和实践，希望对大家从零开始理解伪共享提供一些帮助。\n\n> 伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。\n\n下面我们就来详细剖析伪共享产生的前因后果。首先，我们要了解什么是缓存系统。\n\n###  \n\n## **一、CPU 缓存**\n\nCPU 缓存的百度百科定义为：\n\nCPU 缓存（Cache Memory）是位于 CPU 与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。\n高速缓存的出现主要是为了解决 CPU 运算速度与内存读写速度不匹配的矛盾，因为 CPU 运算速度要比内存读写速度快很多，这样会使 CPU 花费很长时间等待数据到来或把数据写入内存。\n在缓存中的数据是内存中的一小部分，但这一小部分是短时间内 CPU 即将访问的，当 CPU 调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。\n\nCPU 和主内存之间有好几层缓存，因为即使直接访问主内存也是非常慢的。如果你正在多次对一块数据做相同的运算，那么在执行运算的时候把它加载到离 CPU 很近的地方就有意义了。\n\n按照数据读取顺序和与 CPU 结合的紧密程度，CPU 缓存可以分为一级缓存，二级缓存，部分高端 CPU 还具有三级缓存。每一级缓存中所储存的全部数据都是下一级缓存的一部分，越靠近 CPU 的缓存越快也越小。所以 L1 缓存很小但很快(译注：L1 表示一级缓存)，并且紧靠着在使用它的 CPU 内核。L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。拥有三级缓存的的 CPU，到三级缓存时能够达到 95% 的命中率，只有不到 5% 的数据需要从内存中查询。\n\n多核机器的存储结构如下图所示：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201221667-1059026925.png)\n\n当 CPU 执行运算的时候，它先去 L1 查找所需的数据，再去 L2，然后是 L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要确保数据在 L1 缓存中。\n\nMartin Thompson 给出了一些缓存未命中的消耗数据，如下所示：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201305464-895015043.png)\n\n## **二、MESI 协议及 RFO 请求**\n\n从上一节中我们知道，每个核都有自己私有的 L1,、L2 缓存。那么多线程编程时, 另外一个核的线程想要访问当前核内 L1、L2 缓存行的数据, 该怎么办呢？\n\n有人说可以通过第 2 个核直接访问第 1 个核的缓存行，这是当然是可行的，但这种方法不够快。跨核访问需要通过 Memory Controller（内存控制器，是计算机系统内部控制内存并且通过内存控制器使内存与 CPU 之间交换数据的重要组成部分），典型的情况是第 2 个核经常访问第 1 个核的这条数据，那么每次都有跨核的消耗.。更糟的情况是，有可能第 2 个核与第 1 个核不在一个插槽内，况且 Memory Controller 的总线带宽是有限的，扛不住这么多数据传输。所以，CPU 设计者们更偏向于另一种办法： 如果第 2 个核需要这份数据，由第 1 个核直接把数据内容发过去，数据只需要传一次。\n\n那么什么时候会发生缓存行的传输呢？答案很简单：当一个核需要读取另外一个核的脏缓存行时发生。但是前者怎么判断后者的缓存行已经被弄脏(写)了呢？\n\n下面将详细地解答以上问题. 首先我们需要谈到一个协议—— MESI 协议。现在主流的处理器都是用它来保证缓存的相干性和内存的相干性。M、E、S 和 I 代表使用 MESI 协议时缓存行所处的四个状态：\n\n* M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；\n* E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；\n* S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；\n* I（无效，Invalid）：缓存行失效, 不能使用。\n\n下面说明这四个状态是如何转换的：\n\n初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。\n\n本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。\n\n本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）\n\n远程读（Remote Read）：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。\n\n远程写（Remote Write）：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。\n\n状态转换由下图做个补充：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201649808-555029301.png)\n\n我们从上节知道，写操作的代价很高，特别当需要发送 RFO 消息时。我们编写程序时，什么时候会发生 RFO 请求呢？有以下两种：\n\n1. 线程的工作从一个处理器移到另一个处理器, 它操作的所有缓存行都需要移到新的处理器上。此后如果再写缓存行，则此缓存行在不同核上有多个拷贝，需要发送 RFO 请求了。\n2. 两个不同的处理器确实都需要操作相同的缓存行\n\n接下来，我们要了解什么是缓存行。\n\n## **缓存行**\n\n为了高效地存取缓存, 不是简单随意地将单条数据写入缓存的.  缓存是由缓存行组成的, 典型的一行是64字节. 读者可以通过下面的shell命令,查看cherency_line_size就知道知道机器的缓存行是多大. \n\n```\n cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size   \n 64  \n```\n\nCPU存取缓存都是按行为最小单位操作的. 在这儿我将不提及缓存的associativity问题, 将问题简化一些. 一个Java long型占8字节, 所以从一条缓存行上你可以获取到8个long型变量. 所以如果你访问一个long型数组, 当有一个long被加载到cache中, 你将无消耗地加载了另外7个. 所以你可以非常快地遍历数组.\n\n下面是利用缓存行来进行的对比实验代码\n\n```java\npublic class L1CacheMiss {  \n    private static final int RUNS = 10;  \n    private static final int DIMENSION_1 = 1024 * 1024;  \n    private static final int DIMENSION_2 = 62;  \n  \n    private static long[][] longs;  \n  \n    public static void main(String[] args) throws Exception {  \n        Thread.sleep(10000);  \n        longs = new long[DIMENSION_1][];  \n        for (int i = 0; i < DIMENSION_1; i++) {  \n            longs[i] = new long[DIMENSION_2];  \n            for (int j = 0; j < DIMENSION_2; j++) {  \n                longs[i][j] = 0L;  \n            }  \n        }  \n        System.out.println(\"starting....\");  \n  \n        final long start = System.nanoTime();  \n        long sum = 0L;  \n        for (int r = 0; r < RUNS; r++) {  \n//          for (int j = 0; j < DIMENSION_2; j++) {  \n//              for (int i = 0; i < DIMENSION_1; i++) {  \n//                  sum += longs[i][j];  \n//              }  \n//          }  \n  \n            for (int i = 0; i < DIMENSION_1; i++) {  \n                for (int j = 0; j < DIMENSION_2; j++) {  \n                    sum += longs[i][j];  \n                }  \n            }  \n        }  \n        System.out.println(\"duration = \" + (System.nanoTime() - start));  \n    }  \n}  \n```\n\n编译运行得到的结果如下\n\n```\n    starting....\n    duration =  850623099\n```\n\n然后我们将22-26行的注释取消, 将28-32行注释, 编译后再次运行,结果是不是比我们预想得还糟? \n\n```\nstarting....\nduration = 8078753353\n```\n\n通过对比可以看出，第二个花的时间是第一个的10倍还多。从上节我们可以知道在加载longs\\[i][j]时, longs\\[i][j+1]很可能也会被加载至cache中, 所以立即访问longs\\[i][j+1]将会命中L1 Cache, 而如果你访问longs\\[i+1][j]情况就不一样了, 这时候很可能会产生 cache miss导致效率低下. \n\n以上我只是示例了在L1 Cache满了之后才会发生的cache miss. 其实cache miss的原因有下面三种: \n\n1. 第一次访问数据, 在cache中根本不存在这条数据, 所以cache miss, 可以通过prefetch解决. \n2. cache冲突, 需要通过补齐来解决. \n3. 就是我示例的这种, cache满, 一般情况下我们需要减少操作的数据大小, 尽量按数据的物理顺序访问数据\n\n## 四、伪共享\n\n在文章开头提到过，缓存系统中是以缓存行（cache line）为单位存储的。缓存行通常是 64 字节（译注：本文基于 64 字节，其他长度的如 32 字节等不适本文讨论的重点），并且它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。所以，如果你访问一个 long 数组，当数组中的一个值被加载到缓存中，它会额外加载另外 7 个，以致你能非常快地遍历这个数组。事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构。而如果你在数据结构中的项在内存中不是彼此相邻的（如链表），你将得不到免费缓存加载所带来的优势，并且在这些数据结构中的每一个项都可能会出现缓存未命中。\n\n如果存在这样的场景，有多个线程操作不同的成员变量，但是相同的缓存行，这个时候会发生什么？。没错，伪共享（False Sharing）问题就发生了！有张 Disruptor 项目的经典示例图，如下：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202002573-736704844.png)\n\n上图中，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送 RFO 消息，占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。\n\n表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。\n\n## *五、遭遇伪共享*\n\n好的，那么接下来我们就用 code 来进行实验和佐证。\n\n```\npublic class FalseShareTest implements Runnable {\n    public static int NUM_THREADS = 4;\n    public final static long ITERATIONS = 500L * 1000L * 1000L;\n    private final int arrayIndex;\n    private static VolatileLong[] longs;\n    public static long SUM_TIME = 0l;\n    public FalseShareTest(final int arrayIndex) {\n        this.arrayIndex = arrayIndex;\n    }\n    public static void main(final String[] args) throws Exception {\n        Thread.sleep(10000);\n        for(int j=0; j<10; j++){\n            System.out.println(j);\n            if (args.length == 1) {\n                NUM_THREADS = Integer.parseInt(args[0]);\n            }\n            longs = new VolatileLong[NUM_THREADS];\n            for (int i = 0; i < longs.length; i++) {\n                longs[i] = new VolatileLong();\n            }\n            final long start = System.nanoTime();\n            runTest();\n            final long end = System.nanoTime();\n            SUM_TIME += end - start;\n        }\n        System.out.println(\"平均耗时：\"+SUM_TIME/10);\n    }\n    private static void runTest() throws InterruptedException {\n        Thread[] threads = new Thread[NUM_THREADS];\n        for (int i = 0; i < threads.length; i++) {\n            threads[i] = new Thread(new FalseShareTest(i));\n        }\n        for (Thread t : threads) {\n            t.start();\n        }\n        for (Thread t : threads) {\n            t.join();\n        }\n    }\n    public void run() {\n        long i = ITERATIONS + 1;\n        while (0 != --i) {\n            longs[arrayIndex].value = i;\n        }\n    }\n    public final static class VolatileLong {\n        public volatile long value = 0L;\n        public long p1, p2, p3, p4, p5, p6;     //屏蔽此行\n    }\n}\n```\n\n上述代码的逻辑很简单，就是四个线程修改一数组不同元素的内容。元素的类型是 VolatileLong，只有一个长整型成员 value 和 6 个没用到的长整型成员。value 设为 volatile 是为了让 value 的修改对所有线程都可见。程序分两种情况执行，第一种情况为不屏蔽倒数第三行（见”屏蔽此行”字样），第二种情况为屏蔽倒数第三行。为了”保证”数据的相对可靠性，程序取 10 次执行的平均时间。执行情况如下（执行环境：32位 windows，四核，8GB 内存）：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202253714-555001087.png)         ![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202308245-492044780.png)\n\n（不屏蔽）                                                          （屏蔽）\n\n两个逻辑一模一样的程序，前者的耗时大概是后者的 2.5 倍，这太不可思议了！那么这个时候，我们再用伪共享（False Sharing）的理论来分析一下。前者 longs 数组的 4 个元素，由于 VolatileLong 只有 1 个长整型成员，所以整个数组都将被加载至同一缓存行，但有4个线程同时操作这条缓存行，于是伪共享就悄悄地发生了。\n\n基于此，我们有理由相信，在一定线程数量范围内（注意思考：为什么强调是一定线程数量范围内），随着线程数量的增加，伪共享发生的频率也越大，直观体现就是执行时间越长。为了证实这个观点，本人在同样的机器上分别用单线程、2、4、8个线程，对有填充和无填充两种情况进行测试。执行场景是取 10 次执行的平均时间，结果如下所示：\n\n![img](http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202449620-46958750.png)\n\n## 六、如何避免伪共享？**\n\n> 其中一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可。\n\n那么该如何做到呢？其实在我们注释的那行代码中就有答案，那就是缓存行填充（Padding） 。现在分析上面的例子，我们知道一条缓存行有 64 字节，而 Java 程序的对象头固定占 8 字节(32位系统)或 12 字节( 64 位系统默认开启压缩, 不开压缩为 16 字节)，所以我们只需要填 6 个无用的长整型补上6*8=48字节，让不同的 VolatileLong 对象处于不同的缓存行，就避免了伪共享( 64 位系统超过缓存行的 64 字节也无所谓，只要保证不同线程不操作同一缓存行就可以)。\n\n伪共享在多核编程中很容易发生，而且非常隐蔽。例如，在 JDK 的 LinkedBlockingQueue 中，存在指向队列头的引用 head 和指向队列尾的引用 tail 。而这种队列经常在异步编程中使有，这两个引用的值经常的被不同的线程修改，但它们却很可能在同一个缓存行，于是就产生了伪共享。线程越多，核越多，对性能产生的负面效果就越大。\n\n由于某些 Java 编译器的优化策略，那些没有使用到的补齐数据可能会在编译期间被优化掉，我们可以在程序中加入一些代码防止被编译优化。如下：\n\n```\npublic static long preventFromOptimization(VolatileLong v) {  \n        return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;  \n}\n```\n\n> 另外一种技术是使用编译指示，来强制使每一个变量对齐。\n\n下面的代码显式了编译器使用__declspec( align(n) ) 此处 n=64，按照 cache line 边界对齐。\n\n```\n__declspec (align(64)) int thread1_global_variable;\n__declspec (align(64)) int thread2_global_variable;\n```\n\n当使用数组时，在 cache line 尾部填充 padding 来保证数据元素在 cache line 边界开始。如果不能够保证数组按照 cache line 边界对齐，填充数据结构【数组元素】使之是 cache line 大小的两倍。下面的代码显式了填充数据结构使之按照 cache line 对齐。并且通过 __declspec( align(n) ) 语句来保证数组也是对齐的。如果数组是动态分配的，你可以增加分配的大小，并调整指针来对其到 cache line 边界。\n\n```\nstruct ThreadParams\n{\n    // For the following 4 variables: 4*4 = 16 bytes\n    unsigned long thread_id;\n    unsigned long v; // Frequent read/write access variable\n    unsigned long start;\n    unsigned long end;\n    // expand to 64 bytes to avoid false-sharing \n    // (4 unsigned long variables + 12 padding)*4 = 64\n    int padding[12];\n};\n```\n\n除此之外，在网上还有很多对伪共享的研究，提出了一些基于数据融合的方案，有兴趣的同学可以了解下。\n\n## 七、对于伪共享，我们在实际开发中该怎么做？**\n\n通过上面大篇幅的介绍，我们已经知道伪共享的对程序的影响。那么，在实际的生产开发过程中，我们一定要通过缓存行填充去解决掉潜在的伪共享问题吗？\n\n其实并不一定。\n\n首先就是多次强调的，伪共享是很隐蔽的，我们暂时无法从系统层面上通过工具来探测伪共享事件。其次，不同类型的计算机具有不同的微架构（如 32 位系统和 64 位系统的 java 对象所占自己数就不一样），如果设计到跨平台的设计，那就更难以把握了，一个确切的填充方案只适用于一个特定的操作系统。还有，缓存的资源是有限的，如果填充会浪费珍贵的 cache 资源，并不适合大范围应用。最后，目前主流的 Intel 微架构 CPU 的 L1 缓存，已能够达到 80% 以上的命中率。\n\n综上所述，并不是每个系统都适合花大量精力去解决潜在的伪共享问题。\n\n","slug":"伪缓存","published":1,"updated":"2019-01-04T01:48:59.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx6t002ueb1uznsiu1kw","content":"<h1 id=\"伪共享（false-sharing），并发编程无声的性能杀手\"><a href=\"#伪共享（false-sharing），并发编程无声的性能杀手\" class=\"headerlink\" title=\"伪共享（false sharing），并发编程无声的性能杀手\"></a>伪共享（false sharing），并发编程无声的性能杀手</h1><p>在并发编程过程中，我们大部分的焦点都放在如何控制共享变量的访问控制上（代码层面），但是很少人会关注系统硬件及 JVM 底层相关的影响因素。前段时间学习了一个牛X的高性能异步处理框架 Disruptor，它被誉为“最快的消息框架”，其 LMAX 架构能够在一个线程里每秒处理 6百万 订单！在讲到 Disruptor 为什么这么快时，接触到了一个概念——伪共享( false sharing )，其中提到：缓存行上的写竞争是运行在 SMP 系统中并行线程实现可伸缩性最重要的限制因素。由于从代码中很难看出是否会出现伪共享，有人将其描述成无声的性能杀手。</p>\n<p>本文仅针对目前所学进行合并整理，目前并无非常深入地研究和实践，希望对大家从零开始理解伪共享提供一些帮助。</p>\n<blockquote>\n<p>伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>\n</blockquote>\n<p>下面我们就来详细剖析伪共享产生的前因后果。首先，我们要了解什么是缓存系统。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h3><h2 id=\"一、CPU-缓存\"><a href=\"#一、CPU-缓存\" class=\"headerlink\" title=\"一、CPU 缓存\"></a><strong>一、CPU 缓存</strong></h2><p>CPU 缓存的百度百科定义为：</p>\n<p>CPU 缓存（Cache Memory）是位于 CPU 与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。<br>高速缓存的出现主要是为了解决 CPU 运算速度与内存读写速度不匹配的矛盾，因为 CPU 运算速度要比内存读写速度快很多，这样会使 CPU 花费很长时间等待数据到来或把数据写入内存。<br>在缓存中的数据是内存中的一小部分，但这一小部分是短时间内 CPU 即将访问的，当 CPU 调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。</p>\n<p>CPU 和主内存之间有好几层缓存，因为即使直接访问主内存也是非常慢的。如果你正在多次对一块数据做相同的运算，那么在执行运算的时候把它加载到离 CPU 很近的地方就有意义了。</p>\n<p>按照数据读取顺序和与 CPU 结合的紧密程度，CPU 缓存可以分为一级缓存，二级缓存，部分高端 CPU 还具有三级缓存。每一级缓存中所储存的全部数据都是下一级缓存的一部分，越靠近 CPU 的缓存越快也越小。所以 L1 缓存很小但很快(译注：L1 表示一级缓存)，并且紧靠着在使用它的 CPU 内核。L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。拥有三级缓存的的 CPU，到三级缓存时能够达到 95% 的命中率，只有不到 5% 的数据需要从内存中查询。</p>\n<p>多核机器的存储结构如下图所示：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201221667-1059026925.png\" alt=\"img\"></p>\n<p>当 CPU 执行运算的时候，它先去 L1 查找所需的数据，再去 L2，然后是 L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要确保数据在 L1 缓存中。</p>\n<p>Martin Thompson 给出了一些缓存未命中的消耗数据，如下所示：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201305464-895015043.png\" alt=\"img\"></p>\n<h2 id=\"二、MESI-协议及-RFO-请求\"><a href=\"#二、MESI-协议及-RFO-请求\" class=\"headerlink\" title=\"二、MESI 协议及 RFO 请求\"></a><strong>二、MESI 协议及 RFO 请求</strong></h2><p>从上一节中我们知道，每个核都有自己私有的 L1,、L2 缓存。那么多线程编程时, 另外一个核的线程想要访问当前核内 L1、L2 缓存行的数据, 该怎么办呢？</p>\n<p>有人说可以通过第 2 个核直接访问第 1 个核的缓存行，这是当然是可行的，但这种方法不够快。跨核访问需要通过 Memory Controller（内存控制器，是计算机系统内部控制内存并且通过内存控制器使内存与 CPU 之间交换数据的重要组成部分），典型的情况是第 2 个核经常访问第 1 个核的这条数据，那么每次都有跨核的消耗.。更糟的情况是，有可能第 2 个核与第 1 个核不在一个插槽内，况且 Memory Controller 的总线带宽是有限的，扛不住这么多数据传输。所以，CPU 设计者们更偏向于另一种办法： 如果第 2 个核需要这份数据，由第 1 个核直接把数据内容发过去，数据只需要传一次。</p>\n<p>那么什么时候会发生缓存行的传输呢？答案很简单：当一个核需要读取另外一个核的脏缓存行时发生。但是前者怎么判断后者的缓存行已经被弄脏(写)了呢？</p>\n<p>下面将详细地解答以上问题. 首先我们需要谈到一个协议—— MESI 协议。现在主流的处理器都是用它来保证缓存的相干性和内存的相干性。M、E、S 和 I 代表使用 MESI 协议时缓存行所处的四个状态：</p>\n<ul>\n<li>M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；</li>\n<li>E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；</li>\n<li>S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；</li>\n<li>I（无效，Invalid）：缓存行失效, 不能使用。</li>\n</ul>\n<p>下面说明这四个状态是如何转换的：</p>\n<p>初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。</p>\n<p>本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。</p>\n<p>本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）</p>\n<p>远程读（Remote Read）：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。</p>\n<p>远程写（Remote Write）：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。</p>\n<p>状态转换由下图做个补充：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201649808-555029301.png\" alt=\"img\"></p>\n<p>我们从上节知道，写操作的代价很高，特别当需要发送 RFO 消息时。我们编写程序时，什么时候会发生 RFO 请求呢？有以下两种：</p>\n<ol>\n<li>线程的工作从一个处理器移到另一个处理器, 它操作的所有缓存行都需要移到新的处理器上。此后如果再写缓存行，则此缓存行在不同核上有多个拷贝，需要发送 RFO 请求了。</li>\n<li>两个不同的处理器确实都需要操作相同的缓存行</li>\n</ol>\n<p>接下来，我们要了解什么是缓存行。</p>\n<h2 id=\"缓存行\"><a href=\"#缓存行\" class=\"headerlink\" title=\"缓存行\"></a><strong>缓存行</strong></h2><p>为了高效地存取缓存, 不是简单随意地将单条数据写入缓存的.  缓存是由缓存行组成的, 典型的一行是64字节. 读者可以通过下面的shell命令,查看cherency_line_size就知道知道机器的缓存行是多大. </p>\n<pre><code> cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size   \n 64  \n</code></pre><p>CPU存取缓存都是按行为最小单位操作的. 在这儿我将不提及缓存的associativity问题, 将问题简化一些. 一个Java long型占8字节, 所以从一条缓存行上你可以获取到8个long型变量. 所以如果你访问一个long型数组, 当有一个long被加载到cache中, 你将无消耗地加载了另外7个. 所以你可以非常快地遍历数组.</p>\n<p>下面是利用缓存行来进行的对比实验代码</p>\n<pre><code class=\"java\">public class L1CacheMiss {  \n    private static final int RUNS = 10;  \n    private static final int DIMENSION_1 = 1024 * 1024;  \n    private static final int DIMENSION_2 = 62;  \n\n    private static long[][] longs;  \n\n    public static void main(String[] args) throws Exception {  \n        Thread.sleep(10000);  \n        longs = new long[DIMENSION_1][];  \n        for (int i = 0; i &lt; DIMENSION_1; i++) {  \n            longs[i] = new long[DIMENSION_2];  \n            for (int j = 0; j &lt; DIMENSION_2; j++) {  \n                longs[i][j] = 0L;  \n            }  \n        }  \n        System.out.println(&quot;starting....&quot;);  \n\n        final long start = System.nanoTime();  \n        long sum = 0L;  \n        for (int r = 0; r &lt; RUNS; r++) {  \n//          for (int j = 0; j &lt; DIMENSION_2; j++) {  \n//              for (int i = 0; i &lt; DIMENSION_1; i++) {  \n//                  sum += longs[i][j];  \n//              }  \n//          }  \n\n            for (int i = 0; i &lt; DIMENSION_1; i++) {  \n                for (int j = 0; j &lt; DIMENSION_2; j++) {  \n                    sum += longs[i][j];  \n                }  \n            }  \n        }  \n        System.out.println(&quot;duration = &quot; + (System.nanoTime() - start));  \n    }  \n}  \n</code></pre>\n<p>编译运行得到的结果如下</p>\n<pre><code>    starting....\n    duration =  850623099\n</code></pre><p>然后我们将22-26行的注释取消, 将28-32行注释, 编译后再次运行,结果是不是比我们预想得还糟? </p>\n<pre><code>starting....\nduration = 8078753353\n</code></pre><p>通过对比可以看出，第二个花的时间是第一个的10倍还多。从上节我们可以知道在加载longs[i][j]时, longs[i][j+1]很可能也会被加载至cache中, 所以立即访问longs[i][j+1]将会命中L1 Cache, 而如果你访问longs[i+1][j]情况就不一样了, 这时候很可能会产生 cache miss导致效率低下. </p>\n<p>以上我只是示例了在L1 Cache满了之后才会发生的cache miss. 其实cache miss的原因有下面三种: </p>\n<ol>\n<li>第一次访问数据, 在cache中根本不存在这条数据, 所以cache miss, 可以通过prefetch解决. </li>\n<li>cache冲突, 需要通过补齐来解决. </li>\n<li>就是我示例的这种, cache满, 一般情况下我们需要减少操作的数据大小, 尽量按数据的物理顺序访问数据</li>\n</ol>\n<h2 id=\"四、伪共享\"><a href=\"#四、伪共享\" class=\"headerlink\" title=\"四、伪共享\"></a>四、伪共享</h2><p>在文章开头提到过，缓存系统中是以缓存行（cache line）为单位存储的。缓存行通常是 64 字节（译注：本文基于 64 字节，其他长度的如 32 字节等不适本文讨论的重点），并且它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。所以，如果你访问一个 long 数组，当数组中的一个值被加载到缓存中，它会额外加载另外 7 个，以致你能非常快地遍历这个数组。事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构。而如果你在数据结构中的项在内存中不是彼此相邻的（如链表），你将得不到免费缓存加载所带来的优势，并且在这些数据结构中的每一个项都可能会出现缓存未命中。</p>\n<p>如果存在这样的场景，有多个线程操作不同的成员变量，但是相同的缓存行，这个时候会发生什么？。没错，伪共享（False Sharing）问题就发生了！有张 Disruptor 项目的经典示例图，如下：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202002573-736704844.png\" alt=\"img\"></p>\n<p>上图中，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送 RFO 消息，占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。</p>\n<p>表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。</p>\n<h2 id=\"五、遭遇伪共享\"><a href=\"#五、遭遇伪共享\" class=\"headerlink\" title=\"五、遭遇伪共享\"></a><em>五、遭遇伪共享</em></h2><p>好的，那么接下来我们就用 code 来进行实验和佐证。</p>\n<pre><code>public class FalseShareTest implements Runnable {\n    public static int NUM_THREADS = 4;\n    public final static long ITERATIONS = 500L * 1000L * 1000L;\n    private final int arrayIndex;\n    private static VolatileLong[] longs;\n    public static long SUM_TIME = 0l;\n    public FalseShareTest(final int arrayIndex) {\n        this.arrayIndex = arrayIndex;\n    }\n    public static void main(final String[] args) throws Exception {\n        Thread.sleep(10000);\n        for(int j=0; j&lt;10; j++){\n            System.out.println(j);\n            if (args.length == 1) {\n                NUM_THREADS = Integer.parseInt(args[0]);\n            }\n            longs = new VolatileLong[NUM_THREADS];\n            for (int i = 0; i &lt; longs.length; i++) {\n                longs[i] = new VolatileLong();\n            }\n            final long start = System.nanoTime();\n            runTest();\n            final long end = System.nanoTime();\n            SUM_TIME += end - start;\n        }\n        System.out.println(&quot;平均耗时：&quot;+SUM_TIME/10);\n    }\n    private static void runTest() throws InterruptedException {\n        Thread[] threads = new Thread[NUM_THREADS];\n        for (int i = 0; i &lt; threads.length; i++) {\n            threads[i] = new Thread(new FalseShareTest(i));\n        }\n        for (Thread t : threads) {\n            t.start();\n        }\n        for (Thread t : threads) {\n            t.join();\n        }\n    }\n    public void run() {\n        long i = ITERATIONS + 1;\n        while (0 != --i) {\n            longs[arrayIndex].value = i;\n        }\n    }\n    public final static class VolatileLong {\n        public volatile long value = 0L;\n        public long p1, p2, p3, p4, p5, p6;     //屏蔽此行\n    }\n}\n</code></pre><p>上述代码的逻辑很简单，就是四个线程修改一数组不同元素的内容。元素的类型是 VolatileLong，只有一个长整型成员 value 和 6 个没用到的长整型成员。value 设为 volatile 是为了让 value 的修改对所有线程都可见。程序分两种情况执行，第一种情况为不屏蔽倒数第三行（见”屏蔽此行”字样），第二种情况为屏蔽倒数第三行。为了”保证”数据的相对可靠性，程序取 10 次执行的平均时间。执行情况如下（执行环境：32位 windows，四核，8GB 内存）：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202253714-555001087.png\" alt=\"img\">         <img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202308245-492044780.png\" alt=\"img\"></p>\n<p>（不屏蔽）                                                          （屏蔽）</p>\n<p>两个逻辑一模一样的程序，前者的耗时大概是后者的 2.5 倍，这太不可思议了！那么这个时候，我们再用伪共享（False Sharing）的理论来分析一下。前者 longs 数组的 4 个元素，由于 VolatileLong 只有 1 个长整型成员，所以整个数组都将被加载至同一缓存行，但有4个线程同时操作这条缓存行，于是伪共享就悄悄地发生了。</p>\n<p>基于此，我们有理由相信，在一定线程数量范围内（注意思考：为什么强调是一定线程数量范围内），随着线程数量的增加，伪共享发生的频率也越大，直观体现就是执行时间越长。为了证实这个观点，本人在同样的机器上分别用单线程、2、4、8个线程，对有填充和无填充两种情况进行测试。执行场景是取 10 次执行的平均时间，结果如下所示：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202449620-46958750.png\" alt=\"img\"></p>\n<h2 id=\"六、如何避免伪共享？\"><a href=\"#六、如何避免伪共享？\" class=\"headerlink\" title=\"六、如何避免伪共享？**\"></a>六、如何避免伪共享？**</h2><blockquote>\n<p>其中一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可。</p>\n</blockquote>\n<p>那么该如何做到呢？其实在我们注释的那行代码中就有答案，那就是缓存行填充（Padding） 。现在分析上面的例子，我们知道一条缓存行有 64 字节，而 Java 程序的对象头固定占 8 字节(32位系统)或 12 字节( 64 位系统默认开启压缩, 不开压缩为 16 字节)，所以我们只需要填 6 个无用的长整型补上6*8=48字节，让不同的 VolatileLong 对象处于不同的缓存行，就避免了伪共享( 64 位系统超过缓存行的 64 字节也无所谓，只要保证不同线程不操作同一缓存行就可以)。</p>\n<p>伪共享在多核编程中很容易发生，而且非常隐蔽。例如，在 JDK 的 LinkedBlockingQueue 中，存在指向队列头的引用 head 和指向队列尾的引用 tail 。而这种队列经常在异步编程中使有，这两个引用的值经常的被不同的线程修改，但它们却很可能在同一个缓存行，于是就产生了伪共享。线程越多，核越多，对性能产生的负面效果就越大。</p>\n<p>由于某些 Java 编译器的优化策略，那些没有使用到的补齐数据可能会在编译期间被优化掉，我们可以在程序中加入一些代码防止被编译优化。如下：</p>\n<pre><code>public static long preventFromOptimization(VolatileLong v) {  \n        return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;  \n}\n</code></pre><blockquote>\n<p>另外一种技术是使用编译指示，来强制使每一个变量对齐。</p>\n</blockquote>\n<p>下面的代码显式了编译器使用__declspec( align(n) ) 此处 n=64，按照 cache line 边界对齐。</p>\n<pre><code>__declspec (align(64)) int thread1_global_variable;\n__declspec (align(64)) int thread2_global_variable;\n</code></pre><p>当使用数组时，在 cache line 尾部填充 padding 来保证数据元素在 cache line 边界开始。如果不能够保证数组按照 cache line 边界对齐，填充数据结构【数组元素】使之是 cache line 大小的两倍。下面的代码显式了填充数据结构使之按照 cache line 对齐。并且通过 __declspec( align(n) ) 语句来保证数组也是对齐的。如果数组是动态分配的，你可以增加分配的大小，并调整指针来对其到 cache line 边界。</p>\n<pre><code>struct ThreadParams\n{\n    // For the following 4 variables: 4*4 = 16 bytes\n    unsigned long thread_id;\n    unsigned long v; // Frequent read/write access variable\n    unsigned long start;\n    unsigned long end;\n    // expand to 64 bytes to avoid false-sharing \n    // (4 unsigned long variables + 12 padding)*4 = 64\n    int padding[12];\n};\n</code></pre><p>除此之外，在网上还有很多对伪共享的研究，提出了一些基于数据融合的方案，有兴趣的同学可以了解下。</p>\n<h2 id=\"七、对于伪共享，我们在实际开发中该怎么做？\"><a href=\"#七、对于伪共享，我们在实际开发中该怎么做？\" class=\"headerlink\" title=\"七、对于伪共享，我们在实际开发中该怎么做？**\"></a>七、对于伪共享，我们在实际开发中该怎么做？**</h2><p>通过上面大篇幅的介绍，我们已经知道伪共享的对程序的影响。那么，在实际的生产开发过程中，我们一定要通过缓存行填充去解决掉潜在的伪共享问题吗？</p>\n<p>其实并不一定。</p>\n<p>首先就是多次强调的，伪共享是很隐蔽的，我们暂时无法从系统层面上通过工具来探测伪共享事件。其次，不同类型的计算机具有不同的微架构（如 32 位系统和 64 位系统的 java 对象所占自己数就不一样），如果设计到跨平台的设计，那就更难以把握了，一个确切的填充方案只适用于一个特定的操作系统。还有，缓存的资源是有限的，如果填充会浪费珍贵的 cache 资源，并不适合大范围应用。最后，目前主流的 Intel 微架构 CPU 的 L1 缓存，已能够达到 80% 以上的命中率。</p>\n<p>综上所述，并不是每个系统都适合花大量精力去解决潜在的伪共享问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"伪共享（false-sharing），并发编程无声的性能杀手\"><a href=\"#伪共享（false-sharing），并发编程无声的性能杀手\" class=\"headerlink\" title=\"伪共享（false sharing），并发编程无声的性能杀手\"></a>伪共享（false sharing），并发编程无声的性能杀手</h1><p>在并发编程过程中，我们大部分的焦点都放在如何控制共享变量的访问控制上（代码层面），但是很少人会关注系统硬件及 JVM 底层相关的影响因素。前段时间学习了一个牛X的高性能异步处理框架 Disruptor，它被誉为“最快的消息框架”，其 LMAX 架构能够在一个线程里每秒处理 6百万 订单！在讲到 Disruptor 为什么这么快时，接触到了一个概念——伪共享( false sharing )，其中提到：缓存行上的写竞争是运行在 SMP 系统中并行线程实现可伸缩性最重要的限制因素。由于从代码中很难看出是否会出现伪共享，有人将其描述成无声的性能杀手。</p>\n<p>本文仅针对目前所学进行合并整理，目前并无非常深入地研究和实践，希望对大家从零开始理解伪共享提供一些帮助。</p>\n<blockquote>\n<p>伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>\n</blockquote>\n<p>下面我们就来详细剖析伪共享产生的前因后果。首先，我们要了解什么是缓存系统。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h3><h2 id=\"一、CPU-缓存\"><a href=\"#一、CPU-缓存\" class=\"headerlink\" title=\"一、CPU 缓存\"></a><strong>一、CPU 缓存</strong></h2><p>CPU 缓存的百度百科定义为：</p>\n<p>CPU 缓存（Cache Memory）是位于 CPU 与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。<br>高速缓存的出现主要是为了解决 CPU 运算速度与内存读写速度不匹配的矛盾，因为 CPU 运算速度要比内存读写速度快很多，这样会使 CPU 花费很长时间等待数据到来或把数据写入内存。<br>在缓存中的数据是内存中的一小部分，但这一小部分是短时间内 CPU 即将访问的，当 CPU 调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。</p>\n<p>CPU 和主内存之间有好几层缓存，因为即使直接访问主内存也是非常慢的。如果你正在多次对一块数据做相同的运算，那么在执行运算的时候把它加载到离 CPU 很近的地方就有意义了。</p>\n<p>按照数据读取顺序和与 CPU 结合的紧密程度，CPU 缓存可以分为一级缓存，二级缓存，部分高端 CPU 还具有三级缓存。每一级缓存中所储存的全部数据都是下一级缓存的一部分，越靠近 CPU 的缓存越快也越小。所以 L1 缓存很小但很快(译注：L1 表示一级缓存)，并且紧靠着在使用它的 CPU 内核。L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。拥有三级缓存的的 CPU，到三级缓存时能够达到 95% 的命中率，只有不到 5% 的数据需要从内存中查询。</p>\n<p>多核机器的存储结构如下图所示：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201221667-1059026925.png\" alt=\"img\"></p>\n<p>当 CPU 执行运算的时候，它先去 L1 查找所需的数据，再去 L2，然后是 L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要确保数据在 L1 缓存中。</p>\n<p>Martin Thompson 给出了一些缓存未命中的消耗数据，如下所示：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201305464-895015043.png\" alt=\"img\"></p>\n<h2 id=\"二、MESI-协议及-RFO-请求\"><a href=\"#二、MESI-协议及-RFO-请求\" class=\"headerlink\" title=\"二、MESI 协议及 RFO 请求\"></a><strong>二、MESI 协议及 RFO 请求</strong></h2><p>从上一节中我们知道，每个核都有自己私有的 L1,、L2 缓存。那么多线程编程时, 另外一个核的线程想要访问当前核内 L1、L2 缓存行的数据, 该怎么办呢？</p>\n<p>有人说可以通过第 2 个核直接访问第 1 个核的缓存行，这是当然是可行的，但这种方法不够快。跨核访问需要通过 Memory Controller（内存控制器，是计算机系统内部控制内存并且通过内存控制器使内存与 CPU 之间交换数据的重要组成部分），典型的情况是第 2 个核经常访问第 1 个核的这条数据，那么每次都有跨核的消耗.。更糟的情况是，有可能第 2 个核与第 1 个核不在一个插槽内，况且 Memory Controller 的总线带宽是有限的，扛不住这么多数据传输。所以，CPU 设计者们更偏向于另一种办法： 如果第 2 个核需要这份数据，由第 1 个核直接把数据内容发过去，数据只需要传一次。</p>\n<p>那么什么时候会发生缓存行的传输呢？答案很简单：当一个核需要读取另外一个核的脏缓存行时发生。但是前者怎么判断后者的缓存行已经被弄脏(写)了呢？</p>\n<p>下面将详细地解答以上问题. 首先我们需要谈到一个协议—— MESI 协议。现在主流的处理器都是用它来保证缓存的相干性和内存的相干性。M、E、S 和 I 代表使用 MESI 协议时缓存行所处的四个状态：</p>\n<ul>\n<li>M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；</li>\n<li>E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；</li>\n<li>S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；</li>\n<li>I（无效，Invalid）：缓存行失效, 不能使用。</li>\n</ul>\n<p>下面说明这四个状态是如何转换的：</p>\n<p>初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。</p>\n<p>本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。</p>\n<p>本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）</p>\n<p>远程读（Remote Read）：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。</p>\n<p>远程写（Remote Write）：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。</p>\n<p>状态转换由下图做个补充：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823201649808-555029301.png\" alt=\"img\"></p>\n<p>我们从上节知道，写操作的代价很高，特别当需要发送 RFO 消息时。我们编写程序时，什么时候会发生 RFO 请求呢？有以下两种：</p>\n<ol>\n<li>线程的工作从一个处理器移到另一个处理器, 它操作的所有缓存行都需要移到新的处理器上。此后如果再写缓存行，则此缓存行在不同核上有多个拷贝，需要发送 RFO 请求了。</li>\n<li>两个不同的处理器确实都需要操作相同的缓存行</li>\n</ol>\n<p>接下来，我们要了解什么是缓存行。</p>\n<h2 id=\"缓存行\"><a href=\"#缓存行\" class=\"headerlink\" title=\"缓存行\"></a><strong>缓存行</strong></h2><p>为了高效地存取缓存, 不是简单随意地将单条数据写入缓存的.  缓存是由缓存行组成的, 典型的一行是64字节. 读者可以通过下面的shell命令,查看cherency_line_size就知道知道机器的缓存行是多大. </p>\n<pre><code> cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size   \n 64  \n</code></pre><p>CPU存取缓存都是按行为最小单位操作的. 在这儿我将不提及缓存的associativity问题, 将问题简化一些. 一个Java long型占8字节, 所以从一条缓存行上你可以获取到8个long型变量. 所以如果你访问一个long型数组, 当有一个long被加载到cache中, 你将无消耗地加载了另外7个. 所以你可以非常快地遍历数组.</p>\n<p>下面是利用缓存行来进行的对比实验代码</p>\n<pre><code class=\"java\">public class L1CacheMiss {  \n    private static final int RUNS = 10;  \n    private static final int DIMENSION_1 = 1024 * 1024;  \n    private static final int DIMENSION_2 = 62;  \n\n    private static long[][] longs;  \n\n    public static void main(String[] args) throws Exception {  \n        Thread.sleep(10000);  \n        longs = new long[DIMENSION_1][];  \n        for (int i = 0; i &lt; DIMENSION_1; i++) {  \n            longs[i] = new long[DIMENSION_2];  \n            for (int j = 0; j &lt; DIMENSION_2; j++) {  \n                longs[i][j] = 0L;  \n            }  \n        }  \n        System.out.println(&quot;starting....&quot;);  \n\n        final long start = System.nanoTime();  \n        long sum = 0L;  \n        for (int r = 0; r &lt; RUNS; r++) {  \n//          for (int j = 0; j &lt; DIMENSION_2; j++) {  \n//              for (int i = 0; i &lt; DIMENSION_1; i++) {  \n//                  sum += longs[i][j];  \n//              }  \n//          }  \n\n            for (int i = 0; i &lt; DIMENSION_1; i++) {  \n                for (int j = 0; j &lt; DIMENSION_2; j++) {  \n                    sum += longs[i][j];  \n                }  \n            }  \n        }  \n        System.out.println(&quot;duration = &quot; + (System.nanoTime() - start));  \n    }  \n}  \n</code></pre>\n<p>编译运行得到的结果如下</p>\n<pre><code>    starting....\n    duration =  850623099\n</code></pre><p>然后我们将22-26行的注释取消, 将28-32行注释, 编译后再次运行,结果是不是比我们预想得还糟? </p>\n<pre><code>starting....\nduration = 8078753353\n</code></pre><p>通过对比可以看出，第二个花的时间是第一个的10倍还多。从上节我们可以知道在加载longs[i][j]时, longs[i][j+1]很可能也会被加载至cache中, 所以立即访问longs[i][j+1]将会命中L1 Cache, 而如果你访问longs[i+1][j]情况就不一样了, 这时候很可能会产生 cache miss导致效率低下. </p>\n<p>以上我只是示例了在L1 Cache满了之后才会发生的cache miss. 其实cache miss的原因有下面三种: </p>\n<ol>\n<li>第一次访问数据, 在cache中根本不存在这条数据, 所以cache miss, 可以通过prefetch解决. </li>\n<li>cache冲突, 需要通过补齐来解决. </li>\n<li>就是我示例的这种, cache满, 一般情况下我们需要减少操作的数据大小, 尽量按数据的物理顺序访问数据</li>\n</ol>\n<h2 id=\"四、伪共享\"><a href=\"#四、伪共享\" class=\"headerlink\" title=\"四、伪共享\"></a>四、伪共享</h2><p>在文章开头提到过，缓存系统中是以缓存行（cache line）为单位存储的。缓存行通常是 64 字节（译注：本文基于 64 字节，其他长度的如 32 字节等不适本文讨论的重点），并且它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。所以，如果你访问一个 long 数组，当数组中的一个值被加载到缓存中，它会额外加载另外 7 个，以致你能非常快地遍历这个数组。事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构。而如果你在数据结构中的项在内存中不是彼此相邻的（如链表），你将得不到免费缓存加载所带来的优势，并且在这些数据结构中的每一个项都可能会出现缓存未命中。</p>\n<p>如果存在这样的场景，有多个线程操作不同的成员变量，但是相同的缓存行，这个时候会发生什么？。没错，伪共享（False Sharing）问题就发生了！有张 Disruptor 项目的经典示例图，如下：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202002573-736704844.png\" alt=\"img\"></p>\n<p>上图中，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送 RFO 消息，占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。</p>\n<p>表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。</p>\n<h2 id=\"五、遭遇伪共享\"><a href=\"#五、遭遇伪共享\" class=\"headerlink\" title=\"五、遭遇伪共享\"></a><em>五、遭遇伪共享</em></h2><p>好的，那么接下来我们就用 code 来进行实验和佐证。</p>\n<pre><code>public class FalseShareTest implements Runnable {\n    public static int NUM_THREADS = 4;\n    public final static long ITERATIONS = 500L * 1000L * 1000L;\n    private final int arrayIndex;\n    private static VolatileLong[] longs;\n    public static long SUM_TIME = 0l;\n    public FalseShareTest(final int arrayIndex) {\n        this.arrayIndex = arrayIndex;\n    }\n    public static void main(final String[] args) throws Exception {\n        Thread.sleep(10000);\n        for(int j=0; j&lt;10; j++){\n            System.out.println(j);\n            if (args.length == 1) {\n                NUM_THREADS = Integer.parseInt(args[0]);\n            }\n            longs = new VolatileLong[NUM_THREADS];\n            for (int i = 0; i &lt; longs.length; i++) {\n                longs[i] = new VolatileLong();\n            }\n            final long start = System.nanoTime();\n            runTest();\n            final long end = System.nanoTime();\n            SUM_TIME += end - start;\n        }\n        System.out.println(&quot;平均耗时：&quot;+SUM_TIME/10);\n    }\n    private static void runTest() throws InterruptedException {\n        Thread[] threads = new Thread[NUM_THREADS];\n        for (int i = 0; i &lt; threads.length; i++) {\n            threads[i] = new Thread(new FalseShareTest(i));\n        }\n        for (Thread t : threads) {\n            t.start();\n        }\n        for (Thread t : threads) {\n            t.join();\n        }\n    }\n    public void run() {\n        long i = ITERATIONS + 1;\n        while (0 != --i) {\n            longs[arrayIndex].value = i;\n        }\n    }\n    public final static class VolatileLong {\n        public volatile long value = 0L;\n        public long p1, p2, p3, p4, p5, p6;     //屏蔽此行\n    }\n}\n</code></pre><p>上述代码的逻辑很简单，就是四个线程修改一数组不同元素的内容。元素的类型是 VolatileLong，只有一个长整型成员 value 和 6 个没用到的长整型成员。value 设为 volatile 是为了让 value 的修改对所有线程都可见。程序分两种情况执行，第一种情况为不屏蔽倒数第三行（见”屏蔽此行”字样），第二种情况为屏蔽倒数第三行。为了”保证”数据的相对可靠性，程序取 10 次执行的平均时间。执行情况如下（执行环境：32位 windows，四核，8GB 内存）：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202253714-555001087.png\" alt=\"img\">         <img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202308245-492044780.png\" alt=\"img\"></p>\n<p>（不屏蔽）                                                          （屏蔽）</p>\n<p>两个逻辑一模一样的程序，前者的耗时大概是后者的 2.5 倍，这太不可思议了！那么这个时候，我们再用伪共享（False Sharing）的理论来分析一下。前者 longs 数组的 4 个元素，由于 VolatileLong 只有 1 个长整型成员，所以整个数组都将被加载至同一缓存行，但有4个线程同时操作这条缓存行，于是伪共享就悄悄地发生了。</p>\n<p>基于此，我们有理由相信，在一定线程数量范围内（注意思考：为什么强调是一定线程数量范围内），随着线程数量的增加，伪共享发生的频率也越大，直观体现就是执行时间越长。为了证实这个观点，本人在同样的机器上分别用单线程、2、4、8个线程，对有填充和无填充两种情况进行测试。执行场景是取 10 次执行的平均时间，结果如下所示：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/897247/201608/897247-20160823202449620-46958750.png\" alt=\"img\"></p>\n<h2 id=\"六、如何避免伪共享？\"><a href=\"#六、如何避免伪共享？\" class=\"headerlink\" title=\"六、如何避免伪共享？**\"></a>六、如何避免伪共享？**</h2><blockquote>\n<p>其中一个解决思路，就是让不同线程操作的对象处于不同的缓存行即可。</p>\n</blockquote>\n<p>那么该如何做到呢？其实在我们注释的那行代码中就有答案，那就是缓存行填充（Padding） 。现在分析上面的例子，我们知道一条缓存行有 64 字节，而 Java 程序的对象头固定占 8 字节(32位系统)或 12 字节( 64 位系统默认开启压缩, 不开压缩为 16 字节)，所以我们只需要填 6 个无用的长整型补上6*8=48字节，让不同的 VolatileLong 对象处于不同的缓存行，就避免了伪共享( 64 位系统超过缓存行的 64 字节也无所谓，只要保证不同线程不操作同一缓存行就可以)。</p>\n<p>伪共享在多核编程中很容易发生，而且非常隐蔽。例如，在 JDK 的 LinkedBlockingQueue 中，存在指向队列头的引用 head 和指向队列尾的引用 tail 。而这种队列经常在异步编程中使有，这两个引用的值经常的被不同的线程修改，但它们却很可能在同一个缓存行，于是就产生了伪共享。线程越多，核越多，对性能产生的负面效果就越大。</p>\n<p>由于某些 Java 编译器的优化策略，那些没有使用到的补齐数据可能会在编译期间被优化掉，我们可以在程序中加入一些代码防止被编译优化。如下：</p>\n<pre><code>public static long preventFromOptimization(VolatileLong v) {  \n        return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;  \n}\n</code></pre><blockquote>\n<p>另外一种技术是使用编译指示，来强制使每一个变量对齐。</p>\n</blockquote>\n<p>下面的代码显式了编译器使用__declspec( align(n) ) 此处 n=64，按照 cache line 边界对齐。</p>\n<pre><code>__declspec (align(64)) int thread1_global_variable;\n__declspec (align(64)) int thread2_global_variable;\n</code></pre><p>当使用数组时，在 cache line 尾部填充 padding 来保证数据元素在 cache line 边界开始。如果不能够保证数组按照 cache line 边界对齐，填充数据结构【数组元素】使之是 cache line 大小的两倍。下面的代码显式了填充数据结构使之按照 cache line 对齐。并且通过 __declspec( align(n) ) 语句来保证数组也是对齐的。如果数组是动态分配的，你可以增加分配的大小，并调整指针来对其到 cache line 边界。</p>\n<pre><code>struct ThreadParams\n{\n    // For the following 4 variables: 4*4 = 16 bytes\n    unsigned long thread_id;\n    unsigned long v; // Frequent read/write access variable\n    unsigned long start;\n    unsigned long end;\n    // expand to 64 bytes to avoid false-sharing \n    // (4 unsigned long variables + 12 padding)*4 = 64\n    int padding[12];\n};\n</code></pre><p>除此之外，在网上还有很多对伪共享的研究，提出了一些基于数据融合的方案，有兴趣的同学可以了解下。</p>\n<h2 id=\"七、对于伪共享，我们在实际开发中该怎么做？\"><a href=\"#七、对于伪共享，我们在实际开发中该怎么做？\" class=\"headerlink\" title=\"七、对于伪共享，我们在实际开发中该怎么做？**\"></a>七、对于伪共享，我们在实际开发中该怎么做？**</h2><p>通过上面大篇幅的介绍，我们已经知道伪共享的对程序的影响。那么，在实际的生产开发过程中，我们一定要通过缓存行填充去解决掉潜在的伪共享问题吗？</p>\n<p>其实并不一定。</p>\n<p>首先就是多次强调的，伪共享是很隐蔽的，我们暂时无法从系统层面上通过工具来探测伪共享事件。其次，不同类型的计算机具有不同的微架构（如 32 位系统和 64 位系统的 java 对象所占自己数就不一样），如果设计到跨平台的设计，那就更难以把握了，一个确切的填充方案只适用于一个特定的操作系统。还有，缓存的资源是有限的，如果填充会浪费珍贵的 cache 资源，并不适合大范围应用。最后，目前主流的 Intel 微架构 CPU 的 L1 缓存，已能够达到 80% 以上的命中率。</p>\n<p>综上所述，并不是每个系统都适合花大量精力去解决潜在的伪共享问题。</p>\n"},{"abbrlink":14,"title":"枚举","author":"zhangke","date":"2018-03-07T01:24:00.000Z","_content":"# 枚举\n\n### 概要 \n\n>本篇博客的内容如下\n>\n>1. 使用背景\n>2. 枚举定义和使用\n>3. 枚举的总结\n>4. 深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\n\n### 1.  使用背景\n\n>在java语言还没有引入枚举类型之前，表示枚举类型的常用模式是声明一组int常量。之前通常利用public final static 方法定义。下面是一个小案例，分别用1 表示春天 2 表示夏天 3 表示秋天 4 表示冬天\n>\n>```java\n>public class Season {\n>    public static final int SPRING = 1;\n>    public static final int SUMMER = 2;\n>    public static final int AUTUMN = 3;\n>    public static final int WINTER = 4;\n>}\n>```\n>\n>这种方式称作int枚举模式。但是这种模式有一些问题。通常我们写出的代码都会从以下三个方面来进行分析，安全性、易用性和可读性。首先我们考虑一下他的安全性。当然这种模式不是类型安全的。比如我们设计一个函数，要求传入春夏秋冬的某个值。但是使用int类型，我们无法保证传入的值为合法。代码如下所示\n>\n>```java\n>private String getChineseSeason(int season){\n>        StringBuffer result = new StringBuffer();\n>        switch(season){\n>            case Season.SPRING :\n>                result.append(\"春天\");\n>                break;\n>            case Season.SUMMER :\n>                result.append(\"夏天\");\n>                break;\n>            case Season.AUTUMN :\n>                result.append(\"秋天\");\n>                break;\n>            case Season.WINTER :\n>                result.append(\"冬天\");\n>                break;\n>            default :\n>                result.append(\"地球没有的季节\");\n>                break;\n>        }\n>        return result.toString();\n>    }\n>\n>    public void doSomething(){\n>        //这是正常的场景\n>        System.out.println(this.getChineseSeason(Season.SPRING));\n>        //这个却是不正常的场景，这就导致了类型不安全问题\n>        System.out.println(this.getChineseSeason(5));\n>    }\n>```\n>\n>程序`getChineseSeason(Season.SPRING)`是我们预期的使用方法。可`getChineseSeason(5)`显然就不是了，而且编译很通过，在运行时会出现什么情况，我们就不得而知了。这显然就不符合`Java`程序的类型安全。\n>\n>接下来我们考虑一下这种模式的可读性。使用枚举的大多数场合，我们都需要方便的到枚举类型的字符串表达式。如果将int枚举常量打印出来，我们所见到的就是一组数字，这是没什么太大的用处。我们可能会想到是一个String常量来代替int常量。虽然他为这些常量提供了可打印的字符串，但是他会导致性能问题，因为他依赖于字符串的比较操作，所以这种模式也是我们不期望的。从类型安全性和程序可读性俩方面考虑，int和String枚举模式的缺点就显露出来。幸运的是，从`Java1.5`发行版本开始，就提出了另一种可以替代的解决方案，可以避免`int`和`String`枚举模式的缺点，并提供了许多额外的好处。那就是枚举类型（`enum type`）。接下来的章节将介绍枚举类型的定义、特征、应用场景和优缺点。\n>\n>\n\n\n\n### 2. 枚举定义和使用\n\n>枚举类型(enum type)是指由一组固定的常量组成合法的类型。java中由关键字enum来定义一个枚举类型。下面就是java枚举类型的定义:\n>\n>```java\n>publi enum Season{\n>   SPRING, SUMMER, AUTUMN, WINER;\n>}\n>```\n>\n>枚举的用法主要由以下几种：\n>\n>1. 常量，就如上面定义那样使用\n>\n>2. switch\n>\n>   ```java\n>   enum Signal {  \n>       GREEN, YELLOW, RED  \n>   }  \n>   public class TrafficLight {  \n>       Signal color = Signal.RED;  \n>       public void change() {  \n>           switch (color) {  \n>           case RED:  \n>               color = Signal.GREEN;  \n>               break;  \n>           case YELLOW:  \n>               color = Signal.RED;  \n>               break;  \n>           case GREEN:  \n>               color = Signal.YELLOW;  \n>               break;  \n>           }  \n>       }  \n>   }  \n>   ```\n>\n>3. 向枚举中添加新的方法\n>\n>   ```java\n>   public enum Color {  \n>       RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n>       // 成员变量  \n>       private String name;  \n>       private int index;  \n>       // 构造方法  \n>       private Color(String name, int index) {  \n>           this.name = name;  \n>           this.index = index;  \n>       }  \n>       // 普通方法  \n>       public static String getName(int index) {  \n>           for (Color c : Color.values()) {  \n>               if (c.getIndex() == index) {  \n>                   return c.name;  \n>               }  \n>           }  \n>           return null;  \n>       }  \n>       // get set 方法  \n>       public String getName() {  \n>           return name;  \n>       }  \n>       public void setName(String name) {  \n>           this.name = name;  \n>       }  \n>       public int getIndex() {  \n>           return index;  \n>       }  \n>       public void setIndex(int index) {  \n>           this.index = index;  \n>       }  \n>   }  \n>   ```\n>\n>4.  覆盖枚举的方法\n>\n>   ```java\n>   public enum Color {  \n>       RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n>       // 成员变量  \n>       private String name;  \n>       private int index;  \n>       // 构造方法  \n>       private Color(String name, int index) {  \n>           this.name = name;  \n>           this.index = index;  \n>       }  \n>       //覆盖方法  \n>       @Override  \n>       public String toString() {  \n>           return this.index+\"_\"+this.name;  \n>       }  \n>   }  \n>   ```\n>\n>5. 实现接口\n>\n>   ```java\n>   public interface Behaviour {  \n>       void print();  \n>       String getInfo();  \n>   }  \n>   public enum Color implements Behaviour{  \n>       RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n>       // 成员变量  \n>       private String name;  \n>       private int index;  \n>       // 构造方法  \n>       private Color(String name, int index) {  \n>           this.name = name;  \n>           this.index = index;  \n>       }  \n>   //接口方法  \n>       @Override  \n>       public String getInfo() {  \n>           return this.name;  \n>       }  \n>       //接口方法  \n>       @Override  \n>       public void print() {  \n>           System.out.println(this.index+\":\"+this.name);  \n>       }  \n>   }  \n>   ```\n>\n>6. 使用接口组织枚举\n>\n>   ```\n>   public interface Food {  \n>       enum Coffee implements Food{  \n>           BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO  \n>       }  \n>       enum Dessert implements Food{  \n>           FRUIT, CAKE, GELATO  \n>       }  \n>   }\n>   ```\n>\n>7. 常量相关的方法\n>\n>   ```java\n>   public enum Constantmethod{\n>     DATE_TIME{\n>       String getInfo(){\n>         System.out.println(\"date_time\");\n>       }\n>     }\n>     CLASSPATH{\n>       String getInfo(){\n>         System.out.println(\"classpath\");\n>       }\n>     }\n>     //定义每个常量都要实现的方法\n>     abstract String getInfo();\n>   }\n>   ```\n>\n>基本使用\n>\n>```java\n>public enum Season {\n>    SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);\n>\n>    private int code;\n>    private Season(int code){\n>        this.code = code;\n>    }\n>\n>    public int getCode(){\n>        return code;\n>    }\n>}\n>public class UseSeason {\n>    /**\n>     * 将英文的季节转换成中文季节\n>     * @param season\n>     * @return\n>     */\n>    public String getChineseSeason(Season season){\n>        StringBuffer result = new StringBuffer();\n>        switch(season){\n>            case SPRING :\n>                result.append(\"[中文：春天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            case AUTUMN :\n>                result.append(\"[中文：秋天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            case SUMMER : \n>                result.append(\"[中文：夏天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            case WINTER :\n>                result.append(\"[中文：冬天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            default :\n>                result.append(\"地球没有的季节 \" + season.name());\n>                break;\n>        }\n>        return result.toString();\n>    }\n>\n>    public void doSomething(){\n>        for(Season s : Season.values()){\n>            System.out.println(getChineseSeason(s));//这是正常的场景\n>        }\n>        //System.out.println(getChineseSeason(5));\n>        //此处已经是编译不通过了，这就保证了类型安全\n>    }\n>\n>    public static void main(String[] arg){\n>        UseSeason useSeason = new UseSeason();\n>        useSeason.doSomething();\n>    }\n>}\n>```\n>\n>\n\n### 3. 枚举的使用总结\n\n>其实枚举的定义很像类的定义，只不过枚举有一些限制，你甚至可以在枚举里面写main方法，这也是可以运行通过的。不过枚举不能继承类，至于原因接下来的博客会说明，但是枚举可以实现接口，就像上面展示的用法一样。\n\n### 4.深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\n\n>#### 1. 枚举是如何保证线程安全\n>\n>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：\n>\n>```\n>public enum t {\n>    SPRING,SUMMER,AUTUMN,WINTER;\n>}\n>```\n>\n>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译（[Java的反编译](http://www.hollischuang.com/archives/58)）后代码内容如下：\n>\n>```\n>public final class T extends Enum\n>{\n>    private T(String s, int i)\n>    {\n>        super(s, i);\n>    }\n>    public static T[] values()\n>    {\n>        T at[];\n>        int i;\n>        T at1[];\n>        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);\n>        return at1;\n>    }\n>\n>    public static T valueOf(String s)\n>    {\n>        return (T)Enum.valueOf(demo/T, s);\n>    }\n>\n>    public static final T SPRING;\n>    public static final T SUMMER;\n>    public static final T AUTUMN;\n>    public static final T WINTER;\n>    private static final T ENUM$VALUES[];\n>    static\n>    {\n>        SPRING = new T(\"SPRING\", 0);\n>        SUMMER = new T(\"SUMMER\", 1);\n>        AUTUMN = new T(\"AUTUMN\", 2);\n>        WINTER = new T(\"WINTER\", 3);\n>        ENUM$VALUES = (new T[] {\n>            SPRING, SUMMER, AUTUMN, WINTER\n>        });\n>    }\n>}\n>```\n>\n>通过反编译后代码我们可以看到，`public final class T extends Enum`，说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。当我们使用`enmu`来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类,所以枚举类型不能被继承，我们看到这个类中有几个属性和方法。\n>\n>我们可以看到：\n>\n>```\n>        public static final T SPRING;\n>        public static final T SUMMER;\n>        public static final T AUTUMN;\n>        public static final T WINTER;\n>        private static final T ENUM$VALUES[];\n>        static\n>        {\n>            SPRING = new T(\"SPRING\", 0);\n>            SUMMER = new T(\"SUMMER\", 1);\n>            AUTUMN = new T(\"AUTUMN\", 2);\n>            WINTER = new T(\"WINTER\", 3);\n>            ENUM$VALUES = (new T[] {\n>                SPRING, SUMMER, AUTUMN, WINTER\n>            });\n>        }\n>```\n>\n>都是static类型的，因为static类型的属性会在类被加载之后被初始化，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，**创建一个enum类型是线程安全的**。\n>\n>### 为什么用枚举实现的单例是最好的方式\n>\n>在[[转+注\\]单例模式的七种写法](http://www.hollischuang.com/archives/205)中，我们看到一共有七种实现单例的方式，其中，**Effective Java**作者`Josh Bloch` 提倡使用枚举的方式，既然大神说这种方式好，那我们就要知道它为什么好？\n>\n>**1. 枚举写法简单**\n>\n>> 写法简单这个大家看看[[转+注\\]单例模式的七种写法]()里面的实现就知道区别了。\n>\n>```\n>public enum EasySingleton{\n>    INSTANCE;\n>}\n>```\n>\n>你可以通过`EasySingleton.INSTANCE`来访问。\n>\n>**2. 枚举自己处理序列化**\n>\n>> 我们知道，以前的所有的单例模式都有一个比较大的问题，就是一旦实现了Serializable接口之后，就不再是单例得了，因为，每次调用 readObject()方法返回的都是一个新创建出来的对象，有一种解决办法就是使用readResolve()方法来避免此事发生。但是，**为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定。**原文如下：\n>>\n>> > Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant’s name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant’s enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.\n>>\n>> 大概意思就是说，在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。 我们看一下这个`valueOf`方法：\n>\n>```\n>public static <T extends Enum<T>> T valueOf(Class<T> enumType,String name) {  \n>            T result = enumType.enumConstantDirectory().get(name);  \n>            if (result != null)  \n>                return result;  \n>            if (name == null)  \n>                throw new NullPointerException(\"Name is null\");  \n>            throw new IllegalArgumentException(  \n>                \"No enum const \" + enumType +\".\" + name);  \n>        }  \n>```\n>\n>从代码中可以看到，代码会尝试从调用`enumType`这个`Class`对象的`enumConstantDirectory()`方法返回的`map`中获取名字为`name`的枚举对象，如果不存在就会抛出异常。再进一步跟到`enumConstantDirectory()`方法，就会发现到最后会以反射的方式调用`enumType`这个类型的`values()`静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充`enumType`这个`Class`对象中的`enumConstantDirectory`属性。\n>\n>所以，**JVM对序列化有保证。**\n>\n>**3.枚举实例创建是thread-safe(线程安全的)**\n>\n>> 当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，**创建一个enum类型是线程安全的**。","source":"_posts/枚举初探.md","raw":"abbrlink: 14\ntitle: 枚举\ntags:\n  - java基础\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-03-07 09:24:00\n---\n# 枚举\n\n### 概要 \n\n>本篇博客的内容如下\n>\n>1. 使用背景\n>2. 枚举定义和使用\n>3. 枚举的总结\n>4. 深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\n\n### 1.  使用背景\n\n>在java语言还没有引入枚举类型之前，表示枚举类型的常用模式是声明一组int常量。之前通常利用public final static 方法定义。下面是一个小案例，分别用1 表示春天 2 表示夏天 3 表示秋天 4 表示冬天\n>\n>```java\n>public class Season {\n>    public static final int SPRING = 1;\n>    public static final int SUMMER = 2;\n>    public static final int AUTUMN = 3;\n>    public static final int WINTER = 4;\n>}\n>```\n>\n>这种方式称作int枚举模式。但是这种模式有一些问题。通常我们写出的代码都会从以下三个方面来进行分析，安全性、易用性和可读性。首先我们考虑一下他的安全性。当然这种模式不是类型安全的。比如我们设计一个函数，要求传入春夏秋冬的某个值。但是使用int类型，我们无法保证传入的值为合法。代码如下所示\n>\n>```java\n>private String getChineseSeason(int season){\n>        StringBuffer result = new StringBuffer();\n>        switch(season){\n>            case Season.SPRING :\n>                result.append(\"春天\");\n>                break;\n>            case Season.SUMMER :\n>                result.append(\"夏天\");\n>                break;\n>            case Season.AUTUMN :\n>                result.append(\"秋天\");\n>                break;\n>            case Season.WINTER :\n>                result.append(\"冬天\");\n>                break;\n>            default :\n>                result.append(\"地球没有的季节\");\n>                break;\n>        }\n>        return result.toString();\n>    }\n>\n>    public void doSomething(){\n>        //这是正常的场景\n>        System.out.println(this.getChineseSeason(Season.SPRING));\n>        //这个却是不正常的场景，这就导致了类型不安全问题\n>        System.out.println(this.getChineseSeason(5));\n>    }\n>```\n>\n>程序`getChineseSeason(Season.SPRING)`是我们预期的使用方法。可`getChineseSeason(5)`显然就不是了，而且编译很通过，在运行时会出现什么情况，我们就不得而知了。这显然就不符合`Java`程序的类型安全。\n>\n>接下来我们考虑一下这种模式的可读性。使用枚举的大多数场合，我们都需要方便的到枚举类型的字符串表达式。如果将int枚举常量打印出来，我们所见到的就是一组数字，这是没什么太大的用处。我们可能会想到是一个String常量来代替int常量。虽然他为这些常量提供了可打印的字符串，但是他会导致性能问题，因为他依赖于字符串的比较操作，所以这种模式也是我们不期望的。从类型安全性和程序可读性俩方面考虑，int和String枚举模式的缺点就显露出来。幸运的是，从`Java1.5`发行版本开始，就提出了另一种可以替代的解决方案，可以避免`int`和`String`枚举模式的缺点，并提供了许多额外的好处。那就是枚举类型（`enum type`）。接下来的章节将介绍枚举类型的定义、特征、应用场景和优缺点。\n>\n>\n\n\n\n### 2. 枚举定义和使用\n\n>枚举类型(enum type)是指由一组固定的常量组成合法的类型。java中由关键字enum来定义一个枚举类型。下面就是java枚举类型的定义:\n>\n>```java\n>publi enum Season{\n>   SPRING, SUMMER, AUTUMN, WINER;\n>}\n>```\n>\n>枚举的用法主要由以下几种：\n>\n>1. 常量，就如上面定义那样使用\n>\n>2. switch\n>\n>   ```java\n>   enum Signal {  \n>       GREEN, YELLOW, RED  \n>   }  \n>   public class TrafficLight {  \n>       Signal color = Signal.RED;  \n>       public void change() {  \n>           switch (color) {  \n>           case RED:  \n>               color = Signal.GREEN;  \n>               break;  \n>           case YELLOW:  \n>               color = Signal.RED;  \n>               break;  \n>           case GREEN:  \n>               color = Signal.YELLOW;  \n>               break;  \n>           }  \n>       }  \n>   }  \n>   ```\n>\n>3. 向枚举中添加新的方法\n>\n>   ```java\n>   public enum Color {  \n>       RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n>       // 成员变量  \n>       private String name;  \n>       private int index;  \n>       // 构造方法  \n>       private Color(String name, int index) {  \n>           this.name = name;  \n>           this.index = index;  \n>       }  \n>       // 普通方法  \n>       public static String getName(int index) {  \n>           for (Color c : Color.values()) {  \n>               if (c.getIndex() == index) {  \n>                   return c.name;  \n>               }  \n>           }  \n>           return null;  \n>       }  \n>       // get set 方法  \n>       public String getName() {  \n>           return name;  \n>       }  \n>       public void setName(String name) {  \n>           this.name = name;  \n>       }  \n>       public int getIndex() {  \n>           return index;  \n>       }  \n>       public void setIndex(int index) {  \n>           this.index = index;  \n>       }  \n>   }  \n>   ```\n>\n>4.  覆盖枚举的方法\n>\n>   ```java\n>   public enum Color {  \n>       RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n>       // 成员变量  \n>       private String name;  \n>       private int index;  \n>       // 构造方法  \n>       private Color(String name, int index) {  \n>           this.name = name;  \n>           this.index = index;  \n>       }  \n>       //覆盖方法  \n>       @Override  \n>       public String toString() {  \n>           return this.index+\"_\"+this.name;  \n>       }  \n>   }  \n>   ```\n>\n>5. 实现接口\n>\n>   ```java\n>   public interface Behaviour {  \n>       void print();  \n>       String getInfo();  \n>   }  \n>   public enum Color implements Behaviour{  \n>       RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n>       // 成员变量  \n>       private String name;  \n>       private int index;  \n>       // 构造方法  \n>       private Color(String name, int index) {  \n>           this.name = name;  \n>           this.index = index;  \n>       }  \n>   //接口方法  \n>       @Override  \n>       public String getInfo() {  \n>           return this.name;  \n>       }  \n>       //接口方法  \n>       @Override  \n>       public void print() {  \n>           System.out.println(this.index+\":\"+this.name);  \n>       }  \n>   }  \n>   ```\n>\n>6. 使用接口组织枚举\n>\n>   ```\n>   public interface Food {  \n>       enum Coffee implements Food{  \n>           BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO  \n>       }  \n>       enum Dessert implements Food{  \n>           FRUIT, CAKE, GELATO  \n>       }  \n>   }\n>   ```\n>\n>7. 常量相关的方法\n>\n>   ```java\n>   public enum Constantmethod{\n>     DATE_TIME{\n>       String getInfo(){\n>         System.out.println(\"date_time\");\n>       }\n>     }\n>     CLASSPATH{\n>       String getInfo(){\n>         System.out.println(\"classpath\");\n>       }\n>     }\n>     //定义每个常量都要实现的方法\n>     abstract String getInfo();\n>   }\n>   ```\n>\n>基本使用\n>\n>```java\n>public enum Season {\n>    SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);\n>\n>    private int code;\n>    private Season(int code){\n>        this.code = code;\n>    }\n>\n>    public int getCode(){\n>        return code;\n>    }\n>}\n>public class UseSeason {\n>    /**\n>     * 将英文的季节转换成中文季节\n>     * @param season\n>     * @return\n>     */\n>    public String getChineseSeason(Season season){\n>        StringBuffer result = new StringBuffer();\n>        switch(season){\n>            case SPRING :\n>                result.append(\"[中文：春天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            case AUTUMN :\n>                result.append(\"[中文：秋天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            case SUMMER : \n>                result.append(\"[中文：夏天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            case WINTER :\n>                result.append(\"[中文：冬天，枚举常量:\" + season.name() + \"，数据:\" + season.getCode() + \"]\");\n>                break;\n>            default :\n>                result.append(\"地球没有的季节 \" + season.name());\n>                break;\n>        }\n>        return result.toString();\n>    }\n>\n>    public void doSomething(){\n>        for(Season s : Season.values()){\n>            System.out.println(getChineseSeason(s));//这是正常的场景\n>        }\n>        //System.out.println(getChineseSeason(5));\n>        //此处已经是编译不通过了，这就保证了类型安全\n>    }\n>\n>    public static void main(String[] arg){\n>        UseSeason useSeason = new UseSeason();\n>        useSeason.doSomething();\n>    }\n>}\n>```\n>\n>\n\n### 3. 枚举的使用总结\n\n>其实枚举的定义很像类的定义，只不过枚举有一些限制，你甚至可以在枚举里面写main方法，这也是可以运行通过的。不过枚举不能继承类，至于原因接下来的博客会说明，但是枚举可以实现接口，就像上面展示的用法一样。\n\n### 4.深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\n\n>#### 1. 枚举是如何保证线程安全\n>\n>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：\n>\n>```\n>public enum t {\n>    SPRING,SUMMER,AUTUMN,WINTER;\n>}\n>```\n>\n>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译（[Java的反编译](http://www.hollischuang.com/archives/58)）后代码内容如下：\n>\n>```\n>public final class T extends Enum\n>{\n>    private T(String s, int i)\n>    {\n>        super(s, i);\n>    }\n>    public static T[] values()\n>    {\n>        T at[];\n>        int i;\n>        T at1[];\n>        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);\n>        return at1;\n>    }\n>\n>    public static T valueOf(String s)\n>    {\n>        return (T)Enum.valueOf(demo/T, s);\n>    }\n>\n>    public static final T SPRING;\n>    public static final T SUMMER;\n>    public static final T AUTUMN;\n>    public static final T WINTER;\n>    private static final T ENUM$VALUES[];\n>    static\n>    {\n>        SPRING = new T(\"SPRING\", 0);\n>        SUMMER = new T(\"SUMMER\", 1);\n>        AUTUMN = new T(\"AUTUMN\", 2);\n>        WINTER = new T(\"WINTER\", 3);\n>        ENUM$VALUES = (new T[] {\n>            SPRING, SUMMER, AUTUMN, WINTER\n>        });\n>    }\n>}\n>```\n>\n>通过反编译后代码我们可以看到，`public final class T extends Enum`，说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。当我们使用`enmu`来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类,所以枚举类型不能被继承，我们看到这个类中有几个属性和方法。\n>\n>我们可以看到：\n>\n>```\n>        public static final T SPRING;\n>        public static final T SUMMER;\n>        public static final T AUTUMN;\n>        public static final T WINTER;\n>        private static final T ENUM$VALUES[];\n>        static\n>        {\n>            SPRING = new T(\"SPRING\", 0);\n>            SUMMER = new T(\"SUMMER\", 1);\n>            AUTUMN = new T(\"AUTUMN\", 2);\n>            WINTER = new T(\"WINTER\", 3);\n>            ENUM$VALUES = (new T[] {\n>                SPRING, SUMMER, AUTUMN, WINTER\n>            });\n>        }\n>```\n>\n>都是static类型的，因为static类型的属性会在类被加载之后被初始化，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，**创建一个enum类型是线程安全的**。\n>\n>### 为什么用枚举实现的单例是最好的方式\n>\n>在[[转+注\\]单例模式的七种写法](http://www.hollischuang.com/archives/205)中，我们看到一共有七种实现单例的方式，其中，**Effective Java**作者`Josh Bloch` 提倡使用枚举的方式，既然大神说这种方式好，那我们就要知道它为什么好？\n>\n>**1. 枚举写法简单**\n>\n>> 写法简单这个大家看看[[转+注\\]单例模式的七种写法]()里面的实现就知道区别了。\n>\n>```\n>public enum EasySingleton{\n>    INSTANCE;\n>}\n>```\n>\n>你可以通过`EasySingleton.INSTANCE`来访问。\n>\n>**2. 枚举自己处理序列化**\n>\n>> 我们知道，以前的所有的单例模式都有一个比较大的问题，就是一旦实现了Serializable接口之后，就不再是单例得了，因为，每次调用 readObject()方法返回的都是一个新创建出来的对象，有一种解决办法就是使用readResolve()方法来避免此事发生。但是，**为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定。**原文如下：\n>>\n>> > Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant’s name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant’s enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.\n>>\n>> 大概意思就是说，在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。 我们看一下这个`valueOf`方法：\n>\n>```\n>public static <T extends Enum<T>> T valueOf(Class<T> enumType,String name) {  \n>            T result = enumType.enumConstantDirectory().get(name);  \n>            if (result != null)  \n>                return result;  \n>            if (name == null)  \n>                throw new NullPointerException(\"Name is null\");  \n>            throw new IllegalArgumentException(  \n>                \"No enum const \" + enumType +\".\" + name);  \n>        }  \n>```\n>\n>从代码中可以看到，代码会尝试从调用`enumType`这个`Class`对象的`enumConstantDirectory()`方法返回的`map`中获取名字为`name`的枚举对象，如果不存在就会抛出异常。再进一步跟到`enumConstantDirectory()`方法，就会发现到最后会以反射的方式调用`enumType`这个类型的`values()`静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充`enumType`这个`Class`对象中的`enumConstantDirectory`属性。\n>\n>所以，**JVM对序列化有保证。**\n>\n>**3.枚举实例创建是thread-safe(线程安全的)**\n>\n>> 当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，**创建一个enum类型是线程安全的**。","slug":"枚举初探","published":1,"updated":"2019-01-04T01:48:59.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx6x002yeb1ugf1t9112","content":"<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<p>本篇博客的内容如下</p>\n<ol>\n<li>使用背景</li>\n<li>枚举定义和使用</li>\n<li>枚举的总结</li>\n<li>深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</li>\n</ol>\n</blockquote>\n<h3 id=\"1-使用背景\"><a href=\"#1-使用背景\" class=\"headerlink\" title=\"1.  使用背景\"></a>1.  使用背景</h3><blockquote>\n<p>在java语言还没有引入枚举类型之前，表示枚举类型的常用模式是声明一组int常量。之前通常利用public final static 方法定义。下面是一个小案例，分别用1 表示春天 2 表示夏天 3 表示秋天 4 表示冬天</p>\n<pre><code class=\"java\">public class Season {\n   public static final int SPRING = 1;\n   public static final int SUMMER = 2;\n   public static final int AUTUMN = 3;\n   public static final int WINTER = 4;\n}\n</code></pre>\n<p>这种方式称作int枚举模式。但是这种模式有一些问题。通常我们写出的代码都会从以下三个方面来进行分析，安全性、易用性和可读性。首先我们考虑一下他的安全性。当然这种模式不是类型安全的。比如我们设计一个函数，要求传入春夏秋冬的某个值。但是使用int类型，我们无法保证传入的值为合法。代码如下所示</p>\n<pre><code class=\"java\">private String getChineseSeason(int season){\n       StringBuffer result = new StringBuffer();\n       switch(season){\n           case Season.SPRING :\n               result.append(&quot;春天&quot;);\n               break;\n           case Season.SUMMER :\n               result.append(&quot;夏天&quot;);\n               break;\n           case Season.AUTUMN :\n               result.append(&quot;秋天&quot;);\n               break;\n           case Season.WINTER :\n               result.append(&quot;冬天&quot;);\n               break;\n           default :\n               result.append(&quot;地球没有的季节&quot;);\n               break;\n       }\n       return result.toString();\n   }\n\n   public void doSomething(){\n       //这是正常的场景\n       System.out.println(this.getChineseSeason(Season.SPRING));\n       //这个却是不正常的场景，这就导致了类型不安全问题\n       System.out.println(this.getChineseSeason(5));\n   }\n</code></pre>\n<p>程序<code>getChineseSeason(Season.SPRING)</code>是我们预期的使用方法。可<code>getChineseSeason(5)</code>显然就不是了，而且编译很通过，在运行时会出现什么情况，我们就不得而知了。这显然就不符合<code>Java</code>程序的类型安全。</p>\n<p>接下来我们考虑一下这种模式的可读性。使用枚举的大多数场合，我们都需要方便的到枚举类型的字符串表达式。如果将int枚举常量打印出来，我们所见到的就是一组数字，这是没什么太大的用处。我们可能会想到是一个String常量来代替int常量。虽然他为这些常量提供了可打印的字符串，但是他会导致性能问题，因为他依赖于字符串的比较操作，所以这种模式也是我们不期望的。从类型安全性和程序可读性俩方面考虑，int和String枚举模式的缺点就显露出来。幸运的是，从<code>Java1.5</code>发行版本开始，就提出了另一种可以替代的解决方案，可以避免<code>int</code>和<code>String</code>枚举模式的缺点，并提供了许多额外的好处。那就是枚举类型（<code>enum type</code>）。接下来的章节将介绍枚举类型的定义、特征、应用场景和优缺点。</p>\n</blockquote>\n<h3 id=\"2-枚举定义和使用\"><a href=\"#2-枚举定义和使用\" class=\"headerlink\" title=\"2. 枚举定义和使用\"></a>2. 枚举定义和使用</h3><blockquote>\n<p>枚举类型(enum type)是指由一组固定的常量组成合法的类型。java中由关键字enum来定义一个枚举类型。下面就是java枚举类型的定义:</p>\n<pre><code class=\"java\">publi enum Season{\n  SPRING, SUMMER, AUTUMN, WINER;\n}\n</code></pre>\n<p>枚举的用法主要由以下几种：</p>\n<ol>\n<li><p>常量，就如上面定义那样使用</p>\n</li>\n<li><p>switch</p>\n<pre><code class=\"java\">enum Signal {  \n   GREEN, YELLOW, RED  \n}  \npublic class TrafficLight {  \n   Signal color = Signal.RED;  \n   public void change() {  \n       switch (color) {  \n       case RED:  \n           color = Signal.GREEN;  \n           break;  \n       case YELLOW:  \n           color = Signal.RED;  \n           break;  \n       case GREEN:  \n           color = Signal.YELLOW;  \n           break;  \n       }  \n   }  \n}  \n</code></pre>\n</li>\n<li><p>向枚举中添加新的方法</p>\n<pre><code class=\"java\">public enum Color {  \n   RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  \n   // 成员变量  \n   private String name;  \n   private int index;  \n   // 构造方法  \n   private Color(String name, int index) {  \n       this.name = name;  \n       this.index = index;  \n   }  \n   // 普通方法  \n   public static String getName(int index) {  \n       for (Color c : Color.values()) {  \n           if (c.getIndex() == index) {  \n               return c.name;  \n           }  \n       }  \n       return null;  \n   }  \n   // get set 方法  \n   public String getName() {  \n       return name;  \n   }  \n   public void setName(String name) {  \n       this.name = name;  \n   }  \n   public int getIndex() {  \n       return index;  \n   }  \n   public void setIndex(int index) {  \n       this.index = index;  \n   }  \n}  \n</code></pre>\n</li>\n<li><p>覆盖枚举的方法</p>\n<pre><code class=\"java\">public enum Color {  \n  RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  \n  // 成员变量  \n  private String name;  \n  private int index;  \n  // 构造方法  \n  private Color(String name, int index) {  \n      this.name = name;  \n      this.index = index;  \n  }  \n  //覆盖方法  \n  @Override  \n  public String toString() {  \n      return this.index+&quot;_&quot;+this.name;  \n  }  \n}  \n</code></pre>\n</li>\n<li><p>实现接口</p>\n<pre><code class=\"java\">public interface Behaviour {  \n   void print();  \n   String getInfo();  \n}  \npublic enum Color implements Behaviour{  \n   RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  \n   // 成员变量  \n   private String name;  \n   private int index;  \n   // 构造方法  \n   private Color(String name, int index) {  \n       this.name = name;  \n       this.index = index;  \n   }  \n//接口方法  \n   @Override  \n   public String getInfo() {  \n       return this.name;  \n   }  \n   //接口方法  \n   @Override  \n   public void print() {  \n       System.out.println(this.index+&quot;:&quot;+this.name);  \n   }  \n}  \n</code></pre>\n</li>\n<li><p>使用接口组织枚举</p>\n<pre><code>public interface Food {  \n   enum Coffee implements Food{  \n       BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO  \n   }  \n   enum Dessert implements Food{  \n       FRUIT, CAKE, GELATO  \n   }  \n}\n</code></pre></li>\n<li><p>常量相关的方法</p>\n<pre><code class=\"java\">public enum Constantmethod{\n DATE_TIME{\n   String getInfo(){\n     System.out.println(&quot;date_time&quot;);\n   }\n }\n CLASSPATH{\n   String getInfo(){\n     System.out.println(&quot;classpath&quot;);\n   }\n }\n //定义每个常量都要实现的方法\n abstract String getInfo();\n}\n</code></pre>\n</li>\n</ol>\n<p>基本使用</p>\n<pre><code class=\"java\">public enum Season {\n   SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);\n\n   private int code;\n   private Season(int code){\n       this.code = code;\n   }\n\n   public int getCode(){\n       return code;\n   }\n}\npublic class UseSeason {\n   /**\n    * 将英文的季节转换成中文季节\n    * @param season\n    * @return\n    */\n   public String getChineseSeason(Season season){\n       StringBuffer result = new StringBuffer();\n       switch(season){\n           case SPRING :\n               result.append(&quot;[中文：春天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           case AUTUMN :\n               result.append(&quot;[中文：秋天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           case SUMMER : \n               result.append(&quot;[中文：夏天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           case WINTER :\n               result.append(&quot;[中文：冬天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           default :\n               result.append(&quot;地球没有的季节 &quot; + season.name());\n               break;\n       }\n       return result.toString();\n   }\n\n   public void doSomething(){\n       for(Season s : Season.values()){\n           System.out.println(getChineseSeason(s));//这是正常的场景\n       }\n       //System.out.println(getChineseSeason(5));\n       //此处已经是编译不通过了，这就保证了类型安全\n   }\n\n   public static void main(String[] arg){\n       UseSeason useSeason = new UseSeason();\n       useSeason.doSomething();\n   }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"3-枚举的使用总结\"><a href=\"#3-枚举的使用总结\" class=\"headerlink\" title=\"3. 枚举的使用总结\"></a>3. 枚举的使用总结</h3><blockquote>\n<p>其实枚举的定义很像类的定义，只不过枚举有一些限制，你甚至可以在枚举里面写main方法，这也是可以运行通过的。不过枚举不能继承类，至于原因接下来的博客会说明，但是枚举可以实现接口，就像上面展示的用法一样。</p>\n</blockquote>\n<h3 id=\"4-深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\"><a href=\"#4-深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\" class=\"headerlink\" title=\"4.深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\"></a>4.深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</h3><blockquote>\n<h4 id=\"1-枚举是如何保证线程安全\"><a href=\"#1-枚举是如何保证线程安全\" class=\"headerlink\" title=\"1. 枚举是如何保证线程安全\"></a>1. 枚举是如何保证线程安全</h4><p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：</p>\n<pre><code>public enum t {\n   SPRING,SUMMER,AUTUMN,WINTER;\n}\n</code></pre><p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译（<a href=\"http://www.hollischuang.com/archives/58\" target=\"_blank\" rel=\"noopener\">Java的反编译</a>）后代码内容如下：</p>\n<pre><code>public final class T extends Enum\n{\n   private T(String s, int i)\n   {\n       super(s, i);\n   }\n   public static T[] values()\n   {\n       T at[];\n       int i;\n       T at1[];\n       System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);\n       return at1;\n   }\n\n   public static T valueOf(String s)\n   {\n       return (T)Enum.valueOf(demo/T, s);\n   }\n\n   public static final T SPRING;\n   public static final T SUMMER;\n   public static final T AUTUMN;\n   public static final T WINTER;\n   private static final T ENUM$VALUES[];\n   static\n   {\n       SPRING = new T(&quot;SPRING&quot;, 0);\n       SUMMER = new T(&quot;SUMMER&quot;, 1);\n       AUTUMN = new T(&quot;AUTUMN&quot;, 2);\n       WINTER = new T(&quot;WINTER&quot;, 3);\n       ENUM$VALUES = (new T[] {\n           SPRING, SUMMER, AUTUMN, WINTER\n       });\n   }\n}\n</code></pre><p>通过反编译后代码我们可以看到，<code>public final class T extends Enum</code>，说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。当我们使用<code>enmu</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类,所以枚举类型不能被继承，我们看到这个类中有几个属性和方法。</p>\n<p>我们可以看到：</p>\n<pre><code>       public static final T SPRING;\n       public static final T SUMMER;\n       public static final T AUTUMN;\n       public static final T WINTER;\n       private static final T ENUM$VALUES[];\n       static\n       {\n           SPRING = new T(&quot;SPRING&quot;, 0);\n           SUMMER = new T(&quot;SUMMER&quot;, 1);\n           AUTUMN = new T(&quot;AUTUMN&quot;, 2);\n           WINTER = new T(&quot;WINTER&quot;, 3);\n           ENUM$VALUES = (new T[] {\n               SPRING, SUMMER, AUTUMN, WINTER\n           });\n       }\n</code></pre><p>都是static类型的，因为static类型的属性会在类被加载之后被初始化，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，<strong>创建一个enum类型是线程安全的</strong>。</p>\n<h3 id=\"为什么用枚举实现的单例是最好的方式\"><a href=\"#为什么用枚举实现的单例是最好的方式\" class=\"headerlink\" title=\"为什么用枚举实现的单例是最好的方式\"></a>为什么用枚举实现的单例是最好的方式</h3><p>在<a href=\"http://www.hollischuang.com/archives/205\" target=\"_blank\" rel=\"noopener\">[转+注]单例模式的七种写法</a>中，我们看到一共有七种实现单例的方式，其中，<strong>Effective Java</strong>作者<code>Josh Bloch</code> 提倡使用枚举的方式，既然大神说这种方式好，那我们就要知道它为什么好？</p>\n<p><strong>1. 枚举写法简单</strong></p>\n<blockquote>\n<p>写法简单这个大家看看<a href=\"\">[转+注]单例模式的七种写法</a>里面的实现就知道区别了。</p>\n</blockquote>\n<pre><code>public enum EasySingleton{\n   INSTANCE;\n}\n</code></pre><p>你可以通过<code>EasySingleton.INSTANCE</code>来访问。</p>\n<p><strong>2. 枚举自己处理序列化</strong></p>\n<blockquote>\n<p>我们知道，以前的所有的单例模式都有一个比较大的问题，就是一旦实现了Serializable接口之后，就不再是单例得了，因为，每次调用 readObject()方法返回的都是一个新创建出来的对象，有一种解决办法就是使用readResolve()方法来避免此事发生。但是，<strong>为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定。</strong>原文如下：</p>\n<blockquote>\n<p>Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant’s name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant’s enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.</p>\n</blockquote>\n<p>大概意思就是说，在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。 我们看一下这个<code>valueOf</code>方法：</p>\n</blockquote>\n<pre><code>public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name) {  \n           T result = enumType.enumConstantDirectory().get(name);  \n           if (result != null)  \n               return result;  \n           if (name == null)  \n               throw new NullPointerException(&quot;Name is null&quot;);  \n           throw new IllegalArgumentException(  \n               &quot;No enum const &quot; + enumType +&quot;.&quot; + name);  \n       }  \n</code></pre><p>从代码中可以看到，代码会尝试从调用<code>enumType</code>这个<code>Class</code>对象的<code>enumConstantDirectory()</code>方法返回的<code>map</code>中获取名字为<code>name</code>的枚举对象，如果不存在就会抛出异常。再进一步跟到<code>enumConstantDirectory()</code>方法，就会发现到最后会以反射的方式调用<code>enumType</code>这个类型的<code>values()</code>静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充<code>enumType</code>这个<code>Class</code>对象中的<code>enumConstantDirectory</code>属性。</p>\n<p>所以，<strong>JVM对序列化有保证。</strong></p>\n<p><strong>3.枚举实例创建是thread-safe(线程安全的)</strong></p>\n<blockquote>\n<p>当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，<strong>创建一个enum类型是线程安全的</strong>。</p>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<p>本篇博客的内容如下</p>\n<ol>\n<li>使用背景</li>\n<li>枚举定义和使用</li>\n<li>枚举的总结</li>\n<li>深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</li>\n</ol>\n</blockquote>\n<h3 id=\"1-使用背景\"><a href=\"#1-使用背景\" class=\"headerlink\" title=\"1.  使用背景\"></a>1.  使用背景</h3><blockquote>\n<p>在java语言还没有引入枚举类型之前，表示枚举类型的常用模式是声明一组int常量。之前通常利用public final static 方法定义。下面是一个小案例，分别用1 表示春天 2 表示夏天 3 表示秋天 4 表示冬天</p>\n<pre><code class=\"java\">public class Season {\n   public static final int SPRING = 1;\n   public static final int SUMMER = 2;\n   public static final int AUTUMN = 3;\n   public static final int WINTER = 4;\n}\n</code></pre>\n<p>这种方式称作int枚举模式。但是这种模式有一些问题。通常我们写出的代码都会从以下三个方面来进行分析，安全性、易用性和可读性。首先我们考虑一下他的安全性。当然这种模式不是类型安全的。比如我们设计一个函数，要求传入春夏秋冬的某个值。但是使用int类型，我们无法保证传入的值为合法。代码如下所示</p>\n<pre><code class=\"java\">private String getChineseSeason(int season){\n       StringBuffer result = new StringBuffer();\n       switch(season){\n           case Season.SPRING :\n               result.append(&quot;春天&quot;);\n               break;\n           case Season.SUMMER :\n               result.append(&quot;夏天&quot;);\n               break;\n           case Season.AUTUMN :\n               result.append(&quot;秋天&quot;);\n               break;\n           case Season.WINTER :\n               result.append(&quot;冬天&quot;);\n               break;\n           default :\n               result.append(&quot;地球没有的季节&quot;);\n               break;\n       }\n       return result.toString();\n   }\n\n   public void doSomething(){\n       //这是正常的场景\n       System.out.println(this.getChineseSeason(Season.SPRING));\n       //这个却是不正常的场景，这就导致了类型不安全问题\n       System.out.println(this.getChineseSeason(5));\n   }\n</code></pre>\n<p>程序<code>getChineseSeason(Season.SPRING)</code>是我们预期的使用方法。可<code>getChineseSeason(5)</code>显然就不是了，而且编译很通过，在运行时会出现什么情况，我们就不得而知了。这显然就不符合<code>Java</code>程序的类型安全。</p>\n<p>接下来我们考虑一下这种模式的可读性。使用枚举的大多数场合，我们都需要方便的到枚举类型的字符串表达式。如果将int枚举常量打印出来，我们所见到的就是一组数字，这是没什么太大的用处。我们可能会想到是一个String常量来代替int常量。虽然他为这些常量提供了可打印的字符串，但是他会导致性能问题，因为他依赖于字符串的比较操作，所以这种模式也是我们不期望的。从类型安全性和程序可读性俩方面考虑，int和String枚举模式的缺点就显露出来。幸运的是，从<code>Java1.5</code>发行版本开始，就提出了另一种可以替代的解决方案，可以避免<code>int</code>和<code>String</code>枚举模式的缺点，并提供了许多额外的好处。那就是枚举类型（<code>enum type</code>）。接下来的章节将介绍枚举类型的定义、特征、应用场景和优缺点。</p>\n</blockquote>\n<h3 id=\"2-枚举定义和使用\"><a href=\"#2-枚举定义和使用\" class=\"headerlink\" title=\"2. 枚举定义和使用\"></a>2. 枚举定义和使用</h3><blockquote>\n<p>枚举类型(enum type)是指由一组固定的常量组成合法的类型。java中由关键字enum来定义一个枚举类型。下面就是java枚举类型的定义:</p>\n<pre><code class=\"java\">publi enum Season{\n  SPRING, SUMMER, AUTUMN, WINER;\n}\n</code></pre>\n<p>枚举的用法主要由以下几种：</p>\n<ol>\n<li><p>常量，就如上面定义那样使用</p>\n</li>\n<li><p>switch</p>\n<pre><code class=\"java\">enum Signal {  \n   GREEN, YELLOW, RED  \n}  \npublic class TrafficLight {  \n   Signal color = Signal.RED;  \n   public void change() {  \n       switch (color) {  \n       case RED:  \n           color = Signal.GREEN;  \n           break;  \n       case YELLOW:  \n           color = Signal.RED;  \n           break;  \n       case GREEN:  \n           color = Signal.YELLOW;  \n           break;  \n       }  \n   }  \n}  \n</code></pre>\n</li>\n<li><p>向枚举中添加新的方法</p>\n<pre><code class=\"java\">public enum Color {  \n   RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  \n   // 成员变量  \n   private String name;  \n   private int index;  \n   // 构造方法  \n   private Color(String name, int index) {  \n       this.name = name;  \n       this.index = index;  \n   }  \n   // 普通方法  \n   public static String getName(int index) {  \n       for (Color c : Color.values()) {  \n           if (c.getIndex() == index) {  \n               return c.name;  \n           }  \n       }  \n       return null;  \n   }  \n   // get set 方法  \n   public String getName() {  \n       return name;  \n   }  \n   public void setName(String name) {  \n       this.name = name;  \n   }  \n   public int getIndex() {  \n       return index;  \n   }  \n   public void setIndex(int index) {  \n       this.index = index;  \n   }  \n}  \n</code></pre>\n</li>\n<li><p>覆盖枚举的方法</p>\n<pre><code class=\"java\">public enum Color {  \n  RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  \n  // 成员变量  \n  private String name;  \n  private int index;  \n  // 构造方法  \n  private Color(String name, int index) {  \n      this.name = name;  \n      this.index = index;  \n  }  \n  //覆盖方法  \n  @Override  \n  public String toString() {  \n      return this.index+&quot;_&quot;+this.name;  \n  }  \n}  \n</code></pre>\n</li>\n<li><p>实现接口</p>\n<pre><code class=\"java\">public interface Behaviour {  \n   void print();  \n   String getInfo();  \n}  \npublic enum Color implements Behaviour{  \n   RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  \n   // 成员变量  \n   private String name;  \n   private int index;  \n   // 构造方法  \n   private Color(String name, int index) {  \n       this.name = name;  \n       this.index = index;  \n   }  \n//接口方法  \n   @Override  \n   public String getInfo() {  \n       return this.name;  \n   }  \n   //接口方法  \n   @Override  \n   public void print() {  \n       System.out.println(this.index+&quot;:&quot;+this.name);  \n   }  \n}  \n</code></pre>\n</li>\n<li><p>使用接口组织枚举</p>\n<pre><code>public interface Food {  \n   enum Coffee implements Food{  \n       BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO  \n   }  \n   enum Dessert implements Food{  \n       FRUIT, CAKE, GELATO  \n   }  \n}\n</code></pre></li>\n<li><p>常量相关的方法</p>\n<pre><code class=\"java\">public enum Constantmethod{\n DATE_TIME{\n   String getInfo(){\n     System.out.println(&quot;date_time&quot;);\n   }\n }\n CLASSPATH{\n   String getInfo(){\n     System.out.println(&quot;classpath&quot;);\n   }\n }\n //定义每个常量都要实现的方法\n abstract String getInfo();\n}\n</code></pre>\n</li>\n</ol>\n<p>基本使用</p>\n<pre><code class=\"java\">public enum Season {\n   SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);\n\n   private int code;\n   private Season(int code){\n       this.code = code;\n   }\n\n   public int getCode(){\n       return code;\n   }\n}\npublic class UseSeason {\n   /**\n    * 将英文的季节转换成中文季节\n    * @param season\n    * @return\n    */\n   public String getChineseSeason(Season season){\n       StringBuffer result = new StringBuffer();\n       switch(season){\n           case SPRING :\n               result.append(&quot;[中文：春天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           case AUTUMN :\n               result.append(&quot;[中文：秋天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           case SUMMER : \n               result.append(&quot;[中文：夏天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           case WINTER :\n               result.append(&quot;[中文：冬天，枚举常量:&quot; + season.name() + &quot;，数据:&quot; + season.getCode() + &quot;]&quot;);\n               break;\n           default :\n               result.append(&quot;地球没有的季节 &quot; + season.name());\n               break;\n       }\n       return result.toString();\n   }\n\n   public void doSomething(){\n       for(Season s : Season.values()){\n           System.out.println(getChineseSeason(s));//这是正常的场景\n       }\n       //System.out.println(getChineseSeason(5));\n       //此处已经是编译不通过了，这就保证了类型安全\n   }\n\n   public static void main(String[] arg){\n       UseSeason useSeason = new UseSeason();\n       useSeason.doSomething();\n   }\n}\n</code></pre>\n</blockquote>\n<h3 id=\"3-枚举的使用总结\"><a href=\"#3-枚举的使用总结\" class=\"headerlink\" title=\"3. 枚举的使用总结\"></a>3. 枚举的使用总结</h3><blockquote>\n<p>其实枚举的定义很像类的定义，只不过枚举有一些限制，你甚至可以在枚举里面写main方法，这也是可以运行通过的。不过枚举不能继承类，至于原因接下来的博客会说明，但是枚举可以实现接口，就像上面展示的用法一样。</p>\n</blockquote>\n<h3 id=\"4-深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\"><a href=\"#4-深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\" class=\"headerlink\" title=\"4.深度分析Java的枚举类型—-枚举的线程安全性及序列化问题\"></a>4.深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</h3><blockquote>\n<h4 id=\"1-枚举是如何保证线程安全\"><a href=\"#1-枚举是如何保证线程安全\" class=\"headerlink\" title=\"1. 枚举是如何保证线程安全\"></a>1. 枚举是如何保证线程安全</h4><p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：</p>\n<pre><code>public enum t {\n   SPRING,SUMMER,AUTUMN,WINTER;\n}\n</code></pre><p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译（<a href=\"http://www.hollischuang.com/archives/58\" target=\"_blank\" rel=\"noopener\">Java的反编译</a>）后代码内容如下：</p>\n<pre><code>public final class T extends Enum\n{\n   private T(String s, int i)\n   {\n       super(s, i);\n   }\n   public static T[] values()\n   {\n       T at[];\n       int i;\n       T at1[];\n       System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);\n       return at1;\n   }\n\n   public static T valueOf(String s)\n   {\n       return (T)Enum.valueOf(demo/T, s);\n   }\n\n   public static final T SPRING;\n   public static final T SUMMER;\n   public static final T AUTUMN;\n   public static final T WINTER;\n   private static final T ENUM$VALUES[];\n   static\n   {\n       SPRING = new T(&quot;SPRING&quot;, 0);\n       SUMMER = new T(&quot;SUMMER&quot;, 1);\n       AUTUMN = new T(&quot;AUTUMN&quot;, 2);\n       WINTER = new T(&quot;WINTER&quot;, 3);\n       ENUM$VALUES = (new T[] {\n           SPRING, SUMMER, AUTUMN, WINTER\n       });\n   }\n}\n</code></pre><p>通过反编译后代码我们可以看到，<code>public final class T extends Enum</code>，说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。当我们使用<code>enmu</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类,所以枚举类型不能被继承，我们看到这个类中有几个属性和方法。</p>\n<p>我们可以看到：</p>\n<pre><code>       public static final T SPRING;\n       public static final T SUMMER;\n       public static final T AUTUMN;\n       public static final T WINTER;\n       private static final T ENUM$VALUES[];\n       static\n       {\n           SPRING = new T(&quot;SPRING&quot;, 0);\n           SUMMER = new T(&quot;SUMMER&quot;, 1);\n           AUTUMN = new T(&quot;AUTUMN&quot;, 2);\n           WINTER = new T(&quot;WINTER&quot;, 3);\n           ENUM$VALUES = (new T[] {\n               SPRING, SUMMER, AUTUMN, WINTER\n           });\n       }\n</code></pre><p>都是static类型的，因为static类型的属性会在类被加载之后被初始化，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，<strong>创建一个enum类型是线程安全的</strong>。</p>\n<h3 id=\"为什么用枚举实现的单例是最好的方式\"><a href=\"#为什么用枚举实现的单例是最好的方式\" class=\"headerlink\" title=\"为什么用枚举实现的单例是最好的方式\"></a>为什么用枚举实现的单例是最好的方式</h3><p>在<a href=\"http://www.hollischuang.com/archives/205\" target=\"_blank\" rel=\"noopener\">[转+注]单例模式的七种写法</a>中，我们看到一共有七种实现单例的方式，其中，<strong>Effective Java</strong>作者<code>Josh Bloch</code> 提倡使用枚举的方式，既然大神说这种方式好，那我们就要知道它为什么好？</p>\n<p><strong>1. 枚举写法简单</strong></p>\n<blockquote>\n<p>写法简单这个大家看看<a href=\"\">[转+注]单例模式的七种写法</a>里面的实现就知道区别了。</p>\n</blockquote>\n<pre><code>public enum EasySingleton{\n   INSTANCE;\n}\n</code></pre><p>你可以通过<code>EasySingleton.INSTANCE</code>来访问。</p>\n<p><strong>2. 枚举自己处理序列化</strong></p>\n<blockquote>\n<p>我们知道，以前的所有的单例模式都有一个比较大的问题，就是一旦实现了Serializable接口之后，就不再是单例得了，因为，每次调用 readObject()方法返回的都是一个新创建出来的对象，有一种解决办法就是使用readResolve()方法来避免此事发生。但是，<strong>为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定。</strong>原文如下：</p>\n<blockquote>\n<p>Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant’s name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant’s enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.</p>\n</blockquote>\n<p>大概意思就是说，在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。 我们看一下这个<code>valueOf</code>方法：</p>\n</blockquote>\n<pre><code>public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name) {  \n           T result = enumType.enumConstantDirectory().get(name);  \n           if (result != null)  \n               return result;  \n           if (name == null)  \n               throw new NullPointerException(&quot;Name is null&quot;);  \n           throw new IllegalArgumentException(  \n               &quot;No enum const &quot; + enumType +&quot;.&quot; + name);  \n       }  \n</code></pre><p>从代码中可以看到，代码会尝试从调用<code>enumType</code>这个<code>Class</code>对象的<code>enumConstantDirectory()</code>方法返回的<code>map</code>中获取名字为<code>name</code>的枚举对象，如果不存在就会抛出异常。再进一步跟到<code>enumConstantDirectory()</code>方法，就会发现到最后会以反射的方式调用<code>enumType</code>这个类型的<code>values()</code>静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充<code>enumType</code>这个<code>Class</code>对象中的<code>enumConstantDirectory</code>属性。</p>\n<p>所以，<strong>JVM对序列化有保证。</strong></p>\n<p><strong>3.枚举实例创建是thread-safe(线程安全的)</strong></p>\n<blockquote>\n<p>当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，<strong>创建一个enum类型是线程安全的</strong>。</p>\n</blockquote>\n</blockquote>\n"},{"abbrlink":13,"title":"Iterator 和 Iterable 区别","author":"zhangke","date":"2017-12-23T11:31:00.000Z","_content":"# Iterator 和 Iterable 区别\n\n### Iterator（迭代器）\n\n作为一种设计模式，迭代器可以用于遍历一个对象，而开发人员不用去了解这个对象的底层结构。\n\n这里就不仔细说迭代器这种设计模式，因为我们主要的目的是探索 java 中 Iterator 和 Iterable 之间的区别\n\n### 用法\n\n首先来说一下他们各自是怎么使用，不会用谈什么都是瞎搞。\n\n#### Iterator 用法\n\n首先来说一下 Iterator 这个接口，他定义了迭代器基本的功能。\n\n#### 源码如下\n\n```\npackage java.util;\n\npublic interface Iterator<E> {\n    boolean hasNext();   //返回是否有下一个元素\n    E next();            //返回下一个元素\n    void remove();\t\t //移除当前元素\n}\n\n\n```\n\n#### 如何使用这个接口\n\n```\npublic class main {\n\n    public static void main(String[] args) {\n        MyIterator mi = new MyIterator();\n        while (mi.hasNext()){\n            System.out.printf(\"%s\\t\",mi.next());\n        }\n    }\n}\n\nclass MyIterator implements Iterator<String>{\n    private String[] words = (\"And that is how \"\n            + \"we know the Earth to be banana-shaped.\").split(\" \");\n    private int count = 0;\n    public MyIterator() {\n    }\n\n    @Override\n    public boolean hasNext() {\n        return count < words.length;\n    }\n\n    @Override\n    public String next() {\n        return words[count++];\n    }\n}\n```\n\n代码很简单，所以就不过多的解释了，但是有一点需要注意的是，下面这样使用上面定义的 MyIterator 类是错误的，你可以试一下。\n\n```\nfor (String s:new MyIterator){\n            System.out.printf(\"%s\\t\",s);\n }\n```\n\n### Iterable 用法\n\n#### 源码\n\n```\npackage java.lang;\n\nimport java.util.Iterator;\n\npublic interface Iterable<T> {\n\n    Iterator<T> iterator();\n}\n```\n\n#### 如何使用\n\n```\npublic class main {\n\n    public static void main(String[] args) {\n\n      MyIterable myIterable= new MyIterable();\n        Iterator<String> mIterator = myIterable.iterator();\n        for (String s:myIterable){\n            System.out.printf(\"%s\\t\",s);\n        }\n    }\n}\n\nclass MyIterable implements Iterable<String>{\n    private String[] words = (\"And that is how \"\n            + \"we know the Earth to be banana-shaped.\").split(\" \");\n\n    @Override\n    public Iterator<String> iterator() {\n        return new Iterator<String>() {\n            private int i = 0;\n            @Override\n            public boolean hasNext() {\n                return i < words.length;\n            }\n\n            @Override\n            public String next() {\n                return words[i++];\n            }\n        };\n    }\n}\n```\n\n与上面 Iterator 不同的是，这个类还可以下面这样使用\n\n```\n\t\tMyIterable mi = new MyIterable().iterator();\n        while (mi.hasNext()){\n            System.out.printf(\"%s\\t\",mi.next());\n        } \n```\n\n### 区别\n\n基本用法已经说完，相信你也能看出其中的一些区别\n\n1. Iterator 是迭代器类(这个类是指定义了迭代器基本需要的方法)，而 Iterable 是接口。 这个从他们的包名就可以看出来。\n\n```Java\njava.lang.Iterable\njava.util.Iterator\n```\n\n1. Iterator 不嫩用于 foreach 循环语句，Iterable 可以\n\n2. 为什么一定要实现 Iterable 接口，为什么不直接实现 Iterator 接口呢？\n\n   看一下 JDK 中的集合类，比如 List 一族或者 Set 一族，都是实现了 Iterable 接口，但并不直接实现 Iterator 接口。\n\n   这并不是没有道理的。\n\n   ​ 因为 Iterator 接口的核心方法 next()或者 hasNext() 是依赖于迭代器的当前迭代位置的。\n\n   如果 Collection 直接实现 Iterator 接口，势必导致集合对象中包含当前迭代位置的数据(指针)。\n\n   ​ 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么 next()方法的结果会变成不可预知。 除非再为 Iterator 接口添加一个 reset()方法，用来重置当前迭代位置。 但即时这样，Collection 也只能同时存在一个当前迭代位置。\n\n   而 Iterable 则不然，每次调用都会返回一个从头开始计数的迭代器。\n\n   多个迭代器是互不干扰的\n\n### 扩展\n\n你在看 ArrayList 源码的时候，你会发现这样一段代码\n\n```Java\n   private class Itr implements Iterator<E> {\n       int cursor;       // 返回下一个元素的索引\n\n     \tint lastRet = -1; // 返回最后一个元素的索引，如果空，返回-1\n\n       int expectedModCount = modCount; //用于检测当前集合是否执行了添加删除操作，其中modCount，是当前集合中元素的个数\n\n       public boolean hasNext() {\n           return cursor != size;\n       }\n\n       @SuppressWarnings(\"unchecked\")\n       public E next() {\n           checkForComodification(); //检测集合元素是否执行添加删除操作\n           int i = cursor;\n           if (i >= size)\n               throw new NoSuchElementException();\n           Object[] elementData = ArrayList.this.elementData;\n           if (i >= elementData.length)\n               throw new ConcurrentModificationException();\n           cursor = i + 1;\n           return (E) elementData[lastRet = i];\n       }\n\n       public void remove() {\n           if (lastRet < 0)\n               throw new IllegalStateException();\n           checkForComodification();\n\n           try {\n               ArrayList.this.remove(lastRet);\n               cursor = lastRet;\n               lastRet = -1;\n               expectedModCount = modCount;\n           } catch (IndexOutOfBoundsException ex) {\n               throw new ConcurrentModificationException();\n           }\n       }\n\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void forEachRemaining(Consumer<? super E> consumer) {\n           Objects.requireNonNull(consumer);\n           final int size = ArrayList.this.size;\n           int i = cursor;\n           if (i >= size) {\n               return;\n           }\n           final Object[] elementData = ArrayList.this.elementData;\n           if (i >= elementData.length) {\n               throw new ConcurrentModificationException();\n           }\n           while (i != size && modCount == expectedModCount) {\n               consumer.accept((E) elementData[i++]);\n           }\n           // update once at end of iteration to reduce heap write traffic\n           cursor = i;\n           lastRet = i - 1;\n           checkForComodification();\n       }\n\t\t//如果发生添加删除操作，则抛出错误。\n       final void checkForComodification() {\n           if (modCount != expectedModCount)\n               throw new ConcurrentModificationException();\n       }\n   }\n```\n\n​ 对于上述的代码不难看懂，有点疑惑的是 int expectedModCount = modCount;这句代码\n\n​其实这是集合迭代中的一种**快速失败**机制，这种机制提供迭代过程中集合的安全性。阅读源码​ 就可以知道 ArrayList 中存在 modCount 对象，增删操作都会使 modCount++，通过两者的对比​ 迭代器可以快速的知道迭代过程中是否存在 list.add()类似的操作，存在的话快速失败!\n\n## Fail-Fast(快速失败)机制\n\n仔细观察上述的各个方法，我们在源码中就会发现一个特别的属性 modCount，API 解释如下：\n\n​ The number of times this list has been structurally modified. Structural modifications are those​ that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress​ may yield incorrect results.\n\n记录修改此列表的次数：包括改变列表的结构，改变列表的大小，打乱列表的顺序等使正在进行 迭代产生 错误的结果。\n\nTips:仅仅设置元素的值并不是结构的修改\n\n我们知道的是 ArrayList 是线程不安全的，如果在使用迭代器的过程中有其他的线程修改了 List 就会抛出 ConcurrentModificationException 这就是 Fail-Fast 机制。那么快速失败究竟是个什么意思呢？在 ArrayList 类创建迭代器之后，除非通过迭代器自身 remove 或 add 对列表结构进行修改，否则在其他线程中以任何形式对列表进行修改，迭代器马上会抛出异常，快速失败。\n\n### 迭代器的好处\n\n## 迭代器的好处\n\n​ 通过上述我们明白了迭代是到底是个什么，迭代器的使用也十分的简单。现在简要的总结下使用迭代器的好处吧。\n\n​ **1、迭代器可以提供统一的迭代方式。**\n\n**​ 2、 迭代器也可以在对客户端透明的情况下，提供各种不同的迭代方式。**\n\n​ **3、迭代器提供一种快速失败机制，防止多线程下迭代的不安全操作。**\n\n​ 不过对于第三点尚需注意的是：就像上述事例代码一样，我们不能保证迭代过程中出现**快速失败**的都是因为同步造成的，因此为了保证迭代操作的正确性而去依赖此类异常是错误的！","source":"_posts/java 中 Iterator 和 Iterable 区别.md","raw":"abbrlink: 13\ntitle: Iterator 和 Iterable 区别\ntags:\n  - java\ncategories:\n  - java\nauthor: zhangke\ndate: 2017-12-23 19:31:00\n---\n# Iterator 和 Iterable 区别\n\n### Iterator（迭代器）\n\n作为一种设计模式，迭代器可以用于遍历一个对象，而开发人员不用去了解这个对象的底层结构。\n\n这里就不仔细说迭代器这种设计模式，因为我们主要的目的是探索 java 中 Iterator 和 Iterable 之间的区别\n\n### 用法\n\n首先来说一下他们各自是怎么使用，不会用谈什么都是瞎搞。\n\n#### Iterator 用法\n\n首先来说一下 Iterator 这个接口，他定义了迭代器基本的功能。\n\n#### 源码如下\n\n```\npackage java.util;\n\npublic interface Iterator<E> {\n    boolean hasNext();   //返回是否有下一个元素\n    E next();            //返回下一个元素\n    void remove();\t\t //移除当前元素\n}\n\n\n```\n\n#### 如何使用这个接口\n\n```\npublic class main {\n\n    public static void main(String[] args) {\n        MyIterator mi = new MyIterator();\n        while (mi.hasNext()){\n            System.out.printf(\"%s\\t\",mi.next());\n        }\n    }\n}\n\nclass MyIterator implements Iterator<String>{\n    private String[] words = (\"And that is how \"\n            + \"we know the Earth to be banana-shaped.\").split(\" \");\n    private int count = 0;\n    public MyIterator() {\n    }\n\n    @Override\n    public boolean hasNext() {\n        return count < words.length;\n    }\n\n    @Override\n    public String next() {\n        return words[count++];\n    }\n}\n```\n\n代码很简单，所以就不过多的解释了，但是有一点需要注意的是，下面这样使用上面定义的 MyIterator 类是错误的，你可以试一下。\n\n```\nfor (String s:new MyIterator){\n            System.out.printf(\"%s\\t\",s);\n }\n```\n\n### Iterable 用法\n\n#### 源码\n\n```\npackage java.lang;\n\nimport java.util.Iterator;\n\npublic interface Iterable<T> {\n\n    Iterator<T> iterator();\n}\n```\n\n#### 如何使用\n\n```\npublic class main {\n\n    public static void main(String[] args) {\n\n      MyIterable myIterable= new MyIterable();\n        Iterator<String> mIterator = myIterable.iterator();\n        for (String s:myIterable){\n            System.out.printf(\"%s\\t\",s);\n        }\n    }\n}\n\nclass MyIterable implements Iterable<String>{\n    private String[] words = (\"And that is how \"\n            + \"we know the Earth to be banana-shaped.\").split(\" \");\n\n    @Override\n    public Iterator<String> iterator() {\n        return new Iterator<String>() {\n            private int i = 0;\n            @Override\n            public boolean hasNext() {\n                return i < words.length;\n            }\n\n            @Override\n            public String next() {\n                return words[i++];\n            }\n        };\n    }\n}\n```\n\n与上面 Iterator 不同的是，这个类还可以下面这样使用\n\n```\n\t\tMyIterable mi = new MyIterable().iterator();\n        while (mi.hasNext()){\n            System.out.printf(\"%s\\t\",mi.next());\n        } \n```\n\n### 区别\n\n基本用法已经说完，相信你也能看出其中的一些区别\n\n1. Iterator 是迭代器类(这个类是指定义了迭代器基本需要的方法)，而 Iterable 是接口。 这个从他们的包名就可以看出来。\n\n```Java\njava.lang.Iterable\njava.util.Iterator\n```\n\n1. Iterator 不嫩用于 foreach 循环语句，Iterable 可以\n\n2. 为什么一定要实现 Iterable 接口，为什么不直接实现 Iterator 接口呢？\n\n   看一下 JDK 中的集合类，比如 List 一族或者 Set 一族，都是实现了 Iterable 接口，但并不直接实现 Iterator 接口。\n\n   这并不是没有道理的。\n\n   ​ 因为 Iterator 接口的核心方法 next()或者 hasNext() 是依赖于迭代器的当前迭代位置的。\n\n   如果 Collection 直接实现 Iterator 接口，势必导致集合对象中包含当前迭代位置的数据(指针)。\n\n   ​ 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么 next()方法的结果会变成不可预知。 除非再为 Iterator 接口添加一个 reset()方法，用来重置当前迭代位置。 但即时这样，Collection 也只能同时存在一个当前迭代位置。\n\n   而 Iterable 则不然，每次调用都会返回一个从头开始计数的迭代器。\n\n   多个迭代器是互不干扰的\n\n### 扩展\n\n你在看 ArrayList 源码的时候，你会发现这样一段代码\n\n```Java\n   private class Itr implements Iterator<E> {\n       int cursor;       // 返回下一个元素的索引\n\n     \tint lastRet = -1; // 返回最后一个元素的索引，如果空，返回-1\n\n       int expectedModCount = modCount; //用于检测当前集合是否执行了添加删除操作，其中modCount，是当前集合中元素的个数\n\n       public boolean hasNext() {\n           return cursor != size;\n       }\n\n       @SuppressWarnings(\"unchecked\")\n       public E next() {\n           checkForComodification(); //检测集合元素是否执行添加删除操作\n           int i = cursor;\n           if (i >= size)\n               throw new NoSuchElementException();\n           Object[] elementData = ArrayList.this.elementData;\n           if (i >= elementData.length)\n               throw new ConcurrentModificationException();\n           cursor = i + 1;\n           return (E) elementData[lastRet = i];\n       }\n\n       public void remove() {\n           if (lastRet < 0)\n               throw new IllegalStateException();\n           checkForComodification();\n\n           try {\n               ArrayList.this.remove(lastRet);\n               cursor = lastRet;\n               lastRet = -1;\n               expectedModCount = modCount;\n           } catch (IndexOutOfBoundsException ex) {\n               throw new ConcurrentModificationException();\n           }\n       }\n\n       @Override\n       @SuppressWarnings(\"unchecked\")\n       public void forEachRemaining(Consumer<? super E> consumer) {\n           Objects.requireNonNull(consumer);\n           final int size = ArrayList.this.size;\n           int i = cursor;\n           if (i >= size) {\n               return;\n           }\n           final Object[] elementData = ArrayList.this.elementData;\n           if (i >= elementData.length) {\n               throw new ConcurrentModificationException();\n           }\n           while (i != size && modCount == expectedModCount) {\n               consumer.accept((E) elementData[i++]);\n           }\n           // update once at end of iteration to reduce heap write traffic\n           cursor = i;\n           lastRet = i - 1;\n           checkForComodification();\n       }\n\t\t//如果发生添加删除操作，则抛出错误。\n       final void checkForComodification() {\n           if (modCount != expectedModCount)\n               throw new ConcurrentModificationException();\n       }\n   }\n```\n\n​ 对于上述的代码不难看懂，有点疑惑的是 int expectedModCount = modCount;这句代码\n\n​其实这是集合迭代中的一种**快速失败**机制，这种机制提供迭代过程中集合的安全性。阅读源码​ 就可以知道 ArrayList 中存在 modCount 对象，增删操作都会使 modCount++，通过两者的对比​ 迭代器可以快速的知道迭代过程中是否存在 list.add()类似的操作，存在的话快速失败!\n\n## Fail-Fast(快速失败)机制\n\n仔细观察上述的各个方法，我们在源码中就会发现一个特别的属性 modCount，API 解释如下：\n\n​ The number of times this list has been structurally modified. Structural modifications are those​ that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress​ may yield incorrect results.\n\n记录修改此列表的次数：包括改变列表的结构，改变列表的大小，打乱列表的顺序等使正在进行 迭代产生 错误的结果。\n\nTips:仅仅设置元素的值并不是结构的修改\n\n我们知道的是 ArrayList 是线程不安全的，如果在使用迭代器的过程中有其他的线程修改了 List 就会抛出 ConcurrentModificationException 这就是 Fail-Fast 机制。那么快速失败究竟是个什么意思呢？在 ArrayList 类创建迭代器之后，除非通过迭代器自身 remove 或 add 对列表结构进行修改，否则在其他线程中以任何形式对列表进行修改，迭代器马上会抛出异常，快速失败。\n\n### 迭代器的好处\n\n## 迭代器的好处\n\n​ 通过上述我们明白了迭代是到底是个什么，迭代器的使用也十分的简单。现在简要的总结下使用迭代器的好处吧。\n\n​ **1、迭代器可以提供统一的迭代方式。**\n\n**​ 2、 迭代器也可以在对客户端透明的情况下，提供各种不同的迭代方式。**\n\n​ **3、迭代器提供一种快速失败机制，防止多线程下迭代的不安全操作。**\n\n​ 不过对于第三点尚需注意的是：就像上述事例代码一样，我们不能保证迭代过程中出现**快速失败**的都是因为同步造成的，因此为了保证迭代操作的正确性而去依赖此类异常是错误的！","slug":"java 中 Iterator 和 Iterable 区别","published":1,"updated":"2019-01-04T01:48:59.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxx710031eb1upven2t7x","content":"<h1 id=\"Iterator-和-Iterable-区别\"><a href=\"#Iterator-和-Iterable-区别\" class=\"headerlink\" title=\"Iterator 和 Iterable 区别\"></a>Iterator 和 Iterable 区别</h1><h3 id=\"Iterator（迭代器）\"><a href=\"#Iterator（迭代器）\" class=\"headerlink\" title=\"Iterator（迭代器）\"></a>Iterator（迭代器）</h3><p>作为一种设计模式，迭代器可以用于遍历一个对象，而开发人员不用去了解这个对象的底层结构。</p>\n<p>这里就不仔细说迭代器这种设计模式，因为我们主要的目的是探索 java 中 Iterator 和 Iterable 之间的区别</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>首先来说一下他们各自是怎么使用，不会用谈什么都是瞎搞。</p>\n<h4 id=\"Iterator-用法\"><a href=\"#Iterator-用法\" class=\"headerlink\" title=\"Iterator 用法\"></a>Iterator 用法</h4><p>首先来说一下 Iterator 这个接口，他定义了迭代器基本的功能。</p>\n<h4 id=\"源码如下\"><a href=\"#源码如下\" class=\"headerlink\" title=\"源码如下\"></a>源码如下</h4><pre><code>package java.util;\n\npublic interface Iterator&lt;E&gt; {\n    boolean hasNext();   //返回是否有下一个元素\n    E next();            //返回下一个元素\n    void remove();         //移除当前元素\n}\n\n\n</code></pre><h4 id=\"如何使用这个接口\"><a href=\"#如何使用这个接口\" class=\"headerlink\" title=\"如何使用这个接口\"></a>如何使用这个接口</h4><pre><code>public class main {\n\n    public static void main(String[] args) {\n        MyIterator mi = new MyIterator();\n        while (mi.hasNext()){\n            System.out.printf(&quot;%s\\t&quot;,mi.next());\n        }\n    }\n}\n\nclass MyIterator implements Iterator&lt;String&gt;{\n    private String[] words = (&quot;And that is how &quot;\n            + &quot;we know the Earth to be banana-shaped.&quot;).split(&quot; &quot;);\n    private int count = 0;\n    public MyIterator() {\n    }\n\n    @Override\n    public boolean hasNext() {\n        return count &lt; words.length;\n    }\n\n    @Override\n    public String next() {\n        return words[count++];\n    }\n}\n</code></pre><p>代码很简单，所以就不过多的解释了，但是有一点需要注意的是，下面这样使用上面定义的 MyIterator 类是错误的，你可以试一下。</p>\n<pre><code>for (String s:new MyIterator){\n            System.out.printf(&quot;%s\\t&quot;,s);\n }\n</code></pre><h3 id=\"Iterable-用法\"><a href=\"#Iterable-用法\" class=\"headerlink\" title=\"Iterable 用法\"></a>Iterable 用法</h3><h4 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h4><pre><code>package java.lang;\n\nimport java.util.Iterator;\n\npublic interface Iterable&lt;T&gt; {\n\n    Iterator&lt;T&gt; iterator();\n}\n</code></pre><h4 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h4><pre><code>public class main {\n\n    public static void main(String[] args) {\n\n      MyIterable myIterable= new MyIterable();\n        Iterator&lt;String&gt; mIterator = myIterable.iterator();\n        for (String s:myIterable){\n            System.out.printf(&quot;%s\\t&quot;,s);\n        }\n    }\n}\n\nclass MyIterable implements Iterable&lt;String&gt;{\n    private String[] words = (&quot;And that is how &quot;\n            + &quot;we know the Earth to be banana-shaped.&quot;).split(&quot; &quot;);\n\n    @Override\n    public Iterator&lt;String&gt; iterator() {\n        return new Iterator&lt;String&gt;() {\n            private int i = 0;\n            @Override\n            public boolean hasNext() {\n                return i &lt; words.length;\n            }\n\n            @Override\n            public String next() {\n                return words[i++];\n            }\n        };\n    }\n}\n</code></pre><p>与上面 Iterator 不同的是，这个类还可以下面这样使用</p>\n<pre><code>        MyIterable mi = new MyIterable().iterator();\n        while (mi.hasNext()){\n            System.out.printf(&quot;%s\\t&quot;,mi.next());\n        } \n</code></pre><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p>基本用法已经说完，相信你也能看出其中的一些区别</p>\n<ol>\n<li>Iterator 是迭代器类(这个类是指定义了迭代器基本需要的方法)，而 Iterable 是接口。 这个从他们的包名就可以看出来。</li>\n</ol>\n<pre><code class=\"Java\">java.lang.Iterable\njava.util.Iterator\n</code></pre>\n<ol>\n<li><p>Iterator 不嫩用于 foreach 循环语句，Iterable 可以</p>\n</li>\n<li><p>为什么一定要实现 Iterable 接口，为什么不直接实现 Iterator 接口呢？</p>\n<p>看一下 JDK 中的集合类，比如 List 一族或者 Set 一族，都是实现了 Iterable 接口，但并不直接实现 Iterator 接口。</p>\n<p>这并不是没有道理的。</p>\n<p>​ 因为 Iterator 接口的核心方法 next()或者 hasNext() 是依赖于迭代器的当前迭代位置的。</p>\n<p>如果 Collection 直接实现 Iterator 接口，势必导致集合对象中包含当前迭代位置的数据(指针)。</p>\n<p>​ 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么 next()方法的结果会变成不可预知。 除非再为 Iterator 接口添加一个 reset()方法，用来重置当前迭代位置。 但即时这样，Collection 也只能同时存在一个当前迭代位置。</p>\n<p>而 Iterable 则不然，每次调用都会返回一个从头开始计数的迭代器。</p>\n<p>多个迭代器是互不干扰的</p>\n</li>\n</ol>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p>你在看 ArrayList 源码的时候，你会发现这样一段代码</p>\n<pre><code class=\"Java\">   private class Itr implements Iterator&lt;E&gt; {\n       int cursor;       // 返回下一个元素的索引\n\n         int lastRet = -1; // 返回最后一个元素的索引，如果空，返回-1\n\n       int expectedModCount = modCount; //用于检测当前集合是否执行了添加删除操作，其中modCount，是当前集合中元素的个数\n\n       public boolean hasNext() {\n           return cursor != size;\n       }\n\n       @SuppressWarnings(&quot;unchecked&quot;)\n       public E next() {\n           checkForComodification(); //检测集合元素是否执行添加删除操作\n           int i = cursor;\n           if (i &gt;= size)\n               throw new NoSuchElementException();\n           Object[] elementData = ArrayList.this.elementData;\n           if (i &gt;= elementData.length)\n               throw new ConcurrentModificationException();\n           cursor = i + 1;\n           return (E) elementData[lastRet = i];\n       }\n\n       public void remove() {\n           if (lastRet &lt; 0)\n               throw new IllegalStateException();\n           checkForComodification();\n\n           try {\n               ArrayList.this.remove(lastRet);\n               cursor = lastRet;\n               lastRet = -1;\n               expectedModCount = modCount;\n           } catch (IndexOutOfBoundsException ex) {\n               throw new ConcurrentModificationException();\n           }\n       }\n\n       @Override\n       @SuppressWarnings(&quot;unchecked&quot;)\n       public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {\n           Objects.requireNonNull(consumer);\n           final int size = ArrayList.this.size;\n           int i = cursor;\n           if (i &gt;= size) {\n               return;\n           }\n           final Object[] elementData = ArrayList.this.elementData;\n           if (i &gt;= elementData.length) {\n               throw new ConcurrentModificationException();\n           }\n           while (i != size &amp;&amp; modCount == expectedModCount) {\n               consumer.accept((E) elementData[i++]);\n           }\n           // update once at end of iteration to reduce heap write traffic\n           cursor = i;\n           lastRet = i - 1;\n           checkForComodification();\n       }\n        //如果发生添加删除操作，则抛出错误。\n       final void checkForComodification() {\n           if (modCount != expectedModCount)\n               throw new ConcurrentModificationException();\n       }\n   }\n</code></pre>\n<p>​ 对于上述的代码不难看懂，有点疑惑的是 int expectedModCount = modCount;这句代码</p>\n<p>​其实这是集合迭代中的一种<strong>快速失败</strong>机制，这种机制提供迭代过程中集合的安全性。阅读源码​ 就可以知道 ArrayList 中存在 modCount 对象，增删操作都会使 modCount++，通过两者的对比​ 迭代器可以快速的知道迭代过程中是否存在 list.add()类似的操作，存在的话快速失败!</p>\n<h2 id=\"Fail-Fast-快速失败-机制\"><a href=\"#Fail-Fast-快速失败-机制\" class=\"headerlink\" title=\"Fail-Fast(快速失败)机制\"></a>Fail-Fast(快速失败)机制</h2><p>仔细观察上述的各个方法，我们在源码中就会发现一个特别的属性 modCount，API 解释如下：</p>\n<p>​ The number of times this list has been structurally modified. Structural modifications are those​ that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress​ may yield incorrect results.</p>\n<p>记录修改此列表的次数：包括改变列表的结构，改变列表的大小，打乱列表的顺序等使正在进行 迭代产生 错误的结果。</p>\n<p>Tips:仅仅设置元素的值并不是结构的修改</p>\n<p>我们知道的是 ArrayList 是线程不安全的，如果在使用迭代器的过程中有其他的线程修改了 List 就会抛出 ConcurrentModificationException 这就是 Fail-Fast 机制。那么快速失败究竟是个什么意思呢？在 ArrayList 类创建迭代器之后，除非通过迭代器自身 remove 或 add 对列表结构进行修改，否则在其他线程中以任何形式对列表进行修改，迭代器马上会抛出异常，快速失败。</p>\n<h3 id=\"迭代器的好处\"><a href=\"#迭代器的好处\" class=\"headerlink\" title=\"迭代器的好处\"></a>迭代器的好处</h3><h2 id=\"迭代器的好处-1\"><a href=\"#迭代器的好处-1\" class=\"headerlink\" title=\"迭代器的好处\"></a>迭代器的好处</h2><p>​ 通过上述我们明白了迭代是到底是个什么，迭代器的使用也十分的简单。现在简要的总结下使用迭代器的好处吧。</p>\n<p>​ <strong>1、迭代器可以提供统一的迭代方式。</strong></p>\n<p><strong>​ 2、 迭代器也可以在对客户端透明的情况下，提供各种不同的迭代方式。</strong></p>\n<p>​ <strong>3、迭代器提供一种快速失败机制，防止多线程下迭代的不安全操作。</strong></p>\n<p>​ 不过对于第三点尚需注意的是：就像上述事例代码一样，我们不能保证迭代过程中出现<strong>快速失败</strong>的都是因为同步造成的，因此为了保证迭代操作的正确性而去依赖此类异常是错误的！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Iterator-和-Iterable-区别\"><a href=\"#Iterator-和-Iterable-区别\" class=\"headerlink\" title=\"Iterator 和 Iterable 区别\"></a>Iterator 和 Iterable 区别</h1><h3 id=\"Iterator（迭代器）\"><a href=\"#Iterator（迭代器）\" class=\"headerlink\" title=\"Iterator（迭代器）\"></a>Iterator（迭代器）</h3><p>作为一种设计模式，迭代器可以用于遍历一个对象，而开发人员不用去了解这个对象的底层结构。</p>\n<p>这里就不仔细说迭代器这种设计模式，因为我们主要的目的是探索 java 中 Iterator 和 Iterable 之间的区别</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>首先来说一下他们各自是怎么使用，不会用谈什么都是瞎搞。</p>\n<h4 id=\"Iterator-用法\"><a href=\"#Iterator-用法\" class=\"headerlink\" title=\"Iterator 用法\"></a>Iterator 用法</h4><p>首先来说一下 Iterator 这个接口，他定义了迭代器基本的功能。</p>\n<h4 id=\"源码如下\"><a href=\"#源码如下\" class=\"headerlink\" title=\"源码如下\"></a>源码如下</h4><pre><code>package java.util;\n\npublic interface Iterator&lt;E&gt; {\n    boolean hasNext();   //返回是否有下一个元素\n    E next();            //返回下一个元素\n    void remove();         //移除当前元素\n}\n\n\n</code></pre><h4 id=\"如何使用这个接口\"><a href=\"#如何使用这个接口\" class=\"headerlink\" title=\"如何使用这个接口\"></a>如何使用这个接口</h4><pre><code>public class main {\n\n    public static void main(String[] args) {\n        MyIterator mi = new MyIterator();\n        while (mi.hasNext()){\n            System.out.printf(&quot;%s\\t&quot;,mi.next());\n        }\n    }\n}\n\nclass MyIterator implements Iterator&lt;String&gt;{\n    private String[] words = (&quot;And that is how &quot;\n            + &quot;we know the Earth to be banana-shaped.&quot;).split(&quot; &quot;);\n    private int count = 0;\n    public MyIterator() {\n    }\n\n    @Override\n    public boolean hasNext() {\n        return count &lt; words.length;\n    }\n\n    @Override\n    public String next() {\n        return words[count++];\n    }\n}\n</code></pre><p>代码很简单，所以就不过多的解释了，但是有一点需要注意的是，下面这样使用上面定义的 MyIterator 类是错误的，你可以试一下。</p>\n<pre><code>for (String s:new MyIterator){\n            System.out.printf(&quot;%s\\t&quot;,s);\n }\n</code></pre><h3 id=\"Iterable-用法\"><a href=\"#Iterable-用法\" class=\"headerlink\" title=\"Iterable 用法\"></a>Iterable 用法</h3><h4 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h4><pre><code>package java.lang;\n\nimport java.util.Iterator;\n\npublic interface Iterable&lt;T&gt; {\n\n    Iterator&lt;T&gt; iterator();\n}\n</code></pre><h4 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h4><pre><code>public class main {\n\n    public static void main(String[] args) {\n\n      MyIterable myIterable= new MyIterable();\n        Iterator&lt;String&gt; mIterator = myIterable.iterator();\n        for (String s:myIterable){\n            System.out.printf(&quot;%s\\t&quot;,s);\n        }\n    }\n}\n\nclass MyIterable implements Iterable&lt;String&gt;{\n    private String[] words = (&quot;And that is how &quot;\n            + &quot;we know the Earth to be banana-shaped.&quot;).split(&quot; &quot;);\n\n    @Override\n    public Iterator&lt;String&gt; iterator() {\n        return new Iterator&lt;String&gt;() {\n            private int i = 0;\n            @Override\n            public boolean hasNext() {\n                return i &lt; words.length;\n            }\n\n            @Override\n            public String next() {\n                return words[i++];\n            }\n        };\n    }\n}\n</code></pre><p>与上面 Iterator 不同的是，这个类还可以下面这样使用</p>\n<pre><code>        MyIterable mi = new MyIterable().iterator();\n        while (mi.hasNext()){\n            System.out.printf(&quot;%s\\t&quot;,mi.next());\n        } \n</code></pre><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p>基本用法已经说完，相信你也能看出其中的一些区别</p>\n<ol>\n<li>Iterator 是迭代器类(这个类是指定义了迭代器基本需要的方法)，而 Iterable 是接口。 这个从他们的包名就可以看出来。</li>\n</ol>\n<pre><code class=\"Java\">java.lang.Iterable\njava.util.Iterator\n</code></pre>\n<ol>\n<li><p>Iterator 不嫩用于 foreach 循环语句，Iterable 可以</p>\n</li>\n<li><p>为什么一定要实现 Iterable 接口，为什么不直接实现 Iterator 接口呢？</p>\n<p>看一下 JDK 中的集合类，比如 List 一族或者 Set 一族，都是实现了 Iterable 接口，但并不直接实现 Iterator 接口。</p>\n<p>这并不是没有道理的。</p>\n<p>​ 因为 Iterator 接口的核心方法 next()或者 hasNext() 是依赖于迭代器的当前迭代位置的。</p>\n<p>如果 Collection 直接实现 Iterator 接口，势必导致集合对象中包含当前迭代位置的数据(指针)。</p>\n<p>​ 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么 next()方法的结果会变成不可预知。 除非再为 Iterator 接口添加一个 reset()方法，用来重置当前迭代位置。 但即时这样，Collection 也只能同时存在一个当前迭代位置。</p>\n<p>而 Iterable 则不然，每次调用都会返回一个从头开始计数的迭代器。</p>\n<p>多个迭代器是互不干扰的</p>\n</li>\n</ol>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p>你在看 ArrayList 源码的时候，你会发现这样一段代码</p>\n<pre><code class=\"Java\">   private class Itr implements Iterator&lt;E&gt; {\n       int cursor;       // 返回下一个元素的索引\n\n         int lastRet = -1; // 返回最后一个元素的索引，如果空，返回-1\n\n       int expectedModCount = modCount; //用于检测当前集合是否执行了添加删除操作，其中modCount，是当前集合中元素的个数\n\n       public boolean hasNext() {\n           return cursor != size;\n       }\n\n       @SuppressWarnings(&quot;unchecked&quot;)\n       public E next() {\n           checkForComodification(); //检测集合元素是否执行添加删除操作\n           int i = cursor;\n           if (i &gt;= size)\n               throw new NoSuchElementException();\n           Object[] elementData = ArrayList.this.elementData;\n           if (i &gt;= elementData.length)\n               throw new ConcurrentModificationException();\n           cursor = i + 1;\n           return (E) elementData[lastRet = i];\n       }\n\n       public void remove() {\n           if (lastRet &lt; 0)\n               throw new IllegalStateException();\n           checkForComodification();\n\n           try {\n               ArrayList.this.remove(lastRet);\n               cursor = lastRet;\n               lastRet = -1;\n               expectedModCount = modCount;\n           } catch (IndexOutOfBoundsException ex) {\n               throw new ConcurrentModificationException();\n           }\n       }\n\n       @Override\n       @SuppressWarnings(&quot;unchecked&quot;)\n       public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {\n           Objects.requireNonNull(consumer);\n           final int size = ArrayList.this.size;\n           int i = cursor;\n           if (i &gt;= size) {\n               return;\n           }\n           final Object[] elementData = ArrayList.this.elementData;\n           if (i &gt;= elementData.length) {\n               throw new ConcurrentModificationException();\n           }\n           while (i != size &amp;&amp; modCount == expectedModCount) {\n               consumer.accept((E) elementData[i++]);\n           }\n           // update once at end of iteration to reduce heap write traffic\n           cursor = i;\n           lastRet = i - 1;\n           checkForComodification();\n       }\n        //如果发生添加删除操作，则抛出错误。\n       final void checkForComodification() {\n           if (modCount != expectedModCount)\n               throw new ConcurrentModificationException();\n       }\n   }\n</code></pre>\n<p>​ 对于上述的代码不难看懂，有点疑惑的是 int expectedModCount = modCount;这句代码</p>\n<p>​其实这是集合迭代中的一种<strong>快速失败</strong>机制，这种机制提供迭代过程中集合的安全性。阅读源码​ 就可以知道 ArrayList 中存在 modCount 对象，增删操作都会使 modCount++，通过两者的对比​ 迭代器可以快速的知道迭代过程中是否存在 list.add()类似的操作，存在的话快速失败!</p>\n<h2 id=\"Fail-Fast-快速失败-机制\"><a href=\"#Fail-Fast-快速失败-机制\" class=\"headerlink\" title=\"Fail-Fast(快速失败)机制\"></a>Fail-Fast(快速失败)机制</h2><p>仔细观察上述的各个方法，我们在源码中就会发现一个特别的属性 modCount，API 解释如下：</p>\n<p>​ The number of times this list has been structurally modified. Structural modifications are those​ that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress​ may yield incorrect results.</p>\n<p>记录修改此列表的次数：包括改变列表的结构，改变列表的大小，打乱列表的顺序等使正在进行 迭代产生 错误的结果。</p>\n<p>Tips:仅仅设置元素的值并不是结构的修改</p>\n<p>我们知道的是 ArrayList 是线程不安全的，如果在使用迭代器的过程中有其他的线程修改了 List 就会抛出 ConcurrentModificationException 这就是 Fail-Fast 机制。那么快速失败究竟是个什么意思呢？在 ArrayList 类创建迭代器之后，除非通过迭代器自身 remove 或 add 对列表结构进行修改，否则在其他线程中以任何形式对列表进行修改，迭代器马上会抛出异常，快速失败。</p>\n<h3 id=\"迭代器的好处\"><a href=\"#迭代器的好处\" class=\"headerlink\" title=\"迭代器的好处\"></a>迭代器的好处</h3><h2 id=\"迭代器的好处-1\"><a href=\"#迭代器的好处-1\" class=\"headerlink\" title=\"迭代器的好处\"></a>迭代器的好处</h2><p>​ 通过上述我们明白了迭代是到底是个什么，迭代器的使用也十分的简单。现在简要的总结下使用迭代器的好处吧。</p>\n<p>​ <strong>1、迭代器可以提供统一的迭代方式。</strong></p>\n<p><strong>​ 2、 迭代器也可以在对客户端透明的情况下，提供各种不同的迭代方式。</strong></p>\n<p>​ <strong>3、迭代器提供一种快速失败机制，防止多线程下迭代的不安全操作。</strong></p>\n<p>​ 不过对于第三点尚需注意的是：就像上述事例代码一样，我们不能保证迭代过程中出现<strong>快速失败</strong>的都是因为同步造成的，因此为了保证迭代操作的正确性而去依赖此类异常是错误的！</p>\n"},{"abbrlink":11,"author":"zhangke","title":"java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析","date":"2018-07-23T06:35:00.000Z","_content":"# java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析\n\n### 概要\n\n>1. 线程池使用例子\n>2. 线程池状态\n>3. 任务执行流程分析\n\n### 1. 线程池使用例子\n\n>简单例子\n>\n>```\n>import java.util.concurrent.Executors;\n>import java.util.concurrent.ExecutorService;\n>\n>public class ThreadPoolDemo1 {\n>\n>    public static void main(String[] args) {\n>        // 创建一个可重用固定线程数的线程池\n>        ExecutorService pool = Executors.newFixedThreadPool(2);\n>        // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n>        Thread ta = new MyThread();\n>        Thread tb = new MyThread();\n>        Thread tc = new MyThread();\n>        Thread td = new MyThread();\n>        Thread te = new MyThread();\n>        // 将线程放入池中进行执行\n>        pool.execute(ta);\n>        pool.execute(tb);\n>        pool.execute(tc);\n>        pool.execute(td);\n>        pool.execute(te);\n>        // 关闭线程池\n>        pool.shutdown();\n>    }\n>}\n>\n>class MyThread extends Thread {\n>\n>    @Override\n>    public void run() {\n>        System.out.println(Thread.currentThread().getName()+ \" is running.\");\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>```\n>\n>示例中，使用了Excutors工具类来创建线程池，并提交任务到线程池上运行，然后关闭线程池，这是一个简单的实例。接下来我们将进行ThreadPoolExecutor深入分析。\n>\n>\n\n### 2. 线程池状态\n\n>在线程池中使用了一个AtomicInteger对象来表示线程的状态和任务的数量。其中Integer是32位，用高三位来表示线程池的状态，至于怎么计算不是这里的重点，这里我们先讲解任务的状态。\n>\n>线程池中任务的状态有以下5种：\n>\n>```\n>RUNNING   :接收新的任务和处理队列中的任务\n>SHUTDOWN  :不在接收新的任务和但是处理队列中的任务。\n>STOP  \t  :不在接收新的任务，同时不在处理队列中的任务，线程上正在运行的任务也会被打断。\n>TIDYING   :所有的任务已经结束，并且线程的数量为0，线程的状态转换成清理的状态，接下来将会运行\n>\t\t\tterminated()方法。\n>TERMINATED:terminated()执行完成\n>```\n>\n>状态的转换:\n>\n>```\n>* RUNNING -> SHUTDOWN\n>*    On invocation of shutdown(), perhaps implicitly in finalize()\n>* (RUNNING or SHUTDOWN) -> STOP\n>*    On invocation of shutdownNow()\n>* SHUTDOWN -> TIDYING\n>*    When both queue and pool are empty\n>* STOP -> TIDYING\n>*    When pool is empty\n>* TIDYING -> TERMINATED\n>*    When the terminated() hook method has completed\n>```\n>\n>\n>\n>\n\n### 3. 线程池执行任务分析\n\n>在讲解运行过程前，我们先看下`ThreadPoolExecutor`中的几个比较重要的成员变量：\n>\n>```java\n>//线程池状态，和队列中任务数量的表示，高三位表示状态，剩下的表示线程的状态\n>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); \n>//任务缓存队列，用来保存等待中的任务，等待worker线程空闲时执行任务\n>private final BlockingQueue<Runnable> workQueue;\n>//更新 poolSize, corePoolSize,maximumPoolSize, runState, and workers set 时需要持有这个锁\n>private final ReentrantLock mainLock = new ReentrantLock(); \n>//用来保存工作中的执行线程\n>\n>private final HashSet<Worker> workers = new HashSet<Worker>(); \n>private volatile long  keepAliveTime; //超过corePoolSize外的线程空闲存活之间\n>//是否对corePoolSize内的线程设置空闲存活时间\n>private volatile boolean allowCoreThreadTimeOut; \n>private volatile int   corePoolSize; //核心线程数\n>\n>//最大线程数（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）\n>private volatile int   maximumPoolSize; \n>private volatile int   poolSize; //线程池中的当前线程数\n>private volatile RejectedExecutionHandler handler; //任务拒绝策略\n>private volatile ThreadFactory threadFactory; //线程工厂，用来新建线程\n>private int largestPoolSize; //记录线程池中出现过的最大线程数大小\n>private long completedTaskCount; //已经执行完的线程数\n>```\n>\n>这边重点解释下 `corePoolSize`、`maximumPoolSize`、`workQueue`两个变量，这两个变量涉及到线程池中创建线程个数的一个策略。\n>`corePoolSize`： 这个变量我们可以理解为线程池的核心大小，举个例子来说明（corePoolSize假设等于10，maximumPoolSize等于20）：\n>\n>1. 有一个部门，其中有10（corePoolSize）名工人，当有新任务来了后，领导就分配任务给工人去做，每个工人只能做一个任务。\n>2. 当10个工人都在忙时，新来的任务就要放到队列（workQueue）中等待。\n>3. 当任务越积累越多，远远超过工人做任务的速度时，领导就想了一个办法：从其他部门借10个工人来，借的数量有一个公式（maximumPoolSize - corePoolSize）来计算。然后把新来的任务分配给借来的工人来做。\n>4. 但是如果速度还是还不急的话，可能就要采取措施来放弃一些任务了（RejectedExecutionHandler）。\n>   等到一定时间后，任务都完成了，工人比较闲的情况下，就考虑把借来的10个工人还回去（根据keepAliveTime判断）\n>5. 也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。\n>\n>### 任务执行：execute\n>\n>这个方法在ThreadPoolExecutor中的源码如下\n>\n>```java\n> public void execute(Runnable command) {\n>     \t//如果任务是空，则抛出空指针异常\n>        if (command == null)\n>            throw new NullPointerException();\n>     \t//得到当前ctl的值，方便下面计算\t\n>        int c = ctl.get();\n>     \t//计算当前线程池中线程的数量，如果小于核心线程数，则添加线程\n>        if (workerCountOf(c) < corePoolSize) {\n>            // 则通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程\n>            //中；然后，启动该线程从而执行任务。\n>            if (addWorker(command, true))\n>                return;\n>            c = ctl.get();\n>        }\n>         // 当线程池中的任务数量 >= \"核心池大小\"时，\n>    \t // 而且，\"线程池处于运行状态\"时，则尝试将任务添加到阻塞队列中。\n>        if (isRunning(c) && workQueue.offer(command)) {\n>             // 再次确认“线程池状态”，若线程池异常终止了，则删除任务；\n>            //然后通过reject()执行相应的拒绝策略的内容。\n>            int recheck = ctl.get();\n>            if (! isRunning(recheck) && remove(command))\n>                reject(command);\n>            // 否则，如果\"线程池中任务数量\"为0，则通过addWorker(null, false)尝试新建一个线\n>            // 程，新建线程对应的任务为null。防止线程池被关闭\n>            else if (workerCountOf(recheck) == 0)\n>                addWorker(null, false);\n>        }\n>       //这里是启动小于maxpoolSize的线程\n>       //如果添加任务到队列中不成功，则试图通过addWorker(command, false)新建一个线程，\n>       //并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。\n>       // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。\n>        else if (!addWorker(command, false))\n>            reject(command);\n>    }\n>}\n>```\n>\n>**说明**：execute()的作用是将任务添加到线程池中执行。它会分为3种情况进行处理：        \n>\n> **情况1** -- 如果\"线程池中任务数量\" < \"核心池大小\"时，即线程池中少于corePoolSize个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。         \n>\n>**情况2** -- 如果\"线程池中任务数量\" >= \"核心池大小\"，并且\"线程池是允许状态\"；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认\"线程池的状态\"，如果\"第2次读到的线程池状态\"和\"第1次读到的线程池状态\"不同，则从阻塞队列中删除该任务。         \n>\n>**情况3** -- 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过reject()拒绝该任务。\n>\n>到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：\n>\n>1. 首先，要清楚corePoolSize和maximumPoolSize的含义；\n>2. 其次，要知道Worker是用来起到什么作用的；\n>3. 要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：\n>\n>- 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；\n>- 如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；\n>- 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；\n>- 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于 corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。\n>\n>###  **addWorker**\n>\n>源码如下\n>\n>```java\n> private boolean addWorker(Runnable firstTask, boolean core) {\n>        retry:\n>        // 更新\"线程池状态和计数\"标记，即更新ctl。\n>        for (;;) {\n>           // 更新\"线程池状态和计数\"标记，即更新ctl。\n>            int c = ctl.get();\n>             // 获取线程池状态。\n>            int rs = runStateOf(c);\n>\n>            // Check if queue empty only if necessary.\n>            // 有效性检查\n>            if (rs >= SHUTDOWN &&\n>                ! (rs == SHUTDOWN &&\n>                   firstTask == null &&\n>                   ! workQueue.isEmpty()))\n>                return false;\n>\n>            for (;;) {\n>               // 获取线程池中任务的数量。\n>                int wc = workerCountOf(c);\n>                // 如果\"线程池中任务的数量\"超过限制，则返回false。\n>                if (wc >= CAPACITY ||\n>                    wc >= (core ? corePoolSize : maximumPoolSize))\n>                    return false;\n>                // 通过CAS函数将c的值+1。操作失败的话，则退出循环。\n>                if (compareAndIncrementWorkerCount(c))\n>                    break retry;\n>                c = ctl.get();  // Re-read ctl\n>                // 检查\"线程池状态\"，如果与之前的状态不同，则从retry重新开始。\n>                if (runStateOf(c) != rs)\n>                    continue retry;\n>                // else CAS failed due to workerCount change; retry inner loop\n>            }\n>        }\n>\n>    boolean workerStarted = false;\n>    boolean workerAdded = false;\n>    Worker w = null;\n>    // 添加任务到线程池，并启动任务所在的线程。\n>    try {\n>        final ReentrantLock mainLock = this.mainLock;\n>        // 新建Worker，并且指定firstTask为Worker的第一个任务。\n>        w = new Worker(firstTask);\n>        // 获取Worker对应的线程。\n>        final Thread t = w.thread;\n>        if (t != null) {\n>            // 获取锁\n>            mainLock.lock();\n>            try {\n>                int c = ctl.get();\n>                int rs = runStateOf(c);\n>\n>                // 再次确认\"线程池状态\"\n>                if (rs < SHUTDOWN ||\n>                    (rs == SHUTDOWN && firstTask == null)) {\n>                    if (t.isAlive()) // precheck that t is startable\n>                        throw new IllegalThreadStateException();\n>                    // 将Worker对象(w)添加到\"线程池的Worker集合(workers)\"中\n>                    workers.add(w);\n>                    // 更新largestPoolSize\n>                    int s = workers.size();\n>                    if (s > largestPoolSize)\n>                        largestPoolSize = s;\n>                    workerAdded = true;\n>                }\n>            } finally {\n>                // 释放锁\n>                mainLock.unlock();\n>            }\n>            // 如果\"成功将任务添加到线程池\"中，则启动任务所在的线程。 \n>            if (workerAdded) {\n>                t.start();\n>                workerStarted = true;\n>            }\n>        }\n>    } finally {\n>        if (! workerStarted)\n>            addWorkerFailed(w);\n>    }\n>    // 返回任务是否启动。\n>    return workerStarted;\n>}\n>\n>```\n>\n>**说明**：\n>\n>1.  addWorker(Runnable firstTask, boolean core) 的作用是将任务(firstTask)添加到线程池中，并启动该任务。core为true的话，则以corePoolSize为界限，若\"线程池中已有任务数量>=corePoolSize\"，则返回false；core为false的话，则以maximumPoolSize为界限，若\"线程池中已有任务数量>=maximumPoolSize\"，则返回false。\n>\n>2. addWorker()会先通过for循环不断尝试更新ctl状态，ctl记录了\"线程池中任务数量和线程池状态\"。更新成功之后，再通过try模块来将任务添加到线程池中，并启动任务所在的线程。\n>\n>3.  从addWorker()中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的Worker对象；而一个Workder对象包含一个Thread对象。\n>\n>   (01) 通过将Worker对象添加到\"线程的workers集合\"中，从而实现将任务添加到线程池中。\n>\n>   (02) 通过启动Worker对应的Thread线程，则执行该任务。\n>\n>### addWorkerFailed:\n>\n>如果Worker创建成功，但是没有启动，这时我们需要将从线程对象从works上移除，否则会影响线程池的性能，源码如下\n>\n>```java\n>    /**\n>     * Rolls back the worker thread creation.\n>     * - removes worker from workers, if present\n>     * - decrements worker count\n>     * - rechecks for termination, in case the existence of this\n>     *   worker was holding up termination\n>     */\n>    private void addWorkerFailed(Worker w) {\n>        \n>        final ReentrantLock mainLock = this.mainLock;\n>        //获取锁\n>        mainLock.lock();\n>        try {\n>            //从workers上移除线程\n>            if (w != null)\n>                workers.remove(w);\n>            //减少线程的数量\n>            decrementWorkerCount();\n>            //由于线程数量的减少，可能会使得当前线程池上线程的数量变成0，这时有可能进入\n>            //TIDYING状态，所以尝试结束线程池\n>            tryTerminate();\n>        } finally {\n>            mainLock.unlock();\n>        }\n>    }\n>```\n>\n>这时你们会不会有个疑问，一般我们写程序时，如果想让线程一直运行，则会向下面这样写:\n>\n>```\n>public void run(){\n>    while(true){\n>        //doSomething\n>    }\n>}\n>```\n>\n>但是上面执行流程分析完了，但是没看到ThreadPoolExecutor怎么定义线程一直运行，这时我们就要去分析Worker这个内部类的源码，这里面有我们想要的结果：\n>\n>源码如下：\n>\n>```java\n>  private final class Worker\n>        extends AbstractQueuedSynchronizer\n>        implements Runnable {      \n>        private static final long serialVersionUID = 6138294804551838833L;\n>   \t\t//当前woker正在运行的线程\n>        final Thread thread;\n>        //初始化这个工作线程时的第一个任务，可能为null\n>        Runnable firstTask;\n>       \t//每个线程完成任务的数量\n>        volatile long completedTasks;\n>        \n>        Worker(Runnable firstTask) {\n>            setState(-1); // inhibit interrupts until runWorker\n>            this.firstTask = firstTask;       \n>            //使用线程池提供的线程创建工厂来创建线程\n>            this.thread = getThreadFactory().newThread(this);\n>        }\n>        //委派当前线程的run方法到外部类的runWorker上，\n>        public void run() {\n>            runWorker(this);\n>        }\n>        // Lock methods\n>        //\n>        // The value 0 represents the unlocked state.\n>        // The value 1 represents the locked state.\n>        protected boolean isHeldExclusively() {\n>            return getState() != 0;\n>        }\n>\n>        protected boolean tryAcquire(int unused) {\n>            if (compareAndSetState(0, 1)) {\n>                setExclusiveOwnerThread(Thread.currentThread());\n>                return true;\n>            }\n>            return false;\n>        }\n>\n>        protected boolean tryRelease(int unused) {\n>            setExclusiveOwnerThread(null);\n>            setState(0);\n>            return true;\n>        }\n>\n>        public void lock()        { acquire(1); }\n>        public boolean tryLock()  { return tryAcquire(1); }\n>        public void unlock()      { release(1); }\n>        public boolean isLocked() { return isHeldExclusively(); }\n>\n>        void interruptIfStarted() {\n>            Thread t;\n>            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n>                try {\n>                    t.interrupt();\n>                } catch (SecurityException ignore) {\n>                }\n>            }\n>        }\n>    }\n>```\n>\n>分析：\n>\n>1. 从上面我们可以看出，Worker继承AQS，实现Runnable接口，继承AQS实现了一个简单的互斥锁，是不想在Worker运行的时候使用外部类的互斥锁，这样可以减少线程的等待。\n>2. 线程创建时通过外部类的threadFactory来创建的，后面我会讲解这个类，其实很简单\n>\n>从上面可以看出Worker类的run方法实现实际上是外部类的runWorker方法实现的，源码如下：\n>\n>```java\n>final void runWorker(Worker w) {\n>\t\t//获取当前cpu上运行的线程，其实也就是worker中的thread\n>        Thread wt = Thread.currentThread();\n>    \t//获取第一个运行任务，可以为null\n>        Runnable task = w.firstTask;\n>        w.firstTask = null;\n>    \t//释放锁\n>        w.unlock(); // allow interrupts\n>    \t//判断当前线程是否是中断结束 true 不是\n>        boolean completedAbruptly = true;\n>        try {\n>            //当任务不为空，一直运行\n>            while (task != null || (task = getTask()) != null) {\n>                w.lock();\n>                // If pool is stopping, ensure thread is interrupted;\n>                // if not, ensure thread is not interrupted.  This\n>                // requires a recheck in second case to deal with\n>                // shutdownNow race while clearing interrupt\n>                if ((runStateAtLeast(ctl.get(), STOP) ||\n>                     (Thread.interrupted() &&\n>                      runStateAtLeast(ctl.get(), STOP))) &&\n>                    !wt.isInterrupted())\n>                    wt.interrupt();\n>                try {\n>                    //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n>                    //默认什么也不做\n>                    beforeExecute(wt, task);\n>                    Throwable thrown = null;\n>                    try {\n>                        //执行任务\n>                        task.run();\n>                    } catch (RuntimeException x) {\n>                        thrown = x; throw x;\n>                    } catch (Error x) {\n>                        thrown = x; throw x;\n>                    } catch (Throwable x) {\n>                        thrown = x; throw new Error(x);\n>                    } finally {\n>                         //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n>                         //默认什么也不做\n>                        afterExecute(task, thrown);\n>                    }\n>                } finally {\n>                    task = null;\n>                    w.completedTasks++;\n>                    w.unlock();\n>                }\n>            }\n>            completedAbruptly = false;\n>        } finally {\n>            //线程死亡，使用此方法执行后续清理工作，\n>            processWorkerExit(w, completedAbruptly);\n>        }\n>    }\n>```\n>\n>从上面代码可以看到这边在循环获取任务，并执行，直到任务全部执行完毕。除了第一个任务，其他任务都是通过`getTask()`方法去取，这个方法是ThreadPoolExecutor中的一个方法。我们猜一下，整个类中只有任务缓存队列中保存了任务，应该就是去缓存队列中取了。\n>\n>```\n>Runnable getTask() {\n>    for (;;) {\n>        try {\n>            int state = runState;\n>            if (state > SHUTDOWN)\n>                return null;\n>            Runnable r;\n>            if (state == SHUTDOWN)  // Help drain queue\n>                r = workQueue.poll(); //取任务\n>            else if (poolSize > corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，\n>                //则通过poll取任务，若等待一定的时间取不到任务，则返回null\n>                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);\n>            else\n>                r = workQueue.take();\n>            if (r != null)\n>                return r;\n>            if (workerCanExit()) {    //如果没取到任务，即r为null，则判断当前的worker是否可以退出\n>                if (runState >= SHUTDOWN) // Wake up others\n>                    interruptIdleWorkers();   //中断处于空闲状态的worker\n>                return null;\n>            }\n>            // Else retry\n>        } catch (InterruptedException ie) {\n>            // On interruption, re-check runState\n>        }\n>    }\n>}\n>```\n>\n>这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给 空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程Worker去任务缓存队列里面取任务来执行，因为每一个Worker里面都包含了一个线程thread。\n>\n>还需要注意的是，当线程死亡如何处理：\n>\n>源码如下：\n>\n>```\n>\t//处理线程结束时的清理工作\n>    private void processWorkerExit(Worker w, boolean completedAbruptly) {\n>        //如果是中断结束，则线程数量不做调整\n>        if (completedAbruptly) \n>            decrementWorkerCount();\n>\n>        final ReentrantLock mainLock = this.mainLock;\n>        //获取锁\n>        mainLock.lock();\n>        try {\n>            //将当前worker线程上的完成任务数量记录下来\n>            completedTaskCount += w.completedTasks;\n>            //移除当前此worker\n>            workers.remove(w);\n>        } finally {\n>            mainLock.unlock();\n>        }\n>        //尝试关闭线程池\n>        tryTerminate();\n>        int c = ctl.get();\n>        //如果当前线程池状态不是stop，则添加woker线程\n>        if (runStateLessThan(c, STOP)) {\n>            //如果是异常导致线程的中断，则判断当前线程池中线程的\n>            //数量是否大于min，min表示当前线程池最少应该有多少线程\n>            //如果少于，则创建一个新的worker线程\n>            if (!completedAbruptly) {\n>                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n>                if (min == 0 && ! workQueue.isEmpty())\n>                    min = 1;\n>                if (workerCountOf(c) >= min)\n>                    return; // replacement not needed\n>            }\n>            addWorker(null, false);\n>        }\n>    }\n>```\n>\n>\n>\n>### 关闭“线程池”\n>\n>shutdown()的源码如下：\n>\n>```java\n>public void shutdown() {\n>    final ReentrantLock mainLock = this.mainLock;\n>    // 获取锁\n>    mainLock.lock();\n>    try {\n>        // 检查终止线程池的“线程”是否有权限。\n>        checkShutdownAccess();\n>        // 设置线程池的状态为关闭状态。\n>        advanceRunState(SHUTDOWN);\n>        // 中断线程池中空闲的线程。\n>        interruptIdleWorkers();\n>        // 钩子函数，在ThreadPoolExecutor中没有任何动作。\n>        onShutdown(); // hook for ScheduledThreadPoolExecutor\n>    } finally {\n>        // 释放锁\n>        mainLock.unlock();\n>    }\n>    // 尝试终止线程池\n>    tryTerminate();\n>}\n>```\n>\n>**说明**：shutdown()的作用是关闭线程池。\n>\n> shutdownNow()源码如下：\n>\n>```java\n>public List<Runnable> shutdownNow() {\n>        List<Runnable> tasks;\n>        final ReentrantLock mainLock = this.mainLock;\n>        //获取所\n>        mainLock.lock();\n>        try {\n>        \t\n>            checkShutdownAccess();\n>            //设置线程池状态为stop状态\n>            advanceRunState(STOP);\n>            //中断所有线程\n>            interruptWorkers();\n>            //取出队列上还未被执行的任务\n>            tasks = drainQueue();\n>        } finally {\n>            mainLock.unlock();\n>        }\n>        tryTerminate();\n>        //返回队列上的任务\n>        return tasks;\n>    }\n>\n>```\n>\n>\n>\n>\n\n","source":"_posts/java多线程系列-JUC线程池之02 ThreadPoolExecutor源码分析.md","raw":"abbrlink: 11\ntags:\n  - JUC\n  - 线程池\ncategories:\n  - java\nauthor: zhangke\ntitle: java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析\ndate: 2018-07-23 14:35:00\n---\n# java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析\n\n### 概要\n\n>1. 线程池使用例子\n>2. 线程池状态\n>3. 任务执行流程分析\n\n### 1. 线程池使用例子\n\n>简单例子\n>\n>```\n>import java.util.concurrent.Executors;\n>import java.util.concurrent.ExecutorService;\n>\n>public class ThreadPoolDemo1 {\n>\n>    public static void main(String[] args) {\n>        // 创建一个可重用固定线程数的线程池\n>        ExecutorService pool = Executors.newFixedThreadPool(2);\n>        // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n>        Thread ta = new MyThread();\n>        Thread tb = new MyThread();\n>        Thread tc = new MyThread();\n>        Thread td = new MyThread();\n>        Thread te = new MyThread();\n>        // 将线程放入池中进行执行\n>        pool.execute(ta);\n>        pool.execute(tb);\n>        pool.execute(tc);\n>        pool.execute(td);\n>        pool.execute(te);\n>        // 关闭线程池\n>        pool.shutdown();\n>    }\n>}\n>\n>class MyThread extends Thread {\n>\n>    @Override\n>    public void run() {\n>        System.out.println(Thread.currentThread().getName()+ \" is running.\");\n>    }\n>}\n>```\n>\n>**运行结果**：\n>\n>```\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>pool-1-thread-2 is running.\n>pool-1-thread-1 is running.\n>```\n>\n>示例中，使用了Excutors工具类来创建线程池，并提交任务到线程池上运行，然后关闭线程池，这是一个简单的实例。接下来我们将进行ThreadPoolExecutor深入分析。\n>\n>\n\n### 2. 线程池状态\n\n>在线程池中使用了一个AtomicInteger对象来表示线程的状态和任务的数量。其中Integer是32位，用高三位来表示线程池的状态，至于怎么计算不是这里的重点，这里我们先讲解任务的状态。\n>\n>线程池中任务的状态有以下5种：\n>\n>```\n>RUNNING   :接收新的任务和处理队列中的任务\n>SHUTDOWN  :不在接收新的任务和但是处理队列中的任务。\n>STOP  \t  :不在接收新的任务，同时不在处理队列中的任务，线程上正在运行的任务也会被打断。\n>TIDYING   :所有的任务已经结束，并且线程的数量为0，线程的状态转换成清理的状态，接下来将会运行\n>\t\t\tterminated()方法。\n>TERMINATED:terminated()执行完成\n>```\n>\n>状态的转换:\n>\n>```\n>* RUNNING -> SHUTDOWN\n>*    On invocation of shutdown(), perhaps implicitly in finalize()\n>* (RUNNING or SHUTDOWN) -> STOP\n>*    On invocation of shutdownNow()\n>* SHUTDOWN -> TIDYING\n>*    When both queue and pool are empty\n>* STOP -> TIDYING\n>*    When pool is empty\n>* TIDYING -> TERMINATED\n>*    When the terminated() hook method has completed\n>```\n>\n>\n>\n>\n\n### 3. 线程池执行任务分析\n\n>在讲解运行过程前，我们先看下`ThreadPoolExecutor`中的几个比较重要的成员变量：\n>\n>```java\n>//线程池状态，和队列中任务数量的表示，高三位表示状态，剩下的表示线程的状态\n>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); \n>//任务缓存队列，用来保存等待中的任务，等待worker线程空闲时执行任务\n>private final BlockingQueue<Runnable> workQueue;\n>//更新 poolSize, corePoolSize,maximumPoolSize, runState, and workers set 时需要持有这个锁\n>private final ReentrantLock mainLock = new ReentrantLock(); \n>//用来保存工作中的执行线程\n>\n>private final HashSet<Worker> workers = new HashSet<Worker>(); \n>private volatile long  keepAliveTime; //超过corePoolSize外的线程空闲存活之间\n>//是否对corePoolSize内的线程设置空闲存活时间\n>private volatile boolean allowCoreThreadTimeOut; \n>private volatile int   corePoolSize; //核心线程数\n>\n>//最大线程数（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）\n>private volatile int   maximumPoolSize; \n>private volatile int   poolSize; //线程池中的当前线程数\n>private volatile RejectedExecutionHandler handler; //任务拒绝策略\n>private volatile ThreadFactory threadFactory; //线程工厂，用来新建线程\n>private int largestPoolSize; //记录线程池中出现过的最大线程数大小\n>private long completedTaskCount; //已经执行完的线程数\n>```\n>\n>这边重点解释下 `corePoolSize`、`maximumPoolSize`、`workQueue`两个变量，这两个变量涉及到线程池中创建线程个数的一个策略。\n>`corePoolSize`： 这个变量我们可以理解为线程池的核心大小，举个例子来说明（corePoolSize假设等于10，maximumPoolSize等于20）：\n>\n>1. 有一个部门，其中有10（corePoolSize）名工人，当有新任务来了后，领导就分配任务给工人去做，每个工人只能做一个任务。\n>2. 当10个工人都在忙时，新来的任务就要放到队列（workQueue）中等待。\n>3. 当任务越积累越多，远远超过工人做任务的速度时，领导就想了一个办法：从其他部门借10个工人来，借的数量有一个公式（maximumPoolSize - corePoolSize）来计算。然后把新来的任务分配给借来的工人来做。\n>4. 但是如果速度还是还不急的话，可能就要采取措施来放弃一些任务了（RejectedExecutionHandler）。\n>   等到一定时间后，任务都完成了，工人比较闲的情况下，就考虑把借来的10个工人还回去（根据keepAliveTime判断）\n>5. 也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。\n>\n>### 任务执行：execute\n>\n>这个方法在ThreadPoolExecutor中的源码如下\n>\n>```java\n> public void execute(Runnable command) {\n>     \t//如果任务是空，则抛出空指针异常\n>        if (command == null)\n>            throw new NullPointerException();\n>     \t//得到当前ctl的值，方便下面计算\t\n>        int c = ctl.get();\n>     \t//计算当前线程池中线程的数量，如果小于核心线程数，则添加线程\n>        if (workerCountOf(c) < corePoolSize) {\n>            // 则通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程\n>            //中；然后，启动该线程从而执行任务。\n>            if (addWorker(command, true))\n>                return;\n>            c = ctl.get();\n>        }\n>         // 当线程池中的任务数量 >= \"核心池大小\"时，\n>    \t // 而且，\"线程池处于运行状态\"时，则尝试将任务添加到阻塞队列中。\n>        if (isRunning(c) && workQueue.offer(command)) {\n>             // 再次确认“线程池状态”，若线程池异常终止了，则删除任务；\n>            //然后通过reject()执行相应的拒绝策略的内容。\n>            int recheck = ctl.get();\n>            if (! isRunning(recheck) && remove(command))\n>                reject(command);\n>            // 否则，如果\"线程池中任务数量\"为0，则通过addWorker(null, false)尝试新建一个线\n>            // 程，新建线程对应的任务为null。防止线程池被关闭\n>            else if (workerCountOf(recheck) == 0)\n>                addWorker(null, false);\n>        }\n>       //这里是启动小于maxpoolSize的线程\n>       //如果添加任务到队列中不成功，则试图通过addWorker(command, false)新建一个线程，\n>       //并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。\n>       // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。\n>        else if (!addWorker(command, false))\n>            reject(command);\n>    }\n>}\n>```\n>\n>**说明**：execute()的作用是将任务添加到线程池中执行。它会分为3种情况进行处理：        \n>\n> **情况1** -- 如果\"线程池中任务数量\" < \"核心池大小\"时，即线程池中少于corePoolSize个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。         \n>\n>**情况2** -- 如果\"线程池中任务数量\" >= \"核心池大小\"，并且\"线程池是允许状态\"；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认\"线程池的状态\"，如果\"第2次读到的线程池状态\"和\"第1次读到的线程池状态\"不同，则从阻塞队列中删除该任务。         \n>\n>**情况3** -- 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过reject()拒绝该任务。\n>\n>到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：\n>\n>1. 首先，要清楚corePoolSize和maximumPoolSize的含义；\n>2. 其次，要知道Worker是用来起到什么作用的；\n>3. 要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：\n>\n>- 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；\n>- 如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；\n>- 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；\n>- 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于 corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。\n>\n>###  **addWorker**\n>\n>源码如下\n>\n>```java\n> private boolean addWorker(Runnable firstTask, boolean core) {\n>        retry:\n>        // 更新\"线程池状态和计数\"标记，即更新ctl。\n>        for (;;) {\n>           // 更新\"线程池状态和计数\"标记，即更新ctl。\n>            int c = ctl.get();\n>             // 获取线程池状态。\n>            int rs = runStateOf(c);\n>\n>            // Check if queue empty only if necessary.\n>            // 有效性检查\n>            if (rs >= SHUTDOWN &&\n>                ! (rs == SHUTDOWN &&\n>                   firstTask == null &&\n>                   ! workQueue.isEmpty()))\n>                return false;\n>\n>            for (;;) {\n>               // 获取线程池中任务的数量。\n>                int wc = workerCountOf(c);\n>                // 如果\"线程池中任务的数量\"超过限制，则返回false。\n>                if (wc >= CAPACITY ||\n>                    wc >= (core ? corePoolSize : maximumPoolSize))\n>                    return false;\n>                // 通过CAS函数将c的值+1。操作失败的话，则退出循环。\n>                if (compareAndIncrementWorkerCount(c))\n>                    break retry;\n>                c = ctl.get();  // Re-read ctl\n>                // 检查\"线程池状态\"，如果与之前的状态不同，则从retry重新开始。\n>                if (runStateOf(c) != rs)\n>                    continue retry;\n>                // else CAS failed due to workerCount change; retry inner loop\n>            }\n>        }\n>\n>    boolean workerStarted = false;\n>    boolean workerAdded = false;\n>    Worker w = null;\n>    // 添加任务到线程池，并启动任务所在的线程。\n>    try {\n>        final ReentrantLock mainLock = this.mainLock;\n>        // 新建Worker，并且指定firstTask为Worker的第一个任务。\n>        w = new Worker(firstTask);\n>        // 获取Worker对应的线程。\n>        final Thread t = w.thread;\n>        if (t != null) {\n>            // 获取锁\n>            mainLock.lock();\n>            try {\n>                int c = ctl.get();\n>                int rs = runStateOf(c);\n>\n>                // 再次确认\"线程池状态\"\n>                if (rs < SHUTDOWN ||\n>                    (rs == SHUTDOWN && firstTask == null)) {\n>                    if (t.isAlive()) // precheck that t is startable\n>                        throw new IllegalThreadStateException();\n>                    // 将Worker对象(w)添加到\"线程池的Worker集合(workers)\"中\n>                    workers.add(w);\n>                    // 更新largestPoolSize\n>                    int s = workers.size();\n>                    if (s > largestPoolSize)\n>                        largestPoolSize = s;\n>                    workerAdded = true;\n>                }\n>            } finally {\n>                // 释放锁\n>                mainLock.unlock();\n>            }\n>            // 如果\"成功将任务添加到线程池\"中，则启动任务所在的线程。 \n>            if (workerAdded) {\n>                t.start();\n>                workerStarted = true;\n>            }\n>        }\n>    } finally {\n>        if (! workerStarted)\n>            addWorkerFailed(w);\n>    }\n>    // 返回任务是否启动。\n>    return workerStarted;\n>}\n>\n>```\n>\n>**说明**：\n>\n>1.  addWorker(Runnable firstTask, boolean core) 的作用是将任务(firstTask)添加到线程池中，并启动该任务。core为true的话，则以corePoolSize为界限，若\"线程池中已有任务数量>=corePoolSize\"，则返回false；core为false的话，则以maximumPoolSize为界限，若\"线程池中已有任务数量>=maximumPoolSize\"，则返回false。\n>\n>2. addWorker()会先通过for循环不断尝试更新ctl状态，ctl记录了\"线程池中任务数量和线程池状态\"。更新成功之后，再通过try模块来将任务添加到线程池中，并启动任务所在的线程。\n>\n>3.  从addWorker()中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的Worker对象；而一个Workder对象包含一个Thread对象。\n>\n>   (01) 通过将Worker对象添加到\"线程的workers集合\"中，从而实现将任务添加到线程池中。\n>\n>   (02) 通过启动Worker对应的Thread线程，则执行该任务。\n>\n>### addWorkerFailed:\n>\n>如果Worker创建成功，但是没有启动，这时我们需要将从线程对象从works上移除，否则会影响线程池的性能，源码如下\n>\n>```java\n>    /**\n>     * Rolls back the worker thread creation.\n>     * - removes worker from workers, if present\n>     * - decrements worker count\n>     * - rechecks for termination, in case the existence of this\n>     *   worker was holding up termination\n>     */\n>    private void addWorkerFailed(Worker w) {\n>        \n>        final ReentrantLock mainLock = this.mainLock;\n>        //获取锁\n>        mainLock.lock();\n>        try {\n>            //从workers上移除线程\n>            if (w != null)\n>                workers.remove(w);\n>            //减少线程的数量\n>            decrementWorkerCount();\n>            //由于线程数量的减少，可能会使得当前线程池上线程的数量变成0，这时有可能进入\n>            //TIDYING状态，所以尝试结束线程池\n>            tryTerminate();\n>        } finally {\n>            mainLock.unlock();\n>        }\n>    }\n>```\n>\n>这时你们会不会有个疑问，一般我们写程序时，如果想让线程一直运行，则会向下面这样写:\n>\n>```\n>public void run(){\n>    while(true){\n>        //doSomething\n>    }\n>}\n>```\n>\n>但是上面执行流程分析完了，但是没看到ThreadPoolExecutor怎么定义线程一直运行，这时我们就要去分析Worker这个内部类的源码，这里面有我们想要的结果：\n>\n>源码如下：\n>\n>```java\n>  private final class Worker\n>        extends AbstractQueuedSynchronizer\n>        implements Runnable {      \n>        private static final long serialVersionUID = 6138294804551838833L;\n>   \t\t//当前woker正在运行的线程\n>        final Thread thread;\n>        //初始化这个工作线程时的第一个任务，可能为null\n>        Runnable firstTask;\n>       \t//每个线程完成任务的数量\n>        volatile long completedTasks;\n>        \n>        Worker(Runnable firstTask) {\n>            setState(-1); // inhibit interrupts until runWorker\n>            this.firstTask = firstTask;       \n>            //使用线程池提供的线程创建工厂来创建线程\n>            this.thread = getThreadFactory().newThread(this);\n>        }\n>        //委派当前线程的run方法到外部类的runWorker上，\n>        public void run() {\n>            runWorker(this);\n>        }\n>        // Lock methods\n>        //\n>        // The value 0 represents the unlocked state.\n>        // The value 1 represents the locked state.\n>        protected boolean isHeldExclusively() {\n>            return getState() != 0;\n>        }\n>\n>        protected boolean tryAcquire(int unused) {\n>            if (compareAndSetState(0, 1)) {\n>                setExclusiveOwnerThread(Thread.currentThread());\n>                return true;\n>            }\n>            return false;\n>        }\n>\n>        protected boolean tryRelease(int unused) {\n>            setExclusiveOwnerThread(null);\n>            setState(0);\n>            return true;\n>        }\n>\n>        public void lock()        { acquire(1); }\n>        public boolean tryLock()  { return tryAcquire(1); }\n>        public void unlock()      { release(1); }\n>        public boolean isLocked() { return isHeldExclusively(); }\n>\n>        void interruptIfStarted() {\n>            Thread t;\n>            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n>                try {\n>                    t.interrupt();\n>                } catch (SecurityException ignore) {\n>                }\n>            }\n>        }\n>    }\n>```\n>\n>分析：\n>\n>1. 从上面我们可以看出，Worker继承AQS，实现Runnable接口，继承AQS实现了一个简单的互斥锁，是不想在Worker运行的时候使用外部类的互斥锁，这样可以减少线程的等待。\n>2. 线程创建时通过外部类的threadFactory来创建的，后面我会讲解这个类，其实很简单\n>\n>从上面可以看出Worker类的run方法实现实际上是外部类的runWorker方法实现的，源码如下：\n>\n>```java\n>final void runWorker(Worker w) {\n>\t\t//获取当前cpu上运行的线程，其实也就是worker中的thread\n>        Thread wt = Thread.currentThread();\n>    \t//获取第一个运行任务，可以为null\n>        Runnable task = w.firstTask;\n>        w.firstTask = null;\n>    \t//释放锁\n>        w.unlock(); // allow interrupts\n>    \t//判断当前线程是否是中断结束 true 不是\n>        boolean completedAbruptly = true;\n>        try {\n>            //当任务不为空，一直运行\n>            while (task != null || (task = getTask()) != null) {\n>                w.lock();\n>                // If pool is stopping, ensure thread is interrupted;\n>                // if not, ensure thread is not interrupted.  This\n>                // requires a recheck in second case to deal with\n>                // shutdownNow race while clearing interrupt\n>                if ((runStateAtLeast(ctl.get(), STOP) ||\n>                     (Thread.interrupted() &&\n>                      runStateAtLeast(ctl.get(), STOP))) &&\n>                    !wt.isInterrupted())\n>                    wt.interrupt();\n>                try {\n>                    //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n>                    //默认什么也不做\n>                    beforeExecute(wt, task);\n>                    Throwable thrown = null;\n>                    try {\n>                        //执行任务\n>                        task.run();\n>                    } catch (RuntimeException x) {\n>                        thrown = x; throw x;\n>                    } catch (Error x) {\n>                        thrown = x; throw x;\n>                    } catch (Throwable x) {\n>                        thrown = x; throw new Error(x);\n>                    } finally {\n>                         //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n>                         //默认什么也不做\n>                        afterExecute(task, thrown);\n>                    }\n>                } finally {\n>                    task = null;\n>                    w.completedTasks++;\n>                    w.unlock();\n>                }\n>            }\n>            completedAbruptly = false;\n>        } finally {\n>            //线程死亡，使用此方法执行后续清理工作，\n>            processWorkerExit(w, completedAbruptly);\n>        }\n>    }\n>```\n>\n>从上面代码可以看到这边在循环获取任务，并执行，直到任务全部执行完毕。除了第一个任务，其他任务都是通过`getTask()`方法去取，这个方法是ThreadPoolExecutor中的一个方法。我们猜一下，整个类中只有任务缓存队列中保存了任务，应该就是去缓存队列中取了。\n>\n>```\n>Runnable getTask() {\n>    for (;;) {\n>        try {\n>            int state = runState;\n>            if (state > SHUTDOWN)\n>                return null;\n>            Runnable r;\n>            if (state == SHUTDOWN)  // Help drain queue\n>                r = workQueue.poll(); //取任务\n>            else if (poolSize > corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，\n>                //则通过poll取任务，若等待一定的时间取不到任务，则返回null\n>                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);\n>            else\n>                r = workQueue.take();\n>            if (r != null)\n>                return r;\n>            if (workerCanExit()) {    //如果没取到任务，即r为null，则判断当前的worker是否可以退出\n>                if (runState >= SHUTDOWN) // Wake up others\n>                    interruptIdleWorkers();   //中断处于空闲状态的worker\n>                return null;\n>            }\n>            // Else retry\n>        } catch (InterruptedException ie) {\n>            // On interruption, re-check runState\n>        }\n>    }\n>}\n>```\n>\n>这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给 空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程Worker去任务缓存队列里面取任务来执行，因为每一个Worker里面都包含了一个线程thread。\n>\n>还需要注意的是，当线程死亡如何处理：\n>\n>源码如下：\n>\n>```\n>\t//处理线程结束时的清理工作\n>    private void processWorkerExit(Worker w, boolean completedAbruptly) {\n>        //如果是中断结束，则线程数量不做调整\n>        if (completedAbruptly) \n>            decrementWorkerCount();\n>\n>        final ReentrantLock mainLock = this.mainLock;\n>        //获取锁\n>        mainLock.lock();\n>        try {\n>            //将当前worker线程上的完成任务数量记录下来\n>            completedTaskCount += w.completedTasks;\n>            //移除当前此worker\n>            workers.remove(w);\n>        } finally {\n>            mainLock.unlock();\n>        }\n>        //尝试关闭线程池\n>        tryTerminate();\n>        int c = ctl.get();\n>        //如果当前线程池状态不是stop，则添加woker线程\n>        if (runStateLessThan(c, STOP)) {\n>            //如果是异常导致线程的中断，则判断当前线程池中线程的\n>            //数量是否大于min，min表示当前线程池最少应该有多少线程\n>            //如果少于，则创建一个新的worker线程\n>            if (!completedAbruptly) {\n>                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n>                if (min == 0 && ! workQueue.isEmpty())\n>                    min = 1;\n>                if (workerCountOf(c) >= min)\n>                    return; // replacement not needed\n>            }\n>            addWorker(null, false);\n>        }\n>    }\n>```\n>\n>\n>\n>### 关闭“线程池”\n>\n>shutdown()的源码如下：\n>\n>```java\n>public void shutdown() {\n>    final ReentrantLock mainLock = this.mainLock;\n>    // 获取锁\n>    mainLock.lock();\n>    try {\n>        // 检查终止线程池的“线程”是否有权限。\n>        checkShutdownAccess();\n>        // 设置线程池的状态为关闭状态。\n>        advanceRunState(SHUTDOWN);\n>        // 中断线程池中空闲的线程。\n>        interruptIdleWorkers();\n>        // 钩子函数，在ThreadPoolExecutor中没有任何动作。\n>        onShutdown(); // hook for ScheduledThreadPoolExecutor\n>    } finally {\n>        // 释放锁\n>        mainLock.unlock();\n>    }\n>    // 尝试终止线程池\n>    tryTerminate();\n>}\n>```\n>\n>**说明**：shutdown()的作用是关闭线程池。\n>\n> shutdownNow()源码如下：\n>\n>```java\n>public List<Runnable> shutdownNow() {\n>        List<Runnable> tasks;\n>        final ReentrantLock mainLock = this.mainLock;\n>        //获取所\n>        mainLock.lock();\n>        try {\n>        \t\n>            checkShutdownAccess();\n>            //设置线程池状态为stop状态\n>            advanceRunState(STOP);\n>            //中断所有线程\n>            interruptWorkers();\n>            //取出队列上还未被执行的任务\n>            tasks = drainQueue();\n>        } finally {\n>            mainLock.unlock();\n>        }\n>        tryTerminate();\n>        //返回队列上的任务\n>        return tasks;\n>    }\n>\n>```\n>\n>\n>\n>\n\n","slug":"java多线程系列-JUC线程池之02 ThreadPoolExecutor源码分析","published":1,"updated":"2019-01-04T01:48:59.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxxae003ceb1u10ndwv76","content":"<h1 id=\"java多线程系列-JUC线程池之02-ThreadPoolExecutor-执行流程分析\"><a href=\"#java多线程系列-JUC线程池之02-ThreadPoolExecutor-执行流程分析\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析\"></a>java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>线程池使用例子</li>\n<li>线程池状态</li>\n<li>任务执行流程分析</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程池使用例子\"><a href=\"#1-线程池使用例子\" class=\"headerlink\" title=\"1. 线程池使用例子\"></a>1. 线程池使用例子</h3><blockquote>\n<p>简单例子</p>\n<pre><code>import java.util.concurrent.Executors;\nimport java.util.concurrent.ExecutorService;\n\npublic class ThreadPoolDemo1 {\n\n   public static void main(String[] args) {\n       // 创建一个可重用固定线程数的线程池\n       ExecutorService pool = Executors.newFixedThreadPool(2);\n       // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n       Thread ta = new MyThread();\n       Thread tb = new MyThread();\n       Thread tc = new MyThread();\n       Thread td = new MyThread();\n       Thread te = new MyThread();\n       // 将线程放入池中进行执行\n       pool.execute(ta);\n       pool.execute(tb);\n       pool.execute(tc);\n       pool.execute(td);\n       pool.execute(te);\n       // 关闭线程池\n       pool.shutdown();\n   }\n}\n\nclass MyThread extends Thread {\n\n   @Override\n   public void run() {\n       System.out.println(Thread.currentThread().getName()+ &quot; is running.&quot;);\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>pool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\n</code></pre><p>示例中，使用了Excutors工具类来创建线程池，并提交任务到线程池上运行，然后关闭线程池，这是一个简单的实例。接下来我们将进行ThreadPoolExecutor深入分析。</p>\n</blockquote>\n<h3 id=\"2-线程池状态\"><a href=\"#2-线程池状态\" class=\"headerlink\" title=\"2. 线程池状态\"></a>2. 线程池状态</h3><blockquote>\n<p>在线程池中使用了一个AtomicInteger对象来表示线程的状态和任务的数量。其中Integer是32位，用高三位来表示线程池的状态，至于怎么计算不是这里的重点，这里我们先讲解任务的状态。</p>\n<p>线程池中任务的状态有以下5种：</p>\n<pre><code>RUNNING   :接收新的任务和处理队列中的任务\nSHUTDOWN  :不在接收新的任务和但是处理队列中的任务。\nSTOP        :不在接收新的任务，同时不在处理队列中的任务，线程上正在运行的任务也会被打断。\nTIDYING   :所有的任务已经结束，并且线程的数量为0，线程的状态转换成清理的状态，接下来将会运行\n           terminated()方法。\nTERMINATED:terminated()执行完成\n</code></pre><p>状态的转换:</p>\n<pre><code>* RUNNING -&gt; SHUTDOWN\n*    On invocation of shutdown(), perhaps implicitly in finalize()\n* (RUNNING or SHUTDOWN) -&gt; STOP\n*    On invocation of shutdownNow()\n* SHUTDOWN -&gt; TIDYING\n*    When both queue and pool are empty\n* STOP -&gt; TIDYING\n*    When pool is empty\n* TIDYING -&gt; TERMINATED\n*    When the terminated() hook method has completed\n</code></pre></blockquote>\n<h3 id=\"3-线程池执行任务分析\"><a href=\"#3-线程池执行任务分析\" class=\"headerlink\" title=\"3. 线程池执行任务分析\"></a>3. 线程池执行任务分析</h3><blockquote>\n<p>在讲解运行过程前，我们先看下<code>ThreadPoolExecutor</code>中的几个比较重要的成员变量：</p>\n<pre><code class=\"java\">//线程池状态，和队列中任务数量的表示，高三位表示状态，剩下的表示线程的状态\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); \n//任务缓存队列，用来保存等待中的任务，等待worker线程空闲时执行任务\nprivate final BlockingQueue&lt;Runnable&gt; workQueue;\n//更新 poolSize, corePoolSize,maximumPoolSize, runState, and workers set 时需要持有这个锁\nprivate final ReentrantLock mainLock = new ReentrantLock(); \n//用来保存工作中的执行线程\n\nprivate final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); \nprivate volatile long  keepAliveTime; //超过corePoolSize外的线程空闲存活之间\n//是否对corePoolSize内的线程设置空闲存活时间\nprivate volatile boolean allowCoreThreadTimeOut; \nprivate volatile int   corePoolSize; //核心线程数\n\n//最大线程数（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）\nprivate volatile int   maximumPoolSize; \nprivate volatile int   poolSize; //线程池中的当前线程数\nprivate volatile RejectedExecutionHandler handler; //任务拒绝策略\nprivate volatile ThreadFactory threadFactory; //线程工厂，用来新建线程\nprivate int largestPoolSize; //记录线程池中出现过的最大线程数大小\nprivate long completedTaskCount; //已经执行完的线程数\n</code></pre>\n<p>这边重点解释下 <code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>两个变量，这两个变量涉及到线程池中创建线程个数的一个策略。<br><code>corePoolSize</code>： 这个变量我们可以理解为线程池的核心大小，举个例子来说明（corePoolSize假设等于10，maximumPoolSize等于20）：</p>\n<ol>\n<li>有一个部门，其中有10（corePoolSize）名工人，当有新任务来了后，领导就分配任务给工人去做，每个工人只能做一个任务。</li>\n<li>当10个工人都在忙时，新来的任务就要放到队列（workQueue）中等待。</li>\n<li>当任务越积累越多，远远超过工人做任务的速度时，领导就想了一个办法：从其他部门借10个工人来，借的数量有一个公式（maximumPoolSize - corePoolSize）来计算。然后把新来的任务分配给借来的工人来做。</li>\n<li>但是如果速度还是还不急的话，可能就要采取措施来放弃一些任务了（RejectedExecutionHandler）。<br>等到一定时间后，任务都完成了，工人比较闲的情况下，就考虑把借来的10个工人还回去（根据keepAliveTime判断）</li>\n<li>也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</li>\n</ol>\n<h3 id=\"任务执行：execute\"><a href=\"#任务执行：execute\" class=\"headerlink\" title=\"任务执行：execute\"></a>任务执行：execute</h3><p>这个方法在ThreadPoolExecutor中的源码如下</p>\n<pre><code class=\"java\">public void execute(Runnable command) {\n        //如果任务是空，则抛出空指针异常\n       if (command == null)\n           throw new NullPointerException();\n        //得到当前ctl的值，方便下面计算    \n       int c = ctl.get();\n        //计算当前线程池中线程的数量，如果小于核心线程数，则添加线程\n       if (workerCountOf(c) &lt; corePoolSize) {\n           // 则通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程\n           //中；然后，启动该线程从而执行任务。\n           if (addWorker(command, true))\n               return;\n           c = ctl.get();\n       }\n        // 当线程池中的任务数量 &gt;= &quot;核心池大小&quot;时，\n        // 而且，&quot;线程池处于运行状态&quot;时，则尝试将任务添加到阻塞队列中。\n       if (isRunning(c) &amp;&amp; workQueue.offer(command)) {\n            // 再次确认“线程池状态”，若线程池异常终止了，则删除任务；\n           //然后通过reject()执行相应的拒绝策略的内容。\n           int recheck = ctl.get();\n           if (! isRunning(recheck) &amp;&amp; remove(command))\n               reject(command);\n           // 否则，如果&quot;线程池中任务数量&quot;为0，则通过addWorker(null, false)尝试新建一个线\n           // 程，新建线程对应的任务为null。防止线程池被关闭\n           else if (workerCountOf(recheck) == 0)\n               addWorker(null, false);\n       }\n      //这里是启动小于maxpoolSize的线程\n      //如果添加任务到队列中不成功，则试图通过addWorker(command, false)新建一个线程，\n      //并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。\n      // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。\n       else if (!addWorker(command, false))\n           reject(command);\n   }\n}\n</code></pre>\n<p><strong>说明</strong>：execute()的作用是将任务添加到线程池中执行。它会分为3种情况进行处理：        </p>\n<p><strong>情况1</strong> – 如果”线程池中任务数量” &lt; “核心池大小”时，即线程池中少于corePoolSize个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。         </p>\n<p><strong>情况2</strong> – 如果”线程池中任务数量” &gt;= “核心池大小”，并且”线程池是允许状态”；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认”线程池的状态”，如果”第2次读到的线程池状态”和”第1次读到的线程池状态”不同，则从阻塞队列中删除该任务。         </p>\n<p><strong>情况3</strong> – 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过reject()拒绝该任务。</p>\n<p>到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：</p>\n<ol>\n<li>首先，要清楚corePoolSize和maximumPoolSize的含义；</li>\n<li>其次，要知道Worker是用来起到什么作用的；</li>\n<li>要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：</li>\n</ol>\n<ul>\n<li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li>\n<li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li>\n<li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li>\n<li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于 corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li>\n</ul>\n<h3 id=\"addWorker\"><a href=\"#addWorker\" class=\"headerlink\" title=\"addWorker\"></a><strong>addWorker</strong></h3><p>源码如下</p>\n<pre><code class=\"java\">private boolean addWorker(Runnable firstTask, boolean core) {\n       retry:\n       // 更新&quot;线程池状态和计数&quot;标记，即更新ctl。\n       for (;;) {\n          // 更新&quot;线程池状态和计数&quot;标记，即更新ctl。\n           int c = ctl.get();\n            // 获取线程池状态。\n           int rs = runStateOf(c);\n\n           // Check if queue empty only if necessary.\n           // 有效性检查\n           if (rs &gt;= SHUTDOWN &amp;&amp;\n               ! (rs == SHUTDOWN &amp;&amp;\n                  firstTask == null &amp;&amp;\n                  ! workQueue.isEmpty()))\n               return false;\n\n           for (;;) {\n              // 获取线程池中任务的数量。\n               int wc = workerCountOf(c);\n               // 如果&quot;线程池中任务的数量&quot;超过限制，则返回false。\n               if (wc &gt;= CAPACITY ||\n                   wc &gt;= (core ? corePoolSize : maximumPoolSize))\n                   return false;\n               // 通过CAS函数将c的值+1。操作失败的话，则退出循环。\n               if (compareAndIncrementWorkerCount(c))\n                   break retry;\n               c = ctl.get();  // Re-read ctl\n               // 检查&quot;线程池状态&quot;，如果与之前的状态不同，则从retry重新开始。\n               if (runStateOf(c) != rs)\n                   continue retry;\n               // else CAS failed due to workerCount change; retry inner loop\n           }\n       }\n\n   boolean workerStarted = false;\n   boolean workerAdded = false;\n   Worker w = null;\n   // 添加任务到线程池，并启动任务所在的线程。\n   try {\n       final ReentrantLock mainLock = this.mainLock;\n       // 新建Worker，并且指定firstTask为Worker的第一个任务。\n       w = new Worker(firstTask);\n       // 获取Worker对应的线程。\n       final Thread t = w.thread;\n       if (t != null) {\n           // 获取锁\n           mainLock.lock();\n           try {\n               int c = ctl.get();\n               int rs = runStateOf(c);\n\n               // 再次确认&quot;线程池状态&quot;\n               if (rs &lt; SHUTDOWN ||\n                   (rs == SHUTDOWN &amp;&amp; firstTask == null)) {\n                   if (t.isAlive()) // precheck that t is startable\n                       throw new IllegalThreadStateException();\n                   // 将Worker对象(w)添加到&quot;线程池的Worker集合(workers)&quot;中\n                   workers.add(w);\n                   // 更新largestPoolSize\n                   int s = workers.size();\n                   if (s &gt; largestPoolSize)\n                       largestPoolSize = s;\n                   workerAdded = true;\n               }\n           } finally {\n               // 释放锁\n               mainLock.unlock();\n           }\n           // 如果&quot;成功将任务添加到线程池&quot;中，则启动任务所在的线程。 \n           if (workerAdded) {\n               t.start();\n               workerStarted = true;\n           }\n       }\n   } finally {\n       if (! workerStarted)\n           addWorkerFailed(w);\n   }\n   // 返回任务是否启动。\n   return workerStarted;\n}\n\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li><p>addWorker(Runnable firstTask, boolean core) 的作用是将任务(firstTask)添加到线程池中，并启动该任务。core为true的话，则以corePoolSize为界限，若”线程池中已有任务数量&gt;=corePoolSize”，则返回false；core为false的话，则以maximumPoolSize为界限，若”线程池中已有任务数量&gt;=maximumPoolSize”，则返回false。</p>\n</li>\n<li><p>addWorker()会先通过for循环不断尝试更新ctl状态，ctl记录了”线程池中任务数量和线程池状态”。更新成功之后，再通过try模块来将任务添加到线程池中，并启动任务所在的线程。</p>\n</li>\n<li><p>从addWorker()中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的Worker对象；而一个Workder对象包含一个Thread对象。</p>\n<p>(01) 通过将Worker对象添加到”线程的workers集合”中，从而实现将任务添加到线程池中。</p>\n<p>(02) 通过启动Worker对应的Thread线程，则执行该任务。</p>\n</li>\n</ol>\n<h3 id=\"addWorkerFailed\"><a href=\"#addWorkerFailed\" class=\"headerlink\" title=\"addWorkerFailed:\"></a>addWorkerFailed:</h3><p>如果Worker创建成功，但是没有启动，这时我们需要将从线程对象从works上移除，否则会影响线程池的性能，源码如下</p>\n<pre><code class=\"java\">   /**\n    * Rolls back the worker thread creation.\n    * - removes worker from workers, if present\n    * - decrements worker count\n    * - rechecks for termination, in case the existence of this\n    *   worker was holding up termination\n    */\n   private void addWorkerFailed(Worker w) {\n\n       final ReentrantLock mainLock = this.mainLock;\n       //获取锁\n       mainLock.lock();\n       try {\n           //从workers上移除线程\n           if (w != null)\n               workers.remove(w);\n           //减少线程的数量\n           decrementWorkerCount();\n           //由于线程数量的减少，可能会使得当前线程池上线程的数量变成0，这时有可能进入\n           //TIDYING状态，所以尝试结束线程池\n           tryTerminate();\n       } finally {\n           mainLock.unlock();\n       }\n   }\n</code></pre>\n<p>这时你们会不会有个疑问，一般我们写程序时，如果想让线程一直运行，则会向下面这样写:</p>\n<pre><code>public void run(){\n   while(true){\n       //doSomething\n   }\n}\n</code></pre><p>但是上面执行流程分析完了，但是没看到ThreadPoolExecutor怎么定义线程一直运行，这时我们就要去分析Worker这个内部类的源码，这里面有我们想要的结果：</p>\n<p>源码如下：</p>\n<pre><code class=\"java\"> private final class Worker\n       extends AbstractQueuedSynchronizer\n       implements Runnable {      \n       private static final long serialVersionUID = 6138294804551838833L;\n          //当前woker正在运行的线程\n       final Thread thread;\n       //初始化这个工作线程时的第一个任务，可能为null\n       Runnable firstTask;\n          //每个线程完成任务的数量\n       volatile long completedTasks;\n\n       Worker(Runnable firstTask) {\n           setState(-1); // inhibit interrupts until runWorker\n           this.firstTask = firstTask;       \n           //使用线程池提供的线程创建工厂来创建线程\n           this.thread = getThreadFactory().newThread(this);\n       }\n       //委派当前线程的run方法到外部类的runWorker上，\n       public void run() {\n           runWorker(this);\n       }\n       // Lock methods\n       //\n       // The value 0 represents the unlocked state.\n       // The value 1 represents the locked state.\n       protected boolean isHeldExclusively() {\n           return getState() != 0;\n       }\n\n       protected boolean tryAcquire(int unused) {\n           if (compareAndSetState(0, 1)) {\n               setExclusiveOwnerThread(Thread.currentThread());\n               return true;\n           }\n           return false;\n       }\n\n       protected boolean tryRelease(int unused) {\n           setExclusiveOwnerThread(null);\n           setState(0);\n           return true;\n       }\n\n       public void lock()        { acquire(1); }\n       public boolean tryLock()  { return tryAcquire(1); }\n       public void unlock()      { release(1); }\n       public boolean isLocked() { return isHeldExclusively(); }\n\n       void interruptIfStarted() {\n           Thread t;\n           if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {\n               try {\n                   t.interrupt();\n               } catch (SecurityException ignore) {\n               }\n           }\n       }\n   }\n</code></pre>\n<p>分析：</p>\n<ol>\n<li>从上面我们可以看出，Worker继承AQS，实现Runnable接口，继承AQS实现了一个简单的互斥锁，是不想在Worker运行的时候使用外部类的互斥锁，这样可以减少线程的等待。</li>\n<li>线程创建时通过外部类的threadFactory来创建的，后面我会讲解这个类，其实很简单</li>\n</ol>\n<p>从上面可以看出Worker类的run方法实现实际上是外部类的runWorker方法实现的，源码如下：</p>\n<pre><code class=\"java\">final void runWorker(Worker w) {\n       //获取当前cpu上运行的线程，其实也就是worker中的thread\n       Thread wt = Thread.currentThread();\n       //获取第一个运行任务，可以为null\n       Runnable task = w.firstTask;\n       w.firstTask = null;\n       //释放锁\n       w.unlock(); // allow interrupts\n       //判断当前线程是否是中断结束 true 不是\n       boolean completedAbruptly = true;\n       try {\n           //当任务不为空，一直运行\n           while (task != null || (task = getTask()) != null) {\n               w.lock();\n               // If pool is stopping, ensure thread is interrupted;\n               // if not, ensure thread is not interrupted.  This\n               // requires a recheck in second case to deal with\n               // shutdownNow race while clearing interrupt\n               if ((runStateAtLeast(ctl.get(), STOP) ||\n                    (Thread.interrupted() &amp;&amp;\n                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;\n                   !wt.isInterrupted())\n                   wt.interrupt();\n               try {\n                   //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n                   //默认什么也不做\n                   beforeExecute(wt, task);\n                   Throwable thrown = null;\n                   try {\n                       //执行任务\n                       task.run();\n                   } catch (RuntimeException x) {\n                       thrown = x; throw x;\n                   } catch (Error x) {\n                       thrown = x; throw x;\n                   } catch (Throwable x) {\n                       thrown = x; throw new Error(x);\n                   } finally {\n                        //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n                        //默认什么也不做\n                       afterExecute(task, thrown);\n                   }\n               } finally {\n                   task = null;\n                   w.completedTasks++;\n                   w.unlock();\n               }\n           }\n           completedAbruptly = false;\n       } finally {\n           //线程死亡，使用此方法执行后续清理工作，\n           processWorkerExit(w, completedAbruptly);\n       }\n   }\n</code></pre>\n<p>从上面代码可以看到这边在循环获取任务，并执行，直到任务全部执行完毕。除了第一个任务，其他任务都是通过<code>getTask()</code>方法去取，这个方法是ThreadPoolExecutor中的一个方法。我们猜一下，整个类中只有任务缓存队列中保存了任务，应该就是去缓存队列中取了。</p>\n<pre><code>Runnable getTask() {\n   for (;;) {\n       try {\n           int state = runState;\n           if (state &gt; SHUTDOWN)\n               return null;\n           Runnable r;\n           if (state == SHUTDOWN)  // Help drain queue\n               r = workQueue.poll(); //取任务\n           else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，\n               //则通过poll取任务，若等待一定的时间取不到任务，则返回null\n               r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);\n           else\n               r = workQueue.take();\n           if (r != null)\n               return r;\n           if (workerCanExit()) {    //如果没取到任务，即r为null，则判断当前的worker是否可以退出\n               if (runState &gt;= SHUTDOWN) // Wake up others\n                   interruptIdleWorkers();   //中断处于空闲状态的worker\n               return null;\n           }\n           // Else retry\n       } catch (InterruptedException ie) {\n           // On interruption, re-check runState\n       }\n   }\n}\n</code></pre><p>这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给 空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程Worker去任务缓存队列里面取任务来执行，因为每一个Worker里面都包含了一个线程thread。</p>\n<p>还需要注意的是，当线程死亡如何处理：</p>\n<p>源码如下：</p>\n<pre><code>   //处理线程结束时的清理工作\n   private void processWorkerExit(Worker w, boolean completedAbruptly) {\n       //如果是中断结束，则线程数量不做调整\n       if (completedAbruptly) \n           decrementWorkerCount();\n\n       final ReentrantLock mainLock = this.mainLock;\n       //获取锁\n       mainLock.lock();\n       try {\n           //将当前worker线程上的完成任务数量记录下来\n           completedTaskCount += w.completedTasks;\n           //移除当前此worker\n           workers.remove(w);\n       } finally {\n           mainLock.unlock();\n       }\n       //尝试关闭线程池\n       tryTerminate();\n       int c = ctl.get();\n       //如果当前线程池状态不是stop，则添加woker线程\n       if (runStateLessThan(c, STOP)) {\n           //如果是异常导致线程的中断，则判断当前线程池中线程的\n           //数量是否大于min，min表示当前线程池最少应该有多少线程\n           //如果少于，则创建一个新的worker线程\n           if (!completedAbruptly) {\n               int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n               if (min == 0 &amp;&amp; ! workQueue.isEmpty())\n                   min = 1;\n               if (workerCountOf(c) &gt;= min)\n                   return; // replacement not needed\n           }\n           addWorker(null, false);\n       }\n   }\n</code></pre><h3 id=\"关闭“线程池”\"><a href=\"#关闭“线程池”\" class=\"headerlink\" title=\"关闭“线程池”\"></a>关闭“线程池”</h3><p>shutdown()的源码如下：</p>\n<pre><code class=\"java\">public void shutdown() {\n   final ReentrantLock mainLock = this.mainLock;\n   // 获取锁\n   mainLock.lock();\n   try {\n       // 检查终止线程池的“线程”是否有权限。\n       checkShutdownAccess();\n       // 设置线程池的状态为关闭状态。\n       advanceRunState(SHUTDOWN);\n       // 中断线程池中空闲的线程。\n       interruptIdleWorkers();\n       // 钩子函数，在ThreadPoolExecutor中没有任何动作。\n       onShutdown(); // hook for ScheduledThreadPoolExecutor\n   } finally {\n       // 释放锁\n       mainLock.unlock();\n   }\n   // 尝试终止线程池\n   tryTerminate();\n}\n</code></pre>\n<p><strong>说明</strong>：shutdown()的作用是关闭线程池。</p>\n<p>shutdownNow()源码如下：</p>\n<pre><code class=\"java\">public List&lt;Runnable&gt; shutdownNow() {\n       List&lt;Runnable&gt; tasks;\n       final ReentrantLock mainLock = this.mainLock;\n       //获取所\n       mainLock.lock();\n       try {\n\n           checkShutdownAccess();\n           //设置线程池状态为stop状态\n           advanceRunState(STOP);\n           //中断所有线程\n           interruptWorkers();\n           //取出队列上还未被执行的任务\n           tasks = drainQueue();\n       } finally {\n           mainLock.unlock();\n       }\n       tryTerminate();\n       //返回队列上的任务\n       return tasks;\n   }\n\n</code></pre>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java多线程系列-JUC线程池之02-ThreadPoolExecutor-执行流程分析\"><a href=\"#java多线程系列-JUC线程池之02-ThreadPoolExecutor-执行流程分析\" class=\"headerlink\" title=\"java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析\"></a>java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析</h1><h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><blockquote>\n<ol>\n<li>线程池使用例子</li>\n<li>线程池状态</li>\n<li>任务执行流程分析</li>\n</ol>\n</blockquote>\n<h3 id=\"1-线程池使用例子\"><a href=\"#1-线程池使用例子\" class=\"headerlink\" title=\"1. 线程池使用例子\"></a>1. 线程池使用例子</h3><blockquote>\n<p>简单例子</p>\n<pre><code>import java.util.concurrent.Executors;\nimport java.util.concurrent.ExecutorService;\n\npublic class ThreadPoolDemo1 {\n\n   public static void main(String[] args) {\n       // 创建一个可重用固定线程数的线程池\n       ExecutorService pool = Executors.newFixedThreadPool(2);\n       // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口\n       Thread ta = new MyThread();\n       Thread tb = new MyThread();\n       Thread tc = new MyThread();\n       Thread td = new MyThread();\n       Thread te = new MyThread();\n       // 将线程放入池中进行执行\n       pool.execute(ta);\n       pool.execute(tb);\n       pool.execute(tc);\n       pool.execute(td);\n       pool.execute(te);\n       // 关闭线程池\n       pool.shutdown();\n   }\n}\n\nclass MyThread extends Thread {\n\n   @Override\n   public void run() {\n       System.out.println(Thread.currentThread().getName()+ &quot; is running.&quot;);\n   }\n}\n</code></pre><p><strong>运行结果</strong>：</p>\n<pre><code>pool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\npool-1-thread-2 is running.\npool-1-thread-1 is running.\n</code></pre><p>示例中，使用了Excutors工具类来创建线程池，并提交任务到线程池上运行，然后关闭线程池，这是一个简单的实例。接下来我们将进行ThreadPoolExecutor深入分析。</p>\n</blockquote>\n<h3 id=\"2-线程池状态\"><a href=\"#2-线程池状态\" class=\"headerlink\" title=\"2. 线程池状态\"></a>2. 线程池状态</h3><blockquote>\n<p>在线程池中使用了一个AtomicInteger对象来表示线程的状态和任务的数量。其中Integer是32位，用高三位来表示线程池的状态，至于怎么计算不是这里的重点，这里我们先讲解任务的状态。</p>\n<p>线程池中任务的状态有以下5种：</p>\n<pre><code>RUNNING   :接收新的任务和处理队列中的任务\nSHUTDOWN  :不在接收新的任务和但是处理队列中的任务。\nSTOP        :不在接收新的任务，同时不在处理队列中的任务，线程上正在运行的任务也会被打断。\nTIDYING   :所有的任务已经结束，并且线程的数量为0，线程的状态转换成清理的状态，接下来将会运行\n           terminated()方法。\nTERMINATED:terminated()执行完成\n</code></pre><p>状态的转换:</p>\n<pre><code>* RUNNING -&gt; SHUTDOWN\n*    On invocation of shutdown(), perhaps implicitly in finalize()\n* (RUNNING or SHUTDOWN) -&gt; STOP\n*    On invocation of shutdownNow()\n* SHUTDOWN -&gt; TIDYING\n*    When both queue and pool are empty\n* STOP -&gt; TIDYING\n*    When pool is empty\n* TIDYING -&gt; TERMINATED\n*    When the terminated() hook method has completed\n</code></pre></blockquote>\n<h3 id=\"3-线程池执行任务分析\"><a href=\"#3-线程池执行任务分析\" class=\"headerlink\" title=\"3. 线程池执行任务分析\"></a>3. 线程池执行任务分析</h3><blockquote>\n<p>在讲解运行过程前，我们先看下<code>ThreadPoolExecutor</code>中的几个比较重要的成员变量：</p>\n<pre><code class=\"java\">//线程池状态，和队列中任务数量的表示，高三位表示状态，剩下的表示线程的状态\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); \n//任务缓存队列，用来保存等待中的任务，等待worker线程空闲时执行任务\nprivate final BlockingQueue&lt;Runnable&gt; workQueue;\n//更新 poolSize, corePoolSize,maximumPoolSize, runState, and workers set 时需要持有这个锁\nprivate final ReentrantLock mainLock = new ReentrantLock(); \n//用来保存工作中的执行线程\n\nprivate final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); \nprivate volatile long  keepAliveTime; //超过corePoolSize外的线程空闲存活之间\n//是否对corePoolSize内的线程设置空闲存活时间\nprivate volatile boolean allowCoreThreadTimeOut; \nprivate volatile int   corePoolSize; //核心线程数\n\n//最大线程数（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）\nprivate volatile int   maximumPoolSize; \nprivate volatile int   poolSize; //线程池中的当前线程数\nprivate volatile RejectedExecutionHandler handler; //任务拒绝策略\nprivate volatile ThreadFactory threadFactory; //线程工厂，用来新建线程\nprivate int largestPoolSize; //记录线程池中出现过的最大线程数大小\nprivate long completedTaskCount; //已经执行完的线程数\n</code></pre>\n<p>这边重点解释下 <code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>两个变量，这两个变量涉及到线程池中创建线程个数的一个策略。<br><code>corePoolSize</code>： 这个变量我们可以理解为线程池的核心大小，举个例子来说明（corePoolSize假设等于10，maximumPoolSize等于20）：</p>\n<ol>\n<li>有一个部门，其中有10（corePoolSize）名工人，当有新任务来了后，领导就分配任务给工人去做，每个工人只能做一个任务。</li>\n<li>当10个工人都在忙时，新来的任务就要放到队列（workQueue）中等待。</li>\n<li>当任务越积累越多，远远超过工人做任务的速度时，领导就想了一个办法：从其他部门借10个工人来，借的数量有一个公式（maximumPoolSize - corePoolSize）来计算。然后把新来的任务分配给借来的工人来做。</li>\n<li>但是如果速度还是还不急的话，可能就要采取措施来放弃一些任务了（RejectedExecutionHandler）。<br>等到一定时间后，任务都完成了，工人比较闲的情况下，就考虑把借来的10个工人还回去（根据keepAliveTime判断）</li>\n<li>也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</li>\n</ol>\n<h3 id=\"任务执行：execute\"><a href=\"#任务执行：execute\" class=\"headerlink\" title=\"任务执行：execute\"></a>任务执行：execute</h3><p>这个方法在ThreadPoolExecutor中的源码如下</p>\n<pre><code class=\"java\">public void execute(Runnable command) {\n        //如果任务是空，则抛出空指针异常\n       if (command == null)\n           throw new NullPointerException();\n        //得到当前ctl的值，方便下面计算    \n       int c = ctl.get();\n        //计算当前线程池中线程的数量，如果小于核心线程数，则添加线程\n       if (workerCountOf(c) &lt; corePoolSize) {\n           // 则通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程\n           //中；然后，启动该线程从而执行任务。\n           if (addWorker(command, true))\n               return;\n           c = ctl.get();\n       }\n        // 当线程池中的任务数量 &gt;= &quot;核心池大小&quot;时，\n        // 而且，&quot;线程池处于运行状态&quot;时，则尝试将任务添加到阻塞队列中。\n       if (isRunning(c) &amp;&amp; workQueue.offer(command)) {\n            // 再次确认“线程池状态”，若线程池异常终止了，则删除任务；\n           //然后通过reject()执行相应的拒绝策略的内容。\n           int recheck = ctl.get();\n           if (! isRunning(recheck) &amp;&amp; remove(command))\n               reject(command);\n           // 否则，如果&quot;线程池中任务数量&quot;为0，则通过addWorker(null, false)尝试新建一个线\n           // 程，新建线程对应的任务为null。防止线程池被关闭\n           else if (workerCountOf(recheck) == 0)\n               addWorker(null, false);\n       }\n      //这里是启动小于maxpoolSize的线程\n      //如果添加任务到队列中不成功，则试图通过addWorker(command, false)新建一个线程，\n      //并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。\n      // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。\n       else if (!addWorker(command, false))\n           reject(command);\n   }\n}\n</code></pre>\n<p><strong>说明</strong>：execute()的作用是将任务添加到线程池中执行。它会分为3种情况进行处理：        </p>\n<p><strong>情况1</strong> – 如果”线程池中任务数量” &lt; “核心池大小”时，即线程池中少于corePoolSize个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。         </p>\n<p><strong>情况2</strong> – 如果”线程池中任务数量” &gt;= “核心池大小”，并且”线程池是允许状态”；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认”线程池的状态”，如果”第2次读到的线程池状态”和”第1次读到的线程池状态”不同，则从阻塞队列中删除该任务。         </p>\n<p><strong>情况3</strong> – 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过reject()拒绝该任务。</p>\n<p>到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：</p>\n<ol>\n<li>首先，要清楚corePoolSize和maximumPoolSize的含义；</li>\n<li>其次，要知道Worker是用来起到什么作用的；</li>\n<li>要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：</li>\n</ol>\n<ul>\n<li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li>\n<li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li>\n<li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li>\n<li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于 corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li>\n</ul>\n<h3 id=\"addWorker\"><a href=\"#addWorker\" class=\"headerlink\" title=\"addWorker\"></a><strong>addWorker</strong></h3><p>源码如下</p>\n<pre><code class=\"java\">private boolean addWorker(Runnable firstTask, boolean core) {\n       retry:\n       // 更新&quot;线程池状态和计数&quot;标记，即更新ctl。\n       for (;;) {\n          // 更新&quot;线程池状态和计数&quot;标记，即更新ctl。\n           int c = ctl.get();\n            // 获取线程池状态。\n           int rs = runStateOf(c);\n\n           // Check if queue empty only if necessary.\n           // 有效性检查\n           if (rs &gt;= SHUTDOWN &amp;&amp;\n               ! (rs == SHUTDOWN &amp;&amp;\n                  firstTask == null &amp;&amp;\n                  ! workQueue.isEmpty()))\n               return false;\n\n           for (;;) {\n              // 获取线程池中任务的数量。\n               int wc = workerCountOf(c);\n               // 如果&quot;线程池中任务的数量&quot;超过限制，则返回false。\n               if (wc &gt;= CAPACITY ||\n                   wc &gt;= (core ? corePoolSize : maximumPoolSize))\n                   return false;\n               // 通过CAS函数将c的值+1。操作失败的话，则退出循环。\n               if (compareAndIncrementWorkerCount(c))\n                   break retry;\n               c = ctl.get();  // Re-read ctl\n               // 检查&quot;线程池状态&quot;，如果与之前的状态不同，则从retry重新开始。\n               if (runStateOf(c) != rs)\n                   continue retry;\n               // else CAS failed due to workerCount change; retry inner loop\n           }\n       }\n\n   boolean workerStarted = false;\n   boolean workerAdded = false;\n   Worker w = null;\n   // 添加任务到线程池，并启动任务所在的线程。\n   try {\n       final ReentrantLock mainLock = this.mainLock;\n       // 新建Worker，并且指定firstTask为Worker的第一个任务。\n       w = new Worker(firstTask);\n       // 获取Worker对应的线程。\n       final Thread t = w.thread;\n       if (t != null) {\n           // 获取锁\n           mainLock.lock();\n           try {\n               int c = ctl.get();\n               int rs = runStateOf(c);\n\n               // 再次确认&quot;线程池状态&quot;\n               if (rs &lt; SHUTDOWN ||\n                   (rs == SHUTDOWN &amp;&amp; firstTask == null)) {\n                   if (t.isAlive()) // precheck that t is startable\n                       throw new IllegalThreadStateException();\n                   // 将Worker对象(w)添加到&quot;线程池的Worker集合(workers)&quot;中\n                   workers.add(w);\n                   // 更新largestPoolSize\n                   int s = workers.size();\n                   if (s &gt; largestPoolSize)\n                       largestPoolSize = s;\n                   workerAdded = true;\n               }\n           } finally {\n               // 释放锁\n               mainLock.unlock();\n           }\n           // 如果&quot;成功将任务添加到线程池&quot;中，则启动任务所在的线程。 \n           if (workerAdded) {\n               t.start();\n               workerStarted = true;\n           }\n       }\n   } finally {\n       if (! workerStarted)\n           addWorkerFailed(w);\n   }\n   // 返回任务是否启动。\n   return workerStarted;\n}\n\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li><p>addWorker(Runnable firstTask, boolean core) 的作用是将任务(firstTask)添加到线程池中，并启动该任务。core为true的话，则以corePoolSize为界限，若”线程池中已有任务数量&gt;=corePoolSize”，则返回false；core为false的话，则以maximumPoolSize为界限，若”线程池中已有任务数量&gt;=maximumPoolSize”，则返回false。</p>\n</li>\n<li><p>addWorker()会先通过for循环不断尝试更新ctl状态，ctl记录了”线程池中任务数量和线程池状态”。更新成功之后，再通过try模块来将任务添加到线程池中，并启动任务所在的线程。</p>\n</li>\n<li><p>从addWorker()中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的Worker对象；而一个Workder对象包含一个Thread对象。</p>\n<p>(01) 通过将Worker对象添加到”线程的workers集合”中，从而实现将任务添加到线程池中。</p>\n<p>(02) 通过启动Worker对应的Thread线程，则执行该任务。</p>\n</li>\n</ol>\n<h3 id=\"addWorkerFailed\"><a href=\"#addWorkerFailed\" class=\"headerlink\" title=\"addWorkerFailed:\"></a>addWorkerFailed:</h3><p>如果Worker创建成功，但是没有启动，这时我们需要将从线程对象从works上移除，否则会影响线程池的性能，源码如下</p>\n<pre><code class=\"java\">   /**\n    * Rolls back the worker thread creation.\n    * - removes worker from workers, if present\n    * - decrements worker count\n    * - rechecks for termination, in case the existence of this\n    *   worker was holding up termination\n    */\n   private void addWorkerFailed(Worker w) {\n\n       final ReentrantLock mainLock = this.mainLock;\n       //获取锁\n       mainLock.lock();\n       try {\n           //从workers上移除线程\n           if (w != null)\n               workers.remove(w);\n           //减少线程的数量\n           decrementWorkerCount();\n           //由于线程数量的减少，可能会使得当前线程池上线程的数量变成0，这时有可能进入\n           //TIDYING状态，所以尝试结束线程池\n           tryTerminate();\n       } finally {\n           mainLock.unlock();\n       }\n   }\n</code></pre>\n<p>这时你们会不会有个疑问，一般我们写程序时，如果想让线程一直运行，则会向下面这样写:</p>\n<pre><code>public void run(){\n   while(true){\n       //doSomething\n   }\n}\n</code></pre><p>但是上面执行流程分析完了，但是没看到ThreadPoolExecutor怎么定义线程一直运行，这时我们就要去分析Worker这个内部类的源码，这里面有我们想要的结果：</p>\n<p>源码如下：</p>\n<pre><code class=\"java\"> private final class Worker\n       extends AbstractQueuedSynchronizer\n       implements Runnable {      \n       private static final long serialVersionUID = 6138294804551838833L;\n          //当前woker正在运行的线程\n       final Thread thread;\n       //初始化这个工作线程时的第一个任务，可能为null\n       Runnable firstTask;\n          //每个线程完成任务的数量\n       volatile long completedTasks;\n\n       Worker(Runnable firstTask) {\n           setState(-1); // inhibit interrupts until runWorker\n           this.firstTask = firstTask;       \n           //使用线程池提供的线程创建工厂来创建线程\n           this.thread = getThreadFactory().newThread(this);\n       }\n       //委派当前线程的run方法到外部类的runWorker上，\n       public void run() {\n           runWorker(this);\n       }\n       // Lock methods\n       //\n       // The value 0 represents the unlocked state.\n       // The value 1 represents the locked state.\n       protected boolean isHeldExclusively() {\n           return getState() != 0;\n       }\n\n       protected boolean tryAcquire(int unused) {\n           if (compareAndSetState(0, 1)) {\n               setExclusiveOwnerThread(Thread.currentThread());\n               return true;\n           }\n           return false;\n       }\n\n       protected boolean tryRelease(int unused) {\n           setExclusiveOwnerThread(null);\n           setState(0);\n           return true;\n       }\n\n       public void lock()        { acquire(1); }\n       public boolean tryLock()  { return tryAcquire(1); }\n       public void unlock()      { release(1); }\n       public boolean isLocked() { return isHeldExclusively(); }\n\n       void interruptIfStarted() {\n           Thread t;\n           if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {\n               try {\n                   t.interrupt();\n               } catch (SecurityException ignore) {\n               }\n           }\n       }\n   }\n</code></pre>\n<p>分析：</p>\n<ol>\n<li>从上面我们可以看出，Worker继承AQS，实现Runnable接口，继承AQS实现了一个简单的互斥锁，是不想在Worker运行的时候使用外部类的互斥锁，这样可以减少线程的等待。</li>\n<li>线程创建时通过外部类的threadFactory来创建的，后面我会讲解这个类，其实很简单</li>\n</ol>\n<p>从上面可以看出Worker类的run方法实现实际上是外部类的runWorker方法实现的，源码如下：</p>\n<pre><code class=\"java\">final void runWorker(Worker w) {\n       //获取当前cpu上运行的线程，其实也就是worker中的thread\n       Thread wt = Thread.currentThread();\n       //获取第一个运行任务，可以为null\n       Runnable task = w.firstTask;\n       w.firstTask = null;\n       //释放锁\n       w.unlock(); // allow interrupts\n       //判断当前线程是否是中断结束 true 不是\n       boolean completedAbruptly = true;\n       try {\n           //当任务不为空，一直运行\n           while (task != null || (task = getTask()) != null) {\n               w.lock();\n               // If pool is stopping, ensure thread is interrupted;\n               // if not, ensure thread is not interrupted.  This\n               // requires a recheck in second case to deal with\n               // shutdownNow race while clearing interrupt\n               if ((runStateAtLeast(ctl.get(), STOP) ||\n                    (Thread.interrupted() &amp;&amp;\n                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;\n                   !wt.isInterrupted())\n                   wt.interrupt();\n               try {\n                   //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n                   //默认什么也不做\n                   beforeExecute(wt, task);\n                   Throwable thrown = null;\n                   try {\n                       //执行任务\n                       task.run();\n                   } catch (RuntimeException x) {\n                       thrown = x; throw x;\n                   } catch (Error x) {\n                       thrown = x; throw x;\n                   } catch (Throwable x) {\n                       thrown = x; throw new Error(x);\n                   } finally {\n                        //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，\n                        //默认什么也不做\n                       afterExecute(task, thrown);\n                   }\n               } finally {\n                   task = null;\n                   w.completedTasks++;\n                   w.unlock();\n               }\n           }\n           completedAbruptly = false;\n       } finally {\n           //线程死亡，使用此方法执行后续清理工作，\n           processWorkerExit(w, completedAbruptly);\n       }\n   }\n</code></pre>\n<p>从上面代码可以看到这边在循环获取任务，并执行，直到任务全部执行完毕。除了第一个任务，其他任务都是通过<code>getTask()</code>方法去取，这个方法是ThreadPoolExecutor中的一个方法。我们猜一下，整个类中只有任务缓存队列中保存了任务，应该就是去缓存队列中取了。</p>\n<pre><code>Runnable getTask() {\n   for (;;) {\n       try {\n           int state = runState;\n           if (state &gt; SHUTDOWN)\n               return null;\n           Runnable r;\n           if (state == SHUTDOWN)  // Help drain queue\n               r = workQueue.poll(); //取任务\n           else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，\n               //则通过poll取任务，若等待一定的时间取不到任务，则返回null\n               r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);\n           else\n               r = workQueue.take();\n           if (r != null)\n               return r;\n           if (workerCanExit()) {    //如果没取到任务，即r为null，则判断当前的worker是否可以退出\n               if (runState &gt;= SHUTDOWN) // Wake up others\n                   interruptIdleWorkers();   //中断处于空闲状态的worker\n               return null;\n           }\n           // Else retry\n       } catch (InterruptedException ie) {\n           // On interruption, re-check runState\n       }\n   }\n}\n</code></pre><p>这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给 空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程Worker去任务缓存队列里面取任务来执行，因为每一个Worker里面都包含了一个线程thread。</p>\n<p>还需要注意的是，当线程死亡如何处理：</p>\n<p>源码如下：</p>\n<pre><code>   //处理线程结束时的清理工作\n   private void processWorkerExit(Worker w, boolean completedAbruptly) {\n       //如果是中断结束，则线程数量不做调整\n       if (completedAbruptly) \n           decrementWorkerCount();\n\n       final ReentrantLock mainLock = this.mainLock;\n       //获取锁\n       mainLock.lock();\n       try {\n           //将当前worker线程上的完成任务数量记录下来\n           completedTaskCount += w.completedTasks;\n           //移除当前此worker\n           workers.remove(w);\n       } finally {\n           mainLock.unlock();\n       }\n       //尝试关闭线程池\n       tryTerminate();\n       int c = ctl.get();\n       //如果当前线程池状态不是stop，则添加woker线程\n       if (runStateLessThan(c, STOP)) {\n           //如果是异常导致线程的中断，则判断当前线程池中线程的\n           //数量是否大于min，min表示当前线程池最少应该有多少线程\n           //如果少于，则创建一个新的worker线程\n           if (!completedAbruptly) {\n               int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n               if (min == 0 &amp;&amp; ! workQueue.isEmpty())\n                   min = 1;\n               if (workerCountOf(c) &gt;= min)\n                   return; // replacement not needed\n           }\n           addWorker(null, false);\n       }\n   }\n</code></pre><h3 id=\"关闭“线程池”\"><a href=\"#关闭“线程池”\" class=\"headerlink\" title=\"关闭“线程池”\"></a>关闭“线程池”</h3><p>shutdown()的源码如下：</p>\n<pre><code class=\"java\">public void shutdown() {\n   final ReentrantLock mainLock = this.mainLock;\n   // 获取锁\n   mainLock.lock();\n   try {\n       // 检查终止线程池的“线程”是否有权限。\n       checkShutdownAccess();\n       // 设置线程池的状态为关闭状态。\n       advanceRunState(SHUTDOWN);\n       // 中断线程池中空闲的线程。\n       interruptIdleWorkers();\n       // 钩子函数，在ThreadPoolExecutor中没有任何动作。\n       onShutdown(); // hook for ScheduledThreadPoolExecutor\n   } finally {\n       // 释放锁\n       mainLock.unlock();\n   }\n   // 尝试终止线程池\n   tryTerminate();\n}\n</code></pre>\n<p><strong>说明</strong>：shutdown()的作用是关闭线程池。</p>\n<p>shutdownNow()源码如下：</p>\n<pre><code class=\"java\">public List&lt;Runnable&gt; shutdownNow() {\n       List&lt;Runnable&gt; tasks;\n       final ReentrantLock mainLock = this.mainLock;\n       //获取所\n       mainLock.lock();\n       try {\n\n           checkShutdownAccess();\n           //设置线程池状态为stop状态\n           advanceRunState(STOP);\n           //中断所有线程\n           interruptWorkers();\n           //取出队列上还未被执行的任务\n           tasks = drainQueue();\n       } finally {\n           mainLock.unlock();\n       }\n       tryTerminate();\n       //返回队列上的任务\n       return tasks;\n   }\n\n</code></pre>\n</blockquote>\n"},{"title":"自旋锁","author":"zhangke","abbrlink":58330,"date":"2018-12-14T03:27:00.000Z","_content":"---\n# 自旋锁\n\n### 概述\n\n1. 自旋锁是什么\n2. 自旋锁实现\n3. MCS自旋锁\n4. CLH自旋锁\n\n### 1. 自旋锁是什么\n\n自旋锁与**互斥量**(注意这里不是互斥锁)类似，用于多线程同步的一种锁。但他不是休眠使线程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。基本的实现是通过线程反复检查锁特定变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。\n\n自旋锁通常被作为底层原语用于实现其他类型的锁。根据它们所基于与的系统体系结构，可以通过使用测试并设置指令（CAS）有效的实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其它的事情，这也是自旋锁只能够持有一段时间的原因。\n\n有了这一层了解，自旋锁的优势和劣势，以及其适用场景也就一目了然了。\n<!-- more -->\n\n#### 优势：\n\n1. 没有线程阻塞，也就没有了线程上下文切换带来的开销\n2. 自旋操作更加直观，无需分析什么情况下会导致线程阻塞\n\n#### 劣势：\n\n最大的问题就是由于需要一直循环检测锁的状态，因此会浪费CPU Cycles\n\n#### 适用场景：\n\n结合上述的优劣，自旋锁在锁的临界区很小并且锁争抢排队不是非常严重的情况下是非常合适的：\n\n1. 临界区小，因此每个使用锁的线程占用锁的时间不会很长，自旋等待的线程能够快速地获取到锁。\n2. 所争抢排队不严重，因此锁的自旋时间也是可控的，不会有大量线程处于自旋等待的状态中，从而增加浪费CPU Cycles。\n\n### 2. 自旋锁实现\n\n首先需要明确的一点是，对于加锁和释放锁的操作，需要是原子性的。这是能够继续讨论的基石。对于现代处理器，一般通过CAS(Compare And Set)操作来保证原子性。它的原理其实很简单，就是将“对比-设置”这一个流程原子化，保证在符合某种预期的前提下，完成一次写操作。\n\n对应到Java语言层面，就是那一大票的AtomicXXX类型。比如在下面的非公平自旋锁的实现中，会借助AtomicReference类型提供的CAS操作来完成加锁和释放锁的操作。\n\n#### 1. 简单的自旋锁\n\n直接上代码\n\n```java\npackage JUC.spinLock;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 19:38\n *      email  : 398757724@qq.com\n *      Desc   : 简单的自旋锁，哪个线程竞争到，\n *      则获取锁，有可能产生饥饿现象\n ***************************************/\npublic class SpinLock {\n\n    //维护当前拥有锁的线程\n    private AtomicReference<Thread> owner = new AtomicReference<>();\n\n\n    public void lock() {\n        Thread currentThread = Thread.currentThread();\n\n        // 如果锁未被占用，则设置当前线程为锁的拥有者\n        while (!owner.compareAndSet(null, currentThread)) {\n            // 自旋\n        }\n    }\n\n\n    public void unLock() {\n        Thread currentThread = Thread.currentThread();\n        // 只有锁的拥有者才能释放锁，其它的线程因为无法满足Compare，因此不会Set成功\n        owner.compareAndSet(currentThread, null);\n    }\n\n\n    //一下代码属于测试\n    //用于等待所有线程都已结束\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    //所有线程共享的变量，用于测试，如果加锁和释放锁是正确的操作\n    //则在操作此集合时不会产生ConcurrentModificationException\n    static List<String> list = new ArrayList<>();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final SpinLock lock = new SpinLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    \n    private static Runnable generateTask(final SpinLock lock, \n                                        final String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n这里的关键就是加锁和释放锁中的两个CAS操作：\n\n1. 加锁过程:将CAS操作置于一个while循环中，来实现自旋的语义。由于CAS操作成功与否是成功取决于它的boolean返回值，因此当CAS操作失败的情况下，while循环将不会退出，会一直尝试CAS操作直到成功为止，此即所谓的自旋(忙等待)。\n\n1. 释放锁过程:此时不需要循环操作，但是仍然会考虑到只有当前拥有锁的线程才有资格释放锁。这一点还是通过CAS操作来保证。\n\n这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。\n\n**运行结果**:\n\n```\nThread 0 Completed [0]\nThread 9 Completed [0, 9]\nThread 3 Completed [0, 9, 3]\nThread 8 Completed [0, 9, 3, 8]\nThread 4 Completed [0, 9, 3, 8, 4]\nThread 6 Completed [0, 9, 3, 8, 4, 6]\nThread 5 Completed [0, 9, 3, 8, 4, 6, 5]\nThread 7 Completed [0, 9, 3, 8, 4, 6, 5, 7]\nThread 1 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1]\nThread 2 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n[0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n```\n\n从上可以看出，加锁和释放锁正确的实现，和预期的也是一样的，这是一个非公平的自旋锁，不是按照先来先获取锁的方式实现。\n\n#####  缺点\n\n- CAS操作需要硬件的配合；\n- 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；\n- 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。\n\n#### 2.  Ticket Lock\n\nTicket Lock 是为了解决上面的公平性问题，类似于现实中银行柜台的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询。\n\n当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋。\n\n具体代码如下：\n\n```java\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:23\n *      email  : 398757724@qq.com\n *      Desc   : Ticket Lock 简单实现，\n *      此自旋锁保证了FIFI，不会产生饥饿现象\n ***************************************/\npublic class TicketLock {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n\n    public int lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n        return myTicketNum;\n    }\n\n\n    public void unLock(int myTicketNum) {\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n    \n    public static void main(String[] args) throws InterruptedException {\n        final TicketLock lock = new TicketLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n    \n    private static Runnable generateTask(final TicketLock lock, \n    \t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            int myTicketNum = lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock(myTicketNum);\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n加锁和释放锁两个操作的过程如下：\n\n1. 加锁过程。获取一个排队号，当排队号和当前的服务号不相等时自旋等待。\n2. 释放锁过程。当前正被服务的线程释放锁，计算下一个服务号并设置。\n\n这里的AtomicInteger是为了保证服务号和等待号的原子性\n\n运行结果如下\n\n```\nThread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n从运行结果可以看出，确实是按照FIFO的顺序来获取锁，实现了公平性。\n\n不过上面的代码有一个问题，在释放锁的时候需要外部传进来排队号，这样就会带来一个隐患，外部传进来的排队号是可以修改的，也就是线程A获取的排队号是5，但是释放锁的时候却传进来6。这样就有可能导致死锁等问题。下面这个是通过ThreadLocal来改进上面的代码\n\n```java\npublic class TicketLockImprove {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n    //用于保存当前\n    private ThreadLocal<Integer> threadLocalTicketNum = new ThreadLocal<>();\n\n\n    public void lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n        //设置当前线程持有的排队号\n        threadLocalTicketNum.set(myTicketNum);\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n\n    }\n\n\n    public void unLock() {\n        //获取当前线程持有的排队号\n        int myTicketNum = threadLocalTicketNum.get();\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLockImprove lock = new TicketLockImprove();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final TicketLockImprove lock, final String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n这里是通过ThreadLocal来保存每个线程的排队号，这样就不会出现排队号被私自修改问题。其他的和上面的代码一致。\n\n##### 缺点\n\n- Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。\n\n所以，需要有一种办法能够让执行线程不再在同一个共享变量上自旋，避免过高频率的缓存同步操作。下面介绍的CLH锁和MCS锁都是为了解决这个问题的。\n\nMCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。\n\nCLH的发明人是：Craig，Landin and Hagersten。\n\n### 3. MCS 锁\n\nMCS自旋锁是一种基于单向链表的高性能、公平的自旋锁，申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。\n\n先上实现代码，然后在分析重点：\n\n```\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:34\n *      email  : 398757724@qq.com\n *      Desc   : MCS Lock\n ***************************************/\npublic class MCSLock {\n\n    //MCS锁节点\n    public static class MCSNode {\n        //指向后继节点\n        volatile MCSNode next;\n\n        //默认是在等待锁\n        volatile boolean isBlock = true;\n    }\n\n    volatile MCSNode tail; //指向最后一个申请锁的MCSNode\n\n    // 原子更新器\n    private static final AtomicReferenceFieldUpdater<MCSLock, MCSNode> UPDATER\n            = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, \n            \t\t\t\t\t\t\t\t\t\t\tMCSNode.class, \"tail\");\n\n    //用于保存当前节点对应的MCSNode对象\n    ThreadLocal<MCSNode> currentThreadNode = new ThreadLocal<>();\n\n\n    public void lock() {\n\n        //获得当前线程对应的节点\n        MCSNode mcsNode = currentThreadNode.get();\n        if (mcsNode == null) {\n            //初始化节点对象\n            mcsNode = new MCSNode();\n            currentThreadNode.set(mcsNode);\n        }\n        //设置当前队列节点到队尾并获取前置节点\n        MCSNode predecsessor = UPDATER.getAndSet(this, mcsNode); // step 1\n\n        //如果前继节点不为空，则设置前置节点的后继为当前节点，并等待获取锁\n        if (predecsessor != null) {\n            predecsessor.next = mcsNode;  // step 2\n            // 当前线程处于等待状态时自旋(MCSNode的isBlock初始化为true)\n            // 等待前驱节点主动通知，即将isBlock设置为false，表示当前线程可以获取到锁\n            while (mcsNode.isBlock) {\n\n            }\n        } else {\n            // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞 - 表示已经加锁成功\n            mcsNode.isBlock = false;\n        }\n    }\n\n\n    public void unLock() {\n        MCSNode mcsNode = currentThreadNode.get();\n        // 当前线程对应存在节点并且\n        // 锁拥有者进行释放锁才有意义 - 当blocked为true时，表示此线程处于等待状态中，\n        //                          并没有获取到锁，因此没有权利释放锁\n        if (mcsNode == null && mcsNode.isBlock) {\n            return;\n        }\n\n        if (mcsNode.next == null) {\n            if (UPDATER.compareAndSet(this, mcsNode, null)) {\n                // compareAndSet返回true表示确实没有人排在自己后面\n                return;\n            } else {\n                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者\n                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完\n                while (mcsNode.next == null) {\n                }\n            }\n        }\n        // 通知后继节点可以获取锁\n        mcsNode.next.isBlock = false;\n\n        // 将当前节点从链表中断开，方便对当前节点进行GC\n        mcsNode.next = null;// for GC\n        //for GC\n        currentThreadNode.remove();\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final MCSLock lock = new MCSLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    private static Runnable generateTask(final MCSLock lock, \n    \t\t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n实现的代码量虽然不多，但是lock和unlock的设计思想还是有些微妙之处，想要实现正确也并不容易。\n\n需要把握的几个重点：\n\n1. MCS锁的节点对象需要有两个状态，next用来维护单向链表的结构，blocked用来表示节点的状态，true表示处于自旋中；false表示加锁成功\n2. MCS锁的节点状态blocked的改变是由其前驱节点触发改变的\n3. 加锁时会更新链表的末节点并完成链表结构的维护\n4. 释放锁的时候由于链表结构建立的时滞(getAndSet原子方法和链表建立整体而言并非原子性)，可能存在多线程的干扰，需要使用忙等待保证链表结构就绪\n\n### 4. CLH锁\n\n同MCS自旋锁一样，CLH也是一种基于单向链表(隐式创建)的高性能、公平的自旋锁，申请加锁的线程只需要在其前驱节点的本地变量上自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。\n\n实现代码\n\n```\npublic class CLHLock {\n\n    public static class CLHNode {\n        private boolean isLocked = true; // 默认状态为true - 即处于等待状态或者加锁成功(换言之，即此节点处于有效的一种状态)\n    }\n\n    @SuppressWarnings(\"unused\")\n    private volatile CLHNode tail;\n\n    //线程对应CLH节点映射\n    private ThreadLocal<CLHNode> currentThreadNode = new ThreadLocal<>();\n\n\n    /**\n     * CLH 锁获取\n     */\n    public void lock() {\n        CLHNode clhNode = currentThreadNode.get();\n        if (clhNode == null) {\n            clhNode = new CLHNode();\n            currentThreadNode.set(clhNode);\n        }\n        //通过这个操作完成隐式链表的维护，后继节点只需要在前驱节点的locked状态上自旋\n        CLHNode preNode = UPDATER.getAndSet(this, clhNode);\n        if (preNode != null) {  //已有线程占用了锁，进入自旋\n            while (preNode.isLocked) {  //自旋等待前驱节点状态变更 - unlock中进行变更\n\n                //这里这样写，或者isLocked加上voliate，则能观察到变量的变化\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 没有前驱节点表示可以直接获取到锁，由于默认获取锁状态为true，此时可以什么操作都不执行\n        // 能够执行到这里表示已经成功获取到了锁\n\n    }\n\n\n    /**\n     * CLH 锁释放\n     */\n    public void unLock() {\n        CLHNode clhNode = currentThreadNode.get();\n        //只有持有锁的线程才能释放\n        if (clhNode == null || !clhNode.isLocked) {\n            return;\n        }\n\n        //从映射关系中移除当前线程对应的节点\n        currentThreadNode.remove();\n\n        //如果队列里只有当前线程，则释放对当前线程的引用(for GC)\n        // 尝试将tail从currentThread变更为null，因此当tail不为currentThread时表示还有线程在等待加锁\n        if (!UPDATER.compareAndSet(this, clhNode, null)) {\n            //还有后续线程\n            clhNode.isLocked = false; //改变状态，让后续线程结束自旋\n        }\n    }\n\n\n    private static final AtomicReferenceFieldUpdater<CLHLock, CLHNode> UPDATER =\n            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, \"tail\");\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final CLHLock lock = new CLHLock();\n        List<String> list = new ArrayList<>();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final CLHLock lock, \n    \t\t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n            } catch (Exception e) {\n\n            }\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, list));\n//            System.out.println(String.format(\"Thread %s Completed \", taskId));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n实现的代码量相比MCS锁少了很多，也简洁了不少。\n\n需要把握的几个重点：\n\n1. CLH锁的节点对象只有一个isLocked属性，关于其含义前面已经详细讨论过\n2. CLH锁的节点属性isLocked的改变是由其自身触发的\n3. CLH锁是在前驱节点的isLocked属性上进行自旋\n\n众所周知，AbstractQueuedSynchronizer是Java并发包的基石之一，而CLH锁的原理和思想则是AbstractQueuedSynchronizer的基石之一。理解清楚CLH锁的原理和实现对后面学习和理解AbstractQueuedSynchronizer是非常必要的。\n\n在**Doug Lea 写的The java.util.concurrent Synchronizer Framework** 文章中有这么一句话 **CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。**其实只要实现了取消功能，那么超时就比较容易实现。为什么CLH更容易实现取消功能呢。首先在CLH各节点之间只有一条隐形的链表存在，而排队的节点是观察前面节点的信息来判断是否可以获取锁，因此在取消排队节点时，可以不影响前继节点，而对后继节点的影响也比较小，如果MCS自旋锁要取消，则需要前继节点改变后继节点，如果敲好此时前继节点正在拿到锁运行，那此时更改锁就不是那么容易的，而且链表有事单链表，因此更改起来更加麻烦。\n\n### 总结\n\n下面我们来比较一下MCS和CLH锁\n\n首先我们先补充一点知识SMP和NUMA架构\n\n* SMP(Symmetric Multi-Processor)：对称多处理器结构，指服务器中多个 CPU 对称工作，每个 CPU 访问内存地址所需时间相同。其主要特征是共享，包含对 CPU，内存，I/O 等进行共享。SMP 能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着 CPU 数量的增加，每个 CPU 都要访问相同的内存资源，可能导致内存访问冲突，可能会导致 CPU 资源的浪费。常用的 PC 机就属于这种。\n* NUMA(Non-Uniform Memory Access)：非一致存储访问，将 CPU 分为 CPU 模块，每个 CPU 模块由多个 CPU 组成，并且具有独立的本地内存、I/O 槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存 (系统内其它节点的内存) 的速度，这也是非一致存储访问的由来。NUMA 较好地解决 SMP 的扩展问题，当 CPU 数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。\n\nCLH 队列锁的优点是空间复杂度低（如果有 n 个线程，L 个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O（L+n），n 个线程有 n 个myNode，L 个锁有 L 个 tail），CLH 的一种变体被应用在了 JAVA 并发框架中 (AbstractQueuedSynchronizer.Node)。CLH 在 SMP 系统结构下该法是非常有效的。但在 NUMA 系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，一种解决 NUMA 系统结构的思路是 MCS 队列锁。\n\nMSC 与 CLH 最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:CLH 是在前趋结点的 locked 域上自旋等待，而 MCS 是在自己的结点的 locked 域上自旋等待。正因为如此，它解决了 CLH 在 NUMA 系统架构中获取 locked 域状态内存过远的问题。\n\n\n\n### 参考\n\n1. [简单的非公平自旋锁以及基于排队的公平自旋锁的实现](https://blog.csdn.net/dm_vincent/article/details/79677891)\n2. [CLH锁的原理和实现](https://blog.csdn.net/dm_vincent/article/details/79842501)\n3. [MCS锁的原理和实现](https://blog.csdn.net/dm_vincent/article/details/79783104)\n4. [面试必备之深入理解自旋锁](https://segmentfault.com/a/1190000015795906)\n5. [Java自旋锁、排队自旋锁、MCS锁、CLH锁](https://lawrence-zxc.github.io/2015/05/03/lock/)\n6. [CLH锁与MCS锁](https://blog.csdn.net/jackyechina/article/details/73199638)","source":"_posts/自旋锁.md","raw":"---\ntitle: 自旋锁\ntags:\n  - 操作系统\n  - 自旋锁\n  - JUC\ncategories:\n  - java\nauthor: zhangke\nabbrlink: 58330\ndate: 2018-12-14 11:27:00\n---\n---\n# 自旋锁\n\n### 概述\n\n1. 自旋锁是什么\n2. 自旋锁实现\n3. MCS自旋锁\n4. CLH自旋锁\n\n### 1. 自旋锁是什么\n\n自旋锁与**互斥量**(注意这里不是互斥锁)类似，用于多线程同步的一种锁。但他不是休眠使线程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。基本的实现是通过线程反复检查锁特定变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。\n\n自旋锁通常被作为底层原语用于实现其他类型的锁。根据它们所基于与的系统体系结构，可以通过使用测试并设置指令（CAS）有效的实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其它的事情，这也是自旋锁只能够持有一段时间的原因。\n\n有了这一层了解，自旋锁的优势和劣势，以及其适用场景也就一目了然了。\n<!-- more -->\n\n#### 优势：\n\n1. 没有线程阻塞，也就没有了线程上下文切换带来的开销\n2. 自旋操作更加直观，无需分析什么情况下会导致线程阻塞\n\n#### 劣势：\n\n最大的问题就是由于需要一直循环检测锁的状态，因此会浪费CPU Cycles\n\n#### 适用场景：\n\n结合上述的优劣，自旋锁在锁的临界区很小并且锁争抢排队不是非常严重的情况下是非常合适的：\n\n1. 临界区小，因此每个使用锁的线程占用锁的时间不会很长，自旋等待的线程能够快速地获取到锁。\n2. 所争抢排队不严重，因此锁的自旋时间也是可控的，不会有大量线程处于自旋等待的状态中，从而增加浪费CPU Cycles。\n\n### 2. 自旋锁实现\n\n首先需要明确的一点是，对于加锁和释放锁的操作，需要是原子性的。这是能够继续讨论的基石。对于现代处理器，一般通过CAS(Compare And Set)操作来保证原子性。它的原理其实很简单，就是将“对比-设置”这一个流程原子化，保证在符合某种预期的前提下，完成一次写操作。\n\n对应到Java语言层面，就是那一大票的AtomicXXX类型。比如在下面的非公平自旋锁的实现中，会借助AtomicReference类型提供的CAS操作来完成加锁和释放锁的操作。\n\n#### 1. 简单的自旋锁\n\n直接上代码\n\n```java\npackage JUC.spinLock;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 19:38\n *      email  : 398757724@qq.com\n *      Desc   : 简单的自旋锁，哪个线程竞争到，\n *      则获取锁，有可能产生饥饿现象\n ***************************************/\npublic class SpinLock {\n\n    //维护当前拥有锁的线程\n    private AtomicReference<Thread> owner = new AtomicReference<>();\n\n\n    public void lock() {\n        Thread currentThread = Thread.currentThread();\n\n        // 如果锁未被占用，则设置当前线程为锁的拥有者\n        while (!owner.compareAndSet(null, currentThread)) {\n            // 自旋\n        }\n    }\n\n\n    public void unLock() {\n        Thread currentThread = Thread.currentThread();\n        // 只有锁的拥有者才能释放锁，其它的线程因为无法满足Compare，因此不会Set成功\n        owner.compareAndSet(currentThread, null);\n    }\n\n\n    //一下代码属于测试\n    //用于等待所有线程都已结束\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    //所有线程共享的变量，用于测试，如果加锁和释放锁是正确的操作\n    //则在操作此集合时不会产生ConcurrentModificationException\n    static List<String> list = new ArrayList<>();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final SpinLock lock = new SpinLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    \n    private static Runnable generateTask(final SpinLock lock, \n                                        final String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n这里的关键就是加锁和释放锁中的两个CAS操作：\n\n1. 加锁过程:将CAS操作置于一个while循环中，来实现自旋的语义。由于CAS操作成功与否是成功取决于它的boolean返回值，因此当CAS操作失败的情况下，while循环将不会退出，会一直尝试CAS操作直到成功为止，此即所谓的自旋(忙等待)。\n\n1. 释放锁过程:此时不需要循环操作，但是仍然会考虑到只有当前拥有锁的线程才有资格释放锁。这一点还是通过CAS操作来保证。\n\n这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。\n\n**运行结果**:\n\n```\nThread 0 Completed [0]\nThread 9 Completed [0, 9]\nThread 3 Completed [0, 9, 3]\nThread 8 Completed [0, 9, 3, 8]\nThread 4 Completed [0, 9, 3, 8, 4]\nThread 6 Completed [0, 9, 3, 8, 4, 6]\nThread 5 Completed [0, 9, 3, 8, 4, 6, 5]\nThread 7 Completed [0, 9, 3, 8, 4, 6, 5, 7]\nThread 1 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1]\nThread 2 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n[0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n```\n\n从上可以看出，加锁和释放锁正确的实现，和预期的也是一样的，这是一个非公平的自旋锁，不是按照先来先获取锁的方式实现。\n\n#####  缺点\n\n- CAS操作需要硬件的配合；\n- 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；\n- 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。\n\n#### 2.  Ticket Lock\n\nTicket Lock 是为了解决上面的公平性问题，类似于现实中银行柜台的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询。\n\n当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋。\n\n具体代码如下：\n\n```java\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:23\n *      email  : 398757724@qq.com\n *      Desc   : Ticket Lock 简单实现，\n *      此自旋锁保证了FIFI，不会产生饥饿现象\n ***************************************/\npublic class TicketLock {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n\n    public int lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n        return myTicketNum;\n    }\n\n\n    public void unLock(int myTicketNum) {\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n    \n    public static void main(String[] args) throws InterruptedException {\n        final TicketLock lock = new TicketLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n    \n    private static Runnable generateTask(final TicketLock lock, \n    \t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            int myTicketNum = lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock(myTicketNum);\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n加锁和释放锁两个操作的过程如下：\n\n1. 加锁过程。获取一个排队号，当排队号和当前的服务号不相等时自旋等待。\n2. 释放锁过程。当前正被服务的线程释放锁，计算下一个服务号并设置。\n\n这里的AtomicInteger是为了保证服务号和等待号的原子性\n\n运行结果如下\n\n```\nThread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n从运行结果可以看出，确实是按照FIFO的顺序来获取锁，实现了公平性。\n\n不过上面的代码有一个问题，在释放锁的时候需要外部传进来排队号，这样就会带来一个隐患，外部传进来的排队号是可以修改的，也就是线程A获取的排队号是5，但是释放锁的时候却传进来6。这样就有可能导致死锁等问题。下面这个是通过ThreadLocal来改进上面的代码\n\n```java\npublic class TicketLockImprove {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n    //用于保存当前\n    private ThreadLocal<Integer> threadLocalTicketNum = new ThreadLocal<>();\n\n\n    public void lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n        //设置当前线程持有的排队号\n        threadLocalTicketNum.set(myTicketNum);\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n\n    }\n\n\n    public void unLock() {\n        //获取当前线程持有的排队号\n        int myTicketNum = threadLocalTicketNum.get();\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLockImprove lock = new TicketLockImprove();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final TicketLockImprove lock, final String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n这里是通过ThreadLocal来保存每个线程的排队号，这样就不会出现排队号被私自修改问题。其他的和上面的代码一致。\n\n##### 缺点\n\n- Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。\n\n所以，需要有一种办法能够让执行线程不再在同一个共享变量上自旋，避免过高频率的缓存同步操作。下面介绍的CLH锁和MCS锁都是为了解决这个问题的。\n\nMCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。\n\nCLH的发明人是：Craig，Landin and Hagersten。\n\n### 3. MCS 锁\n\nMCS自旋锁是一种基于单向链表的高性能、公平的自旋锁，申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。\n\n先上实现代码，然后在分析重点：\n\n```\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:34\n *      email  : 398757724@qq.com\n *      Desc   : MCS Lock\n ***************************************/\npublic class MCSLock {\n\n    //MCS锁节点\n    public static class MCSNode {\n        //指向后继节点\n        volatile MCSNode next;\n\n        //默认是在等待锁\n        volatile boolean isBlock = true;\n    }\n\n    volatile MCSNode tail; //指向最后一个申请锁的MCSNode\n\n    // 原子更新器\n    private static final AtomicReferenceFieldUpdater<MCSLock, MCSNode> UPDATER\n            = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, \n            \t\t\t\t\t\t\t\t\t\t\tMCSNode.class, \"tail\");\n\n    //用于保存当前节点对应的MCSNode对象\n    ThreadLocal<MCSNode> currentThreadNode = new ThreadLocal<>();\n\n\n    public void lock() {\n\n        //获得当前线程对应的节点\n        MCSNode mcsNode = currentThreadNode.get();\n        if (mcsNode == null) {\n            //初始化节点对象\n            mcsNode = new MCSNode();\n            currentThreadNode.set(mcsNode);\n        }\n        //设置当前队列节点到队尾并获取前置节点\n        MCSNode predecsessor = UPDATER.getAndSet(this, mcsNode); // step 1\n\n        //如果前继节点不为空，则设置前置节点的后继为当前节点，并等待获取锁\n        if (predecsessor != null) {\n            predecsessor.next = mcsNode;  // step 2\n            // 当前线程处于等待状态时自旋(MCSNode的isBlock初始化为true)\n            // 等待前驱节点主动通知，即将isBlock设置为false，表示当前线程可以获取到锁\n            while (mcsNode.isBlock) {\n\n            }\n        } else {\n            // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞 - 表示已经加锁成功\n            mcsNode.isBlock = false;\n        }\n    }\n\n\n    public void unLock() {\n        MCSNode mcsNode = currentThreadNode.get();\n        // 当前线程对应存在节点并且\n        // 锁拥有者进行释放锁才有意义 - 当blocked为true时，表示此线程处于等待状态中，\n        //                          并没有获取到锁，因此没有权利释放锁\n        if (mcsNode == null && mcsNode.isBlock) {\n            return;\n        }\n\n        if (mcsNode.next == null) {\n            if (UPDATER.compareAndSet(this, mcsNode, null)) {\n                // compareAndSet返回true表示确实没有人排在自己后面\n                return;\n            } else {\n                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者\n                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完\n                while (mcsNode.next == null) {\n                }\n            }\n        }\n        // 通知后继节点可以获取锁\n        mcsNode.next.isBlock = false;\n\n        // 将当前节点从链表中断开，方便对当前节点进行GC\n        mcsNode.next = null;// for GC\n        //for GC\n        currentThreadNode.remove();\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final MCSLock lock = new MCSLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    private static Runnable generateTask(final MCSLock lock, \n    \t\t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n实现的代码量虽然不多，但是lock和unlock的设计思想还是有些微妙之处，想要实现正确也并不容易。\n\n需要把握的几个重点：\n\n1. MCS锁的节点对象需要有两个状态，next用来维护单向链表的结构，blocked用来表示节点的状态，true表示处于自旋中；false表示加锁成功\n2. MCS锁的节点状态blocked的改变是由其前驱节点触发改变的\n3. 加锁时会更新链表的末节点并完成链表结构的维护\n4. 释放锁的时候由于链表结构建立的时滞(getAndSet原子方法和链表建立整体而言并非原子性)，可能存在多线程的干扰，需要使用忙等待保证链表结构就绪\n\n### 4. CLH锁\n\n同MCS自旋锁一样，CLH也是一种基于单向链表(隐式创建)的高性能、公平的自旋锁，申请加锁的线程只需要在其前驱节点的本地变量上自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。\n\n实现代码\n\n```\npublic class CLHLock {\n\n    public static class CLHNode {\n        private boolean isLocked = true; // 默认状态为true - 即处于等待状态或者加锁成功(换言之，即此节点处于有效的一种状态)\n    }\n\n    @SuppressWarnings(\"unused\")\n    private volatile CLHNode tail;\n\n    //线程对应CLH节点映射\n    private ThreadLocal<CLHNode> currentThreadNode = new ThreadLocal<>();\n\n\n    /**\n     * CLH 锁获取\n     */\n    public void lock() {\n        CLHNode clhNode = currentThreadNode.get();\n        if (clhNode == null) {\n            clhNode = new CLHNode();\n            currentThreadNode.set(clhNode);\n        }\n        //通过这个操作完成隐式链表的维护，后继节点只需要在前驱节点的locked状态上自旋\n        CLHNode preNode = UPDATER.getAndSet(this, clhNode);\n        if (preNode != null) {  //已有线程占用了锁，进入自旋\n            while (preNode.isLocked) {  //自旋等待前驱节点状态变更 - unlock中进行变更\n\n                //这里这样写，或者isLocked加上voliate，则能观察到变量的变化\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 没有前驱节点表示可以直接获取到锁，由于默认获取锁状态为true，此时可以什么操作都不执行\n        // 能够执行到这里表示已经成功获取到了锁\n\n    }\n\n\n    /**\n     * CLH 锁释放\n     */\n    public void unLock() {\n        CLHNode clhNode = currentThreadNode.get();\n        //只有持有锁的线程才能释放\n        if (clhNode == null || !clhNode.isLocked) {\n            return;\n        }\n\n        //从映射关系中移除当前线程对应的节点\n        currentThreadNode.remove();\n\n        //如果队列里只有当前线程，则释放对当前线程的引用(for GC)\n        // 尝试将tail从currentThread变更为null，因此当tail不为currentThread时表示还有线程在等待加锁\n        if (!UPDATER.compareAndSet(this, clhNode, null)) {\n            //还有后续线程\n            clhNode.isLocked = false; //改变状态，让后续线程结束自旋\n        }\n    }\n\n\n    private static final AtomicReferenceFieldUpdater<CLHLock, CLHNode> UPDATER =\n            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, \"tail\");\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final CLHLock lock = new CLHLock();\n        List<String> list = new ArrayList<>();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final CLHLock lock, \n    \t\t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n            } catch (Exception e) {\n\n            }\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, list));\n//            System.out.println(String.format(\"Thread %s Completed \", taskId));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n实现的代码量相比MCS锁少了很多，也简洁了不少。\n\n需要把握的几个重点：\n\n1. CLH锁的节点对象只有一个isLocked属性，关于其含义前面已经详细讨论过\n2. CLH锁的节点属性isLocked的改变是由其自身触发的\n3. CLH锁是在前驱节点的isLocked属性上进行自旋\n\n众所周知，AbstractQueuedSynchronizer是Java并发包的基石之一，而CLH锁的原理和思想则是AbstractQueuedSynchronizer的基石之一。理解清楚CLH锁的原理和实现对后面学习和理解AbstractQueuedSynchronizer是非常必要的。\n\n在**Doug Lea 写的The java.util.concurrent Synchronizer Framework** 文章中有这么一句话 **CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。**其实只要实现了取消功能，那么超时就比较容易实现。为什么CLH更容易实现取消功能呢。首先在CLH各节点之间只有一条隐形的链表存在，而排队的节点是观察前面节点的信息来判断是否可以获取锁，因此在取消排队节点时，可以不影响前继节点，而对后继节点的影响也比较小，如果MCS自旋锁要取消，则需要前继节点改变后继节点，如果敲好此时前继节点正在拿到锁运行，那此时更改锁就不是那么容易的，而且链表有事单链表，因此更改起来更加麻烦。\n\n### 总结\n\n下面我们来比较一下MCS和CLH锁\n\n首先我们先补充一点知识SMP和NUMA架构\n\n* SMP(Symmetric Multi-Processor)：对称多处理器结构，指服务器中多个 CPU 对称工作，每个 CPU 访问内存地址所需时间相同。其主要特征是共享，包含对 CPU，内存，I/O 等进行共享。SMP 能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着 CPU 数量的增加，每个 CPU 都要访问相同的内存资源，可能导致内存访问冲突，可能会导致 CPU 资源的浪费。常用的 PC 机就属于这种。\n* NUMA(Non-Uniform Memory Access)：非一致存储访问，将 CPU 分为 CPU 模块，每个 CPU 模块由多个 CPU 组成，并且具有独立的本地内存、I/O 槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存 (系统内其它节点的内存) 的速度，这也是非一致存储访问的由来。NUMA 较好地解决 SMP 的扩展问题，当 CPU 数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。\n\nCLH 队列锁的优点是空间复杂度低（如果有 n 个线程，L 个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O（L+n），n 个线程有 n 个myNode，L 个锁有 L 个 tail），CLH 的一种变体被应用在了 JAVA 并发框架中 (AbstractQueuedSynchronizer.Node)。CLH 在 SMP 系统结构下该法是非常有效的。但在 NUMA 系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，一种解决 NUMA 系统结构的思路是 MCS 队列锁。\n\nMSC 与 CLH 最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:CLH 是在前趋结点的 locked 域上自旋等待，而 MCS 是在自己的结点的 locked 域上自旋等待。正因为如此，它解决了 CLH 在 NUMA 系统架构中获取 locked 域状态内存过远的问题。\n\n\n\n### 参考\n\n1. [简单的非公平自旋锁以及基于排队的公平自旋锁的实现](https://blog.csdn.net/dm_vincent/article/details/79677891)\n2. [CLH锁的原理和实现](https://blog.csdn.net/dm_vincent/article/details/79842501)\n3. [MCS锁的原理和实现](https://blog.csdn.net/dm_vincent/article/details/79783104)\n4. [面试必备之深入理解自旋锁](https://segmentfault.com/a/1190000015795906)\n5. [Java自旋锁、排队自旋锁、MCS锁、CLH锁](https://lawrence-zxc.github.io/2015/05/03/lock/)\n6. [CLH锁与MCS锁](https://blog.csdn.net/jackyechina/article/details/73199638)","slug":"自旋锁","published":1,"updated":"2019-01-02T05:50:19.801Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhnxxah003deb1u2x3relsu","content":"<hr>\n<h1 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>自旋锁是什么</li>\n<li>自旋锁实现</li>\n<li>MCS自旋锁</li>\n<li>CLH自旋锁</li>\n</ol>\n<h3 id=\"1-自旋锁是什么\"><a href=\"#1-自旋锁是什么\" class=\"headerlink\" title=\"1. 自旋锁是什么\"></a>1. 自旋锁是什么</h3><p>自旋锁与<strong>互斥量</strong>(注意这里不是互斥锁)类似，用于多线程同步的一种锁。但他不是休眠使线程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。基本的实现是通过线程反复检查锁特定变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。</p>\n<p>自旋锁通常被作为底层原语用于实现其他类型的锁。根据它们所基于与的系统体系结构，可以通过使用测试并设置指令（CAS）有效的实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其它的事情，这也是自旋锁只能够持有一段时间的原因。</p>\n<p>有了这一层了解，自旋锁的优势和劣势，以及其适用场景也就一目了然了。<br><a id=\"more\"></a></p>\n<h4 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h4><ol>\n<li>没有线程阻塞，也就没有了线程上下文切换带来的开销</li>\n<li>自旋操作更加直观，无需分析什么情况下会导致线程阻塞</li>\n</ol>\n<h4 id=\"劣势：\"><a href=\"#劣势：\" class=\"headerlink\" title=\"劣势：\"></a>劣势：</h4><p>最大的问题就是由于需要一直循环检测锁的状态，因此会浪费CPU Cycles</p>\n<h4 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h4><p>结合上述的优劣，自旋锁在锁的临界区很小并且锁争抢排队不是非常严重的情况下是非常合适的：</p>\n<ol>\n<li>临界区小，因此每个使用锁的线程占用锁的时间不会很长，自旋等待的线程能够快速地获取到锁。</li>\n<li>所争抢排队不严重，因此锁的自旋时间也是可控的，不会有大量线程处于自旋等待的状态中，从而增加浪费CPU Cycles。</li>\n</ol>\n<h3 id=\"2-自旋锁实现\"><a href=\"#2-自旋锁实现\" class=\"headerlink\" title=\"2. 自旋锁实现\"></a>2. 自旋锁实现</h3><p>首先需要明确的一点是，对于加锁和释放锁的操作，需要是原子性的。这是能够继续讨论的基石。对于现代处理器，一般通过CAS(Compare And Set)操作来保证原子性。它的原理其实很简单，就是将“对比-设置”这一个流程原子化，保证在符合某种预期的前提下，完成一次写操作。</p>\n<p>对应到Java语言层面，就是那一大票的AtomicXXX类型。比如在下面的非公平自旋锁的实现中，会借助AtomicReference类型提供的CAS操作来完成加锁和释放锁的操作。</p>\n<h4 id=\"1-简单的自旋锁\"><a href=\"#1-简单的自旋锁\" class=\"headerlink\" title=\"1. 简单的自旋锁\"></a>1. 简单的自旋锁</h4><p>直接上代码</p>\n<pre><code class=\"java\">package JUC.spinLock;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 19:38\n *      email  : 398757724@qq.com\n *      Desc   : 简单的自旋锁，哪个线程竞争到，\n *      则获取锁，有可能产生饥饿现象\n ***************************************/\npublic class SpinLock {\n\n    //维护当前拥有锁的线程\n    private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;();\n\n\n    public void lock() {\n        Thread currentThread = Thread.currentThread();\n\n        // 如果锁未被占用，则设置当前线程为锁的拥有者\n        while (!owner.compareAndSet(null, currentThread)) {\n            // 自旋\n        }\n    }\n\n\n    public void unLock() {\n        Thread currentThread = Thread.currentThread();\n        // 只有锁的拥有者才能释放锁，其它的线程因为无法满足Compare，因此不会Set成功\n        owner.compareAndSet(currentThread, null);\n    }\n\n\n    //一下代码属于测试\n    //用于等待所有线程都已结束\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    //所有线程共享的变量，用于测试，如果加锁和释放锁是正确的操作\n    //则在操作此集合时不会产生ConcurrentModificationException\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final SpinLock lock = new SpinLock();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n\n    private static Runnable generateTask(final SpinLock lock, \n                                        final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n</code></pre>\n<p>这里的关键就是加锁和释放锁中的两个CAS操作：</p>\n<ol>\n<li><p>加锁过程:将CAS操作置于一个while循环中，来实现自旋的语义。由于CAS操作成功与否是成功取决于它的boolean返回值，因此当CAS操作失败的情况下，while循环将不会退出，会一直尝试CAS操作直到成功为止，此即所谓的自旋(忙等待)。</p>\n</li>\n<li><p>释放锁过程:此时不需要循环操作，但是仍然会考虑到只有当前拥有锁的线程才有资格释放锁。这一点还是通过CAS操作来保证。</p>\n</li>\n</ol>\n<p>这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。</p>\n<p><strong>运行结果</strong>:</p>\n<pre><code>Thread 0 Completed [0]\nThread 9 Completed [0, 9]\nThread 3 Completed [0, 9, 3]\nThread 8 Completed [0, 9, 3, 8]\nThread 4 Completed [0, 9, 3, 8, 4]\nThread 6 Completed [0, 9, 3, 8, 4, 6]\nThread 5 Completed [0, 9, 3, 8, 4, 6, 5]\nThread 7 Completed [0, 9, 3, 8, 4, 6, 5, 7]\nThread 1 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1]\nThread 2 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n[0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n</code></pre><p>从上可以看出，加锁和释放锁正确的实现，和预期的也是一样的，这是一个非公平的自旋锁，不是按照先来先获取锁的方式实现。</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>CAS操作需要硬件的配合；</li>\n<li>保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；</li>\n<li>没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。</li>\n</ul>\n<h4 id=\"2-Ticket-Lock\"><a href=\"#2-Ticket-Lock\" class=\"headerlink\" title=\"2.  Ticket Lock\"></a>2.  Ticket Lock</h4><p>Ticket Lock 是为了解决上面的公平性问题，类似于现实中银行柜台的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询。</p>\n<p>当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋。</p>\n<p>具体代码如下：</p>\n<pre><code class=\"java\">\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:23\n *      email  : 398757724@qq.com\n *      Desc   : Ticket Lock 简单实现，\n *      此自旋锁保证了FIFI，不会产生饥饿现象\n ***************************************/\npublic class TicketLock {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n\n    public int lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n        return myTicketNum;\n    }\n\n\n    public void unLock(int myTicketNum) {\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLock lock = new TicketLock();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n    private static Runnable generateTask(final TicketLock lock, \n            final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            int myTicketNum = lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock(myTicketNum);\n            countDownLatch.countDown();\n        };\n    }\n}\n</code></pre>\n<p>加锁和释放锁两个操作的过程如下：</p>\n<ol>\n<li>加锁过程。获取一个排队号，当排队号和当前的服务号不相等时自旋等待。</li>\n<li>释放锁过程。当前正被服务的线程释放锁，计算下一个服务号并设置。</li>\n</ol>\n<p>这里的AtomicInteger是为了保证服务号和等待号的原子性</p>\n<p>运行结果如下</p>\n<pre><code>Thread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre><p>从运行结果可以看出，确实是按照FIFO的顺序来获取锁，实现了公平性。</p>\n<p>不过上面的代码有一个问题，在释放锁的时候需要外部传进来排队号，这样就会带来一个隐患，外部传进来的排队号是可以修改的，也就是线程A获取的排队号是5，但是释放锁的时候却传进来6。这样就有可能导致死锁等问题。下面这个是通过ThreadLocal来改进上面的代码</p>\n<pre><code class=\"java\">public class TicketLockImprove {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n    //用于保存当前\n    private ThreadLocal&lt;Integer&gt; threadLocalTicketNum = new ThreadLocal&lt;&gt;();\n\n\n    public void lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n        //设置当前线程持有的排队号\n        threadLocalTicketNum.set(myTicketNum);\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n\n    }\n\n\n    public void unLock() {\n        //获取当前线程持有的排队号\n        int myTicketNum = threadLocalTicketNum.get();\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLockImprove lock = new TicketLockImprove();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final TicketLockImprove lock, final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n</code></pre>\n<p>这里是通过ThreadLocal来保存每个线程的排队号，这样就不会出现排队号被私自修改问题。其他的和上面的代码一致。</p>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</li>\n</ul>\n<p>所以，需要有一种办法能够让执行线程不再在同一个共享变量上自旋，避免过高频率的缓存同步操作。下面介绍的CLH锁和MCS锁都是为了解决这个问题的。</p>\n<p>MCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。</p>\n<p>CLH的发明人是：Craig，Landin and Hagersten。</p>\n<h3 id=\"3-MCS-锁\"><a href=\"#3-MCS-锁\" class=\"headerlink\" title=\"3. MCS 锁\"></a>3. MCS 锁</h3><p>MCS自旋锁是一种基于单向链表的高性能、公平的自旋锁，申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。</p>\n<p>先上实现代码，然后在分析重点：</p>\n<pre><code>/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:34\n *      email  : 398757724@qq.com\n *      Desc   : MCS Lock\n ***************************************/\npublic class MCSLock {\n\n    //MCS锁节点\n    public static class MCSNode {\n        //指向后继节点\n        volatile MCSNode next;\n\n        //默认是在等待锁\n        volatile boolean isBlock = true;\n    }\n\n    volatile MCSNode tail; //指向最后一个申请锁的MCSNode\n\n    // 原子更新器\n    private static final AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER\n            = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, \n                                                        MCSNode.class, &quot;tail&quot;);\n\n    //用于保存当前节点对应的MCSNode对象\n    ThreadLocal&lt;MCSNode&gt; currentThreadNode = new ThreadLocal&lt;&gt;();\n\n\n    public void lock() {\n\n        //获得当前线程对应的节点\n        MCSNode mcsNode = currentThreadNode.get();\n        if (mcsNode == null) {\n            //初始化节点对象\n            mcsNode = new MCSNode();\n            currentThreadNode.set(mcsNode);\n        }\n        //设置当前队列节点到队尾并获取前置节点\n        MCSNode predecsessor = UPDATER.getAndSet(this, mcsNode); // step 1\n\n        //如果前继节点不为空，则设置前置节点的后继为当前节点，并等待获取锁\n        if (predecsessor != null) {\n            predecsessor.next = mcsNode;  // step 2\n            // 当前线程处于等待状态时自旋(MCSNode的isBlock初始化为true)\n            // 等待前驱节点主动通知，即将isBlock设置为false，表示当前线程可以获取到锁\n            while (mcsNode.isBlock) {\n\n            }\n        } else {\n            // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞 - 表示已经加锁成功\n            mcsNode.isBlock = false;\n        }\n    }\n\n\n    public void unLock() {\n        MCSNode mcsNode = currentThreadNode.get();\n        // 当前线程对应存在节点并且\n        // 锁拥有者进行释放锁才有意义 - 当blocked为true时，表示此线程处于等待状态中，\n        //                          并没有获取到锁，因此没有权利释放锁\n        if (mcsNode == null &amp;&amp; mcsNode.isBlock) {\n            return;\n        }\n\n        if (mcsNode.next == null) {\n            if (UPDATER.compareAndSet(this, mcsNode, null)) {\n                // compareAndSet返回true表示确实没有人排在自己后面\n                return;\n            } else {\n                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者\n                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完\n                while (mcsNode.next == null) {\n                }\n            }\n        }\n        // 通知后继节点可以获取锁\n        mcsNode.next.isBlock = false;\n\n        // 将当前节点从链表中断开，方便对当前节点进行GC\n        mcsNode.next = null;// for GC\n        //for GC\n        currentThreadNode.remove();\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final MCSLock lock = new MCSLock();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    private static Runnable generateTask(final MCSLock lock, \n                        final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n</code></pre><p>实现的代码量虽然不多，但是lock和unlock的设计思想还是有些微妙之处，想要实现正确也并不容易。</p>\n<p>需要把握的几个重点：</p>\n<ol>\n<li>MCS锁的节点对象需要有两个状态，next用来维护单向链表的结构，blocked用来表示节点的状态，true表示处于自旋中；false表示加锁成功</li>\n<li>MCS锁的节点状态blocked的改变是由其前驱节点触发改变的</li>\n<li>加锁时会更新链表的末节点并完成链表结构的维护</li>\n<li>释放锁的时候由于链表结构建立的时滞(getAndSet原子方法和链表建立整体而言并非原子性)，可能存在多线程的干扰，需要使用忙等待保证链表结构就绪</li>\n</ol>\n<h3 id=\"4-CLH锁\"><a href=\"#4-CLH锁\" class=\"headerlink\" title=\"4. CLH锁\"></a>4. CLH锁</h3><p>同MCS自旋锁一样，CLH也是一种基于单向链表(隐式创建)的高性能、公平的自旋锁，申请加锁的线程只需要在其前驱节点的本地变量上自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。</p>\n<p>实现代码</p>\n<pre><code>public class CLHLock {\n\n    public static class CLHNode {\n        private boolean isLocked = true; // 默认状态为true - 即处于等待状态或者加锁成功(换言之，即此节点处于有效的一种状态)\n    }\n\n    @SuppressWarnings(&quot;unused&quot;)\n    private volatile CLHNode tail;\n\n    //线程对应CLH节点映射\n    private ThreadLocal&lt;CLHNode&gt; currentThreadNode = new ThreadLocal&lt;&gt;();\n\n\n    /**\n     * CLH 锁获取\n     */\n    public void lock() {\n        CLHNode clhNode = currentThreadNode.get();\n        if (clhNode == null) {\n            clhNode = new CLHNode();\n            currentThreadNode.set(clhNode);\n        }\n        //通过这个操作完成隐式链表的维护，后继节点只需要在前驱节点的locked状态上自旋\n        CLHNode preNode = UPDATER.getAndSet(this, clhNode);\n        if (preNode != null) {  //已有线程占用了锁，进入自旋\n            while (preNode.isLocked) {  //自旋等待前驱节点状态变更 - unlock中进行变更\n\n                //这里这样写，或者isLocked加上voliate，则能观察到变量的变化\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 没有前驱节点表示可以直接获取到锁，由于默认获取锁状态为true，此时可以什么操作都不执行\n        // 能够执行到这里表示已经成功获取到了锁\n\n    }\n\n\n    /**\n     * CLH 锁释放\n     */\n    public void unLock() {\n        CLHNode clhNode = currentThreadNode.get();\n        //只有持有锁的线程才能释放\n        if (clhNode == null || !clhNode.isLocked) {\n            return;\n        }\n\n        //从映射关系中移除当前线程对应的节点\n        currentThreadNode.remove();\n\n        //如果队列里只有当前线程，则释放对当前线程的引用(for GC)\n        // 尝试将tail从currentThread变更为null，因此当tail不为currentThread时表示还有线程在等待加锁\n        if (!UPDATER.compareAndSet(this, clhNode, null)) {\n            //还有后续线程\n            clhNode.isLocked = false; //改变状态，让后续线程结束自旋\n        }\n    }\n\n\n    private static final AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER =\n            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, &quot;tail&quot;);\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final CLHLock lock = new CLHLock();\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final CLHLock lock, \n                        final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n            } catch (Exception e) {\n\n            }\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, list));\n//            System.out.println(String.format(&quot;Thread %s Completed &quot;, taskId));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n</code></pre><p>实现的代码量相比MCS锁少了很多，也简洁了不少。</p>\n<p>需要把握的几个重点：</p>\n<ol>\n<li>CLH锁的节点对象只有一个isLocked属性，关于其含义前面已经详细讨论过</li>\n<li>CLH锁的节点属性isLocked的改变是由其自身触发的</li>\n<li>CLH锁是在前驱节点的isLocked属性上进行自旋</li>\n</ol>\n<p>众所周知，AbstractQueuedSynchronizer是Java并发包的基石之一，而CLH锁的原理和思想则是AbstractQueuedSynchronizer的基石之一。理解清楚CLH锁的原理和实现对后面学习和理解AbstractQueuedSynchronizer是非常必要的。</p>\n<p>在<strong>Doug Lea 写的The java.util.concurrent Synchronizer Framework</strong> 文章中有这么一句话 <strong>CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。</strong>其实只要实现了取消功能，那么超时就比较容易实现。为什么CLH更容易实现取消功能呢。首先在CLH各节点之间只有一条隐形的链表存在，而排队的节点是观察前面节点的信息来判断是否可以获取锁，因此在取消排队节点时，可以不影响前继节点，而对后继节点的影响也比较小，如果MCS自旋锁要取消，则需要前继节点改变后继节点，如果敲好此时前继节点正在拿到锁运行，那此时更改锁就不是那么容易的，而且链表有事单链表，因此更改起来更加麻烦。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>下面我们来比较一下MCS和CLH锁</p>\n<p>首先我们先补充一点知识SMP和NUMA架构</p>\n<ul>\n<li>SMP(Symmetric Multi-Processor)：对称多处理器结构，指服务器中多个 CPU 对称工作，每个 CPU 访问内存地址所需时间相同。其主要特征是共享，包含对 CPU，内存，I/O 等进行共享。SMP 能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着 CPU 数量的增加，每个 CPU 都要访问相同的内存资源，可能导致内存访问冲突，可能会导致 CPU 资源的浪费。常用的 PC 机就属于这种。</li>\n<li>NUMA(Non-Uniform Memory Access)：非一致存储访问，将 CPU 分为 CPU 模块，每个 CPU 模块由多个 CPU 组成，并且具有独立的本地内存、I/O 槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存 (系统内其它节点的内存) 的速度，这也是非一致存储访问的由来。NUMA 较好地解决 SMP 的扩展问题，当 CPU 数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。</li>\n</ul>\n<p>CLH 队列锁的优点是空间复杂度低（如果有 n 个线程，L 个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O（L+n），n 个线程有 n 个myNode，L 个锁有 L 个 tail），CLH 的一种变体被应用在了 JAVA 并发框架中 (AbstractQueuedSynchronizer.Node)。CLH 在 SMP 系统结构下该法是非常有效的。但在 NUMA 系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，一种解决 NUMA 系统结构的思路是 MCS 队列锁。</p>\n<p>MSC 与 CLH 最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:CLH 是在前趋结点的 locked 域上自旋等待，而 MCS 是在自己的结点的 locked 域上自旋等待。正因为如此，它解决了 CLH 在 NUMA 系统架构中获取 locked 域状态内存过远的问题。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79677891\" target=\"_blank\" rel=\"noopener\">简单的非公平自旋锁以及基于排队的公平自旋锁的实现</a></li>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79842501\" target=\"_blank\" rel=\"noopener\">CLH锁的原理和实现</a></li>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79783104\" target=\"_blank\" rel=\"noopener\">MCS锁的原理和实现</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015795906\" target=\"_blank\" rel=\"noopener\">面试必备之深入理解自旋锁</a></li>\n<li><a href=\"https://lawrence-zxc.github.io/2015/05/03/lock/\" target=\"_blank\" rel=\"noopener\">Java自旋锁、排队自旋锁、MCS锁、CLH锁</a></li>\n<li><a href=\"https://blog.csdn.net/jackyechina/article/details/73199638\" target=\"_blank\" rel=\"noopener\">CLH锁与MCS锁</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<hr>\n<h1 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>自旋锁是什么</li>\n<li>自旋锁实现</li>\n<li>MCS自旋锁</li>\n<li>CLH自旋锁</li>\n</ol>\n<h3 id=\"1-自旋锁是什么\"><a href=\"#1-自旋锁是什么\" class=\"headerlink\" title=\"1. 自旋锁是什么\"></a>1. 自旋锁是什么</h3><p>自旋锁与<strong>互斥量</strong>(注意这里不是互斥锁)类似，用于多线程同步的一种锁。但他不是休眠使线程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。基本的实现是通过线程反复检查锁特定变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。</p>\n<p>自旋锁通常被作为底层原语用于实现其他类型的锁。根据它们所基于与的系统体系结构，可以通过使用测试并设置指令（CAS）有效的实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其它的事情，这也是自旋锁只能够持有一段时间的原因。</p>\n<p>有了这一层了解，自旋锁的优势和劣势，以及其适用场景也就一目了然了。<br>","more":"</p>\n<h4 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h4><ol>\n<li>没有线程阻塞，也就没有了线程上下文切换带来的开销</li>\n<li>自旋操作更加直观，无需分析什么情况下会导致线程阻塞</li>\n</ol>\n<h4 id=\"劣势：\"><a href=\"#劣势：\" class=\"headerlink\" title=\"劣势：\"></a>劣势：</h4><p>最大的问题就是由于需要一直循环检测锁的状态，因此会浪费CPU Cycles</p>\n<h4 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h4><p>结合上述的优劣，自旋锁在锁的临界区很小并且锁争抢排队不是非常严重的情况下是非常合适的：</p>\n<ol>\n<li>临界区小，因此每个使用锁的线程占用锁的时间不会很长，自旋等待的线程能够快速地获取到锁。</li>\n<li>所争抢排队不严重，因此锁的自旋时间也是可控的，不会有大量线程处于自旋等待的状态中，从而增加浪费CPU Cycles。</li>\n</ol>\n<h3 id=\"2-自旋锁实现\"><a href=\"#2-自旋锁实现\" class=\"headerlink\" title=\"2. 自旋锁实现\"></a>2. 自旋锁实现</h3><p>首先需要明确的一点是，对于加锁和释放锁的操作，需要是原子性的。这是能够继续讨论的基石。对于现代处理器，一般通过CAS(Compare And Set)操作来保证原子性。它的原理其实很简单，就是将“对比-设置”这一个流程原子化，保证在符合某种预期的前提下，完成一次写操作。</p>\n<p>对应到Java语言层面，就是那一大票的AtomicXXX类型。比如在下面的非公平自旋锁的实现中，会借助AtomicReference类型提供的CAS操作来完成加锁和释放锁的操作。</p>\n<h4 id=\"1-简单的自旋锁\"><a href=\"#1-简单的自旋锁\" class=\"headerlink\" title=\"1. 简单的自旋锁\"></a>1. 简单的自旋锁</h4><p>直接上代码</p>\n<pre><code class=\"java\">package JUC.spinLock;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 19:38\n *      email  : 398757724@qq.com\n *      Desc   : 简单的自旋锁，哪个线程竞争到，\n *      则获取锁，有可能产生饥饿现象\n ***************************************/\npublic class SpinLock {\n\n    //维护当前拥有锁的线程\n    private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;();\n\n\n    public void lock() {\n        Thread currentThread = Thread.currentThread();\n\n        // 如果锁未被占用，则设置当前线程为锁的拥有者\n        while (!owner.compareAndSet(null, currentThread)) {\n            // 自旋\n        }\n    }\n\n\n    public void unLock() {\n        Thread currentThread = Thread.currentThread();\n        // 只有锁的拥有者才能释放锁，其它的线程因为无法满足Compare，因此不会Set成功\n        owner.compareAndSet(currentThread, null);\n    }\n\n\n    //一下代码属于测试\n    //用于等待所有线程都已结束\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    //所有线程共享的变量，用于测试，如果加锁和释放锁是正确的操作\n    //则在操作此集合时不会产生ConcurrentModificationException\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final SpinLock lock = new SpinLock();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n\n    private static Runnable generateTask(final SpinLock lock, \n                                        final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n</code></pre>\n<p>这里的关键就是加锁和释放锁中的两个CAS操作：</p>\n<ol>\n<li><p>加锁过程:将CAS操作置于一个while循环中，来实现自旋的语义。由于CAS操作成功与否是成功取决于它的boolean返回值，因此当CAS操作失败的情况下，while循环将不会退出，会一直尝试CAS操作直到成功为止，此即所谓的自旋(忙等待)。</p>\n</li>\n<li><p>释放锁过程:此时不需要循环操作，但是仍然会考虑到只有当前拥有锁的线程才有资格释放锁。这一点还是通过CAS操作来保证。</p>\n</li>\n</ol>\n<p>这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。</p>\n<p><strong>运行结果</strong>:</p>\n<pre><code>Thread 0 Completed [0]\nThread 9 Completed [0, 9]\nThread 3 Completed [0, 9, 3]\nThread 8 Completed [0, 9, 3, 8]\nThread 4 Completed [0, 9, 3, 8, 4]\nThread 6 Completed [0, 9, 3, 8, 4, 6]\nThread 5 Completed [0, 9, 3, 8, 4, 6, 5]\nThread 7 Completed [0, 9, 3, 8, 4, 6, 5, 7]\nThread 1 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1]\nThread 2 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n[0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n</code></pre><p>从上可以看出，加锁和释放锁正确的实现，和预期的也是一样的，这是一个非公平的自旋锁，不是按照先来先获取锁的方式实现。</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>CAS操作需要硬件的配合；</li>\n<li>保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；</li>\n<li>没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。</li>\n</ul>\n<h4 id=\"2-Ticket-Lock\"><a href=\"#2-Ticket-Lock\" class=\"headerlink\" title=\"2.  Ticket Lock\"></a>2.  Ticket Lock</h4><p>Ticket Lock 是为了解决上面的公平性问题，类似于现实中银行柜台的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询。</p>\n<p>当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋。</p>\n<p>具体代码如下：</p>\n<pre><code class=\"java\">\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:23\n *      email  : 398757724@qq.com\n *      Desc   : Ticket Lock 简单实现，\n *      此自旋锁保证了FIFI，不会产生饥饿现象\n ***************************************/\npublic class TicketLock {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n\n    public int lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n        return myTicketNum;\n    }\n\n\n    public void unLock(int myTicketNum) {\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLock lock = new TicketLock();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n    private static Runnable generateTask(final TicketLock lock, \n            final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            int myTicketNum = lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock(myTicketNum);\n            countDownLatch.countDown();\n        };\n    }\n}\n</code></pre>\n<p>加锁和释放锁两个操作的过程如下：</p>\n<ol>\n<li>加锁过程。获取一个排队号，当排队号和当前的服务号不相等时自旋等待。</li>\n<li>释放锁过程。当前正被服务的线程释放锁，计算下一个服务号并设置。</li>\n</ol>\n<p>这里的AtomicInteger是为了保证服务号和等待号的原子性</p>\n<p>运行结果如下</p>\n<pre><code>Thread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre><p>从运行结果可以看出，确实是按照FIFO的顺序来获取锁，实现了公平性。</p>\n<p>不过上面的代码有一个问题，在释放锁的时候需要外部传进来排队号，这样就会带来一个隐患，外部传进来的排队号是可以修改的，也就是线程A获取的排队号是5，但是释放锁的时候却传进来6。这样就有可能导致死锁等问题。下面这个是通过ThreadLocal来改进上面的代码</p>\n<pre><code class=\"java\">public class TicketLockImprove {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n    //用于保存当前\n    private ThreadLocal&lt;Integer&gt; threadLocalTicketNum = new ThreadLocal&lt;&gt;();\n\n\n    public void lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n        //设置当前线程持有的排队号\n        threadLocalTicketNum.set(myTicketNum);\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n\n    }\n\n\n    public void unLock() {\n        //获取当前线程持有的排队号\n        int myTicketNum = threadLocalTicketNum.get();\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLockImprove lock = new TicketLockImprove();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final TicketLockImprove lock, final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n</code></pre>\n<p>这里是通过ThreadLocal来保存每个线程的排队号，这样就不会出现排队号被私自修改问题。其他的和上面的代码一致。</p>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</li>\n</ul>\n<p>所以，需要有一种办法能够让执行线程不再在同一个共享变量上自旋，避免过高频率的缓存同步操作。下面介绍的CLH锁和MCS锁都是为了解决这个问题的。</p>\n<p>MCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。</p>\n<p>CLH的发明人是：Craig，Landin and Hagersten。</p>\n<h3 id=\"3-MCS-锁\"><a href=\"#3-MCS-锁\" class=\"headerlink\" title=\"3. MCS 锁\"></a>3. MCS 锁</h3><p>MCS自旋锁是一种基于单向链表的高性能、公平的自旋锁，申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。</p>\n<p>先上实现代码，然后在分析重点：</p>\n<pre><code>/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:34\n *      email  : 398757724@qq.com\n *      Desc   : MCS Lock\n ***************************************/\npublic class MCSLock {\n\n    //MCS锁节点\n    public static class MCSNode {\n        //指向后继节点\n        volatile MCSNode next;\n\n        //默认是在等待锁\n        volatile boolean isBlock = true;\n    }\n\n    volatile MCSNode tail; //指向最后一个申请锁的MCSNode\n\n    // 原子更新器\n    private static final AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER\n            = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, \n                                                        MCSNode.class, &quot;tail&quot;);\n\n    //用于保存当前节点对应的MCSNode对象\n    ThreadLocal&lt;MCSNode&gt; currentThreadNode = new ThreadLocal&lt;&gt;();\n\n\n    public void lock() {\n\n        //获得当前线程对应的节点\n        MCSNode mcsNode = currentThreadNode.get();\n        if (mcsNode == null) {\n            //初始化节点对象\n            mcsNode = new MCSNode();\n            currentThreadNode.set(mcsNode);\n        }\n        //设置当前队列节点到队尾并获取前置节点\n        MCSNode predecsessor = UPDATER.getAndSet(this, mcsNode); // step 1\n\n        //如果前继节点不为空，则设置前置节点的后继为当前节点，并等待获取锁\n        if (predecsessor != null) {\n            predecsessor.next = mcsNode;  // step 2\n            // 当前线程处于等待状态时自旋(MCSNode的isBlock初始化为true)\n            // 等待前驱节点主动通知，即将isBlock设置为false，表示当前线程可以获取到锁\n            while (mcsNode.isBlock) {\n\n            }\n        } else {\n            // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞 - 表示已经加锁成功\n            mcsNode.isBlock = false;\n        }\n    }\n\n\n    public void unLock() {\n        MCSNode mcsNode = currentThreadNode.get();\n        // 当前线程对应存在节点并且\n        // 锁拥有者进行释放锁才有意义 - 当blocked为true时，表示此线程处于等待状态中，\n        //                          并没有获取到锁，因此没有权利释放锁\n        if (mcsNode == null &amp;&amp; mcsNode.isBlock) {\n            return;\n        }\n\n        if (mcsNode.next == null) {\n            if (UPDATER.compareAndSet(this, mcsNode, null)) {\n                // compareAndSet返回true表示确实没有人排在自己后面\n                return;\n            } else {\n                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者\n                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完\n                while (mcsNode.next == null) {\n                }\n            }\n        }\n        // 通知后继节点可以获取锁\n        mcsNode.next.isBlock = false;\n\n        // 将当前节点从链表中断开，方便对当前节点进行GC\n        mcsNode.next = null;// for GC\n        //for GC\n        currentThreadNode.remove();\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final MCSLock lock = new MCSLock();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n\n    private static Runnable generateTask(final MCSLock lock, \n                        final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n</code></pre><p>实现的代码量虽然不多，但是lock和unlock的设计思想还是有些微妙之处，想要实现正确也并不容易。</p>\n<p>需要把握的几个重点：</p>\n<ol>\n<li>MCS锁的节点对象需要有两个状态，next用来维护单向链表的结构，blocked用来表示节点的状态，true表示处于自旋中；false表示加锁成功</li>\n<li>MCS锁的节点状态blocked的改变是由其前驱节点触发改变的</li>\n<li>加锁时会更新链表的末节点并完成链表结构的维护</li>\n<li>释放锁的时候由于链表结构建立的时滞(getAndSet原子方法和链表建立整体而言并非原子性)，可能存在多线程的干扰，需要使用忙等待保证链表结构就绪</li>\n</ol>\n<h3 id=\"4-CLH锁\"><a href=\"#4-CLH锁\" class=\"headerlink\" title=\"4. CLH锁\"></a>4. CLH锁</h3><p>同MCS自旋锁一样，CLH也是一种基于单向链表(隐式创建)的高性能、公平的自旋锁，申请加锁的线程只需要在其前驱节点的本地变量上自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。</p>\n<p>实现代码</p>\n<pre><code>public class CLHLock {\n\n    public static class CLHNode {\n        private boolean isLocked = true; // 默认状态为true - 即处于等待状态或者加锁成功(换言之，即此节点处于有效的一种状态)\n    }\n\n    @SuppressWarnings(&quot;unused&quot;)\n    private volatile CLHNode tail;\n\n    //线程对应CLH节点映射\n    private ThreadLocal&lt;CLHNode&gt; currentThreadNode = new ThreadLocal&lt;&gt;();\n\n\n    /**\n     * CLH 锁获取\n     */\n    public void lock() {\n        CLHNode clhNode = currentThreadNode.get();\n        if (clhNode == null) {\n            clhNode = new CLHNode();\n            currentThreadNode.set(clhNode);\n        }\n        //通过这个操作完成隐式链表的维护，后继节点只需要在前驱节点的locked状态上自旋\n        CLHNode preNode = UPDATER.getAndSet(this, clhNode);\n        if (preNode != null) {  //已有线程占用了锁，进入自旋\n            while (preNode.isLocked) {  //自旋等待前驱节点状态变更 - unlock中进行变更\n\n                //这里这样写，或者isLocked加上voliate，则能观察到变量的变化\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 没有前驱节点表示可以直接获取到锁，由于默认获取锁状态为true，此时可以什么操作都不执行\n        // 能够执行到这里表示已经成功获取到了锁\n\n    }\n\n\n    /**\n     * CLH 锁释放\n     */\n    public void unLock() {\n        CLHNode clhNode = currentThreadNode.get();\n        //只有持有锁的线程才能释放\n        if (clhNode == null || !clhNode.isLocked) {\n            return;\n        }\n\n        //从映射关系中移除当前线程对应的节点\n        currentThreadNode.remove();\n\n        //如果队列里只有当前线程，则释放对当前线程的引用(for GC)\n        // 尝试将tail从currentThread变更为null，因此当tail不为currentThread时表示还有线程在等待加锁\n        if (!UPDATER.compareAndSet(this, clhNode, null)) {\n            //还有后续线程\n            clhNode.isLocked = false; //改变状态，让后续线程结束自旋\n        }\n    }\n\n\n    private static final AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER =\n            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, &quot;tail&quot;);\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final CLHLock lock = new CLHLock();\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final CLHLock lock, \n                        final String taskId, final List&lt;String&gt; list) {\n        return () -&gt; {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n            } catch (Exception e) {\n\n            }\n            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, list));\n//            System.out.println(String.format(&quot;Thread %s Completed &quot;, taskId));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n</code></pre><p>实现的代码量相比MCS锁少了很多，也简洁了不少。</p>\n<p>需要把握的几个重点：</p>\n<ol>\n<li>CLH锁的节点对象只有一个isLocked属性，关于其含义前面已经详细讨论过</li>\n<li>CLH锁的节点属性isLocked的改变是由其自身触发的</li>\n<li>CLH锁是在前驱节点的isLocked属性上进行自旋</li>\n</ol>\n<p>众所周知，AbstractQueuedSynchronizer是Java并发包的基石之一，而CLH锁的原理和思想则是AbstractQueuedSynchronizer的基石之一。理解清楚CLH锁的原理和实现对后面学习和理解AbstractQueuedSynchronizer是非常必要的。</p>\n<p>在<strong>Doug Lea 写的The java.util.concurrent Synchronizer Framework</strong> 文章中有这么一句话 <strong>CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。</strong>其实只要实现了取消功能，那么超时就比较容易实现。为什么CLH更容易实现取消功能呢。首先在CLH各节点之间只有一条隐形的链表存在，而排队的节点是观察前面节点的信息来判断是否可以获取锁，因此在取消排队节点时，可以不影响前继节点，而对后继节点的影响也比较小，如果MCS自旋锁要取消，则需要前继节点改变后继节点，如果敲好此时前继节点正在拿到锁运行，那此时更改锁就不是那么容易的，而且链表有事单链表，因此更改起来更加麻烦。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>下面我们来比较一下MCS和CLH锁</p>\n<p>首先我们先补充一点知识SMP和NUMA架构</p>\n<ul>\n<li>SMP(Symmetric Multi-Processor)：对称多处理器结构，指服务器中多个 CPU 对称工作，每个 CPU 访问内存地址所需时间相同。其主要特征是共享，包含对 CPU，内存，I/O 等进行共享。SMP 能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着 CPU 数量的增加，每个 CPU 都要访问相同的内存资源，可能导致内存访问冲突，可能会导致 CPU 资源的浪费。常用的 PC 机就属于这种。</li>\n<li>NUMA(Non-Uniform Memory Access)：非一致存储访问，将 CPU 分为 CPU 模块，每个 CPU 模块由多个 CPU 组成，并且具有独立的本地内存、I/O 槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存 (系统内其它节点的内存) 的速度，这也是非一致存储访问的由来。NUMA 较好地解决 SMP 的扩展问题，当 CPU 数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。</li>\n</ul>\n<p>CLH 队列锁的优点是空间复杂度低（如果有 n 个线程，L 个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O（L+n），n 个线程有 n 个myNode，L 个锁有 L 个 tail），CLH 的一种变体被应用在了 JAVA 并发框架中 (AbstractQueuedSynchronizer.Node)。CLH 在 SMP 系统结构下该法是非常有效的。但在 NUMA 系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，一种解决 NUMA 系统结构的思路是 MCS 队列锁。</p>\n<p>MSC 与 CLH 最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:CLH 是在前趋结点的 locked 域上自旋等待，而 MCS 是在自己的结点的 locked 域上自旋等待。正因为如此，它解决了 CLH 在 NUMA 系统架构中获取 locked 域状态内存过远的问题。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79677891\" target=\"_blank\" rel=\"noopener\">简单的非公平自旋锁以及基于排队的公平自旋锁的实现</a></li>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79842501\" target=\"_blank\" rel=\"noopener\">CLH锁的原理和实现</a></li>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79783104\" target=\"_blank\" rel=\"noopener\">MCS锁的原理和实现</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015795906\" target=\"_blank\" rel=\"noopener\">面试必备之深入理解自旋锁</a></li>\n<li><a href=\"https://lawrence-zxc.github.io/2015/05/03/lock/\" target=\"_blank\" rel=\"noopener\">Java自旋锁、排队自旋锁、MCS锁、CLH锁</a></li>\n<li><a href=\"https://blog.csdn.net/jackyechina/article/details/73199638\" target=\"_blank\" rel=\"noopener\">CLH锁与MCS锁</a></li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjqhnxwtx0008eb1uartitfbx","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxwu9000eeb1u80ijbqid"},{"post_id":"cjqhnxwtj0000eb1udh29d65g","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxwub000heb1ue8yy5h9w"},{"post_id":"cjqhnxwty0009eb1u0fvx3uaj","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxwub000jeb1u7549ogjj"},{"post_id":"cjqhnxwtp0002eb1u2enxtjsg","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxwuc000neb1uyn3p9ofw"},{"post_id":"cjqhnxwtv0006eb1uxmbju8jc","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxwud000peb1uebfscac7"},{"post_id":"cjqhnxwu5000ceb1uhn3efimo","category_id":"cjqhnxwub000keb1uhwt61kec","_id":"cjqhnxwuf000teb1u9ga0rj9b"},{"post_id":"cjqhnxwu7000deb1uwrbqtfzc","category_id":"cjqhnxwud000qeb1ui8roqaax","_id":"cjqhnxwug000web1ucgip5mb1"},{"post_id":"cjqhnxx2c0012eb1uxr3gr88e","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx2o0017eb1ucoexawx7"},{"post_id":"cjqhnxx2g0013eb1ug9ly4372","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx2q001aeb1u5kxkhni9"},{"post_id":"cjqhnxx2m0015eb1uk13fqitb","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx2t001eeb1uj24a7j6u"},{"post_id":"cjqhnxx2o0016eb1u85n5h48v","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx2v001geb1u8os64yc4"},{"post_id":"cjqhnxx2p0019eb1unry36yac","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx2x001keb1u3yqkvyt3"},{"post_id":"cjqhnxx2r001deb1u684fat6q","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx2z001neb1uxh09u0uc"},{"post_id":"cjqhnxx2u001feb1uv8afof78","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx34001reb1u1kxnyq4a"},{"post_id":"cjqhnxx2w001jeb1uaq3x32b1","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx36001ueb1udzqt62fh"},{"post_id":"cjqhnxx2y001meb1u5kxf1oam","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx3a001xeb1uxswmgzmt"},{"post_id":"cjqhnxx30001qeb1u1x0d481h","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx3b001zeb1uvdowxsyn"},{"post_id":"cjqhnxx34001teb1uuol6hjty","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx3c0022eb1ua6gcmby8"},{"post_id":"cjqhnxx6d002meb1uykreokja","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx6t002seb1udzzexttd"},{"post_id":"cjqhnxx6i002neb1u0l72mwmo","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx6v002veb1ur73iyq9c"},{"post_id":"cjqhnxx6q002peb1u27f68izp","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx6y002zeb1uk8iqgrhv"},{"post_id":"cjqhnxx6s002reb1uaahjb14y","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx720032eb1uflzdzrmp"},{"post_id":"cjqhnxx6t002ueb1uznsiu1kw","category_id":"cjqhnxwud000qeb1ui8roqaax","_id":"cjqhnxx740035eb1ueup02r05"},{"post_id":"cjqhnxx6x002yeb1ugf1t9112","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx750037eb1ubjgyq5ie"},{"post_id":"cjqhnxx710031eb1upven2t7x","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxx750038eb1uxhgwcz82"},{"post_id":"cjqhnxxae003ceb1u10ndwv76","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxxba003heb1ue3d24ha2"},{"post_id":"cjqhnxxah003deb1u2x3relsu","category_id":"cjqhnxwtt0004eb1uq2ze45b3","_id":"cjqhnxxbb003ieb1ukisbjh3e"}],"PostTag":[{"post_id":"cjqhnxwtj0000eb1udh29d65g","tag_id":"cjqhnxwtv0005eb1ud1xa4qhb","_id":"cjqhnxwub000ieb1uzzr2qsgo"},{"post_id":"cjqhnxwtj0000eb1udh29d65g","tag_id":"cjqhnxwu0000beb1ufsvxivmn","_id":"cjqhnxwuc000leb1un765atuy"},{"post_id":"cjqhnxwtp0002eb1u2enxtjsg","tag_id":"cjqhnxwtv0005eb1ud1xa4qhb","_id":"cjqhnxwuc000oeb1uqgt6nyjd"},{"post_id":"cjqhnxwtv0006eb1uxmbju8jc","tag_id":"cjqhnxwuc000meb1utriy1uvb","_id":"cjqhnxwue000seb1upgiv2o0z"},{"post_id":"cjqhnxwtx0008eb1uartitfbx","tag_id":"cjqhnxwuc000meb1utriy1uvb","_id":"cjqhnxwug000veb1u9a5awe7d"},{"post_id":"cjqhnxwty0009eb1u0fvx3uaj","tag_id":"cjqhnxwuc000meb1utriy1uvb","_id":"cjqhnxwuh000yeb1uer5qobra"},{"post_id":"cjqhnxwu5000ceb1uhn3efimo","tag_id":"cjqhnxwug000xeb1uq3v35s1m","_id":"cjqhnxwuh0010eb1uc8b3q4a9"},{"post_id":"cjqhnxwu7000deb1uwrbqtfzc","tag_id":"cjqhnxwuh000zeb1uar5g1pcr","_id":"cjqhnxwuh0011eb1u7bkn4aom"},{"post_id":"cjqhnxx2m0015eb1uk13fqitb","tag_id":"cjqhnxwtv0005eb1ud1xa4qhb","_id":"cjqhnxx2p0018eb1uzut8bj71"},{"post_id":"cjqhnxx2o0016eb1u85n5h48v","tag_id":"cjqhnxwuc000meb1utriy1uvb","_id":"cjqhnxx2r001ceb1u9lap5qe4"},{"post_id":"cjqhnxx2r001deb1u684fat6q","tag_id":"cjqhnxwuc000meb1utriy1uvb","_id":"cjqhnxx2w001ieb1udpbgtx8p"},{"post_id":"cjqhnxx2u001feb1uv8afof78","tag_id":"cjqhnxwtv0005eb1ud1xa4qhb","_id":"cjqhnxx2y001leb1uawq7jj6f"},{"post_id":"cjqhnxx2u001feb1uv8afof78","tag_id":"cjqhnxwu0000beb1ufsvxivmn","_id":"cjqhnxx30001peb1uhpycpdfd"},{"post_id":"cjqhnxx2w001jeb1uaq3x32b1","tag_id":"cjqhnxwu0000beb1ufsvxivmn","_id":"cjqhnxx34001seb1u6eh9yq0p"},{"post_id":"cjqhnxx2w001jeb1uaq3x32b1","tag_id":"cjqhnxwtv0005eb1ud1xa4qhb","_id":"cjqhnxx39001web1uo0mkgmf0"},{"post_id":"cjqhnxx2c0012eb1uxr3gr88e","tag_id":"cjqhnxx2l0014eb1uobhrzog3","_id":"cjqhnxx3b001yeb1u0zwxtseh"},{"post_id":"cjqhnxx2c0012eb1uxr3gr88e","tag_id":"cjqhnxx2q001beb1ussxc4bux","_id":"cjqhnxx3b0021eb1uti68ffc3"},{"post_id":"cjqhnxx2c0012eb1uxr3gr88e","tag_id":"cjqhnxx2v001heb1u0d7fvboo","_id":"cjqhnxx3c0023eb1ufqkgfdzm"},{"post_id":"cjqhnxx2g0013eb1ug9ly4372","tag_id":"cjqhnxx2l0014eb1uobhrzog3","_id":"cjqhnxx3d0024eb1u6xivoivq"},{"post_id":"cjqhnxx2g0013eb1ug9ly4372","tag_id":"cjqhnxx2q001beb1ussxc4bux","_id":"cjqhnxx3d0026eb1u9q7sgyc9"},{"post_id":"cjqhnxx2p0019eb1unry36yac","tag_id":"cjqhnxx2l0014eb1uobhrzog3","_id":"cjqhnxx3e0028eb1uucvlkunh"},{"post_id":"cjqhnxx2p0019eb1unry36yac","tag_id":"cjqhnxx3b0020eb1u0s5d2mwd","_id":"cjqhnxx3f0029eb1u1sadry8d"},{"post_id":"cjqhnxx2p0019eb1unry36yac","tag_id":"cjqhnxx3d0025eb1u9bfromjn","_id":"cjqhnxx3f002beb1u2qhw5cro"},{"post_id":"cjqhnxx2y001meb1u5kxf1oam","tag_id":"cjqhnxx2l0014eb1uobhrzog3","_id":"cjqhnxx3g002ceb1ux88r4apt"},{"post_id":"cjqhnxx2y001meb1u5kxf1oam","tag_id":"cjqhnxx3e0027eb1u54w7v3c5","_id":"cjqhnxx3g002eeb1uwgb6ovnq"},{"post_id":"cjqhnxx30001qeb1u1x0d481h","tag_id":"cjqhnxx3b0020eb1u0s5d2mwd","_id":"cjqhnxx3h002feb1uv7i8cte4"},{"post_id":"cjqhnxx34001teb1uuol6hjty","tag_id":"cjqhnxx2l0014eb1uobhrzog3","_id":"cjqhnxx3k002ieb1u6w59tn48"},{"post_id":"cjqhnxx34001teb1uuol6hjty","tag_id":"cjqhnxx3g002deb1uqkikr75x","_id":"cjqhnxx3k002jeb1uhp2guh22"},{"post_id":"cjqhnxx34001teb1uuol6hjty","tag_id":"cjqhnxx3h002geb1uj7pb48vn","_id":"cjqhnxx3k002keb1upg0g27nv"},{"post_id":"cjqhnxx34001teb1uuol6hjty","tag_id":"cjqhnxx3j002heb1u6kclnda0","_id":"cjqhnxx3k002leb1umq1bhkw0"},{"post_id":"cjqhnxx6i002neb1u0l72mwmo","tag_id":"cjqhnxwuc000meb1utriy1uvb","_id":"cjqhnxx6s002qeb1u6k88d3ty"},{"post_id":"cjqhnxx6q002peb1u27f68izp","tag_id":"cjqhnxwuc000meb1utriy1uvb","_id":"cjqhnxx6t002teb1ude97klx3"},{"post_id":"cjqhnxx6s002reb1uaahjb14y","tag_id":"cjqhnxwuc000meb1utriy1uvb","_id":"cjqhnxx6x002xeb1urtt6ylu7"},{"post_id":"cjqhnxx6t002ueb1uznsiu1kw","tag_id":"cjqhnxwuh000zeb1uar5g1pcr","_id":"cjqhnxx710030eb1uropdt7bp"},{"post_id":"cjqhnxx6x002yeb1ugf1t9112","tag_id":"cjqhnxx3b0020eb1u0s5d2mwd","_id":"cjqhnxx730034eb1uoh3vt1ry"},{"post_id":"cjqhnxx710031eb1upven2t7x","tag_id":"cjqhnxx2l0014eb1uobhrzog3","_id":"cjqhnxx750036eb1uewi87k6t"},{"post_id":"cjqhnxx6d002meb1uykreokja","tag_id":"cjqhnxx6q002oeb1ueexw62d6","_id":"cjqhnxx760039eb1uhfm5ixmo"},{"post_id":"cjqhnxx6d002meb1uykreokja","tag_id":"cjqhnxx6v002web1uapfnuxso","_id":"cjqhnxx76003aeb1udiox5v4m"},{"post_id":"cjqhnxx6d002meb1uykreokja","tag_id":"cjqhnxx720033eb1u8bt5im73","_id":"cjqhnxx77003beb1u3o6zoo4e"},{"post_id":"cjqhnxxae003ceb1u10ndwv76","tag_id":"cjqhnxwtv0005eb1ud1xa4qhb","_id":"cjqhnxxar003eeb1ul2l71rkg"},{"post_id":"cjqhnxxae003ceb1u10ndwv76","tag_id":"cjqhnxwu0000beb1ufsvxivmn","_id":"cjqhnxxba003geb1u5jl7nr6h"},{"post_id":"cjqhnxxah003deb1u2x3relsu","tag_id":"cjqhnxwuh000zeb1uar5g1pcr","_id":"cjqhnxxbc003jeb1uxb1k7b8h"},{"post_id":"cjqhnxxah003deb1u2x3relsu","tag_id":"cjqhnxxba003feb1ufwj4bsps","_id":"cjqhnxxbc003keb1uymdve3dd"},{"post_id":"cjqhnxxah003deb1u2x3relsu","tag_id":"cjqhnxwtv0005eb1ud1xa4qhb","_id":"cjqhnxxbc003leb1uodt0kkcx"}],"Tag":[{"name":"JUC","_id":"cjqhnxwtv0005eb1ud1xa4qhb"},{"name":"线程池","_id":"cjqhnxwu0000beb1ufsvxivmn"},{"name":"多线程","_id":"cjqhnxwuc000meb1utriy1uvb"},{"name":"博客建站","_id":"cjqhnxwug000xeb1uq3v35s1m"},{"name":"操作系统","_id":"cjqhnxwuh000zeb1uar5g1pcr"},{"name":"java","_id":"cjqhnxx2l0014eb1uobhrzog3"},{"name":"java引用","_id":"cjqhnxx2q001beb1ussxc4bux"},{"name":"JVM","_id":"cjqhnxx2v001heb1u0d7fvboo"},{"name":"java基础","_id":"cjqhnxx3b0020eb1u0s5d2mwd"},{"name":"String","_id":"cjqhnxx3d0025eb1u9bfromjn"},{"name":"泛型","_id":"cjqhnxx3e0027eb1u54w7v3c5"},{"name":"并发","_id":"cjqhnxx3g002deb1uqkikr75x"},{"name":"线程","_id":"cjqhnxx3h002geb1uj7pb48vn"},{"name":"thread","_id":"cjqhnxx3j002heb1u6kclnda0"},{"name":"NIO","_id":"cjqhnxx6q002oeb1ueexw62d6"},{"name":"内存映射","_id":"cjqhnxx6v002web1uapfnuxso"},{"name":"直接内存","_id":"cjqhnxx720033eb1u8bt5im73"},{"name":"自旋锁","_id":"cjqhnxxba003feb1ufwj4bsps"}]}}