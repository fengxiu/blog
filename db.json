{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/uploads/img/avatar.jpg","path":"uploads/img/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"c3ddb78d56d8afb1de43766a962b58378cd300c2","modified":1545966351620},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1545966551750},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1545966551752},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1545966551752},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1545966551752},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1545966606782},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1545966551752},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1545966646627},{"_id":"themes/next/README.md","hash":"898213e66d34a46c3cf8446bf693bd50db0d3269","modified":1545966646628},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1545966551751},{"_id":"themes/next/_config.yml","hash":"827a5d9da717140b2e22eae0f3190c538691471f","modified":1545986082688},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1545966551750},{"_id":"themes/next/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1545973610843},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1545966606784},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1545966606795},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1545966551753},{"_id":"source/_discarded/hello-world.md","hash":"202a20f1ba49668b3709f06599583a8d017be807","modified":1545980330760},{"_id":"source/_posts/测试视频.md","hash":"7dac0e72398556690c1f694c6589b22e06111a78","modified":1546142325134},{"_id":"source/_posts/使用-Travis-CI-自动更新-GitHub-Pages.md","hash":"fe69649e89707b4803795d609d294feebc34fd92","modified":1545980842912},{"_id":"source/about/index.html","hash":"3da0683d9fac971c9072a727a6d6623b12890669","modified":1546407077770},{"_id":"source/categories/index.md","hash":"79cd584ef9d28b5afbd1836b345ab5648d6f7fed","modified":1545980134150},{"_id":"source/tags/index.md","hash":"de2c4bea11d42170dabebd5ecfc7551e86759c4b","modified":1545980134151},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1545966606785},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1545966606785},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1545966606785},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1545966606785},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1545966606786},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1545966606786},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1545966606787},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1545966606787},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1545966606786},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1545966606787},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1545966606786},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1545966606788},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1545966606789},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1545966606788},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1545966606794},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1545966606794},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1545966551770},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1545966606794},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1545966606795},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1545966551771},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1545966551771},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1545966606795},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1545966551772},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1545966551846},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1545966551846},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1545966551846},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1545966606787},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1545966606788},{"_id":"themes/next/languages/zh-Hans.yml","hash":"abd5fa390c921edeee4040efd67dcc44ed6611c9","modified":1545980134152},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551798},{"_id":"source/uploads/img/avatar.jpg","hash":"8f378705739f7611db358b2b61c7986c7223c2f8","modified":1545980134151},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1545966551756},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1545966551757},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1545966606790},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1545966606791},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1545966606791},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1545966606791},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1545966551759},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1545966551760},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1545966551760},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1545966551757},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1545966606789},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1545966606790},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1545966606790},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1545966606790},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1545966551758},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1545966551761},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1545966551761},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1545966606792},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1545966606794},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1545966551767},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1545966551767},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1545966551767},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1545966551768},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1545966551767},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1545966551767},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1545966606796},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1545966551772},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1545966551773},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1545966551773},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1545966551773},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1545966551773},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1545966551773},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1545966551773},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1545966551774},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1545966551798},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1545966551798},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1545966606805},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1545966551799},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1545966551799},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1545966551799},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1545966551800},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1545966606805},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1545966606805},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545966551801},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1545966606806},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545966551801},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1545966551801},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1545966551801},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1545966551801},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1545966551798},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1545966551800},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1545966551800},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1545966551801},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551762},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551762},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551789},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551789},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551790},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551797},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545966551797},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1545966551759},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1545966551759},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1545966551760},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1545966551760},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1545966551761},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1545966551761},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1545966551760},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1545966551760},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1545966606792},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1545966551761},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1545966606792},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1545966551763},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1545966551763},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1545966551763},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1545966551764},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1545966551764},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1545966606792},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1545966551764},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1545966606793},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1545966551765},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1545966551765},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1545966551765},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1545966551765},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1545966551765},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1545966551765},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1545966551766},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1545966606793},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1545966551766},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1545966606793},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1545966551766},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1545966551766},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1545966551768},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1545966551769},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1545966551769},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1545966551769},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1545966551788},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1545966551789},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1545966606803},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1545966551790},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1545966606804},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1545966606804},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1545966606804},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1545966606805},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1545966551802},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1545966551802},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1545966606806},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1545966551802},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1545966551803},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1545966551803},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1545966606806},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1545966606807},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1545966551804},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1545966551804},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1545966606807},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1545966551762},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1545966606793},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1545966551762},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1545966606808},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1545966551811},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1545966551812},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1545966551812},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1545966551818},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1545966551818},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1545966551819},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1545966551818},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1545966551820},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1545966551820},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1545966551832},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1545966551820},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1545966551820},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1545966551820},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1545966551833},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1545966551833},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1545966551833},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1545966551833},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1545966551834},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1545966551834},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1545966606809},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1545966606808},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1545966551835},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1545966551835},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1545966551835},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1545966551835},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1545966551835},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1545966551836},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1545966551836},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1545966551836},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1545966551836},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1545966551836},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1545966551836},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1545966551837},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1545966551834},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1545966551834},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1545966606809},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1545966551837},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1545966551838},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1545966551838},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1545966551842},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1545966551842},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1545966551845},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1545966551844},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1545966551845},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1545966551808},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1545966551833},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1545966551768},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1545966551768},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1545966606796},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1545966551774},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1545966606796},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1545966551774},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1545966551775},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1545966606797},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1545966551783},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1545966551787},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1545966551788},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1545966551788},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1545966551788},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1545966606803},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1545966551791},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1545966551791},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1545966551791},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1545966551792},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1545966606803},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1545966551792},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1545966551792},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1545966551793},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1545966551793},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1545966646628},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1545966551794},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1545966551795},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1545966551796},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1545966551796},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1545966551796},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1545966551796},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1545966606804},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1545966551796},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1545966606807},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1545966606802},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1545966551787},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1545966606802},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1545966551806},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1545966551813},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1545966551808},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1545966551807},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1545966551813},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1545966551814},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1545966551813},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1545966551814},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1545966551816},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1545966551814},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1545966551817},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1545966551817},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1545966551819},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1545966551819},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1545966551821},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1545966551822},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1545966551821},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1545966551842},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1545966551841},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1545966551807},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1545966551831},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1545966551844},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1545966551775},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1545966606796},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1545966551775},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1545966551775},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1545966551776},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1545966551776},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1545966551776},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1545966606797},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1545966551777},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1545966606797},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1545966551777},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1545966551777},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1545966551778},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1545966551778},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1545966606798},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1545966551778},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1545966551779},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1545966551779},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1545966606798},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1545966551779},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1545966606798},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1545966551780},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1545966606799},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1545966551780},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1545966551780},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1545966606799},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1545966551780},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1545966606799},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1545966606800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1545966606800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1545966551781},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1545966606800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1545966551782},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1545966551782},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1545966551782},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1545966606800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1545966551782},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1545966606801},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1545966551783},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1545966551783},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1545966551784},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1545966606801},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1545966551784},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1545966551784},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1545966606801},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1545966551785},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1545966551785},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1545966551785},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1545966551785},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1545966551785},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1545966551786},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1545966551786},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1545966606801},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1545966551786},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1545966551786},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1545966551786},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1545966606802},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1545966606802},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1545966551793},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1545966551793},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1545966551795},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1545966551805},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1545966551805},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1545966551805},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1545966606807},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1545966551806},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1545966551814},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1545966551815},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1545966551816},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1545966551816},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1545966551815},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1545966551816},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1545966551831},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1545966551830},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1545966551823},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1545966551825},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1545966551811},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1545966551841},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1545966551828},{"_id":"source/_drafts/测试视频.md","hash":"7dac0e72398556690c1f694c6589b22e06111a78","modified":1546406044192},{"_id":"source/_discarded/测试视频.md","hash":"7dac0e72398556690c1f694c6589b22e06111a78","modified":1546406045955},{"_id":"source/_drafts/String、StringBuffer和StringBuilder对比.md","hash":"f408885e1c0ffe5695d40b5b613f436a2c4e95dd","modified":1546406652063},{"_id":"source/_posts/String、StringBuffer和StringBuilder对比.md","hash":"c5a92ccda612ed6e0bd672f51dfd067bf055f5ad","modified":1546406758647},{"_id":"source/.DS_Store","hash":"9f7b4b6032924368072dfd27fe7cec91c4c08be2","modified":1546406467300},{"_id":"source/_posts/深入分析ThreadLocal.md","hash":"ed44507140a354073aa885a8c6ddc887e37c159e","modified":1546406786418},{"_id":"source/_discarded/String、StringBuffer和StringBuilder对比.md","hash":"1b11dc203cdda7a8b1683e485fde9c17a947447d","modified":1546406544430},{"_id":"source/_posts/.DS_Store","hash":"712350a80ef9fb11b59ac4ded928b87bb0fc84fd","modified":1546406602967},{"_id":"source/_posts/LockSupport.md","hash":"4c8dc4961a0b92694bbc3e6d3d2ac1e06af287c7","modified":1546406980987},{"_id":"source/_posts/Random 与 ThreadLocalRandom 对比.md","hash":"06b739ae5a9ffb135199ce554ae30ec3196ea0b0","modified":1546407009485},{"_id":"source/_posts/自旋锁.md","hash":"d3daf5c3b1bc05cc3db4cb55ca3c7e0f5b0ad933","modified":1546406939348},{"_id":"source/_posts/虚拟内存.md","hash":"ed94a08ed98c7b38ab14c7186c7b3379b8ae66f3","modified":1540882011309}],"Category":[{"name":"保存视频","_id":"cjqeq7wxn0004dq1uf8ovvh6o"},{"name":"其他","_id":"cjqeq7wxr0007dq1upkx5i2ao"},{"name":"java","_id":"cjqeqa3dk000fdq1uape9qpu5"}],"Data":[],"Page":[{"title":"简介","date":"2019-01-02T05:30:52.000Z","_content":"---\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    <strong>TODO<strong>\n</body>\n\n</html>","source":"about/index.html","raw":"title: 简介\ndate: 2019-01-02 13:30:52\n---\n---\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    <strong>TODO<strong>\n</body>\n\n</html>","updated":"2019-01-02T05:31:17.770Z","path":"about/index.html","_id":"cjqeq7wxj0001dq1ugo58t65r","comments":1,"layout":"page","content":"---\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    <strong>TODO<strong>\n</strong></strong></body>\n\n</html>","site":{"data":{}},"excerpt":"","more":"---\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n\n<body>\n    <strong>TODO<strong>\n</strong></strong></body>\n\n</html>"},{"title":"文章分类","date":"2018-12-28T06:31:10.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2018-12-28 14:31:10\ntype: \"categories\"\n---\n","updated":"2018-12-28T06:55:34.150Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjqeq7wxm0003dq1ugkkltn2r","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-12-28T06:30:54.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-12-28 14:30:54\ntype: \"tags\"\n---\n","updated":"2018-12-28T06:55:34.151Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjqeq7wxp0006dq1usrp1ft73","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"测试视频","author":"枫秀天涯","date":"2018-12-30T03:42:00.000Z","_content":"{% dplayer \"url=http://devtest.qiniudn.com/若能绽放光芒.mp4\" \"api=http://dplayer.daoapp.io\" \"pic=http://devtest.qiniudn.com/若能绽放光芒.png\" \"id=9E2E3368B56CDBB4\" \"loop=yes\" \"theme=#FADFA3\" \"autoplay=false\" \"token=tokendemo\" %}","source":"_discarded//测试视频.md","raw":"title: 测试视频\nauthor: 枫秀天涯\ntags:\n  - 视屏\ncategories:\n  - 保存视频\ndate: 2018-12-30 11:42:00\n---\n{% dplayer \"url=http://devtest.qiniudn.com/若能绽放光芒.mp4\" \"api=http://dplayer.daoapp.io\" \"pic=http://devtest.qiniudn.com/若能绽放光芒.png\" \"id=9E2E3368B56CDBB4\" \"loop=yes\" \"theme=#FADFA3\" \"autoplay=false\" \"token=tokendemo\" %}","slug":"测试视频","published":0,"updated":"2019-01-02T05:14:05.948Z","_id":"cjqeq7wxe0000dq1ubjamoxj0","comments":1,"layout":"post","photos":[],"link":"","content":"<div id=\"dplayer2\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer2\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"http://devtest.qiniudn.com/若能绽放光芒.mp4\",\"pic\":\"http://devtest.qiniudn.com/若能绽放光芒.png\"},\"danmaku\":{\"id\":\"9E2E3368B56CDBB4\",\"api\":\"http://dplayer.daoapp.io\",\"token\":\"tokendemo\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>","site":{"data":{}},"excerpt":"","more":"<div id=\"dplayer2\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer2\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"http://devtest.qiniudn.com/若能绽放光芒.mp4\",\"pic\":\"http://devtest.qiniudn.com/若能绽放光芒.png\"},\"danmaku\":{\"id\":\"9E2E3368B56CDBB4\",\"api\":\"http://dplayer.daoapp.io\",\"token\":\"tokendemo\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>"},{"title":"使用 Travis CI 自动更新 GitHub Pages","author":"枫秀天涯","date":"2018-12-28T06:59:00.000Z","_content":"此篇博客主要为记录学习使用\n在研究过程中主要参考如下俩篇文章\n1. [使用 Travis CI 自动更新 GitHub Pages](https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/)\n2. [在持续集成过程出现文件为空的错误解决](http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/)","source":"_posts/使用-Travis-CI-自动更新-GitHub-Pages.md","raw":"title: 使用 Travis CI 自动更新 GitHub Pages\nauthor: 枫秀天涯\ntags:\n  - 博客建站\ncategories:\n  - 其他\ndate: 2018-12-28 14:59:00\n---\n此篇博客主要为记录学习使用\n在研究过程中主要参考如下俩篇文章\n1. [使用 Travis CI 自动更新 GitHub Pages](https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/)\n2. [在持续集成过程出现文件为空的错误解决](http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/)","slug":"使用-Travis-CI-自动更新-GitHub-Pages","published":1,"updated":"2018-12-28T07:07:22.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqeq7wxk0002dq1u4gmeiox0","content":"<p>此篇博客主要为记录学习使用<br>在研究过程中主要参考如下俩篇文章</p>\n<ol>\n<li><a href=\"https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/\" target=\"_blank\" rel=\"noopener\">使用 Travis CI 自动更新 GitHub Pages</a></li>\n<li><a href=\"http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/\" target=\"_blank\" rel=\"noopener\">在持续集成过程出现文件为空的错误解决</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>此篇博客主要为记录学习使用<br>在研究过程中主要参考如下俩篇文章</p>\n<ol>\n<li><a href=\"https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/\" target=\"_blank\" rel=\"noopener\">使用 Travis CI 自动更新 GitHub Pages</a></li>\n<li><a href=\"http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/\" target=\"_blank\" rel=\"noopener\">在持续集成过程出现文件为空的错误解决</a></li>\n</ol>\n"},{"title":"String、StringBuffer和StringBuilder对比","author":"枫秀天涯","date":"2019-01-02T05:14:00.000Z","_content":"","source":"_discarded//String、StringBuffer和StringBuilder对比.md","raw":"title: String、StringBuffer和StringBuilder对比\nauthor: 枫秀天涯\ntags:\n  - java\n  - String\n  - java 基础\ncategories:\n  - java\ndate: 2019-01-02 13:14:00\n---\n","slug":"String、StringBuffer和StringBuilder对比","published":0,"updated":"2019-01-02T05:22:24.426Z","_id":"cjqeq9az9000ddq1upsmaxhdd","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"深入分析ThreadLocal","author":"zhangke","abbrlink":"400f00a6","date":"2018-09-12T02:28:00.000Z","_content":"###  概述\n>1. ThreadLocal是什么\n>2. 如何使用ThreadLocal\n>3. ThreadLocal源码分析\n>4. 总结\n\n### ThreadLocal 是什么\n>首先我们要明白一点，线程同步主要是为了完成线程间数据共享和同步，保持数据的完整性。而ThreadLocal正如他的名字一样是线程的本地变量，也就是线程所私有的。因此他和线程同步无关，（因为不存在线程之间共享变量的问题，就不需要使用同步机制）。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？\n<!-- more --->\n>\n>#### API是这样介绍它的：\n>\n>**This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).**\n>\n>#### 中文翻译\n>\n>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其`get` 或 `set`方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。`ThreadLocal`实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。正如这句话所说，spring 中的事务就使用了ThreadLocal来保证同一个线程中的所有操作使用的是同一个数据库连接。\n>\n>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。\n\n### 如何使用ThreadLocal\n\n>简单案例\n>\n>```JAVA\n>public class SeqCount {\n>\n>    private static ThreadLocal<Integer> seqCount = new ThreadLocal<Integer>(){\n>        // 实现initialValue()\n>        public Integer initialValue() {\n>            return 0;\n>        }\n>    };\n>\n>    public int nextSeq(){\n>        seqCount.set(seqCount.get() + 1);\n>\n>        return seqCount.get();\n>    }\n>\n>    public static void main(String[] args){\n>        SeqCount seqCount = new SeqCount();\n>\n>        SeqThread thread1 = new SeqThread(seqCount);\n>        SeqThread thread2 = new SeqThread(seqCount);\n>        SeqThread thread3 = new SeqThread(seqCount);\n>        SeqThread thread4 = new SeqThread(seqCount);\n>\n>        thread1.start();\n>        thread2.start();\n>        thread3.start();\n>        thread4.start();\n>    }\n>\n>    private static class SeqThread extends Thread{\n>        private SeqCount seqCount;\n>\n>        SeqThread(SeqCount seqCount){\n>            this.seqCount = seqCount;\n>        }\n>\n>        public void run() {\n>            for(int i = 0 ; i < 3 ; i++){\n>                System.out.println(Thread.currentThread().getName() + \" seqCount :\" + seqCount.nextSeq());\n>            }\n>        }\n>    }\n>}\n>```\n>\n>运行结果\n>\n>```\n>Thread-1 seqCount :1\n>Thread-0 seqCount :1\n>Thread-2 seqCount :1\n>Thread-3 seqCount :1\n>Thread-1 seqCount :2\n>Thread-0 seqCount :2\n>Thread-2 seqCount :2\n>Thread-3 seqCount :2\n>Thread-1 seqCount :3\n>Thread-0 seqCount :3\n>Thread-2 seqCount :3\n>Thread-3 seqCount :3\n>```\n>\n>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。\n>\n>**不过这里要注意一个问题，不要使用对象的引用来设置ThreadLocal的初始值，这样会导致线程共享此对象**\n>\n>就像下面这样写\n>\n>```java\n>    A a = new A();\n>    private static ThreadLocal<A> seqCount = new ThreadLocal<A>(){\n>        // 实现initialValue()\n>        public A initialValue() {\n>            return a;\n>        }\n>    };\n>\n>    class A{\n>        // ....\n>    }\n>```\n>\n>具体过程请参考：[对ThreadLocal实现原理的一点思考](http://www.jianshu.com/p/ee8c9dccc953)\n>\n>总结一般使用ThreadLocal的方式是：\n>\n>1. 设置ThreadLocal对象为静态内部私有属性\n>2. 使用initalValue方法进行初始化值的时候，不要使用引用对象，这样会造成线程间共享此对象，从而达不到线程私有变量的的效果。\n>\n>具体代码如下\n>\n>```java\n>private statis ThreadLocal<T> objectName = new  \n>    ThreadLocal(){\n>        private T initialValue() {\n>        \t\t//下面写法肯定有问题，主要是告诉你要声明一个对\n>        \t\t//象，而不是返回对象的引用\n>            return new T() ;\n>        }\n>}\n>```\n>\n>\n\n### ThreadLocal源码解析\n\n>ThreadLocal定义了四个方法：\n>\n>- get()：返回此线程局部变量的当前线程副本中的值。\n>- initialValue()：返回此线程局部变量的当前线程的“初始值”。\n>- remove()：移除此线程局部变量当前线程的值。\n>- set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。\n>\n>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。\n>\n>对于ThreadLocal需要注意的有两点：\n>\n>1. ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。\n>2. 是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。\n>\n>下图是Thread、ThreadLocal、ThreadLocalMap的关系\n>\n>![](http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg)\n>\n>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。\n>\n>### ThreadLocalMap\n>\n>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：\n>\n>```\n>       static class Entry extends WeakReference<ThreadLocal<?>> {\n>            /** The value associated with this ThreadLocal. */\n>            Object value;\n>\n>            Entry(ThreadLocal<?> k, Object v) {\n>                super(k);\n>                value = v;\n>            }\n>        }\n>```\n>\n>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：[Java 理论与实践: 用弱引用堵住内存泄漏](https://www.ibm.com/developerworks/cn/java/j-jtp11225/)）\n>\n>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal> key, Object value)方法。\n>\n>**set(ThreadLocal<?> key, Object value)**\n>\n>```\n>    private void set(ThreadLocal<?> key, Object value) {\n>\n>        ThreadLocal.ThreadLocalMap.Entry[] tab = table;\n>        int len = tab.length;\n>\n>        // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置\n>        int i = key.threadLocalHashCode & (len-1);\n>\n>        // 采用“线性探测法”，寻找合适位置\n>        for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];\n>            e != null;\n>            e = tab[i = nextIndex(i, len)]) {\n>\n>            ThreadLocal<?> k = e.get();\n>\n>            // key 存在，直接覆盖\n>            if (k == key) {\n>                e.value = value;\n>                return;\n>            }\n>\n>            // key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了\n>            if (k == null) {\n>                // 用新元素替换陈旧的元素\n>                replaceStaleEntry(key, value, i);\n>                return;\n>            }\n>        }\n>\n>        // ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个\n>        tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value);\n>\n>        int sz = ++size;\n>\n>        // cleanSomeSlots 清楚陈旧的Entry（key == null）\n>        // 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash\n>        if (!cleanSomeSlots(i, sz) && sz >= threshold)\n>            rehash();\n>    }\n>```\n>\n>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考[散列冲突处理系列博客](http://www.nowamagic.net/academy/detail/3008015)）。掌握了开放地址法该方法就一目了然了。\n>\n>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：\n>\n>```\n>private final int threadLocalHashCode = nextHashCode();\n>```\n>\n>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：\n>\n>```\n>    private static AtomicInteger nextHashCode = new AtomicInteger();\n>\n>    private static final int HASH_INCREMENT = 0x61c88647;\n>\n>    private static int nextHashCode() {\n>        return nextHashCode.getAndAdd(HASH_INCREMENT);\n>    }\n>```\n>\n>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。\n>\n>**getEntry()**\n>\n>```\n>        private Entry getEntry(ThreadLocal<?> key) {\n>            int i = key.threadLocalHashCode & (table.length - 1);\n>            Entry e = table[i];\n>            if (e != null && e.get() == key)\n>                return e;\n>            else\n>                return getEntryAfterMiss(key, i, e);\n>        }\n>```\n>\n>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：\n>\n>```\n>        private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n>            Entry[] tab = table;\n>            int len = tab.length;\n>\n>            while (e != null) {\n>                ThreadLocal<?> k = e.get();\n>                if (k == key)\n>                    return e;\n>                if (k == null)\n>                    expungeStaleEntry(i);\n>                else\n>                    i = nextIndex(i, len);\n>                e = tab[i];\n>            }\n>            return null;\n>        }\n>```\n>\n>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。\n>\n>### get()\n>\n>> 返回当前线程所对应的线程变量\n>\n>```\n>    public T get() {\n>        // 获取当前线程\n>        Thread t = Thread.currentThread();\n>\n>        // 获取当前线程的成员变量 threadLocal\n>        ThreadLocalMap map = getMap(t);\n>        if (map != null) {\n>            // 从当前线程的ThreadLocalMap获取相对应的Entry\n>            ThreadLocalMap.Entry e = map.getEntry(this);\n>            if (e != null) {\n>                @SuppressWarnings(\"unchecked\")\n>\n>                // 获取目标值        \n>                T result = (T)e.value;\n>                return result;\n>            }\n>        }\n>        return setInitialValue();\n>    }\n>```\n>\n>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。\n>\n>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：\n>\n>```\n>    ThreadLocalMap getMap(Thread t) {\n>        return t.threadLocals;\n>    }\n>```\n>\n>### set(T value)\n>\n>> 设置当前线程的线程局部变量的值。\n>\n>```\n>    public void set(T value) {\n>        Thread t = Thread.currentThread();\n>        ThreadLocalMap map = getMap(t);\n>        if (map != null)\n>            map.set(this, value);\n>        else\n>            createMap(t, value);\n>    }\n>```\n>\n>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：\n>\n>```\n>    void createMap(Thread t, T firstValue) {\n>        t.threadLocals = new ThreadLocalMap(this, firstValue);\n>    }\n>```\n>\n>### initialValue()\n>\n>> 返回该线程局部变量的初始值。\n>\n>``` JAVA\n>    protected T initialValue() {\n>        return null;\n>    }\n>```\n>\n>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。\n>\n>### remove()\n>\n>> 将当前线程局部变量的值删除。\n>\n>```java\n>public void remove() {\n>    ThreadLocalMap m =  getMap(Thread.currentThread());\n>    if (m != null)\n>        m.remove(this);\n>}\n>```\n>\n>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。\n>\n> \n\n### 总结\n\n>- ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。\n>- 每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。\n>- ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。\n>\n>这里有一个使用ThreadLocal的案例，可以好好看看，写的很好\n>\n>[透彻理解Spring事务设计思想之手写实现](https://www.jianshu.com/p/1becdc376f5d)\n\n### 参考\n\n1. [深入分析 ThreadLocal 内存泄漏问题](http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/)\n2.  [【死磕Java并发】—–深入分析ThreadLocal](http://cmsblogs.com/?p=2442)","source":"_posts/深入分析ThreadLocal.md","raw":"title: 深入分析ThreadLocal\nauthor: zhangke\nabbrlink: 400f00a6\ntags:\n  - java\n  - 并发\n  - 线程\n  - thread\ncategories:\n  - java\ndate: 2018-09-12 10:28:00\n---\n###  概述\n>1. ThreadLocal是什么\n>2. 如何使用ThreadLocal\n>3. ThreadLocal源码分析\n>4. 总结\n\n### ThreadLocal 是什么\n>首先我们要明白一点，线程同步主要是为了完成线程间数据共享和同步，保持数据的完整性。而ThreadLocal正如他的名字一样是线程的本地变量，也就是线程所私有的。因此他和线程同步无关，（因为不存在线程之间共享变量的问题，就不需要使用同步机制）。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？\n<!-- more --->\n>\n>#### API是这样介绍它的：\n>\n>**This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).**\n>\n>#### 中文翻译\n>\n>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其`get` 或 `set`方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。`ThreadLocal`实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。正如这句话所说，spring 中的事务就使用了ThreadLocal来保证同一个线程中的所有操作使用的是同一个数据库连接。\n>\n>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。\n\n### 如何使用ThreadLocal\n\n>简单案例\n>\n>```JAVA\n>public class SeqCount {\n>\n>    private static ThreadLocal<Integer> seqCount = new ThreadLocal<Integer>(){\n>        // 实现initialValue()\n>        public Integer initialValue() {\n>            return 0;\n>        }\n>    };\n>\n>    public int nextSeq(){\n>        seqCount.set(seqCount.get() + 1);\n>\n>        return seqCount.get();\n>    }\n>\n>    public static void main(String[] args){\n>        SeqCount seqCount = new SeqCount();\n>\n>        SeqThread thread1 = new SeqThread(seqCount);\n>        SeqThread thread2 = new SeqThread(seqCount);\n>        SeqThread thread3 = new SeqThread(seqCount);\n>        SeqThread thread4 = new SeqThread(seqCount);\n>\n>        thread1.start();\n>        thread2.start();\n>        thread3.start();\n>        thread4.start();\n>    }\n>\n>    private static class SeqThread extends Thread{\n>        private SeqCount seqCount;\n>\n>        SeqThread(SeqCount seqCount){\n>            this.seqCount = seqCount;\n>        }\n>\n>        public void run() {\n>            for(int i = 0 ; i < 3 ; i++){\n>                System.out.println(Thread.currentThread().getName() + \" seqCount :\" + seqCount.nextSeq());\n>            }\n>        }\n>    }\n>}\n>```\n>\n>运行结果\n>\n>```\n>Thread-1 seqCount :1\n>Thread-0 seqCount :1\n>Thread-2 seqCount :1\n>Thread-3 seqCount :1\n>Thread-1 seqCount :2\n>Thread-0 seqCount :2\n>Thread-2 seqCount :2\n>Thread-3 seqCount :2\n>Thread-1 seqCount :3\n>Thread-0 seqCount :3\n>Thread-2 seqCount :3\n>Thread-3 seqCount :3\n>```\n>\n>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。\n>\n>**不过这里要注意一个问题，不要使用对象的引用来设置ThreadLocal的初始值，这样会导致线程共享此对象**\n>\n>就像下面这样写\n>\n>```java\n>    A a = new A();\n>    private static ThreadLocal<A> seqCount = new ThreadLocal<A>(){\n>        // 实现initialValue()\n>        public A initialValue() {\n>            return a;\n>        }\n>    };\n>\n>    class A{\n>        // ....\n>    }\n>```\n>\n>具体过程请参考：[对ThreadLocal实现原理的一点思考](http://www.jianshu.com/p/ee8c9dccc953)\n>\n>总结一般使用ThreadLocal的方式是：\n>\n>1. 设置ThreadLocal对象为静态内部私有属性\n>2. 使用initalValue方法进行初始化值的时候，不要使用引用对象，这样会造成线程间共享此对象，从而达不到线程私有变量的的效果。\n>\n>具体代码如下\n>\n>```java\n>private statis ThreadLocal<T> objectName = new  \n>    ThreadLocal(){\n>        private T initialValue() {\n>        \t\t//下面写法肯定有问题，主要是告诉你要声明一个对\n>        \t\t//象，而不是返回对象的引用\n>            return new T() ;\n>        }\n>}\n>```\n>\n>\n\n### ThreadLocal源码解析\n\n>ThreadLocal定义了四个方法：\n>\n>- get()：返回此线程局部变量的当前线程副本中的值。\n>- initialValue()：返回此线程局部变量的当前线程的“初始值”。\n>- remove()：移除此线程局部变量当前线程的值。\n>- set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。\n>\n>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。\n>\n>对于ThreadLocal需要注意的有两点：\n>\n>1. ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。\n>2. 是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。\n>\n>下图是Thread、ThreadLocal、ThreadLocalMap的关系\n>\n>![](http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg)\n>\n>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。\n>\n>### ThreadLocalMap\n>\n>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：\n>\n>```\n>       static class Entry extends WeakReference<ThreadLocal<?>> {\n>            /** The value associated with this ThreadLocal. */\n>            Object value;\n>\n>            Entry(ThreadLocal<?> k, Object v) {\n>                super(k);\n>                value = v;\n>            }\n>        }\n>```\n>\n>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：[Java 理论与实践: 用弱引用堵住内存泄漏](https://www.ibm.com/developerworks/cn/java/j-jtp11225/)）\n>\n>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal> key, Object value)方法。\n>\n>**set(ThreadLocal<?> key, Object value)**\n>\n>```\n>    private void set(ThreadLocal<?> key, Object value) {\n>\n>        ThreadLocal.ThreadLocalMap.Entry[] tab = table;\n>        int len = tab.length;\n>\n>        // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置\n>        int i = key.threadLocalHashCode & (len-1);\n>\n>        // 采用“线性探测法”，寻找合适位置\n>        for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];\n>            e != null;\n>            e = tab[i = nextIndex(i, len)]) {\n>\n>            ThreadLocal<?> k = e.get();\n>\n>            // key 存在，直接覆盖\n>            if (k == key) {\n>                e.value = value;\n>                return;\n>            }\n>\n>            // key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了\n>            if (k == null) {\n>                // 用新元素替换陈旧的元素\n>                replaceStaleEntry(key, value, i);\n>                return;\n>            }\n>        }\n>\n>        // ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个\n>        tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value);\n>\n>        int sz = ++size;\n>\n>        // cleanSomeSlots 清楚陈旧的Entry（key == null）\n>        // 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash\n>        if (!cleanSomeSlots(i, sz) && sz >= threshold)\n>            rehash();\n>    }\n>```\n>\n>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考[散列冲突处理系列博客](http://www.nowamagic.net/academy/detail/3008015)）。掌握了开放地址法该方法就一目了然了。\n>\n>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：\n>\n>```\n>private final int threadLocalHashCode = nextHashCode();\n>```\n>\n>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：\n>\n>```\n>    private static AtomicInteger nextHashCode = new AtomicInteger();\n>\n>    private static final int HASH_INCREMENT = 0x61c88647;\n>\n>    private static int nextHashCode() {\n>        return nextHashCode.getAndAdd(HASH_INCREMENT);\n>    }\n>```\n>\n>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。\n>\n>**getEntry()**\n>\n>```\n>        private Entry getEntry(ThreadLocal<?> key) {\n>            int i = key.threadLocalHashCode & (table.length - 1);\n>            Entry e = table[i];\n>            if (e != null && e.get() == key)\n>                return e;\n>            else\n>                return getEntryAfterMiss(key, i, e);\n>        }\n>```\n>\n>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：\n>\n>```\n>        private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n>            Entry[] tab = table;\n>            int len = tab.length;\n>\n>            while (e != null) {\n>                ThreadLocal<?> k = e.get();\n>                if (k == key)\n>                    return e;\n>                if (k == null)\n>                    expungeStaleEntry(i);\n>                else\n>                    i = nextIndex(i, len);\n>                e = tab[i];\n>            }\n>            return null;\n>        }\n>```\n>\n>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。\n>\n>### get()\n>\n>> 返回当前线程所对应的线程变量\n>\n>```\n>    public T get() {\n>        // 获取当前线程\n>        Thread t = Thread.currentThread();\n>\n>        // 获取当前线程的成员变量 threadLocal\n>        ThreadLocalMap map = getMap(t);\n>        if (map != null) {\n>            // 从当前线程的ThreadLocalMap获取相对应的Entry\n>            ThreadLocalMap.Entry e = map.getEntry(this);\n>            if (e != null) {\n>                @SuppressWarnings(\"unchecked\")\n>\n>                // 获取目标值        \n>                T result = (T)e.value;\n>                return result;\n>            }\n>        }\n>        return setInitialValue();\n>    }\n>```\n>\n>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。\n>\n>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：\n>\n>```\n>    ThreadLocalMap getMap(Thread t) {\n>        return t.threadLocals;\n>    }\n>```\n>\n>### set(T value)\n>\n>> 设置当前线程的线程局部变量的值。\n>\n>```\n>    public void set(T value) {\n>        Thread t = Thread.currentThread();\n>        ThreadLocalMap map = getMap(t);\n>        if (map != null)\n>            map.set(this, value);\n>        else\n>            createMap(t, value);\n>    }\n>```\n>\n>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：\n>\n>```\n>    void createMap(Thread t, T firstValue) {\n>        t.threadLocals = new ThreadLocalMap(this, firstValue);\n>    }\n>```\n>\n>### initialValue()\n>\n>> 返回该线程局部变量的初始值。\n>\n>``` JAVA\n>    protected T initialValue() {\n>        return null;\n>    }\n>```\n>\n>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。\n>\n>### remove()\n>\n>> 将当前线程局部变量的值删除。\n>\n>```java\n>public void remove() {\n>    ThreadLocalMap m =  getMap(Thread.currentThread());\n>    if (m != null)\n>        m.remove(this);\n>}\n>```\n>\n>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。\n>\n> \n\n### 总结\n\n>- ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。\n>- 每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。\n>- ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。\n>\n>这里有一个使用ThreadLocal的案例，可以好好看看，写的很好\n>\n>[透彻理解Spring事务设计思想之手写实现](https://www.jianshu.com/p/1becdc376f5d)\n\n### 参考\n\n1. [深入分析 ThreadLocal 内存泄漏问题](http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/)\n2.  [【死磕Java并发】—–深入分析ThreadLocal](http://cmsblogs.com/?p=2442)","slug":"深入分析ThreadLocal","published":1,"updated":"2019-01-02T05:26:26.418Z","_id":"cjqeqhf2d000ndq1u36wra1c1","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<ol>\n<li>ThreadLocal是什么</li>\n<li>如何使用ThreadLocal</li>\n<li>ThreadLocal源码分析</li>\n<li>总结</li>\n</ol>\n</blockquote>\n<h3 id=\"ThreadLocal-是什么\"><a href=\"#ThreadLocal-是什么\" class=\"headerlink\" title=\"ThreadLocal 是什么\"></a>ThreadLocal 是什么</h3><blockquote>\n<p>首先我们要明白一点，线程同步主要是为了完成线程间数据共享和同步，保持数据的完整性。而ThreadLocal正如他的名字一样是线程的本地变量，也就是线程所私有的。因此他和线程同步无关，（因为不存在线程之间共享变量的问题，就不需要使用同步机制）。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？<br><a id=\"more\"></a></p>\n<h4 id=\"API是这样介绍它的：\"><a href=\"#API是这样介绍它的：\" class=\"headerlink\" title=\"API是这样介绍它的：\"></a>API是这样介绍它的：</h4><p><strong>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).</strong></p>\n<h4 id=\"中文翻译\"><a href=\"#中文翻译\" class=\"headerlink\" title=\"中文翻译\"></a>中文翻译</h4><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其<code>get</code> 或 <code>set</code>方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。<code>ThreadLocal</code>实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。正如这句话所说，spring 中的事务就使用了ThreadLocal来保证同一个线程中的所有操作使用的是同一个数据库连接。</p>\n<p>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。</p>\n</blockquote>\n<h3 id=\"如何使用ThreadLocal\"><a href=\"#如何使用ThreadLocal\" class=\"headerlink\" title=\"如何使用ThreadLocal\"></a>如何使用ThreadLocal</h3><blockquote>\n<p>简单案例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SeqCount</span> </span>&#123;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal&lt;Integer&gt; seqCount = <span class=\"keyword\">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class=\"line\">&gt;        <span class=\"comment\">// 实现initialValue()</span></span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    &#125;;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">nextSeq</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">&gt;        seqCount.set(seqCount.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        <span class=\"keyword\">return</span> seqCount.get();</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">&gt;        SeqCount seqCount = <span class=\"keyword\">new</span> SeqCount();</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        SeqThread thread1 = <span class=\"keyword\">new</span> SeqThread(seqCount);</span><br><span class=\"line\">&gt;        SeqThread thread2 = <span class=\"keyword\">new</span> SeqThread(seqCount);</span><br><span class=\"line\">&gt;        SeqThread thread3 = <span class=\"keyword\">new</span> SeqThread(seqCount);</span><br><span class=\"line\">&gt;        SeqThread thread4 = <span class=\"keyword\">new</span> SeqThread(seqCount);</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        thread1.start();</span><br><span class=\"line\">&gt;        thread2.start();</span><br><span class=\"line\">&gt;        thread3.start();</span><br><span class=\"line\">&gt;        thread4.start();</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SeqThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"keyword\">private</span> SeqCount seqCount;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        SeqThread(SeqCount seqCount)&#123;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">this</span>.seqCount = seqCount;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">3</span> ; i++)&#123;</span><br><span class=\"line\">&gt;                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" seqCount :\"</span> + seqCount.nextSeq());</span><br><span class=\"line\">&gt;            &#125;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>运行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;Thread-1 seqCount :1</span><br><span class=\"line\">&gt;Thread-0 seqCount :1</span><br><span class=\"line\">&gt;Thread-2 seqCount :1</span><br><span class=\"line\">&gt;Thread-3 seqCount :1</span><br><span class=\"line\">&gt;Thread-1 seqCount :2</span><br><span class=\"line\">&gt;Thread-0 seqCount :2</span><br><span class=\"line\">&gt;Thread-2 seqCount :2</span><br><span class=\"line\">&gt;Thread-3 seqCount :2</span><br><span class=\"line\">&gt;Thread-1 seqCount :3</span><br><span class=\"line\">&gt;Thread-0 seqCount :3</span><br><span class=\"line\">&gt;Thread-2 seqCount :3</span><br><span class=\"line\">&gt;Thread-3 seqCount :3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。</p>\n<p><strong>不过这里要注意一个问题，不要使用对象的引用来设置ThreadLocal的初始值，这样会导致线程共享此对象</strong></p>\n<p>就像下面这样写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">&gt;    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal&lt;A&gt; seqCount = <span class=\"keyword\">new</span> ThreadLocal&lt;A&gt;()&#123;</span><br><span class=\"line\">&gt;        <span class=\"comment\">// 实现initialValue()</span></span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">public</span> A <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    &#125;;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"comment\">// ....</span></span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>具体过程请参考：<a href=\"http://www.jianshu.com/p/ee8c9dccc953\" target=\"_blank\" rel=\"noopener\">对ThreadLocal实现原理的一点思考</a></p>\n<p>总结一般使用ThreadLocal的方式是：</p>\n<ol>\n<li>设置ThreadLocal对象为静态内部私有属性</li>\n<li>使用initalValue方法进行初始化值的时候，不要使用引用对象，这样会造成线程间共享此对象，从而达不到线程私有变量的的效果。</li>\n</ol>\n<p>具体代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;<span class=\"keyword\">private</span> statis ThreadLocal&lt;T&gt; objectName = <span class=\"keyword\">new</span>  </span><br><span class=\"line\">&gt;    ThreadLocal()&#123;</span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;        \t\t<span class=\"comment\">//下面写法肯定有问题，主要是告诉你要声明一个对</span></span><br><span class=\"line\">&gt;        \t\t<span class=\"comment\">//象，而不是返回对象的引用</span></span><br><span class=\"line\">&gt;            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> T() ;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n</blockquote>\n<h3 id=\"ThreadLocal源码解析\"><a href=\"#ThreadLocal源码解析\" class=\"headerlink\" title=\"ThreadLocal源码解析\"></a>ThreadLocal源码解析</h3><blockquote>\n<p>ThreadLocal定义了四个方法：</p>\n<ul>\n<li>get()：返回此线程局部变量的当前线程副本中的值。</li>\n<li>initialValue()：返回此线程局部变量的当前线程的“初始值”。</li>\n<li>remove()：移除此线程局部变量当前线程的值。</li>\n<li>set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。</li>\n</ul>\n<p>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</p>\n<p>对于ThreadLocal需要注意的有两点：</p>\n<ol>\n<li>ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。</li>\n<li>是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。</li>\n</ol>\n<p>下图是Thread、ThreadLocal、ThreadLocalMap的关系</p>\n<p><img src=\"http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg\" alt=\"\"></p>\n<p>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。</p>\n<h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><p>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;       static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">&gt;            /** The value associated with this ThreadLocal. */</span><br><span class=\"line\">&gt;            Object value;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">&gt;                super(k);</span><br><span class=\"line\">&gt;                value = v;</span><br><span class=\"line\">&gt;            &#125;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp11225/\" target=\"_blank\" rel=\"noopener\">Java 理论与实践: 用弱引用堵住内存泄漏</a>）</p>\n<p>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal&gt; key, Object value)方法。</p>\n<p><strong>set(ThreadLocal&lt;?&gt; key, Object value)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class=\"line\">&gt;        int len = tab.length;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置</span><br><span class=\"line\">&gt;        int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        // 采用“线性探测法”，寻找合适位置</span><br><span class=\"line\">&gt;        for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];</span><br><span class=\"line\">&gt;            e != null;</span><br><span class=\"line\">&gt;            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;            // key 存在，直接覆盖</span><br><span class=\"line\">&gt;            if (k == key) &#123;</span><br><span class=\"line\">&gt;                e.value = value;</span><br><span class=\"line\">&gt;                return;</span><br><span class=\"line\">&gt;            &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;            // key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了</span><br><span class=\"line\">&gt;            if (k == null) &#123;</span><br><span class=\"line\">&gt;                // 用新元素替换陈旧的元素</span><br><span class=\"line\">&gt;                replaceStaleEntry(key, value, i);</span><br><span class=\"line\">&gt;                return;</span><br><span class=\"line\">&gt;            &#125;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        // ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个</span><br><span class=\"line\">&gt;        tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        int sz = ++size;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        // cleanSomeSlots 清楚陈旧的Entry（key == null）</span><br><span class=\"line\">&gt;        // 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash</span><br><span class=\"line\">&gt;        if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class=\"line\">&gt;            rehash();</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考<a href=\"http://www.nowamagic.net/academy/detail/3008015\" target=\"_blank\" rel=\"noopener\">散列冲突处理系列博客</a>）。掌握了开放地址法该方法就一目了然了。</p>\n<p>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;private final int threadLocalHashCode = nextHashCode();</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    private static AtomicInteger nextHashCode = new AtomicInteger();</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    private static final int HASH_INCREMENT = 0x61c88647;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    private static int nextHashCode() &#123;</span><br><span class=\"line\">&gt;        return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。</p>\n<p><strong>getEntry()</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;        private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class=\"line\">&gt;            int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class=\"line\">&gt;            Entry e = table[i];</span><br><span class=\"line\">&gt;            if (e != null &amp;&amp; e.get() == key)</span><br><span class=\"line\">&gt;                return e;</span><br><span class=\"line\">&gt;            else</span><br><span class=\"line\">&gt;                return getEntryAfterMiss(key, i, e);</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;        private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class=\"line\">&gt;            Entry[] tab = table;</span><br><span class=\"line\">&gt;            int len = tab.length;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;            while (e != null) &#123;</span><br><span class=\"line\">&gt;                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">&gt;                if (k == key)</span><br><span class=\"line\">&gt;                    return e;</span><br><span class=\"line\">&gt;                if (k == null)</span><br><span class=\"line\">&gt;                    expungeStaleEntry(i);</span><br><span class=\"line\">&gt;                else</span><br><span class=\"line\">&gt;                    i = nextIndex(i, len);</span><br><span class=\"line\">&gt;                e = tab[i];</span><br><span class=\"line\">&gt;            &#125;</span><br><span class=\"line\">&gt;            return null;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><blockquote>\n<p>返回当前线程所对应的线程变量</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    public T get() &#123;</span><br><span class=\"line\">&gt;        // 获取当前线程</span><br><span class=\"line\">&gt;        Thread t = Thread.currentThread();</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        // 获取当前线程的成员变量 threadLocal</span><br><span class=\"line\">&gt;        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">&gt;        if (map != null) &#123;</span><br><span class=\"line\">&gt;            // 从当前线程的ThreadLocalMap获取相对应的Entry</span><br><span class=\"line\">&gt;            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class=\"line\">&gt;            if (e != null) &#123;</span><br><span class=\"line\">&gt;                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;                // 获取目标值        </span><br><span class=\"line\">&gt;                T result = (T)e.value;</span><br><span class=\"line\">&gt;                return result;</span><br><span class=\"line\">&gt;            &#125;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;        return setInitialValue();</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。</p>\n<p>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    ThreadLocalMap getMap(Thread t) &#123;</span><br><span class=\"line\">&gt;        return t.threadLocals;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<h3 id=\"set-T-value\"><a href=\"#set-T-value\" class=\"headerlink\" title=\"set(T value)\"></a>set(T value)</h3><blockquote>\n<p>设置当前线程的线程局部变量的值。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    public void set(T value) &#123;</span><br><span class=\"line\">&gt;        Thread t = Thread.currentThread();</span><br><span class=\"line\">&gt;        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">&gt;        if (map != null)</span><br><span class=\"line\">&gt;            map.set(this, value);</span><br><span class=\"line\">&gt;        else</span><br><span class=\"line\">&gt;            createMap(t, value);</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    void createMap(Thread t, T firstValue) &#123;</span><br><span class=\"line\">&gt;        t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<h3 id=\"initialValue\"><a href=\"#initialValue\" class=\"headerlink\" title=\"initialValue()\"></a>initialValue()</h3><blockquote>\n<p>返回该线程局部变量的初始值。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    <span class=\"function\"><span class=\"keyword\">protected</span> T <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><blockquote>\n<p>将当前线程局部变量的值删除。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;    ThreadLocalMap m =  getMap(Thread.currentThread());</span><br><span class=\"line\">&gt;    <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">&gt;        m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&gt;&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<ul>\n<li>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。</li>\n<li>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</li>\n<li>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li>\n</ul>\n<p>这里有一个使用ThreadLocal的案例，可以好好看看，写的很好</p>\n<p><a href=\"https://www.jianshu.com/p/1becdc376f5d\" target=\"_blank\" rel=\"noopener\">透彻理解Spring事务设计思想之手写实现</a></p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/\" target=\"_blank\" rel=\"noopener\">深入分析 ThreadLocal 内存泄漏问题</a></li>\n<li><a href=\"http://cmsblogs.com/?p=2442\" target=\"_blank\" rel=\"noopener\">【死磕Java并发】—–深入分析ThreadLocal</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<ol>\n<li>ThreadLocal是什么</li>\n<li>如何使用ThreadLocal</li>\n<li>ThreadLocal源码分析</li>\n<li>总结</li>\n</ol>\n</blockquote>\n<h3 id=\"ThreadLocal-是什么\"><a href=\"#ThreadLocal-是什么\" class=\"headerlink\" title=\"ThreadLocal 是什么\"></a>ThreadLocal 是什么</h3><blockquote>\n<p>首先我们要明白一点，线程同步主要是为了完成线程间数据共享和同步，保持数据的完整性。而ThreadLocal正如他的名字一样是线程的本地变量，也就是线程所私有的。因此他和线程同步无关，（因为不存在线程之间共享变量的问题，就不需要使用同步机制）。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。那么ThreadLocal到底是什么呢？<br>","more":"</p>\n<h4 id=\"API是这样介绍它的：\"><a href=\"#API是这样介绍它的：\" class=\"headerlink\" title=\"API是这样介绍它的：\"></a>API是这样介绍它的：</h4><p><strong>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID).</strong></p>\n<h4 id=\"中文翻译\"><a href=\"#中文翻译\" class=\"headerlink\" title=\"中文翻译\"></a>中文翻译</h4><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其<code>get</code> 或 <code>set</code>方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。<code>ThreadLocal</code>实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。正如这句话所说，spring 中的事务就使用了ThreadLocal来保证同一个线程中的所有操作使用的是同一个数据库连接。</p>\n<p>所以ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本，故而每个线程都可以独立地改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。</p>\n</blockquote>\n<h3 id=\"如何使用ThreadLocal\"><a href=\"#如何使用ThreadLocal\" class=\"headerlink\" title=\"如何使用ThreadLocal\"></a>如何使用ThreadLocal</h3><blockquote>\n<p>简单案例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SeqCount</span> </span>&#123;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal&lt;Integer&gt; seqCount = <span class=\"keyword\">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class=\"line\">&gt;        <span class=\"comment\">// 实现initialValue()</span></span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    &#125;;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">nextSeq</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">&gt;        seqCount.set(seqCount.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        <span class=\"keyword\">return</span> seqCount.get();</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">&gt;        SeqCount seqCount = <span class=\"keyword\">new</span> SeqCount();</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        SeqThread thread1 = <span class=\"keyword\">new</span> SeqThread(seqCount);</span><br><span class=\"line\">&gt;        SeqThread thread2 = <span class=\"keyword\">new</span> SeqThread(seqCount);</span><br><span class=\"line\">&gt;        SeqThread thread3 = <span class=\"keyword\">new</span> SeqThread(seqCount);</span><br><span class=\"line\">&gt;        SeqThread thread4 = <span class=\"keyword\">new</span> SeqThread(seqCount);</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        thread1.start();</span><br><span class=\"line\">&gt;        thread2.start();</span><br><span class=\"line\">&gt;        thread3.start();</span><br><span class=\"line\">&gt;        thread4.start();</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SeqThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"keyword\">private</span> SeqCount seqCount;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        SeqThread(SeqCount seqCount)&#123;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">this</span>.seqCount = seqCount;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">3</span> ; i++)&#123;</span><br><span class=\"line\">&gt;                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" seqCount :\"</span> + seqCount.nextSeq());</span><br><span class=\"line\">&gt;            &#125;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>运行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;Thread-1 seqCount :1</span><br><span class=\"line\">&gt;Thread-0 seqCount :1</span><br><span class=\"line\">&gt;Thread-2 seqCount :1</span><br><span class=\"line\">&gt;Thread-3 seqCount :1</span><br><span class=\"line\">&gt;Thread-1 seqCount :2</span><br><span class=\"line\">&gt;Thread-0 seqCount :2</span><br><span class=\"line\">&gt;Thread-2 seqCount :2</span><br><span class=\"line\">&gt;Thread-3 seqCount :2</span><br><span class=\"line\">&gt;Thread-1 seqCount :3</span><br><span class=\"line\">&gt;Thread-0 seqCount :3</span><br><span class=\"line\">&gt;Thread-2 seqCount :3</span><br><span class=\"line\">&gt;Thread-3 seqCount :3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>从运行结果可以看出，ThreadLocal确实是可以达到线程隔离机制，确保变量的安全性。</p>\n<p><strong>不过这里要注意一个问题，不要使用对象的引用来设置ThreadLocal的初始值，这样会导致线程共享此对象</strong></p>\n<p>就像下面这样写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">&gt;    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal&lt;A&gt; seqCount = <span class=\"keyword\">new</span> ThreadLocal&lt;A&gt;()&#123;</span><br><span class=\"line\">&gt;        <span class=\"comment\">// 实现initialValue()</span></span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">public</span> A <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;            <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    &#125;;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"comment\">// ....</span></span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>具体过程请参考：<a href=\"http://www.jianshu.com/p/ee8c9dccc953\" target=\"_blank\" rel=\"noopener\">对ThreadLocal实现原理的一点思考</a></p>\n<p>总结一般使用ThreadLocal的方式是：</p>\n<ol>\n<li>设置ThreadLocal对象为静态内部私有属性</li>\n<li>使用initalValue方法进行初始化值的时候，不要使用引用对象，这样会造成线程间共享此对象，从而达不到线程私有变量的的效果。</li>\n</ol>\n<p>具体代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;<span class=\"keyword\">private</span> statis ThreadLocal&lt;T&gt; objectName = <span class=\"keyword\">new</span>  </span><br><span class=\"line\">&gt;    ThreadLocal()&#123;</span><br><span class=\"line\">&gt;        <span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;        \t\t<span class=\"comment\">//下面写法肯定有问题，主要是告诉你要声明一个对</span></span><br><span class=\"line\">&gt;        \t\t<span class=\"comment\">//象，而不是返回对象的引用</span></span><br><span class=\"line\">&gt;            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> T() ;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n</blockquote>\n<h3 id=\"ThreadLocal源码解析\"><a href=\"#ThreadLocal源码解析\" class=\"headerlink\" title=\"ThreadLocal源码解析\"></a>ThreadLocal源码解析</h3><blockquote>\n<p>ThreadLocal定义了四个方法：</p>\n<ul>\n<li>get()：返回此线程局部变量的当前线程副本中的值。</li>\n<li>initialValue()：返回此线程局部变量的当前线程的“初始值”。</li>\n<li>remove()：移除此线程局部变量当前线程的值。</li>\n<li>set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值。</li>\n</ul>\n<p>除了这四个方法，ThreadLocal内部还有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</p>\n<p>对于ThreadLocal需要注意的有两点：</p>\n<ol>\n<li>ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值得key。</li>\n<li>是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中，有些小伙伴会弄错他们的关系。</li>\n</ol>\n<p>下图是Thread、ThreadLocal、ThreadLocalMap的关系</p>\n<p><img src=\"http://7xjtfr.com1.z0.glb.clouddn.com/threadlocal.jpg\" alt=\"\"></p>\n<p>ThreadLocal虽然解决了这个多线程变量的复杂问题，但是它的源码实现却是比较简单的。ThreadLocalMap是实现ThreadLocal的关键，我们先从它入手。</p>\n<h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><p>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;       static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">&gt;            /** The value associated with this ThreadLocal. */</span><br><span class=\"line\">&gt;            Object value;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">&gt;                super(k);</span><br><span class=\"line\">&gt;                value = v;</span><br><span class=\"line\">&gt;            &#125;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用（关于弱引用这里就不多说了，感兴趣的可以关注这篇博客：<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp11225/\" target=\"_blank\" rel=\"noopener\">Java 理论与实践: 用弱引用堵住内存泄漏</a>）</p>\n<p>ThreadLocalMap的源码稍微多了点，我们就看两个最核心的方法getEntry()、set(ThreadLocal&gt; key, Object value)方法。</p>\n<p><strong>set(ThreadLocal&lt;?&gt; key, Object value)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class=\"line\">&gt;        int len = tab.length;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置</span><br><span class=\"line\">&gt;        int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        // 采用“线性探测法”，寻找合适位置</span><br><span class=\"line\">&gt;        for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];</span><br><span class=\"line\">&gt;            e != null;</span><br><span class=\"line\">&gt;            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;            // key 存在，直接覆盖</span><br><span class=\"line\">&gt;            if (k == key) &#123;</span><br><span class=\"line\">&gt;                e.value = value;</span><br><span class=\"line\">&gt;                return;</span><br><span class=\"line\">&gt;            &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;            // key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了</span><br><span class=\"line\">&gt;            if (k == null) &#123;</span><br><span class=\"line\">&gt;                // 用新元素替换陈旧的元素</span><br><span class=\"line\">&gt;                replaceStaleEntry(key, value, i);</span><br><span class=\"line\">&gt;                return;</span><br><span class=\"line\">&gt;            &#125;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        // ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个</span><br><span class=\"line\">&gt;        tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        int sz = ++size;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        // cleanSomeSlots 清楚陈旧的Entry（key == null）</span><br><span class=\"line\">&gt;        // 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash</span><br><span class=\"line\">&gt;        if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class=\"line\">&gt;            rehash();</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>这个set()操作和我们在集合了解的put()方式有点儿不一样，虽然他们都是key-value结构，不同在于他们解决散列冲突的方式不同。集合Map的put()采用的是拉链法，而ThreadLocalMap的set()则是采用开放定址法（具体请参考<a href=\"http://www.nowamagic.net/academy/detail/3008015\" target=\"_blank\" rel=\"noopener\">散列冲突处理系列博客</a>）。掌握了开放地址法该方法就一目了然了。</p>\n<p>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;private final int threadLocalHashCode = nextHashCode();</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>从名字上面我们可以看出threadLocalHashCode应该是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    private static AtomicInteger nextHashCode = new AtomicInteger();</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    private static final int HASH_INCREMENT = 0x61c88647;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;    private static int nextHashCode() &#123;</span><br><span class=\"line\">&gt;        return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量，从nextHashCode就可以看出他们的定义。</p>\n<p><strong>getEntry()</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;        private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class=\"line\">&gt;            int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class=\"line\">&gt;            Entry e = table[i];</span><br><span class=\"line\">&gt;            if (e != null &amp;&amp; e.get() == key)</span><br><span class=\"line\">&gt;                return e;</span><br><span class=\"line\">&gt;            else</span><br><span class=\"line\">&gt;                return getEntryAfterMiss(key, i, e);</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;        private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class=\"line\">&gt;            Entry[] tab = table;</span><br><span class=\"line\">&gt;            int len = tab.length;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;            while (e != null) &#123;</span><br><span class=\"line\">&gt;                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">&gt;                if (k == key)</span><br><span class=\"line\">&gt;                    return e;</span><br><span class=\"line\">&gt;                if (k == null)</span><br><span class=\"line\">&gt;                    expungeStaleEntry(i);</span><br><span class=\"line\">&gt;                else</span><br><span class=\"line\">&gt;                    i = nextIndex(i, len);</span><br><span class=\"line\">&gt;                e = tab[i];</span><br><span class=\"line\">&gt;            &#125;</span><br><span class=\"line\">&gt;            return null;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><blockquote>\n<p>返回当前线程所对应的线程变量</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    public T get() &#123;</span><br><span class=\"line\">&gt;        // 获取当前线程</span><br><span class=\"line\">&gt;        Thread t = Thread.currentThread();</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;        // 获取当前线程的成员变量 threadLocal</span><br><span class=\"line\">&gt;        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">&gt;        if (map != null) &#123;</span><br><span class=\"line\">&gt;            // 从当前线程的ThreadLocalMap获取相对应的Entry</span><br><span class=\"line\">&gt;            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class=\"line\">&gt;            if (e != null) &#123;</span><br><span class=\"line\">&gt;                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;                // 获取目标值        </span><br><span class=\"line\">&gt;                T result = (T)e.value;</span><br><span class=\"line\">&gt;                return result;</span><br><span class=\"line\">&gt;            &#125;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;        return setInitialValue();</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。</p>\n<p>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    ThreadLocalMap getMap(Thread t) &#123;</span><br><span class=\"line\">&gt;        return t.threadLocals;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<h3 id=\"set-T-value\"><a href=\"#set-T-value\" class=\"headerlink\" title=\"set(T value)\"></a>set(T value)</h3><blockquote>\n<p>设置当前线程的线程局部变量的值。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    public void set(T value) &#123;</span><br><span class=\"line\">&gt;        Thread t = Thread.currentThread();</span><br><span class=\"line\">&gt;        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">&gt;        if (map != null)</span><br><span class=\"line\">&gt;            map.set(this, value);</span><br><span class=\"line\">&gt;        else</span><br><span class=\"line\">&gt;            createMap(t, value);</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    void createMap(Thread t, T firstValue) &#123;</span><br><span class=\"line\">&gt;        t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<h3 id=\"initialValue\"><a href=\"#initialValue\" class=\"headerlink\" title=\"initialValue()\"></a>initialValue()</h3><blockquote>\n<p>返回该线程局部变量的初始值。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;    <span class=\"function\"><span class=\"keyword\">protected</span> T <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。该方法不能显示调用，只有在第一次调用get()或者set()方法时才会被执行，并且仅执行1次。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><blockquote>\n<p>将当前线程局部变量的值删除。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&gt;    ThreadLocalMap m =  getMap(Thread.currentThread());</span><br><span class=\"line\">&gt;    <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">&gt;        m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&gt;&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<ul>\n<li>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。</li>\n<li>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</li>\n<li>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li>\n</ul>\n<p>这里有一个使用ThreadLocal的案例，可以好好看看，写的很好</p>\n<p><a href=\"https://www.jianshu.com/p/1becdc376f5d\" target=\"_blank\" rel=\"noopener\">透彻理解Spring事务设计思想之手写实现</a></p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/\" target=\"_blank\" rel=\"noopener\">深入分析 ThreadLocal 内存泄漏问题</a></li>\n<li><a href=\"http://cmsblogs.com/?p=2442\" target=\"_blank\" rel=\"noopener\">【死磕Java并发】—–深入分析ThreadLocal</a></li>\n</ol>"},{"title":"String、StringBuffer和StringBuilder对比","author":"zhangke","date":"2019-01-02T05:24:00.000Z","_content":"---\n# String、StringBuffer和StringBuilder对比\n\n### 概述\n\n1. 简单介绍\n2. 性能对比\n3. 字符串常量池\n<!-- more -->\n\n### 1. 简单介绍\n\n这里只对这三个类做个简单的总结，如果你希望详细了解这三个类，可以看一下三篇文章，我觉得写得很好。\n\n1.  [String 详解(String系列之1)](https://www.cnblogs.com/skywang12345/p/string01.html)\n2.  [StringBuilder 详解 (String系列之2)](http://www.cnblogs.com/skywang12345/p/string02.html)\n3.  [StringBuffer 详解 (String系列之3)](http://www.cnblogs.com/skywang12345/p/string03.html)\n\n首先一个简单的对比\n\n**String 字符串常量**\n\n**StringBuffer 字符串变量（线程安全）**\n\n**StringBuilder 字符串变量（非线程安全）**\n\nStringBuffer与StringBuilder的实现几乎是一样的，只是StringBufferr为了保证线程安全，在方法前面加上Synchronize关键字来保证安全性，因此下面先用StringBuffer来和String进行对比\n\nString 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。\n 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：\n\n```java\n String S1 = “This is only a” + “ simple” + “ test”;\n StringBuffer Sb = new StringBuffer(“This is only a”).append(“ simple”).append(“ test”);\n```\n\n测试结果：\n\n```\n\nBenchmark                         Mode  Cnt   Score    Error  Units\nStringBenchmark.testString        avgt    3   5.701 ±  2.431  ns/op\nStringBenchmark.testStringBuffer  avgt    3  27.077 ± 21.828  ns/op\n```\n\n**其中score对应是每次操作花费的纳秒说**\n\n 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个\n**String S1 = “This is only a” + “ simple” + “test”; **其实就是：\n** String S1 = “This is only a simple test”**; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：\n\n```\nString S2 = “This is only a”;\nString S3 = “ simple”;\nString S4 = “ test”;\nString S1 = S2 +S3 + S4;\n```\n\n这时候 JVM 会规规矩矩的按照原来的方式去做\n在大部分情况下 StringBuffer的性能要好于 String\n**StringBuffer**\nJava.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。\n例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(\"le\") 会使字符串缓冲区包含“startle”，而 z.insert(4, \"le\") 将更改字符串缓冲区，使之包含“starlet”。\n在大部分情况下 StringBuilder > StringBuffer\n\n**StringBuilder**\njava.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。\n\n### 2. 性能对比\n\n测试性能源码(使用了JMH来进行基准测试)\n\n```\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 3)\n@Measurement(iterations = 3, time = 3)\n@Threads(1)\n@Fork(1)\n@State(Scope.Thread)\npublic class StringBenchmark {\n\n    String s1;\n\n    StringBuffer stringBuffer;\n\n    StringBuilder stringBuilder;\n\n\n    @Setup(Level.Iteration)\n    public void before() {\n        s1 = \"s1\";\n        stringBuffer = new StringBuffer(\"s1\");\n        stringBuilder = new StringBuilder(\"s1\");\n\n    }\n\n\n    @TearDown\n    public void after() {\n\n    }\n\n\n    @Benchmark\n    public String testStringAppend() {\n\n        return s1 += \"s2\";\n    }\n\n\n    @Benchmark\n    public StringBuffer testStringBufferAppend() {\n\n        return stringBuffer.append(\"s2\");\n\n    }\n\n\n    @Benchmark\n    public StringBuilder testStringBuilderAppend() {\n        //下面这个还会单独生成一个String对象，因此性能上有所损失，所以调整一下\n//        return new StringBuilder(\"s1\").append(\"s2\").toString();\n\n        return stringBuilder.append(\"s2\");\n    }\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(StringBenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n```\n\n测试结果\n\n```\nBenchmark                                Mode  Cnt      Score       Error  Units\nStringBenchmark.testStringAppend         avgt    3  28179.211 ± 25587.942  ns/op\nStringBenchmark.testStringBufferAppend   avgt    3     26.152 ±   189.157  ns/op\nStringBenchmark.testStringBuilderAppend  avgt    3     21.150 ±    48.648  ns/op\n```\n\n从结果可以验证，在上面简单介绍中所说的，如果字符串拼接操作，最好选择StringBuilder，如果要保证线程安全选择StringBuffer，另外上面结果有一点需要注意的是，从测试结果看，StringBuffer和StringBuilder的性能差不多，这是因为我是在jdk8上运行的，JVM在运行时，因为只有一个线程，因此对Synchronize做了优化，使得StringBuffer性能得到提升。\n\n### 3. 字符串常量池\n\n我觉得这篇文章已经写得非常好因此可以看这篇文章\n\n[String：字符串常量池](https://segmentfault.com/a/1190000009888357)\n\n但是我对这个持有疑问\n\n**String str2 = new String(\"ABC\") + \"ABC\" ; 会创建多少个对象?**\n\nstr2 ：\n字符串常量池：\"ABC\" : 1个\n堆：new String(\"ABC\") ：1个\n引用： str2 ：1个\n总共 ： 3个\n\n我认为结果是这样的：\n\n字符串常量池 “ABC” 1个\n\n堆：new String(\"ABC\"),new String(\"ABCABC\"),new StringBuilder()\n\nNew String(\"ABCABC\") 是由于new String(\"ABC\") +\"ABC\"在编译的时候会按照下面这种方式来生成\n\n```java\nStringBuilder  stringBuilder = new StringBuilder();\nstringBuilder.append(\"ABC\");\nstringBuilder.append(\"ABC);\nstringBuilder.toString();// 这时就会产生 new String(\"ABCABC)\n```\n\n另外由于这个是使用new String(\"ABC\") + \"ABC\"，因此ABCABC不会进入常量池，除非调用String.intern()方法\n\n不知道对不对，欢迎大家讨论\n\n### 参考\n\n1.  [String,StringBuffer与StringBuilder的区别|线程安全与线程不安全](https://www.cnblogs.com/xingzc/p/6277581.html)\n2. [字面量和常量池初探](https://mccxj.github.io/blog/20130615_java-string-constant-pool.html) 基于java1.6","source":"_posts/String、StringBuffer和StringBuilder对比.md","raw":"title: String、StringBuffer和StringBuilder对比\ntags:\n  - java\n  - java基础\n  - String\ncategories:\n  - java\nauthor: zhangke\ndate: 2019-01-02 13:24:00\n---\n---\n# String、StringBuffer和StringBuilder对比\n\n### 概述\n\n1. 简单介绍\n2. 性能对比\n3. 字符串常量池\n<!-- more -->\n\n### 1. 简单介绍\n\n这里只对这三个类做个简单的总结，如果你希望详细了解这三个类，可以看一下三篇文章，我觉得写得很好。\n\n1.  [String 详解(String系列之1)](https://www.cnblogs.com/skywang12345/p/string01.html)\n2.  [StringBuilder 详解 (String系列之2)](http://www.cnblogs.com/skywang12345/p/string02.html)\n3.  [StringBuffer 详解 (String系列之3)](http://www.cnblogs.com/skywang12345/p/string03.html)\n\n首先一个简单的对比\n\n**String 字符串常量**\n\n**StringBuffer 字符串变量（线程安全）**\n\n**StringBuilder 字符串变量（非线程安全）**\n\nStringBuffer与StringBuilder的实现几乎是一样的，只是StringBufferr为了保证线程安全，在方法前面加上Synchronize关键字来保证安全性，因此下面先用StringBuffer来和String进行对比\n\nString 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。\n 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：\n\n```java\n String S1 = “This is only a” + “ simple” + “ test”;\n StringBuffer Sb = new StringBuffer(“This is only a”).append(“ simple”).append(“ test”);\n```\n\n测试结果：\n\n```\n\nBenchmark                         Mode  Cnt   Score    Error  Units\nStringBenchmark.testString        avgt    3   5.701 ±  2.431  ns/op\nStringBenchmark.testStringBuffer  avgt    3  27.077 ± 21.828  ns/op\n```\n\n**其中score对应是每次操作花费的纳秒说**\n\n 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个\n**String S1 = “This is only a” + “ simple” + “test”; **其实就是：\n** String S1 = “This is only a simple test”**; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：\n\n```\nString S2 = “This is only a”;\nString S3 = “ simple”;\nString S4 = “ test”;\nString S1 = S2 +S3 + S4;\n```\n\n这时候 JVM 会规规矩矩的按照原来的方式去做\n在大部分情况下 StringBuffer的性能要好于 String\n**StringBuffer**\nJava.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。\n例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(\"le\") 会使字符串缓冲区包含“startle”，而 z.insert(4, \"le\") 将更改字符串缓冲区，使之包含“starlet”。\n在大部分情况下 StringBuilder > StringBuffer\n\n**StringBuilder**\njava.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。\n\n### 2. 性能对比\n\n测试性能源码(使用了JMH来进行基准测试)\n\n```\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 3)\n@Measurement(iterations = 3, time = 3)\n@Threads(1)\n@Fork(1)\n@State(Scope.Thread)\npublic class StringBenchmark {\n\n    String s1;\n\n    StringBuffer stringBuffer;\n\n    StringBuilder stringBuilder;\n\n\n    @Setup(Level.Iteration)\n    public void before() {\n        s1 = \"s1\";\n        stringBuffer = new StringBuffer(\"s1\");\n        stringBuilder = new StringBuilder(\"s1\");\n\n    }\n\n\n    @TearDown\n    public void after() {\n\n    }\n\n\n    @Benchmark\n    public String testStringAppend() {\n\n        return s1 += \"s2\";\n    }\n\n\n    @Benchmark\n    public StringBuffer testStringBufferAppend() {\n\n        return stringBuffer.append(\"s2\");\n\n    }\n\n\n    @Benchmark\n    public StringBuilder testStringBuilderAppend() {\n        //下面这个还会单独生成一个String对象，因此性能上有所损失，所以调整一下\n//        return new StringBuilder(\"s1\").append(\"s2\").toString();\n\n        return stringBuilder.append(\"s2\");\n    }\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(StringBenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n```\n\n测试结果\n\n```\nBenchmark                                Mode  Cnt      Score       Error  Units\nStringBenchmark.testStringAppend         avgt    3  28179.211 ± 25587.942  ns/op\nStringBenchmark.testStringBufferAppend   avgt    3     26.152 ±   189.157  ns/op\nStringBenchmark.testStringBuilderAppend  avgt    3     21.150 ±    48.648  ns/op\n```\n\n从结果可以验证，在上面简单介绍中所说的，如果字符串拼接操作，最好选择StringBuilder，如果要保证线程安全选择StringBuffer，另外上面结果有一点需要注意的是，从测试结果看，StringBuffer和StringBuilder的性能差不多，这是因为我是在jdk8上运行的，JVM在运行时，因为只有一个线程，因此对Synchronize做了优化，使得StringBuffer性能得到提升。\n\n### 3. 字符串常量池\n\n我觉得这篇文章已经写得非常好因此可以看这篇文章\n\n[String：字符串常量池](https://segmentfault.com/a/1190000009888357)\n\n但是我对这个持有疑问\n\n**String str2 = new String(\"ABC\") + \"ABC\" ; 会创建多少个对象?**\n\nstr2 ：\n字符串常量池：\"ABC\" : 1个\n堆：new String(\"ABC\") ：1个\n引用： str2 ：1个\n总共 ： 3个\n\n我认为结果是这样的：\n\n字符串常量池 “ABC” 1个\n\n堆：new String(\"ABC\"),new String(\"ABCABC\"),new StringBuilder()\n\nNew String(\"ABCABC\") 是由于new String(\"ABC\") +\"ABC\"在编译的时候会按照下面这种方式来生成\n\n```java\nStringBuilder  stringBuilder = new StringBuilder();\nstringBuilder.append(\"ABC\");\nstringBuilder.append(\"ABC);\nstringBuilder.toString();// 这时就会产生 new String(\"ABCABC)\n```\n\n另外由于这个是使用new String(\"ABC\") + \"ABC\"，因此ABCABC不会进入常量池，除非调用String.intern()方法\n\n不知道对不对，欢迎大家讨论\n\n### 参考\n\n1.  [String,StringBuffer与StringBuilder的区别|线程安全与线程不安全](https://www.cnblogs.com/xingzc/p/6277581.html)\n2. [字面量和常量池初探](https://mccxj.github.io/blog/20130615_java-string-constant-pool.html) 基于java1.6","slug":"String、StringBuffer和StringBuilder对比","published":1,"updated":"2019-01-02T05:25:58.647Z","_id":"cjqeqk7n7000tdq1uvnzsvsmm","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<h1 id=\"String、StringBuffer和StringBuilder对比\"><a href=\"#String、StringBuffer和StringBuilder对比\" class=\"headerlink\" title=\"String、StringBuffer和StringBuilder对比\"></a>String、StringBuffer和StringBuilder对比</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>简单介绍</li>\n<li>性能对比</li>\n<li>字符串常量池<a id=\"more\"></a>\n</li>\n</ol>\n<h3 id=\"1-简单介绍\"><a href=\"#1-简单介绍\" class=\"headerlink\" title=\"1. 简单介绍\"></a>1. 简单介绍</h3><p>这里只对这三个类做个简单的总结，如果你希望详细了解这三个类，可以看一下三篇文章，我觉得写得很好。</p>\n<ol>\n<li><a href=\"https://www.cnblogs.com/skywang12345/p/string01.html\" target=\"_blank\" rel=\"noopener\">String 详解(String系列之1)</a></li>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/string02.html\" target=\"_blank\" rel=\"noopener\">StringBuilder 详解 (String系列之2)</a></li>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/string03.html\" target=\"_blank\" rel=\"noopener\">StringBuffer 详解 (String系列之3)</a></li>\n</ol>\n<p>首先一个简单的对比</p>\n<p><strong>String 字符串常量</strong></p>\n<p><strong>StringBuffer 字符串变量（线程安全）</strong></p>\n<p><strong>StringBuilder 字符串变量（非线程安全）</strong></p>\n<p>StringBuffer与StringBuilder的实现几乎是一样的，只是StringBufferr为了保证线程安全，在方法前面加上Synchronize关键字来保证安全性，因此下面先用StringBuffer来和String进行对比</p>\n<p>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。<br> 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String S1 = “This is only a” + “ simple” + “ test”;</span><br><span class=\"line\">StringBuffer Sb = <span class=\"keyword\">new</span> StringBuffer(“This is only a”).append(“ simple”).append(“ test”);</span><br></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Benchmark                         Mode  Cnt   Score    Error  Units</span><br><span class=\"line\">StringBenchmark.testString        avgt    3   5.701 ±  2.431  ns/op</span><br><span class=\"line\">StringBenchmark.testStringBuffer  avgt    3  27.077 ± 21.828  ns/op</span><br></pre></td></tr></table></figure>\n<p><strong>其中score对应是每次操作花费的纳秒说</strong></p>\n<p> 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个<br><strong>String S1 = “This is only a” + “ simple” + “test”; </strong>其实就是：<br><strong> String S1 = “This is only a simple test”</strong>; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String S2 = “This is only a”;</span><br><span class=\"line\">String S3 = “ simple”;</span><br><span class=\"line\">String S4 = “ test”;</span><br><span class=\"line\">String S1 = S2 +S3 + S4;</span><br></pre></td></tr></table></figure>\n<p>这时候 JVM 会规规矩矩的按照原来的方式去做<br>在大部分情况下 StringBuffer的性能要好于 String<br><strong>StringBuffer</strong><br>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。<br>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。<br>在大部分情况下 StringBuilder &gt; StringBuffer</p>\n<p><strong>StringBuilder</strong><br>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>\n<h3 id=\"2-性能对比\"><a href=\"#2-性能对比\" class=\"headerlink\" title=\"2. 性能对比\"></a>2. 性能对比</h3><p>测试性能源码(使用了JMH来进行基准测试)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@BenchmarkMode(&#123;Mode.AverageTime&#125;)</span><br><span class=\"line\">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span><br><span class=\"line\">@Warmup(iterations = 3, time = 3)</span><br><span class=\"line\">@Measurement(iterations = 3, time = 3)</span><br><span class=\"line\">@Threads(1)</span><br><span class=\"line\">@Fork(1)</span><br><span class=\"line\">@State(Scope.Thread)</span><br><span class=\"line\">public class StringBenchmark &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String s1;</span><br><span class=\"line\"></span><br><span class=\"line\">    StringBuffer stringBuffer;</span><br><span class=\"line\"></span><br><span class=\"line\">    StringBuilder stringBuilder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Setup(Level.Iteration)</span><br><span class=\"line\">    public void before() &#123;</span><br><span class=\"line\">        s1 = &quot;s1&quot;;</span><br><span class=\"line\">        stringBuffer = new StringBuffer(&quot;s1&quot;);</span><br><span class=\"line\">        stringBuilder = new StringBuilder(&quot;s1&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @TearDown</span><br><span class=\"line\">    public void after() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Benchmark</span><br><span class=\"line\">    public String testStringAppend() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return s1 += &quot;s2&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Benchmark</span><br><span class=\"line\">    public StringBuffer testStringBufferAppend() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return stringBuffer.append(&quot;s2&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Benchmark</span><br><span class=\"line\">    public StringBuilder testStringBuilderAppend() &#123;</span><br><span class=\"line\">        //下面这个还会单独生成一个String对象，因此性能上有所损失，所以调整一下</span><br><span class=\"line\">//        return new StringBuilder(&quot;s1&quot;).append(&quot;s2&quot;).toString();</span><br><span class=\"line\"></span><br><span class=\"line\">        return stringBuilder.append(&quot;s2&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) throws RunnerException &#123;</span><br><span class=\"line\">        Options opt = new OptionsBuilder()</span><br><span class=\"line\">                .include(StringBenchmark.class.getSimpleName())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        new Runner(opt).run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Benchmark                                Mode  Cnt      Score       Error  Units</span><br><span class=\"line\">StringBenchmark.testStringAppend         avgt    3  28179.211 ± 25587.942  ns/op</span><br><span class=\"line\">StringBenchmark.testStringBufferAppend   avgt    3     26.152 ±   189.157  ns/op</span><br><span class=\"line\">StringBenchmark.testStringBuilderAppend  avgt    3     21.150 ±    48.648  ns/op</span><br></pre></td></tr></table></figure>\n<p>从结果可以验证，在上面简单介绍中所说的，如果字符串拼接操作，最好选择StringBuilder，如果要保证线程安全选择StringBuffer，另外上面结果有一点需要注意的是，从测试结果看，StringBuffer和StringBuilder的性能差不多，这是因为我是在jdk8上运行的，JVM在运行时，因为只有一个线程，因此对Synchronize做了优化，使得StringBuffer性能得到提升。</p>\n<h3 id=\"3-字符串常量池\"><a href=\"#3-字符串常量池\" class=\"headerlink\" title=\"3. 字符串常量池\"></a>3. 字符串常量池</h3><p>我觉得这篇文章已经写得非常好因此可以看这篇文章</p>\n<p><a href=\"https://segmentfault.com/a/1190000009888357\" target=\"_blank\" rel=\"noopener\">String：字符串常量池</a></p>\n<p>但是我对这个持有疑问</p>\n<p><strong>String str2 = new String(“ABC”) + “ABC” ; 会创建多少个对象?</strong></p>\n<p>str2 ：<br>字符串常量池：”ABC” : 1个<br>堆：new String(“ABC”) ：1个<br>引用： str2 ：1个<br>总共 ： 3个</p>\n<p>我认为结果是这样的：</p>\n<p>字符串常量池 “ABC” 1个</p>\n<p>堆：new String(“ABC”),new String(“ABCABC”),new StringBuilder()</p>\n<p>New String(“ABCABC”) 是由于new String(“ABC”) +”ABC”在编译的时候会按照下面这种方式来生成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuilder  stringBuilder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">stringBuilder.append(<span class=\"string\">\"ABC\"</span>);</span><br><span class=\"line\">stringBuilder.append(<span class=\"string\">\"ABC);</span></span><br><span class=\"line\"><span class=\"string\">stringBuilder.toString();// 这时就会产生 new String(\"</span>ABCABC)</span><br></pre></td></tr></table></figure>\n<p>另外由于这个是使用new String(“ABC”) + “ABC”，因此ABCABC不会进入常量池，除非调用String.intern()方法</p>\n<p>不知道对不对，欢迎大家讨论</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://www.cnblogs.com/xingzc/p/6277581.html\" target=\"_blank\" rel=\"noopener\">String,StringBuffer与StringBuilder的区别|线程安全与线程不安全</a></li>\n<li><a href=\"https://mccxj.github.io/blog/20130615_java-string-constant-pool.html\" target=\"_blank\" rel=\"noopener\">字面量和常量池初探</a> 基于java1.6</li>\n</ol>\n","site":{"data":{}},"excerpt":"<hr>\n<h1 id=\"String、StringBuffer和StringBuilder对比\"><a href=\"#String、StringBuffer和StringBuilder对比\" class=\"headerlink\" title=\"String、StringBuffer和StringBuilder对比\"></a>String、StringBuffer和StringBuilder对比</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>简单介绍</li>\n<li>性能对比</li>\n<li>字符串常量池","more":"</li>\n</ol>\n<h3 id=\"1-简单介绍\"><a href=\"#1-简单介绍\" class=\"headerlink\" title=\"1. 简单介绍\"></a>1. 简单介绍</h3><p>这里只对这三个类做个简单的总结，如果你希望详细了解这三个类，可以看一下三篇文章，我觉得写得很好。</p>\n<ol>\n<li><a href=\"https://www.cnblogs.com/skywang12345/p/string01.html\" target=\"_blank\" rel=\"noopener\">String 详解(String系列之1)</a></li>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/string02.html\" target=\"_blank\" rel=\"noopener\">StringBuilder 详解 (String系列之2)</a></li>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/string03.html\" target=\"_blank\" rel=\"noopener\">StringBuffer 详解 (String系列之3)</a></li>\n</ol>\n<p>首先一个简单的对比</p>\n<p><strong>String 字符串常量</strong></p>\n<p><strong>StringBuffer 字符串变量（线程安全）</strong></p>\n<p><strong>StringBuilder 字符串变量（非线程安全）</strong></p>\n<p>StringBuffer与StringBuilder的实现几乎是一样的，只是StringBufferr为了保证线程安全，在方法前面加上Synchronize关键字来保证安全性，因此下面先用StringBuffer来和String进行对比</p>\n<p>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。<br> 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String S1 = “This is only a” + “ simple” + “ test”;</span><br><span class=\"line\">StringBuffer Sb = <span class=\"keyword\">new</span> StringBuffer(“This is only a”).append(“ simple”).append(“ test”);</span><br></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Benchmark                         Mode  Cnt   Score    Error  Units</span><br><span class=\"line\">StringBenchmark.testString        avgt    3   5.701 ±  2.431  ns/op</span><br><span class=\"line\">StringBenchmark.testStringBuffer  avgt    3  27.077 ± 21.828  ns/op</span><br></pre></td></tr></table></figure>\n<p><strong>其中score对应是每次操作花费的纳秒说</strong></p>\n<p> 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个<br><strong>String S1 = “This is only a” + “ simple” + “test”; </strong>其实就是：<br><strong> String S1 = “This is only a simple test”</strong>; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String S2 = “This is only a”;</span><br><span class=\"line\">String S3 = “ simple”;</span><br><span class=\"line\">String S4 = “ test”;</span><br><span class=\"line\">String S1 = S2 +S3 + S4;</span><br></pre></td></tr></table></figure>\n<p>这时候 JVM 会规规矩矩的按照原来的方式去做<br>在大部分情况下 StringBuffer的性能要好于 String<br><strong>StringBuffer</strong><br>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。<br>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。<br>在大部分情况下 StringBuilder &gt; StringBuffer</p>\n<p><strong>StringBuilder</strong><br>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>\n<h3 id=\"2-性能对比\"><a href=\"#2-性能对比\" class=\"headerlink\" title=\"2. 性能对比\"></a>2. 性能对比</h3><p>测试性能源码(使用了JMH来进行基准测试)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@BenchmarkMode(&#123;Mode.AverageTime&#125;)</span><br><span class=\"line\">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span><br><span class=\"line\">@Warmup(iterations = 3, time = 3)</span><br><span class=\"line\">@Measurement(iterations = 3, time = 3)</span><br><span class=\"line\">@Threads(1)</span><br><span class=\"line\">@Fork(1)</span><br><span class=\"line\">@State(Scope.Thread)</span><br><span class=\"line\">public class StringBenchmark &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String s1;</span><br><span class=\"line\"></span><br><span class=\"line\">    StringBuffer stringBuffer;</span><br><span class=\"line\"></span><br><span class=\"line\">    StringBuilder stringBuilder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Setup(Level.Iteration)</span><br><span class=\"line\">    public void before() &#123;</span><br><span class=\"line\">        s1 = &quot;s1&quot;;</span><br><span class=\"line\">        stringBuffer = new StringBuffer(&quot;s1&quot;);</span><br><span class=\"line\">        stringBuilder = new StringBuilder(&quot;s1&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @TearDown</span><br><span class=\"line\">    public void after() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Benchmark</span><br><span class=\"line\">    public String testStringAppend() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return s1 += &quot;s2&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Benchmark</span><br><span class=\"line\">    public StringBuffer testStringBufferAppend() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return stringBuffer.append(&quot;s2&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Benchmark</span><br><span class=\"line\">    public StringBuilder testStringBuilderAppend() &#123;</span><br><span class=\"line\">        //下面这个还会单独生成一个String对象，因此性能上有所损失，所以调整一下</span><br><span class=\"line\">//        return new StringBuilder(&quot;s1&quot;).append(&quot;s2&quot;).toString();</span><br><span class=\"line\"></span><br><span class=\"line\">        return stringBuilder.append(&quot;s2&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) throws RunnerException &#123;</span><br><span class=\"line\">        Options opt = new OptionsBuilder()</span><br><span class=\"line\">                .include(StringBenchmark.class.getSimpleName())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        new Runner(opt).run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Benchmark                                Mode  Cnt      Score       Error  Units</span><br><span class=\"line\">StringBenchmark.testStringAppend         avgt    3  28179.211 ± 25587.942  ns/op</span><br><span class=\"line\">StringBenchmark.testStringBufferAppend   avgt    3     26.152 ±   189.157  ns/op</span><br><span class=\"line\">StringBenchmark.testStringBuilderAppend  avgt    3     21.150 ±    48.648  ns/op</span><br></pre></td></tr></table></figure>\n<p>从结果可以验证，在上面简单介绍中所说的，如果字符串拼接操作，最好选择StringBuilder，如果要保证线程安全选择StringBuffer，另外上面结果有一点需要注意的是，从测试结果看，StringBuffer和StringBuilder的性能差不多，这是因为我是在jdk8上运行的，JVM在运行时，因为只有一个线程，因此对Synchronize做了优化，使得StringBuffer性能得到提升。</p>\n<h3 id=\"3-字符串常量池\"><a href=\"#3-字符串常量池\" class=\"headerlink\" title=\"3. 字符串常量池\"></a>3. 字符串常量池</h3><p>我觉得这篇文章已经写得非常好因此可以看这篇文章</p>\n<p><a href=\"https://segmentfault.com/a/1190000009888357\" target=\"_blank\" rel=\"noopener\">String：字符串常量池</a></p>\n<p>但是我对这个持有疑问</p>\n<p><strong>String str2 = new String(“ABC”) + “ABC” ; 会创建多少个对象?</strong></p>\n<p>str2 ：<br>字符串常量池：”ABC” : 1个<br>堆：new String(“ABC”) ：1个<br>引用： str2 ：1个<br>总共 ： 3个</p>\n<p>我认为结果是这样的：</p>\n<p>字符串常量池 “ABC” 1个</p>\n<p>堆：new String(“ABC”),new String(“ABCABC”),new StringBuilder()</p>\n<p>New String(“ABCABC”) 是由于new String(“ABC”) +”ABC”在编译的时候会按照下面这种方式来生成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuilder  stringBuilder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">stringBuilder.append(<span class=\"string\">\"ABC\"</span>);</span><br><span class=\"line\">stringBuilder.append(<span class=\"string\">\"ABC);</span></span><br><span class=\"line\"><span class=\"string\">stringBuilder.toString();// 这时就会产生 new String(\"</span>ABCABC)</span><br></pre></td></tr></table></figure>\n<p>另外由于这个是使用new String(“ABC”) + “ABC”，因此ABCABC不会进入常量池，除非调用String.intern()方法</p>\n<p>不知道对不对，欢迎大家讨论</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://www.cnblogs.com/xingzc/p/6277581.html\" target=\"_blank\" rel=\"noopener\">String,StringBuffer与StringBuilder的区别|线程安全与线程不安全</a></li>\n<li><a href=\"https://mccxj.github.io/blog/20130615_java-string-constant-pool.html\" target=\"_blank\" rel=\"noopener\">字面量和常量池初探</a> 基于java1.6</li>\n</ol>"},{"title":"虚拟内存","author":"zhangke","abbrlink":"f79e4123","date":"2018-09-21T06:42:00.000Z","_content":"# 虚拟内存\n\n### 概述\n\n1. 虚拟内存是什么、可以用来做什么\n2. 基本概念介绍\n3. 虚拟内存作为缓存的工具\n4. 虚拟内存作为内存管理的工具\n5. 虚拟内存作为内存保护的工具\n\n### 1. 虚拟内存是什么、功能是什么\n\n**虚拟内存是什么**\n\n**虚拟内存**是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。\n\n下面是《深入立即操作系统》给出的定义：\n\n> 为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。\n\n并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。\n\n虚拟内存功能是什么\n\n1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。\n2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。\n3. 它保护了每个进程的地址空间不被其他进程破坏。\n\n<!-- more -->\n\n### 2.基本概念介绍\n\n#### 物理地址、虚拟地址\n\n虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：\n\n![物理寻址](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg)\n\n主存的每个地址都是唯一的，第一个字节地址为0，接下来为1，以此类推。CPU使用这种访问方式就是**物理寻址**。上图所示就是CPU通过**地址总线**传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。\n\n当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：\n\n![img](upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp)\n\n\n\n使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。\n\n我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。\n\n#### 地址空间\n\n地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。\n\n### 3. 虚拟内存作为缓存的工具\n\n**虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。**\n\n从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块(block)，这些块作为和主存(较高层)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。\n\n在任意时刻，虚拟页面都分为三个不相交的部分：\n\n- **未分配的(Unallocated)**：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。\n- **缓存的(Cached)**：当前已缓存在物理内存中的已分配页。\n- **未缓存的(UnCached)**：该页已经映射到磁盘上了，但是还没缓存在物理内存中。\n\n> 其中**未分配的VP**不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射，毕竟程序不可能实际使用那么大的地址空间。\n\n![](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png)\n\n图13：VM使用主存来作为缓存\n\n上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。\n\n> 当然，那个图上标注的不对,VP 部分， `n-p`和`N-1`应该分别标注为`3`和`7`,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。\n\n### 参考\n\n[什么是虚拟内存](https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-3/virtual_mem_managment.html)\n\n[《深入理解计算机系统》| 虚拟存储器](https://www.jianshu.com/p/e1b82b230917)\n\n[什么是内存(二)：虚拟内存](https://www.cnblogs.com/yaoxiaowen/p/7805964.html)","source":"_posts/虚拟内存.md","raw":"---\ntitle: 虚拟内存\nauthor: zhangke\nabbrlink: f79e4123\ntags:\n  - 操作系统\ncategories: []\ndate: 2018-09-21 14:42:00\n---\n# 虚拟内存\n\n### 概述\n\n1. 虚拟内存是什么、可以用来做什么\n2. 基本概念介绍\n3. 虚拟内存作为缓存的工具\n4. 虚拟内存作为内存管理的工具\n5. 虚拟内存作为内存保护的工具\n\n### 1. 虚拟内存是什么、功能是什么\n\n**虚拟内存是什么**\n\n**虚拟内存**是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。\n\n下面是《深入立即操作系统》给出的定义：\n\n> 为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。\n\n并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。\n\n虚拟内存功能是什么\n\n1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。\n2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。\n3. 它保护了每个进程的地址空间不被其他进程破坏。\n\n<!-- more -->\n\n### 2.基本概念介绍\n\n#### 物理地址、虚拟地址\n\n虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：\n\n![物理寻址](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg)\n\n主存的每个地址都是唯一的，第一个字节地址为0，接下来为1，以此类推。CPU使用这种访问方式就是**物理寻址**。上图所示就是CPU通过**地址总线**传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。\n\n当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：\n\n![img](upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp)\n\n\n\n使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。\n\n我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。\n\n#### 地址空间\n\n地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。\n\n### 3. 虚拟内存作为缓存的工具\n\n**虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。**\n\n从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块(block)，这些块作为和主存(较高层)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。\n\n在任意时刻，虚拟页面都分为三个不相交的部分：\n\n- **未分配的(Unallocated)**：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。\n- **缓存的(Cached)**：当前已缓存在物理内存中的已分配页。\n- **未缓存的(UnCached)**：该页已经映射到磁盘上了，但是还没缓存在物理内存中。\n\n> 其中**未分配的VP**不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射，毕竟程序不可能实际使用那么大的地址空间。\n\n![](https://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png)\n\n图13：VM使用主存来作为缓存\n\n上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。\n\n> 当然，那个图上标注的不对,VP 部分， `n-p`和`N-1`应该分别标注为`3`和`7`,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。\n\n### 参考\n\n[什么是虚拟内存](https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-3/virtual_mem_managment.html)\n\n[《深入理解计算机系统》| 虚拟存储器](https://www.jianshu.com/p/e1b82b230917)\n\n[什么是内存(二)：虚拟内存](https://www.cnblogs.com/yaoxiaowen/p/7805964.html)","slug":"虚拟内存","published":1,"updated":"2018-10-30T06:46:51.309Z","_id":"cjqeqp9zx000ahj1ua8o3x402","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>虚拟内存是什么、可以用来做什么</li>\n<li>基本概念介绍</li>\n<li>虚拟内存作为缓存的工具</li>\n<li>虚拟内存作为内存管理的工具</li>\n<li>虚拟内存作为内存保护的工具</li>\n</ol>\n<h3 id=\"1-虚拟内存是什么、功能是什么\"><a href=\"#1-虚拟内存是什么、功能是什么\" class=\"headerlink\" title=\"1. 虚拟内存是什么、功能是什么\"></a>1. 虚拟内存是什么、功能是什么</h3><p><strong>虚拟内存是什么</strong></p>\n<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>\n<p>下面是《深入立即操作系统》给出的定义：</p>\n<blockquote>\n<p>为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。</p>\n</blockquote>\n<p>并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。</p>\n<p>虚拟内存功能是什么</p>\n<ol>\n<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。</li>\n<li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li>\n<li>它保护了每个进程的地址空间不被其他进程破坏。</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"2-基本概念介绍\"><a href=\"#2-基本概念介绍\" class=\"headerlink\" title=\"2.基本概念介绍\"></a>2.基本概念介绍</h3><h4 id=\"物理地址、虚拟地址\"><a href=\"#物理地址、虚拟地址\" class=\"headerlink\" title=\"物理地址、虚拟地址\"></a>物理地址、虚拟地址</h4><p>虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg\" alt=\"物理寻址\"></p>\n<p>主存的每个地址都是唯一的，第一个字节地址为0，接下来为1，以此类推。CPU使用这种访问方式就是<strong>物理寻址</strong>。上图所示就是CPU通过<strong>地址总线</strong>传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。</p>\n<p>当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：</p>\n<p><img src=\"upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp\" alt=\"img\"></p>\n<p>使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。</p>\n<p>我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。</p>\n<h4 id=\"地址空间\"><a href=\"#地址空间\" class=\"headerlink\" title=\"地址空间\"></a>地址空间</h4><p>地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>\n<h3 id=\"3-虚拟内存作为缓存的工具\"><a href=\"#3-虚拟内存作为缓存的工具\" class=\"headerlink\" title=\"3. 虚拟内存作为缓存的工具\"></a>3. 虚拟内存作为缓存的工具</h3><p><strong>虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。</strong></p>\n<p>从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块(block)，这些块作为和主存(较高层)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。</p>\n<p>在任意时刻，虚拟页面都分为三个不相交的部分：</p>\n<ul>\n<li><strong>未分配的(Unallocated)</strong>：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。</li>\n<li><strong>缓存的(Cached)</strong>：当前已缓存在物理内存中的已分配页。</li>\n<li><strong>未缓存的(UnCached)</strong>：该页已经映射到磁盘上了，但是还没缓存在物理内存中。</li>\n</ul>\n<blockquote>\n<p>其中<strong>未分配的VP</strong>不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射，毕竟程序不可能实际使用那么大的地址空间。</p>\n</blockquote>\n<p><img src=\"https://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png\" alt=\"\"></p>\n<p>图13：VM使用主存来作为缓存</p>\n<p>上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。</p>\n<blockquote>\n<p>当然，那个图上标注的不对,VP 部分， <code>n-p</code>和<code>N-1</code>应该分别标注为<code>3</code>和<code>7</code>,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。</p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-3/virtual_mem_managment.html\" target=\"_blank\" rel=\"noopener\">什么是虚拟内存</a></p>\n<p><a href=\"https://www.jianshu.com/p/e1b82b230917\" target=\"_blank\" rel=\"noopener\">《深入理解计算机系统》| 虚拟存储器</a></p>\n<p><a href=\"https://www.cnblogs.com/yaoxiaowen/p/7805964.html\" target=\"_blank\" rel=\"noopener\">什么是内存(二)：虚拟内存</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>虚拟内存是什么、可以用来做什么</li>\n<li>基本概念介绍</li>\n<li>虚拟内存作为缓存的工具</li>\n<li>虚拟内存作为内存管理的工具</li>\n<li>虚拟内存作为内存保护的工具</li>\n</ol>\n<h3 id=\"1-虚拟内存是什么、功能是什么\"><a href=\"#1-虚拟内存是什么、功能是什么\" class=\"headerlink\" title=\"1. 虚拟内存是什么、功能是什么\"></a>1. 虚拟内存是什么、功能是什么</h3><p><strong>虚拟内存是什么</strong></p>\n<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>\n<p>下面是《深入立即操作系统》给出的定义：</p>\n<blockquote>\n<p>为了更加有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。</p>\n</blockquote>\n<p>并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，他对应用程序是透明的。</p>\n<p>虚拟内存功能是什么</p>\n<ol>\n<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了内存。</li>\n<li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li>\n<li>它保护了每个进程的地址空间不被其他进程破坏。</li>\n</ol>","more":"<h3 id=\"2-基本概念介绍\"><a href=\"#2-基本概念介绍\" class=\"headerlink\" title=\"2.基本概念介绍\"></a>2.基本概念介绍</h3><h4 id=\"物理地址、虚拟地址\"><a href=\"#物理地址、虚拟地址\" class=\"headerlink\" title=\"物理地址、虚拟地址\"></a>物理地址、虚拟地址</h4><p>虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。我们来看看什么是物理寻址：</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg\" alt=\"物理寻址\"></p>\n<p>主存的每个地址都是唯一的，第一个字节地址为0，接下来为1，以此类推。CPU使用这种访问方式就是<strong>物理寻址</strong>。上图所示就是CPU通过<strong>地址总线</strong>传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。</p>\n<p>当然地址总线也不是无限大的，我们通常所说的32位系统，其寻址能力是2^32 = 4 294 967 296B（4GB）也就是说内存条插的再多也没有用，地址总线只能最多访问到4GB的地址内容。我们前面说过4GB的物理内存空间其实并不大（如果是独占的话）。这时候科学家们想到了一个很好的方法，建立虚拟寻址方式，使用一个成为MMU的地址翻译工具将虚拟地址翻译成物理地址在提供访问，如下图：</p>\n<p><img src=\"upload-images.jianshu.io/upload_images/3010486-936b0ad750173e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp\" alt=\"img\"></p>\n<p>使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。</p>\n<p>我们说过虚拟地址要比物理地址大的多，为啥还要麻烦的将物理地址转成虚拟地址呢？虚拟地址的发明究竟是为了什么，我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。</p>\n<h4 id=\"地址空间\"><a href=\"#地址空间\" class=\"headerlink\" title=\"地址空间\"></a>地址空间</h4><p>地址空间是一个非负整数的集合{0，1，2，……}，一个32位的系统中有：2^32 = 4 294 967 296B（4GB）个有效地址。地址空间的概念很重要，我们必须要清楚数据对象（字节）和它的属性（地址）的区别， 举个例子：我和我老婆住在苍溪县xx小区7栋1单元，这个就是我的属性：地址。另外，住在家的我和我老婆就是数据对象（字节）。虚拟存储器的基本思想是：主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>\n<h3 id=\"3-虚拟内存作为缓存的工具\"><a href=\"#3-虚拟内存作为缓存的工具\" class=\"headerlink\" title=\"3. 虚拟内存作为缓存的工具\"></a>3. 虚拟内存作为缓存的工具</h3><p><strong>虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。</strong></p>\n<p>从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块(block)，这些块作为和主存(较高层)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。</p>\n<p>在任意时刻，虚拟页面都分为三个不相交的部分：</p>\n<ul>\n<li><strong>未分配的(Unallocated)</strong>：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。</li>\n<li><strong>缓存的(Cached)</strong>：当前已缓存在物理内存中的已分配页。</li>\n<li><strong>未缓存的(UnCached)</strong>：该页已经映射到磁盘上了，但是还没缓存在物理内存中。</li>\n</ul>\n<blockquote>\n<p>其中<strong>未分配的VP</strong>不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射，毕竟程序不可能实际使用那么大的地址空间。</p>\n</blockquote>\n<p><img src=\"https://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png\" alt=\"\"></p>\n<p>图13：VM使用主存来作为缓存</p>\n<p>上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。</p>\n<blockquote>\n<p>当然，那个图上标注的不对,VP 部分， <code>n-p</code>和<code>N-1</code>应该分别标注为<code>3</code>和<code>7</code>,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。</p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-3/virtual_mem_managment.html\" target=\"_blank\" rel=\"noopener\">什么是虚拟内存</a></p>\n<p><a href=\"https://www.jianshu.com/p/e1b82b230917\" target=\"_blank\" rel=\"noopener\">《深入理解计算机系统》| 虚拟存储器</a></p>\n<p><a href=\"https://www.cnblogs.com/yaoxiaowen/p/7805964.html\" target=\"_blank\" rel=\"noopener\">什么是内存(二)：虚拟内存</a></p>"},{"title":"自旋锁","author":"zhangke","date":"2018-12-14T03:27:00.000Z","_content":"---\n# 自旋锁\n\n### 概述\n\n1. 自旋锁是什么\n2. 自旋锁实现\n3. MCS自旋锁\n4. CLH自旋锁\n\n### 1. 自旋锁是什么\n\n自旋锁与**互斥量**(注意这里不是互斥锁)类似，用于多线程同步的一种锁。但他不是休眠使线程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。基本的实现是通过线程反复检查锁特定变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。\n\n自旋锁通常被作为底层原语用于实现其他类型的锁。根据它们所基于与的系统体系结构，可以通过使用测试并设置指令（CAS）有效的实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其它的事情，这也是自旋锁只能够持有一段时间的原因。\n\n有了这一层了解，自旋锁的优势和劣势，以及其适用场景也就一目了然了。\n<!-- more -->\n\n#### 优势：\n\n1. 没有线程阻塞，也就没有了线程上下文切换带来的开销\n2. 自旋操作更加直观，无需分析什么情况下会导致线程阻塞\n\n#### 劣势：\n\n最大的问题就是由于需要一直循环检测锁的状态，因此会浪费CPU Cycles\n\n#### 适用场景：\n\n结合上述的优劣，自旋锁在锁的临界区很小并且锁争抢排队不是非常严重的情况下是非常合适的：\n\n1. 临界区小，因此每个使用锁的线程占用锁的时间不会很长，自旋等待的线程能够快速地获取到锁。\n2. 所争抢排队不严重，因此锁的自旋时间也是可控的，不会有大量线程处于自旋等待的状态中，从而增加浪费CPU Cycles。\n\n### 2. 自旋锁实现\n\n首先需要明确的一点是，对于加锁和释放锁的操作，需要是原子性的。这是能够继续讨论的基石。对于现代处理器，一般通过CAS(Compare And Set)操作来保证原子性。它的原理其实很简单，就是将“对比-设置”这一个流程原子化，保证在符合某种预期的前提下，完成一次写操作。\n\n对应到Java语言层面，就是那一大票的AtomicXXX类型。比如在下面的非公平自旋锁的实现中，会借助AtomicReference类型提供的CAS操作来完成加锁和释放锁的操作。\n\n#### 1. 简单的自旋锁\n\n直接上代码\n\n```java\npackage JUC.spinLock;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 19:38\n *      email  : 398757724@qq.com\n *      Desc   : 简单的自旋锁，哪个线程竞争到，\n *      则获取锁，有可能产生饥饿现象\n ***************************************/\npublic class SpinLock {\n\n    //维护当前拥有锁的线程\n    private AtomicReference<Thread> owner = new AtomicReference<>();\n\n\n    public void lock() {\n        Thread currentThread = Thread.currentThread();\n\n        // 如果锁未被占用，则设置当前线程为锁的拥有者\n        while (!owner.compareAndSet(null, currentThread)) {\n            // 自旋\n        }\n    }\n\n\n    public void unLock() {\n        Thread currentThread = Thread.currentThread();\n        // 只有锁的拥有者才能释放锁，其它的线程因为无法满足Compare，因此不会Set成功\n        owner.compareAndSet(currentThread, null);\n    }\n\n\n    //一下代码属于测试\n    //用于等待所有线程都已结束\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    //所有线程共享的变量，用于测试，如果加锁和释放锁是正确的操作\n    //则在操作此集合时不会产生ConcurrentModificationException\n    static List<String> list = new ArrayList<>();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final SpinLock lock = new SpinLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    \n    private static Runnable generateTask(final SpinLock lock, \n                                        final String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n这里的关键就是加锁和释放锁中的两个CAS操作：\n\n1. 加锁过程:将CAS操作置于一个while循环中，来实现自旋的语义。由于CAS操作成功与否是成功取决于它的boolean返回值，因此当CAS操作失败的情况下，while循环将不会退出，会一直尝试CAS操作直到成功为止，此即所谓的自旋(忙等待)。\n\n1. 释放锁过程:此时不需要循环操作，但是仍然会考虑到只有当前拥有锁的线程才有资格释放锁。这一点还是通过CAS操作来保证。\n\n这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。\n\n**运行结果**:\n\n```\nThread 0 Completed [0]\nThread 9 Completed [0, 9]\nThread 3 Completed [0, 9, 3]\nThread 8 Completed [0, 9, 3, 8]\nThread 4 Completed [0, 9, 3, 8, 4]\nThread 6 Completed [0, 9, 3, 8, 4, 6]\nThread 5 Completed [0, 9, 3, 8, 4, 6, 5]\nThread 7 Completed [0, 9, 3, 8, 4, 6, 5, 7]\nThread 1 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1]\nThread 2 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n[0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n```\n\n从上可以看出，加锁和释放锁正确的实现，和预期的也是一样的，这是一个非公平的自旋锁，不是按照先来先获取锁的方式实现。\n\n#####  缺点\n\n- CAS操作需要硬件的配合；\n- 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；\n- 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。\n\n#### 2.  Ticket Lock\n\nTicket Lock 是为了解决上面的公平性问题，类似于现实中银行柜台的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询。\n\n当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋。\n\n具体代码如下：\n\n```java\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:23\n *      email  : 398757724@qq.com\n *      Desc   : Ticket Lock 简单实现，\n *      此自旋锁保证了FIFI，不会产生饥饿现象\n ***************************************/\npublic class TicketLock {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n\n    public int lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n        return myTicketNum;\n    }\n\n\n    public void unLock(int myTicketNum) {\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n    \n    public static void main(String[] args) throws InterruptedException {\n        final TicketLock lock = new TicketLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n    \n    private static Runnable generateTask(final TicketLock lock, \n    \t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            int myTicketNum = lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock(myTicketNum);\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n加锁和释放锁两个操作的过程如下：\n\n1. 加锁过程。获取一个排队号，当排队号和当前的服务号不相等时自旋等待。\n2. 释放锁过程。当前正被服务的线程释放锁，计算下一个服务号并设置。\n\n这里的AtomicInteger是为了保证服务号和等待号的原子性\n\n运行结果如下\n\n```\nThread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n从运行结果可以看出，确实是按照FIFO的顺序来获取锁，实现了公平性。\n\n不过上面的代码有一个问题，在释放锁的时候需要外部传进来排队号，这样就会带来一个隐患，外部传进来的排队号是可以修改的，也就是线程A获取的排队号是5，但是释放锁的时候却传进来6。这样就有可能导致死锁等问题。下面这个是通过ThreadLocal来改进上面的代码\n\n```java\npublic class TicketLockImprove {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n    //用于保存当前\n    private ThreadLocal<Integer> threadLocalTicketNum = new ThreadLocal<>();\n\n\n    public void lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n        //设置当前线程持有的排队号\n        threadLocalTicketNum.set(myTicketNum);\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n\n    }\n\n\n    public void unLock() {\n        //获取当前线程持有的排队号\n        int myTicketNum = threadLocalTicketNum.get();\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLockImprove lock = new TicketLockImprove();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final TicketLockImprove lock, final String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n这里是通过ThreadLocal来保存每个线程的排队号，这样就不会出现排队号被私自修改问题。其他的和上面的代码一致。\n\n##### 缺点\n\n- Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。\n\n所以，需要有一种办法能够让执行线程不再在同一个共享变量上自旋，避免过高频率的缓存同步操作。下面介绍的CLH锁和MCS锁都是为了解决这个问题的。\n\nMCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。\n\nCLH的发明人是：Craig，Landin and Hagersten。\n\n### 3. MCS 锁\n\nMCS自旋锁是一种基于单向链表的高性能、公平的自旋锁，申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。\n\n先上实现代码，然后在分析重点：\n\n```\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:34\n *      email  : 398757724@qq.com\n *      Desc   : MCS Lock\n ***************************************/\npublic class MCSLock {\n\n    //MCS锁节点\n    public static class MCSNode {\n        //指向后继节点\n        volatile MCSNode next;\n\n        //默认是在等待锁\n        volatile boolean isBlock = true;\n    }\n\n    volatile MCSNode tail; //指向最后一个申请锁的MCSNode\n\n    // 原子更新器\n    private static final AtomicReferenceFieldUpdater<MCSLock, MCSNode> UPDATER\n            = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, \n            \t\t\t\t\t\t\t\t\t\t\tMCSNode.class, \"tail\");\n\n    //用于保存当前节点对应的MCSNode对象\n    ThreadLocal<MCSNode> currentThreadNode = new ThreadLocal<>();\n\n\n    public void lock() {\n\n        //获得当前线程对应的节点\n        MCSNode mcsNode = currentThreadNode.get();\n        if (mcsNode == null) {\n            //初始化节点对象\n            mcsNode = new MCSNode();\n            currentThreadNode.set(mcsNode);\n        }\n        //设置当前队列节点到队尾并获取前置节点\n        MCSNode predecsessor = UPDATER.getAndSet(this, mcsNode); // step 1\n\n        //如果前继节点不为空，则设置前置节点的后继为当前节点，并等待获取锁\n        if (predecsessor != null) {\n            predecsessor.next = mcsNode;  // step 2\n            // 当前线程处于等待状态时自旋(MCSNode的isBlock初始化为true)\n            // 等待前驱节点主动通知，即将isBlock设置为false，表示当前线程可以获取到锁\n            while (mcsNode.isBlock) {\n\n            }\n        } else {\n            // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞 - 表示已经加锁成功\n            mcsNode.isBlock = false;\n        }\n    }\n\n\n    public void unLock() {\n        MCSNode mcsNode = currentThreadNode.get();\n        // 当前线程对应存在节点并且\n        // 锁拥有者进行释放锁才有意义 - 当blocked为true时，表示此线程处于等待状态中，\n        //                          并没有获取到锁，因此没有权利释放锁\n        if (mcsNode == null && mcsNode.isBlock) {\n            return;\n        }\n\n        if (mcsNode.next == null) {\n            if (UPDATER.compareAndSet(this, mcsNode, null)) {\n                // compareAndSet返回true表示确实没有人排在自己后面\n                return;\n            } else {\n                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者\n                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完\n                while (mcsNode.next == null) {\n                }\n            }\n        }\n        // 通知后继节点可以获取锁\n        mcsNode.next.isBlock = false;\n\n        // 将当前节点从链表中断开，方便对当前节点进行GC\n        mcsNode.next = null;// for GC\n        //for GC\n        currentThreadNode.remove();\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final MCSLock lock = new MCSLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    private static Runnable generateTask(final MCSLock lock, \n    \t\t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n实现的代码量虽然不多，但是lock和unlock的设计思想还是有些微妙之处，想要实现正确也并不容易。\n\n需要把握的几个重点：\n\n1. MCS锁的节点对象需要有两个状态，next用来维护单向链表的结构，blocked用来表示节点的状态，true表示处于自旋中；false表示加锁成功\n2. MCS锁的节点状态blocked的改变是由其前驱节点触发改变的\n3. 加锁时会更新链表的末节点并完成链表结构的维护\n4. 释放锁的时候由于链表结构建立的时滞(getAndSet原子方法和链表建立整体而言并非原子性)，可能存在多线程的干扰，需要使用忙等待保证链表结构就绪\n\n### 4. CLH锁\n\n同MCS自旋锁一样，CLH也是一种基于单向链表(隐式创建)的高性能、公平的自旋锁，申请加锁的线程只需要在其前驱节点的本地变量上自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。\n\n实现代码\n\n```\npublic class CLHLock {\n\n    public static class CLHNode {\n        private boolean isLocked = true; // 默认状态为true - 即处于等待状态或者加锁成功(换言之，即此节点处于有效的一种状态)\n    }\n\n    @SuppressWarnings(\"unused\")\n    private volatile CLHNode tail;\n\n    //线程对应CLH节点映射\n    private ThreadLocal<CLHNode> currentThreadNode = new ThreadLocal<>();\n\n\n    /**\n     * CLH 锁获取\n     */\n    public void lock() {\n        CLHNode clhNode = currentThreadNode.get();\n        if (clhNode == null) {\n            clhNode = new CLHNode();\n            currentThreadNode.set(clhNode);\n        }\n        //通过这个操作完成隐式链表的维护，后继节点只需要在前驱节点的locked状态上自旋\n        CLHNode preNode = UPDATER.getAndSet(this, clhNode);\n        if (preNode != null) {  //已有线程占用了锁，进入自旋\n            while (preNode.isLocked) {  //自旋等待前驱节点状态变更 - unlock中进行变更\n\n                //这里这样写，或者isLocked加上voliate，则能观察到变量的变化\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 没有前驱节点表示可以直接获取到锁，由于默认获取锁状态为true，此时可以什么操作都不执行\n        // 能够执行到这里表示已经成功获取到了锁\n\n    }\n\n\n    /**\n     * CLH 锁释放\n     */\n    public void unLock() {\n        CLHNode clhNode = currentThreadNode.get();\n        //只有持有锁的线程才能释放\n        if (clhNode == null || !clhNode.isLocked) {\n            return;\n        }\n\n        //从映射关系中移除当前线程对应的节点\n        currentThreadNode.remove();\n\n        //如果队列里只有当前线程，则释放对当前线程的引用(for GC)\n        // 尝试将tail从currentThread变更为null，因此当tail不为currentThread时表示还有线程在等待加锁\n        if (!UPDATER.compareAndSet(this, clhNode, null)) {\n            //还有后续线程\n            clhNode.isLocked = false; //改变状态，让后续线程结束自旋\n        }\n    }\n\n\n    private static final AtomicReferenceFieldUpdater<CLHLock, CLHNode> UPDATER =\n            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, \"tail\");\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final CLHLock lock = new CLHLock();\n        List<String> list = new ArrayList<>();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final CLHLock lock, \n    \t\t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n            } catch (Exception e) {\n\n            }\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, list));\n//            System.out.println(String.format(\"Thread %s Completed \", taskId));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n实现的代码量相比MCS锁少了很多，也简洁了不少。\n\n需要把握的几个重点：\n\n1. CLH锁的节点对象只有一个isLocked属性，关于其含义前面已经详细讨论过\n2. CLH锁的节点属性isLocked的改变是由其自身触发的\n3. CLH锁是在前驱节点的isLocked属性上进行自旋\n\n众所周知，AbstractQueuedSynchronizer是Java并发包的基石之一，而CLH锁的原理和思想则是AbstractQueuedSynchronizer的基石之一。理解清楚CLH锁的原理和实现对后面学习和理解AbstractQueuedSynchronizer是非常必要的。\n\n在**Doug Lea 写的The java.util.concurrent Synchronizer Framework** 文章中有这么一句话 **CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。**其实只要实现了取消功能，那么超时就比较容易实现。为什么CLH更容易实现取消功能呢。首先在CLH各节点之间只有一条隐形的链表存在，而排队的节点是观察前面节点的信息来判断是否可以获取锁，因此在取消排队节点时，可以不影响前继节点，而对后继节点的影响也比较小，如果MCS自旋锁要取消，则需要前继节点改变后继节点，如果敲好此时前继节点正在拿到锁运行，那此时更改锁就不是那么容易的，而且链表有事单链表，因此更改起来更加麻烦。\n\n### 总结\n\n下面我们来比较一下MCS和CLH锁\n\n首先我们先补充一点知识SMP和NUMA架构\n\n* SMP(Symmetric Multi-Processor)：对称多处理器结构，指服务器中多个 CPU 对称工作，每个 CPU 访问内存地址所需时间相同。其主要特征是共享，包含对 CPU，内存，I/O 等进行共享。SMP 能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着 CPU 数量的增加，每个 CPU 都要访问相同的内存资源，可能导致内存访问冲突，可能会导致 CPU 资源的浪费。常用的 PC 机就属于这种。\n* NUMA(Non-Uniform Memory Access)：非一致存储访问，将 CPU 分为 CPU 模块，每个 CPU 模块由多个 CPU 组成，并且具有独立的本地内存、I/O 槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存 (系统内其它节点的内存) 的速度，这也是非一致存储访问的由来。NUMA 较好地解决 SMP 的扩展问题，当 CPU 数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。\n\nCLH 队列锁的优点是空间复杂度低（如果有 n 个线程，L 个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O（L+n），n 个线程有 n 个myNode，L 个锁有 L 个 tail），CLH 的一种变体被应用在了 JAVA 并发框架中 (AbstractQueuedSynchronizer.Node)。CLH 在 SMP 系统结构下该法是非常有效的。但在 NUMA 系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，一种解决 NUMA 系统结构的思路是 MCS 队列锁。\n\nMSC 与 CLH 最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:CLH 是在前趋结点的 locked 域上自旋等待，而 MCS 是在自己的结点的 locked 域上自旋等待。正因为如此，它解决了 CLH 在 NUMA 系统架构中获取 locked 域状态内存过远的问题。\n\n\n\n### 参考\n\n1. [简单的非公平自旋锁以及基于排队的公平自旋锁的实现](https://blog.csdn.net/dm_vincent/article/details/79677891)\n2. [CLH锁的原理和实现](https://blog.csdn.net/dm_vincent/article/details/79842501)\n3. [MCS锁的原理和实现](https://blog.csdn.net/dm_vincent/article/details/79783104)\n4. [面试必备之深入理解自旋锁](https://segmentfault.com/a/1190000015795906)\n5. [Java自旋锁、排队自旋锁、MCS锁、CLH锁](https://lawrence-zxc.github.io/2015/05/03/lock/)\n6. [CLH锁与MCS锁](https://blog.csdn.net/jackyechina/article/details/73199638)","source":"_posts/自旋锁.md","raw":"title: 自旋锁\ntags:\n  - 操作系统\n  - 自旋锁\n  - JUC\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-12-14 11:27:00\n---\n---\n# 自旋锁\n\n### 概述\n\n1. 自旋锁是什么\n2. 自旋锁实现\n3. MCS自旋锁\n4. CLH自旋锁\n\n### 1. 自旋锁是什么\n\n自旋锁与**互斥量**(注意这里不是互斥锁)类似，用于多线程同步的一种锁。但他不是休眠使线程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。基本的实现是通过线程反复检查锁特定变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。\n\n自旋锁通常被作为底层原语用于实现其他类型的锁。根据它们所基于与的系统体系结构，可以通过使用测试并设置指令（CAS）有效的实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其它的事情，这也是自旋锁只能够持有一段时间的原因。\n\n有了这一层了解，自旋锁的优势和劣势，以及其适用场景也就一目了然了。\n<!-- more -->\n\n#### 优势：\n\n1. 没有线程阻塞，也就没有了线程上下文切换带来的开销\n2. 自旋操作更加直观，无需分析什么情况下会导致线程阻塞\n\n#### 劣势：\n\n最大的问题就是由于需要一直循环检测锁的状态，因此会浪费CPU Cycles\n\n#### 适用场景：\n\n结合上述的优劣，自旋锁在锁的临界区很小并且锁争抢排队不是非常严重的情况下是非常合适的：\n\n1. 临界区小，因此每个使用锁的线程占用锁的时间不会很长，自旋等待的线程能够快速地获取到锁。\n2. 所争抢排队不严重，因此锁的自旋时间也是可控的，不会有大量线程处于自旋等待的状态中，从而增加浪费CPU Cycles。\n\n### 2. 自旋锁实现\n\n首先需要明确的一点是，对于加锁和释放锁的操作，需要是原子性的。这是能够继续讨论的基石。对于现代处理器，一般通过CAS(Compare And Set)操作来保证原子性。它的原理其实很简单，就是将“对比-设置”这一个流程原子化，保证在符合某种预期的前提下，完成一次写操作。\n\n对应到Java语言层面，就是那一大票的AtomicXXX类型。比如在下面的非公平自旋锁的实现中，会借助AtomicReference类型提供的CAS操作来完成加锁和释放锁的操作。\n\n#### 1. 简单的自旋锁\n\n直接上代码\n\n```java\npackage JUC.spinLock;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 19:38\n *      email  : 398757724@qq.com\n *      Desc   : 简单的自旋锁，哪个线程竞争到，\n *      则获取锁，有可能产生饥饿现象\n ***************************************/\npublic class SpinLock {\n\n    //维护当前拥有锁的线程\n    private AtomicReference<Thread> owner = new AtomicReference<>();\n\n\n    public void lock() {\n        Thread currentThread = Thread.currentThread();\n\n        // 如果锁未被占用，则设置当前线程为锁的拥有者\n        while (!owner.compareAndSet(null, currentThread)) {\n            // 自旋\n        }\n    }\n\n\n    public void unLock() {\n        Thread currentThread = Thread.currentThread();\n        // 只有锁的拥有者才能释放锁，其它的线程因为无法满足Compare，因此不会Set成功\n        owner.compareAndSet(currentThread, null);\n    }\n\n\n    //一下代码属于测试\n    //用于等待所有线程都已结束\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    //所有线程共享的变量，用于测试，如果加锁和释放锁是正确的操作\n    //则在操作此集合时不会产生ConcurrentModificationException\n    static List<String> list = new ArrayList<>();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final SpinLock lock = new SpinLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    \n    private static Runnable generateTask(final SpinLock lock, \n                                        final String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n这里的关键就是加锁和释放锁中的两个CAS操作：\n\n1. 加锁过程:将CAS操作置于一个while循环中，来实现自旋的语义。由于CAS操作成功与否是成功取决于它的boolean返回值，因此当CAS操作失败的情况下，while循环将不会退出，会一直尝试CAS操作直到成功为止，此即所谓的自旋(忙等待)。\n\n1. 释放锁过程:此时不需要循环操作，但是仍然会考虑到只有当前拥有锁的线程才有资格释放锁。这一点还是通过CAS操作来保证。\n\n这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。\n\n**运行结果**:\n\n```\nThread 0 Completed [0]\nThread 9 Completed [0, 9]\nThread 3 Completed [0, 9, 3]\nThread 8 Completed [0, 9, 3, 8]\nThread 4 Completed [0, 9, 3, 8, 4]\nThread 6 Completed [0, 9, 3, 8, 4, 6]\nThread 5 Completed [0, 9, 3, 8, 4, 6, 5]\nThread 7 Completed [0, 9, 3, 8, 4, 6, 5, 7]\nThread 1 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1]\nThread 2 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n[0, 9, 3, 8, 4, 6, 5, 7, 1, 2]\n```\n\n从上可以看出，加锁和释放锁正确的实现，和预期的也是一样的，这是一个非公平的自旋锁，不是按照先来先获取锁的方式实现。\n\n#####  缺点\n\n- CAS操作需要硬件的配合；\n- 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；\n- 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。\n\n#### 2.  Ticket Lock\n\nTicket Lock 是为了解决上面的公平性问题，类似于现实中银行柜台的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询。\n\n当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋。\n\n具体代码如下：\n\n```java\n\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:23\n *      email  : 398757724@qq.com\n *      Desc   : Ticket Lock 简单实现，\n *      此自旋锁保证了FIFI，不会产生饥饿现象\n ***************************************/\npublic class TicketLock {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n\n    public int lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n        return myTicketNum;\n    }\n\n\n    public void unLock(int myTicketNum) {\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n    \n    public static void main(String[] args) throws InterruptedException {\n        final TicketLock lock = new TicketLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n    \n    private static Runnable generateTask(final TicketLock lock, \n    \t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            int myTicketNum = lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock(myTicketNum);\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n加锁和释放锁两个操作的过程如下：\n\n1. 加锁过程。获取一个排队号，当排队号和当前的服务号不相等时自旋等待。\n2. 释放锁过程。当前正被服务的线程释放锁，计算下一个服务号并设置。\n\n这里的AtomicInteger是为了保证服务号和等待号的原子性\n\n运行结果如下\n\n```\nThread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n从运行结果可以看出，确实是按照FIFO的顺序来获取锁，实现了公平性。\n\n不过上面的代码有一个问题，在释放锁的时候需要外部传进来排队号，这样就会带来一个隐患，外部传进来的排队号是可以修改的，也就是线程A获取的排队号是5，但是释放锁的时候却传进来6。这样就有可能导致死锁等问题。下面这个是通过ThreadLocal来改进上面的代码\n\n```java\npublic class TicketLockImprove {\n    private AtomicInteger serviceNum = new AtomicInteger(); //服务号\n\n    private AtomicInteger ticketNum = new AtomicInteger(); //排队号\n\n    //用于保存当前\n    private ThreadLocal<Integer> threadLocalTicketNum = new ThreadLocal<>();\n\n\n    public void lock() {\n        //首先原子性地获得一个排队号\n        int myTicketNum = ticketNum.getAndIncrement();\n        //设置当前线程持有的排队号\n        threadLocalTicketNum.set(myTicketNum);\n        //只要当前服务号不是自己的就不断轮询\n        while (serviceNum.get() != myTicketNum) {\n\n        }\n\n    }\n\n\n    public void unLock() {\n        //获取当前线程持有的排队号\n        int myTicketNum = threadLocalTicketNum.get();\n        //只有当前线程拥有者才能释放锁\n        int next = myTicketNum + 1;\n        serviceNum.compareAndSet(myTicketNum, next);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final TicketLockImprove lock = new TicketLockImprove();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final TicketLockImprove lock, final String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n这里是通过ThreadLocal来保存每个线程的排队号，这样就不会出现排队号被私自修改问题。其他的和上面的代码一致。\n\n##### 缺点\n\n- Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。\n\n所以，需要有一种办法能够让执行线程不再在同一个共享变量上自旋，避免过高频率的缓存同步操作。下面介绍的CLH锁和MCS锁都是为了解决这个问题的。\n\nMCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。\n\nCLH的发明人是：Craig，Landin and Hagersten。\n\n### 3. MCS 锁\n\nMCS自旋锁是一种基于单向链表的高性能、公平的自旋锁，申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。\n\n先上实现代码，然后在分析重点：\n\n```\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 20:34\n *      email  : 398757724@qq.com\n *      Desc   : MCS Lock\n ***************************************/\npublic class MCSLock {\n\n    //MCS锁节点\n    public static class MCSNode {\n        //指向后继节点\n        volatile MCSNode next;\n\n        //默认是在等待锁\n        volatile boolean isBlock = true;\n    }\n\n    volatile MCSNode tail; //指向最后一个申请锁的MCSNode\n\n    // 原子更新器\n    private static final AtomicReferenceFieldUpdater<MCSLock, MCSNode> UPDATER\n            = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, \n            \t\t\t\t\t\t\t\t\t\t\tMCSNode.class, \"tail\");\n\n    //用于保存当前节点对应的MCSNode对象\n    ThreadLocal<MCSNode> currentThreadNode = new ThreadLocal<>();\n\n\n    public void lock() {\n\n        //获得当前线程对应的节点\n        MCSNode mcsNode = currentThreadNode.get();\n        if (mcsNode == null) {\n            //初始化节点对象\n            mcsNode = new MCSNode();\n            currentThreadNode.set(mcsNode);\n        }\n        //设置当前队列节点到队尾并获取前置节点\n        MCSNode predecsessor = UPDATER.getAndSet(this, mcsNode); // step 1\n\n        //如果前继节点不为空，则设置前置节点的后继为当前节点，并等待获取锁\n        if (predecsessor != null) {\n            predecsessor.next = mcsNode;  // step 2\n            // 当前线程处于等待状态时自旋(MCSNode的isBlock初始化为true)\n            // 等待前驱节点主动通知，即将isBlock设置为false，表示当前线程可以获取到锁\n            while (mcsNode.isBlock) {\n\n            }\n        } else {\n            // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞 - 表示已经加锁成功\n            mcsNode.isBlock = false;\n        }\n    }\n\n\n    public void unLock() {\n        MCSNode mcsNode = currentThreadNode.get();\n        // 当前线程对应存在节点并且\n        // 锁拥有者进行释放锁才有意义 - 当blocked为true时，表示此线程处于等待状态中，\n        //                          并没有获取到锁，因此没有权利释放锁\n        if (mcsNode == null && mcsNode.isBlock) {\n            return;\n        }\n\n        if (mcsNode.next == null) {\n            if (UPDATER.compareAndSet(this, mcsNode, null)) {\n                // compareAndSet返回true表示确实没有人排在自己后面\n                return;\n            } else {\n                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者\n                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完\n                while (mcsNode.next == null) {\n                }\n            }\n        }\n        // 通知后继节点可以获取锁\n        mcsNode.next.isBlock = false;\n\n        // 将当前节点从链表中断开，方便对当前节点进行GC\n        mcsNode.next = null;// for GC\n        //for GC\n        currentThreadNode.remove();\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final MCSLock lock = new MCSLock();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    private static Runnable generateTask(final MCSLock lock, \n    \t\t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n实现的代码量虽然不多，但是lock和unlock的设计思想还是有些微妙之处，想要实现正确也并不容易。\n\n需要把握的几个重点：\n\n1. MCS锁的节点对象需要有两个状态，next用来维护单向链表的结构，blocked用来表示节点的状态，true表示处于自旋中；false表示加锁成功\n2. MCS锁的节点状态blocked的改变是由其前驱节点触发改变的\n3. 加锁时会更新链表的末节点并完成链表结构的维护\n4. 释放锁的时候由于链表结构建立的时滞(getAndSet原子方法和链表建立整体而言并非原子性)，可能存在多线程的干扰，需要使用忙等待保证链表结构就绪\n\n### 4. CLH锁\n\n同MCS自旋锁一样，CLH也是一种基于单向链表(隐式创建)的高性能、公平的自旋锁，申请加锁的线程只需要在其前驱节点的本地变量上自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。\n\n实现代码\n\n```\npublic class CLHLock {\n\n    public static class CLHNode {\n        private boolean isLocked = true; // 默认状态为true - 即处于等待状态或者加锁成功(换言之，即此节点处于有效的一种状态)\n    }\n\n    @SuppressWarnings(\"unused\")\n    private volatile CLHNode tail;\n\n    //线程对应CLH节点映射\n    private ThreadLocal<CLHNode> currentThreadNode = new ThreadLocal<>();\n\n\n    /**\n     * CLH 锁获取\n     */\n    public void lock() {\n        CLHNode clhNode = currentThreadNode.get();\n        if (clhNode == null) {\n            clhNode = new CLHNode();\n            currentThreadNode.set(clhNode);\n        }\n        //通过这个操作完成隐式链表的维护，后继节点只需要在前驱节点的locked状态上自旋\n        CLHNode preNode = UPDATER.getAndSet(this, clhNode);\n        if (preNode != null) {  //已有线程占用了锁，进入自旋\n            while (preNode.isLocked) {  //自旋等待前驱节点状态变更 - unlock中进行变更\n\n                //这里这样写，或者isLocked加上voliate，则能观察到变量的变化\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 没有前驱节点表示可以直接获取到锁，由于默认获取锁状态为true，此时可以什么操作都不执行\n        // 能够执行到这里表示已经成功获取到了锁\n\n    }\n\n\n    /**\n     * CLH 锁释放\n     */\n    public void unLock() {\n        CLHNode clhNode = currentThreadNode.get();\n        //只有持有锁的线程才能释放\n        if (clhNode == null || !clhNode.isLocked) {\n            return;\n        }\n\n        //从映射关系中移除当前线程对应的节点\n        currentThreadNode.remove();\n\n        //如果队列里只有当前线程，则释放对当前线程的引用(for GC)\n        // 尝试将tail从currentThread变更为null，因此当tail不为currentThread时表示还有线程在等待加锁\n        if (!UPDATER.compareAndSet(this, clhNode, null)) {\n            //还有后续线程\n            clhNode.isLocked = false; //改变状态，让后续线程结束自旋\n        }\n    }\n\n\n    private static final AtomicReferenceFieldUpdater<CLHLock, CLHNode> UPDATER =\n            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, \"tail\");\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n\n    public static void main(String[] args) throws InterruptedException {\n        final CLHLock lock = new CLHLock();\n        List<String> list = new ArrayList<>();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    private static Runnable generateTask(final CLHLock lock, \n    \t\t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n            } catch (Exception e) {\n\n            }\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, list));\n//            System.out.println(String.format(\"Thread %s Completed \", taskId));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n\n```\n\n实现的代码量相比MCS锁少了很多，也简洁了不少。\n\n需要把握的几个重点：\n\n1. CLH锁的节点对象只有一个isLocked属性，关于其含义前面已经详细讨论过\n2. CLH锁的节点属性isLocked的改变是由其自身触发的\n3. CLH锁是在前驱节点的isLocked属性上进行自旋\n\n众所周知，AbstractQueuedSynchronizer是Java并发包的基石之一，而CLH锁的原理和思想则是AbstractQueuedSynchronizer的基石之一。理解清楚CLH锁的原理和实现对后面学习和理解AbstractQueuedSynchronizer是非常必要的。\n\n在**Doug Lea 写的The java.util.concurrent Synchronizer Framework** 文章中有这么一句话 **CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。**其实只要实现了取消功能，那么超时就比较容易实现。为什么CLH更容易实现取消功能呢。首先在CLH各节点之间只有一条隐形的链表存在，而排队的节点是观察前面节点的信息来判断是否可以获取锁，因此在取消排队节点时，可以不影响前继节点，而对后继节点的影响也比较小，如果MCS自旋锁要取消，则需要前继节点改变后继节点，如果敲好此时前继节点正在拿到锁运行，那此时更改锁就不是那么容易的，而且链表有事单链表，因此更改起来更加麻烦。\n\n### 总结\n\n下面我们来比较一下MCS和CLH锁\n\n首先我们先补充一点知识SMP和NUMA架构\n\n* SMP(Symmetric Multi-Processor)：对称多处理器结构，指服务器中多个 CPU 对称工作，每个 CPU 访问内存地址所需时间相同。其主要特征是共享，包含对 CPU，内存，I/O 等进行共享。SMP 能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着 CPU 数量的增加，每个 CPU 都要访问相同的内存资源，可能导致内存访问冲突，可能会导致 CPU 资源的浪费。常用的 PC 机就属于这种。\n* NUMA(Non-Uniform Memory Access)：非一致存储访问，将 CPU 分为 CPU 模块，每个 CPU 模块由多个 CPU 组成，并且具有独立的本地内存、I/O 槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存 (系统内其它节点的内存) 的速度，这也是非一致存储访问的由来。NUMA 较好地解决 SMP 的扩展问题，当 CPU 数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。\n\nCLH 队列锁的优点是空间复杂度低（如果有 n 个线程，L 个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O（L+n），n 个线程有 n 个myNode，L 个锁有 L 个 tail），CLH 的一种变体被应用在了 JAVA 并发框架中 (AbstractQueuedSynchronizer.Node)。CLH 在 SMP 系统结构下该法是非常有效的。但在 NUMA 系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，一种解决 NUMA 系统结构的思路是 MCS 队列锁。\n\nMSC 与 CLH 最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:CLH 是在前趋结点的 locked 域上自旋等待，而 MCS 是在自己的结点的 locked 域上自旋等待。正因为如此，它解决了 CLH 在 NUMA 系统架构中获取 locked 域状态内存过远的问题。\n\n\n\n### 参考\n\n1. [简单的非公平自旋锁以及基于排队的公平自旋锁的实现](https://blog.csdn.net/dm_vincent/article/details/79677891)\n2. [CLH锁的原理和实现](https://blog.csdn.net/dm_vincent/article/details/79842501)\n3. [MCS锁的原理和实现](https://blog.csdn.net/dm_vincent/article/details/79783104)\n4. [面试必备之深入理解自旋锁](https://segmentfault.com/a/1190000015795906)\n5. [Java自旋锁、排队自旋锁、MCS锁、CLH锁](https://lawrence-zxc.github.io/2015/05/03/lock/)\n6. [CLH锁与MCS锁](https://blog.csdn.net/jackyechina/article/details/73199638)","slug":"自旋锁","published":1,"updated":"2019-01-02T05:28:59.348Z","_id":"cjqeqpa02000dhj1uiuw5v4lm","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<h1 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>自旋锁是什么</li>\n<li>自旋锁实现</li>\n<li>MCS自旋锁</li>\n<li>CLH自旋锁</li>\n</ol>\n<h3 id=\"1-自旋锁是什么\"><a href=\"#1-自旋锁是什么\" class=\"headerlink\" title=\"1. 自旋锁是什么\"></a>1. 自旋锁是什么</h3><p>自旋锁与<strong>互斥量</strong>(注意这里不是互斥锁)类似，用于多线程同步的一种锁。但他不是休眠使线程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。基本的实现是通过线程反复检查锁特定变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。</p>\n<p>自旋锁通常被作为底层原语用于实现其他类型的锁。根据它们所基于与的系统体系结构，可以通过使用测试并设置指令（CAS）有效的实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其它的事情，这也是自旋锁只能够持有一段时间的原因。</p>\n<p>有了这一层了解，自旋锁的优势和劣势，以及其适用场景也就一目了然了。<br><a id=\"more\"></a></p>\n<h4 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h4><ol>\n<li>没有线程阻塞，也就没有了线程上下文切换带来的开销</li>\n<li>自旋操作更加直观，无需分析什么情况下会导致线程阻塞</li>\n</ol>\n<h4 id=\"劣势：\"><a href=\"#劣势：\" class=\"headerlink\" title=\"劣势：\"></a>劣势：</h4><p>最大的问题就是由于需要一直循环检测锁的状态，因此会浪费CPU Cycles</p>\n<h4 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h4><p>结合上述的优劣，自旋锁在锁的临界区很小并且锁争抢排队不是非常严重的情况下是非常合适的：</p>\n<ol>\n<li>临界区小，因此每个使用锁的线程占用锁的时间不会很长，自旋等待的线程能够快速地获取到锁。</li>\n<li>所争抢排队不严重，因此锁的自旋时间也是可控的，不会有大量线程处于自旋等待的状态中，从而增加浪费CPU Cycles。</li>\n</ol>\n<h3 id=\"2-自旋锁实现\"><a href=\"#2-自旋锁实现\" class=\"headerlink\" title=\"2. 自旋锁实现\"></a>2. 自旋锁实现</h3><p>首先需要明确的一点是，对于加锁和释放锁的操作，需要是原子性的。这是能够继续讨论的基石。对于现代处理器，一般通过CAS(Compare And Set)操作来保证原子性。它的原理其实很简单，就是将“对比-设置”这一个流程原子化，保证在符合某种预期的前提下，完成一次写操作。</p>\n<p>对应到Java语言层面，就是那一大票的AtomicXXX类型。比如在下面的非公平自旋锁的实现中，会借助AtomicReference类型提供的CAS操作来完成加锁和释放锁的操作。</p>\n<h4 id=\"1-简单的自旋锁\"><a href=\"#1-简单的自旋锁\" class=\"headerlink\" title=\"1. 简单的自旋锁\"></a>1. 简单的自旋锁</h4><p>直接上代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> JUC.spinLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CountDownLatch;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**************************************</span></span><br><span class=\"line\"><span class=\"comment\"> *      Author : zhangke</span></span><br><span class=\"line\"><span class=\"comment\"> *      Date   : 2018-12-12 19:38</span></span><br><span class=\"line\"><span class=\"comment\"> *      email  : 398757724@qq.com</span></span><br><span class=\"line\"><span class=\"comment\"> *      Desc   : 简单的自旋锁，哪个线程竞争到，</span></span><br><span class=\"line\"><span class=\"comment\"> *      则获取锁，有可能产生饥饿现象</span></span><br><span class=\"line\"><span class=\"comment\"> ***************************************/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpinLock</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//维护当前拥有锁的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicReference&lt;Thread&gt; owner = <span class=\"keyword\">new</span> AtomicReference&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread currentThread = Thread.currentThread();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果锁未被占用，则设置当前线程为锁的拥有者</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!owner.compareAndSet(<span class=\"keyword\">null</span>, currentThread)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 自旋</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread currentThread = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"comment\">// 只有锁的拥有者才能释放锁，其它的线程因为无法满足Compare，因此不会Set成功</span></span><br><span class=\"line\">        owner.compareAndSet(currentThread, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//一下代码属于测试</span></span><br><span class=\"line\">    <span class=\"comment\">//用于等待所有线程都已结束</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//所有线程共享的变量，用于测试，如果加锁和释放锁是正确的操作</span></span><br><span class=\"line\">    <span class=\"comment\">//则在操作此集合时不会产生ConcurrentModificationException</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SpinLock lock = <span class=\"keyword\">new</span> SpinLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(generateTask(lock, String.valueOf(i), list)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Runnable <span class=\"title\">generateTask</span><span class=\"params\">(<span class=\"keyword\">final</span> SpinLock lock, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                        <span class=\"keyword\">final</span> String taskId, <span class=\"keyword\">final</span> List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> () -&gt; &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">                list.add(taskId);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String s = list.toString();</span><br><span class=\"line\">            System.out.println(String.format(<span class=\"string\">\"Thread %s Completed %s\"</span>, taskId, s));</span><br><span class=\"line\">            lock.unLock();</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的关键就是加锁和释放锁中的两个CAS操作：</p>\n<ol>\n<li><p>加锁过程:将CAS操作置于一个while循环中，来实现自旋的语义。由于CAS操作成功与否是成功取决于它的boolean返回值，因此当CAS操作失败的情况下，while循环将不会退出，会一直尝试CAS操作直到成功为止，此即所谓的自旋(忙等待)。</p>\n</li>\n<li><p>释放锁过程:此时不需要循环操作，但是仍然会考虑到只有当前拥有锁的线程才有资格释放锁。这一点还是通过CAS操作来保证。</p>\n</li>\n</ol>\n<p>这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。</p>\n<p><strong>运行结果</strong>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread 0 Completed [0]</span><br><span class=\"line\">Thread 9 Completed [0, 9]</span><br><span class=\"line\">Thread 3 Completed [0, 9, 3]</span><br><span class=\"line\">Thread 8 Completed [0, 9, 3, 8]</span><br><span class=\"line\">Thread 4 Completed [0, 9, 3, 8, 4]</span><br><span class=\"line\">Thread 6 Completed [0, 9, 3, 8, 4, 6]</span><br><span class=\"line\">Thread 5 Completed [0, 9, 3, 8, 4, 6, 5]</span><br><span class=\"line\">Thread 7 Completed [0, 9, 3, 8, 4, 6, 5, 7]</span><br><span class=\"line\">Thread 1 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1]</span><br><span class=\"line\">Thread 2 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1, 2]</span><br><span class=\"line\">[0, 9, 3, 8, 4, 6, 5, 7, 1, 2]</span><br></pre></td></tr></table></figure>\n<p>从上可以看出，加锁和释放锁正确的实现，和预期的也是一样的，这是一个非公平的自旋锁，不是按照先来先获取锁的方式实现。</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>CAS操作需要硬件的配合；</li>\n<li>保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；</li>\n<li>没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。</li>\n</ul>\n<h4 id=\"2-Ticket-Lock\"><a href=\"#2-Ticket-Lock\" class=\"headerlink\" title=\"2.  Ticket Lock\"></a>2.  Ticket Lock</h4><p>Ticket Lock 是为了解决上面的公平性问题，类似于现实中银行柜台的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询。</p>\n<p>当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋。</p>\n<p>具体代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**************************************</span></span><br><span class=\"line\"><span class=\"comment\"> *      Author : zhangke</span></span><br><span class=\"line\"><span class=\"comment\"> *      Date   : 2018-12-12 20:23</span></span><br><span class=\"line\"><span class=\"comment\"> *      email  : 398757724@qq.com</span></span><br><span class=\"line\"><span class=\"comment\"> *      Desc   : Ticket Lock 简单实现，</span></span><br><span class=\"line\"><span class=\"comment\"> *      此自旋锁保证了FIFI，不会产生饥饿现象</span></span><br><span class=\"line\"><span class=\"comment\"> ***************************************/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TicketLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger serviceNum = <span class=\"keyword\">new</span> AtomicInteger(); <span class=\"comment\">//服务号</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger ticketNum = <span class=\"keyword\">new</span> AtomicInteger(); <span class=\"comment\">//排队号</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//首先原子性地获得一个排队号</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> myTicketNum = ticketNum.getAndIncrement();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//只要当前服务号不是自己的就不断轮询</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (serviceNum.get() != myTicketNum) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myTicketNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unLock</span><span class=\"params\">(<span class=\"keyword\">int</span> myTicketNum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//只有当前线程拥有者才能释放锁</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> next = myTicketNum + <span class=\"number\">1</span>;</span><br><span class=\"line\">        serviceNum.compareAndSet(myTicketNum, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> TicketLock lock = <span class=\"keyword\">new</span> TicketLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(generateTask(lock, String.valueOf(i), list)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Runnable <span class=\"title\">generateTask</span><span class=\"params\">(<span class=\"keyword\">final</span> TicketLock lock, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    \t\t<span class=\"keyword\">final</span> String taskId, <span class=\"keyword\">final</span> List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> myTicketNum = lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">                list.add(taskId);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String s = list.toString();</span><br><span class=\"line\">            System.out.println(String.format(<span class=\"string\">\"Thread %s Completed %s\"</span>, taskId, s));</span><br><span class=\"line\">            lock.unLock(myTicketNum);</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>加锁和释放锁两个操作的过程如下：</p>\n<ol>\n<li>加锁过程。获取一个排队号，当排队号和当前的服务号不相等时自旋等待。</li>\n<li>释放锁过程。当前正被服务的线程释放锁，计算下一个服务号并设置。</li>\n</ol>\n<p>这里的AtomicInteger是为了保证服务号和等待号的原子性</p>\n<p>运行结果如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread 0 Completed [0]</span><br><span class=\"line\">Thread 1 Completed [0, 1]</span><br><span class=\"line\">Thread 2 Completed [0, 1, 2]</span><br><span class=\"line\">Thread 3 Completed [0, 1, 2, 3]</span><br><span class=\"line\">Thread 4 Completed [0, 1, 2, 3, 4]</span><br><span class=\"line\">Thread 5 Completed [0, 1, 2, 3, 4, 5]</span><br><span class=\"line\">Thread 6 Completed [0, 1, 2, 3, 4, 5, 6]</span><br><span class=\"line\">Thread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]</span><br><span class=\"line\">Thread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]</span><br><span class=\"line\">Thread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>\n<p>从运行结果可以看出，确实是按照FIFO的顺序来获取锁，实现了公平性。</p>\n<p>不过上面的代码有一个问题，在释放锁的时候需要外部传进来排队号，这样就会带来一个隐患，外部传进来的排队号是可以修改的，也就是线程A获取的排队号是5，但是释放锁的时候却传进来6。这样就有可能导致死锁等问题。下面这个是通过ThreadLocal来改进上面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TicketLockImprove</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger serviceNum = <span class=\"keyword\">new</span> AtomicInteger(); <span class=\"comment\">//服务号</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger ticketNum = <span class=\"keyword\">new</span> AtomicInteger(); <span class=\"comment\">//排队号</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于保存当前</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ThreadLocal&lt;Integer&gt; threadLocalTicketNum = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//首先原子性地获得一个排队号</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> myTicketNum = ticketNum.getAndIncrement();</span><br><span class=\"line\">        <span class=\"comment\">//设置当前线程持有的排队号</span></span><br><span class=\"line\">        threadLocalTicketNum.set(myTicketNum);</span><br><span class=\"line\">        <span class=\"comment\">//只要当前服务号不是自己的就不断轮询</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (serviceNum.get() != myTicketNum) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前线程持有的排队号</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> myTicketNum = threadLocalTicketNum.get();</span><br><span class=\"line\">        <span class=\"comment\">//只有当前线程拥有者才能释放锁</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> next = myTicketNum + <span class=\"number\">1</span>;</span><br><span class=\"line\">        serviceNum.compareAndSet(myTicketNum, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> TicketLockImprove lock = <span class=\"keyword\">new</span> TicketLockImprove();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(generateTask(lock, String.valueOf(i), list)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Runnable <span class=\"title\">generateTask</span><span class=\"params\">(<span class=\"keyword\">final</span> TicketLockImprove lock, <span class=\"keyword\">final</span> String taskId, <span class=\"keyword\">final</span> List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> () -&gt; &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">                list.add(taskId);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String s = list.toString();</span><br><span class=\"line\">            System.out.println(String.format(<span class=\"string\">\"Thread %s Completed %s\"</span>, taskId, s));</span><br><span class=\"line\">            lock.unLock();</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里是通过ThreadLocal来保存每个线程的排队号，这样就不会出现排队号被私自修改问题。其他的和上面的代码一致。</p>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</li>\n</ul>\n<p>所以，需要有一种办法能够让执行线程不再在同一个共享变量上自旋，避免过高频率的缓存同步操作。下面介绍的CLH锁和MCS锁都是为了解决这个问题的。</p>\n<p>MCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。</p>\n<p>CLH的发明人是：Craig，Landin and Hagersten。</p>\n<h3 id=\"3-MCS-锁\"><a href=\"#3-MCS-锁\" class=\"headerlink\" title=\"3. MCS 锁\"></a>3. MCS 锁</h3><p>MCS自旋锁是一种基于单向链表的高性能、公平的自旋锁，申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。</p>\n<p>先上实现代码，然后在分析重点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**************************************</span><br><span class=\"line\"> *      Author : zhangke</span><br><span class=\"line\"> *      Date   : 2018-12-12 20:34</span><br><span class=\"line\"> *      email  : 398757724@qq.com</span><br><span class=\"line\"> *      Desc   : MCS Lock</span><br><span class=\"line\"> ***************************************/</span><br><span class=\"line\">public class MCSLock &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //MCS锁节点</span><br><span class=\"line\">    public static class MCSNode &#123;</span><br><span class=\"line\">        //指向后继节点</span><br><span class=\"line\">        volatile MCSNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">        //默认是在等待锁</span><br><span class=\"line\">        volatile boolean isBlock = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    volatile MCSNode tail; //指向最后一个申请锁的MCSNode</span><br><span class=\"line\"></span><br><span class=\"line\">    // 原子更新器</span><br><span class=\"line\">    private static final AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER</span><br><span class=\"line\">            = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, </span><br><span class=\"line\">            \t\t\t\t\t\t\t\t\t\t\tMCSNode.class, &quot;tail&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //用于保存当前节点对应的MCSNode对象</span><br><span class=\"line\">    ThreadLocal&lt;MCSNode&gt; currentThreadNode = new ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public void lock() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        //获得当前线程对应的节点</span><br><span class=\"line\">        MCSNode mcsNode = currentThreadNode.get();</span><br><span class=\"line\">        if (mcsNode == null) &#123;</span><br><span class=\"line\">            //初始化节点对象</span><br><span class=\"line\">            mcsNode = new MCSNode();</span><br><span class=\"line\">            currentThreadNode.set(mcsNode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //设置当前队列节点到队尾并获取前置节点</span><br><span class=\"line\">        MCSNode predecsessor = UPDATER.getAndSet(this, mcsNode); // step 1</span><br><span class=\"line\"></span><br><span class=\"line\">        //如果前继节点不为空，则设置前置节点的后继为当前节点，并等待获取锁</span><br><span class=\"line\">        if (predecsessor != null) &#123;</span><br><span class=\"line\">            predecsessor.next = mcsNode;  // step 2</span><br><span class=\"line\">            // 当前线程处于等待状态时自旋(MCSNode的isBlock初始化为true)</span><br><span class=\"line\">            // 等待前驱节点主动通知，即将isBlock设置为false，表示当前线程可以获取到锁</span><br><span class=\"line\">            while (mcsNode.isBlock) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞 - 表示已经加锁成功</span><br><span class=\"line\">            mcsNode.isBlock = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public void unLock() &#123;</span><br><span class=\"line\">        MCSNode mcsNode = currentThreadNode.get();</span><br><span class=\"line\">        // 当前线程对应存在节点并且</span><br><span class=\"line\">        // 锁拥有者进行释放锁才有意义 - 当blocked为true时，表示此线程处于等待状态中，</span><br><span class=\"line\">        //                          并没有获取到锁，因此没有权利释放锁</span><br><span class=\"line\">        if (mcsNode == null &amp;&amp; mcsNode.isBlock) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mcsNode.next == null) &#123;</span><br><span class=\"line\">            if (UPDATER.compareAndSet(this, mcsNode, null)) &#123;</span><br><span class=\"line\">                // compareAndSet返回true表示确实没有人排在自己后面</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者</span><br><span class=\"line\">                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完</span><br><span class=\"line\">                while (mcsNode.next == null) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 通知后继节点可以获取锁</span><br><span class=\"line\">        mcsNode.next.isBlock = false;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 将当前节点从链表中断开，方便对当前节点进行GC</span><br><span class=\"line\">        mcsNode.next = null;// for GC</span><br><span class=\"line\">        //for GC</span><br><span class=\"line\">        currentThreadNode.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        final MCSLock lock = new MCSLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            new Thread(generateTask(lock, String.valueOf(i), list)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    static CountDownLatch countDownLatch = new CountDownLatch(10);</span><br><span class=\"line\"></span><br><span class=\"line\">    static List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private static Runnable generateTask(final MCSLock lock, </span><br><span class=\"line\">    \t\t\t\t\tfinal String taskId, final List&lt;String&gt; list) &#123;</span><br><span class=\"line\">        return () -&gt; &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(300);</span><br><span class=\"line\">                list.add(taskId);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; catch (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String s = list.toString();</span><br><span class=\"line\">            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));</span><br><span class=\"line\">            lock.unLock();</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现的代码量虽然不多，但是lock和unlock的设计思想还是有些微妙之处，想要实现正确也并不容易。</p>\n<p>需要把握的几个重点：</p>\n<ol>\n<li>MCS锁的节点对象需要有两个状态，next用来维护单向链表的结构，blocked用来表示节点的状态，true表示处于自旋中；false表示加锁成功</li>\n<li>MCS锁的节点状态blocked的改变是由其前驱节点触发改变的</li>\n<li>加锁时会更新链表的末节点并完成链表结构的维护</li>\n<li>释放锁的时候由于链表结构建立的时滞(getAndSet原子方法和链表建立整体而言并非原子性)，可能存在多线程的干扰，需要使用忙等待保证链表结构就绪</li>\n</ol>\n<h3 id=\"4-CLH锁\"><a href=\"#4-CLH锁\" class=\"headerlink\" title=\"4. CLH锁\"></a>4. CLH锁</h3><p>同MCS自旋锁一样，CLH也是一种基于单向链表(隐式创建)的高性能、公平的自旋锁，申请加锁的线程只需要在其前驱节点的本地变量上自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。</p>\n<p>实现代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CLHLock &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static class CLHNode &#123;</span><br><span class=\"line\">        private boolean isLocked = true; // 默认状态为true - 即处于等待状态或者加锁成功(换言之，即此节点处于有效的一种状态)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @SuppressWarnings(&quot;unused&quot;)</span><br><span class=\"line\">    private volatile CLHNode tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    //线程对应CLH节点映射</span><br><span class=\"line\">    private ThreadLocal&lt;CLHNode&gt; currentThreadNode = new ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * CLH 锁获取</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void lock() &#123;</span><br><span class=\"line\">        CLHNode clhNode = currentThreadNode.get();</span><br><span class=\"line\">        if (clhNode == null) &#123;</span><br><span class=\"line\">            clhNode = new CLHNode();</span><br><span class=\"line\">            currentThreadNode.set(clhNode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //通过这个操作完成隐式链表的维护，后继节点只需要在前驱节点的locked状态上自旋</span><br><span class=\"line\">        CLHNode preNode = UPDATER.getAndSet(this, clhNode);</span><br><span class=\"line\">        if (preNode != null) &#123;  //已有线程占用了锁，进入自旋</span><br><span class=\"line\">            while (preNode.isLocked) &#123;  //自旋等待前驱节点状态变更 - unlock中进行变更</span><br><span class=\"line\"></span><br><span class=\"line\">                //这里这样写，或者isLocked加上voliate，则能观察到变量的变化</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(100);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 没有前驱节点表示可以直接获取到锁，由于默认获取锁状态为true，此时可以什么操作都不执行</span><br><span class=\"line\">        // 能够执行到这里表示已经成功获取到了锁</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * CLH 锁释放</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void unLock() &#123;</span><br><span class=\"line\">        CLHNode clhNode = currentThreadNode.get();</span><br><span class=\"line\">        //只有持有锁的线程才能释放</span><br><span class=\"line\">        if (clhNode == null || !clhNode.isLocked) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //从映射关系中移除当前线程对应的节点</span><br><span class=\"line\">        currentThreadNode.remove();</span><br><span class=\"line\"></span><br><span class=\"line\">        //如果队列里只有当前线程，则释放对当前线程的引用(for GC)</span><br><span class=\"line\">        // 尝试将tail从currentThread变更为null，因此当tail不为currentThread时表示还有线程在等待加锁</span><br><span class=\"line\">        if (!UPDATER.compareAndSet(this, clhNode, null)) &#123;</span><br><span class=\"line\">            //还有后续线程</span><br><span class=\"line\">            clhNode.isLocked = false; //改变状态，让后续线程结束自旋</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private static final AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER =</span><br><span class=\"line\">            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, &quot;tail&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    static CountDownLatch countDownLatch = new CountDownLatch(10);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        final CLHLock lock = new CLHLock();</span><br><span class=\"line\">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            new Thread(generateTask(lock, String.valueOf(i), list)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private static Runnable generateTask(final CLHLock lock, </span><br><span class=\"line\">    \t\t\t\t\tfinal String taskId, final List&lt;String&gt; list) &#123;</span><br><span class=\"line\">        return () -&gt; &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(300);</span><br><span class=\"line\">                list.add(taskId);</span><br><span class=\"line\">            &#125; catch (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, list));</span><br><span class=\"line\">//            System.out.println(String.format(&quot;Thread %s Completed &quot;, taskId));</span><br><span class=\"line\">            lock.unLock();</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现的代码量相比MCS锁少了很多，也简洁了不少。</p>\n<p>需要把握的几个重点：</p>\n<ol>\n<li>CLH锁的节点对象只有一个isLocked属性，关于其含义前面已经详细讨论过</li>\n<li>CLH锁的节点属性isLocked的改变是由其自身触发的</li>\n<li>CLH锁是在前驱节点的isLocked属性上进行自旋</li>\n</ol>\n<p>众所周知，AbstractQueuedSynchronizer是Java并发包的基石之一，而CLH锁的原理和思想则是AbstractQueuedSynchronizer的基石之一。理解清楚CLH锁的原理和实现对后面学习和理解AbstractQueuedSynchronizer是非常必要的。</p>\n<p>在<strong>Doug Lea 写的The java.util.concurrent Synchronizer Framework</strong> 文章中有这么一句话 <strong>CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。</strong>其实只要实现了取消功能，那么超时就比较容易实现。为什么CLH更容易实现取消功能呢。首先在CLH各节点之间只有一条隐形的链表存在，而排队的节点是观察前面节点的信息来判断是否可以获取锁，因此在取消排队节点时，可以不影响前继节点，而对后继节点的影响也比较小，如果MCS自旋锁要取消，则需要前继节点改变后继节点，如果敲好此时前继节点正在拿到锁运行，那此时更改锁就不是那么容易的，而且链表有事单链表，因此更改起来更加麻烦。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>下面我们来比较一下MCS和CLH锁</p>\n<p>首先我们先补充一点知识SMP和NUMA架构</p>\n<ul>\n<li>SMP(Symmetric Multi-Processor)：对称多处理器结构，指服务器中多个 CPU 对称工作，每个 CPU 访问内存地址所需时间相同。其主要特征是共享，包含对 CPU，内存，I/O 等进行共享。SMP 能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着 CPU 数量的增加，每个 CPU 都要访问相同的内存资源，可能导致内存访问冲突，可能会导致 CPU 资源的浪费。常用的 PC 机就属于这种。</li>\n<li>NUMA(Non-Uniform Memory Access)：非一致存储访问，将 CPU 分为 CPU 模块，每个 CPU 模块由多个 CPU 组成，并且具有独立的本地内存、I/O 槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存 (系统内其它节点的内存) 的速度，这也是非一致存储访问的由来。NUMA 较好地解决 SMP 的扩展问题，当 CPU 数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。</li>\n</ul>\n<p>CLH 队列锁的优点是空间复杂度低（如果有 n 个线程，L 个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O（L+n），n 个线程有 n 个myNode，L 个锁有 L 个 tail），CLH 的一种变体被应用在了 JAVA 并发框架中 (AbstractQueuedSynchronizer.Node)。CLH 在 SMP 系统结构下该法是非常有效的。但在 NUMA 系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，一种解决 NUMA 系统结构的思路是 MCS 队列锁。</p>\n<p>MSC 与 CLH 最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:CLH 是在前趋结点的 locked 域上自旋等待，而 MCS 是在自己的结点的 locked 域上自旋等待。正因为如此，它解决了 CLH 在 NUMA 系统架构中获取 locked 域状态内存过远的问题。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79677891\" target=\"_blank\" rel=\"noopener\">简单的非公平自旋锁以及基于排队的公平自旋锁的实现</a></li>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79842501\" target=\"_blank\" rel=\"noopener\">CLH锁的原理和实现</a></li>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79783104\" target=\"_blank\" rel=\"noopener\">MCS锁的原理和实现</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015795906\" target=\"_blank\" rel=\"noopener\">面试必备之深入理解自旋锁</a></li>\n<li><a href=\"https://lawrence-zxc.github.io/2015/05/03/lock/\" target=\"_blank\" rel=\"noopener\">Java自旋锁、排队自旋锁、MCS锁、CLH锁</a></li>\n<li><a href=\"https://blog.csdn.net/jackyechina/article/details/73199638\" target=\"_blank\" rel=\"noopener\">CLH锁与MCS锁</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<hr>\n<h1 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>自旋锁是什么</li>\n<li>自旋锁实现</li>\n<li>MCS自旋锁</li>\n<li>CLH自旋锁</li>\n</ol>\n<h3 id=\"1-自旋锁是什么\"><a href=\"#1-自旋锁是什么\" class=\"headerlink\" title=\"1. 自旋锁是什么\"></a>1. 自旋锁是什么</h3><p>自旋锁与<strong>互斥量</strong>(注意这里不是互斥锁)类似，用于多线程同步的一种锁。但他不是休眠使线程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。基本的实现是通过线程反复检查锁特定变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。</p>\n<p>自旋锁通常被作为底层原语用于实现其他类型的锁。根据它们所基于与的系统体系结构，可以通过使用测试并设置指令（CAS）有效的实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋等待锁变为可用时，CPU不能做其它的事情，这也是自旋锁只能够持有一段时间的原因。</p>\n<p>有了这一层了解，自旋锁的优势和劣势，以及其适用场景也就一目了然了。<br>","more":"</p>\n<h4 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h4><ol>\n<li>没有线程阻塞，也就没有了线程上下文切换带来的开销</li>\n<li>自旋操作更加直观，无需分析什么情况下会导致线程阻塞</li>\n</ol>\n<h4 id=\"劣势：\"><a href=\"#劣势：\" class=\"headerlink\" title=\"劣势：\"></a>劣势：</h4><p>最大的问题就是由于需要一直循环检测锁的状态，因此会浪费CPU Cycles</p>\n<h4 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h4><p>结合上述的优劣，自旋锁在锁的临界区很小并且锁争抢排队不是非常严重的情况下是非常合适的：</p>\n<ol>\n<li>临界区小，因此每个使用锁的线程占用锁的时间不会很长，自旋等待的线程能够快速地获取到锁。</li>\n<li>所争抢排队不严重，因此锁的自旋时间也是可控的，不会有大量线程处于自旋等待的状态中，从而增加浪费CPU Cycles。</li>\n</ol>\n<h3 id=\"2-自旋锁实现\"><a href=\"#2-自旋锁实现\" class=\"headerlink\" title=\"2. 自旋锁实现\"></a>2. 自旋锁实现</h3><p>首先需要明确的一点是，对于加锁和释放锁的操作，需要是原子性的。这是能够继续讨论的基石。对于现代处理器，一般通过CAS(Compare And Set)操作来保证原子性。它的原理其实很简单，就是将“对比-设置”这一个流程原子化，保证在符合某种预期的前提下，完成一次写操作。</p>\n<p>对应到Java语言层面，就是那一大票的AtomicXXX类型。比如在下面的非公平自旋锁的实现中，会借助AtomicReference类型提供的CAS操作来完成加锁和释放锁的操作。</p>\n<h4 id=\"1-简单的自旋锁\"><a href=\"#1-简单的自旋锁\" class=\"headerlink\" title=\"1. 简单的自旋锁\"></a>1. 简单的自旋锁</h4><p>直接上代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> JUC.spinLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CountDownLatch;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**************************************</span></span><br><span class=\"line\"><span class=\"comment\"> *      Author : zhangke</span></span><br><span class=\"line\"><span class=\"comment\"> *      Date   : 2018-12-12 19:38</span></span><br><span class=\"line\"><span class=\"comment\"> *      email  : 398757724@qq.com</span></span><br><span class=\"line\"><span class=\"comment\"> *      Desc   : 简单的自旋锁，哪个线程竞争到，</span></span><br><span class=\"line\"><span class=\"comment\"> *      则获取锁，有可能产生饥饿现象</span></span><br><span class=\"line\"><span class=\"comment\"> ***************************************/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpinLock</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//维护当前拥有锁的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicReference&lt;Thread&gt; owner = <span class=\"keyword\">new</span> AtomicReference&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread currentThread = Thread.currentThread();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果锁未被占用，则设置当前线程为锁的拥有者</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!owner.compareAndSet(<span class=\"keyword\">null</span>, currentThread)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 自旋</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread currentThread = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"comment\">// 只有锁的拥有者才能释放锁，其它的线程因为无法满足Compare，因此不会Set成功</span></span><br><span class=\"line\">        owner.compareAndSet(currentThread, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//一下代码属于测试</span></span><br><span class=\"line\">    <span class=\"comment\">//用于等待所有线程都已结束</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//所有线程共享的变量，用于测试，如果加锁和释放锁是正确的操作</span></span><br><span class=\"line\">    <span class=\"comment\">//则在操作此集合时不会产生ConcurrentModificationException</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SpinLock lock = <span class=\"keyword\">new</span> SpinLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(generateTask(lock, String.valueOf(i), list)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Runnable <span class=\"title\">generateTask</span><span class=\"params\">(<span class=\"keyword\">final</span> SpinLock lock, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                        <span class=\"keyword\">final</span> String taskId, <span class=\"keyword\">final</span> List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> () -&gt; &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">                list.add(taskId);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String s = list.toString();</span><br><span class=\"line\">            System.out.println(String.format(<span class=\"string\">\"Thread %s Completed %s\"</span>, taskId, s));</span><br><span class=\"line\">            lock.unLock();</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的关键就是加锁和释放锁中的两个CAS操作：</p>\n<ol>\n<li><p>加锁过程:将CAS操作置于一个while循环中，来实现自旋的语义。由于CAS操作成功与否是成功取决于它的boolean返回值，因此当CAS操作失败的情况下，while循环将不会退出，会一直尝试CAS操作直到成功为止，此即所谓的自旋(忙等待)。</p>\n</li>\n<li><p>释放锁过程:此时不需要循环操作，但是仍然会考虑到只有当前拥有锁的线程才有资格释放锁。这一点还是通过CAS操作来保证。</p>\n</li>\n</ol>\n<p>这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。</p>\n<p><strong>运行结果</strong>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread 0 Completed [0]</span><br><span class=\"line\">Thread 9 Completed [0, 9]</span><br><span class=\"line\">Thread 3 Completed [0, 9, 3]</span><br><span class=\"line\">Thread 8 Completed [0, 9, 3, 8]</span><br><span class=\"line\">Thread 4 Completed [0, 9, 3, 8, 4]</span><br><span class=\"line\">Thread 6 Completed [0, 9, 3, 8, 4, 6]</span><br><span class=\"line\">Thread 5 Completed [0, 9, 3, 8, 4, 6, 5]</span><br><span class=\"line\">Thread 7 Completed [0, 9, 3, 8, 4, 6, 5, 7]</span><br><span class=\"line\">Thread 1 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1]</span><br><span class=\"line\">Thread 2 Completed [0, 9, 3, 8, 4, 6, 5, 7, 1, 2]</span><br><span class=\"line\">[0, 9, 3, 8, 4, 6, 5, 7, 1, 2]</span><br></pre></td></tr></table></figure>\n<p>从上可以看出，加锁和释放锁正确的实现，和预期的也是一样的，这是一个非公平的自旋锁，不是按照先来先获取锁的方式实现。</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>CAS操作需要硬件的配合；</li>\n<li>保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；</li>\n<li>没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。</li>\n</ul>\n<h4 id=\"2-Ticket-Lock\"><a href=\"#2-Ticket-Lock\" class=\"headerlink\" title=\"2.  Ticket Lock\"></a>2.  Ticket Lock</h4><p>Ticket Lock 是为了解决上面的公平性问题，类似于现实中银行柜台的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询。</p>\n<p>当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋。</p>\n<p>具体代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**************************************</span></span><br><span class=\"line\"><span class=\"comment\"> *      Author : zhangke</span></span><br><span class=\"line\"><span class=\"comment\"> *      Date   : 2018-12-12 20:23</span></span><br><span class=\"line\"><span class=\"comment\"> *      email  : 398757724@qq.com</span></span><br><span class=\"line\"><span class=\"comment\"> *      Desc   : Ticket Lock 简单实现，</span></span><br><span class=\"line\"><span class=\"comment\"> *      此自旋锁保证了FIFI，不会产生饥饿现象</span></span><br><span class=\"line\"><span class=\"comment\"> ***************************************/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TicketLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger serviceNum = <span class=\"keyword\">new</span> AtomicInteger(); <span class=\"comment\">//服务号</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger ticketNum = <span class=\"keyword\">new</span> AtomicInteger(); <span class=\"comment\">//排队号</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//首先原子性地获得一个排队号</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> myTicketNum = ticketNum.getAndIncrement();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//只要当前服务号不是自己的就不断轮询</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (serviceNum.get() != myTicketNum) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myTicketNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unLock</span><span class=\"params\">(<span class=\"keyword\">int</span> myTicketNum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//只有当前线程拥有者才能释放锁</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> next = myTicketNum + <span class=\"number\">1</span>;</span><br><span class=\"line\">        serviceNum.compareAndSet(myTicketNum, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> TicketLock lock = <span class=\"keyword\">new</span> TicketLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(generateTask(lock, String.valueOf(i), list)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Runnable <span class=\"title\">generateTask</span><span class=\"params\">(<span class=\"keyword\">final</span> TicketLock lock, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    \t\t<span class=\"keyword\">final</span> String taskId, <span class=\"keyword\">final</span> List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> myTicketNum = lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">                list.add(taskId);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String s = list.toString();</span><br><span class=\"line\">            System.out.println(String.format(<span class=\"string\">\"Thread %s Completed %s\"</span>, taskId, s));</span><br><span class=\"line\">            lock.unLock(myTicketNum);</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>加锁和释放锁两个操作的过程如下：</p>\n<ol>\n<li>加锁过程。获取一个排队号，当排队号和当前的服务号不相等时自旋等待。</li>\n<li>释放锁过程。当前正被服务的线程释放锁，计算下一个服务号并设置。</li>\n</ol>\n<p>这里的AtomicInteger是为了保证服务号和等待号的原子性</p>\n<p>运行结果如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread 0 Completed [0]</span><br><span class=\"line\">Thread 1 Completed [0, 1]</span><br><span class=\"line\">Thread 2 Completed [0, 1, 2]</span><br><span class=\"line\">Thread 3 Completed [0, 1, 2, 3]</span><br><span class=\"line\">Thread 4 Completed [0, 1, 2, 3, 4]</span><br><span class=\"line\">Thread 5 Completed [0, 1, 2, 3, 4, 5]</span><br><span class=\"line\">Thread 6 Completed [0, 1, 2, 3, 4, 5, 6]</span><br><span class=\"line\">Thread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]</span><br><span class=\"line\">Thread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]</span><br><span class=\"line\">Thread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>\n<p>从运行结果可以看出，确实是按照FIFO的顺序来获取锁，实现了公平性。</p>\n<p>不过上面的代码有一个问题，在释放锁的时候需要外部传进来排队号，这样就会带来一个隐患，外部传进来的排队号是可以修改的，也就是线程A获取的排队号是5，但是释放锁的时候却传进来6。这样就有可能导致死锁等问题。下面这个是通过ThreadLocal来改进上面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TicketLockImprove</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger serviceNum = <span class=\"keyword\">new</span> AtomicInteger(); <span class=\"comment\">//服务号</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger ticketNum = <span class=\"keyword\">new</span> AtomicInteger(); <span class=\"comment\">//排队号</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于保存当前</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ThreadLocal&lt;Integer&gt; threadLocalTicketNum = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//首先原子性地获得一个排队号</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> myTicketNum = ticketNum.getAndIncrement();</span><br><span class=\"line\">        <span class=\"comment\">//设置当前线程持有的排队号</span></span><br><span class=\"line\">        threadLocalTicketNum.set(myTicketNum);</span><br><span class=\"line\">        <span class=\"comment\">//只要当前服务号不是自己的就不断轮询</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (serviceNum.get() != myTicketNum) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前线程持有的排队号</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> myTicketNum = threadLocalTicketNum.get();</span><br><span class=\"line\">        <span class=\"comment\">//只有当前线程拥有者才能释放锁</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> next = myTicketNum + <span class=\"number\">1</span>;</span><br><span class=\"line\">        serviceNum.compareAndSet(myTicketNum, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> TicketLockImprove lock = <span class=\"keyword\">new</span> TicketLockImprove();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(generateTask(lock, String.valueOf(i), list)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Runnable <span class=\"title\">generateTask</span><span class=\"params\">(<span class=\"keyword\">final</span> TicketLockImprove lock, <span class=\"keyword\">final</span> String taskId, <span class=\"keyword\">final</span> List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> () -&gt; &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">                list.add(taskId);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String s = list.toString();</span><br><span class=\"line\">            System.out.println(String.format(<span class=\"string\">\"Thread %s Completed %s\"</span>, taskId, s));</span><br><span class=\"line\">            lock.unLock();</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里是通过ThreadLocal来保存每个线程的排队号，这样就不会出现排队号被私自修改问题。其他的和上面的代码一致。</p>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</li>\n</ul>\n<p>所以，需要有一种办法能够让执行线程不再在同一个共享变量上自旋，避免过高频率的缓存同步操作。下面介绍的CLH锁和MCS锁都是为了解决这个问题的。</p>\n<p>MCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。</p>\n<p>CLH的发明人是：Craig，Landin and Hagersten。</p>\n<h3 id=\"3-MCS-锁\"><a href=\"#3-MCS-锁\" class=\"headerlink\" title=\"3. MCS 锁\"></a>3. MCS 锁</h3><p>MCS自旋锁是一种基于单向链表的高性能、公平的自旋锁，申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。</p>\n<p>先上实现代码，然后在分析重点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**************************************</span><br><span class=\"line\"> *      Author : zhangke</span><br><span class=\"line\"> *      Date   : 2018-12-12 20:34</span><br><span class=\"line\"> *      email  : 398757724@qq.com</span><br><span class=\"line\"> *      Desc   : MCS Lock</span><br><span class=\"line\"> ***************************************/</span><br><span class=\"line\">public class MCSLock &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //MCS锁节点</span><br><span class=\"line\">    public static class MCSNode &#123;</span><br><span class=\"line\">        //指向后继节点</span><br><span class=\"line\">        volatile MCSNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">        //默认是在等待锁</span><br><span class=\"line\">        volatile boolean isBlock = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    volatile MCSNode tail; //指向最后一个申请锁的MCSNode</span><br><span class=\"line\"></span><br><span class=\"line\">    // 原子更新器</span><br><span class=\"line\">    private static final AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER</span><br><span class=\"line\">            = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, </span><br><span class=\"line\">            \t\t\t\t\t\t\t\t\t\t\tMCSNode.class, &quot;tail&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //用于保存当前节点对应的MCSNode对象</span><br><span class=\"line\">    ThreadLocal&lt;MCSNode&gt; currentThreadNode = new ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public void lock() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        //获得当前线程对应的节点</span><br><span class=\"line\">        MCSNode mcsNode = currentThreadNode.get();</span><br><span class=\"line\">        if (mcsNode == null) &#123;</span><br><span class=\"line\">            //初始化节点对象</span><br><span class=\"line\">            mcsNode = new MCSNode();</span><br><span class=\"line\">            currentThreadNode.set(mcsNode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //设置当前队列节点到队尾并获取前置节点</span><br><span class=\"line\">        MCSNode predecsessor = UPDATER.getAndSet(this, mcsNode); // step 1</span><br><span class=\"line\"></span><br><span class=\"line\">        //如果前继节点不为空，则设置前置节点的后继为当前节点，并等待获取锁</span><br><span class=\"line\">        if (predecsessor != null) &#123;</span><br><span class=\"line\">            predecsessor.next = mcsNode;  // step 2</span><br><span class=\"line\">            // 当前线程处于等待状态时自旋(MCSNode的isBlock初始化为true)</span><br><span class=\"line\">            // 等待前驱节点主动通知，即将isBlock设置为false，表示当前线程可以获取到锁</span><br><span class=\"line\">            while (mcsNode.isBlock) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己为非阻塞 - 表示已经加锁成功</span><br><span class=\"line\">            mcsNode.isBlock = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public void unLock() &#123;</span><br><span class=\"line\">        MCSNode mcsNode = currentThreadNode.get();</span><br><span class=\"line\">        // 当前线程对应存在节点并且</span><br><span class=\"line\">        // 锁拥有者进行释放锁才有意义 - 当blocked为true时，表示此线程处于等待状态中，</span><br><span class=\"line\">        //                          并没有获取到锁，因此没有权利释放锁</span><br><span class=\"line\">        if (mcsNode == null &amp;&amp; mcsNode.isBlock) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mcsNode.next == null) &#123;</span><br><span class=\"line\">            if (UPDATER.compareAndSet(this, mcsNode, null)) &#123;</span><br><span class=\"line\">                // compareAndSet返回true表示确实没有人排在自己后面</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者</span><br><span class=\"line\">                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完</span><br><span class=\"line\">                while (mcsNode.next == null) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 通知后继节点可以获取锁</span><br><span class=\"line\">        mcsNode.next.isBlock = false;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 将当前节点从链表中断开，方便对当前节点进行GC</span><br><span class=\"line\">        mcsNode.next = null;// for GC</span><br><span class=\"line\">        //for GC</span><br><span class=\"line\">        currentThreadNode.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        final MCSLock lock = new MCSLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            new Thread(generateTask(lock, String.valueOf(i), list)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    static CountDownLatch countDownLatch = new CountDownLatch(10);</span><br><span class=\"line\"></span><br><span class=\"line\">    static List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private static Runnable generateTask(final MCSLock lock, </span><br><span class=\"line\">    \t\t\t\t\tfinal String taskId, final List&lt;String&gt; list) &#123;</span><br><span class=\"line\">        return () -&gt; &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(300);</span><br><span class=\"line\">                list.add(taskId);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; catch (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String s = list.toString();</span><br><span class=\"line\">            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, s));</span><br><span class=\"line\">            lock.unLock();</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现的代码量虽然不多，但是lock和unlock的设计思想还是有些微妙之处，想要实现正确也并不容易。</p>\n<p>需要把握的几个重点：</p>\n<ol>\n<li>MCS锁的节点对象需要有两个状态，next用来维护单向链表的结构，blocked用来表示节点的状态，true表示处于自旋中；false表示加锁成功</li>\n<li>MCS锁的节点状态blocked的改变是由其前驱节点触发改变的</li>\n<li>加锁时会更新链表的末节点并完成链表结构的维护</li>\n<li>释放锁的时候由于链表结构建立的时滞(getAndSet原子方法和链表建立整体而言并非原子性)，可能存在多线程的干扰，需要使用忙等待保证链表结构就绪</li>\n</ol>\n<h3 id=\"4-CLH锁\"><a href=\"#4-CLH锁\" class=\"headerlink\" title=\"4. CLH锁\"></a>4. CLH锁</h3><p>同MCS自旋锁一样，CLH也是一种基于单向链表(隐式创建)的高性能、公平的自旋锁，申请加锁的线程只需要在其前驱节点的本地变量上自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。</p>\n<p>实现代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CLHLock &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static class CLHNode &#123;</span><br><span class=\"line\">        private boolean isLocked = true; // 默认状态为true - 即处于等待状态或者加锁成功(换言之，即此节点处于有效的一种状态)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @SuppressWarnings(&quot;unused&quot;)</span><br><span class=\"line\">    private volatile CLHNode tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    //线程对应CLH节点映射</span><br><span class=\"line\">    private ThreadLocal&lt;CLHNode&gt; currentThreadNode = new ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * CLH 锁获取</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void lock() &#123;</span><br><span class=\"line\">        CLHNode clhNode = currentThreadNode.get();</span><br><span class=\"line\">        if (clhNode == null) &#123;</span><br><span class=\"line\">            clhNode = new CLHNode();</span><br><span class=\"line\">            currentThreadNode.set(clhNode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //通过这个操作完成隐式链表的维护，后继节点只需要在前驱节点的locked状态上自旋</span><br><span class=\"line\">        CLHNode preNode = UPDATER.getAndSet(this, clhNode);</span><br><span class=\"line\">        if (preNode != null) &#123;  //已有线程占用了锁，进入自旋</span><br><span class=\"line\">            while (preNode.isLocked) &#123;  //自旋等待前驱节点状态变更 - unlock中进行变更</span><br><span class=\"line\"></span><br><span class=\"line\">                //这里这样写，或者isLocked加上voliate，则能观察到变量的变化</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(100);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 没有前驱节点表示可以直接获取到锁，由于默认获取锁状态为true，此时可以什么操作都不执行</span><br><span class=\"line\">        // 能够执行到这里表示已经成功获取到了锁</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * CLH 锁释放</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void unLock() &#123;</span><br><span class=\"line\">        CLHNode clhNode = currentThreadNode.get();</span><br><span class=\"line\">        //只有持有锁的线程才能释放</span><br><span class=\"line\">        if (clhNode == null || !clhNode.isLocked) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //从映射关系中移除当前线程对应的节点</span><br><span class=\"line\">        currentThreadNode.remove();</span><br><span class=\"line\"></span><br><span class=\"line\">        //如果队列里只有当前线程，则释放对当前线程的引用(for GC)</span><br><span class=\"line\">        // 尝试将tail从currentThread变更为null，因此当tail不为currentThread时表示还有线程在等待加锁</span><br><span class=\"line\">        if (!UPDATER.compareAndSet(this, clhNode, null)) &#123;</span><br><span class=\"line\">            //还有后续线程</span><br><span class=\"line\">            clhNode.isLocked = false; //改变状态，让后续线程结束自旋</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private static final AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER =</span><br><span class=\"line\">            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, &quot;tail&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    static CountDownLatch countDownLatch = new CountDownLatch(10);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        final CLHLock lock = new CLHLock();</span><br><span class=\"line\">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            new Thread(generateTask(lock, String.valueOf(i), list)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private static Runnable generateTask(final CLHLock lock, </span><br><span class=\"line\">    \t\t\t\t\tfinal String taskId, final List&lt;String&gt; list) &#123;</span><br><span class=\"line\">        return () -&gt; &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(300);</span><br><span class=\"line\">                list.add(taskId);</span><br><span class=\"line\">            &#125; catch (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(String.format(&quot;Thread %s Completed %s&quot;, taskId, list));</span><br><span class=\"line\">//            System.out.println(String.format(&quot;Thread %s Completed &quot;, taskId));</span><br><span class=\"line\">            lock.unLock();</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现的代码量相比MCS锁少了很多，也简洁了不少。</p>\n<p>需要把握的几个重点：</p>\n<ol>\n<li>CLH锁的节点对象只有一个isLocked属性，关于其含义前面已经详细讨论过</li>\n<li>CLH锁的节点属性isLocked的改变是由其自身触发的</li>\n<li>CLH锁是在前驱节点的isLocked属性上进行自旋</li>\n</ol>\n<p>众所周知，AbstractQueuedSynchronizer是Java并发包的基石之一，而CLH锁的原理和思想则是AbstractQueuedSynchronizer的基石之一。理解清楚CLH锁的原理和实现对后面学习和理解AbstractQueuedSynchronizer是非常必要的。</p>\n<p>在<strong>Doug Lea 写的The java.util.concurrent Synchronizer Framework</strong> 文章中有这么一句话 <strong>CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。</strong>其实只要实现了取消功能，那么超时就比较容易实现。为什么CLH更容易实现取消功能呢。首先在CLH各节点之间只有一条隐形的链表存在，而排队的节点是观察前面节点的信息来判断是否可以获取锁，因此在取消排队节点时，可以不影响前继节点，而对后继节点的影响也比较小，如果MCS自旋锁要取消，则需要前继节点改变后继节点，如果敲好此时前继节点正在拿到锁运行，那此时更改锁就不是那么容易的，而且链表有事单链表，因此更改起来更加麻烦。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>下面我们来比较一下MCS和CLH锁</p>\n<p>首先我们先补充一点知识SMP和NUMA架构</p>\n<ul>\n<li>SMP(Symmetric Multi-Processor)：对称多处理器结构，指服务器中多个 CPU 对称工作，每个 CPU 访问内存地址所需时间相同。其主要特征是共享，包含对 CPU，内存，I/O 等进行共享。SMP 能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着 CPU 数量的增加，每个 CPU 都要访问相同的内存资源，可能导致内存访问冲突，可能会导致 CPU 资源的浪费。常用的 PC 机就属于这种。</li>\n<li>NUMA(Non-Uniform Memory Access)：非一致存储访问，将 CPU 分为 CPU 模块，每个 CPU 模块由多个 CPU 组成，并且具有独立的本地内存、I/O 槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存 (系统内其它节点的内存) 的速度，这也是非一致存储访问的由来。NUMA 较好地解决 SMP 的扩展问题，当 CPU 数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。</li>\n</ul>\n<p>CLH 队列锁的优点是空间复杂度低（如果有 n 个线程，L 个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O（L+n），n 个线程有 n 个myNode，L 个锁有 L 个 tail），CLH 的一种变体被应用在了 JAVA 并发框架中 (AbstractQueuedSynchronizer.Node)。CLH 在 SMP 系统结构下该法是非常有效的。但在 NUMA 系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，一种解决 NUMA 系统结构的思路是 MCS 队列锁。</p>\n<p>MSC 与 CLH 最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:CLH 是在前趋结点的 locked 域上自旋等待，而 MCS 是在自己的结点的 locked 域上自旋等待。正因为如此，它解决了 CLH 在 NUMA 系统架构中获取 locked 域状态内存过远的问题。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79677891\" target=\"_blank\" rel=\"noopener\">简单的非公平自旋锁以及基于排队的公平自旋锁的实现</a></li>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79842501\" target=\"_blank\" rel=\"noopener\">CLH锁的原理和实现</a></li>\n<li><a href=\"https://blog.csdn.net/dm_vincent/article/details/79783104\" target=\"_blank\" rel=\"noopener\">MCS锁的原理和实现</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015795906\" target=\"_blank\" rel=\"noopener\">面试必备之深入理解自旋锁</a></li>\n<li><a href=\"https://lawrence-zxc.github.io/2015/05/03/lock/\" target=\"_blank\" rel=\"noopener\">Java自旋锁、排队自旋锁、MCS锁、CLH锁</a></li>\n<li><a href=\"https://blog.csdn.net/jackyechina/article/details/73199638\" target=\"_blank\" rel=\"noopener\">CLH锁与MCS锁</a></li>\n</ol>"},{"title":"Random 与 ThreadLocalRandom 对比","author":"zhangke","date":"2018-12-12T07:42:00.000Z","_content":"\n---\n# Random 与 ThreadLocalRandom 对比\n\n1. 简介\n2. 测试结果与分析\n3. 补充\n\n### 1. 简介\n\n首先，如果你看到这篇文章相信对这俩个类有一定的了解，所以我就不再这里介绍具体的用法。简单的介绍一下这个类，Random，ThreadLocalRandom是Java中的随机数生成器，Random是我们比较常用的随机数生成器，他是线程安全的。ThreadLocalRandom是jdk7才出现的，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，同时也能保证线程安全和提高性能。\n\n由于本人能力有限，如果你的英文比较好，可以看看StackOverFlow上的这个讨论[https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom](https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom)\n\n### 2. 测试结果与分析\n\n我使用的JMH来进行的压测，这篇文章可以帮助你[入门 JMH](https://www.cnkirito.moe/java-jmh/)。具体代码如下\n\n```java\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 11:44\n *      email  : 398757724@qq.com\n *      Desc   : ThreadRandom 和 Random性能对比\n ***************************************/\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 5)\n@Measurement(iterations = 3, time = 5)\n@Threads(10)\n@Fork(1)\n@State(Scope.Benchmark)\npublic class Randombenchmark {\n    Random random = new Random();\n\n    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n\n\n    @Benchmark\n    public int random() {\n        return random.nextInt();\n    }\n\n\n    @Benchmark\n    public int threadLocalRandom() {\n        return threadLocalRandom.nextInt();\n    }\n\n\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(Randombenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n\n```\n\n测试结果\n\n```\n··· 前面一部分省略，主要内容如下\nBenchmark                          Mode  Cnt    Score     Error  Units\nRandombenchmark.random             avgt    3  349.952 ± 115.007  ns/op\nRandombenchmark.threadLocalRandom  avgt    3   26.393 ±  11.538  ns/op\n```\n\n从上面结果可以看出，结果验证确实ThreadLocalRandom在多线程环境情况下更快，ThreadLocalRandom比Random快了将近13倍之多。\n\n至于为什么ThreadLocalRandom更快呢，这个要从源码来分析。\n\nRandom的实现也比较简单，初始化的时候用当前的事件来初始化一个随机数种子，然后每次取值的时候用这个种子与有些MagicNumber运算，并更新种子。最核心的就是这个next的函数，不管你是调用了nextDouble还是nextInt还是nextBoolean，Random底层都是调这个next(int bits)。\n\n```java\n    protected int next(int bits) {\n        long oldseed, nextseed;\n        AtomicLong seed = this.seed;\n        do {\n            oldseed = seed.get();\n            nextseed = (oldseed * multiplier + addend) & mask;\n        } while (!seed.compareAndSet(oldseed, nextseed));\n        return (int)(nextseed >>> (48 - bits));\n    }\n```\n\n　　为了保证多线程下每次生成随机数都是用的不同，next()得保证seed的更新是原子操作，所以用了AtomicLong的compareAndSet()，该方法底层调用了sum.misc.Unsafe的compareAndSwapLong()，也就是大家常听到的CAS， 这是一个native方法，它能保证原子更新一个数。\n\n既然Random是线程安全的，又能满足我们大多说的要求，为什么concurrent包里还要实现一个ThreadLocalRandom。在oracle的jdk文档里发现这样一句话\n\n> use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.\n\n大意就是用ThreadLocalRandom更适合用在多线程下，能大幅减少多线程并行下的性能开销和资源争抢。\n\n　既然ThreadLocalRandom在多线程下表现这么牛逼，它究竟是如何做到的？我们来看下源码，它的核心代码是这个（在看源码时需要注意一点，虽然ThreadLocalRandom也实现了next函数，但是在这个函数上面有一句，定义了这个方法，但绝不使用，你也可以从next*方法里面看出，使用的都是mix32(nextSeed)或者mix64(nextSeed)来获取随机数）\n\n```java\n    final long nextSeed() {\n        Thread t; long r; // read and update per-thread seed\n        UNSAFE.putLong(t = Thread.currentThread(), SEED,\n                       r = UNSAFE.getLong(t, SEED) + GAMMA);\n        return r;\n    }\n```\n\n上面虽然使用了UNSAFE对象，但是没有调用CAS方法，只是简单的替换Thread对象中的threadLocalRandomSeed属性，所以不要一看到UNSAFE这个类，就当成要调用CAS方法，我刚开始阅读的时候就有这个疑惑，自己太菜了。\n\n在创建ThreadLocalRandom对象时，ThreadLocalRandom是对每个线程都设置了单独的随机数种子，这样就不会发生多线程同时更新一个数时产生的资源争抢了，用空间换时间。\n\n### 3. 补充\n\n在生成验证码的情况下，不要使用Random，因为它是线性可预测的。所以在安全性要求比较高的场合，应当使用SecureRandom。从理论上来说计算机产生的随机数都是伪随机数，要想**产生高强度的随机数，有两个重要的因素：种子和算法。当然算法是可以有很多的，但是如何选择种子是非常关键的因素。如Random，它的种子是System.currentTimeMillis()，所以它的随机数都是可预测的。那么如何得到一个近似随机的种子？这里有一个很别致的思路：收集计算机的各种信息，如键盘输入时间，CPU时钟，内存使用状态，硬盘空闲空间，IO延时，进程数量，线程数量等信息，来得到一个近似随机的种子。这样的话，除了理论上有破解的可能，实际上基本没有被破解的可能。而事实上，现在的高强度的随机数生成器都是这样实现的。**\n\n\n\n### 参考\n\n1. [https://xindoo.me/article/1400](https://xindoo.me/article/1400)\n2. [C 位操作 左移32位 错误](https://blog.csdn.net/huqinweI987/article/details/70941199) 这个是我在进行源码研究时，发先自己int类型的说移动32位还是原数子，从这篇文章找到了答案\n3. [Java并发计数器探秘](https://www.cnkirito.moe/java-random/)\n\n","source":"_posts/Random 与 ThreadLocalRandom 对比.md","raw":"title: Random 与 ThreadLocalRandom 对比\ntags:\n  - JUC\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-12-12 15:42:00\n---\n\n---\n# Random 与 ThreadLocalRandom 对比\n\n1. 简介\n2. 测试结果与分析\n3. 补充\n\n### 1. 简介\n\n首先，如果你看到这篇文章相信对这俩个类有一定的了解，所以我就不再这里介绍具体的用法。简单的介绍一下这个类，Random，ThreadLocalRandom是Java中的随机数生成器，Random是我们比较常用的随机数生成器，他是线程安全的。ThreadLocalRandom是jdk7才出现的，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，同时也能保证线程安全和提高性能。\n\n由于本人能力有限，如果你的英文比较好，可以看看StackOverFlow上的这个讨论[https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom](https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom)\n\n### 2. 测试结果与分析\n\n我使用的JMH来进行的压测，这篇文章可以帮助你[入门 JMH](https://www.cnkirito.moe/java-jmh/)。具体代码如下\n\n```java\n/**************************************\n *      Author : zhangke\n *      Date   : 2018-12-12 11:44\n *      email  : 398757724@qq.com\n *      Desc   : ThreadRandom 和 Random性能对比\n ***************************************/\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 3, time = 5)\n@Measurement(iterations = 3, time = 5)\n@Threads(10)\n@Fork(1)\n@State(Scope.Benchmark)\npublic class Randombenchmark {\n    Random random = new Random();\n\n    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n\n\n    @Benchmark\n    public int random() {\n        return random.nextInt();\n    }\n\n\n    @Benchmark\n    public int threadLocalRandom() {\n        return threadLocalRandom.nextInt();\n    }\n\n\n    public static void main(String[] args) throws RunnerException {\n        Options opt = new OptionsBuilder()\n                .include(Randombenchmark.class.getSimpleName())\n                .build();\n\n        new Runner(opt).run();\n    }\n}\n\n```\n\n测试结果\n\n```\n··· 前面一部分省略，主要内容如下\nBenchmark                          Mode  Cnt    Score     Error  Units\nRandombenchmark.random             avgt    3  349.952 ± 115.007  ns/op\nRandombenchmark.threadLocalRandom  avgt    3   26.393 ±  11.538  ns/op\n```\n\n从上面结果可以看出，结果验证确实ThreadLocalRandom在多线程环境情况下更快，ThreadLocalRandom比Random快了将近13倍之多。\n\n至于为什么ThreadLocalRandom更快呢，这个要从源码来分析。\n\nRandom的实现也比较简单，初始化的时候用当前的事件来初始化一个随机数种子，然后每次取值的时候用这个种子与有些MagicNumber运算，并更新种子。最核心的就是这个next的函数，不管你是调用了nextDouble还是nextInt还是nextBoolean，Random底层都是调这个next(int bits)。\n\n```java\n    protected int next(int bits) {\n        long oldseed, nextseed;\n        AtomicLong seed = this.seed;\n        do {\n            oldseed = seed.get();\n            nextseed = (oldseed * multiplier + addend) & mask;\n        } while (!seed.compareAndSet(oldseed, nextseed));\n        return (int)(nextseed >>> (48 - bits));\n    }\n```\n\n　　为了保证多线程下每次生成随机数都是用的不同，next()得保证seed的更新是原子操作，所以用了AtomicLong的compareAndSet()，该方法底层调用了sum.misc.Unsafe的compareAndSwapLong()，也就是大家常听到的CAS， 这是一个native方法，它能保证原子更新一个数。\n\n既然Random是线程安全的，又能满足我们大多说的要求，为什么concurrent包里还要实现一个ThreadLocalRandom。在oracle的jdk文档里发现这样一句话\n\n> use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.\n\n大意就是用ThreadLocalRandom更适合用在多线程下，能大幅减少多线程并行下的性能开销和资源争抢。\n\n　既然ThreadLocalRandom在多线程下表现这么牛逼，它究竟是如何做到的？我们来看下源码，它的核心代码是这个（在看源码时需要注意一点，虽然ThreadLocalRandom也实现了next函数，但是在这个函数上面有一句，定义了这个方法，但绝不使用，你也可以从next*方法里面看出，使用的都是mix32(nextSeed)或者mix64(nextSeed)来获取随机数）\n\n```java\n    final long nextSeed() {\n        Thread t; long r; // read and update per-thread seed\n        UNSAFE.putLong(t = Thread.currentThread(), SEED,\n                       r = UNSAFE.getLong(t, SEED) + GAMMA);\n        return r;\n    }\n```\n\n上面虽然使用了UNSAFE对象，但是没有调用CAS方法，只是简单的替换Thread对象中的threadLocalRandomSeed属性，所以不要一看到UNSAFE这个类，就当成要调用CAS方法，我刚开始阅读的时候就有这个疑惑，自己太菜了。\n\n在创建ThreadLocalRandom对象时，ThreadLocalRandom是对每个线程都设置了单独的随机数种子，这样就不会发生多线程同时更新一个数时产生的资源争抢了，用空间换时间。\n\n### 3. 补充\n\n在生成验证码的情况下，不要使用Random，因为它是线性可预测的。所以在安全性要求比较高的场合，应当使用SecureRandom。从理论上来说计算机产生的随机数都是伪随机数，要想**产生高强度的随机数，有两个重要的因素：种子和算法。当然算法是可以有很多的，但是如何选择种子是非常关键的因素。如Random，它的种子是System.currentTimeMillis()，所以它的随机数都是可预测的。那么如何得到一个近似随机的种子？这里有一个很别致的思路：收集计算机的各种信息，如键盘输入时间，CPU时钟，内存使用状态，硬盘空闲空间，IO延时，进程数量，线程数量等信息，来得到一个近似随机的种子。这样的话，除了理论上有破解的可能，实际上基本没有被破解的可能。而事实上，现在的高强度的随机数生成器都是这样实现的。**\n\n\n\n### 参考\n\n1. [https://xindoo.me/article/1400](https://xindoo.me/article/1400)\n2. [C 位操作 左移32位 错误](https://blog.csdn.net/huqinweI987/article/details/70941199) 这个是我在进行源码研究时，发先自己int类型的说移动32位还是原数子，从这篇文章找到了答案\n3. [Java并发计数器探秘](https://www.cnkirito.moe/java-random/)\n\n","slug":"Random 与 ThreadLocalRandom 对比","published":1,"updated":"2019-01-02T05:30:09.485Z","_id":"cjqeqpchi000ehj1u4xoaa6u8","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<h1 id=\"Random-与-ThreadLocalRandom-对比\"><a href=\"#Random-与-ThreadLocalRandom-对比\" class=\"headerlink\" title=\"Random 与 ThreadLocalRandom 对比\"></a>Random 与 ThreadLocalRandom 对比</h1><ol>\n<li>简介</li>\n<li>测试结果与分析</li>\n<li>补充</li>\n</ol>\n<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>首先，如果你看到这篇文章相信对这俩个类有一定的了解，所以我就不再这里介绍具体的用法。简单的介绍一下这个类，Random，ThreadLocalRandom是Java中的随机数生成器，Random是我们比较常用的随机数生成器，他是线程安全的。ThreadLocalRandom是jdk7才出现的，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，同时也能保证线程安全和提高性能。</p>\n<p>由于本人能力有限，如果你的英文比较好，可以看看StackOverFlow上的这个讨论<a href=\"https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom</a></p>\n<h3 id=\"2-测试结果与分析\"><a href=\"#2-测试结果与分析\" class=\"headerlink\" title=\"2. 测试结果与分析\"></a>2. 测试结果与分析</h3><p>我使用的JMH来进行的压测，这篇文章可以帮助你<a href=\"https://www.cnkirito.moe/java-jmh/\" target=\"_blank\" rel=\"noopener\">入门 JMH</a>。具体代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**************************************</span></span><br><span class=\"line\"><span class=\"comment\"> *      Author : zhangke</span></span><br><span class=\"line\"><span class=\"comment\"> *      Date   : 2018-12-12 11:44</span></span><br><span class=\"line\"><span class=\"comment\"> *      email  : 398757724@qq.com</span></span><br><span class=\"line\"><span class=\"comment\"> *      Desc   : ThreadRandom 和 Random性能对比</span></span><br><span class=\"line\"><span class=\"comment\"> ***************************************/</span></span><br><span class=\"line\"><span class=\"meta\">@BenchmarkMode</span>(&#123;Mode.AverageTime&#125;)</span><br><span class=\"line\"><span class=\"meta\">@OutputTimeUnit</span>(TimeUnit.NANOSECONDS)</span><br><span class=\"line\"><span class=\"meta\">@Warmup</span>(iterations = <span class=\"number\">3</span>, time = <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"meta\">@Measurement</span>(iterations = <span class=\"number\">3</span>, time = <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"meta\">@Threads</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"meta\">@Fork</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">@State</span>(Scope.Benchmark)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Randombenchmark</span> </span>&#123;</span><br><span class=\"line\">    Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Benchmark</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">random</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> random.nextInt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Benchmark</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">threadLocalRandom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> threadLocalRandom.nextInt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> RunnerException </span>&#123;</span><br><span class=\"line\">        Options opt = <span class=\"keyword\">new</span> OptionsBuilder()</span><br><span class=\"line\">                .include(Randombenchmark.class.getSimpleName())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Runner(opt).run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">··· 前面一部分省略，主要内容如下</span><br><span class=\"line\">Benchmark                          Mode  Cnt    Score     Error  Units</span><br><span class=\"line\">Randombenchmark.random             avgt    3  349.952 ± 115.007  ns/op</span><br><span class=\"line\">Randombenchmark.threadLocalRandom  avgt    3   26.393 ±  11.538  ns/op</span><br></pre></td></tr></table></figure>\n<p>从上面结果可以看出，结果验证确实ThreadLocalRandom在多线程环境情况下更快，ThreadLocalRandom比Random快了将近13倍之多。</p>\n<p>至于为什么ThreadLocalRandom更快呢，这个要从源码来分析。</p>\n<p>Random的实现也比较简单，初始化的时候用当前的事件来初始化一个随机数种子，然后每次取值的时候用这个种子与有些MagicNumber运算，并更新种子。最核心的就是这个next的函数，不管你是调用了nextDouble还是nextInt还是nextBoolean，Random底层都是调这个next(int bits)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">(<span class=\"keyword\">int</span> bits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> oldseed, nextseed;</span><br><span class=\"line\">    AtomicLong seed = <span class=\"keyword\">this</span>.seed;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        oldseed = seed.get();</span><br><span class=\"line\">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)(nextseed &gt;&gt;&gt; (<span class=\"number\">48</span> - bits));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>　　为了保证多线程下每次生成随机数都是用的不同，next()得保证seed的更新是原子操作，所以用了AtomicLong的compareAndSet()，该方法底层调用了sum.misc.Unsafe的compareAndSwapLong()，也就是大家常听到的CAS， 这是一个native方法，它能保证原子更新一个数。</p>\n<p>既然Random是线程安全的，又能满足我们大多说的要求，为什么concurrent包里还要实现一个ThreadLocalRandom。在oracle的jdk文档里发现这样一句话</p>\n<blockquote>\n<p>use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.</p>\n</blockquote>\n<p>大意就是用ThreadLocalRandom更适合用在多线程下，能大幅减少多线程并行下的性能开销和资源争抢。</p>\n<p>　既然ThreadLocalRandom在多线程下表现这么牛逼，它究竟是如何做到的？我们来看下源码，它的核心代码是这个（在看源码时需要注意一点，虽然ThreadLocalRandom也实现了next函数，但是在这个函数上面有一句，定义了这个方法，但绝不使用，你也可以从next*方法里面看出，使用的都是mix32(nextSeed)或者mix64(nextSeed)来获取随机数）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">long</span> <span class=\"title\">nextSeed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t; <span class=\"keyword\">long</span> r; <span class=\"comment\">// read and update per-thread seed</span></span><br><span class=\"line\">    UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class=\"line\">                   r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面虽然使用了UNSAFE对象，但是没有调用CAS方法，只是简单的替换Thread对象中的threadLocalRandomSeed属性，所以不要一看到UNSAFE这个类，就当成要调用CAS方法，我刚开始阅读的时候就有这个疑惑，自己太菜了。</p>\n<p>在创建ThreadLocalRandom对象时，ThreadLocalRandom是对每个线程都设置了单独的随机数种子，这样就不会发生多线程同时更新一个数时产生的资源争抢了，用空间换时间。</p>\n<h3 id=\"3-补充\"><a href=\"#3-补充\" class=\"headerlink\" title=\"3. 补充\"></a>3. 补充</h3><p>在生成验证码的情况下，不要使用Random，因为它是线性可预测的。所以在安全性要求比较高的场合，应当使用SecureRandom。从理论上来说计算机产生的随机数都是伪随机数，要想<strong>产生高强度的随机数，有两个重要的因素：种子和算法。当然算法是可以有很多的，但是如何选择种子是非常关键的因素。如Random，它的种子是System.currentTimeMillis()，所以它的随机数都是可预测的。那么如何得到一个近似随机的种子？这里有一个很别致的思路：收集计算机的各种信息，如键盘输入时间，CPU时钟，内存使用状态，硬盘空闲空间，IO延时，进程数量，线程数量等信息，来得到一个近似随机的种子。这样的话，除了理论上有破解的可能，实际上基本没有被破解的可能。而事实上，现在的高强度的随机数生成器都是这样实现的。</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://xindoo.me/article/1400\" target=\"_blank\" rel=\"noopener\">https://xindoo.me/article/1400</a></li>\n<li><a href=\"https://blog.csdn.net/huqinweI987/article/details/70941199\" target=\"_blank\" rel=\"noopener\">C 位操作 左移32位 错误</a> 这个是我在进行源码研究时，发先自己int类型的说移动32位还是原数子，从这篇文章找到了答案</li>\n<li><a href=\"https://www.cnkirito.moe/java-random/\" target=\"_blank\" rel=\"noopener\">Java并发计数器探秘</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h1 id=\"Random-与-ThreadLocalRandom-对比\"><a href=\"#Random-与-ThreadLocalRandom-对比\" class=\"headerlink\" title=\"Random 与 ThreadLocalRandom 对比\"></a>Random 与 ThreadLocalRandom 对比</h1><ol>\n<li>简介</li>\n<li>测试结果与分析</li>\n<li>补充</li>\n</ol>\n<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>首先，如果你看到这篇文章相信对这俩个类有一定的了解，所以我就不再这里介绍具体的用法。简单的介绍一下这个类，Random，ThreadLocalRandom是Java中的随机数生成器，Random是我们比较常用的随机数生成器，他是线程安全的。ThreadLocalRandom是jdk7才出现的，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，同时也能保证线程安全和提高性能。</p>\n<p>由于本人能力有限，如果你的英文比较好，可以看看StackOverFlow上的这个讨论<a href=\"https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/23396033/random-over-threadlocalrandom</a></p>\n<h3 id=\"2-测试结果与分析\"><a href=\"#2-测试结果与分析\" class=\"headerlink\" title=\"2. 测试结果与分析\"></a>2. 测试结果与分析</h3><p>我使用的JMH来进行的压测，这篇文章可以帮助你<a href=\"https://www.cnkirito.moe/java-jmh/\" target=\"_blank\" rel=\"noopener\">入门 JMH</a>。具体代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**************************************</span></span><br><span class=\"line\"><span class=\"comment\"> *      Author : zhangke</span></span><br><span class=\"line\"><span class=\"comment\"> *      Date   : 2018-12-12 11:44</span></span><br><span class=\"line\"><span class=\"comment\"> *      email  : 398757724@qq.com</span></span><br><span class=\"line\"><span class=\"comment\"> *      Desc   : ThreadRandom 和 Random性能对比</span></span><br><span class=\"line\"><span class=\"comment\"> ***************************************/</span></span><br><span class=\"line\"><span class=\"meta\">@BenchmarkMode</span>(&#123;Mode.AverageTime&#125;)</span><br><span class=\"line\"><span class=\"meta\">@OutputTimeUnit</span>(TimeUnit.NANOSECONDS)</span><br><span class=\"line\"><span class=\"meta\">@Warmup</span>(iterations = <span class=\"number\">3</span>, time = <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"meta\">@Measurement</span>(iterations = <span class=\"number\">3</span>, time = <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"meta\">@Threads</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"meta\">@Fork</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">@State</span>(Scope.Benchmark)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Randombenchmark</span> </span>&#123;</span><br><span class=\"line\">    Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Benchmark</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">random</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> random.nextInt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Benchmark</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">threadLocalRandom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> threadLocalRandom.nextInt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> RunnerException </span>&#123;</span><br><span class=\"line\">        Options opt = <span class=\"keyword\">new</span> OptionsBuilder()</span><br><span class=\"line\">                .include(Randombenchmark.class.getSimpleName())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Runner(opt).run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">··· 前面一部分省略，主要内容如下</span><br><span class=\"line\">Benchmark                          Mode  Cnt    Score     Error  Units</span><br><span class=\"line\">Randombenchmark.random             avgt    3  349.952 ± 115.007  ns/op</span><br><span class=\"line\">Randombenchmark.threadLocalRandom  avgt    3   26.393 ±  11.538  ns/op</span><br></pre></td></tr></table></figure>\n<p>从上面结果可以看出，结果验证确实ThreadLocalRandom在多线程环境情况下更快，ThreadLocalRandom比Random快了将近13倍之多。</p>\n<p>至于为什么ThreadLocalRandom更快呢，这个要从源码来分析。</p>\n<p>Random的实现也比较简单，初始化的时候用当前的事件来初始化一个随机数种子，然后每次取值的时候用这个种子与有些MagicNumber运算，并更新种子。最核心的就是这个next的函数，不管你是调用了nextDouble还是nextInt还是nextBoolean，Random底层都是调这个next(int bits)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">(<span class=\"keyword\">int</span> bits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> oldseed, nextseed;</span><br><span class=\"line\">    AtomicLong seed = <span class=\"keyword\">this</span>.seed;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        oldseed = seed.get();</span><br><span class=\"line\">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)(nextseed &gt;&gt;&gt; (<span class=\"number\">48</span> - bits));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>　　为了保证多线程下每次生成随机数都是用的不同，next()得保证seed的更新是原子操作，所以用了AtomicLong的compareAndSet()，该方法底层调用了sum.misc.Unsafe的compareAndSwapLong()，也就是大家常听到的CAS， 这是一个native方法，它能保证原子更新一个数。</p>\n<p>既然Random是线程安全的，又能满足我们大多说的要求，为什么concurrent包里还要实现一个ThreadLocalRandom。在oracle的jdk文档里发现这样一句话</p>\n<blockquote>\n<p>use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.</p>\n</blockquote>\n<p>大意就是用ThreadLocalRandom更适合用在多线程下，能大幅减少多线程并行下的性能开销和资源争抢。</p>\n<p>　既然ThreadLocalRandom在多线程下表现这么牛逼，它究竟是如何做到的？我们来看下源码，它的核心代码是这个（在看源码时需要注意一点，虽然ThreadLocalRandom也实现了next函数，但是在这个函数上面有一句，定义了这个方法，但绝不使用，你也可以从next*方法里面看出，使用的都是mix32(nextSeed)或者mix64(nextSeed)来获取随机数）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">long</span> <span class=\"title\">nextSeed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t; <span class=\"keyword\">long</span> r; <span class=\"comment\">// read and update per-thread seed</span></span><br><span class=\"line\">    UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class=\"line\">                   r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面虽然使用了UNSAFE对象，但是没有调用CAS方法，只是简单的替换Thread对象中的threadLocalRandomSeed属性，所以不要一看到UNSAFE这个类，就当成要调用CAS方法，我刚开始阅读的时候就有这个疑惑，自己太菜了。</p>\n<p>在创建ThreadLocalRandom对象时，ThreadLocalRandom是对每个线程都设置了单独的随机数种子，这样就不会发生多线程同时更新一个数时产生的资源争抢了，用空间换时间。</p>\n<h3 id=\"3-补充\"><a href=\"#3-补充\" class=\"headerlink\" title=\"3. 补充\"></a>3. 补充</h3><p>在生成验证码的情况下，不要使用Random，因为它是线性可预测的。所以在安全性要求比较高的场合，应当使用SecureRandom。从理论上来说计算机产生的随机数都是伪随机数，要想<strong>产生高强度的随机数，有两个重要的因素：种子和算法。当然算法是可以有很多的，但是如何选择种子是非常关键的因素。如Random，它的种子是System.currentTimeMillis()，所以它的随机数都是可预测的。那么如何得到一个近似随机的种子？这里有一个很别致的思路：收集计算机的各种信息，如键盘输入时间，CPU时钟，内存使用状态，硬盘空闲空间，IO延时，进程数量，线程数量等信息，来得到一个近似随机的种子。这样的话，除了理论上有破解的可能，实际上基本没有被破解的可能。而事实上，现在的高强度的随机数生成器都是这样实现的。</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://xindoo.me/article/1400\" target=\"_blank\" rel=\"noopener\">https://xindoo.me/article/1400</a></li>\n<li><a href=\"https://blog.csdn.net/huqinweI987/article/details/70941199\" target=\"_blank\" rel=\"noopener\">C 位操作 左移32位 错误</a> 这个是我在进行源码研究时，发先自己int类型的说移动32位还是原数子，从这篇文章找到了答案</li>\n<li><a href=\"https://www.cnkirito.moe/java-random/\" target=\"_blank\" rel=\"noopener\">Java并发计数器探秘</a></li>\n</ol>\n"},{"title":"LockSupport","author":"zhangke","date":"2018-12-13T07:21:00.000Z","_content":"\n---\n# LockSupport\n\n### 概述\n\n1. 用法简介\n2. 源码分析\n3. 底层实现原理\n\n### 1. 用法简介\n\nLockSupport是用来创建锁和其他同步类的基本**线程阻塞**原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。\n\npark()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。\n\n如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。\n\n需要特别注意的一点：**park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法**。从这个意义上说，park 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 unpark 配对使用才更高效。\n\n官方推介的使用方式如下\n\n```java\nwhile(!canprocess()){\n    ....\n    LockSupport.park(this);\n}\n```\n\n\n\n三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。\n看下线程dump的结果来理解blocker的作用。\n\n![线程dump结果对比](https://segmentfault.com/img/bVJuIP?w=783&h=375)\n\n从线程dump结果可以看出：\n有blocker的可以传递给开发人员更多的现场信息，可以查看到当前线程的阻塞对象，方便定位问题。所以java6新增加带blocker入参的系列park方法，替代原有的park方法。\n\n#### demo1\n\n看一个Java docs中的示例用法：一个先进先出非重入锁类的框架\n\n```java\nclass FIFOMutex {\n    private final AtomicBoolean locked = new AtomicBoolean(false);\n    private final Queue<Thread> waiters\n      = new ConcurrentLinkedQueue<Thread>();\n \n    public void lock() {\n      boolean wasInterrupted = false;\n      Thread current = Thread.currentThread();\n      waiters.add(current);\n \n      // Block while not first in queue or cannot acquire lock\n      while (waiters.peek() != current ||\n             !locked.compareAndSet(false, true)) {\n        LockSupport.park(this);\n        if (Thread.interrupted()) // ignore interrupts while waiting\n          wasInterrupted = true;\n      }\n\n      waiters.remove();\n      if (wasInterrupted)          // reassert interrupt status on exit\n        current.interrupt();\n    }\n \n    public void unlock() {\n      locked.set(false);\n      LockSupport.unpark(waiters.peek());\n    }\n  }}\n  \n  //具体使用\n  public class LockSupportDemo {\n    public static void main(String[] args) throws InterruptedException {\n        final FIFOMutex lock = new FIFOMutex();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    private static Runnable generateTask(final FIFOMutex lock, \n    \t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n运行结果\n\n```\nThread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n从结果可以看出，运行结果可以看出，确实是先进先出类型的锁，同时也验证了没有俩个线程同时获取修改list的时机，因为如果同时修改List回抛出异常，这里没有。从侧面验证了锁的正确性\n\n#### demo2 \n\n验证一下，在park之前多次调用unpark，是否会累加\n\n```\npublic class LockSupportStudy2 {\n\n    public static void main(String[] args) {\n        //在park之前不管有多少个unpark，都只能释放一个park\n        LockSupport.unpark(Thread.currentThread());\n        LockSupport.unpark(Thread.currentThread());\n        System.out.println(\"暂停线程\");\n        LockSupport.park();\n        System.out.println(\"线程继续\");\n        LockSupport.park();\n        System.out.println(\"线程继续\");\n    }\n}\n```\n\n运行结果\n\n```\n暂停线程\n线程继续\n。。。。。\n```\n\n从实验结果可以看出，不管在park之前调用了多少次的unpark，只会唤醒一次相应的线程阻塞。\n\n另外这个实验可以看出park和unpark的先后顺序是不重要的，因此park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。\n\n### 2. 源码分析\n\n1. LockSupport中主要的两个成员变量：\n\n```\n\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long parkBlockerOffset;\n```\n\nunsafe:全名sun.misc.Unsafe可以直接操控内存，被JDK广泛用于自己的包中，如java.nio和java.util.concurrent。但是不建议在生产环境中使用这个类。因为这个API十分不安全、不轻便、而且不稳定。\nLockSupport的方法底层都是调用Unsafe的方法实现。\n\n再来看parkBlockerOffset:\nparkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。\n\n```\n static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> tk = Thread.class;\n            parkBlockerOffset = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(\"parkBlocker\"));\n        } catch (Exception ex) { throw new Error(ex); }\n }\n```\n\n从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.\n\nJVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。\n\n为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？\n仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。\n\n2.LockSupport的方法：\n\n```\npublic static  Object getBlocker(Thread t)\npublic static  void park()\npublic static  void park(Object blocker)\npublic static  void parkNanos(long nanos)\npublic static  void parkNanos(Object blocker, long nanos)\npublic static  void parkUntil(long deadline)\npublic static  void parkUntil(Object blocker, long deadline)\n```\n\n\n\n可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。\n\n```\n private static void setBlocker(Thread t, Object arg) {\n        // Even though volatile, hotspot doesn't need a write barrier here.\n        UNSAFE.putObject(t, parkBlockerOffset, arg);\n  }\n```\n\n对给定线程t的parkBlocker赋值。\n\n```\n    public static Object getBlocker(Thread t) {\n        if (t == null)\n            throw new NullPointerException();\n        return UNSAFE.getObjectVolatile(t, parkBlockerOffset);\n    }\n  \n```\n\n从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。\n\n接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法\n\n**阻塞线程**\n\n- park()\n\n```\npublic static void park() {\n        UNSAFE.park(false, 0L);\n}\n```\n\n调用native方法阻塞当前线程。\n\n- parkNanos(long nanos)\n\n```\npublic static void parkNanos(long nanos) {\n        if (nanos > 0)\n            UNSAFE.park(false, nanos);\n}\n```\n\n阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。\n\n- parkUntil(long deadline)\n\n```\npublic static void parkUntil(long deadline) {\n  UNSAFE.park(true, deadline);\n}\n```\n\n阻塞当前线程，知道deadline时间（deadline - 毫秒数）。\n\nJDK1.6引入这三个方法对应的拥有Blocker版本。\n\n- park(Object blocker)\n\n```\npublic static void park(Object blocker) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(false, 0L);\n  setBlocker(t, null);\n}\n```\n\n1) 记录当前线程等待的对象（阻塞对象）；\n2) 阻塞当前线程；\n3) 当前线程等待对象置为null。\n\n- parkNanos(Object blocker, long nanos)\n\n```\npublic static void parkNanos(Object blocker, long nanos) {\n  if (nanos > 0) {\n      Thread t = Thread.currentThread();\n      setBlocker(t, blocker);\n      UNSAFE.park(false, nanos);\n      setBlocker(t, null);\n  }\n}\n```\n\n阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。\n\n- parkUntil(Object blocker, long deadline)\n\n```\npublic static void parkUntil(Object blocker, long deadline) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(true, deadline);\n  setBlocker(t, null);\n}\n```\n\n阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。\n\n**唤醒线程**\n\n- unpark(Thread thread)\n\n```\npublic static void unpark(Thread thread) {\n  if (thread != null)\n      UNSAFE.unpark(thread);\n}\n```\n\n唤醒处于阻塞状态的线程Thread。\n\n### 3. 底层实现原理\n\n从LockSupport源码可以看出，park和unpark的实现都是调用Unsafe.park和Unsafe.unpark，因此只要找到这俩个的底层实现原理，就可以明白park和unpark的底层实现。\n\n#### HotSpot 里 park/unpark 的实现\n\n每个 java 线程都有一个 Parker 实例，Parker 类是这样定义的：\n\n```\nclass Parker : public os::PlatformParker {\nprivate:\n  volatile int _counter ;\n  ...\npublic:\n  void park(bool isAbsolute, jlong time);\n  void unpark();\n  ...\n}\nclass PlatformParker : public CHeapObj<mtInternal> {\n  protected:\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [1] ;\n    ...\n}\n```\n\n可以看到 Parker 类实际上用 Posix 的 mutex，condition 来实现的。\n\n在 Parker 类里的_counter 字段，就是用来记录所谓的 “许可” 的。\n\n当调用 park 时，先尝试直接能否直接拿到 “许可”，即_counter>0 时，如果成功，则把_counter 设置为 0, 并返回：\n\n```\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &_counter) > 0) return;\n```\n\n如果不成功，则构造一个 ThreadBlockInVM，然后检查_counter 是不是 > 0，如果是，则把_counter 设置为 0，unlock mutex 并返回：\n\n```\n  ThreadBlockInVM tbivm(jt);\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n```\n\n否则，再判断等待的时间，然后再调用 pthread_cond_wait 函数等待，如果等待返回，则把_counter 设置为 0，unlock mutex 并返回\n\n```\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  OrderAccess::fence();\n```\n\n当 unpark 时，则简单多了，直接设置_counter 为 1，再 unlock mutext 返回。如果_counter 之前的值是 0，则还要调用 pthread_cond_signal 唤醒在 park 中等待的线程\n\n```\nvoid Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n     if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") ;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n     } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") \n     }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n```\n\n简而言之，是用 mutex 和 condition 保护了一个_counter 的变量，当 park 时，这个变量置为了 0，当 unpark 时，这个变量置为 1。\n\n值得注意的是在 park 函数里，调用 pthread_cond_wait 时，并没有用 while 来判断，所以 posix condition 里的 \"Spurious wakeup\" 一样会传递到上层 Java 的代码里，这也是官方为什么推介使用while方式的原因。\n\n关于 \"Spurious wakeup\"，参考这篇文章：[Why does pthread_cond_wait have spurious wakeups?](https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups)\n\n不过在看这篇文章之前，最好看看《Unix环境高级编程》这本书第11章节\n\n```\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n```\n\n这也就是为什么 Java dos 里提到，当下面三种情况下 park 函数会返回：\n\n- Some other thread invokes unpark with the current thread as the target; or\n- Some other thread interrupts the current thread; or\n- **The call spuriously (that is, for no reason) returns.**\n\n相关的实现代码在：\n\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp\n\n### 参考\n\n1. [浅谈Java并发编程系列（八）—— LockSupport原理剖析](https://segmentfault.com/a/1190000008420938)\n2. [并行编程之条件变量（posix condition variables）](https://blog.csdn.net/hengyunabc/article/details/27969613)\n3. [Java的LockSupport.park()实现分析](https://blog.csdn.net/hengyunabc/article/details/28126139)","source":"_posts/LockSupport.md","raw":"title: LockSupport\ntags:\n  - JUC\ncategories:\n  - java\nauthor: zhangke\ndate: 2018-12-13 15:21:00\n---\n\n---\n# LockSupport\n\n### 概述\n\n1. 用法简介\n2. 源码分析\n3. 底层实现原理\n\n### 1. 用法简介\n\nLockSupport是用来创建锁和其他同步类的基本**线程阻塞**原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。\n\npark()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。\n\n如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。\n\n需要特别注意的一点：**park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法**。从这个意义上说，park 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 unpark 配对使用才更高效。\n\n官方推介的使用方式如下\n\n```java\nwhile(!canprocess()){\n    ....\n    LockSupport.park(this);\n}\n```\n\n\n\n三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。\n看下线程dump的结果来理解blocker的作用。\n\n![线程dump结果对比](https://segmentfault.com/img/bVJuIP?w=783&h=375)\n\n从线程dump结果可以看出：\n有blocker的可以传递给开发人员更多的现场信息，可以查看到当前线程的阻塞对象，方便定位问题。所以java6新增加带blocker入参的系列park方法，替代原有的park方法。\n\n#### demo1\n\n看一个Java docs中的示例用法：一个先进先出非重入锁类的框架\n\n```java\nclass FIFOMutex {\n    private final AtomicBoolean locked = new AtomicBoolean(false);\n    private final Queue<Thread> waiters\n      = new ConcurrentLinkedQueue<Thread>();\n \n    public void lock() {\n      boolean wasInterrupted = false;\n      Thread current = Thread.currentThread();\n      waiters.add(current);\n \n      // Block while not first in queue or cannot acquire lock\n      while (waiters.peek() != current ||\n             !locked.compareAndSet(false, true)) {\n        LockSupport.park(this);\n        if (Thread.interrupted()) // ignore interrupts while waiting\n          wasInterrupted = true;\n      }\n\n      waiters.remove();\n      if (wasInterrupted)          // reassert interrupt status on exit\n        current.interrupt();\n    }\n \n    public void unlock() {\n      locked.set(false);\n      LockSupport.unpark(waiters.peek());\n    }\n  }}\n  \n  //具体使用\n  public class LockSupportDemo {\n    public static void main(String[] args) throws InterruptedException {\n        final FIFOMutex lock = new FIFOMutex();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(generateTask(lock, String.valueOf(i), list)).start();\n        }\n        countDownLatch.await();\n        System.out.println(list);\n    }\n\n\n    static CountDownLatch countDownLatch = new CountDownLatch(10);\n\n    static List<String> list = new ArrayList<>();\n\n\n    private static Runnable generateTask(final FIFOMutex lock, \n    \t\t\t\tfinal String taskId, final List<String> list) {\n        return () -> {\n            lock.lock();\n            try {\n                Thread.sleep(300);\n                list.add(taskId);\n\n            } catch (Exception e) {\n\n            }\n            String s = list.toString();\n            System.out.println(String.format(\"Thread %s Completed %s\", taskId, s));\n            lock.unLock();\n            countDownLatch.countDown();\n        };\n    }\n}\n```\n\n运行结果\n\n```\nThread 0 Completed [0]\nThread 1 Completed [0, 1]\nThread 2 Completed [0, 1, 2]\nThread 3 Completed [0, 1, 2, 3]\nThread 4 Completed [0, 1, 2, 3, 4]\nThread 5 Completed [0, 1, 2, 3, 4, 5]\nThread 6 Completed [0, 1, 2, 3, 4, 5, 6]\nThread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]\nThread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]\nThread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n从结果可以看出，运行结果可以看出，确实是先进先出类型的锁，同时也验证了没有俩个线程同时获取修改list的时机，因为如果同时修改List回抛出异常，这里没有。从侧面验证了锁的正确性\n\n#### demo2 \n\n验证一下，在park之前多次调用unpark，是否会累加\n\n```\npublic class LockSupportStudy2 {\n\n    public static void main(String[] args) {\n        //在park之前不管有多少个unpark，都只能释放一个park\n        LockSupport.unpark(Thread.currentThread());\n        LockSupport.unpark(Thread.currentThread());\n        System.out.println(\"暂停线程\");\n        LockSupport.park();\n        System.out.println(\"线程继续\");\n        LockSupport.park();\n        System.out.println(\"线程继续\");\n    }\n}\n```\n\n运行结果\n\n```\n暂停线程\n线程继续\n。。。。。\n```\n\n从实验结果可以看出，不管在park之前调用了多少次的unpark，只会唤醒一次相应的线程阻塞。\n\n另外这个实验可以看出park和unpark的先后顺序是不重要的，因此park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。\n\n### 2. 源码分析\n\n1. LockSupport中主要的两个成员变量：\n\n```\n\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long parkBlockerOffset;\n```\n\nunsafe:全名sun.misc.Unsafe可以直接操控内存，被JDK广泛用于自己的包中，如java.nio和java.util.concurrent。但是不建议在生产环境中使用这个类。因为这个API十分不安全、不轻便、而且不稳定。\nLockSupport的方法底层都是调用Unsafe的方法实现。\n\n再来看parkBlockerOffset:\nparkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。\n\n```\n static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> tk = Thread.class;\n            parkBlockerOffset = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(\"parkBlocker\"));\n        } catch (Exception ex) { throw new Error(ex); }\n }\n```\n\n从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.\n\nJVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。\n\n为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？\n仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。\n\n2.LockSupport的方法：\n\n```\npublic static  Object getBlocker(Thread t)\npublic static  void park()\npublic static  void park(Object blocker)\npublic static  void parkNanos(long nanos)\npublic static  void parkNanos(Object blocker, long nanos)\npublic static  void parkUntil(long deadline)\npublic static  void parkUntil(Object blocker, long deadline)\n```\n\n\n\n可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。\n\n```\n private static void setBlocker(Thread t, Object arg) {\n        // Even though volatile, hotspot doesn't need a write barrier here.\n        UNSAFE.putObject(t, parkBlockerOffset, arg);\n  }\n```\n\n对给定线程t的parkBlocker赋值。\n\n```\n    public static Object getBlocker(Thread t) {\n        if (t == null)\n            throw new NullPointerException();\n        return UNSAFE.getObjectVolatile(t, parkBlockerOffset);\n    }\n  \n```\n\n从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。\n\n接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法\n\n**阻塞线程**\n\n- park()\n\n```\npublic static void park() {\n        UNSAFE.park(false, 0L);\n}\n```\n\n调用native方法阻塞当前线程。\n\n- parkNanos(long nanos)\n\n```\npublic static void parkNanos(long nanos) {\n        if (nanos > 0)\n            UNSAFE.park(false, nanos);\n}\n```\n\n阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。\n\n- parkUntil(long deadline)\n\n```\npublic static void parkUntil(long deadline) {\n  UNSAFE.park(true, deadline);\n}\n```\n\n阻塞当前线程，知道deadline时间（deadline - 毫秒数）。\n\nJDK1.6引入这三个方法对应的拥有Blocker版本。\n\n- park(Object blocker)\n\n```\npublic static void park(Object blocker) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(false, 0L);\n  setBlocker(t, null);\n}\n```\n\n1) 记录当前线程等待的对象（阻塞对象）；\n2) 阻塞当前线程；\n3) 当前线程等待对象置为null。\n\n- parkNanos(Object blocker, long nanos)\n\n```\npublic static void parkNanos(Object blocker, long nanos) {\n  if (nanos > 0) {\n      Thread t = Thread.currentThread();\n      setBlocker(t, blocker);\n      UNSAFE.park(false, nanos);\n      setBlocker(t, null);\n  }\n}\n```\n\n阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。\n\n- parkUntil(Object blocker, long deadline)\n\n```\npublic static void parkUntil(Object blocker, long deadline) {\n  Thread t = Thread.currentThread();\n  setBlocker(t, blocker);\n  UNSAFE.park(true, deadline);\n  setBlocker(t, null);\n}\n```\n\n阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。\n\n**唤醒线程**\n\n- unpark(Thread thread)\n\n```\npublic static void unpark(Thread thread) {\n  if (thread != null)\n      UNSAFE.unpark(thread);\n}\n```\n\n唤醒处于阻塞状态的线程Thread。\n\n### 3. 底层实现原理\n\n从LockSupport源码可以看出，park和unpark的实现都是调用Unsafe.park和Unsafe.unpark，因此只要找到这俩个的底层实现原理，就可以明白park和unpark的底层实现。\n\n#### HotSpot 里 park/unpark 的实现\n\n每个 java 线程都有一个 Parker 实例，Parker 类是这样定义的：\n\n```\nclass Parker : public os::PlatformParker {\nprivate:\n  volatile int _counter ;\n  ...\npublic:\n  void park(bool isAbsolute, jlong time);\n  void unpark();\n  ...\n}\nclass PlatformParker : public CHeapObj<mtInternal> {\n  protected:\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [1] ;\n    ...\n}\n```\n\n可以看到 Parker 类实际上用 Posix 的 mutex，condition 来实现的。\n\n在 Parker 类里的_counter 字段，就是用来记录所谓的 “许可” 的。\n\n当调用 park 时，先尝试直接能否直接拿到 “许可”，即_counter>0 时，如果成功，则把_counter 设置为 0, 并返回：\n\n```\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &_counter) > 0) return;\n```\n\n如果不成功，则构造一个 ThreadBlockInVM，然后检查_counter 是不是 > 0，如果是，则把_counter 设置为 0，unlock mutex 并返回：\n\n```\n  ThreadBlockInVM tbivm(jt);\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n```\n\n否则，再判断等待的时间，然后再调用 pthread_cond_wait 函数等待，如果等待返回，则把_counter 设置为 0，unlock mutex 并返回\n\n```\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  OrderAccess::fence();\n```\n\n当 unpark 时，则简单多了，直接设置_counter 为 1，再 unlock mutext 返回。如果_counter 之前的值是 0，则还要调用 pthread_cond_signal 唤醒在 park 中等待的线程\n\n```\nvoid Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n     if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") ;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n     } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") \n     }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n```\n\n简而言之，是用 mutex 和 condition 保护了一个_counter 的变量，当 park 时，这个变量置为了 0，当 unpark 时，这个变量置为 1。\n\n值得注意的是在 park 函数里，调用 pthread_cond_wait 时，并没有用 while 来判断，所以 posix condition 里的 \"Spurious wakeup\" 一样会传递到上层 Java 的代码里，这也是官方为什么推介使用while方式的原因。\n\n关于 \"Spurious wakeup\"，参考这篇文章：[Why does pthread_cond_wait have spurious wakeups?](https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups)\n\n不过在看这篇文章之前，最好看看《Unix环境高级编程》这本书第11章节\n\n```\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  }\n```\n\n这也就是为什么 Java dos 里提到，当下面三种情况下 park 函数会返回：\n\n- Some other thread invokes unpark with the current thread as the target; or\n- Some other thread interrupts the current thread; or\n- **The call spuriously (that is, for no reason) returns.**\n\n相关的实现代码在：\n\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp\nhttp://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp\n\n### 参考\n\n1. [浅谈Java并发编程系列（八）—— LockSupport原理剖析](https://segmentfault.com/a/1190000008420938)\n2. [并行编程之条件变量（posix condition variables）](https://blog.csdn.net/hengyunabc/article/details/27969613)\n3. [Java的LockSupport.park()实现分析](https://blog.csdn.net/hengyunabc/article/details/28126139)","slug":"LockSupport","published":1,"updated":"2019-01-02T05:29:40.987Z","_id":"cjqeqq73z000fhj1u6apip25u","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<h1 id=\"LockSupport\"><a href=\"#LockSupport\" class=\"headerlink\" title=\"LockSupport\"></a>LockSupport</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>用法简介</li>\n<li>源码分析</li>\n<li>底层实现原理</li>\n</ol>\n<h3 id=\"1-用法简介\"><a href=\"#1-用法简介\" class=\"headerlink\" title=\"1. 用法简介\"></a>1. 用法简介</h3><p>LockSupport是用来创建锁和其他同步类的基本<strong>线程阻塞</strong>原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。</p>\n<p>park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p>\n<p>如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。</p>\n<p>需要特别注意的一点：<strong>park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法</strong>。从这个意义上说，park 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 unpark 配对使用才更高效。</p>\n<p>官方推介的使用方式如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(!canprocess())&#123;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。<br>看下线程dump的结果来理解blocker的作用。</p>\n<p><img src=\"https://segmentfault.com/img/bVJuIP?w=783&amp;h=375\" alt=\"线程dump结果对比\"></p>\n<p>从线程dump结果可以看出：<br>有blocker的可以传递给开发人员更多的现场信息，可以查看到当前线程的阻塞对象，方便定位问题。所以java6新增加带blocker入参的系列park方法，替代原有的park方法。</p>\n<h4 id=\"demo1\"><a href=\"#demo1\" class=\"headerlink\" title=\"demo1\"></a>demo1</h4><p>看一个Java docs中的示例用法：一个先进先出非重入锁类的框架</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FIFOMutex</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicBoolean locked = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Queue&lt;Thread&gt; waiters</span><br><span class=\"line\">      = <span class=\"keyword\">new</span> ConcurrentLinkedQueue&lt;Thread&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> wasInterrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      Thread current = Thread.currentThread();</span><br><span class=\"line\">      waiters.add(current);</span><br><span class=\"line\"> </span><br><span class=\"line\">      <span class=\"comment\">// Block while not first in queue or cannot acquire lock</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (waiters.peek() != current ||</span><br><span class=\"line\">             !locked.compareAndSet(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.interrupted()) <span class=\"comment\">// ignore interrupts while waiting</span></span><br><span class=\"line\">          wasInterrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      waiters.remove();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (wasInterrupted)          <span class=\"comment\">// reassert interrupt status on exit</span></span><br><span class=\"line\">        current.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      locked.set(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">      LockSupport.unpark(waiters.peek());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//具体使用</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LockSupportDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> FIFOMutex lock = <span class=\"keyword\">new</span> FIFOMutex();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(generateTask(lock, String.valueOf(i), list)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Runnable <span class=\"title\">generateTask</span><span class=\"params\">(<span class=\"keyword\">final</span> FIFOMutex lock, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    \t\t\t\t<span class=\"keyword\">final</span> String taskId, <span class=\"keyword\">final</span> List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> () -&gt; &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">                list.add(taskId);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String s = list.toString();</span><br><span class=\"line\">            System.out.println(String.format(<span class=\"string\">\"Thread %s Completed %s\"</span>, taskId, s));</span><br><span class=\"line\">            lock.unLock();</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread 0 Completed [0]</span><br><span class=\"line\">Thread 1 Completed [0, 1]</span><br><span class=\"line\">Thread 2 Completed [0, 1, 2]</span><br><span class=\"line\">Thread 3 Completed [0, 1, 2, 3]</span><br><span class=\"line\">Thread 4 Completed [0, 1, 2, 3, 4]</span><br><span class=\"line\">Thread 5 Completed [0, 1, 2, 3, 4, 5]</span><br><span class=\"line\">Thread 6 Completed [0, 1, 2, 3, 4, 5, 6]</span><br><span class=\"line\">Thread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]</span><br><span class=\"line\">Thread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]</span><br><span class=\"line\">Thread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>\n<p>从结果可以看出，运行结果可以看出，确实是先进先出类型的锁，同时也验证了没有俩个线程同时获取修改list的时机，因为如果同时修改List回抛出异常，这里没有。从侧面验证了锁的正确性</p>\n<h4 id=\"demo2\"><a href=\"#demo2\" class=\"headerlink\" title=\"demo2\"></a>demo2</h4><p>验证一下，在park之前多次调用unpark，是否会累加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LockSupportStudy2 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //在park之前不管有多少个unpark，都只能释放一个park</span><br><span class=\"line\">        LockSupport.unpark(Thread.currentThread());</span><br><span class=\"line\">        LockSupport.unpark(Thread.currentThread());</span><br><span class=\"line\">        System.out.println(&quot;暂停线程&quot;);</span><br><span class=\"line\">        LockSupport.park();</span><br><span class=\"line\">        System.out.println(&quot;线程继续&quot;);</span><br><span class=\"line\">        LockSupport.park();</span><br><span class=\"line\">        System.out.println(&quot;线程继续&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">暂停线程</span><br><span class=\"line\">线程继续</span><br><span class=\"line\">。。。。。</span><br></pre></td></tr></table></figure>\n<p>从实验结果可以看出，不管在park之前调用了多少次的unpark，只会唤醒一次相应的线程阻塞。</p>\n<p>另外这个实验可以看出park和unpark的先后顺序是不重要的，因此park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p>\n<h3 id=\"2-源码分析\"><a href=\"#2-源码分析\" class=\"headerlink\" title=\"2. 源码分析\"></a>2. 源码分析</h3><ol>\n<li>LockSupport中主要的两个成员变量：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">private static final sun.misc.Unsafe UNSAFE;</span><br><span class=\"line\">private static final long parkBlockerOffset;</span><br></pre></td></tr></table></figure>\n<p>unsafe:全名sun.misc.Unsafe可以直接操控内存，被JDK广泛用于自己的包中，如java.nio和java.util.concurrent。但是不建议在生产环境中使用这个类。因为这个API十分不安全、不轻便、而且不稳定。<br>LockSupport的方法底层都是调用Unsafe的方法实现。</p>\n<p>再来看parkBlockerOffset:<br>parkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static &#123;</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class=\"line\">           Class&lt;?&gt; tk = Thread.class;</span><br><span class=\"line\">           parkBlockerOffset = UNSAFE.objectFieldOffset</span><br><span class=\"line\">               (tk.getDeclaredField(&quot;parkBlocker&quot;));</span><br><span class=\"line\">       &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.</p>\n<p>JVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。</p>\n<p>为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？<br>仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。</p>\n<p>2.LockSupport的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static  Object getBlocker(Thread t)</span><br><span class=\"line\">public static  void park()</span><br><span class=\"line\">public static  void park(Object blocker)</span><br><span class=\"line\">public static  void parkNanos(long nanos)</span><br><span class=\"line\">public static  void parkNanos(Object blocker, long nanos)</span><br><span class=\"line\">public static  void parkUntil(long deadline)</span><br><span class=\"line\">public static  void parkUntil(Object blocker, long deadline)</span><br></pre></td></tr></table></figure>\n<p>可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void setBlocker(Thread t, Object arg) &#123;</span><br><span class=\"line\">       // Even though volatile, hotspot doesn&apos;t need a write barrier here.</span><br><span class=\"line\">       UNSAFE.putObject(t, parkBlockerOffset, arg);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>对给定线程t的parkBlocker赋值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Object getBlocker(Thread t) &#123;</span><br><span class=\"line\">    if (t == null)</span><br><span class=\"line\">        throw new NullPointerException();</span><br><span class=\"line\">    return UNSAFE.getObjectVolatile(t, parkBlockerOffset);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。</p>\n<p>接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法</p>\n<p><strong>阻塞线程</strong></p>\n<ul>\n<li>park()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void park() &#123;</span><br><span class=\"line\">        UNSAFE.park(false, 0L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用native方法阻塞当前线程。</p>\n<ul>\n<li>parkNanos(long nanos)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void parkNanos(long nanos) &#123;</span><br><span class=\"line\">        if (nanos &gt; 0)</span><br><span class=\"line\">            UNSAFE.park(false, nanos);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。</p>\n<ul>\n<li>parkUntil(long deadline)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void parkUntil(long deadline) &#123;</span><br><span class=\"line\">  UNSAFE.park(true, deadline);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>阻塞当前线程，知道deadline时间（deadline - 毫秒数）。</p>\n<p>JDK1.6引入这三个方法对应的拥有Blocker版本。</p>\n<ul>\n<li>park(Object blocker)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void park(Object blocker) &#123;</span><br><span class=\"line\">  Thread t = Thread.currentThread();</span><br><span class=\"line\">  setBlocker(t, blocker);</span><br><span class=\"line\">  UNSAFE.park(false, 0L);</span><br><span class=\"line\">  setBlocker(t, null);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1) 记录当前线程等待的对象（阻塞对象）；<br>2) 阻塞当前线程；<br>3) 当前线程等待对象置为null。</p>\n<ul>\n<li>parkNanos(Object blocker, long nanos)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void parkNanos(Object blocker, long nanos) &#123;</span><br><span class=\"line\">  if (nanos &gt; 0) &#123;</span><br><span class=\"line\">      Thread t = Thread.currentThread();</span><br><span class=\"line\">      setBlocker(t, blocker);</span><br><span class=\"line\">      UNSAFE.park(false, nanos);</span><br><span class=\"line\">      setBlocker(t, null);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。</p>\n<ul>\n<li>parkUntil(Object blocker, long deadline)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void parkUntil(Object blocker, long deadline) &#123;</span><br><span class=\"line\">  Thread t = Thread.currentThread();</span><br><span class=\"line\">  setBlocker(t, blocker);</span><br><span class=\"line\">  UNSAFE.park(true, deadline);</span><br><span class=\"line\">  setBlocker(t, null);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。</p>\n<p><strong>唤醒线程</strong></p>\n<ul>\n<li>unpark(Thread thread)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void unpark(Thread thread) &#123;</span><br><span class=\"line\">  if (thread != null)</span><br><span class=\"line\">      UNSAFE.unpark(thread);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>唤醒处于阻塞状态的线程Thread。</p>\n<h3 id=\"3-底层实现原理\"><a href=\"#3-底层实现原理\" class=\"headerlink\" title=\"3. 底层实现原理\"></a>3. 底层实现原理</h3><p>从LockSupport源码可以看出，park和unpark的实现都是调用Unsafe.park和Unsafe.unpark，因此只要找到这俩个的底层实现原理，就可以明白park和unpark的底层实现。</p>\n<h4 id=\"HotSpot-里-park-unpark-的实现\"><a href=\"#HotSpot-里-park-unpark-的实现\" class=\"headerlink\" title=\"HotSpot 里 park/unpark 的实现\"></a>HotSpot 里 park/unpark 的实现</h4><p>每个 java 线程都有一个 Parker 实例，Parker 类是这样定义的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Parker : public os::PlatformParker &#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">  volatile int _counter ;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">public:</span><br><span class=\"line\">  void park(bool isAbsolute, jlong time);</span><br><span class=\"line\">  void unpark();</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class PlatformParker : public CHeapObj&lt;mtInternal&gt; &#123;</span><br><span class=\"line\">  protected:</span><br><span class=\"line\">    pthread_mutex_t _mutex [1] ;</span><br><span class=\"line\">    pthread_cond_t  _cond  [1] ;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到 Parker 类实际上用 Posix 的 mutex，condition 来实现的。</p>\n<p>在 Parker 类里的_counter 字段，就是用来记录所谓的 “许可” 的。</p>\n<p>当调用 park 时，先尝试直接能否直接拿到 “许可”，即_counter&gt;0 时，如果成功，则把_counter 设置为 0, 并返回：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Parker::park(bool isAbsolute, jlong time) &#123;</span><br><span class=\"line\">  // Ideally we&apos;d do something useful while spinning, such</span><br><span class=\"line\">  // as calling unpackTime().</span><br><span class=\"line\">  // Optional fast-path check:</span><br><span class=\"line\">  // Return immediately if a permit is available.</span><br><span class=\"line\">  // We depend on Atomic::xchg() having full barrier semantics</span><br><span class=\"line\">  // since we are doing a lock-free update to _counter.</span><br><span class=\"line\">  if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;</span><br></pre></td></tr></table></figure>\n<p>如果不成功，则构造一个 ThreadBlockInVM，然后检查_counter 是不是 &gt; 0，如果是，则把_counter 设置为 0，unlock mutex 并返回：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadBlockInVM tbivm(jt);</span><br><span class=\"line\">if (_counter &gt; 0)  &#123; // no wait needed</span><br><span class=\"line\">  _counter = 0;</span><br><span class=\"line\">  status = pthread_mutex_unlock(_mutex);</span><br></pre></td></tr></table></figure>\n<p>否则，再判断等待的时间，然后再调用 pthread_cond_wait 函数等待，如果等待返回，则把_counter 设置为 0，unlock mutex 并返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (time == 0) &#123;</span><br><span class=\"line\">  status = pthread_cond_wait (_cond, _mutex) ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_counter = 0 ;</span><br><span class=\"line\">status = pthread_mutex_unlock(_mutex) ;</span><br><span class=\"line\">assert_status(status == 0, status, &quot;invariant&quot;) ;</span><br><span class=\"line\">OrderAccess::fence();</span><br></pre></td></tr></table></figure>\n<p>当 unpark 时，则简单多了，直接设置_counter 为 1，再 unlock mutext 返回。如果_counter 之前的值是 0，则还要调用 pthread_cond_signal 唤醒在 park 中等待的线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Parker::unpark() &#123;</span><br><span class=\"line\">  int s, status ;</span><br><span class=\"line\">  status = pthread_mutex_lock(_mutex);</span><br><span class=\"line\">  assert (status == 0, &quot;invariant&quot;) ;</span><br><span class=\"line\">  s = _counter;</span><br><span class=\"line\">  _counter = 1;</span><br><span class=\"line\">  if (s &lt; 1) &#123;</span><br><span class=\"line\">     if (WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class=\"line\">        status = pthread_cond_signal (_cond) ;</span><br><span class=\"line\">        assert (status == 0, &quot;invariant&quot;) ;</span><br><span class=\"line\">        status = pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">        assert (status == 0, &quot;invariant&quot;) ;</span><br><span class=\"line\">     &#125; else &#123;</span><br><span class=\"line\">        status = pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">        assert (status == 0, &quot;invariant&quot;) ;</span><br><span class=\"line\">        status = pthread_cond_signal (_cond) ;</span><br><span class=\"line\">        assert (status == 0, &quot;invariant&quot;) </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">    assert (status == 0, &quot;invariant&quot;) ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简而言之，是用 mutex 和 condition 保护了一个_counter 的变量，当 park 时，这个变量置为了 0，当 unpark 时，这个变量置为 1。</p>\n<p>值得注意的是在 park 函数里，调用 pthread_cond_wait 时，并没有用 while 来判断，所以 posix condition 里的 “Spurious wakeup” 一样会传递到上层 Java 的代码里，这也是官方为什么推介使用while方式的原因。</p>\n<p>关于 “Spurious wakeup”，参考这篇文章：<a href=\"https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups\" target=\"_blank\" rel=\"noopener\">Why does pthread_cond_wait have spurious wakeups?</a></p>\n<p>不过在看这篇文章之前，最好看看《Unix环境高级编程》这本书第11章节</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (time == 0) &#123;</span><br><span class=\"line\">  status = pthread_cond_wait (_cond, _mutex) ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这也就是为什么 Java dos 里提到，当下面三种情况下 park 函数会返回：</p>\n<ul>\n<li>Some other thread invokes unpark with the current thread as the target; or</li>\n<li>Some other thread interrupts the current thread; or</li>\n<li><strong>The call spuriously (that is, for no reason) returns.</strong></li>\n</ul>\n<p>相关的实现代码在：</p>\n<p><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp</a></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000008420938\" target=\"_blank\" rel=\"noopener\">浅谈Java并发编程系列（八）—— LockSupport原理剖析</a></li>\n<li><a href=\"https://blog.csdn.net/hengyunabc/article/details/27969613\" target=\"_blank\" rel=\"noopener\">并行编程之条件变量（posix condition variables）</a></li>\n<li><a href=\"https://blog.csdn.net/hengyunabc/article/details/28126139\" target=\"_blank\" rel=\"noopener\">Java的LockSupport.park()实现分析</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h1 id=\"LockSupport\"><a href=\"#LockSupport\" class=\"headerlink\" title=\"LockSupport\"></a>LockSupport</h1><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>用法简介</li>\n<li>源码分析</li>\n<li>底层实现原理</li>\n</ol>\n<h3 id=\"1-用法简介\"><a href=\"#1-用法简介\" class=\"headerlink\" title=\"1. 用法简介\"></a>1. 用法简介</h3><p>LockSupport是用来创建锁和其他同步类的基本<strong>线程阻塞</strong>原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。</p>\n<p>park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p>\n<p>如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。</p>\n<p>需要特别注意的一点：<strong>park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法</strong>。从这个意义上说，park 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 unpark 配对使用才更高效。</p>\n<p>官方推介的使用方式如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(!canprocess())&#123;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。<br>看下线程dump的结果来理解blocker的作用。</p>\n<p><img src=\"https://segmentfault.com/img/bVJuIP?w=783&amp;h=375\" alt=\"线程dump结果对比\"></p>\n<p>从线程dump结果可以看出：<br>有blocker的可以传递给开发人员更多的现场信息，可以查看到当前线程的阻塞对象，方便定位问题。所以java6新增加带blocker入参的系列park方法，替代原有的park方法。</p>\n<h4 id=\"demo1\"><a href=\"#demo1\" class=\"headerlink\" title=\"demo1\"></a>demo1</h4><p>看一个Java docs中的示例用法：一个先进先出非重入锁类的框架</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FIFOMutex</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicBoolean locked = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Queue&lt;Thread&gt; waiters</span><br><span class=\"line\">      = <span class=\"keyword\">new</span> ConcurrentLinkedQueue&lt;Thread&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> wasInterrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      Thread current = Thread.currentThread();</span><br><span class=\"line\">      waiters.add(current);</span><br><span class=\"line\"> </span><br><span class=\"line\">      <span class=\"comment\">// Block while not first in queue or cannot acquire lock</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (waiters.peek() != current ||</span><br><span class=\"line\">             !locked.compareAndSet(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.interrupted()) <span class=\"comment\">// ignore interrupts while waiting</span></span><br><span class=\"line\">          wasInterrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      waiters.remove();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (wasInterrupted)          <span class=\"comment\">// reassert interrupt status on exit</span></span><br><span class=\"line\">        current.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      locked.set(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">      LockSupport.unpark(waiters.peek());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//具体使用</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LockSupportDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> FIFOMutex lock = <span class=\"keyword\">new</span> FIFOMutex();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(generateTask(lock, String.valueOf(i), list)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Runnable <span class=\"title\">generateTask</span><span class=\"params\">(<span class=\"keyword\">final</span> FIFOMutex lock, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    \t\t\t\t<span class=\"keyword\">final</span> String taskId, <span class=\"keyword\">final</span> List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> () -&gt; &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">                list.add(taskId);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String s = list.toString();</span><br><span class=\"line\">            System.out.println(String.format(<span class=\"string\">\"Thread %s Completed %s\"</span>, taskId, s));</span><br><span class=\"line\">            lock.unLock();</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread 0 Completed [0]</span><br><span class=\"line\">Thread 1 Completed [0, 1]</span><br><span class=\"line\">Thread 2 Completed [0, 1, 2]</span><br><span class=\"line\">Thread 3 Completed [0, 1, 2, 3]</span><br><span class=\"line\">Thread 4 Completed [0, 1, 2, 3, 4]</span><br><span class=\"line\">Thread 5 Completed [0, 1, 2, 3, 4, 5]</span><br><span class=\"line\">Thread 6 Completed [0, 1, 2, 3, 4, 5, 6]</span><br><span class=\"line\">Thread 7 Completed [0, 1, 2, 3, 4, 5, 6, 7]</span><br><span class=\"line\">Thread 8 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8]</span><br><span class=\"line\">Thread 9 Completed [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>\n<p>从结果可以看出，运行结果可以看出，确实是先进先出类型的锁，同时也验证了没有俩个线程同时获取修改list的时机，因为如果同时修改List回抛出异常，这里没有。从侧面验证了锁的正确性</p>\n<h4 id=\"demo2\"><a href=\"#demo2\" class=\"headerlink\" title=\"demo2\"></a>demo2</h4><p>验证一下，在park之前多次调用unpark，是否会累加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LockSupportStudy2 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //在park之前不管有多少个unpark，都只能释放一个park</span><br><span class=\"line\">        LockSupport.unpark(Thread.currentThread());</span><br><span class=\"line\">        LockSupport.unpark(Thread.currentThread());</span><br><span class=\"line\">        System.out.println(&quot;暂停线程&quot;);</span><br><span class=\"line\">        LockSupport.park();</span><br><span class=\"line\">        System.out.println(&quot;线程继续&quot;);</span><br><span class=\"line\">        LockSupport.park();</span><br><span class=\"line\">        System.out.println(&quot;线程继续&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">暂停线程</span><br><span class=\"line\">线程继续</span><br><span class=\"line\">。。。。。</span><br></pre></td></tr></table></figure>\n<p>从实验结果可以看出，不管在park之前调用了多少次的unpark，只会唤醒一次相应的线程阻塞。</p>\n<p>另外这个实验可以看出park和unpark的先后顺序是不重要的，因此park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p>\n<h3 id=\"2-源码分析\"><a href=\"#2-源码分析\" class=\"headerlink\" title=\"2. 源码分析\"></a>2. 源码分析</h3><ol>\n<li>LockSupport中主要的两个成员变量：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">private static final sun.misc.Unsafe UNSAFE;</span><br><span class=\"line\">private static final long parkBlockerOffset;</span><br></pre></td></tr></table></figure>\n<p>unsafe:全名sun.misc.Unsafe可以直接操控内存，被JDK广泛用于自己的包中，如java.nio和java.util.concurrent。但是不建议在生产环境中使用这个类。因为这个API十分不安全、不轻便、而且不稳定。<br>LockSupport的方法底层都是调用Unsafe的方法实现。</p>\n<p>再来看parkBlockerOffset:<br>parkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static &#123;</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class=\"line\">           Class&lt;?&gt; tk = Thread.class;</span><br><span class=\"line\">           parkBlockerOffset = UNSAFE.objectFieldOffset</span><br><span class=\"line\">               (tk.getDeclaredField(&quot;parkBlocker&quot;));</span><br><span class=\"line\">       &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.</p>\n<p>JVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。</p>\n<p>为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？<br>仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。</p>\n<p>2.LockSupport的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static  Object getBlocker(Thread t)</span><br><span class=\"line\">public static  void park()</span><br><span class=\"line\">public static  void park(Object blocker)</span><br><span class=\"line\">public static  void parkNanos(long nanos)</span><br><span class=\"line\">public static  void parkNanos(Object blocker, long nanos)</span><br><span class=\"line\">public static  void parkUntil(long deadline)</span><br><span class=\"line\">public static  void parkUntil(Object blocker, long deadline)</span><br></pre></td></tr></table></figure>\n<p>可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void setBlocker(Thread t, Object arg) &#123;</span><br><span class=\"line\">       // Even though volatile, hotspot doesn&apos;t need a write barrier here.</span><br><span class=\"line\">       UNSAFE.putObject(t, parkBlockerOffset, arg);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>对给定线程t的parkBlocker赋值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Object getBlocker(Thread t) &#123;</span><br><span class=\"line\">    if (t == null)</span><br><span class=\"line\">        throw new NullPointerException();</span><br><span class=\"line\">    return UNSAFE.getObjectVolatile(t, parkBlockerOffset);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。</p>\n<p>接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法</p>\n<p><strong>阻塞线程</strong></p>\n<ul>\n<li>park()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void park() &#123;</span><br><span class=\"line\">        UNSAFE.park(false, 0L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用native方法阻塞当前线程。</p>\n<ul>\n<li>parkNanos(long nanos)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void parkNanos(long nanos) &#123;</span><br><span class=\"line\">        if (nanos &gt; 0)</span><br><span class=\"line\">            UNSAFE.park(false, nanos);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。</p>\n<ul>\n<li>parkUntil(long deadline)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void parkUntil(long deadline) &#123;</span><br><span class=\"line\">  UNSAFE.park(true, deadline);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>阻塞当前线程，知道deadline时间（deadline - 毫秒数）。</p>\n<p>JDK1.6引入这三个方法对应的拥有Blocker版本。</p>\n<ul>\n<li>park(Object blocker)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void park(Object blocker) &#123;</span><br><span class=\"line\">  Thread t = Thread.currentThread();</span><br><span class=\"line\">  setBlocker(t, blocker);</span><br><span class=\"line\">  UNSAFE.park(false, 0L);</span><br><span class=\"line\">  setBlocker(t, null);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1) 记录当前线程等待的对象（阻塞对象）；<br>2) 阻塞当前线程；<br>3) 当前线程等待对象置为null。</p>\n<ul>\n<li>parkNanos(Object blocker, long nanos)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void parkNanos(Object blocker, long nanos) &#123;</span><br><span class=\"line\">  if (nanos &gt; 0) &#123;</span><br><span class=\"line\">      Thread t = Thread.currentThread();</span><br><span class=\"line\">      setBlocker(t, blocker);</span><br><span class=\"line\">      UNSAFE.park(false, nanos);</span><br><span class=\"line\">      setBlocker(t, null);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。</p>\n<ul>\n<li>parkUntil(Object blocker, long deadline)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void parkUntil(Object blocker, long deadline) &#123;</span><br><span class=\"line\">  Thread t = Thread.currentThread();</span><br><span class=\"line\">  setBlocker(t, blocker);</span><br><span class=\"line\">  UNSAFE.park(true, deadline);</span><br><span class=\"line\">  setBlocker(t, null);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。</p>\n<p><strong>唤醒线程</strong></p>\n<ul>\n<li>unpark(Thread thread)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void unpark(Thread thread) &#123;</span><br><span class=\"line\">  if (thread != null)</span><br><span class=\"line\">      UNSAFE.unpark(thread);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>唤醒处于阻塞状态的线程Thread。</p>\n<h3 id=\"3-底层实现原理\"><a href=\"#3-底层实现原理\" class=\"headerlink\" title=\"3. 底层实现原理\"></a>3. 底层实现原理</h3><p>从LockSupport源码可以看出，park和unpark的实现都是调用Unsafe.park和Unsafe.unpark，因此只要找到这俩个的底层实现原理，就可以明白park和unpark的底层实现。</p>\n<h4 id=\"HotSpot-里-park-unpark-的实现\"><a href=\"#HotSpot-里-park-unpark-的实现\" class=\"headerlink\" title=\"HotSpot 里 park/unpark 的实现\"></a>HotSpot 里 park/unpark 的实现</h4><p>每个 java 线程都有一个 Parker 实例，Parker 类是这样定义的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Parker : public os::PlatformParker &#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">  volatile int _counter ;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">public:</span><br><span class=\"line\">  void park(bool isAbsolute, jlong time);</span><br><span class=\"line\">  void unpark();</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class PlatformParker : public CHeapObj&lt;mtInternal&gt; &#123;</span><br><span class=\"line\">  protected:</span><br><span class=\"line\">    pthread_mutex_t _mutex [1] ;</span><br><span class=\"line\">    pthread_cond_t  _cond  [1] ;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到 Parker 类实际上用 Posix 的 mutex，condition 来实现的。</p>\n<p>在 Parker 类里的_counter 字段，就是用来记录所谓的 “许可” 的。</p>\n<p>当调用 park 时，先尝试直接能否直接拿到 “许可”，即_counter&gt;0 时，如果成功，则把_counter 设置为 0, 并返回：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Parker::park(bool isAbsolute, jlong time) &#123;</span><br><span class=\"line\">  // Ideally we&apos;d do something useful while spinning, such</span><br><span class=\"line\">  // as calling unpackTime().</span><br><span class=\"line\">  // Optional fast-path check:</span><br><span class=\"line\">  // Return immediately if a permit is available.</span><br><span class=\"line\">  // We depend on Atomic::xchg() having full barrier semantics</span><br><span class=\"line\">  // since we are doing a lock-free update to _counter.</span><br><span class=\"line\">  if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;</span><br></pre></td></tr></table></figure>\n<p>如果不成功，则构造一个 ThreadBlockInVM，然后检查_counter 是不是 &gt; 0，如果是，则把_counter 设置为 0，unlock mutex 并返回：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadBlockInVM tbivm(jt);</span><br><span class=\"line\">if (_counter &gt; 0)  &#123; // no wait needed</span><br><span class=\"line\">  _counter = 0;</span><br><span class=\"line\">  status = pthread_mutex_unlock(_mutex);</span><br></pre></td></tr></table></figure>\n<p>否则，再判断等待的时间，然后再调用 pthread_cond_wait 函数等待，如果等待返回，则把_counter 设置为 0，unlock mutex 并返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (time == 0) &#123;</span><br><span class=\"line\">  status = pthread_cond_wait (_cond, _mutex) ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_counter = 0 ;</span><br><span class=\"line\">status = pthread_mutex_unlock(_mutex) ;</span><br><span class=\"line\">assert_status(status == 0, status, &quot;invariant&quot;) ;</span><br><span class=\"line\">OrderAccess::fence();</span><br></pre></td></tr></table></figure>\n<p>当 unpark 时，则简单多了，直接设置_counter 为 1，再 unlock mutext 返回。如果_counter 之前的值是 0，则还要调用 pthread_cond_signal 唤醒在 park 中等待的线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Parker::unpark() &#123;</span><br><span class=\"line\">  int s, status ;</span><br><span class=\"line\">  status = pthread_mutex_lock(_mutex);</span><br><span class=\"line\">  assert (status == 0, &quot;invariant&quot;) ;</span><br><span class=\"line\">  s = _counter;</span><br><span class=\"line\">  _counter = 1;</span><br><span class=\"line\">  if (s &lt; 1) &#123;</span><br><span class=\"line\">     if (WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class=\"line\">        status = pthread_cond_signal (_cond) ;</span><br><span class=\"line\">        assert (status == 0, &quot;invariant&quot;) ;</span><br><span class=\"line\">        status = pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">        assert (status == 0, &quot;invariant&quot;) ;</span><br><span class=\"line\">     &#125; else &#123;</span><br><span class=\"line\">        status = pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">        assert (status == 0, &quot;invariant&quot;) ;</span><br><span class=\"line\">        status = pthread_cond_signal (_cond) ;</span><br><span class=\"line\">        assert (status == 0, &quot;invariant&quot;) </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">    assert (status == 0, &quot;invariant&quot;) ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简而言之，是用 mutex 和 condition 保护了一个_counter 的变量，当 park 时，这个变量置为了 0，当 unpark 时，这个变量置为 1。</p>\n<p>值得注意的是在 park 函数里，调用 pthread_cond_wait 时，并没有用 while 来判断，所以 posix condition 里的 “Spurious wakeup” 一样会传递到上层 Java 的代码里，这也是官方为什么推介使用while方式的原因。</p>\n<p>关于 “Spurious wakeup”，参考这篇文章：<a href=\"https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups\" target=\"_blank\" rel=\"noopener\">Why does pthread_cond_wait have spurious wakeups?</a></p>\n<p>不过在看这篇文章之前，最好看看《Unix环境高级编程》这本书第11章节</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (time == 0) &#123;</span><br><span class=\"line\">  status = pthread_cond_wait (_cond, _mutex) ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这也就是为什么 Java dos 里提到，当下面三种情况下 park 函数会返回：</p>\n<ul>\n<li>Some other thread invokes unpark with the current thread as the target; or</li>\n<li>Some other thread interrupts the current thread; or</li>\n<li><strong>The call spuriously (that is, for no reason) returns.</strong></li>\n</ul>\n<p>相关的实现代码在：</p>\n<p><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp</a><br><a href=\"http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp\" target=\"_blank\" rel=\"noopener\">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cp</a></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000008420938\" target=\"_blank\" rel=\"noopener\">浅谈Java并发编程系列（八）—— LockSupport原理剖析</a></li>\n<li><a href=\"https://blog.csdn.net/hengyunabc/article/details/27969613\" target=\"_blank\" rel=\"noopener\">并行编程之条件变量（posix condition variables）</a></li>\n<li><a href=\"https://blog.csdn.net/hengyunabc/article/details/28126139\" target=\"_blank\" rel=\"noopener\">Java的LockSupport.park()实现分析</a></li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjqeq7wxe0000dq1ubjamoxj0","category_id":"cjqeq7wxn0004dq1uf8ovvh6o","_id":"cjqeq7wxt000adq1uwxgxrox6"},{"post_id":"cjqeq7wxk0002dq1u4gmeiox0","category_id":"cjqeq7wxr0007dq1upkx5i2ao","_id":"cjqeq7wxu000cdq1uv89cq8ya"},{"post_id":"cjqeq9az9000ddq1upsmaxhdd","category_id":"cjqeqa3dk000fdq1uape9qpu5","_id":"cjqeqa3dm000hdq1uu11o08sr"},{"post_id":"cjqeqk7n7000tdq1uvnzsvsmm","category_id":"cjqeqa3dk000fdq1uape9qpu5","_id":"cjqeqnnjp0001hj1ubwstq819"},{"post_id":"cjqeqhf2d000ndq1u36wra1c1","category_id":"cjqeqa3dk000fdq1uape9qpu5","_id":"cjqeqo8z30006hj1ulnoo2z2n"},{"post_id":"cjqeqpa02000dhj1uiuw5v4lm","category_id":"cjqeqa3dk000fdq1uape9qpu5","_id":"cjqeqr6nq000hhj1uklmmix96"},{"post_id":"cjqeqq73z000fhj1u6apip25u","category_id":"cjqeqa3dk000fdq1uape9qpu5","_id":"cjqeqsf3t000nhj1upb5wemyd"},{"post_id":"cjqeqpchi000ehj1u4xoaa6u8","category_id":"cjqeqa3dk000fdq1uape9qpu5","_id":"cjqeqswop000phj1ubecwpy0f"}],"PostTag":[{"post_id":"cjqeq7wxe0000dq1ubjamoxj0","tag_id":"cjqeq7wxp0005dq1u65vzc2sv","_id":"cjqeq7wxs0009dq1umbcuthtq"},{"post_id":"cjqeq7wxk0002dq1u4gmeiox0","tag_id":"cjqeq7wxs0008dq1udmtf4oib","_id":"cjqeq7wxt000bdq1uhjhsv52c"},{"post_id":"cjqeq9az9000ddq1upsmaxhdd","tag_id":"cjqeqa3dk000edq1usld2lo1c","_id":"cjqeqa3dn000jdq1ulj883dk0"},{"post_id":"cjqeq9az9000ddq1upsmaxhdd","tag_id":"cjqeqa3dl000gdq1ux3spjpos","_id":"cjqeqa3dn000kdq1ub7tn0aj2"},{"post_id":"cjqeq9az9000ddq1upsmaxhdd","tag_id":"cjqeqa3dm000idq1uqb9repct","_id":"cjqeqa3dn000ldq1u2sf7ch3l"},{"post_id":"cjqeqhf2d000ndq1u36wra1c1","tag_id":"cjqeqa3dk000edq1usld2lo1c","_id":"cjqeqhf2e000pdq1udoc0xx0a"},{"post_id":"cjqeqhf2d000ndq1u36wra1c1","tag_id":"cjqeqhf2e000odq1utp2ooxhv","_id":"cjqeqhf2e000qdq1un6xebuwx"},{"post_id":"cjqeqk7n7000tdq1uvnzsvsmm","tag_id":"cjqeqa3dk000edq1usld2lo1c","_id":"cjqeqnnjq0002hj1u5vddhg9a"},{"post_id":"cjqeqk7n7000tdq1uvnzsvsmm","tag_id":"cjqeqnnjo0000hj1uzgb85kk6","_id":"cjqeqnnjq0003hj1u9vbdf43k"},{"post_id":"cjqeqk7n7000tdq1uvnzsvsmm","tag_id":"cjqeqa3dl000gdq1ux3spjpos","_id":"cjqeqnnjq0004hj1uccrz9o0m"},{"post_id":"cjqeqhf2d000ndq1u36wra1c1","tag_id":"cjqeqo8z30005hj1u9tye9w80","_id":"cjqeqo8z40008hj1utngatnmo"},{"post_id":"cjqeqhf2d000ndq1u36wra1c1","tag_id":"cjqeqo8z40007hj1uhc3r1h4o","_id":"cjqeqo8z50009hj1urnv67n6a"},{"post_id":"cjqeqp9zx000ahj1ua8o3x402","tag_id":"cjqeqp9zz000bhj1ugxqejxg6","_id":"cjqeqpa00000chj1u9uvhh7td"},{"post_id":"cjqeqpa02000dhj1uiuw5v4lm","tag_id":"cjqeqp9zz000bhj1ugxqejxg6","_id":"cjqeqr6nq000jhj1uof2o5m00"},{"post_id":"cjqeqpa02000dhj1uiuw5v4lm","tag_id":"cjqeqr6nq000ghj1u86hwrxcq","_id":"cjqeqr6nq000khj1u0fsfrgwe"},{"post_id":"cjqeqpa02000dhj1uiuw5v4lm","tag_id":"cjqeqr6nq000ihj1u5rab0g83","_id":"cjqeqr6nr000lhj1uecciq4r0"},{"post_id":"cjqeqq73z000fhj1u6apip25u","tag_id":"cjqeqr6nq000ihj1u5rab0g83","_id":"cjqeqsf3s000mhj1u8g9nw97f"},{"post_id":"cjqeqpchi000ehj1u4xoaa6u8","tag_id":"cjqeqr6nq000ihj1u5rab0g83","_id":"cjqeqswoo000ohj1unx2y3z2b"}],"Tag":[{"name":"视屏","_id":"cjqeq7wxp0005dq1u65vzc2sv"},{"name":"博客建站","_id":"cjqeq7wxs0008dq1udmtf4oib"},{"name":"java","_id":"cjqeqa3dk000edq1usld2lo1c"},{"name":"String","_id":"cjqeqa3dl000gdq1ux3spjpos"},{"name":"java 基础","_id":"cjqeqa3dm000idq1uqb9repct"},{"name":"并发","_id":"cjqeqhf2e000odq1utp2ooxhv"},{"name":"java基础","_id":"cjqeqnnjo0000hj1uzgb85kk6"},{"name":"线程","_id":"cjqeqo8z30005hj1u9tye9w80"},{"name":"thread","_id":"cjqeqo8z40007hj1uhc3r1h4o"},{"name":"操作系统","_id":"cjqeqp9zz000bhj1ugxqejxg6"},{"name":"自旋锁","_id":"cjqeqr6nq000ghj1u86hwrxcq"},{"name":"JUC","_id":"cjqeqr6nq000ihj1u5rab0g83"}]}}